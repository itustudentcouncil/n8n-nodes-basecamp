// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/fleetengine/v1/vehicle_api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Viewport } from "../../../geo/type/viewport.js";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Int32Value } from "../../../protobuf/wrappers.js";
import { LatLng } from "../../../type/latlng.js";
import { TerminalLocation, TripType, tripTypeFromJSON, tripTypeToJSON, VehicleAttribute } from "./fleetengine.js";
import { RequestHeader } from "./header.js";
import {
  Vehicle,
  Vehicle_VehicleType,
  Vehicle_VehicleType_Category,
  vehicle_VehicleType_CategoryFromJSON,
  vehicle_VehicleType_CategoryToJSON,
  VehicleState,
  vehicleStateFromJSON,
  vehicleStateToJSON,
} from "./vehicles.js";

export const protobufPackage = "maps.fleetengine.v1";

/** `CreateVehicle` request message. */
export interface CreateVehicleRequest {
  /** The standard Fleet Engine request header. */
  header:
    | RequestHeader
    | undefined;
  /**
   * Required. Must be in the format `providers/{provider}`.
   * The provider must be the Project ID (for example, `sample-cloud-project`)
   * of the Google Cloud Project of which the service account making
   * this call is a member.
   */
  parent: string;
  /**
   * Required. Unique Vehicle ID.
   * Subject to the following restrictions:
   *
   * * Must be a valid Unicode string.
   * * Limited to a maximum length of 64 characters.
   * * Normalized according to [Unicode Normalization Form C]
   * (http://www.unicode.org/reports/tr15/).
   * * May not contain any of the following ASCII characters: '/', ':', '?',
   * ',', or '#'.
   */
  vehicleId: string;
  /**
   * Required. The Vehicle entity to create. When creating a Vehicle, the
   * following fields are required:
   *
   * * `vehicleState`
   * * `supportedTripTypes`
   * * `maximumCapacity`
   * * `vehicleType`
   *
   * When creating a Vehicle, the following fields are ignored:
   *
   * * `name`
   * * `currentTrips`
   * * `availableCapacity`
   * * `current_route_segment`
   * * `current_route_segment_end_point`
   * * `current_route_segment_version`
   * * `current_route_segment_traffic`
   * * `route`
   * * `waypoints`
   * * `waypoints_version`
   * * `remaining_distance_meters`
   * * `remaining_time_seconds`
   * * `eta_to_next_waypoint`
   * * `navigation_status`
   *
   * All other fields are optional and used if provided.
   */
  vehicle: Vehicle | undefined;
}

/** `GetVehicle` request message. */
export interface GetVehicleRequest {
  /** The standard Fleet Engine request header. */
  header:
    | RequestHeader
    | undefined;
  /**
   * Required. Must be in the format
   * `providers/{provider}/vehicles/{vehicle}`.
   * The provider must be the Project ID (for example, `sample-cloud-project`)
   * of the Google Cloud Project of which the service account making
   * this call is a member.
   */
  name: string;
  /**
   * Indicates the minimum timestamp (exclusive) for which
   * `Vehicle.current_route_segment` is retrieved.
   * If the route is unchanged since this timestamp, the `current_route_segment`
   * field is not set in the response. If a minimum is unspecified, the
   * `current_route_segment` is always retrieved.
   */
  currentRouteSegmentVersion:
    | Date
    | undefined;
  /**
   * Indicates the minimum timestamp (exclusive) for which `Vehicle.waypoints`
   * data is retrieved. If the waypoints are unchanged since this timestamp, the
   * `vehicle.waypoints` data is not set in the response. If this field is
   * unspecified, `vehicle.waypoints` is always retrieved.
   */
  waypointsVersion: Date | undefined;
}

/** `UpdateVehicle request message. */
export interface UpdateVehicleRequest {
  /** The standard Fleet Engine request header. */
  header:
    | RequestHeader
    | undefined;
  /**
   * Required. Must be in the format
   * `providers/{provider}/vehicles/{vehicle}`.
   * The {provider} must be the Project ID (for example, `sample-cloud-project`)
   * of the Google Cloud Project of which the service account making
   * this call is a member.
   */
  name: string;
  /**
   * Required. The `Vehicle` entity values to apply.  When updating a `Vehicle`,
   * the following fields may not be updated as they are managed by the
   * server.
   *
   * * `available_capacity`
   * * `current_route_segment_version`
   * * `current_trips`
   * * `name`
   * * `waypoints_version`
   *
   * If the `attributes` field is updated, **all** the vehicle's attributes are
   * replaced with the attributes provided in the request. If you want to update
   * only some attributes, see the `UpdateVehicleAttributes` method.
   *
   * Likewise, the `waypoints` field can be updated, but must contain all the
   * waypoints currently on the vehicle, and no other waypoints.
   */
  vehicle:
    | Vehicle
    | undefined;
  /**
   * Required. A field mask indicating which fields of the `Vehicle` to update.
   * At least one field name must be provided.
   */
  updateMask: string[] | undefined;
}

/** `UpdateVehicleAttributes` request message. */
export interface UpdateVehicleAttributesRequest {
  /** The standard Fleet Engine request header. */
  header:
    | RequestHeader
    | undefined;
  /**
   * Required. Must be in the format `providers/{provider}/vehicles/{vehicle}`.
   * The provider must be the Project ID (for example, `sample-cloud-project`)
   * of the Google Cloud Project of which the service account making
   * this call is a member.
   */
  name: string;
  /**
   * Required. The vehicle attributes to update. Unmentioned attributes are not
   * altered or removed.
   */
  attributes: VehicleAttribute[];
}

/** `UpdateVehicleAttributes` response message. */
export interface UpdateVehicleAttributesResponse {
  /**
   * Required. The updated full list of vehicle attributes, including new,
   * altered, and untouched attributes.
   */
  attributes: VehicleAttribute[];
}

/** `SearchVehicles` request message. */
export interface SearchVehiclesRequest {
  /** The standard Fleet Engine request header. */
  header:
    | RequestHeader
    | undefined;
  /**
   * Required. Must be in the format `providers/{provider}`.
   * The provider must be the Project ID (for example, `sample-cloud-project`)
   * of the Google Cloud Project of which the service account making
   * this call is a member.
   */
  parent: string;
  /** Required. The pickup point to search near. */
  pickupPoint:
    | TerminalLocation
    | undefined;
  /**
   * The customer's intended dropoff location. The field is required if
   * `trip_types` contains `TripType.SHARED`.
   */
  dropoffPoint:
    | TerminalLocation
    | undefined;
  /**
   * Required. Defines the vehicle search radius around the pickup point. Only
   * vehicles within the search radius will be returned. Value must be between
   * 400 and 10000 meters (inclusive).
   */
  pickupRadiusMeters: number;
  /**
   * Required. Specifies the maximum number of vehicles to return. The value
   * must be between 1 and 50 (inclusive).
   */
  count: number;
  /**
   * Required. Specifies the number of passengers being considered for a trip.
   * The value must be greater than or equal to one. The driver is not
   * considered in the capacity value.
   */
  minimumCapacity: number;
  /**
   * Required. Represents the type of proposed trip. Must include exactly one
   * type. `UNKNOWN_TRIP_TYPE` is not allowed. Restricts the search to only
   * those vehicles that can support that trip type.
   */
  tripTypes: TripType[];
  /**
   * Restricts the search to only those vehicles that have sent location updates
   * to Fleet Engine within the specified duration. Stationary vehicles still
   * transmitting their locations are not considered stale. If this field is not
   * set, the server uses five minutes as the default value.
   */
  maximumStaleness:
    | Duration
    | undefined;
  /**
   * Required. Restricts the search to vehicles with one of the specified types.
   * At least one vehicle type must be specified. VehicleTypes with a category
   * of `UNKNOWN` are not allowed.
   */
  vehicleTypes: Vehicle_VehicleType[];
  /**
   * Callers can form complex logical operations using any combination of the
   * `required_attributes`, `required_one_of_attributes`, and
   * `required_one_of_attribute_sets` fields.
   *
   * `required_attributes` is a list; `required_one_of_attributes` uses a
   * message which allows a list of lists. In combination, the two fields allow
   * the composition of this expression:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
   * ...)
   * AND
   * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
   * ...)
   * ```
   *
   * Restricts the search to only those vehicles with the specified attributes.
   * This field is a conjunction/AND operation. A max of 50 required_attributes
   * is allowed. This matches the maximum number of attributes allowed on a
   * vehicle.
   */
  requiredAttributes: VehicleAttribute[];
  /**
   * Restricts the search to only those vehicles with at least one of
   * the specified attributes in each `VehicleAttributeList`. Within each
   * list, a vehicle must match at least one of the attributes. This field is an
   * inclusive disjunction/OR operation in each `VehicleAttributeList` and a
   * conjunction/AND operation across the collection of `VehicleAttributeList`.
   */
  requiredOneOfAttributes: VehicleAttributeList[];
  /**
   * `required_one_of_attribute_sets` provides additional functionality.
   *
   * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
   * uses a message which allows a list of lists, allowing expressions such as
   * this one:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (
   *   (required_one_of_attribute_sets[0][0] AND
   *   required_one_of_attribute_sets[0][1] AND
   *   ...)
   *   OR
   *   (required_one_of_attribute_sets[1][0] AND
   *   required_one_of_attribute_sets[1][1] AND
   *   ...)
   * )
   * ```
   *
   * Restricts the search to only those vehicles with all the attributes in a
   * `VehicleAttributeList`. Within each list, a
   * vehicle must match all of the attributes. This field is a conjunction/AND
   * operation in each `VehicleAttributeList` and inclusive disjunction/OR
   * operation across the collection of `VehicleAttributeList`.
   */
  requiredOneOfAttributeSets: VehicleAttributeList[];
  /** Required. Specifies the desired ordering criterion for results. */
  orderBy: SearchVehiclesRequest_VehicleMatchOrder;
  /**
   * This indicates if vehicles with a single active trip are eligible for this
   * search. This field is only used when `current_trips_present` is
   * unspecified. When `current_trips_present` is unspecified  and  this field
   * is `false`, vehicles with assigned trips are excluded from the search
   * results. When `current_trips_present` is unspecified and this field is
   * `true`, search results can include vehicles with one active trip that has a
   * status of `ENROUTE_TO_DROPOFF`. When `current_trips_present` is specified,
   * this field cannot be set to true.
   *
   * The default value is `false`.
   */
  includeBackToBack: boolean;
  /** Indicates the trip associated with this `SearchVehicleRequest`. */
  tripId: string;
  /**
   * This indicates if vehicles with active trips are eligible for this search.
   * This must be set to something other than
   * `CURRENT_TRIPS_PRESENT_UNSPECIFIED` if `trip_type` includes `SHARED`.
   */
  currentTripsPresent: SearchVehiclesRequest_CurrentTripsPresent;
  /**
   * Optional. A filter query to apply when searching vehicles. See
   * http://aip.dev/160 for examples of the filter syntax.
   *
   * This field is designed to replace the `required_attributes`,
   * `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
   * If a non-empty value is specified here, the following fields must be empty:
   * `required_attributes`, `required_one_of_attributes`, and
   * `required_one_of_attributes_sets`.
   *
   * This filter functions as an AND clause with other constraints,
   * such as `minimum_capacity` or `vehicle_types`.
   *
   * Note that the only queries supported are on vehicle attributes (for
   * example, `attributes.<key> = <value>` or `attributes.<key1> = <value1> AND
   * attributes.<key2> = <value2>`). The maximum number of restrictions allowed
   * in a filter query is 50.
   *
   * Also, all attributes are stored as strings, so the only supported
   * comparisons against attributes are string comparisons. In order to compare
   * against number or boolean values, the values must be explicitly quoted to
   * be treated as strings (for example, `attributes.<key> = "10"` or
   * `attributes.<key> = "true"`).
   */
  filter: string;
}

/** Specifies the order of the vehicle matches in the response. */
export enum SearchVehiclesRequest_VehicleMatchOrder {
  /** UNKNOWN_VEHICLE_MATCH_ORDER - Default, used for unspecified or unrecognized vehicle matches order. */
  UNKNOWN_VEHICLE_MATCH_ORDER = 0,
  /** PICKUP_POINT_ETA - Ascending order by vehicle driving time to the pickup point. */
  PICKUP_POINT_ETA = 1,
  /** PICKUP_POINT_DISTANCE - Ascending order by vehicle driving distance to the pickup point. */
  PICKUP_POINT_DISTANCE = 2,
  /**
   * DROPOFF_POINT_ETA - Ascending order by vehicle driving time to the dropoff point. This order
   * can only be used if the dropoff point is specified in the request.
   */
  DROPOFF_POINT_ETA = 3,
  /**
   * PICKUP_POINT_STRAIGHT_DISTANCE - Ascending order by straight-line distance from the vehicle's last
   * reported location to the pickup point.
   */
  PICKUP_POINT_STRAIGHT_DISTANCE = 4,
  /**
   * COST - Ascending order by the configured match cost. Match cost is defined as a
   * weighted calculation between straight-line distance and ETA. Weights are
   * set with default values and can be modified per customer. Please contact
   * Google support if these weights need to be modified for your project.
   */
  COST = 5,
  UNRECOGNIZED = -1,
}

export function searchVehiclesRequest_VehicleMatchOrderFromJSON(object: any): SearchVehiclesRequest_VehicleMatchOrder {
  switch (object) {
    case 0:
    case "UNKNOWN_VEHICLE_MATCH_ORDER":
      return SearchVehiclesRequest_VehicleMatchOrder.UNKNOWN_VEHICLE_MATCH_ORDER;
    case 1:
    case "PICKUP_POINT_ETA":
      return SearchVehiclesRequest_VehicleMatchOrder.PICKUP_POINT_ETA;
    case 2:
    case "PICKUP_POINT_DISTANCE":
      return SearchVehiclesRequest_VehicleMatchOrder.PICKUP_POINT_DISTANCE;
    case 3:
    case "DROPOFF_POINT_ETA":
      return SearchVehiclesRequest_VehicleMatchOrder.DROPOFF_POINT_ETA;
    case 4:
    case "PICKUP_POINT_STRAIGHT_DISTANCE":
      return SearchVehiclesRequest_VehicleMatchOrder.PICKUP_POINT_STRAIGHT_DISTANCE;
    case 5:
    case "COST":
      return SearchVehiclesRequest_VehicleMatchOrder.COST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchVehiclesRequest_VehicleMatchOrder.UNRECOGNIZED;
  }
}

export function searchVehiclesRequest_VehicleMatchOrderToJSON(object: SearchVehiclesRequest_VehicleMatchOrder): string {
  switch (object) {
    case SearchVehiclesRequest_VehicleMatchOrder.UNKNOWN_VEHICLE_MATCH_ORDER:
      return "UNKNOWN_VEHICLE_MATCH_ORDER";
    case SearchVehiclesRequest_VehicleMatchOrder.PICKUP_POINT_ETA:
      return "PICKUP_POINT_ETA";
    case SearchVehiclesRequest_VehicleMatchOrder.PICKUP_POINT_DISTANCE:
      return "PICKUP_POINT_DISTANCE";
    case SearchVehiclesRequest_VehicleMatchOrder.DROPOFF_POINT_ETA:
      return "DROPOFF_POINT_ETA";
    case SearchVehiclesRequest_VehicleMatchOrder.PICKUP_POINT_STRAIGHT_DISTANCE:
      return "PICKUP_POINT_STRAIGHT_DISTANCE";
    case SearchVehiclesRequest_VehicleMatchOrder.COST:
      return "COST";
    case SearchVehiclesRequest_VehicleMatchOrder.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies the types of restrictions on a vehicle's current trips. */
export enum SearchVehiclesRequest_CurrentTripsPresent {
  /**
   * CURRENT_TRIPS_PRESENT_UNSPECIFIED - The availability of vehicles with trips present is governed by the
   * `include_back_to_back` field.
   */
  CURRENT_TRIPS_PRESENT_UNSPECIFIED = 0,
  /**
   * NONE - Vehicles without trips can appear in search results. When this value is
   * used, `include_back_to_back` cannot be `true`.
   */
  NONE = 1,
  /**
   * ANY - Vehicles with at most 5 current trips and 10 waypoints are included
   * in the search results. When this value is used, `include_back_to_back`
   * cannot be `true`.
   */
  ANY = 2,
  UNRECOGNIZED = -1,
}

export function searchVehiclesRequest_CurrentTripsPresentFromJSON(
  object: any,
): SearchVehiclesRequest_CurrentTripsPresent {
  switch (object) {
    case 0:
    case "CURRENT_TRIPS_PRESENT_UNSPECIFIED":
      return SearchVehiclesRequest_CurrentTripsPresent.CURRENT_TRIPS_PRESENT_UNSPECIFIED;
    case 1:
    case "NONE":
      return SearchVehiclesRequest_CurrentTripsPresent.NONE;
    case 2:
    case "ANY":
      return SearchVehiclesRequest_CurrentTripsPresent.ANY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchVehiclesRequest_CurrentTripsPresent.UNRECOGNIZED;
  }
}

export function searchVehiclesRequest_CurrentTripsPresentToJSON(
  object: SearchVehiclesRequest_CurrentTripsPresent,
): string {
  switch (object) {
    case SearchVehiclesRequest_CurrentTripsPresent.CURRENT_TRIPS_PRESENT_UNSPECIFIED:
      return "CURRENT_TRIPS_PRESENT_UNSPECIFIED";
    case SearchVehiclesRequest_CurrentTripsPresent.NONE:
      return "NONE";
    case SearchVehiclesRequest_CurrentTripsPresent.ANY:
      return "ANY";
    case SearchVehiclesRequest_CurrentTripsPresent.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** `SearchVehicles` response message. */
export interface SearchVehiclesResponse {
  /**
   * List of vehicles that match the `SearchVehiclesRequest` criteria, ordered
   * according to `SearchVehiclesRequest.order_by` field.
   */
  matches: VehicleMatch[];
}

/** `ListVehicles` request message. */
export interface ListVehiclesRequest {
  /** The standard Fleet Engine request header. */
  header:
    | RequestHeader
    | undefined;
  /**
   * Required. Must be in the format `providers/{provider}`.
   * The provider must be the Project ID (for example, `sample-cloud-project`)
   * of the Google Cloud Project of which the service account making
   * this call is a member.
   */
  parent: string;
  /**
   * The maximum number of vehicles to return.
   * Default value: 100.
   */
  pageSize: number;
  /**
   * The value of the `next_page_token` provided by a previous call to
   * `ListVehicles` so that you can paginate through groups of vehicles. The
   * value is undefined if the filter criteria of the request is not the same as
   * the filter criteria for the previous call to `ListVehicles`.
   */
  pageToken: string;
  /**
   * Specifies the required minimum capacity of the vehicle. All vehicles
   * returned will have a `maximum_capacity` greater than or equal to this
   * value. If set, must be greater or equal to 0.
   */
  minimumCapacity:
    | number
    | undefined;
  /**
   * Restricts the response to vehicles that support at least one of the
   * specified trip types.
   */
  tripTypes: TripType[];
  /**
   * Restricts the response to vehicles that have sent location updates to Fleet
   * Engine within the specified duration. Stationary vehicles still
   * transmitting their locations are not considered stale. If present, must be
   * a valid positive duration.
   */
  maximumStaleness:
    | Duration
    | undefined;
  /**
   * Required. Restricts the response to vehicles with one of the specified type
   * categories. `UNKNOWN` is not allowed.
   */
  vehicleTypeCategories: Vehicle_VehicleType_Category[];
  /**
   * Callers can form complex logical operations using any combination of the
   * `required_attributes`, `required_one_of_attributes`, and
   * `required_one_of_attribute_sets` fields.
   *
   * `required_attributes` is a list; `required_one_of_attributes` uses a
   * message which allows a list of lists. In combination, the two fields allow
   * the composition of this expression:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (required_one_of_attributes[0][0] OR required_one_of_attributes[0][1] OR
   * ...)
   * AND
   * (required_one_of_attributes[1][0] OR required_one_of_attributes[1][1] OR
   * ...)
   * ```
   *
   * Restricts the response to vehicles with the specified attributes. This
   * field is a conjunction/AND operation. A max of 50 required_attributes is
   * allowed. This matches the maximum number of attributes allowed on a
   * vehicle. Each repeated string should be of the format "key:value".
   */
  requiredAttributes: string[];
  /**
   * Restricts the response to vehicles with at least one of the specified
   * attributes in each `VehicleAttributeList`. Within each list, a vehicle must
   * match at least one of the attributes. This field is an inclusive
   * disjunction/OR operation in each `VehicleAttributeList` and a
   * conjunction/AND operation across the collection of `VehicleAttributeList`.
   * Each repeated string should be of the format
   * "key1:value1|key2:value2|key3:value3".
   */
  requiredOneOfAttributes: string[];
  /**
   * `required_one_of_attribute_sets` provides additional functionality.
   *
   * Similar to `required_one_of_attributes`, `required_one_of_attribute_sets`
   * uses a message which allows a list of lists, allowing expressions such as
   * this one:
   *
   * ```
   * (required_attributes[0] AND required_attributes[1] AND ...)
   * AND
   * (
   *   (required_one_of_attribute_sets[0][0] AND
   *   required_one_of_attribute_sets[0][1] AND
   *   ...)
   *   OR
   *   (required_one_of_attribute_sets[1][0] AND
   *   required_one_of_attribute_sets[1][1] AND
   *   ...)
   * )
   * ```
   *
   * Restricts the response to vehicles that match all the attributes in a
   * `VehicleAttributeList`. Within each list, a vehicle must match all of the
   * attributes. This field is a conjunction/AND operation in each
   * `VehicleAttributeList` and inclusive disjunction/OR operation across the
   * collection of `VehicleAttributeList`. Each repeated string should be of the
   * format "key1:value1|key2:value2|key3:value3".
   */
  requiredOneOfAttributeSets: string[];
  /** Restricts the response to vehicles that have this vehicle state. */
  vehicleState: VehicleState;
  /** Only return the vehicles with current trip(s). */
  onTripOnly: boolean;
  /**
   * Optional. A filter query to apply when listing vehicles. See
   * http://aip.dev/160 for examples of the filter syntax.
   *
   * This field is designed to replace the `required_attributes`,
   * `required_one_of_attributes`, and `required_one_of_attributes_sets` fields.
   * If a non-empty value is specified here, the following fields must be empty:
   * `required_attributes`, `required_one_of_attributes`, and
   * `required_one_of_attributes_sets`.
   *
   * This filter functions as an AND clause with other constraints,
   * such as `vehicle_state` or `on_trip_only`.
   *
   * Note that the only queries supported are on vehicle attributes (for
   * example, `attributes.<key> = <value>` or `attributes.<key1> = <value1> AND
   * attributes.<key2> = <value2>`). The maximum number of restrictions allowed
   * in a filter query is 50.
   *
   * Also, all attributes are stored as strings, so the only supported
   * comparisons against attributes are string comparisons. In order to compare
   * against number or boolean values, the values must be explicitly quoted to
   * be treated as strings (for example, `attributes.<key> = "10"` or
   * `attributes.<key> = "true"`).
   */
  filter: string;
  /**
   * Optional. A filter that limits the vehicles returned to those whose last
   * known location was in the rectangular area defined by the viewport.
   */
  viewport: Viewport | undefined;
}

/** `ListVehicles` response message. */
export interface ListVehiclesResponse {
  /**
   * Vehicles matching the criteria in the request.
   * The maximum number of vehicles returned is determined by the `page_size`
   * field in the request.
   */
  vehicles: Vehicle[];
  /**
   * Token to retrieve the next page of vehicles, or empty if there are no
   * more vehicles that meet the request criteria.
   */
  nextPageToken: string;
  /**
   * Required. Total number of vehicles matching the request criteria across all
   * pages.
   */
  totalSize: Long;
}

/**
 * Describes intermediate points along a route for a `VehicleMatch` in a
 * `SearchVehiclesResponse`. This concept is represented as a `TripWaypoint` in
 * all other endpoints.
 */
export interface Waypoint {
  /** The location of this waypoint. */
  latLng:
    | LatLng
    | undefined;
  /** The estimated time that the vehicle will arrive at this waypoint. */
  eta: Date | undefined;
}

/**
 * Contains the vehicle and related estimates for a vehicle that match the
 * points of active trips for the vehicle `SearchVehiclesRequest`.
 */
export interface VehicleMatch {
  /** Required. A vehicle that matches the request. */
  vehicle:
    | Vehicle
    | undefined;
  /**
   * The vehicle's driving ETA to the pickup point specified in the
   * request. An empty value indicates a failure in calculating ETA for the
   * vehicle.  If `SearchVehiclesRequest.include_back_to_back` was `true` and
   * this vehicle has an active trip, `vehicle_pickup_eta` includes the time
   * required to complete the current active trip.
   */
  vehiclePickupEta:
    | Date
    | undefined;
  /**
   * The distance from the Vehicle's current location to the pickup point
   * specified in the request, including any intermediate pickup or dropoff
   * points for existing trips. This distance comprises the calculated driving
   * (route) distance, plus the straight line distance between the navigation
   * end point and the requested pickup point. (The distance between the
   * navigation end point and the requested pickup point is typically small.) An
   * empty value indicates an error in calculating the distance.
   */
  vehiclePickupDistanceMeters:
    | number
    | undefined;
  /**
   * Required. The straight-line distance between the vehicle and the pickup
   * point specified in the request.
   */
  vehiclePickupStraightLineDistanceMeters:
    | number
    | undefined;
  /**
   * The complete vehicle's driving ETA to the drop off point specified in the
   * request. The ETA includes stopping at any waypoints before the
   * `dropoff_point` specified in the request. The value will only be populated
   * when a drop off point is specified in the request. An empty value indicates
   * an error calculating the ETA.
   */
  vehicleDropoffEta:
    | Date
    | undefined;
  /**
   * The vehicle's driving distance (in meters) from the pickup point
   * to the drop off point specified in the request. The distance is only
   * between the two points and does not include the vehicle location or any
   * other points that must be visited before the vehicle visits either the
   * pickup point or dropoff point. The value will only be populated when a
   * `dropoff_point` is specified in the request. An empty value indicates
   * a failure in calculating the distance from the pickup to
   * drop off point specified in the request.
   */
  vehiclePickupToDropoffDistanceMeters:
    | number
    | undefined;
  /**
   * Required. The trip type of the request that was used to calculate the ETA
   * to the pickup point.
   */
  tripType: TripType;
  /**
   * The ordered list of waypoints used to calculate the ETA. The list
   * includes vehicle location, the pickup points of active
   * trips for the vehicle, and the pickup points provided in the
   * request. An empty list indicates a failure in calculating ETA for the
   * vehicle.
   */
  vehicleTripsWaypoints: Waypoint[];
  /** Type of the vehicle match. */
  vehicleMatchType: VehicleMatch_VehicleMatchType;
  /** The order requested for sorting vehicle matches. */
  requestedOrderedBy: SearchVehiclesRequest_VehicleMatchOrder;
  /**
   * The actual order that was used for this vehicle. Normally this
   * will match the 'order_by' field from the request; however, in certain
   * circumstances such as an internal server error, a different method
   * may be used (such as `PICKUP_POINT_STRAIGHT_DISTANCE`).
   */
  orderedBy: SearchVehiclesRequest_VehicleMatchOrder;
}

/** Type of vehicle match. */
export enum VehicleMatch_VehicleMatchType {
  /** UNKNOWN - Unknown vehicle match type */
  UNKNOWN = 0,
  /**
   * EXCLUSIVE - The vehicle currently has no trip assigned to it and can proceed to the
   * pickup point.
   */
  EXCLUSIVE = 1,
  /**
   * BACK_TO_BACK - The vehicle is currently assigned to a trip, but can proceed to the
   * pickup point after completing the in-progress trip.  ETA and distance
   * calculations take the existing trip into account.
   */
  BACK_TO_BACK = 2,
  /** CARPOOL - The vehicle has sufficient capacity for a shared ride. */
  CARPOOL = 3,
  /**
   * CARPOOL_BACK_TO_BACK - The vehicle will finish its current, active trip before proceeding to the
   * pickup point.  ETA and distance calculations take the existing trip into
   * account.
   */
  CARPOOL_BACK_TO_BACK = 4,
  UNRECOGNIZED = -1,
}

export function vehicleMatch_VehicleMatchTypeFromJSON(object: any): VehicleMatch_VehicleMatchType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return VehicleMatch_VehicleMatchType.UNKNOWN;
    case 1:
    case "EXCLUSIVE":
      return VehicleMatch_VehicleMatchType.EXCLUSIVE;
    case 2:
    case "BACK_TO_BACK":
      return VehicleMatch_VehicleMatchType.BACK_TO_BACK;
    case 3:
    case "CARPOOL":
      return VehicleMatch_VehicleMatchType.CARPOOL;
    case 4:
    case "CARPOOL_BACK_TO_BACK":
      return VehicleMatch_VehicleMatchType.CARPOOL_BACK_TO_BACK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VehicleMatch_VehicleMatchType.UNRECOGNIZED;
  }
}

export function vehicleMatch_VehicleMatchTypeToJSON(object: VehicleMatch_VehicleMatchType): string {
  switch (object) {
    case VehicleMatch_VehicleMatchType.UNKNOWN:
      return "UNKNOWN";
    case VehicleMatch_VehicleMatchType.EXCLUSIVE:
      return "EXCLUSIVE";
    case VehicleMatch_VehicleMatchType.BACK_TO_BACK:
      return "BACK_TO_BACK";
    case VehicleMatch_VehicleMatchType.CARPOOL:
      return "CARPOOL";
    case VehicleMatch_VehicleMatchType.CARPOOL_BACK_TO_BACK:
      return "CARPOOL_BACK_TO_BACK";
    case VehicleMatch_VehicleMatchType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A list-of-lists datatype for vehicle attributes. */
export interface VehicleAttributeList {
  /** A list of attributes in this collection. */
  attributes: VehicleAttribute[];
}

function createBaseCreateVehicleRequest(): CreateVehicleRequest {
  return { header: undefined, parent: "", vehicleId: "", vehicle: undefined };
}

export const CreateVehicleRequest: MessageFns<CreateVehicleRequest> = {
  encode(message: CreateVehicleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(26).string(message.parent);
    }
    if (message.vehicleId !== "") {
      writer.uint32(34).string(message.vehicleId);
    }
    if (message.vehicle !== undefined) {
      Vehicle.encode(message.vehicle, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVehicleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVehicleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = RequestHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.vehicleId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.vehicle = Vehicle.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVehicleRequest {
    return {
      header: isSet(object.header) ? RequestHeader.fromJSON(object.header) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      vehicleId: isSet(object.vehicleId) ? globalThis.String(object.vehicleId) : "",
      vehicle: isSet(object.vehicle) ? Vehicle.fromJSON(object.vehicle) : undefined,
    };
  },

  toJSON(message: CreateVehicleRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = RequestHeader.toJSON(message.header);
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.vehicleId !== "") {
      obj.vehicleId = message.vehicleId;
    }
    if (message.vehicle !== undefined) {
      obj.vehicle = Vehicle.toJSON(message.vehicle);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateVehicleRequest>): CreateVehicleRequest {
    return CreateVehicleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateVehicleRequest>): CreateVehicleRequest {
    const message = createBaseCreateVehicleRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? RequestHeader.fromPartial(object.header)
      : undefined;
    message.parent = object.parent ?? "";
    message.vehicleId = object.vehicleId ?? "";
    message.vehicle = (object.vehicle !== undefined && object.vehicle !== null)
      ? Vehicle.fromPartial(object.vehicle)
      : undefined;
    return message;
  },
};

function createBaseGetVehicleRequest(): GetVehicleRequest {
  return { header: undefined, name: "", currentRouteSegmentVersion: undefined, waypointsVersion: undefined };
}

export const GetVehicleRequest: MessageFns<GetVehicleRequest> = {
  encode(message: GetVehicleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.currentRouteSegmentVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.currentRouteSegmentVersion), writer.uint32(34).fork()).join();
    }
    if (message.waypointsVersion !== undefined) {
      Timestamp.encode(toTimestamp(message.waypointsVersion), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVehicleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVehicleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = RequestHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currentRouteSegmentVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.waypointsVersion = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVehicleRequest {
    return {
      header: isSet(object.header) ? RequestHeader.fromJSON(object.header) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      currentRouteSegmentVersion: isSet(object.currentRouteSegmentVersion)
        ? fromJsonTimestamp(object.currentRouteSegmentVersion)
        : undefined,
      waypointsVersion: isSet(object.waypointsVersion) ? fromJsonTimestamp(object.waypointsVersion) : undefined,
    };
  },

  toJSON(message: GetVehicleRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = RequestHeader.toJSON(message.header);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.currentRouteSegmentVersion !== undefined) {
      obj.currentRouteSegmentVersion = message.currentRouteSegmentVersion.toISOString();
    }
    if (message.waypointsVersion !== undefined) {
      obj.waypointsVersion = message.waypointsVersion.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<GetVehicleRequest>): GetVehicleRequest {
    return GetVehicleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVehicleRequest>): GetVehicleRequest {
    const message = createBaseGetVehicleRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? RequestHeader.fromPartial(object.header)
      : undefined;
    message.name = object.name ?? "";
    message.currentRouteSegmentVersion = object.currentRouteSegmentVersion ?? undefined;
    message.waypointsVersion = object.waypointsVersion ?? undefined;
    return message;
  },
};

function createBaseUpdateVehicleRequest(): UpdateVehicleRequest {
  return { header: undefined, name: "", vehicle: undefined, updateMask: undefined };
}

export const UpdateVehicleRequest: MessageFns<UpdateVehicleRequest> = {
  encode(message: UpdateVehicleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.vehicle !== undefined) {
      Vehicle.encode(message.vehicle, writer.uint32(34).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVehicleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVehicleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = RequestHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.vehicle = Vehicle.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateVehicleRequest {
    return {
      header: isSet(object.header) ? RequestHeader.fromJSON(object.header) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      vehicle: isSet(object.vehicle) ? Vehicle.fromJSON(object.vehicle) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateVehicleRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = RequestHeader.toJSON(message.header);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.vehicle !== undefined) {
      obj.vehicle = Vehicle.toJSON(message.vehicle);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateVehicleRequest>): UpdateVehicleRequest {
    return UpdateVehicleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateVehicleRequest>): UpdateVehicleRequest {
    const message = createBaseUpdateVehicleRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? RequestHeader.fromPartial(object.header)
      : undefined;
    message.name = object.name ?? "";
    message.vehicle = (object.vehicle !== undefined && object.vehicle !== null)
      ? Vehicle.fromPartial(object.vehicle)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseUpdateVehicleAttributesRequest(): UpdateVehicleAttributesRequest {
  return { header: undefined, name: "", attributes: [] };
}

export const UpdateVehicleAttributesRequest: MessageFns<UpdateVehicleAttributesRequest> = {
  encode(message: UpdateVehicleAttributesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    for (const v of message.attributes) {
      VehicleAttribute.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVehicleAttributesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVehicleAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = RequestHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.attributes.push(VehicleAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateVehicleAttributesRequest {
    return {
      header: isSet(object.header) ? RequestHeader.fromJSON(object.header) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => VehicleAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateVehicleAttributesRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = RequestHeader.toJSON(message.header);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => VehicleAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateVehicleAttributesRequest>): UpdateVehicleAttributesRequest {
    return UpdateVehicleAttributesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateVehicleAttributesRequest>): UpdateVehicleAttributesRequest {
    const message = createBaseUpdateVehicleAttributesRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? RequestHeader.fromPartial(object.header)
      : undefined;
    message.name = object.name ?? "";
    message.attributes = object.attributes?.map((e) => VehicleAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateVehicleAttributesResponse(): UpdateVehicleAttributesResponse {
  return { attributes: [] };
}

export const UpdateVehicleAttributesResponse: MessageFns<UpdateVehicleAttributesResponse> = {
  encode(message: UpdateVehicleAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attributes) {
      VehicleAttribute.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVehicleAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVehicleAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributes.push(VehicleAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateVehicleAttributesResponse {
    return {
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => VehicleAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateVehicleAttributesResponse): unknown {
    const obj: any = {};
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => VehicleAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateVehicleAttributesResponse>): UpdateVehicleAttributesResponse {
    return UpdateVehicleAttributesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateVehicleAttributesResponse>): UpdateVehicleAttributesResponse {
    const message = createBaseUpdateVehicleAttributesResponse();
    message.attributes = object.attributes?.map((e) => VehicleAttribute.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchVehiclesRequest(): SearchVehiclesRequest {
  return {
    header: undefined,
    parent: "",
    pickupPoint: undefined,
    dropoffPoint: undefined,
    pickupRadiusMeters: 0,
    count: 0,
    minimumCapacity: 0,
    tripTypes: [],
    maximumStaleness: undefined,
    vehicleTypes: [],
    requiredAttributes: [],
    requiredOneOfAttributes: [],
    requiredOneOfAttributeSets: [],
    orderBy: 0,
    includeBackToBack: false,
    tripId: "",
    currentTripsPresent: 0,
    filter: "",
  };
}

export const SearchVehiclesRequest: MessageFns<SearchVehiclesRequest> = {
  encode(message: SearchVehiclesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(26).string(message.parent);
    }
    if (message.pickupPoint !== undefined) {
      TerminalLocation.encode(message.pickupPoint, writer.uint32(34).fork()).join();
    }
    if (message.dropoffPoint !== undefined) {
      TerminalLocation.encode(message.dropoffPoint, writer.uint32(42).fork()).join();
    }
    if (message.pickupRadiusMeters !== 0) {
      writer.uint32(48).int32(message.pickupRadiusMeters);
    }
    if (message.count !== 0) {
      writer.uint32(56).int32(message.count);
    }
    if (message.minimumCapacity !== 0) {
      writer.uint32(64).int32(message.minimumCapacity);
    }
    writer.uint32(74).fork();
    for (const v of message.tripTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.maximumStaleness !== undefined) {
      Duration.encode(message.maximumStaleness, writer.uint32(82).fork()).join();
    }
    for (const v of message.vehicleTypes) {
      Vehicle_VehicleType.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.requiredAttributes) {
      VehicleAttribute.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.requiredOneOfAttributes) {
      VehicleAttributeList.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.requiredOneOfAttributeSets) {
      VehicleAttributeList.encode(v!, writer.uint32(162).fork()).join();
    }
    if (message.orderBy !== 0) {
      writer.uint32(104).int32(message.orderBy);
    }
    if (message.includeBackToBack !== false) {
      writer.uint32(144).bool(message.includeBackToBack);
    }
    if (message.tripId !== "") {
      writer.uint32(154).string(message.tripId);
    }
    if (message.currentTripsPresent !== 0) {
      writer.uint32(168).int32(message.currentTripsPresent);
    }
    if (message.filter !== "") {
      writer.uint32(178).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchVehiclesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchVehiclesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = RequestHeader.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pickupPoint = TerminalLocation.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dropoffPoint = TerminalLocation.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.pickupRadiusMeters = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.count = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.minimumCapacity = reader.int32();
          continue;
        case 9:
          if (tag === 72) {
            message.tripTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.tripTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.maximumStaleness = Duration.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.vehicleTypes.push(Vehicle_VehicleType.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.requiredAttributes.push(VehicleAttribute.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.requiredOneOfAttributes.push(VehicleAttributeList.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.requiredOneOfAttributeSets.push(VehicleAttributeList.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.orderBy = reader.int32() as any;
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.includeBackToBack = reader.bool();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.tripId = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.currentTripsPresent = reader.int32() as any;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchVehiclesRequest {
    return {
      header: isSet(object.header) ? RequestHeader.fromJSON(object.header) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pickupPoint: isSet(object.pickupPoint) ? TerminalLocation.fromJSON(object.pickupPoint) : undefined,
      dropoffPoint: isSet(object.dropoffPoint) ? TerminalLocation.fromJSON(object.dropoffPoint) : undefined,
      pickupRadiusMeters: isSet(object.pickupRadiusMeters) ? globalThis.Number(object.pickupRadiusMeters) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      minimumCapacity: isSet(object.minimumCapacity) ? globalThis.Number(object.minimumCapacity) : 0,
      tripTypes: globalThis.Array.isArray(object?.tripTypes)
        ? object.tripTypes.map((e: any) => tripTypeFromJSON(e))
        : [],
      maximumStaleness: isSet(object.maximumStaleness) ? Duration.fromJSON(object.maximumStaleness) : undefined,
      vehicleTypes: globalThis.Array.isArray(object?.vehicleTypes)
        ? object.vehicleTypes.map((e: any) => Vehicle_VehicleType.fromJSON(e))
        : [],
      requiredAttributes: globalThis.Array.isArray(object?.requiredAttributes)
        ? object.requiredAttributes.map((e: any) => VehicleAttribute.fromJSON(e))
        : [],
      requiredOneOfAttributes: globalThis.Array.isArray(object?.requiredOneOfAttributes)
        ? object.requiredOneOfAttributes.map((e: any) => VehicleAttributeList.fromJSON(e))
        : [],
      requiredOneOfAttributeSets: globalThis.Array.isArray(object?.requiredOneOfAttributeSets)
        ? object.requiredOneOfAttributeSets.map((e: any) => VehicleAttributeList.fromJSON(e))
        : [],
      orderBy: isSet(object.orderBy) ? searchVehiclesRequest_VehicleMatchOrderFromJSON(object.orderBy) : 0,
      includeBackToBack: isSet(object.includeBackToBack) ? globalThis.Boolean(object.includeBackToBack) : false,
      tripId: isSet(object.tripId) ? globalThis.String(object.tripId) : "",
      currentTripsPresent: isSet(object.currentTripsPresent)
        ? searchVehiclesRequest_CurrentTripsPresentFromJSON(object.currentTripsPresent)
        : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: SearchVehiclesRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = RequestHeader.toJSON(message.header);
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pickupPoint !== undefined) {
      obj.pickupPoint = TerminalLocation.toJSON(message.pickupPoint);
    }
    if (message.dropoffPoint !== undefined) {
      obj.dropoffPoint = TerminalLocation.toJSON(message.dropoffPoint);
    }
    if (message.pickupRadiusMeters !== 0) {
      obj.pickupRadiusMeters = Math.round(message.pickupRadiusMeters);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.minimumCapacity !== 0) {
      obj.minimumCapacity = Math.round(message.minimumCapacity);
    }
    if (message.tripTypes?.length) {
      obj.tripTypes = message.tripTypes.map((e) => tripTypeToJSON(e));
    }
    if (message.maximumStaleness !== undefined) {
      obj.maximumStaleness = Duration.toJSON(message.maximumStaleness);
    }
    if (message.vehicleTypes?.length) {
      obj.vehicleTypes = message.vehicleTypes.map((e) => Vehicle_VehicleType.toJSON(e));
    }
    if (message.requiredAttributes?.length) {
      obj.requiredAttributes = message.requiredAttributes.map((e) => VehicleAttribute.toJSON(e));
    }
    if (message.requiredOneOfAttributes?.length) {
      obj.requiredOneOfAttributes = message.requiredOneOfAttributes.map((e) => VehicleAttributeList.toJSON(e));
    }
    if (message.requiredOneOfAttributeSets?.length) {
      obj.requiredOneOfAttributeSets = message.requiredOneOfAttributeSets.map((e) => VehicleAttributeList.toJSON(e));
    }
    if (message.orderBy !== 0) {
      obj.orderBy = searchVehiclesRequest_VehicleMatchOrderToJSON(message.orderBy);
    }
    if (message.includeBackToBack !== false) {
      obj.includeBackToBack = message.includeBackToBack;
    }
    if (message.tripId !== "") {
      obj.tripId = message.tripId;
    }
    if (message.currentTripsPresent !== 0) {
      obj.currentTripsPresent = searchVehiclesRequest_CurrentTripsPresentToJSON(message.currentTripsPresent);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchVehiclesRequest>): SearchVehiclesRequest {
    return SearchVehiclesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchVehiclesRequest>): SearchVehiclesRequest {
    const message = createBaseSearchVehiclesRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? RequestHeader.fromPartial(object.header)
      : undefined;
    message.parent = object.parent ?? "";
    message.pickupPoint = (object.pickupPoint !== undefined && object.pickupPoint !== null)
      ? TerminalLocation.fromPartial(object.pickupPoint)
      : undefined;
    message.dropoffPoint = (object.dropoffPoint !== undefined && object.dropoffPoint !== null)
      ? TerminalLocation.fromPartial(object.dropoffPoint)
      : undefined;
    message.pickupRadiusMeters = object.pickupRadiusMeters ?? 0;
    message.count = object.count ?? 0;
    message.minimumCapacity = object.minimumCapacity ?? 0;
    message.tripTypes = object.tripTypes?.map((e) => e) || [];
    message.maximumStaleness = (object.maximumStaleness !== undefined && object.maximumStaleness !== null)
      ? Duration.fromPartial(object.maximumStaleness)
      : undefined;
    message.vehicleTypes = object.vehicleTypes?.map((e) => Vehicle_VehicleType.fromPartial(e)) || [];
    message.requiredAttributes = object.requiredAttributes?.map((e) => VehicleAttribute.fromPartial(e)) || [];
    message.requiredOneOfAttributes = object.requiredOneOfAttributes?.map((e) => VehicleAttributeList.fromPartial(e)) ||
      [];
    message.requiredOneOfAttributeSets =
      object.requiredOneOfAttributeSets?.map((e) => VehicleAttributeList.fromPartial(e)) || [];
    message.orderBy = object.orderBy ?? 0;
    message.includeBackToBack = object.includeBackToBack ?? false;
    message.tripId = object.tripId ?? "";
    message.currentTripsPresent = object.currentTripsPresent ?? 0;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseSearchVehiclesResponse(): SearchVehiclesResponse {
  return { matches: [] };
}

export const SearchVehiclesResponse: MessageFns<SearchVehiclesResponse> = {
  encode(message: SearchVehiclesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      VehicleMatch.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchVehiclesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchVehiclesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.matches.push(VehicleMatch.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchVehiclesResponse {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => VehicleMatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchVehiclesResponse): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => VehicleMatch.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchVehiclesResponse>): SearchVehiclesResponse {
    return SearchVehiclesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchVehiclesResponse>): SearchVehiclesResponse {
    const message = createBaseSearchVehiclesResponse();
    message.matches = object.matches?.map((e) => VehicleMatch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListVehiclesRequest(): ListVehiclesRequest {
  return {
    header: undefined,
    parent: "",
    pageSize: 0,
    pageToken: "",
    minimumCapacity: undefined,
    tripTypes: [],
    maximumStaleness: undefined,
    vehicleTypeCategories: [],
    requiredAttributes: [],
    requiredOneOfAttributes: [],
    requiredOneOfAttributeSets: [],
    vehicleState: 0,
    onTripOnly: false,
    filter: "",
    viewport: undefined,
  };
}

export const ListVehiclesRequest: MessageFns<ListVehiclesRequest> = {
  encode(message: ListVehiclesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      RequestHeader.encode(message.header, writer.uint32(98).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.minimumCapacity !== undefined) {
      Int32Value.encode({ value: message.minimumCapacity! }, writer.uint32(50).fork()).join();
    }
    writer.uint32(58).fork();
    for (const v of message.tripTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.maximumStaleness !== undefined) {
      Duration.encode(message.maximumStaleness, writer.uint32(66).fork()).join();
    }
    writer.uint32(74).fork();
    for (const v of message.vehicleTypeCategories) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.requiredAttributes) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.requiredOneOfAttributes) {
      writer.uint32(106).string(v!);
    }
    for (const v of message.requiredOneOfAttributeSets) {
      writer.uint32(122).string(v!);
    }
    if (message.vehicleState !== 0) {
      writer.uint32(88).int32(message.vehicleState);
    }
    if (message.onTripOnly !== false) {
      writer.uint32(112).bool(message.onTripOnly);
    }
    if (message.filter !== "") {
      writer.uint32(130).string(message.filter);
    }
    if (message.viewport !== undefined) {
      Viewport.encode(message.viewport, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVehiclesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVehiclesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 12:
          if (tag !== 98) {
            break;
          }

          message.header = RequestHeader.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.minimumCapacity = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag === 56) {
            message.tripTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.tripTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.maximumStaleness = Duration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag === 72) {
            message.vehicleTypeCategories.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vehicleTypeCategories.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.requiredAttributes.push(reader.string());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.requiredOneOfAttributes.push(reader.string());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.requiredOneOfAttributeSets.push(reader.string());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.vehicleState = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.onTripOnly = reader.bool();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.viewport = Viewport.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVehiclesRequest {
    return {
      header: isSet(object.header) ? RequestHeader.fromJSON(object.header) : undefined,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      minimumCapacity: isSet(object.minimumCapacity) ? Number(object.minimumCapacity) : undefined,
      tripTypes: globalThis.Array.isArray(object?.tripTypes)
        ? object.tripTypes.map((e: any) => tripTypeFromJSON(e))
        : [],
      maximumStaleness: isSet(object.maximumStaleness) ? Duration.fromJSON(object.maximumStaleness) : undefined,
      vehicleTypeCategories: globalThis.Array.isArray(object?.vehicleTypeCategories)
        ? object.vehicleTypeCategories.map((e: any) => vehicle_VehicleType_CategoryFromJSON(e))
        : [],
      requiredAttributes: globalThis.Array.isArray(object?.requiredAttributes)
        ? object.requiredAttributes.map((e: any) => globalThis.String(e))
        : [],
      requiredOneOfAttributes: globalThis.Array.isArray(object?.requiredOneOfAttributes)
        ? object.requiredOneOfAttributes.map((e: any) => globalThis.String(e))
        : [],
      requiredOneOfAttributeSets: globalThis.Array.isArray(object?.requiredOneOfAttributeSets)
        ? object.requiredOneOfAttributeSets.map((e: any) => globalThis.String(e))
        : [],
      vehicleState: isSet(object.vehicleState) ? vehicleStateFromJSON(object.vehicleState) : 0,
      onTripOnly: isSet(object.onTripOnly) ? globalThis.Boolean(object.onTripOnly) : false,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      viewport: isSet(object.viewport) ? Viewport.fromJSON(object.viewport) : undefined,
    };
  },

  toJSON(message: ListVehiclesRequest): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = RequestHeader.toJSON(message.header);
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.minimumCapacity !== undefined) {
      obj.minimumCapacity = message.minimumCapacity;
    }
    if (message.tripTypes?.length) {
      obj.tripTypes = message.tripTypes.map((e) => tripTypeToJSON(e));
    }
    if (message.maximumStaleness !== undefined) {
      obj.maximumStaleness = Duration.toJSON(message.maximumStaleness);
    }
    if (message.vehicleTypeCategories?.length) {
      obj.vehicleTypeCategories = message.vehicleTypeCategories.map((e) => vehicle_VehicleType_CategoryToJSON(e));
    }
    if (message.requiredAttributes?.length) {
      obj.requiredAttributes = message.requiredAttributes;
    }
    if (message.requiredOneOfAttributes?.length) {
      obj.requiredOneOfAttributes = message.requiredOneOfAttributes;
    }
    if (message.requiredOneOfAttributeSets?.length) {
      obj.requiredOneOfAttributeSets = message.requiredOneOfAttributeSets;
    }
    if (message.vehicleState !== 0) {
      obj.vehicleState = vehicleStateToJSON(message.vehicleState);
    }
    if (message.onTripOnly !== false) {
      obj.onTripOnly = message.onTripOnly;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.viewport !== undefined) {
      obj.viewport = Viewport.toJSON(message.viewport);
    }
    return obj;
  },

  create(base?: DeepPartial<ListVehiclesRequest>): ListVehiclesRequest {
    return ListVehiclesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVehiclesRequest>): ListVehiclesRequest {
    const message = createBaseListVehiclesRequest();
    message.header = (object.header !== undefined && object.header !== null)
      ? RequestHeader.fromPartial(object.header)
      : undefined;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.minimumCapacity = object.minimumCapacity ?? undefined;
    message.tripTypes = object.tripTypes?.map((e) => e) || [];
    message.maximumStaleness = (object.maximumStaleness !== undefined && object.maximumStaleness !== null)
      ? Duration.fromPartial(object.maximumStaleness)
      : undefined;
    message.vehicleTypeCategories = object.vehicleTypeCategories?.map((e) => e) || [];
    message.requiredAttributes = object.requiredAttributes?.map((e) => e) || [];
    message.requiredOneOfAttributes = object.requiredOneOfAttributes?.map((e) => e) || [];
    message.requiredOneOfAttributeSets = object.requiredOneOfAttributeSets?.map((e) => e) || [];
    message.vehicleState = object.vehicleState ?? 0;
    message.onTripOnly = object.onTripOnly ?? false;
    message.filter = object.filter ?? "";
    message.viewport = (object.viewport !== undefined && object.viewport !== null)
      ? Viewport.fromPartial(object.viewport)
      : undefined;
    return message;
  },
};

function createBaseListVehiclesResponse(): ListVehiclesResponse {
  return { vehicles: [], nextPageToken: "", totalSize: Long.ZERO };
}

export const ListVehiclesResponse: MessageFns<ListVehiclesResponse> = {
  encode(message: ListVehiclesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.vehicles) {
      Vehicle.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (!message.totalSize.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.totalSize.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVehiclesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVehiclesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vehicles.push(Vehicle.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVehiclesResponse {
    return {
      vehicles: globalThis.Array.isArray(object?.vehicles) ? object.vehicles.map((e: any) => Vehicle.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? Long.fromValue(object.totalSize) : Long.ZERO,
    };
  },

  toJSON(message: ListVehiclesResponse): unknown {
    const obj: any = {};
    if (message.vehicles?.length) {
      obj.vehicles = message.vehicles.map((e) => Vehicle.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (!message.totalSize.equals(Long.ZERO)) {
      obj.totalSize = (message.totalSize || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListVehiclesResponse>): ListVehiclesResponse {
    return ListVehiclesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVehiclesResponse>): ListVehiclesResponse {
    const message = createBaseListVehiclesResponse();
    message.vehicles = object.vehicles?.map((e) => Vehicle.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = (object.totalSize !== undefined && object.totalSize !== null)
      ? Long.fromValue(object.totalSize)
      : Long.ZERO;
    return message;
  },
};

function createBaseWaypoint(): Waypoint {
  return { latLng: undefined, eta: undefined };
}

export const Waypoint: MessageFns<Waypoint> = {
  encode(message: Waypoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.latLng !== undefined) {
      LatLng.encode(message.latLng, writer.uint32(10).fork()).join();
    }
    if (message.eta !== undefined) {
      Timestamp.encode(toTimestamp(message.eta), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Waypoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaypoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.latLng = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eta = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Waypoint {
    return {
      latLng: isSet(object.latLng) ? LatLng.fromJSON(object.latLng) : undefined,
      eta: isSet(object.eta) ? fromJsonTimestamp(object.eta) : undefined,
    };
  },

  toJSON(message: Waypoint): unknown {
    const obj: any = {};
    if (message.latLng !== undefined) {
      obj.latLng = LatLng.toJSON(message.latLng);
    }
    if (message.eta !== undefined) {
      obj.eta = message.eta.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Waypoint>): Waypoint {
    return Waypoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Waypoint>): Waypoint {
    const message = createBaseWaypoint();
    message.latLng = (object.latLng !== undefined && object.latLng !== null)
      ? LatLng.fromPartial(object.latLng)
      : undefined;
    message.eta = object.eta ?? undefined;
    return message;
  },
};

function createBaseVehicleMatch(): VehicleMatch {
  return {
    vehicle: undefined,
    vehiclePickupEta: undefined,
    vehiclePickupDistanceMeters: undefined,
    vehiclePickupStraightLineDistanceMeters: undefined,
    vehicleDropoffEta: undefined,
    vehiclePickupToDropoffDistanceMeters: undefined,
    tripType: 0,
    vehicleTripsWaypoints: [],
    vehicleMatchType: 0,
    requestedOrderedBy: 0,
    orderedBy: 0,
  };
}

export const VehicleMatch: MessageFns<VehicleMatch> = {
  encode(message: VehicleMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vehicle !== undefined) {
      Vehicle.encode(message.vehicle, writer.uint32(10).fork()).join();
    }
    if (message.vehiclePickupEta !== undefined) {
      Timestamp.encode(toTimestamp(message.vehiclePickupEta), writer.uint32(18).fork()).join();
    }
    if (message.vehiclePickupDistanceMeters !== undefined) {
      Int32Value.encode({ value: message.vehiclePickupDistanceMeters! }, writer.uint32(26).fork()).join();
    }
    if (message.vehiclePickupStraightLineDistanceMeters !== undefined) {
      Int32Value.encode({ value: message.vehiclePickupStraightLineDistanceMeters! }, writer.uint32(90).fork()).join();
    }
    if (message.vehicleDropoffEta !== undefined) {
      Timestamp.encode(toTimestamp(message.vehicleDropoffEta), writer.uint32(34).fork()).join();
    }
    if (message.vehiclePickupToDropoffDistanceMeters !== undefined) {
      Int32Value.encode({ value: message.vehiclePickupToDropoffDistanceMeters! }, writer.uint32(42).fork()).join();
    }
    if (message.tripType !== 0) {
      writer.uint32(48).int32(message.tripType);
    }
    for (const v of message.vehicleTripsWaypoints) {
      Waypoint.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.vehicleMatchType !== 0) {
      writer.uint32(64).int32(message.vehicleMatchType);
    }
    if (message.requestedOrderedBy !== 0) {
      writer.uint32(72).int32(message.requestedOrderedBy);
    }
    if (message.orderedBy !== 0) {
      writer.uint32(80).int32(message.orderedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vehicle = Vehicle.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vehiclePickupEta = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vehiclePickupDistanceMeters = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.vehiclePickupStraightLineDistanceMeters = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.vehicleDropoffEta = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.vehiclePickupToDropoffDistanceMeters = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.tripType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.vehicleTripsWaypoints.push(Waypoint.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.vehicleMatchType = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.requestedOrderedBy = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.orderedBy = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleMatch {
    return {
      vehicle: isSet(object.vehicle) ? Vehicle.fromJSON(object.vehicle) : undefined,
      vehiclePickupEta: isSet(object.vehiclePickupEta) ? fromJsonTimestamp(object.vehiclePickupEta) : undefined,
      vehiclePickupDistanceMeters: isSet(object.vehiclePickupDistanceMeters)
        ? Number(object.vehiclePickupDistanceMeters)
        : undefined,
      vehiclePickupStraightLineDistanceMeters: isSet(object.vehiclePickupStraightLineDistanceMeters)
        ? Number(object.vehiclePickupStraightLineDistanceMeters)
        : undefined,
      vehicleDropoffEta: isSet(object.vehicleDropoffEta) ? fromJsonTimestamp(object.vehicleDropoffEta) : undefined,
      vehiclePickupToDropoffDistanceMeters: isSet(object.vehiclePickupToDropoffDistanceMeters)
        ? Number(object.vehiclePickupToDropoffDistanceMeters)
        : undefined,
      tripType: isSet(object.tripType) ? tripTypeFromJSON(object.tripType) : 0,
      vehicleTripsWaypoints: globalThis.Array.isArray(object?.vehicleTripsWaypoints)
        ? object.vehicleTripsWaypoints.map((e: any) => Waypoint.fromJSON(e))
        : [],
      vehicleMatchType: isSet(object.vehicleMatchType)
        ? vehicleMatch_VehicleMatchTypeFromJSON(object.vehicleMatchType)
        : 0,
      requestedOrderedBy: isSet(object.requestedOrderedBy)
        ? searchVehiclesRequest_VehicleMatchOrderFromJSON(object.requestedOrderedBy)
        : 0,
      orderedBy: isSet(object.orderedBy) ? searchVehiclesRequest_VehicleMatchOrderFromJSON(object.orderedBy) : 0,
    };
  },

  toJSON(message: VehicleMatch): unknown {
    const obj: any = {};
    if (message.vehicle !== undefined) {
      obj.vehicle = Vehicle.toJSON(message.vehicle);
    }
    if (message.vehiclePickupEta !== undefined) {
      obj.vehiclePickupEta = message.vehiclePickupEta.toISOString();
    }
    if (message.vehiclePickupDistanceMeters !== undefined) {
      obj.vehiclePickupDistanceMeters = message.vehiclePickupDistanceMeters;
    }
    if (message.vehiclePickupStraightLineDistanceMeters !== undefined) {
      obj.vehiclePickupStraightLineDistanceMeters = message.vehiclePickupStraightLineDistanceMeters;
    }
    if (message.vehicleDropoffEta !== undefined) {
      obj.vehicleDropoffEta = message.vehicleDropoffEta.toISOString();
    }
    if (message.vehiclePickupToDropoffDistanceMeters !== undefined) {
      obj.vehiclePickupToDropoffDistanceMeters = message.vehiclePickupToDropoffDistanceMeters;
    }
    if (message.tripType !== 0) {
      obj.tripType = tripTypeToJSON(message.tripType);
    }
    if (message.vehicleTripsWaypoints?.length) {
      obj.vehicleTripsWaypoints = message.vehicleTripsWaypoints.map((e) => Waypoint.toJSON(e));
    }
    if (message.vehicleMatchType !== 0) {
      obj.vehicleMatchType = vehicleMatch_VehicleMatchTypeToJSON(message.vehicleMatchType);
    }
    if (message.requestedOrderedBy !== 0) {
      obj.requestedOrderedBy = searchVehiclesRequest_VehicleMatchOrderToJSON(message.requestedOrderedBy);
    }
    if (message.orderedBy !== 0) {
      obj.orderedBy = searchVehiclesRequest_VehicleMatchOrderToJSON(message.orderedBy);
    }
    return obj;
  },

  create(base?: DeepPartial<VehicleMatch>): VehicleMatch {
    return VehicleMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VehicleMatch>): VehicleMatch {
    const message = createBaseVehicleMatch();
    message.vehicle = (object.vehicle !== undefined && object.vehicle !== null)
      ? Vehicle.fromPartial(object.vehicle)
      : undefined;
    message.vehiclePickupEta = object.vehiclePickupEta ?? undefined;
    message.vehiclePickupDistanceMeters = object.vehiclePickupDistanceMeters ?? undefined;
    message.vehiclePickupStraightLineDistanceMeters = object.vehiclePickupStraightLineDistanceMeters ?? undefined;
    message.vehicleDropoffEta = object.vehicleDropoffEta ?? undefined;
    message.vehiclePickupToDropoffDistanceMeters = object.vehiclePickupToDropoffDistanceMeters ?? undefined;
    message.tripType = object.tripType ?? 0;
    message.vehicleTripsWaypoints = object.vehicleTripsWaypoints?.map((e) => Waypoint.fromPartial(e)) || [];
    message.vehicleMatchType = object.vehicleMatchType ?? 0;
    message.requestedOrderedBy = object.requestedOrderedBy ?? 0;
    message.orderedBy = object.orderedBy ?? 0;
    return message;
  },
};

function createBaseVehicleAttributeList(): VehicleAttributeList {
  return { attributes: [] };
}

export const VehicleAttributeList: MessageFns<VehicleAttributeList> = {
  encode(message: VehicleAttributeList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attributes) {
      VehicleAttribute.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VehicleAttributeList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicleAttributeList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributes.push(VehicleAttribute.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VehicleAttributeList {
    return {
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => VehicleAttribute.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VehicleAttributeList): unknown {
    const obj: any = {};
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => VehicleAttribute.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VehicleAttributeList>): VehicleAttributeList {
    return VehicleAttributeList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VehicleAttributeList>): VehicleAttributeList {
    const message = createBaseVehicleAttributeList();
    message.attributes = object.attributes?.map((e) => VehicleAttribute.fromPartial(e)) || [];
    return message;
  },
};

/** Vehicle management service. */
export type VehicleServiceDefinition = typeof VehicleServiceDefinition;
export const VehicleServiceDefinition = {
  name: "VehicleService",
  fullName: "maps.fleetengine.v1.VehicleService",
  methods: {
    /**
     * Instantiates a new vehicle associated with an on-demand rideshare or
     * deliveries provider. Each `Vehicle` must have a unique vehicle ID.
     *
     * The following `Vehicle` fields are required when creating a `Vehicle`:
     *
     * * `vehicleState`
     * * `supportedTripTypes`
     * * `maximumCapacity`
     * * `vehicleType`
     *
     * The following `Vehicle` fields are ignored when creating a `Vehicle`:
     *
     * * `name`
     * * `currentTrips`
     * * `availableCapacity`
     * * `current_route_segment`
     * * `current_route_segment_end_point`
     * * `current_route_segment_version`
     * * `current_route_segment_traffic`
     * * `route`
     * * `waypoints`
     * * `waypoints_version`
     * * `remaining_distance_meters`
     * * `remaining_time_seconds`
     * * `eta_to_next_waypoint`
     * * `navigation_status`
     *
     * All other fields are optional and used if provided.
     */
    createVehicle: {
      name: "CreateVehicle",
      requestType: CreateVehicleRequest,
      requestStream: false,
      responseType: Vehicle,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              44,
              58,
              7,
              118,
              101,
              104,
              105,
              99,
              108,
              101,
              34,
              33,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              118,
              101,
              104,
              105,
              99,
              108,
              101,
              115,
            ]),
          ],
          578365834: [
            Buffer.from([
              37,
              18,
              35,
              10,
              6,
              112,
              97,
              114,
              101,
              110,
              116,
              18,
              25,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              95,
              105,
              100,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns a vehicle from the Fleet Engine. */
    getVehicle: {
      name: "GetVehicle",
      requestType: GetVehicleRequest,
      requestStream: false,
      responseType: Vehicle,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              35,
              18,
              33,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              118,
              101,
              104,
              105,
              99,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
          578365834: [
            Buffer.from([
              35,
              18,
              33,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              25,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              95,
              105,
              100,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Writes updated vehicle data to the Fleet Engine.
     *
     * When updating a `Vehicle`, the following fields cannot be updated since
     * they are managed by the server:
     *
     * * `currentTrips`
     * * `availableCapacity`
     * * `current_route_segment_version`
     * * `waypoints_version`
     *
     * The vehicle `name` also cannot be updated.
     *
     * If the `attributes` field is updated, **all** the vehicle's attributes are
     * replaced with the attributes provided in the request. If you want to update
     * only some attributes, see the `UpdateVehicleAttributes` method. Likewise,
     * the `waypoints` field can be updated, but must contain all the waypoints
     * currently on the vehicle, and no other waypoints.
     */
    updateVehicle: {
      name: "UpdateVehicle",
      requestType: UpdateVehicleRequest,
      requestStream: false,
      responseType: Vehicle,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              44,
              58,
              7,
              118,
              101,
              104,
              105,
              99,
              108,
              101,
              26,
              33,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              118,
              101,
              104,
              105,
              99,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
          578365834: [
            Buffer.from([
              35,
              18,
              33,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              25,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              95,
              105,
              100,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Partially updates a vehicle's attributes.
     * Only the attributes mentioned in the request will be updated, other
     * attributes will NOT be altered. Note: this is different in `UpdateVehicle`,
     * where the whole `attributes` field will be replaced by the one in
     * `UpdateVehicleRequest`, attributes not in the request would be removed.
     */
    updateVehicleAttributes: {
      name: "UpdateVehicleAttributes",
      requestType: UpdateVehicleAttributesRequest,
      requestStream: false,
      responseType: UpdateVehicleAttributesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              118,
              101,
              104,
              105,
              99,
              108,
              101,
              115,
              47,
              42,
              125,
              58,
              117,
              112,
              100,
              97,
              116,
              101,
              65,
              116,
              116,
              114,
              105,
              98,
              117,
              116,
              101,
              115,
            ]),
          ],
          578365834: [
            Buffer.from([
              35,
              18,
              33,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              25,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              95,
              105,
              100,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Returns a paginated list of vehicles associated with
     * a provider that match the request options.
     */
    listVehicles: {
      name: "ListVehicles",
      requestType: ListVehiclesRequest,
      requestStream: false,
      responseType: ListVehiclesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              35,
              18,
              33,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              118,
              101,
              104,
              105,
              99,
              108,
              101,
              115,
            ]),
          ],
          578365834: [
            Buffer.from([
              37,
              18,
              35,
              10,
              6,
              112,
              97,
              114,
              101,
              110,
              116,
              18,
              25,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              95,
              105,
              100,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns a list of vehicles that match the request options. */
    searchVehicles: {
      name: "SearchVehicles",
      requestType: SearchVehiclesRequest,
      requestStream: false,
      responseType: SearchVehiclesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              45,
              58,
              1,
              42,
              34,
              40,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              118,
              101,
              104,
              105,
              99,
              108,
              101,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
          578365834: [
            Buffer.from([
              37,
              18,
              35,
              10,
              6,
              112,
              97,
              114,
              101,
              110,
              116,
              18,
              25,
              123,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              95,
              105,
              100,
              61,
              112,
              114,
              111,
              118,
              105,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface VehicleServiceImplementation<CallContextExt = {}> {
  /**
   * Instantiates a new vehicle associated with an on-demand rideshare or
   * deliveries provider. Each `Vehicle` must have a unique vehicle ID.
   *
   * The following `Vehicle` fields are required when creating a `Vehicle`:
   *
   * * `vehicleState`
   * * `supportedTripTypes`
   * * `maximumCapacity`
   * * `vehicleType`
   *
   * The following `Vehicle` fields are ignored when creating a `Vehicle`:
   *
   * * `name`
   * * `currentTrips`
   * * `availableCapacity`
   * * `current_route_segment`
   * * `current_route_segment_end_point`
   * * `current_route_segment_version`
   * * `current_route_segment_traffic`
   * * `route`
   * * `waypoints`
   * * `waypoints_version`
   * * `remaining_distance_meters`
   * * `remaining_time_seconds`
   * * `eta_to_next_waypoint`
   * * `navigation_status`
   *
   * All other fields are optional and used if provided.
   */
  createVehicle(request: CreateVehicleRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Vehicle>>;
  /** Returns a vehicle from the Fleet Engine. */
  getVehicle(request: GetVehicleRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Vehicle>>;
  /**
   * Writes updated vehicle data to the Fleet Engine.
   *
   * When updating a `Vehicle`, the following fields cannot be updated since
   * they are managed by the server:
   *
   * * `currentTrips`
   * * `availableCapacity`
   * * `current_route_segment_version`
   * * `waypoints_version`
   *
   * The vehicle `name` also cannot be updated.
   *
   * If the `attributes` field is updated, **all** the vehicle's attributes are
   * replaced with the attributes provided in the request. If you want to update
   * only some attributes, see the `UpdateVehicleAttributes` method. Likewise,
   * the `waypoints` field can be updated, but must contain all the waypoints
   * currently on the vehicle, and no other waypoints.
   */
  updateVehicle(request: UpdateVehicleRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Vehicle>>;
  /**
   * Partially updates a vehicle's attributes.
   * Only the attributes mentioned in the request will be updated, other
   * attributes will NOT be altered. Note: this is different in `UpdateVehicle`,
   * where the whole `attributes` field will be replaced by the one in
   * `UpdateVehicleRequest`, attributes not in the request would be removed.
   */
  updateVehicleAttributes(
    request: UpdateVehicleAttributesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<UpdateVehicleAttributesResponse>>;
  /**
   * Returns a paginated list of vehicles associated with
   * a provider that match the request options.
   */
  listVehicles(
    request: ListVehiclesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListVehiclesResponse>>;
  /** Returns a list of vehicles that match the request options. */
  searchVehicles(
    request: SearchVehiclesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchVehiclesResponse>>;
}

export interface VehicleServiceClient<CallOptionsExt = {}> {
  /**
   * Instantiates a new vehicle associated with an on-demand rideshare or
   * deliveries provider. Each `Vehicle` must have a unique vehicle ID.
   *
   * The following `Vehicle` fields are required when creating a `Vehicle`:
   *
   * * `vehicleState`
   * * `supportedTripTypes`
   * * `maximumCapacity`
   * * `vehicleType`
   *
   * The following `Vehicle` fields are ignored when creating a `Vehicle`:
   *
   * * `name`
   * * `currentTrips`
   * * `availableCapacity`
   * * `current_route_segment`
   * * `current_route_segment_end_point`
   * * `current_route_segment_version`
   * * `current_route_segment_traffic`
   * * `route`
   * * `waypoints`
   * * `waypoints_version`
   * * `remaining_distance_meters`
   * * `remaining_time_seconds`
   * * `eta_to_next_waypoint`
   * * `navigation_status`
   *
   * All other fields are optional and used if provided.
   */
  createVehicle(request: DeepPartial<CreateVehicleRequest>, options?: CallOptions & CallOptionsExt): Promise<Vehicle>;
  /** Returns a vehicle from the Fleet Engine. */
  getVehicle(request: DeepPartial<GetVehicleRequest>, options?: CallOptions & CallOptionsExt): Promise<Vehicle>;
  /**
   * Writes updated vehicle data to the Fleet Engine.
   *
   * When updating a `Vehicle`, the following fields cannot be updated since
   * they are managed by the server:
   *
   * * `currentTrips`
   * * `availableCapacity`
   * * `current_route_segment_version`
   * * `waypoints_version`
   *
   * The vehicle `name` also cannot be updated.
   *
   * If the `attributes` field is updated, **all** the vehicle's attributes are
   * replaced with the attributes provided in the request. If you want to update
   * only some attributes, see the `UpdateVehicleAttributes` method. Likewise,
   * the `waypoints` field can be updated, but must contain all the waypoints
   * currently on the vehicle, and no other waypoints.
   */
  updateVehicle(request: DeepPartial<UpdateVehicleRequest>, options?: CallOptions & CallOptionsExt): Promise<Vehicle>;
  /**
   * Partially updates a vehicle's attributes.
   * Only the attributes mentioned in the request will be updated, other
   * attributes will NOT be altered. Note: this is different in `UpdateVehicle`,
   * where the whole `attributes` field will be replaced by the one in
   * `UpdateVehicleRequest`, attributes not in the request would be removed.
   */
  updateVehicleAttributes(
    request: DeepPartial<UpdateVehicleAttributesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<UpdateVehicleAttributesResponse>;
  /**
   * Returns a paginated list of vehicles associated with
   * a provider that match the request options.
   */
  listVehicles(
    request: DeepPartial<ListVehiclesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListVehiclesResponse>;
  /** Returns a list of vehicles that match the request options. */
  searchVehicles(
    request: DeepPartial<SearchVehiclesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchVehiclesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
