// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/aerialview/v1/aerial_view.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Duration } from "../../../protobuf/duration.js";
import { DateMessage } from "../../../type/date.js";

export const protobufPackage = "google.maps.aerialview.v1";

/** An object that encapsulates all of the data about a video. */
export interface Video {
  /**
   * A mapping of media types to their URIs.
   * This field is only included for `ACTIVE` videos.
   * The key is an enum value from `MediaFormat`.
   */
  uris: { [key: string]: Uris };
  /** Current state of the render request. */
  state: Video_State;
  /** Contains the video's metadata, only set if the state is `ACTIVE`. */
  metadata: VideoMetadata | undefined;
}

/** The different states a video can be in. */
export enum Video_State {
  /** STATE_UNSPECIFIED - Default value. This value is unused. */
  STATE_UNSPECIFIED = 0,
  /** PROCESSING - The video is currently processing. */
  PROCESSING = 1,
  /**
   * ACTIVE - The video has finished rendering, and can be viewed through
   * `LookupVideo`.
   */
  ACTIVE = 2,
  /** FAILED - The video has failed to render. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function video_StateFromJSON(object: any): Video_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Video_State.STATE_UNSPECIFIED;
    case 1:
    case "PROCESSING":
      return Video_State.PROCESSING;
    case 2:
    case "ACTIVE":
      return Video_State.ACTIVE;
    case 3:
    case "FAILED":
      return Video_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Video_State.UNRECOGNIZED;
  }
}

export function video_StateToJSON(object: Video_State): string {
  switch (object) {
    case Video_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Video_State.PROCESSING:
      return "PROCESSING";
    case Video_State.ACTIVE:
      return "ACTIVE";
    case Video_State.FAILED:
      return "FAILED";
    case Video_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Video_UrisEntry {
  key: string;
  value: Uris | undefined;
}

/** Contains all the uris for a given video format. */
export interface Uris {
  /** A signed short-lived URI for the media in a landscape orientation. */
  landscapeUri: string;
  /** A signed short-lived URI for the media in a portrait orientation. */
  portraitUri: string;
}

/** Contains metadata about a video, such as its videoId and duration. */
export interface VideoMetadata {
  /** An ID for the video, and the recommended way to retrieve a video. */
  videoId: string;
  /**
   * The date at which the imagery used in the video was captured.
   * This will be at a month-level granularity.
   */
  captureDate:
    | DateMessage
    | undefined;
  /** The length of the video. */
  duration: Duration | undefined;
}

/** Request message for `AerialView.RenderVideo`. */
export interface RenderVideoRequest {
  /** Required. A US postal address for the location to be rendered in the video. */
  address: string;
}

/** Response message for `AerialView.RenderVideo`. */
export interface RenderVideoResponse {
  /** Current state of the render request. */
  state: Video_State;
  /** Contains the video's metadata, only set if the state is `ACTIVE`. */
  metadata: VideoMetadata | undefined;
}

/** Request message for `AerialView.LookupVideo`. */
export interface LookupVideoRequest {
  /** An ID returned from `RenderVideo`. */
  videoId?:
    | string
    | undefined;
  /** A US postal address. */
  address?: string | undefined;
}

function createBaseVideo(): Video {
  return { uris: {}, state: 0, metadata: undefined };
}

export const Video: MessageFns<Video> = {
  encode(message: Video, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.uris).forEach(([key, value]) => {
      Video_UrisEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.metadata !== undefined) {
      VideoMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Video {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Video_UrisEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.uris[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = VideoMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Video {
    return {
      uris: isObject(object.uris)
        ? Object.entries(object.uris).reduce<{ [key: string]: Uris }>((acc, [key, value]) => {
          acc[key] = Uris.fromJSON(value);
          return acc;
        }, {})
        : {},
      state: isSet(object.state) ? video_StateFromJSON(object.state) : 0,
      metadata: isSet(object.metadata) ? VideoMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Video): unknown {
    const obj: any = {};
    if (message.uris) {
      const entries = Object.entries(message.uris);
      if (entries.length > 0) {
        obj.uris = {};
        entries.forEach(([k, v]) => {
          obj.uris[k] = Uris.toJSON(v);
        });
      }
    }
    if (message.state !== 0) {
      obj.state = video_StateToJSON(message.state);
    }
    if (message.metadata !== undefined) {
      obj.metadata = VideoMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<Video>): Video {
    return Video.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Video>): Video {
    const message = createBaseVideo();
    message.uris = Object.entries(object.uris ?? {}).reduce<{ [key: string]: Uris }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Uris.fromPartial(value);
      }
      return acc;
    }, {});
    message.state = object.state ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? VideoMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseVideo_UrisEntry(): Video_UrisEntry {
  return { key: "", value: undefined };
}

export const Video_UrisEntry: MessageFns<Video_UrisEntry> = {
  encode(message: Video_UrisEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Uris.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Video_UrisEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideo_UrisEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Uris.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Video_UrisEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Uris.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Video_UrisEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Uris.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Video_UrisEntry>): Video_UrisEntry {
    return Video_UrisEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Video_UrisEntry>): Video_UrisEntry {
    const message = createBaseVideo_UrisEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Uris.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseUris(): Uris {
  return { landscapeUri: "", portraitUri: "" };
}

export const Uris: MessageFns<Uris> = {
  encode(message: Uris, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.landscapeUri !== "") {
      writer.uint32(10).string(message.landscapeUri);
    }
    if (message.portraitUri !== "") {
      writer.uint32(18).string(message.portraitUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Uris {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUris();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.landscapeUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.portraitUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Uris {
    return {
      landscapeUri: isSet(object.landscapeUri) ? globalThis.String(object.landscapeUri) : "",
      portraitUri: isSet(object.portraitUri) ? globalThis.String(object.portraitUri) : "",
    };
  },

  toJSON(message: Uris): unknown {
    const obj: any = {};
    if (message.landscapeUri !== "") {
      obj.landscapeUri = message.landscapeUri;
    }
    if (message.portraitUri !== "") {
      obj.portraitUri = message.portraitUri;
    }
    return obj;
  },

  create(base?: DeepPartial<Uris>): Uris {
    return Uris.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Uris>): Uris {
    const message = createBaseUris();
    message.landscapeUri = object.landscapeUri ?? "";
    message.portraitUri = object.portraitUri ?? "";
    return message;
  },
};

function createBaseVideoMetadata(): VideoMetadata {
  return { videoId: "", captureDate: undefined, duration: undefined };
}

export const VideoMetadata: MessageFns<VideoMetadata> = {
  encode(message: VideoMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoId !== "") {
      writer.uint32(10).string(message.videoId);
    }
    if (message.captureDate !== undefined) {
      DateMessage.encode(message.captureDate, writer.uint32(18).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VideoMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVideoMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.videoId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.captureDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VideoMetadata {
    return {
      videoId: isSet(object.videoId) ? globalThis.String(object.videoId) : "",
      captureDate: isSet(object.captureDate) ? DateMessage.fromJSON(object.captureDate) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
    };
  },

  toJSON(message: VideoMetadata): unknown {
    const obj: any = {};
    if (message.videoId !== "") {
      obj.videoId = message.videoId;
    }
    if (message.captureDate !== undefined) {
      obj.captureDate = DateMessage.toJSON(message.captureDate);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    return obj;
  },

  create(base?: DeepPartial<VideoMetadata>): VideoMetadata {
    return VideoMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VideoMetadata>): VideoMetadata {
    const message = createBaseVideoMetadata();
    message.videoId = object.videoId ?? "";
    message.captureDate = (object.captureDate !== undefined && object.captureDate !== null)
      ? DateMessage.fromPartial(object.captureDate)
      : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    return message;
  },
};

function createBaseRenderVideoRequest(): RenderVideoRequest {
  return { address: "" };
}

export const RenderVideoRequest: MessageFns<RenderVideoRequest> = {
  encode(message: RenderVideoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenderVideoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderVideoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderVideoRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: RenderVideoRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<RenderVideoRequest>): RenderVideoRequest {
    return RenderVideoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenderVideoRequest>): RenderVideoRequest {
    const message = createBaseRenderVideoRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseRenderVideoResponse(): RenderVideoResponse {
  return { state: 0, metadata: undefined };
}

export const RenderVideoResponse: MessageFns<RenderVideoResponse> = {
  encode(message: RenderVideoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.metadata !== undefined) {
      VideoMetadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenderVideoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenderVideoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metadata = VideoMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenderVideoResponse {
    return {
      state: isSet(object.state) ? video_StateFromJSON(object.state) : 0,
      metadata: isSet(object.metadata) ? VideoMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: RenderVideoResponse): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = video_StateToJSON(message.state);
    }
    if (message.metadata !== undefined) {
      obj.metadata = VideoMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<RenderVideoResponse>): RenderVideoResponse {
    return RenderVideoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenderVideoResponse>): RenderVideoResponse {
    const message = createBaseRenderVideoResponse();
    message.state = object.state ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? VideoMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseLookupVideoRequest(): LookupVideoRequest {
  return { videoId: undefined, address: undefined };
}

export const LookupVideoRequest: MessageFns<LookupVideoRequest> = {
  encode(message: LookupVideoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.videoId !== undefined) {
      writer.uint32(10).string(message.videoId);
    }
    if (message.address !== undefined) {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupVideoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupVideoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.videoId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupVideoRequest {
    return {
      videoId: isSet(object.videoId) ? globalThis.String(object.videoId) : undefined,
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
    };
  },

  toJSON(message: LookupVideoRequest): unknown {
    const obj: any = {};
    if (message.videoId !== undefined) {
      obj.videoId = message.videoId;
    }
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    return obj;
  },

  create(base?: DeepPartial<LookupVideoRequest>): LookupVideoRequest {
    return LookupVideoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LookupVideoRequest>): LookupVideoRequest {
    const message = createBaseLookupVideoRequest();
    message.videoId = object.videoId ?? undefined;
    message.address = object.address ?? undefined;
    return message;
  },
};

/** Service definition for the Aerial View API. */
export type AerialViewDefinition = typeof AerialViewDefinition;
export const AerialViewDefinition = {
  name: "AerialView",
  fullName: "google.maps.aerialview.v1.AerialView",
  methods: {
    /**
     * Adds an address to the renderer's queue if a video hasn't already been
     * rendered. Otherwise, returns metadata about the video.
     */
    renderVideo: {
      name: "RenderVideo",
      requestType: RenderVideoRequest,
      requestStream: false,
      responseType: RenderVideoResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([7, 97, 100, 100, 114, 101, 115, 115])],
          578365826: [
            Buffer.from([
              27,
              58,
              1,
              42,
              34,
              22,
              47,
              118,
              49,
              47,
              118,
              105,
              100,
              101,
              111,
              115,
              58,
              114,
              101,
              110,
              100,
              101,
              114,
              86,
              105,
              100,
              101,
              111,
            ]),
          ],
        },
      },
    },
    /**
     * Fetches a video given its address or videoId. The response will either be
     * a video with a set of playback URIs for ACTIVE videos, a PROCESSING state
     * for pending videos, or a 404 error if the video does not exist. Receiving a
     * video is a billable event, so callers of this method should be ready to use
     * the returned URIs at the time of request.
     */
    lookupVideo: {
      name: "LookupVideo",
      requestType: LookupVideoRequest,
      requestStream: false,
      responseType: Video,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              24,
              18,
              22,
              47,
              118,
              49,
              47,
              118,
              105,
              100,
              101,
              111,
              115,
              58,
              108,
              111,
              111,
              107,
              117,
              112,
              86,
              105,
              100,
              101,
              111,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AerialViewServiceImplementation<CallContextExt = {}> {
  /**
   * Adds an address to the renderer's queue if a video hasn't already been
   * rendered. Otherwise, returns metadata about the video.
   */
  renderVideo(
    request: RenderVideoRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RenderVideoResponse>>;
  /**
   * Fetches a video given its address or videoId. The response will either be
   * a video with a set of playback URIs for ACTIVE videos, a PROCESSING state
   * for pending videos, or a 404 error if the video does not exist. Receiving a
   * video is a billable event, so callers of this method should be ready to use
   * the returned URIs at the time of request.
   */
  lookupVideo(request: LookupVideoRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Video>>;
}

export interface AerialViewClient<CallOptionsExt = {}> {
  /**
   * Adds an address to the renderer's queue if a video hasn't already been
   * rendered. Otherwise, returns metadata about the video.
   */
  renderVideo(
    request: DeepPartial<RenderVideoRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RenderVideoResponse>;
  /**
   * Fetches a video given its address or videoId. The response will either be
   * a video with a set of playback URIs for ACTIVE videos, a PROCESSING state
   * for pending videos, or a 404 error if the video does not exist. Receiving a
   * video is a billable event, so callers of this method should be ready to use
   * the returned URIs at the time of request.
   */
  lookupVideo(request: DeepPartial<LookupVideoRequest>, options?: CallOptions & CallOptionsExt): Promise<Video>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
