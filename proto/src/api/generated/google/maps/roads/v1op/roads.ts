// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/maps/roads/v1op/roads.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { UInt32Value } from "../../../protobuf/wrappers.js";
import { LatLng } from "../../../type/latlng.js";

export const protobufPackage = "google.maps.roads.v1op";

/** An enum representing the mode of travel used for snapping. */
export enum TravelMode {
  TRAVEL_MODE_UNSPECIFIED = 0,
  DRIVING = 1,
  CYCLING = 2,
  WALKING = 3,
  UNRECOGNIZED = -1,
}

export function travelModeFromJSON(object: any): TravelMode {
  switch (object) {
    case 0:
    case "TRAVEL_MODE_UNSPECIFIED":
      return TravelMode.TRAVEL_MODE_UNSPECIFIED;
    case 1:
    case "DRIVING":
      return TravelMode.DRIVING;
    case 2:
    case "CYCLING":
      return TravelMode.CYCLING;
    case 3:
    case "WALKING":
      return TravelMode.WALKING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TravelMode.UNRECOGNIZED;
  }
}

export function travelModeToJSON(object: TravelMode): string {
  switch (object) {
    case TravelMode.TRAVEL_MODE_UNSPECIFIED:
      return "TRAVEL_MODE_UNSPECIFIED";
    case TravelMode.DRIVING:
      return "DRIVING";
    case TravelMode.CYCLING:
      return "CYCLING";
    case TravelMode.WALKING:
      return "WALKING";
    case TravelMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A request to the SnapToRoads method, requesting that a sequence of points be
 * snapped to road segments.
 */
export interface SnapToRoadsRequest {
  /**
   * The path to be snapped as a series of lat, lng points. Specified as
   * a string of the format: lat,lng|lat,lng|...
   */
  path: string;
  /** Whether to interpolate the points to return full road geometry. */
  interpolate: boolean;
  /**
   * The asset ID of the asset to which this path relates. This is used for
   * abuse detection purposes for clients with asset-based SKUs.
   */
  assetId: string;
  /** The type of travel being tracked. This will constrain the paths we snap to. */
  travelMode: TravelMode;
}

/** A snapped point object, representing the result of snapping. */
export interface SnappedPoint {
  /** The lat,lng of the snapped location. */
  location:
    | LatLng
    | undefined;
  /**
   * The index into the original path of the equivalent pre-snapped point.
   * This allows for identification of points which have been interpolated if
   * this index is missing.
   */
  originalIndex:
    | number
    | undefined;
  /**
   * The place ID for this snapped location (road segment). These are the same
   * as are currently used by the Places API.
   */
  placeId: string;
}

/**
 * The response from the SnapToRoads method, returning a sequence of snapped
 * points.
 */
export interface SnapToRoadsResponse {
  /** A list of snapped points. */
  snappedPoints: SnappedPoint[];
  /**
   * User-visible warning message, if any, which can be shown alongside a valid
   * result.
   */
  warningMessage: string;
}

/**
 * A request to the ListNearestRoads method, requesting that a sequence of
 * points be snapped individually to the road segment that each is closest to.
 */
export interface ListNearestRoadsRequest {
  /**
   * The points to be snapped as a series of lat, lng points. Specified as
   * a string of the format: lat,lng|lat,lng|...
   */
  points: string;
  /** The type of travel being tracked. This will constrain the roads we snap to. */
  travelMode: TravelMode;
}

/**
 * The response from the ListNearestRoads method, returning a list of snapped
 * points.
 */
export interface ListNearestRoadsResponse {
  /** A list of snapped points. */
  snappedPoints: SnappedPoint[];
}

function createBaseSnapToRoadsRequest(): SnapToRoadsRequest {
  return { path: "", interpolate: false, assetId: "", travelMode: 0 };
}

export const SnapToRoadsRequest: MessageFns<SnapToRoadsRequest> = {
  encode(message: SnapToRoadsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.interpolate !== false) {
      writer.uint32(16).bool(message.interpolate);
    }
    if (message.assetId !== "") {
      writer.uint32(26).string(message.assetId);
    }
    if (message.travelMode !== 0) {
      writer.uint32(32).int32(message.travelMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnapToRoadsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapToRoadsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.interpolate = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assetId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.travelMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnapToRoadsRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      interpolate: isSet(object.interpolate) ? globalThis.Boolean(object.interpolate) : false,
      assetId: isSet(object.assetId) ? globalThis.String(object.assetId) : "",
      travelMode: isSet(object.travelMode) ? travelModeFromJSON(object.travelMode) : 0,
    };
  },

  toJSON(message: SnapToRoadsRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.interpolate !== false) {
      obj.interpolate = message.interpolate;
    }
    if (message.assetId !== "") {
      obj.assetId = message.assetId;
    }
    if (message.travelMode !== 0) {
      obj.travelMode = travelModeToJSON(message.travelMode);
    }
    return obj;
  },

  create(base?: DeepPartial<SnapToRoadsRequest>): SnapToRoadsRequest {
    return SnapToRoadsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SnapToRoadsRequest>): SnapToRoadsRequest {
    const message = createBaseSnapToRoadsRequest();
    message.path = object.path ?? "";
    message.interpolate = object.interpolate ?? false;
    message.assetId = object.assetId ?? "";
    message.travelMode = object.travelMode ?? 0;
    return message;
  },
};

function createBaseSnappedPoint(): SnappedPoint {
  return { location: undefined, originalIndex: undefined, placeId: "" };
}

export const SnappedPoint: MessageFns<SnappedPoint> = {
  encode(message: SnappedPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      LatLng.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.originalIndex !== undefined) {
      UInt32Value.encode({ value: message.originalIndex! }, writer.uint32(18).fork()).join();
    }
    if (message.placeId !== "") {
      writer.uint32(26).string(message.placeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnappedPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnappedPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = LatLng.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.originalIndex = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.placeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnappedPoint {
    return {
      location: isSet(object.location) ? LatLng.fromJSON(object.location) : undefined,
      originalIndex: isSet(object.originalIndex) ? Number(object.originalIndex) : undefined,
      placeId: isSet(object.placeId) ? globalThis.String(object.placeId) : "",
    };
  },

  toJSON(message: SnappedPoint): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = LatLng.toJSON(message.location);
    }
    if (message.originalIndex !== undefined) {
      obj.originalIndex = message.originalIndex;
    }
    if (message.placeId !== "") {
      obj.placeId = message.placeId;
    }
    return obj;
  },

  create(base?: DeepPartial<SnappedPoint>): SnappedPoint {
    return SnappedPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SnappedPoint>): SnappedPoint {
    const message = createBaseSnappedPoint();
    message.location = (object.location !== undefined && object.location !== null)
      ? LatLng.fromPartial(object.location)
      : undefined;
    message.originalIndex = object.originalIndex ?? undefined;
    message.placeId = object.placeId ?? "";
    return message;
  },
};

function createBaseSnapToRoadsResponse(): SnapToRoadsResponse {
  return { snappedPoints: [], warningMessage: "" };
}

export const SnapToRoadsResponse: MessageFns<SnapToRoadsResponse> = {
  encode(message: SnapToRoadsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.snappedPoints) {
      SnappedPoint.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.warningMessage !== "") {
      writer.uint32(18).string(message.warningMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnapToRoadsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapToRoadsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.snappedPoints.push(SnappedPoint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.warningMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnapToRoadsResponse {
    return {
      snappedPoints: globalThis.Array.isArray(object?.snappedPoints)
        ? object.snappedPoints.map((e: any) => SnappedPoint.fromJSON(e))
        : [],
      warningMessage: isSet(object.warningMessage) ? globalThis.String(object.warningMessage) : "",
    };
  },

  toJSON(message: SnapToRoadsResponse): unknown {
    const obj: any = {};
    if (message.snappedPoints?.length) {
      obj.snappedPoints = message.snappedPoints.map((e) => SnappedPoint.toJSON(e));
    }
    if (message.warningMessage !== "") {
      obj.warningMessage = message.warningMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<SnapToRoadsResponse>): SnapToRoadsResponse {
    return SnapToRoadsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SnapToRoadsResponse>): SnapToRoadsResponse {
    const message = createBaseSnapToRoadsResponse();
    message.snappedPoints = object.snappedPoints?.map((e) => SnappedPoint.fromPartial(e)) || [];
    message.warningMessage = object.warningMessage ?? "";
    return message;
  },
};

function createBaseListNearestRoadsRequest(): ListNearestRoadsRequest {
  return { points: "", travelMode: 0 };
}

export const ListNearestRoadsRequest: MessageFns<ListNearestRoadsRequest> = {
  encode(message: ListNearestRoadsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.points !== "") {
      writer.uint32(10).string(message.points);
    }
    if (message.travelMode !== 0) {
      writer.uint32(16).int32(message.travelMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNearestRoadsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNearestRoadsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.points = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.travelMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNearestRoadsRequest {
    return {
      points: isSet(object.points) ? globalThis.String(object.points) : "",
      travelMode: isSet(object.travelMode) ? travelModeFromJSON(object.travelMode) : 0,
    };
  },

  toJSON(message: ListNearestRoadsRequest): unknown {
    const obj: any = {};
    if (message.points !== "") {
      obj.points = message.points;
    }
    if (message.travelMode !== 0) {
      obj.travelMode = travelModeToJSON(message.travelMode);
    }
    return obj;
  },

  create(base?: DeepPartial<ListNearestRoadsRequest>): ListNearestRoadsRequest {
    return ListNearestRoadsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNearestRoadsRequest>): ListNearestRoadsRequest {
    const message = createBaseListNearestRoadsRequest();
    message.points = object.points ?? "";
    message.travelMode = object.travelMode ?? 0;
    return message;
  },
};

function createBaseListNearestRoadsResponse(): ListNearestRoadsResponse {
  return { snappedPoints: [] };
}

export const ListNearestRoadsResponse: MessageFns<ListNearestRoadsResponse> = {
  encode(message: ListNearestRoadsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.snappedPoints) {
      SnappedPoint.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNearestRoadsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNearestRoadsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.snappedPoints.push(SnappedPoint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNearestRoadsResponse {
    return {
      snappedPoints: globalThis.Array.isArray(object?.snappedPoints)
        ? object.snappedPoints.map((e: any) => SnappedPoint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListNearestRoadsResponse): unknown {
    const obj: any = {};
    if (message.snappedPoints?.length) {
      obj.snappedPoints = message.snappedPoints.map((e) => SnappedPoint.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListNearestRoadsResponse>): ListNearestRoadsResponse {
    return ListNearestRoadsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNearestRoadsResponse>): ListNearestRoadsResponse {
    const message = createBaseListNearestRoadsResponse();
    message.snappedPoints = object.snappedPoints?.map((e) => SnappedPoint.fromPartial(e)) || [];
    return message;
  },
};

/**
 * The Roads API maps one or more GPS coordinates to the geometry of the road
 * and determines the speed limit along road segments.
 */
export type RoadsServiceDefinition = typeof RoadsServiceDefinition;
export const RoadsServiceDefinition = {
  name: "RoadsService",
  fullName: "google.maps.roads.v1op.RoadsService",
  methods: {
    /**
     * This method takes a sequence of latitude,longitude points and snaps them to
     * the most likely road segments. Optionally returns additional points giving
     * the full road geometry. Also returns a place ID for each snapped point.
     */
    snapToRoads: {
      name: "SnapToRoads",
      requestType: SnapToRoadsRequest,
      requestStream: false,
      responseType: SnapToRoadsResponse,
      responseStream: false,
      options: { _unknownFields: { 8410: [Buffer.from([4, 112, 97, 116, 104])] } },
    },
    /**
     * This method takes a list of latitude,longitude points and snaps them each
     * to their nearest road. Also returns a place ID for each snapped point.
     */
    listNearestRoads: {
      name: "ListNearestRoads",
      requestType: ListNearestRoadsRequest,
      requestStream: false,
      responseType: ListNearestRoadsResponse,
      responseStream: false,
      options: { _unknownFields: { 8410: [Buffer.from([6, 112, 111, 105, 110, 116, 115])] } },
    },
  },
} as const;

export interface RoadsServiceImplementation<CallContextExt = {}> {
  /**
   * This method takes a sequence of latitude,longitude points and snaps them to
   * the most likely road segments. Optionally returns additional points giving
   * the full road geometry. Also returns a place ID for each snapped point.
   */
  snapToRoads(
    request: SnapToRoadsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SnapToRoadsResponse>>;
  /**
   * This method takes a list of latitude,longitude points and snaps them each
   * to their nearest road. Also returns a place ID for each snapped point.
   */
  listNearestRoads(
    request: ListNearestRoadsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNearestRoadsResponse>>;
}

export interface RoadsServiceClient<CallOptionsExt = {}> {
  /**
   * This method takes a sequence of latitude,longitude points and snaps them to
   * the most likely road segments. Optionally returns additional points giving
   * the full road geometry. Also returns a place ID for each snapped point.
   */
  snapToRoads(
    request: DeepPartial<SnapToRoadsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SnapToRoadsResponse>;
  /**
   * This method takes a list of latitude,longitude points and snaps them each
   * to their nearest road. Also returns a place ID for each snapped point.
   */
  listNearestRoads(
    request: DeepPartial<ListNearestRoadsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNearestRoadsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
