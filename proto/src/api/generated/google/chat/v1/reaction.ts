// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/chat/v1/reaction.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { User } from "./user.js";

export const protobufPackage = "google.chat.v1";

/** A reaction to a message. */
export interface Reaction {
  /**
   * The resource name of the reaction.
   *
   * Format: `spaces/{space}/messages/{message}/reactions/{reaction}`
   */
  name: string;
  /** Output only. The user who created the reaction. */
  user:
    | User
    | undefined;
  /** The emoji used in the reaction. */
  emoji: Emoji | undefined;
}

/** An emoji that is used as a reaction to a message. */
export interface Emoji {
  /** A basic emoji represented by a unicode string. */
  unicode?:
    | string
    | undefined;
  /** Output only. A custom emoji. */
  customEmoji?: CustomEmoji | undefined;
}

/** Represents a custom emoji. */
export interface CustomEmoji {
  /** Output only. Unique key for the custom emoji resource. */
  uid: string;
}

/** The number of people who reacted to a message with a specific emoji. */
export interface EmojiReactionSummary {
  /** Emoji associated with the reactions. */
  emoji:
    | Emoji
    | undefined;
  /** The total number of reactions using the associated emoji. */
  reactionCount?: number | undefined;
}

/** Creates a reaction to a message. */
export interface CreateReactionRequest {
  /**
   * Required. The message where the reaction is created.
   *
   * Format: `spaces/{space}/messages/{message}`
   */
  parent: string;
  /** Required. The reaction to create. */
  reaction: Reaction | undefined;
}

/** Lists reactions to a message. */
export interface ListReactionsRequest {
  /**
   * Required. The message users reacted to.
   *
   * Format: `spaces/{space}/messages/{message}`
   */
  parent: string;
  /**
   * Optional. The maximum number of reactions returned. The service can return
   * fewer reactions than this value. If unspecified, the default value is 25.
   * The maximum value is 200; values above 200 are changed to 200.
   */
  pageSize: number;
  /**
   * Optional. (If resuming from a previous query.)
   *
   * A page token received from a previous list reactions call. Provide this
   * to retrieve the subsequent page.
   *
   * When paginating, the filter value should match the call that provided the
   * page token. Passing a different value might lead to unexpected results.
   */
  pageToken: string;
  /**
   * Optional. A query filter.
   *
   * You can filter reactions by
   * [emoji](https://developers.google.com/workspace/chat/api/reference/rest/v1/Emoji)
   * (either `emoji.unicode` or `emoji.custom_emoji.uid`) and
   * [user](https://developers.google.com/workspace/chat/api/reference/rest/v1/User)
   * (`user.name`).
   *
   * To filter reactions for multiple emojis or users, join similar fields
   * with the `OR` operator, such as `emoji.unicode = "üôÇ" OR emoji.unicode =
   * "üëç"` and `user.name = "users/AAAAAA" OR user.name = "users/BBBBBB"`.
   *
   * To filter reactions by emoji and user, use the `AND` operator, such as
   * `emoji.unicode = "üôÇ" AND user.name = "users/AAAAAA"`.
   *
   * If your query uses both `AND` and `OR`, group them with parentheses.
   *
   * For example, the following queries are valid:
   *
   * ```
   * user.name = "users/{user}"
   * emoji.unicode = "üôÇ"
   * emoji.custom_emoji.uid = "{uid}"
   * emoji.unicode = "üôÇ" OR emoji.unicode = "üëç"
   * emoji.unicode = "üôÇ" OR emoji.custom_emoji.uid = "{uid}"
   * emoji.unicode = "üôÇ" AND user.name = "users/{user}"
   * (emoji.unicode = "üôÇ" OR emoji.custom_emoji.uid = "{uid}")
   * AND user.name = "users/{user}"
   * ```
   *
   * The following queries are invalid:
   *
   * ```
   * emoji.unicode = "üôÇ" AND emoji.unicode = "üëç"
   * emoji.unicode = "üôÇ" AND emoji.custom_emoji.uid = "{uid}"
   * emoji.unicode = "üôÇ" OR user.name = "users/{user}"
   * emoji.unicode = "üôÇ" OR emoji.custom_emoji.uid = "{uid}" OR
   * user.name = "users/{user}"
   * emoji.unicode = "üôÇ" OR emoji.custom_emoji.uid = "{uid}"
   * AND user.name = "users/{user}"
   * ```
   *
   * Invalid queries are rejected by the server with an `INVALID_ARGUMENT`
   * error.
   */
  filter: string;
}

/** Response to a list reactions request. */
export interface ListReactionsResponse {
  /** List of reactions in the requested (or first) page. */
  reactions: Reaction[];
  /**
   * Continuation token to retrieve the next page of results. It's empty
   * for the last page of results.
   */
  nextPageToken: string;
}

/** Deletes a reaction to a message. */
export interface DeleteReactionRequest {
  /**
   * Required. Name of the reaction to delete.
   *
   * Format: `spaces/{space}/messages/{message}/reactions/{reaction}`
   */
  name: string;
}

function createBaseReaction(): Reaction {
  return { name: "", user: undefined, emoji: undefined };
}

export const Reaction: MessageFns<Reaction> = {
  encode(message: Reaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(18).fork()).join();
    }
    if (message.emoji !== undefined) {
      Emoji.encode(message.emoji, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.emoji = Emoji.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reaction {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      emoji: isSet(object.emoji) ? Emoji.fromJSON(object.emoji) : undefined,
    };
  },

  toJSON(message: Reaction): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.emoji !== undefined) {
      obj.emoji = Emoji.toJSON(message.emoji);
    }
    return obj;
  },

  create(base?: DeepPartial<Reaction>): Reaction {
    return Reaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Reaction>): Reaction {
    const message = createBaseReaction();
    message.name = object.name ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.emoji = (object.emoji !== undefined && object.emoji !== null) ? Emoji.fromPartial(object.emoji) : undefined;
    return message;
  },
};

function createBaseEmoji(): Emoji {
  return { unicode: undefined, customEmoji: undefined };
}

export const Emoji: MessageFns<Emoji> = {
  encode(message: Emoji, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unicode !== undefined) {
      writer.uint32(10).string(message.unicode);
    }
    if (message.customEmoji !== undefined) {
      CustomEmoji.encode(message.customEmoji, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Emoji {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmoji();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.unicode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customEmoji = CustomEmoji.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Emoji {
    return {
      unicode: isSet(object.unicode) ? globalThis.String(object.unicode) : undefined,
      customEmoji: isSet(object.customEmoji) ? CustomEmoji.fromJSON(object.customEmoji) : undefined,
    };
  },

  toJSON(message: Emoji): unknown {
    const obj: any = {};
    if (message.unicode !== undefined) {
      obj.unicode = message.unicode;
    }
    if (message.customEmoji !== undefined) {
      obj.customEmoji = CustomEmoji.toJSON(message.customEmoji);
    }
    return obj;
  },

  create(base?: DeepPartial<Emoji>): Emoji {
    return Emoji.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Emoji>): Emoji {
    const message = createBaseEmoji();
    message.unicode = object.unicode ?? undefined;
    message.customEmoji = (object.customEmoji !== undefined && object.customEmoji !== null)
      ? CustomEmoji.fromPartial(object.customEmoji)
      : undefined;
    return message;
  },
};

function createBaseCustomEmoji(): CustomEmoji {
  return { uid: "" };
}

export const CustomEmoji: MessageFns<CustomEmoji> = {
  encode(message: CustomEmoji, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomEmoji {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomEmoji();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomEmoji {
    return { uid: isSet(object.uid) ? globalThis.String(object.uid) : "" };
  },

  toJSON(message: CustomEmoji): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomEmoji>): CustomEmoji {
    return CustomEmoji.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomEmoji>): CustomEmoji {
    const message = createBaseCustomEmoji();
    message.uid = object.uid ?? "";
    return message;
  },
};

function createBaseEmojiReactionSummary(): EmojiReactionSummary {
  return { emoji: undefined, reactionCount: undefined };
}

export const EmojiReactionSummary: MessageFns<EmojiReactionSummary> = {
  encode(message: EmojiReactionSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emoji !== undefined) {
      Emoji.encode(message.emoji, writer.uint32(10).fork()).join();
    }
    if (message.reactionCount !== undefined) {
      writer.uint32(16).int32(message.reactionCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmojiReactionSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmojiReactionSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.emoji = Emoji.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reactionCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmojiReactionSummary {
    return {
      emoji: isSet(object.emoji) ? Emoji.fromJSON(object.emoji) : undefined,
      reactionCount: isSet(object.reactionCount) ? globalThis.Number(object.reactionCount) : undefined,
    };
  },

  toJSON(message: EmojiReactionSummary): unknown {
    const obj: any = {};
    if (message.emoji !== undefined) {
      obj.emoji = Emoji.toJSON(message.emoji);
    }
    if (message.reactionCount !== undefined) {
      obj.reactionCount = Math.round(message.reactionCount);
    }
    return obj;
  },

  create(base?: DeepPartial<EmojiReactionSummary>): EmojiReactionSummary {
    return EmojiReactionSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EmojiReactionSummary>): EmojiReactionSummary {
    const message = createBaseEmojiReactionSummary();
    message.emoji = (object.emoji !== undefined && object.emoji !== null) ? Emoji.fromPartial(object.emoji) : undefined;
    message.reactionCount = object.reactionCount ?? undefined;
    return message;
  },
};

function createBaseCreateReactionRequest(): CreateReactionRequest {
  return { parent: "", reaction: undefined };
}

export const CreateReactionRequest: MessageFns<CreateReactionRequest> = {
  encode(message: CreateReactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.reaction !== undefined) {
      Reaction.encode(message.reaction, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reaction = Reaction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReactionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      reaction: isSet(object.reaction) ? Reaction.fromJSON(object.reaction) : undefined,
    };
  },

  toJSON(message: CreateReactionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.reaction !== undefined) {
      obj.reaction = Reaction.toJSON(message.reaction);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateReactionRequest>): CreateReactionRequest {
    return CreateReactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateReactionRequest>): CreateReactionRequest {
    const message = createBaseCreateReactionRequest();
    message.parent = object.parent ?? "";
    message.reaction = (object.reaction !== undefined && object.reaction !== null)
      ? Reaction.fromPartial(object.reaction)
      : undefined;
    return message;
  },
};

function createBaseListReactionsRequest(): ListReactionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListReactionsRequest: MessageFns<ListReactionsRequest> = {
  encode(message: ListReactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListReactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReactionsRequest>): ListReactionsRequest {
    return ListReactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReactionsRequest>): ListReactionsRequest {
    const message = createBaseListReactionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListReactionsResponse(): ListReactionsResponse {
  return { reactions: [], nextPageToken: "" };
}

export const ListReactionsResponse: MessageFns<ListReactionsResponse> = {
  encode(message: ListReactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reactions) {
      Reaction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reactions.push(Reaction.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReactionsResponse {
    return {
      reactions: globalThis.Array.isArray(object?.reactions)
        ? object.reactions.map((e: any) => Reaction.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListReactionsResponse): unknown {
    const obj: any = {};
    if (message.reactions?.length) {
      obj.reactions = message.reactions.map((e) => Reaction.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReactionsResponse>): ListReactionsResponse {
    return ListReactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReactionsResponse>): ListReactionsResponse {
    const message = createBaseListReactionsResponse();
    message.reactions = object.reactions?.map((e) => Reaction.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteReactionRequest(): DeleteReactionRequest {
  return { name: "" };
}

export const DeleteReactionRequest: MessageFns<DeleteReactionRequest> = {
  encode(message: DeleteReactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteReactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteReactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteReactionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteReactionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteReactionRequest>): DeleteReactionRequest {
    return DeleteReactionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteReactionRequest>): DeleteReactionRequest {
    const message = createBaseDeleteReactionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
