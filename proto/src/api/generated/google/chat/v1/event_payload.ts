// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/chat/v1/event_payload.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Membership } from "./membership.js";
import { Message } from "./message.js";
import { Reaction } from "./reaction.js";
import { Space } from "./space.js";

export const protobufPackage = "google.chat.v1";

/**
 * Event payload for a new membership.
 *
 * Event type: `google.workspace.chat.membership.v1.created`.
 */
export interface MembershipCreatedEventData {
  /** The new membership. */
  membership: Membership | undefined;
}

/**
 * Event payload for a deleted membership.
 *
 * Event type: `google.workspace.chat.membership.v1.deleted`
 */
export interface MembershipDeletedEventData {
  /** The deleted membership. Only the `name` and `state` fields are populated. */
  membership: Membership | undefined;
}

/**
 * Event payload for an updated membership.
 *
 * Event type: `google.workspace.chat.membership.v1.updated`
 */
export interface MembershipUpdatedEventData {
  /** The updated membership. */
  membership: Membership | undefined;
}

/**
 * Event payload for multiple new memberships.
 *
 * Event type: `google.workspace.chat.membership.v1.batchCreated`
 */
export interface MembershipBatchCreatedEventData {
  /** A list of new memberships. */
  memberships: MembershipCreatedEventData[];
}

/**
 * Event payload for multiple updated memberships.
 *
 * Event type: `google.workspace.chat.membership.v1.batchUpdated`
 */
export interface MembershipBatchUpdatedEventData {
  /** A list of updated memberships. */
  memberships: MembershipUpdatedEventData[];
}

/**
 * Event payload for multiple deleted memberships.
 *
 * Event type: `google.workspace.chat.membership.v1.batchDeleted`
 */
export interface MembershipBatchDeletedEventData {
  /** A list of deleted memberships. */
  memberships: MembershipDeletedEventData[];
}

/**
 * Event payload for a new message.
 *
 * Event type: `google.workspace.chat.message.v1.created`
 */
export interface MessageCreatedEventData {
  /** The new message. */
  message: Message | undefined;
}

/**
 * Event payload for an updated message.
 *
 * Event type: `google.workspace.chat.message.v1.updated`
 */
export interface MessageUpdatedEventData {
  /** The updated message. */
  message: Message | undefined;
}

/**
 * Event payload for a deleted message.
 *
 * Event type: `google.workspace.chat.message.v1.deleted`
 */
export interface MessageDeletedEventData {
  /**
   * The deleted message. Only the `name`, `createTime`, `deleteTime`, and
   * `deletionMetadata` fields are populated.
   */
  message: Message | undefined;
}

/**
 * Event payload for multiple new messages.
 *
 * Event type: `google.workspace.chat.message.v1.batchCreated`
 */
export interface MessageBatchCreatedEventData {
  /** A list of new messages. */
  messages: MessageCreatedEventData[];
}

/**
 * Event payload for multiple updated messages.
 *
 * Event type: `google.workspace.chat.message.v1.batchUpdated`
 */
export interface MessageBatchUpdatedEventData {
  /** A list of updated messages. */
  messages: MessageUpdatedEventData[];
}

/**
 * Event payload for multiple deleted messages.
 *
 * Event type: `google.workspace.chat.message.v1.batchDeleted`
 */
export interface MessageBatchDeletedEventData {
  /** A list of deleted messages. */
  messages: MessageDeletedEventData[];
}

/**
 * Event payload for an updated space.
 *
 * Event type: `google.workspace.chat.space.v1.updated`
 */
export interface SpaceUpdatedEventData {
  /** The updated space. */
  space: Space | undefined;
}

/**
 * Event payload for multiple updates to a space.
 *
 * Event type: `google.workspace.chat.space.v1.batchUpdated`
 */
export interface SpaceBatchUpdatedEventData {
  /** A list of updated spaces. */
  spaces: SpaceUpdatedEventData[];
}

/**
 * Event payload for a new reaction.
 *
 * Event type: `google.workspace.chat.reaction.v1.created`
 */
export interface ReactionCreatedEventData {
  /** The new reaction. */
  reaction: Reaction | undefined;
}

/**
 * Event payload for a deleted reaction.
 *
 * Type: `google.workspace.chat.reaction.v1.deleted`
 */
export interface ReactionDeletedEventData {
  /** The deleted reaction. */
  reaction: Reaction | undefined;
}

/**
 * Event payload for multiple new reactions.
 *
 * Event type: `google.workspace.chat.reaction.v1.batchCreated`
 */
export interface ReactionBatchCreatedEventData {
  /** A list of new reactions. */
  reactions: ReactionCreatedEventData[];
}

/**
 * Event payload for multiple deleted reactions.
 *
 * Event type: `google.workspace.chat.reaction.v1.batchDeleted`
 */
export interface ReactionBatchDeletedEventData {
  /** A list of deleted reactions. */
  reactions: ReactionDeletedEventData[];
}

function createBaseMembershipCreatedEventData(): MembershipCreatedEventData {
  return { membership: undefined };
}

export const MembershipCreatedEventData: MessageFns<MembershipCreatedEventData> = {
  encode(message: MembershipCreatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.membership !== undefined) {
      Membership.encode(message.membership, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipCreatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipCreatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.membership = Membership.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipCreatedEventData {
    return { membership: isSet(object.membership) ? Membership.fromJSON(object.membership) : undefined };
  },

  toJSON(message: MembershipCreatedEventData): unknown {
    const obj: any = {};
    if (message.membership !== undefined) {
      obj.membership = Membership.toJSON(message.membership);
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipCreatedEventData>): MembershipCreatedEventData {
    return MembershipCreatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipCreatedEventData>): MembershipCreatedEventData {
    const message = createBaseMembershipCreatedEventData();
    message.membership = (object.membership !== undefined && object.membership !== null)
      ? Membership.fromPartial(object.membership)
      : undefined;
    return message;
  },
};

function createBaseMembershipDeletedEventData(): MembershipDeletedEventData {
  return { membership: undefined };
}

export const MembershipDeletedEventData: MessageFns<MembershipDeletedEventData> = {
  encode(message: MembershipDeletedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.membership !== undefined) {
      Membership.encode(message.membership, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipDeletedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipDeletedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.membership = Membership.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipDeletedEventData {
    return { membership: isSet(object.membership) ? Membership.fromJSON(object.membership) : undefined };
  },

  toJSON(message: MembershipDeletedEventData): unknown {
    const obj: any = {};
    if (message.membership !== undefined) {
      obj.membership = Membership.toJSON(message.membership);
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipDeletedEventData>): MembershipDeletedEventData {
    return MembershipDeletedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipDeletedEventData>): MembershipDeletedEventData {
    const message = createBaseMembershipDeletedEventData();
    message.membership = (object.membership !== undefined && object.membership !== null)
      ? Membership.fromPartial(object.membership)
      : undefined;
    return message;
  },
};

function createBaseMembershipUpdatedEventData(): MembershipUpdatedEventData {
  return { membership: undefined };
}

export const MembershipUpdatedEventData: MessageFns<MembershipUpdatedEventData> = {
  encode(message: MembershipUpdatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.membership !== undefined) {
      Membership.encode(message.membership, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipUpdatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipUpdatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.membership = Membership.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipUpdatedEventData {
    return { membership: isSet(object.membership) ? Membership.fromJSON(object.membership) : undefined };
  },

  toJSON(message: MembershipUpdatedEventData): unknown {
    const obj: any = {};
    if (message.membership !== undefined) {
      obj.membership = Membership.toJSON(message.membership);
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipUpdatedEventData>): MembershipUpdatedEventData {
    return MembershipUpdatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipUpdatedEventData>): MembershipUpdatedEventData {
    const message = createBaseMembershipUpdatedEventData();
    message.membership = (object.membership !== undefined && object.membership !== null)
      ? Membership.fromPartial(object.membership)
      : undefined;
    return message;
  },
};

function createBaseMembershipBatchCreatedEventData(): MembershipBatchCreatedEventData {
  return { memberships: [] };
}

export const MembershipBatchCreatedEventData: MessageFns<MembershipBatchCreatedEventData> = {
  encode(message: MembershipBatchCreatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.memberships) {
      MembershipCreatedEventData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipBatchCreatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipBatchCreatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.memberships.push(MembershipCreatedEventData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipBatchCreatedEventData {
    return {
      memberships: globalThis.Array.isArray(object?.memberships)
        ? object.memberships.map((e: any) => MembershipCreatedEventData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MembershipBatchCreatedEventData): unknown {
    const obj: any = {};
    if (message.memberships?.length) {
      obj.memberships = message.memberships.map((e) => MembershipCreatedEventData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipBatchCreatedEventData>): MembershipBatchCreatedEventData {
    return MembershipBatchCreatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipBatchCreatedEventData>): MembershipBatchCreatedEventData {
    const message = createBaseMembershipBatchCreatedEventData();
    message.memberships = object.memberships?.map((e) => MembershipCreatedEventData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMembershipBatchUpdatedEventData(): MembershipBatchUpdatedEventData {
  return { memberships: [] };
}

export const MembershipBatchUpdatedEventData: MessageFns<MembershipBatchUpdatedEventData> = {
  encode(message: MembershipBatchUpdatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.memberships) {
      MembershipUpdatedEventData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipBatchUpdatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipBatchUpdatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.memberships.push(MembershipUpdatedEventData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipBatchUpdatedEventData {
    return {
      memberships: globalThis.Array.isArray(object?.memberships)
        ? object.memberships.map((e: any) => MembershipUpdatedEventData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MembershipBatchUpdatedEventData): unknown {
    const obj: any = {};
    if (message.memberships?.length) {
      obj.memberships = message.memberships.map((e) => MembershipUpdatedEventData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipBatchUpdatedEventData>): MembershipBatchUpdatedEventData {
    return MembershipBatchUpdatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipBatchUpdatedEventData>): MembershipBatchUpdatedEventData {
    const message = createBaseMembershipBatchUpdatedEventData();
    message.memberships = object.memberships?.map((e) => MembershipUpdatedEventData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMembershipBatchDeletedEventData(): MembershipBatchDeletedEventData {
  return { memberships: [] };
}

export const MembershipBatchDeletedEventData: MessageFns<MembershipBatchDeletedEventData> = {
  encode(message: MembershipBatchDeletedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.memberships) {
      MembershipDeletedEventData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MembershipBatchDeletedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMembershipBatchDeletedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.memberships.push(MembershipDeletedEventData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MembershipBatchDeletedEventData {
    return {
      memberships: globalThis.Array.isArray(object?.memberships)
        ? object.memberships.map((e: any) => MembershipDeletedEventData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MembershipBatchDeletedEventData): unknown {
    const obj: any = {};
    if (message.memberships?.length) {
      obj.memberships = message.memberships.map((e) => MembershipDeletedEventData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MembershipBatchDeletedEventData>): MembershipBatchDeletedEventData {
    return MembershipBatchDeletedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MembershipBatchDeletedEventData>): MembershipBatchDeletedEventData {
    const message = createBaseMembershipBatchDeletedEventData();
    message.memberships = object.memberships?.map((e) => MembershipDeletedEventData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessageCreatedEventData(): MessageCreatedEventData {
  return { message: undefined };
}

export const MessageCreatedEventData: MessageFns<MessageCreatedEventData> = {
  encode(message: MessageCreatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageCreatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageCreatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageCreatedEventData {
    return { message: isSet(object.message) ? Message.fromJSON(object.message) : undefined };
  },

  toJSON(message: MessageCreatedEventData): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageCreatedEventData>): MessageCreatedEventData {
    return MessageCreatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageCreatedEventData>): MessageCreatedEventData {
    const message = createBaseMessageCreatedEventData();
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseMessageUpdatedEventData(): MessageUpdatedEventData {
  return { message: undefined };
}

export const MessageUpdatedEventData: MessageFns<MessageUpdatedEventData> = {
  encode(message: MessageUpdatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageUpdatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageUpdatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageUpdatedEventData {
    return { message: isSet(object.message) ? Message.fromJSON(object.message) : undefined };
  },

  toJSON(message: MessageUpdatedEventData): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageUpdatedEventData>): MessageUpdatedEventData {
    return MessageUpdatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageUpdatedEventData>): MessageUpdatedEventData {
    const message = createBaseMessageUpdatedEventData();
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseMessageDeletedEventData(): MessageDeletedEventData {
  return { message: undefined };
}

export const MessageDeletedEventData: MessageFns<MessageDeletedEventData> = {
  encode(message: MessageDeletedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageDeletedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageDeletedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageDeletedEventData {
    return { message: isSet(object.message) ? Message.fromJSON(object.message) : undefined };
  },

  toJSON(message: MessageDeletedEventData): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<MessageDeletedEventData>): MessageDeletedEventData {
    return MessageDeletedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageDeletedEventData>): MessageDeletedEventData {
    const message = createBaseMessageDeletedEventData();
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseMessageBatchCreatedEventData(): MessageBatchCreatedEventData {
  return { messages: [] };
}

export const MessageBatchCreatedEventData: MessageFns<MessageBatchCreatedEventData> = {
  encode(message: MessageBatchCreatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      MessageCreatedEventData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageBatchCreatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageBatchCreatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(MessageCreatedEventData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageBatchCreatedEventData {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => MessageCreatedEventData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessageBatchCreatedEventData): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => MessageCreatedEventData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MessageBatchCreatedEventData>): MessageBatchCreatedEventData {
    return MessageBatchCreatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageBatchCreatedEventData>): MessageBatchCreatedEventData {
    const message = createBaseMessageBatchCreatedEventData();
    message.messages = object.messages?.map((e) => MessageCreatedEventData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessageBatchUpdatedEventData(): MessageBatchUpdatedEventData {
  return { messages: [] };
}

export const MessageBatchUpdatedEventData: MessageFns<MessageBatchUpdatedEventData> = {
  encode(message: MessageBatchUpdatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      MessageUpdatedEventData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageBatchUpdatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageBatchUpdatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(MessageUpdatedEventData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageBatchUpdatedEventData {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => MessageUpdatedEventData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessageBatchUpdatedEventData): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => MessageUpdatedEventData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MessageBatchUpdatedEventData>): MessageBatchUpdatedEventData {
    return MessageBatchUpdatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageBatchUpdatedEventData>): MessageBatchUpdatedEventData {
    const message = createBaseMessageBatchUpdatedEventData();
    message.messages = object.messages?.map((e) => MessageUpdatedEventData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMessageBatchDeletedEventData(): MessageBatchDeletedEventData {
  return { messages: [] };
}

export const MessageBatchDeletedEventData: MessageFns<MessageBatchDeletedEventData> = {
  encode(message: MessageBatchDeletedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      MessageDeletedEventData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageBatchDeletedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageBatchDeletedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(MessageDeletedEventData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageBatchDeletedEventData {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => MessageDeletedEventData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessageBatchDeletedEventData): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => MessageDeletedEventData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MessageBatchDeletedEventData>): MessageBatchDeletedEventData {
    return MessageBatchDeletedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageBatchDeletedEventData>): MessageBatchDeletedEventData {
    const message = createBaseMessageBatchDeletedEventData();
    message.messages = object.messages?.map((e) => MessageDeletedEventData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSpaceUpdatedEventData(): SpaceUpdatedEventData {
  return { space: undefined };
}

export const SpaceUpdatedEventData: MessageFns<SpaceUpdatedEventData> = {
  encode(message: SpaceUpdatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.space !== undefined) {
      Space.encode(message.space, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpaceUpdatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpaceUpdatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.space = Space.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpaceUpdatedEventData {
    return { space: isSet(object.space) ? Space.fromJSON(object.space) : undefined };
  },

  toJSON(message: SpaceUpdatedEventData): unknown {
    const obj: any = {};
    if (message.space !== undefined) {
      obj.space = Space.toJSON(message.space);
    }
    return obj;
  },

  create(base?: DeepPartial<SpaceUpdatedEventData>): SpaceUpdatedEventData {
    return SpaceUpdatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpaceUpdatedEventData>): SpaceUpdatedEventData {
    const message = createBaseSpaceUpdatedEventData();
    message.space = (object.space !== undefined && object.space !== null) ? Space.fromPartial(object.space) : undefined;
    return message;
  },
};

function createBaseSpaceBatchUpdatedEventData(): SpaceBatchUpdatedEventData {
  return { spaces: [] };
}

export const SpaceBatchUpdatedEventData: MessageFns<SpaceBatchUpdatedEventData> = {
  encode(message: SpaceBatchUpdatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.spaces) {
      SpaceUpdatedEventData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpaceBatchUpdatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpaceBatchUpdatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.spaces.push(SpaceUpdatedEventData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpaceBatchUpdatedEventData {
    return {
      spaces: globalThis.Array.isArray(object?.spaces)
        ? object.spaces.map((e: any) => SpaceUpdatedEventData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SpaceBatchUpdatedEventData): unknown {
    const obj: any = {};
    if (message.spaces?.length) {
      obj.spaces = message.spaces.map((e) => SpaceUpdatedEventData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SpaceBatchUpdatedEventData>): SpaceBatchUpdatedEventData {
    return SpaceBatchUpdatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpaceBatchUpdatedEventData>): SpaceBatchUpdatedEventData {
    const message = createBaseSpaceBatchUpdatedEventData();
    message.spaces = object.spaces?.map((e) => SpaceUpdatedEventData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReactionCreatedEventData(): ReactionCreatedEventData {
  return { reaction: undefined };
}

export const ReactionCreatedEventData: MessageFns<ReactionCreatedEventData> = {
  encode(message: ReactionCreatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reaction !== undefined) {
      Reaction.encode(message.reaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReactionCreatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReactionCreatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reaction = Reaction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReactionCreatedEventData {
    return { reaction: isSet(object.reaction) ? Reaction.fromJSON(object.reaction) : undefined };
  },

  toJSON(message: ReactionCreatedEventData): unknown {
    const obj: any = {};
    if (message.reaction !== undefined) {
      obj.reaction = Reaction.toJSON(message.reaction);
    }
    return obj;
  },

  create(base?: DeepPartial<ReactionCreatedEventData>): ReactionCreatedEventData {
    return ReactionCreatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReactionCreatedEventData>): ReactionCreatedEventData {
    const message = createBaseReactionCreatedEventData();
    message.reaction = (object.reaction !== undefined && object.reaction !== null)
      ? Reaction.fromPartial(object.reaction)
      : undefined;
    return message;
  },
};

function createBaseReactionDeletedEventData(): ReactionDeletedEventData {
  return { reaction: undefined };
}

export const ReactionDeletedEventData: MessageFns<ReactionDeletedEventData> = {
  encode(message: ReactionDeletedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reaction !== undefined) {
      Reaction.encode(message.reaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReactionDeletedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReactionDeletedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reaction = Reaction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReactionDeletedEventData {
    return { reaction: isSet(object.reaction) ? Reaction.fromJSON(object.reaction) : undefined };
  },

  toJSON(message: ReactionDeletedEventData): unknown {
    const obj: any = {};
    if (message.reaction !== undefined) {
      obj.reaction = Reaction.toJSON(message.reaction);
    }
    return obj;
  },

  create(base?: DeepPartial<ReactionDeletedEventData>): ReactionDeletedEventData {
    return ReactionDeletedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReactionDeletedEventData>): ReactionDeletedEventData {
    const message = createBaseReactionDeletedEventData();
    message.reaction = (object.reaction !== undefined && object.reaction !== null)
      ? Reaction.fromPartial(object.reaction)
      : undefined;
    return message;
  },
};

function createBaseReactionBatchCreatedEventData(): ReactionBatchCreatedEventData {
  return { reactions: [] };
}

export const ReactionBatchCreatedEventData: MessageFns<ReactionBatchCreatedEventData> = {
  encode(message: ReactionBatchCreatedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reactions) {
      ReactionCreatedEventData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReactionBatchCreatedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReactionBatchCreatedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reactions.push(ReactionCreatedEventData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReactionBatchCreatedEventData {
    return {
      reactions: globalThis.Array.isArray(object?.reactions)
        ? object.reactions.map((e: any) => ReactionCreatedEventData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReactionBatchCreatedEventData): unknown {
    const obj: any = {};
    if (message.reactions?.length) {
      obj.reactions = message.reactions.map((e) => ReactionCreatedEventData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReactionBatchCreatedEventData>): ReactionBatchCreatedEventData {
    return ReactionBatchCreatedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReactionBatchCreatedEventData>): ReactionBatchCreatedEventData {
    const message = createBaseReactionBatchCreatedEventData();
    message.reactions = object.reactions?.map((e) => ReactionCreatedEventData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReactionBatchDeletedEventData(): ReactionBatchDeletedEventData {
  return { reactions: [] };
}

export const ReactionBatchDeletedEventData: MessageFns<ReactionBatchDeletedEventData> = {
  encode(message: ReactionBatchDeletedEventData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reactions) {
      ReactionDeletedEventData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReactionBatchDeletedEventData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReactionBatchDeletedEventData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reactions.push(ReactionDeletedEventData.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReactionBatchDeletedEventData {
    return {
      reactions: globalThis.Array.isArray(object?.reactions)
        ? object.reactions.map((e: any) => ReactionDeletedEventData.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReactionBatchDeletedEventData): unknown {
    const obj: any = {};
    if (message.reactions?.length) {
      obj.reactions = message.reactions.map((e) => ReactionDeletedEventData.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReactionBatchDeletedEventData>): ReactionBatchDeletedEventData {
    return ReactionBatchDeletedEventData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReactionBatchDeletedEventData>): ReactionBatchDeletedEventData {
    const message = createBaseReactionBatchDeletedEventData();
    message.reactions = object.reactions?.map((e) => ReactionDeletedEventData.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
