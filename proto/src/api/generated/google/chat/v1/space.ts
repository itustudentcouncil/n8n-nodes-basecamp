// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/chat/v1/space.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../protobuf/field_mask.js";
import { Timestamp } from "../../protobuf/timestamp.js";
import { HistoryState, historyStateFromJSON, historyStateToJSON } from "./history_state.js";

export const protobufPackage = "google.chat.v1";

/**
 * A space in Google Chat. Spaces are conversations between two or more users
 * or 1:1 messages between a user and a Chat app.
 */
export interface Space {
  /**
   * Resource name of the space.
   *
   * Format: `spaces/{space}`
   */
  name: string;
  /**
   * Output only. Deprecated: Use `space_type` instead.
   * The type of a space.
   *
   * @deprecated
   */
  type: Space_Type;
  /**
   * The type of space. Required when creating a space or updating the space
   * type of a space. Output only for other usage.
   */
  spaceType: Space_SpaceType;
  /**
   * Optional. Whether the space is a DM between a Chat app and a single
   * human.
   */
  singleUserBotDm: boolean;
  /**
   * Output only. Deprecated: Use `spaceThreadingState` instead.
   * Whether messages are threaded in this space.
   *
   * @deprecated
   */
  threaded: boolean;
  /**
   * The space's display name. Required when [creating a
   * space](https://developers.google.com/workspace/chat/api/reference/rest/v1/spaces/create).
   * If you receive the error message `ALREADY_EXISTS` when creating a space or
   * updating the `displayName`, try a different `displayName`. An
   * existing space within the Google Workspace organization might already use
   * this display name.
   *
   * For direct messages, this field might be empty.
   *
   * Supports up to 128 characters.
   */
  displayName: string;
  /**
   * Immutable. Whether this space permits any Google Chat user as a member.
   * Input when creating a space in a Google Workspace organization. Omit this
   * field when creating spaces in the following conditions:
   *
   *   * The authenticated user uses a consumer account (unmanaged user
   *     account). By default, a space created by a consumer account permits any
   *     Google Chat user.
   *
   *   * The space is used to [import data to Google Chat]
   *     (https://developers.google.com/chat/api/guides/import-data-overview)
   *     because import mode spaces must only permit members from the same
   *     Google Workspace organization. However, as part of the [Google
   *     Workspace Developer Preview
   *     Program](https://developers.google.com/workspace/preview), import mode
   *     spaces can permit any Google Chat user so this field can then be set
   *     for import mode spaces.
   *
   * For existing spaces, this field is output only.
   */
  externalUserAllowed: boolean;
  /** Output only. The threading state in the Chat space. */
  spaceThreadingState: Space_SpaceThreadingState;
  /** Details about the space including description and rules. */
  spaceDetails:
    | Space_SpaceDetails
    | undefined;
  /** The message history state for messages and threads in this space. */
  spaceHistoryState: HistoryState;
  /**
   * Optional. Whether this space is created in `Import Mode` as part of a data
   * migration into Google Workspace. While spaces are being imported, they
   * aren't visible to users until the import is complete.
   */
  importMode: boolean;
  /**
   * Optional. Immutable. For spaces created in Chat, the time the space was
   * created. This field is output only, except when used in import mode spaces.
   *
   * For import mode spaces, set this field to the historical timestamp at which
   * the space was created in the source in order to preserve the original
   * creation time.
   *
   * Only populated in the output when `spaceType` is `GROUP_CHAT` or `SPACE`.
   */
  createTime:
    | Date
    | undefined;
  /** Output only. Timestamp of the last message in the space. */
  lastActiveTime:
    | Date
    | undefined;
  /**
   * Output only. For direct message (DM) spaces with a Chat app, whether the
   * space was created by a Google Workspace administrator. Administrators can
   * install and set up a direct message with a Chat app on behalf of users in
   * their organization.
   *
   * To support admin install, your Chat app must feature direct messaging.
   */
  adminInstalled: boolean;
  /**
   * Output only. The count of joined memberships grouped by member type.
   * Populated when the `space_type` is `SPACE`, `DIRECT_MESSAGE` or
   * `GROUP_CHAT`.
   */
  membershipCount:
    | Space_MembershipCount
    | undefined;
  /**
   * Optional. Specifies the [access
   * setting](https://support.google.com/chat/answer/11971020) of the space.
   * Only populated when the `space_type` is `SPACE`.
   */
  accessSettings:
    | Space_AccessSettings
    | undefined;
  /** Output only. The URI for a user to access the space. */
  spaceUri: string;
}

/** Deprecated: Use `SpaceType` instead. */
export enum Space_Type {
  /** TYPE_UNSPECIFIED - Reserved. */
  TYPE_UNSPECIFIED = 0,
  /** ROOM - Conversations between two or more humans. */
  ROOM = 1,
  /**
   * DM - 1:1 Direct Message between a human and a Chat app, where all messages are
   * flat. Note that this doesn't include direct messages between two humans.
   */
  DM = 2,
  UNRECOGNIZED = -1,
}

export function space_TypeFromJSON(object: any): Space_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Space_Type.TYPE_UNSPECIFIED;
    case 1:
    case "ROOM":
      return Space_Type.ROOM;
    case 2:
    case "DM":
      return Space_Type.DM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Space_Type.UNRECOGNIZED;
  }
}

export function space_TypeToJSON(object: Space_Type): string {
  switch (object) {
    case Space_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Space_Type.ROOM:
      return "ROOM";
    case Space_Type.DM:
      return "DM";
    case Space_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The type of space. Required when creating or updating a space. Output only
 * for other usage.
 */
export enum Space_SpaceType {
  /** SPACE_TYPE_UNSPECIFIED - Reserved. */
  SPACE_TYPE_UNSPECIFIED = 0,
  /**
   * SPACE - A place where people send messages, share files, and collaborate.
   * A `SPACE` can include Chat apps.
   */
  SPACE = 1,
  /**
   * GROUP_CHAT - Group conversations between 3 or more people.
   * A `GROUP_CHAT` can include Chat apps.
   */
  GROUP_CHAT = 2,
  /** DIRECT_MESSAGE - 1:1 messages between two humans or a human and a Chat app. */
  DIRECT_MESSAGE = 3,
  UNRECOGNIZED = -1,
}

export function space_SpaceTypeFromJSON(object: any): Space_SpaceType {
  switch (object) {
    case 0:
    case "SPACE_TYPE_UNSPECIFIED":
      return Space_SpaceType.SPACE_TYPE_UNSPECIFIED;
    case 1:
    case "SPACE":
      return Space_SpaceType.SPACE;
    case 2:
    case "GROUP_CHAT":
      return Space_SpaceType.GROUP_CHAT;
    case 3:
    case "DIRECT_MESSAGE":
      return Space_SpaceType.DIRECT_MESSAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Space_SpaceType.UNRECOGNIZED;
  }
}

export function space_SpaceTypeToJSON(object: Space_SpaceType): string {
  switch (object) {
    case Space_SpaceType.SPACE_TYPE_UNSPECIFIED:
      return "SPACE_TYPE_UNSPECIFIED";
    case Space_SpaceType.SPACE:
      return "SPACE";
    case Space_SpaceType.GROUP_CHAT:
      return "GROUP_CHAT";
    case Space_SpaceType.DIRECT_MESSAGE:
      return "DIRECT_MESSAGE";
    case Space_SpaceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies the type of threading state in the Chat space. */
export enum Space_SpaceThreadingState {
  /** SPACE_THREADING_STATE_UNSPECIFIED - Reserved. */
  SPACE_THREADING_STATE_UNSPECIFIED = 0,
  /**
   * THREADED_MESSAGES - Named spaces that support message threads. When users respond to a
   * message, they can reply in-thread, which keeps their response in the
   * context of the original message.
   */
  THREADED_MESSAGES = 2,
  /**
   * GROUPED_MESSAGES - Named spaces where the conversation is organized by topic. Topics and
   * their replies are grouped together.
   */
  GROUPED_MESSAGES = 3,
  /**
   * UNTHREADED_MESSAGES - Direct messages (DMs) between two people and group conversations between
   * 3 or more people.
   */
  UNTHREADED_MESSAGES = 4,
  UNRECOGNIZED = -1,
}

export function space_SpaceThreadingStateFromJSON(object: any): Space_SpaceThreadingState {
  switch (object) {
    case 0:
    case "SPACE_THREADING_STATE_UNSPECIFIED":
      return Space_SpaceThreadingState.SPACE_THREADING_STATE_UNSPECIFIED;
    case 2:
    case "THREADED_MESSAGES":
      return Space_SpaceThreadingState.THREADED_MESSAGES;
    case 3:
    case "GROUPED_MESSAGES":
      return Space_SpaceThreadingState.GROUPED_MESSAGES;
    case 4:
    case "UNTHREADED_MESSAGES":
      return Space_SpaceThreadingState.UNTHREADED_MESSAGES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Space_SpaceThreadingState.UNRECOGNIZED;
  }
}

export function space_SpaceThreadingStateToJSON(object: Space_SpaceThreadingState): string {
  switch (object) {
    case Space_SpaceThreadingState.SPACE_THREADING_STATE_UNSPECIFIED:
      return "SPACE_THREADING_STATE_UNSPECIFIED";
    case Space_SpaceThreadingState.THREADED_MESSAGES:
      return "THREADED_MESSAGES";
    case Space_SpaceThreadingState.GROUPED_MESSAGES:
      return "GROUPED_MESSAGES";
    case Space_SpaceThreadingState.UNTHREADED_MESSAGES:
      return "UNTHREADED_MESSAGES";
    case Space_SpaceThreadingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details about the space including description and rules. */
export interface Space_SpaceDetails {
  /**
   * Optional. A description of the space. For example, describe the space's
   * discussion topic, functional purpose, or participants.
   *
   * Supports up to 150 characters.
   */
  description: string;
  /**
   * Optional. The space's rules, expectations, and etiquette.
   *
   * Supports up to 5,000 characters.
   */
  guidelines: string;
}

/** Represents the count of memberships of a space, grouped into categories. */
export interface Space_MembershipCount {
  /**
   * Count of human users that have directly joined the space, not counting
   * users joined by having membership in a joined group.
   */
  joinedDirectHumanUserCount: number;
  /** Count of all groups that have directly joined the space. */
  joinedGroupCount: number;
}

/**
 * Represents the [access
 * setting](https://support.google.com/chat/answer/11971020) of the space.
 */
export interface Space_AccessSettings {
  /** Output only. Indicates the access state of the space. */
  accessState: Space_AccessSettings_AccessState;
  /**
   * Optional. The resource name of the [target
   * audience](https://support.google.com/a/answer/9934697) who can discover
   * the space, join the space, and preview the messages in the space. For
   * details, see [Make a space discoverable to a target
   * audience](https://developers.google.com/workspace/chat/space-target-audience).
   *
   * Format: `audiences/{audience}`
   *
   * To use the default target audience for the Google Workspace organization,
   * set to `audiences/default`.
   */
  audience: string;
}

/** Represents the access state of the space. */
export enum Space_AccessSettings_AccessState {
  /** ACCESS_STATE_UNSPECIFIED - Access state is unknown or not supported in this API. */
  ACCESS_STATE_UNSPECIFIED = 0,
  /** PRIVATE - Space is discoverable by added or invited members or groups. */
  PRIVATE = 1,
  /**
   * DISCOVERABLE - Space is discoverable by the selected [target
   * audience](https://support.google.com/a/answer/9934697), as well as
   * added or invited members or groups.
   */
  DISCOVERABLE = 2,
  UNRECOGNIZED = -1,
}

export function space_AccessSettings_AccessStateFromJSON(object: any): Space_AccessSettings_AccessState {
  switch (object) {
    case 0:
    case "ACCESS_STATE_UNSPECIFIED":
      return Space_AccessSettings_AccessState.ACCESS_STATE_UNSPECIFIED;
    case 1:
    case "PRIVATE":
      return Space_AccessSettings_AccessState.PRIVATE;
    case 2:
    case "DISCOVERABLE":
      return Space_AccessSettings_AccessState.DISCOVERABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Space_AccessSettings_AccessState.UNRECOGNIZED;
  }
}

export function space_AccessSettings_AccessStateToJSON(object: Space_AccessSettings_AccessState): string {
  switch (object) {
    case Space_AccessSettings_AccessState.ACCESS_STATE_UNSPECIFIED:
      return "ACCESS_STATE_UNSPECIFIED";
    case Space_AccessSettings_AccessState.PRIVATE:
      return "PRIVATE";
    case Space_AccessSettings_AccessState.DISCOVERABLE:
      return "DISCOVERABLE";
    case Space_AccessSettings_AccessState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A request to create a named space. */
export interface CreateSpaceRequest {
  /**
   * Required. The `displayName` and `spaceType` fields must be populated.  Only
   * `SpaceType.SPACE` is supported.
   *
   * If you receive the error message `ALREADY_EXISTS` when creating a space,
   * try a different `displayName`. An existing space within the Google
   * Workspace organization might already use this display name.
   *
   * The space `name` is assigned on the server so anything specified in this
   * field will be ignored.
   */
  space:
    | Space
    | undefined;
  /**
   * Optional. A unique identifier for this request.
   * A random UUID is recommended.
   * Specifying an existing request ID returns the space created with that ID
   * instead of creating a new space.
   * Specifying an existing request ID from the same Chat app with a different
   * authenticated user returns an error.
   */
  requestId: string;
}

/** A request to list the spaces the caller is a member of. */
export interface ListSpacesRequest {
  /**
   * Optional. The maximum number of spaces to return. The service might return
   * fewer than this value.
   *
   * If unspecified, at most 100 spaces are returned.
   *
   * The maximum value is 1000. If you use a value more than 1000, it's
   * automatically changed to 1000.
   *
   * Negative values return an `INVALID_ARGUMENT` error.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous list spaces call.
   * Provide this parameter to retrieve the subsequent page.
   *
   * When paginating, the filter value should match the call that provided the
   * page token. Passing a different value may lead to unexpected results.
   */
  pageToken: string;
  /**
   * Optional. A query filter.
   *
   * You can filter spaces by the space type
   * ([`space_type`](https://developers.google.com/workspace/chat/api/reference/rest/v1/spaces#spacetype)).
   *
   * To filter by space type, you must specify valid enum value, such as
   * `SPACE` or `GROUP_CHAT` (the `space_type` can't be
   * `SPACE_TYPE_UNSPECIFIED`). To query for multiple space types, use the `OR`
   * operator.
   *
   * For example, the following queries are valid:
   *
   * ```
   * space_type = "SPACE"
   * spaceType = "GROUP_CHAT" OR spaceType = "DIRECT_MESSAGE"
   * ```
   *
   * Invalid queries are rejected by the server with an `INVALID_ARGUMENT`
   * error.
   */
  filter: string;
}

/** The response for a list spaces request. */
export interface ListSpacesResponse {
  /** List of spaces in the requested (or first) page. */
  spaces: Space[];
  /**
   * You can send a token as `pageToken` to retrieve the next page of
   * results. If empty, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** A request to return a single space. */
export interface GetSpaceRequest {
  /**
   * Required. Resource name of the space, in the form `spaces/{space}`.
   *
   * Format: `spaces/{space}`
   */
  name: string;
  /**
   * When `true`, the method runs using the user's Google Workspace
   * administrator privileges.
   *
   * The calling user must be a Google Workspace administrator with the
   * [manage chat and spaces conversations
   * privilege](https://support.google.com/a/answer/13369245).
   *
   * Requires the `chat.admin.spaces` or `chat.admin.spaces.readonly` [OAuth 2.0
   * scopes](https://developers.google.com/workspace/chat/authenticate-authorize#chat-api-scopes).
   */
  useAdminAccess: boolean;
}

/** A request to get direct message space based on the user resource. */
export interface FindDirectMessageRequest {
  /**
   * Required. Resource name of the user to find direct message with.
   *
   * Format: `users/{user}`, where `{user}` is either the `id` for the
   * [person](https://developers.google.com/people/api/rest/v1/people) from the
   * People API, or the `id` for the
   * [user](https://developers.google.com/admin-sdk/directory/reference/rest/v1/users)
   * in the Directory API. For example, if the People API profile ID is
   * `123456789`, you can find a direct message with that person by using
   * `users/123456789` as the `name`. When [authenticated as a
   * user](https://developers.google.com/workspace/chat/authenticate-authorize-chat-user),
   * you can use the email as an alias for `{user}`. For example,
   * `users/example@gmail.com` where `example@gmail.com` is the email of the
   * Google Chat user.
   */
  name: string;
}

/** A request to update a single space. */
export interface UpdateSpaceRequest {
  /**
   * Required. Space with fields to be updated. `Space.name` must be
   * populated in the form of `spaces/{space}`. Only fields
   * specified by `update_mask` are updated.
   */
  space:
    | Space
    | undefined;
  /**
   * Required. The updated field paths, comma separated if there are
   * multiple.
   *
   * Currently supported field paths:
   *
   * - `display_name` (Only supports changing the display name of a space with
   * the `SPACE` type, or when also including the `space_type` mask to change a
   * `GROUP_CHAT` space type to `SPACE`. Trying to update the display name of a
   * `GROUP_CHAT` or a `DIRECT_MESSAGE` space results in an invalid argument
   * error. If you receive the error message `ALREADY_EXISTS` when updating the
   * `displayName`, try a different `displayName`. An existing space within the
   * Google Workspace organization might already use this display name.)
   *
   * - `space_type` (Only supports changing a `GROUP_CHAT` space type to
   * `SPACE`. Include `display_name` together
   * with `space_type` in the update mask and ensure that the specified space
   * has a non-empty display name and the `SPACE` space type. Including the
   * `space_type` mask and the `SPACE` type in the specified space when updating
   * the display name is optional if the existing space already has the `SPACE`
   * type. Trying to update the space type in other ways results in an invalid
   * argument error).
   * `space_type` is not supported with admin access.
   *
   * - `space_details`
   *
   * - `space_history_state` (Supports [turning history on or off for the
   * space](https://support.google.com/chat/answer/7664687) if [the organization
   * allows users to change their history
   * setting](https://support.google.com/a/answer/7664184).
   * Warning: mutually exclusive with all other field paths.)
   * `space_history_state` is not supported with admin access.
   *
   * - `access_settings.audience` (Supports changing the [access
   * setting](https://support.google.com/chat/answer/11971020) of who can
   * discover the space, join the space, and preview the messages in space. If
   * no audience is specified in the access setting, the space's access setting
   * is updated to private. Warning: mutually exclusive with all other field
   * paths.)
   * `access_settings.audience` is not supported with admin access.
   *
   * - Developer Preview: Supports changing the [permission
   * settings](https://support.google.com/chat/answer/13340792) of a space,
   * supported field paths
   * include: `permission_settings.manage_members_and_groups`,
   * `permission_settings.modify_space_details`,
   * `permission_settings.toggle_history`,
   * `permission_settings.use_at_mention_all`,
   * `permission_settings.manage_apps`, `permission_settings.manage_webhooks`,
   * `permission_settings.reply_messages`
   *  (Warning: mutually exclusive with all other non-permission settings field
   * paths). `permission_settings` is not supported with admin access.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * When `true`, the method runs using the user's Google Workspace
   * administrator privileges.
   *
   * The calling user must be a Google Workspace administrator with the
   * [manage chat and spaces conversations
   * privilege](https://support.google.com/a/answer/13369245).
   *
   * Requires the `chat.admin.spaces` [OAuth 2.0
   * scope](https://developers.google.com/workspace/chat/authenticate-authorize#chat-api-scopes).
   *
   * Some `FieldMask` values are not supported using admin access. For details,
   * see the description of `update_mask`.
   */
  useAdminAccess: boolean;
}

/** Request to search for a list of spaces based on a query. */
export interface SearchSpacesRequest {
  /**
   * When `true`, the method runs using the user's Google Workspace
   * administrator privileges.
   *
   * The calling user must be a Google Workspace administrator with the
   * [manage chat and spaces conversations
   * privilege](https://support.google.com/a/answer/13369245).
   *
   * Requires either the `chat.admin.spaces.readonly` or `chat.admin.spaces`
   * [OAuth 2.0
   * scope](https://developers.google.com/workspace/chat/authenticate-authorize#chat-api-scopes).
   *
   * This method currently only supports admin access, thus only `true` is
   * accepted for this field.
   */
  useAdminAccess: boolean;
  /**
   * The maximum number of spaces to return. The service may return fewer than
   * this value.
   *
   * If unspecified, at most 100 spaces are returned.
   *
   * The maximum value is 1000. If you use a value more than 1000, it's
   * automatically changed to 1000.
   */
  pageSize: number;
  /**
   * A token, received from the previous search spaces call. Provide this
   * parameter to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided should match the call that
   * provided the page token. Passing different values to the other parameters
   * might lead to unexpected results.
   */
  pageToken: string;
  /**
   * Required. A search query.
   *
   * You can search by using the following parameters:
   *
   * - `create_time`
   * - `customer`
   * - `display_name`
   * - `external_user_allowed`
   * - `last_active_time`
   * - `space_history_state`
   * - `space_type`
   *
   * `create_time` and `last_active_time` accept a timestamp in
   * [RFC-3339](https://www.rfc-editor.org/rfc/rfc3339) format and the supported
   * comparison operators are: `=`, `<`, `>`, `<=`, `>=`.
   *
   * `customer` is required and is used to indicate which customer
   * to fetch spaces from. `customers/my_customer` is the only supported value.
   *
   * `display_name` only accepts the `HAS` (`:`) operator. The text to
   * match is first tokenized into tokens and each token is prefix-matched
   * case-insensitively and independently as a substring anywhere in the space's
   * `display_name`. For example, `Fun Eve` matches `Fun event` or `The
   * evening was fun`, but not `notFun event` or `even`.
   *
   * `external_user_allowed` accepts either `true` or `false`.
   *
   * `space_history_state` only accepts values from the [`historyState`]
   * (https://developers.google.com/workspace/chat/api/reference/rest/v1/spaces#Space.HistoryState)
   * field of a `space` resource.
   *
   * `space_type` is required and the only valid value is `SPACE`.
   *
   * Across different fields, only `AND` operators are supported. A valid
   * example is `space_type = "SPACE" AND display_name:"Hello"` and an invalid
   * example is `space_type = "SPACE" OR display_name:"Hello"`.
   *
   * Among the same field,
   * `space_type` doesn't support `AND` or `OR` operators.
   * `display_name`, 'space_history_state', and 'external_user_allowed' only
   * support `OR` operators.
   * `last_active_time` and `create_time` support both `AND` and `OR` operators.
   * `AND` can only be used to represent an interval, such as `last_active_time
   * < "2022-01-01T00:00:00+00:00" AND last_active_time >
   * "2023-01-01T00:00:00+00:00"`.
   *
   * The following example queries are valid:
   *
   * ```
   * customer = "customers/my_customer" AND space_type = "SPACE"
   *
   * customer = "customers/my_customer" AND space_type = "SPACE" AND
   * display_name:"Hello World"
   *
   * customer = "customers/my_customer" AND space_type = "SPACE" AND
   * (last_active_time < "2020-01-01T00:00:00+00:00" OR last_active_time >
   * "2022-01-01T00:00:00+00:00")
   *
   * customer = "customers/my_customer" AND space_type = "SPACE" AND
   * (display_name:"Hello World" OR display_name:"Fun event") AND
   * (last_active_time > "2020-01-01T00:00:00+00:00" AND last_active_time <
   * "2022-01-01T00:00:00+00:00")
   *
   * customer = "customers/my_customer" AND space_type = "SPACE" AND
   * (create_time > "2019-01-01T00:00:00+00:00" AND create_time <
   * "2020-01-01T00:00:00+00:00") AND (external_user_allowed = "true") AND
   * (space_history_state = "HISTORY_ON" OR space_history_state = "HISTORY_OFF")
   * ```
   */
  query: string;
  /**
   * Optional. How the list of spaces is ordered.
   *
   * Supported attributes to order by are:
   *
   * - `membership_count.joined_direct_human_user_count` — Denotes the count of
   * human users that have directly joined a space.
   * - `last_active_time` — Denotes the time when last eligible item is added to
   * any topic of this space.
   * - `create_time` — Denotes the time of the space creation.
   *
   * Valid ordering operation values are:
   *
   * - `ASC` for ascending. Default value.
   *
   * - `DESC` for descending.
   *
   * The supported syntax are:
   *
   * - `membership_count.joined_direct_human_user_count DESC`
   * - `membership_count.joined_direct_human_user_count ASC`
   * - `last_active_time DESC`
   * - `last_active_time ASC`
   * - `create_time DESC`
   * - `create_time ASC`
   */
  orderBy: string;
}

/** Response with a list of spaces corresponding to the search spaces request. */
export interface SearchSpacesResponse {
  /** A page of the requested spaces. */
  spaces: Space[];
  /**
   * A token that can be used to retrieve the next page. If this field is empty,
   * there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * The total number of spaces that match the query, across all pages. If the
   * result is over 10,000 spaces, this value is an estimate.
   */
  totalSize: number;
}

/** Request for deleting a space. */
export interface DeleteSpaceRequest {
  /**
   * Required. Resource name of the space to delete.
   *
   * Format: `spaces/{space}`
   */
  name: string;
  /**
   * When `true`, the method runs using the user's Google Workspace
   * administrator privileges.
   *
   * The calling user must be a Google Workspace administrator with the
   * [manage chat and spaces conversations
   * privilege](https://support.google.com/a/answer/13369245).
   *
   * Requires the `chat.admin.delete` [OAuth 2.0
   * scope](https://developers.google.com/workspace/chat/authenticate-authorize#chat-api-scopes).
   */
  useAdminAccess: boolean;
}

/** Request message for completing the import process for a space. */
export interface CompleteImportSpaceRequest {
  /**
   * Required. Resource name of the import mode space.
   *
   * Format: `spaces/{space}`
   */
  name: string;
}

/** Response message for completing the import process for a space. */
export interface CompleteImportSpaceResponse {
  /** The import mode space. */
  space: Space | undefined;
}

function createBaseSpace(): Space {
  return {
    name: "",
    type: 0,
    spaceType: 0,
    singleUserBotDm: false,
    threaded: false,
    displayName: "",
    externalUserAllowed: false,
    spaceThreadingState: 0,
    spaceDetails: undefined,
    spaceHistoryState: 0,
    importMode: false,
    createTime: undefined,
    lastActiveTime: undefined,
    adminInstalled: false,
    membershipCount: undefined,
    accessSettings: undefined,
    spaceUri: "",
  };
}

export const Space: MessageFns<Space> = {
  encode(message: Space, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.spaceType !== 0) {
      writer.uint32(80).int32(message.spaceType);
    }
    if (message.singleUserBotDm !== false) {
      writer.uint32(32).bool(message.singleUserBotDm);
    }
    if (message.threaded !== false) {
      writer.uint32(40).bool(message.threaded);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.externalUserAllowed !== false) {
      writer.uint32(64).bool(message.externalUserAllowed);
    }
    if (message.spaceThreadingState !== 0) {
      writer.uint32(72).int32(message.spaceThreadingState);
    }
    if (message.spaceDetails !== undefined) {
      Space_SpaceDetails.encode(message.spaceDetails, writer.uint32(90).fork()).join();
    }
    if (message.spaceHistoryState !== 0) {
      writer.uint32(104).int32(message.spaceHistoryState);
    }
    if (message.importMode !== false) {
      writer.uint32(128).bool(message.importMode);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(138).fork()).join();
    }
    if (message.lastActiveTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastActiveTime), writer.uint32(146).fork()).join();
    }
    if (message.adminInstalled !== false) {
      writer.uint32(152).bool(message.adminInstalled);
    }
    if (message.membershipCount !== undefined) {
      Space_MembershipCount.encode(message.membershipCount, writer.uint32(162).fork()).join();
    }
    if (message.accessSettings !== undefined) {
      Space_AccessSettings.encode(message.accessSettings, writer.uint32(186).fork()).join();
    }
    if (message.spaceUri !== "") {
      writer.uint32(202).string(message.spaceUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Space {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.spaceType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.singleUserBotDm = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.threaded = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.externalUserAllowed = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.spaceThreadingState = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.spaceDetails = Space_SpaceDetails.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.spaceHistoryState = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.importMode = reader.bool();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.lastActiveTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.adminInstalled = reader.bool();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.membershipCount = Space_MembershipCount.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.accessSettings = Space_AccessSettings.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.spaceUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Space {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? space_TypeFromJSON(object.type) : 0,
      spaceType: isSet(object.spaceType) ? space_SpaceTypeFromJSON(object.spaceType) : 0,
      singleUserBotDm: isSet(object.singleUserBotDm) ? globalThis.Boolean(object.singleUserBotDm) : false,
      threaded: isSet(object.threaded) ? globalThis.Boolean(object.threaded) : false,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      externalUserAllowed: isSet(object.externalUserAllowed) ? globalThis.Boolean(object.externalUserAllowed) : false,
      spaceThreadingState: isSet(object.spaceThreadingState)
        ? space_SpaceThreadingStateFromJSON(object.spaceThreadingState)
        : 0,
      spaceDetails: isSet(object.spaceDetails) ? Space_SpaceDetails.fromJSON(object.spaceDetails) : undefined,
      spaceHistoryState: isSet(object.spaceHistoryState) ? historyStateFromJSON(object.spaceHistoryState) : 0,
      importMode: isSet(object.importMode) ? globalThis.Boolean(object.importMode) : false,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      lastActiveTime: isSet(object.lastActiveTime) ? fromJsonTimestamp(object.lastActiveTime) : undefined,
      adminInstalled: isSet(object.adminInstalled) ? globalThis.Boolean(object.adminInstalled) : false,
      membershipCount: isSet(object.membershipCount)
        ? Space_MembershipCount.fromJSON(object.membershipCount)
        : undefined,
      accessSettings: isSet(object.accessSettings) ? Space_AccessSettings.fromJSON(object.accessSettings) : undefined,
      spaceUri: isSet(object.spaceUri) ? globalThis.String(object.spaceUri) : "",
    };
  },

  toJSON(message: Space): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = space_TypeToJSON(message.type);
    }
    if (message.spaceType !== 0) {
      obj.spaceType = space_SpaceTypeToJSON(message.spaceType);
    }
    if (message.singleUserBotDm !== false) {
      obj.singleUserBotDm = message.singleUserBotDm;
    }
    if (message.threaded !== false) {
      obj.threaded = message.threaded;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.externalUserAllowed !== false) {
      obj.externalUserAllowed = message.externalUserAllowed;
    }
    if (message.spaceThreadingState !== 0) {
      obj.spaceThreadingState = space_SpaceThreadingStateToJSON(message.spaceThreadingState);
    }
    if (message.spaceDetails !== undefined) {
      obj.spaceDetails = Space_SpaceDetails.toJSON(message.spaceDetails);
    }
    if (message.spaceHistoryState !== 0) {
      obj.spaceHistoryState = historyStateToJSON(message.spaceHistoryState);
    }
    if (message.importMode !== false) {
      obj.importMode = message.importMode;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.lastActiveTime !== undefined) {
      obj.lastActiveTime = message.lastActiveTime.toISOString();
    }
    if (message.adminInstalled !== false) {
      obj.adminInstalled = message.adminInstalled;
    }
    if (message.membershipCount !== undefined) {
      obj.membershipCount = Space_MembershipCount.toJSON(message.membershipCount);
    }
    if (message.accessSettings !== undefined) {
      obj.accessSettings = Space_AccessSettings.toJSON(message.accessSettings);
    }
    if (message.spaceUri !== "") {
      obj.spaceUri = message.spaceUri;
    }
    return obj;
  },

  create(base?: DeepPartial<Space>): Space {
    return Space.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Space>): Space {
    const message = createBaseSpace();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.spaceType = object.spaceType ?? 0;
    message.singleUserBotDm = object.singleUserBotDm ?? false;
    message.threaded = object.threaded ?? false;
    message.displayName = object.displayName ?? "";
    message.externalUserAllowed = object.externalUserAllowed ?? false;
    message.spaceThreadingState = object.spaceThreadingState ?? 0;
    message.spaceDetails = (object.spaceDetails !== undefined && object.spaceDetails !== null)
      ? Space_SpaceDetails.fromPartial(object.spaceDetails)
      : undefined;
    message.spaceHistoryState = object.spaceHistoryState ?? 0;
    message.importMode = object.importMode ?? false;
    message.createTime = object.createTime ?? undefined;
    message.lastActiveTime = object.lastActiveTime ?? undefined;
    message.adminInstalled = object.adminInstalled ?? false;
    message.membershipCount = (object.membershipCount !== undefined && object.membershipCount !== null)
      ? Space_MembershipCount.fromPartial(object.membershipCount)
      : undefined;
    message.accessSettings = (object.accessSettings !== undefined && object.accessSettings !== null)
      ? Space_AccessSettings.fromPartial(object.accessSettings)
      : undefined;
    message.spaceUri = object.spaceUri ?? "";
    return message;
  },
};

function createBaseSpace_SpaceDetails(): Space_SpaceDetails {
  return { description: "", guidelines: "" };
}

export const Space_SpaceDetails: MessageFns<Space_SpaceDetails> = {
  encode(message: Space_SpaceDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.guidelines !== "") {
      writer.uint32(18).string(message.guidelines);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Space_SpaceDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpace_SpaceDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.guidelines = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Space_SpaceDetails {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      guidelines: isSet(object.guidelines) ? globalThis.String(object.guidelines) : "",
    };
  },

  toJSON(message: Space_SpaceDetails): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.guidelines !== "") {
      obj.guidelines = message.guidelines;
    }
    return obj;
  },

  create(base?: DeepPartial<Space_SpaceDetails>): Space_SpaceDetails {
    return Space_SpaceDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Space_SpaceDetails>): Space_SpaceDetails {
    const message = createBaseSpace_SpaceDetails();
    message.description = object.description ?? "";
    message.guidelines = object.guidelines ?? "";
    return message;
  },
};

function createBaseSpace_MembershipCount(): Space_MembershipCount {
  return { joinedDirectHumanUserCount: 0, joinedGroupCount: 0 };
}

export const Space_MembershipCount: MessageFns<Space_MembershipCount> = {
  encode(message: Space_MembershipCount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.joinedDirectHumanUserCount !== 0) {
      writer.uint32(32).int32(message.joinedDirectHumanUserCount);
    }
    if (message.joinedGroupCount !== 0) {
      writer.uint32(40).int32(message.joinedGroupCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Space_MembershipCount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpace_MembershipCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 32) {
            break;
          }

          message.joinedDirectHumanUserCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.joinedGroupCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Space_MembershipCount {
    return {
      joinedDirectHumanUserCount: isSet(object.joinedDirectHumanUserCount)
        ? globalThis.Number(object.joinedDirectHumanUserCount)
        : 0,
      joinedGroupCount: isSet(object.joinedGroupCount) ? globalThis.Number(object.joinedGroupCount) : 0,
    };
  },

  toJSON(message: Space_MembershipCount): unknown {
    const obj: any = {};
    if (message.joinedDirectHumanUserCount !== 0) {
      obj.joinedDirectHumanUserCount = Math.round(message.joinedDirectHumanUserCount);
    }
    if (message.joinedGroupCount !== 0) {
      obj.joinedGroupCount = Math.round(message.joinedGroupCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Space_MembershipCount>): Space_MembershipCount {
    return Space_MembershipCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Space_MembershipCount>): Space_MembershipCount {
    const message = createBaseSpace_MembershipCount();
    message.joinedDirectHumanUserCount = object.joinedDirectHumanUserCount ?? 0;
    message.joinedGroupCount = object.joinedGroupCount ?? 0;
    return message;
  },
};

function createBaseSpace_AccessSettings(): Space_AccessSettings {
  return { accessState: 0, audience: "" };
}

export const Space_AccessSettings: MessageFns<Space_AccessSettings> = {
  encode(message: Space_AccessSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessState !== 0) {
      writer.uint32(8).int32(message.accessState);
    }
    if (message.audience !== "") {
      writer.uint32(26).string(message.audience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Space_AccessSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpace_AccessSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accessState = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.audience = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Space_AccessSettings {
    return {
      accessState: isSet(object.accessState) ? space_AccessSettings_AccessStateFromJSON(object.accessState) : 0,
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
    };
  },

  toJSON(message: Space_AccessSettings): unknown {
    const obj: any = {};
    if (message.accessState !== 0) {
      obj.accessState = space_AccessSettings_AccessStateToJSON(message.accessState);
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    return obj;
  },

  create(base?: DeepPartial<Space_AccessSettings>): Space_AccessSettings {
    return Space_AccessSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Space_AccessSettings>): Space_AccessSettings {
    const message = createBaseSpace_AccessSettings();
    message.accessState = object.accessState ?? 0;
    message.audience = object.audience ?? "";
    return message;
  },
};

function createBaseCreateSpaceRequest(): CreateSpaceRequest {
  return { space: undefined, requestId: "" };
}

export const CreateSpaceRequest: MessageFns<CreateSpaceRequest> = {
  encode(message: CreateSpaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.space !== undefined) {
      Space.encode(message.space, writer.uint32(10).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSpaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSpaceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.space = Space.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSpaceRequest {
    return {
      space: isSet(object.space) ? Space.fromJSON(object.space) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateSpaceRequest): unknown {
    const obj: any = {};
    if (message.space !== undefined) {
      obj.space = Space.toJSON(message.space);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSpaceRequest>): CreateSpaceRequest {
    return CreateSpaceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSpaceRequest>): CreateSpaceRequest {
    const message = createBaseCreateSpaceRequest();
    message.space = (object.space !== undefined && object.space !== null) ? Space.fromPartial(object.space) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListSpacesRequest(): ListSpacesRequest {
  return { pageSize: 0, pageToken: "", filter: "" };
}

export const ListSpacesRequest: MessageFns<ListSpacesRequest> = {
  encode(message: ListSpacesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSpacesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSpacesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSpacesRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListSpacesRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSpacesRequest>): ListSpacesRequest {
    return ListSpacesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSpacesRequest>): ListSpacesRequest {
    const message = createBaseListSpacesRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListSpacesResponse(): ListSpacesResponse {
  return { spaces: [], nextPageToken: "" };
}

export const ListSpacesResponse: MessageFns<ListSpacesResponse> = {
  encode(message: ListSpacesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.spaces) {
      Space.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSpacesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSpacesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.spaces.push(Space.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSpacesResponse {
    return {
      spaces: globalThis.Array.isArray(object?.spaces) ? object.spaces.map((e: any) => Space.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSpacesResponse): unknown {
    const obj: any = {};
    if (message.spaces?.length) {
      obj.spaces = message.spaces.map((e) => Space.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSpacesResponse>): ListSpacesResponse {
    return ListSpacesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSpacesResponse>): ListSpacesResponse {
    const message = createBaseListSpacesResponse();
    message.spaces = object.spaces?.map((e) => Space.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetSpaceRequest(): GetSpaceRequest {
  return { name: "", useAdminAccess: false };
}

export const GetSpaceRequest: MessageFns<GetSpaceRequest> = {
  encode(message: GetSpaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.useAdminAccess !== false) {
      writer.uint32(16).bool(message.useAdminAccess);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSpaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSpaceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.useAdminAccess = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSpaceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      useAdminAccess: isSet(object.useAdminAccess) ? globalThis.Boolean(object.useAdminAccess) : false,
    };
  },

  toJSON(message: GetSpaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.useAdminAccess !== false) {
      obj.useAdminAccess = message.useAdminAccess;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSpaceRequest>): GetSpaceRequest {
    return GetSpaceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSpaceRequest>): GetSpaceRequest {
    const message = createBaseGetSpaceRequest();
    message.name = object.name ?? "";
    message.useAdminAccess = object.useAdminAccess ?? false;
    return message;
  },
};

function createBaseFindDirectMessageRequest(): FindDirectMessageRequest {
  return { name: "" };
}

export const FindDirectMessageRequest: MessageFns<FindDirectMessageRequest> = {
  encode(message: FindDirectMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindDirectMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindDirectMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindDirectMessageRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: FindDirectMessageRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<FindDirectMessageRequest>): FindDirectMessageRequest {
    return FindDirectMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FindDirectMessageRequest>): FindDirectMessageRequest {
    const message = createBaseFindDirectMessageRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateSpaceRequest(): UpdateSpaceRequest {
  return { space: undefined, updateMask: undefined, useAdminAccess: false };
}

export const UpdateSpaceRequest: MessageFns<UpdateSpaceRequest> = {
  encode(message: UpdateSpaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.space !== undefined) {
      Space.encode(message.space, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.useAdminAccess !== false) {
      writer.uint32(24).bool(message.useAdminAccess);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSpaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSpaceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.space = Space.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.useAdminAccess = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSpaceRequest {
    return {
      space: isSet(object.space) ? Space.fromJSON(object.space) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      useAdminAccess: isSet(object.useAdminAccess) ? globalThis.Boolean(object.useAdminAccess) : false,
    };
  },

  toJSON(message: UpdateSpaceRequest): unknown {
    const obj: any = {};
    if (message.space !== undefined) {
      obj.space = Space.toJSON(message.space);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.useAdminAccess !== false) {
      obj.useAdminAccess = message.useAdminAccess;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSpaceRequest>): UpdateSpaceRequest {
    return UpdateSpaceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSpaceRequest>): UpdateSpaceRequest {
    const message = createBaseUpdateSpaceRequest();
    message.space = (object.space !== undefined && object.space !== null) ? Space.fromPartial(object.space) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.useAdminAccess = object.useAdminAccess ?? false;
    return message;
  },
};

function createBaseSearchSpacesRequest(): SearchSpacesRequest {
  return { useAdminAccess: false, pageSize: 0, pageToken: "", query: "", orderBy: "" };
}

export const SearchSpacesRequest: MessageFns<SearchSpacesRequest> = {
  encode(message: SearchSpacesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useAdminAccess !== false) {
      writer.uint32(8).bool(message.useAdminAccess);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.query !== "") {
      writer.uint32(34).string(message.query);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchSpacesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchSpacesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useAdminAccess = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.query = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchSpacesRequest {
    return {
      useAdminAccess: isSet(object.useAdminAccess) ? globalThis.Boolean(object.useAdminAccess) : false,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: SearchSpacesRequest): unknown {
    const obj: any = {};
    if (message.useAdminAccess !== false) {
      obj.useAdminAccess = message.useAdminAccess;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchSpacesRequest>): SearchSpacesRequest {
    return SearchSpacesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchSpacesRequest>): SearchSpacesRequest {
    const message = createBaseSearchSpacesRequest();
    message.useAdminAccess = object.useAdminAccess ?? false;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.query = object.query ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseSearchSpacesResponse(): SearchSpacesResponse {
  return { spaces: [], nextPageToken: "", totalSize: 0 };
}

export const SearchSpacesResponse: MessageFns<SearchSpacesResponse> = {
  encode(message: SearchSpacesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.spaces) {
      Space.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchSpacesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchSpacesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.spaces.push(Space.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchSpacesResponse {
    return {
      spaces: globalThis.Array.isArray(object?.spaces) ? object.spaces.map((e: any) => Space.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
    };
  },

  toJSON(message: SearchSpacesResponse): unknown {
    const obj: any = {};
    if (message.spaces?.length) {
      obj.spaces = message.spaces.map((e) => Space.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchSpacesResponse>): SearchSpacesResponse {
    return SearchSpacesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchSpacesResponse>): SearchSpacesResponse {
    const message = createBaseSearchSpacesResponse();
    message.spaces = object.spaces?.map((e) => Space.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseDeleteSpaceRequest(): DeleteSpaceRequest {
  return { name: "", useAdminAccess: false };
}

export const DeleteSpaceRequest: MessageFns<DeleteSpaceRequest> = {
  encode(message: DeleteSpaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.useAdminAccess !== false) {
      writer.uint32(16).bool(message.useAdminAccess);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSpaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSpaceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.useAdminAccess = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSpaceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      useAdminAccess: isSet(object.useAdminAccess) ? globalThis.Boolean(object.useAdminAccess) : false,
    };
  },

  toJSON(message: DeleteSpaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.useAdminAccess !== false) {
      obj.useAdminAccess = message.useAdminAccess;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSpaceRequest>): DeleteSpaceRequest {
    return DeleteSpaceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSpaceRequest>): DeleteSpaceRequest {
    const message = createBaseDeleteSpaceRequest();
    message.name = object.name ?? "";
    message.useAdminAccess = object.useAdminAccess ?? false;
    return message;
  },
};

function createBaseCompleteImportSpaceRequest(): CompleteImportSpaceRequest {
  return { name: "" };
}

export const CompleteImportSpaceRequest: MessageFns<CompleteImportSpaceRequest> = {
  encode(message: CompleteImportSpaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteImportSpaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteImportSpaceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteImportSpaceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CompleteImportSpaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteImportSpaceRequest>): CompleteImportSpaceRequest {
    return CompleteImportSpaceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteImportSpaceRequest>): CompleteImportSpaceRequest {
    const message = createBaseCompleteImportSpaceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCompleteImportSpaceResponse(): CompleteImportSpaceResponse {
  return { space: undefined };
}

export const CompleteImportSpaceResponse: MessageFns<CompleteImportSpaceResponse> = {
  encode(message: CompleteImportSpaceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.space !== undefined) {
      Space.encode(message.space, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompleteImportSpaceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteImportSpaceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.space = Space.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteImportSpaceResponse {
    return { space: isSet(object.space) ? Space.fromJSON(object.space) : undefined };
  },

  toJSON(message: CompleteImportSpaceResponse): unknown {
    const obj: any = {};
    if (message.space !== undefined) {
      obj.space = Space.toJSON(message.space);
    }
    return obj;
  },

  create(base?: DeepPartial<CompleteImportSpaceResponse>): CompleteImportSpaceResponse {
    return CompleteImportSpaceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompleteImportSpaceResponse>): CompleteImportSpaceResponse {
    const message = createBaseCompleteImportSpaceResponse();
    message.space = (object.space !== undefined && object.space !== null) ? Space.fromPartial(object.space) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
