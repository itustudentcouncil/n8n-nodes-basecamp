// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/chat/v1/message.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ButtonList, Card, SelectionInput_SelectionItem } from "../../apps/card/v1/card.js";
import { FieldMask } from "../../protobuf/field_mask.js";
import { Timestamp } from "../../protobuf/timestamp.js";
import { ActionStatus } from "./action_status.js";
import { Annotation } from "./annotation.js";
import { Attachment } from "./attachment.js";
import { ContextualAddOnMarkup_Card } from "./contextual_addon.js";
import { DeletionMetadata } from "./deletion_metadata.js";
import { MatchedUrl } from "./matched_url.js";
import { EmojiReactionSummary } from "./reaction.js";
import { SlashCommand } from "./slash_command.js";
import { Space } from "./space.js";
import { User } from "./user.js";

export const protobufPackage = "google.chat.v1";

/** A message in a Google Chat space. */
export interface Message {
  /**
   * Resource name of the message.
   *
   * Format: `spaces/{space}/messages/{message}`
   *
   * Where `{space}` is the ID of the space where the message is posted and
   * `{message}` is a system-assigned ID for the message. For example,
   * `spaces/AAAAAAAAAAA/messages/BBBBBBBBBBB.BBBBBBBBBBB`.
   *
   * If you set a custom ID when you create a message, you can use this ID to
   * specify the message in a request by replacing `{message}` with the value
   * from the `clientAssignedMessageId` field. For example,
   * `spaces/AAAAAAAAAAA/messages/client-custom-name`. For details, see [Name
   * a
   * message](https://developers.google.com/workspace/chat/create-messages#name_a_created_message).
   */
  name: string;
  /**
   * Output only. The user who created the message.
   * If your Chat app [authenticates as a
   * user](https://developers.google.com/workspace/chat/authenticate-authorize-chat-user),
   * the output populates the
   * [user](https://developers.google.com/workspace/chat/api/reference/rest/v1/User)
   * `name` and `type`.
   */
  sender:
    | User
    | undefined;
  /**
   * Optional. Immutable. For spaces created in Chat, the time at which the
   * message was created. This field is output only, except when used in import
   * mode spaces.
   *
   * For import mode spaces, set this field to the historical timestamp at which
   * the message was created in the source in order to preserve the original
   * creation time.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which the message was last edited by a user. If
   * the message has never been edited, this field is empty.
   */
  lastUpdateTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which the message was deleted in
   * Google Chat. If the message is never deleted, this field is empty.
   */
  deleteTime:
    | Date
    | undefined;
  /**
   * Plain-text body of the message. The first link to an image, video, or web
   * page generates a
   * [preview chip](https://developers.google.com/workspace/chat/preview-links).
   * You can also [@mention a Google Chat
   * user](https://developers.google.com/workspace/chat/format-messages#messages-@mention),
   * or everyone in the space.
   *
   * To learn about creating text messages, see [Send a text
   * message](https://developers.google.com/workspace/chat/create-messages#create-text-messages).
   */
  text: string;
  /**
   * Output only. Contains the message `text` with markups added to communicate
   * formatting. This field might not capture all formatting visible in the UI,
   * but includes the following:
   *
   * * [Markup
   * syntax](https://developers.google.com/workspace/chat/format-messages)
   * for bold, italic, strikethrough, monospace, monospace block, and bulleted
   * list.
   *
   * * [User
   * mentions](https://developers.google.com/workspace/chat/format-messages#messages-@mention)
   * using the format `<users/{user}>`.
   *
   * * Custom hyperlinks using the format `<{url}|{rendered_text}>` where the
   * first string is the URL and the second is the rendered text—for example,
   * `<http://example.com|custom text>`.
   *
   * * Custom emoji using the format `:{emoji_name}:`—for example, `:smile:`.
   * This doesn't apply to Unicode emoji, such as `U+1F600` for a grinning
   * face emoji.
   *
   * For more information, see [View text formatting sent in a
   * message](https://developers.google.com/workspace/chat/format-messages#view_text_formatting_sent_in_a_message)
   */
  formattedText: string;
  /**
   * Deprecated: Use `cards_v2` instead.
   *
   * Rich, formatted, and interactive cards that you can use to display UI
   * elements such as: formatted texts, buttons, and clickable images. Cards are
   * normally displayed below the plain-text body of the message. `cards` and
   * `cards_v2` can have a maximum size of 32 KB.
   *
   * @deprecated
   */
  cards: ContextualAddOnMarkup_Card[];
  /**
   * An array of
   * [cards](https://developers.google.com/workspace/chat/api/reference/rest/v1/cards).
   *
   * Only Chat apps can create cards. If your Chat app [authenticates as a
   * user](https://developers.google.com/workspace/chat/authenticate-authorize-chat-user),
   * the messages can't contain cards.
   *
   * To learn about cards and how to create them, see [Send card
   * messages](https://developers.google.com/workspace/chat/create-messages#create).
   *
   * [Card builder](https://addons.gsuite.google.com/uikit/builder)
   */
  cardsV2: CardWithId[];
  /** Output only. Annotations associated with the `text` in this message. */
  annotations: Annotation[];
  /**
   * The thread the message belongs to. For example usage, see
   * [Start or reply to a message
   * thread](https://developers.google.com/workspace/chat/create-messages#create-message-thread).
   */
  thread:
    | Thread
    | undefined;
  /**
   * If your Chat app [authenticates as a
   * user](https://developers.google.com/workspace/chat/authenticate-authorize-chat-user),
   * the output populates the
   * [space](https://developers.google.com/workspace/chat/api/reference/rest/v1/spaces)
   * `name`.
   */
  space:
    | Space
    | undefined;
  /**
   * A plain-text description of the message's cards, used when the actual cards
   * can't be displayed—for example, mobile notifications.
   */
  fallbackText: string;
  /**
   * Input only. Parameters that a Chat app can use to configure how its
   * response is posted.
   */
  actionResponse:
    | ActionResponse
    | undefined;
  /**
   * Output only. Plain-text body of the message with all Chat app mentions
   * stripped out.
   */
  argumentText: string;
  /** Output only. Slash command information, if applicable. */
  slashCommand:
    | SlashCommand
    | undefined;
  /** User-uploaded attachment. */
  attachment: Attachment[];
  /**
   * Output only. A URL in `spaces.messages.text` that matches a link preview
   * pattern. For more information, see [Preview
   * links](https://developers.google.com/workspace/chat/preview-links).
   */
  matchedUrl:
    | MatchedUrl
    | undefined;
  /**
   * Output only. When `true`, the message is a response in a reply thread. When
   * `false`, the message is visible in the space's top-level conversation as
   * either the first message of a thread or a message with no threaded replies.
   *
   * If the space doesn't support reply in threads, this field is always
   * `false`.
   */
  threadReply: boolean;
  /**
   * Optional. A custom ID for the message. You can use field to identify a
   * message, or to get, delete, or update a message. To set a custom ID,
   * specify the
   * [`messageId`](https://developers.google.com/workspace/chat/api/reference/rest/v1/spaces.messages/create#body.QUERY_PARAMETERS.message_id)
   * field when you create the message. For details, see [Name a
   * message](https://developers.google.com/workspace/chat/create-messages#name_a_created_message).
   */
  clientAssignedMessageId: string;
  /** Output only. The list of emoji reaction summaries on the message. */
  emojiReactionSummaries: EmojiReactionSummary[];
  /**
   * Immutable. Input for creating a message, otherwise output only. The user
   * that can view the message. When set, the message is private and only
   * visible to the specified user and the Chat app. Link previews and
   * attachments aren't supported for private messages.
   *
   * Only Chat apps can send private messages. If your Chat app [authenticates
   * as a
   * user](https://developers.google.com/workspace/chat/authenticate-authorize-chat-user)
   * to send a message, the message can't be private and must omit this field.
   *
   * For details, see [Send private messages to Google Chat
   * users](https://developers.google.com/workspace/chat/private-messages).
   */
  privateMessageViewer:
    | User
    | undefined;
  /**
   * Output only. Information about a deleted message. A message is deleted when
   * `delete_time` is set.
   */
  deletionMetadata:
    | DeletionMetadata
    | undefined;
  /**
   * Output only. Information about a message that's quoted by a Google Chat
   * user in a space. Google Chat users can quote a message to reply to it.
   */
  quotedMessageMetadata:
    | QuotedMessageMetadata
    | undefined;
  /** Output only. GIF images that are attached to the message. */
  attachedGifs: AttachedGif[];
  /**
   * One or more interactive widgets that appear at the bottom of a message.
   * You can add accessory widgets to messages that contain text, cards, or both
   * text and cards. Not supported for messages that contain dialogs. For
   * details, see [Add interactive widgets at the bottom of a
   * message](https://developers.google.com/workspace/chat/create-messages#add-accessory-widgets).
   *
   * Creating a message with accessory widgets requires [app
   * authentication]
   * (https://developers.google.com/workspace/chat/authenticate-authorize-chat-app).
   */
  accessoryWidgets: AccessoryWidget[];
}

/** A GIF image that's specified by a URL. */
export interface AttachedGif {
  /** Output only. The URL that hosts the GIF image. */
  uri: string;
}

/** Information about a quoted message. */
export interface QuotedMessageMetadata {
  /**
   * Output only. Resource name of the quoted message.
   *
   * Format: `spaces/{space}/messages/{message}`
   */
  name: string;
  /**
   * Output only. The timestamp when the quoted message was created or when the
   * quoted message was last updated.
   */
  lastUpdateTime: Date | undefined;
}

/**
 * A thread in a Google Chat space. For example usage, see
 * [Start or reply to a message
 * thread](https://developers.google.com/workspace/chat/create-messages#create-message-thread).
 *
 * If you specify a thread when creating a message, you can set the
 * [`messageReplyOption`](https://developers.google.com/workspace/chat/api/reference/rest/v1/spaces.messages/create#messagereplyoption)
 * field to determine what happens if no matching thread is found.
 */
export interface Thread {
  /**
   * Output only. Resource name of the thread.
   *
   * Example: `spaces/{space}/threads/{thread}`
   */
  name: string;
  /**
   * Optional. Input for creating or updating a thread. Otherwise, output only.
   * ID for the thread. Supports up to 4000 characters.
   *
   * This ID is unique to the Chat app that sets it. For example, if
   * multiple Chat apps create a message using the same thread key,
   * the messages are posted in different threads. To reply in a
   * thread created by a person or another Chat app, specify the thread `name`
   * field instead.
   */
  threadKey: string;
}

/** Parameters that a Chat app can use to configure how its response is posted. */
export interface ActionResponse {
  /** Input only. The type of Chat app response. */
  type: ActionResponse_ResponseType;
  /**
   * Input only. URL for users to authenticate or configure. (Only for
   * `REQUEST_CONFIG` response types.)
   */
  url: string;
  /**
   * Input only. A response to an interaction event related to a
   * [dialog](https://developers.google.com/workspace/chat/dialogs). Must be
   * accompanied by `ResponseType.Dialog`.
   */
  dialogAction:
    | DialogAction
    | undefined;
  /** Input only. The response of the updated widget. */
  updatedWidget: ActionResponse_UpdatedWidget | undefined;
}

/** The type of Chat app response. */
export enum ActionResponse_ResponseType {
  /** TYPE_UNSPECIFIED - Default type that's handled as `NEW_MESSAGE`. */
  TYPE_UNSPECIFIED = 0,
  /** NEW_MESSAGE - Post as a new message in the topic. */
  NEW_MESSAGE = 1,
  /**
   * UPDATE_MESSAGE - Update the Chat app's message. This is only permitted on a `CARD_CLICKED`
   * event where the message sender type is `BOT`.
   */
  UPDATE_MESSAGE = 2,
  /**
   * UPDATE_USER_MESSAGE_CARDS - Update the cards on a user's message. This is only permitted as a
   * response to a `MESSAGE` event with a matched url, or a `CARD_CLICKED`
   * event where the message sender type is `HUMAN`. Text is ignored.
   */
  UPDATE_USER_MESSAGE_CARDS = 6,
  /** REQUEST_CONFIG - Privately ask the user for additional authentication or configuration. */
  REQUEST_CONFIG = 3,
  /**
   * DIALOG - Presents a
   * [dialog](https://developers.google.com/workspace/chat/dialogs).
   */
  DIALOG = 4,
  /** UPDATE_WIDGET - Widget text autocomplete options query. */
  UPDATE_WIDGET = 7,
  UNRECOGNIZED = -1,
}

export function actionResponse_ResponseTypeFromJSON(object: any): ActionResponse_ResponseType {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return ActionResponse_ResponseType.TYPE_UNSPECIFIED;
    case 1:
    case "NEW_MESSAGE":
      return ActionResponse_ResponseType.NEW_MESSAGE;
    case 2:
    case "UPDATE_MESSAGE":
      return ActionResponse_ResponseType.UPDATE_MESSAGE;
    case 6:
    case "UPDATE_USER_MESSAGE_CARDS":
      return ActionResponse_ResponseType.UPDATE_USER_MESSAGE_CARDS;
    case 3:
    case "REQUEST_CONFIG":
      return ActionResponse_ResponseType.REQUEST_CONFIG;
    case 4:
    case "DIALOG":
      return ActionResponse_ResponseType.DIALOG;
    case 7:
    case "UPDATE_WIDGET":
      return ActionResponse_ResponseType.UPDATE_WIDGET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ActionResponse_ResponseType.UNRECOGNIZED;
  }
}

export function actionResponse_ResponseTypeToJSON(object: ActionResponse_ResponseType): string {
  switch (object) {
    case ActionResponse_ResponseType.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case ActionResponse_ResponseType.NEW_MESSAGE:
      return "NEW_MESSAGE";
    case ActionResponse_ResponseType.UPDATE_MESSAGE:
      return "UPDATE_MESSAGE";
    case ActionResponse_ResponseType.UPDATE_USER_MESSAGE_CARDS:
      return "UPDATE_USER_MESSAGE_CARDS";
    case ActionResponse_ResponseType.REQUEST_CONFIG:
      return "REQUEST_CONFIG";
    case ActionResponse_ResponseType.DIALOG:
      return "DIALOG";
    case ActionResponse_ResponseType.UPDATE_WIDGET:
      return "UPDATE_WIDGET";
    case ActionResponse_ResponseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** List of widget autocomplete results. */
export interface ActionResponse_SelectionItems {
  /** An array of the SelectionItem objects. */
  items: SelectionInput_SelectionItem[];
}

/**
 * The response of the updated widget.
 * Used to provide autocomplete options for a widget.
 */
export interface ActionResponse_UpdatedWidget {
  /** List of widget autocomplete results */
  suggestions?:
    | ActionResponse_SelectionItems
    | undefined;
  /**
   * The ID of the updated widget. The ID must match the one for the
   * widget that triggered the update request.
   */
  widget: string;
}

/**
 * One or more interactive widgets that appear at the bottom of a message. For
 * details, see [Add interactive widgets at the bottom of a
 * message](https://developers.google.com/workspace/chat/create-messages#add-accessory-widgets).
 */
export interface AccessoryWidget {
  /** A list of buttons. */
  buttonList?: ButtonList | undefined;
}

/** Request to get a message. */
export interface GetMessageRequest {
  /**
   * Required. Resource name of the message.
   *
   * Format: `spaces/{space}/messages/{message}`
   *
   * If you've set a custom ID for your message, you can use the value from the
   * `clientAssignedMessageId` field for `{message}`. For details, see [Name a
   * message]
   * (https://developers.google.com/workspace/chat/create-messages#name_a_created_message).
   */
  name: string;
}

/** Request to delete a message. */
export interface DeleteMessageRequest {
  /**
   * Required. Resource name of the message.
   *
   * Format: `spaces/{space}/messages/{message}`
   *
   * If you've set a custom ID for your message, you can use the value from the
   * `clientAssignedMessageId` field for `{message}`. For details, see [Name a
   * message]
   * (https://developers.google.com/workspace/chat/create-messages#name_a_created_message).
   */
  name: string;
  /**
   * When `true`, deleting a message also deletes its threaded replies. When
   * `false`, if a message has threaded replies, deletion fails.
   *
   * Only applies when [authenticating as a
   * user](https://developers.google.com/workspace/chat/authenticate-authorize-chat-user).
   * Has no effect when [authenticating as a Chat app]
   * (https://developers.google.com/workspace/chat/authenticate-authorize-chat-app).
   */
  force: boolean;
}

/** Request to update a message. */
export interface UpdateMessageRequest {
  /** Required. Message with fields updated. */
  message:
    | Message
    | undefined;
  /**
   * Required. The field paths to update. Separate multiple values with commas
   * or use `*` to update all field paths.
   *
   * Currently supported field paths:
   *
   * - `text`
   *
   * - `attachment`
   *
   * - `cards` (Requires [app
   * authentication](/chat/api/guides/auth/service-accounts).)
   *
   * - `cards_v2`  (Requires [app
   * authentication](/chat/api/guides/auth/service-accounts).)
   *
   * - `accessory_widgets`  (Requires [app
   * authentication](/chat/api/guides/auth/service-accounts).)
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. If `true` and the message isn't found, a new message is created
   * and `updateMask` is ignored. The specified message ID must be
   * [client-assigned](https://developers.google.com/workspace/chat/create-messages#name_a_created_message)
   * or the request fails.
   */
  allowMissing: boolean;
}

/** Creates a message. */
export interface CreateMessageRequest {
  /**
   * Required. The resource name of the space in which to create a message.
   *
   * Format: `spaces/{space}`
   */
  parent: string;
  /** Required. Message body. */
  message:
    | Message
    | undefined;
  /**
   * Optional. Deprecated: Use
   * [thread.thread_key][google.chat.v1.Thread.thread_key] instead. ID for the
   * thread. Supports up to 4000 characters. To start or add to a thread, create
   * a message and specify a `threadKey` or the
   * [thread.name][google.chat.v1.Thread.name]. For example usage, see [Start or
   * reply to a message
   * thread](https://developers.google.com/workspace/chat/create-messages#create-message-thread).
   *
   * @deprecated
   */
  threadKey: string;
  /**
   * Optional. A unique request ID for this message. Specifying an existing
   * request ID returns the message created with that ID instead of creating a
   * new message.
   */
  requestId: string;
  /**
   * Optional. Specifies whether a message starts a thread or replies to one.
   * Only supported in named spaces.
   */
  messageReplyOption: CreateMessageRequest_MessageReplyOption;
  /**
   * Optional. A custom ID for a message. Lets Chat apps get, update, or delete
   * a message without needing to store the system-assigned ID in the message's
   * resource name (represented in the message `name` field).
   *
   * The value for this field must meet the following requirements:
   *
   * * Begins with `client-`. For example, `client-custom-name` is a valid
   *   custom ID, but `custom-name` is not.
   * * Contains up to 63 characters and only lowercase letters, numbers, and
   *   hyphens.
   * * Is unique within a space. A Chat app can't use the same custom ID for
   * different messages.
   *
   * For details, see [Name a
   * message](https://developers.google.com/workspace/chat/create-messages#name_a_created_message).
   */
  messageId: string;
}

/**
 * Specifies how to reply to a message.
 * More states might be added in the future.
 */
export enum CreateMessageRequest_MessageReplyOption {
  /**
   * MESSAGE_REPLY_OPTION_UNSPECIFIED - Default. Starts a new thread. Using this option ignores any [thread
   * ID][google.chat.v1.Thread.name] or
   * [`thread_key`][google.chat.v1.Thread.thread_key] that's included.
   */
  MESSAGE_REPLY_OPTION_UNSPECIFIED = 0,
  /**
   * REPLY_MESSAGE_FALLBACK_TO_NEW_THREAD - Creates the message as a reply to the thread specified by [thread
   * ID][google.chat.v1.Thread.name] or
   * [`thread_key`][google.chat.v1.Thread.thread_key]. If it fails, the
   * message starts a new thread instead.
   */
  REPLY_MESSAGE_FALLBACK_TO_NEW_THREAD = 1,
  /**
   * REPLY_MESSAGE_OR_FAIL - Creates the message as a reply to the thread specified by [thread
   * ID][google.chat.v1.Thread.name] or
   * [`thread_key`][google.chat.v1.Thread.thread_key]. If a new `thread_key`
   * is used, a new thread is created. If the message creation fails, a
   * `NOT_FOUND` error is returned instead.
   */
  REPLY_MESSAGE_OR_FAIL = 2,
  UNRECOGNIZED = -1,
}

export function createMessageRequest_MessageReplyOptionFromJSON(object: any): CreateMessageRequest_MessageReplyOption {
  switch (object) {
    case 0:
    case "MESSAGE_REPLY_OPTION_UNSPECIFIED":
      return CreateMessageRequest_MessageReplyOption.MESSAGE_REPLY_OPTION_UNSPECIFIED;
    case 1:
    case "REPLY_MESSAGE_FALLBACK_TO_NEW_THREAD":
      return CreateMessageRequest_MessageReplyOption.REPLY_MESSAGE_FALLBACK_TO_NEW_THREAD;
    case 2:
    case "REPLY_MESSAGE_OR_FAIL":
      return CreateMessageRequest_MessageReplyOption.REPLY_MESSAGE_OR_FAIL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CreateMessageRequest_MessageReplyOption.UNRECOGNIZED;
  }
}

export function createMessageRequest_MessageReplyOptionToJSON(object: CreateMessageRequest_MessageReplyOption): string {
  switch (object) {
    case CreateMessageRequest_MessageReplyOption.MESSAGE_REPLY_OPTION_UNSPECIFIED:
      return "MESSAGE_REPLY_OPTION_UNSPECIFIED";
    case CreateMessageRequest_MessageReplyOption.REPLY_MESSAGE_FALLBACK_TO_NEW_THREAD:
      return "REPLY_MESSAGE_FALLBACK_TO_NEW_THREAD";
    case CreateMessageRequest_MessageReplyOption.REPLY_MESSAGE_OR_FAIL:
      return "REPLY_MESSAGE_OR_FAIL";
    case CreateMessageRequest_MessageReplyOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Lists messages in the specified space, that the user is a member of. */
export interface ListMessagesRequest {
  /**
   * Required. The resource name of the space to list messages from.
   *
   * Format: `spaces/{space}`
   */
  parent: string;
  /**
   * The maximum number of messages returned. The service might return fewer
   * messages than this value.
   *
   * If unspecified, at most 25 are returned.
   *
   * The maximum value is 1000. If you use a value more than 1000, it's
   * automatically changed to 1000.
   *
   * Negative values return an `INVALID_ARGUMENT` error.
   */
  pageSize: number;
  /**
   * Optional, if resuming from a previous query.
   *
   * A page token received from a previous list messages call. Provide this
   * parameter to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided should match the call that
   * provided the page token. Passing different values to the other parameters
   * might lead to unexpected results.
   */
  pageToken: string;
  /**
   * A query filter.
   *
   * You can filter messages by date (`create_time`) and thread (`thread.name`).
   *
   * To filter messages by the date they were created, specify the `create_time`
   * with a timestamp in [RFC-3339](https://www.rfc-editor.org/rfc/rfc3339)
   * format and double quotation marks. For example,
   * `"2023-04-21T11:30:00-04:00"`. You can use the greater than operator `>` to
   * list messages that were created after a timestamp, or the less than
   * operator `<` to list messages that were created before a timestamp. To
   * filter messages within a time interval, use the `AND` operator between two
   * timestamps.
   *
   * To filter by thread, specify the `thread.name`, formatted as
   * `spaces/{space}/threads/{thread}`. You can only specify one
   * `thread.name` per query.
   *
   * To filter by both thread and date, use the `AND` operator in your query.
   *
   * For example, the following queries are valid:
   *
   * ```
   * create_time > "2012-04-21T11:30:00-04:00"
   *
   * create_time > "2012-04-21T11:30:00-04:00" AND
   *   thread.name = spaces/AAAAAAAAAAA/threads/123
   *
   * create_time > "2012-04-21T11:30:00+00:00" AND
   *
   * create_time < "2013-01-01T00:00:00+00:00" AND
   *   thread.name = spaces/AAAAAAAAAAA/threads/123
   *
   * thread.name = spaces/AAAAAAAAAAA/threads/123
   * ```
   *
   * Invalid queries are rejected by the server with an `INVALID_ARGUMENT`
   * error.
   */
  filter: string;
  /**
   * Optional, if resuming from a previous query.
   *
   * How the list of messages is ordered. Specify a value to order by an
   * ordering operation. Valid ordering operation values are as follows:
   *
   * - `ASC` for ascending.
   *
   * - `DESC` for descending.
   *
   * The default ordering is `create_time ASC`.
   */
  orderBy: string;
  /**
   * Whether to include deleted messages. Deleted messages include deleted time
   * and metadata about their deletion, but message content is unavailable.
   */
  showDeleted: boolean;
}

/** Response message for listing messages. */
export interface ListMessagesResponse {
  /** List of messages. */
  messages: Message[];
  /**
   * You can send a token as `pageToken` to retrieve the next page of
   * results. If empty, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * Contains a
 * [dialog](https://developers.google.com/workspace/chat/dialogs) and request
 * status code.
 */
export interface DialogAction {
  /**
   * Input only.
   * [Dialog](https://developers.google.com/workspace/chat/dialogs) for the
   * request.
   */
  dialog?:
    | Dialog
    | undefined;
  /**
   * Input only. Status for a request to either invoke or submit a
   * [dialog](https://developers.google.com/workspace/chat/dialogs). Displays
   * a status and message to users, if necessary.
   * For example, in case of an error or success.
   */
  actionStatus: ActionStatus | undefined;
}

/** Wrapper around the card body of the dialog. */
export interface Dialog {
  /**
   * Input only. Body of the dialog, which is rendered in a modal.
   * Google Chat apps don't support the following card entities:
   * `DateTimePicker`, `OnChangeAction`.
   */
  body: Card | undefined;
}

/**
 * A
 * [card](https://developers.google.com/workspace/chat/api/reference/rest/v1/cards)
 * in a Google Chat message.
 *
 * Only Chat apps can create cards. If your Chat app [authenticates as a
 * user](https://developers.google.com/workspace/chat/authenticate-authorize-chat-user),
 * the message can't contain cards.
 *
 * [Card builder](https://addons.gsuite.google.com/uikit/builder)
 */
export interface CardWithId {
  /**
   * Required if the message contains multiple cards. A unique identifier for
   * a card in a message.
   */
  cardId: string;
  /** A card. Maximum size is 32 KB. */
  card: Card | undefined;
}

function createBaseMessage(): Message {
  return {
    name: "",
    sender: undefined,
    createTime: undefined,
    lastUpdateTime: undefined,
    deleteTime: undefined,
    text: "",
    formattedText: "",
    cards: [],
    cardsV2: [],
    annotations: [],
    thread: undefined,
    space: undefined,
    fallbackText: "",
    actionResponse: undefined,
    argumentText: "",
    slashCommand: undefined,
    attachment: [],
    matchedUrl: undefined,
    threadReply: false,
    clientAssignedMessageId: "",
    emojiReactionSummaries: [],
    privateMessageViewer: undefined,
    deletionMetadata: undefined,
    quotedMessageMetadata: undefined,
    attachedGifs: [],
    accessoryWidgets: [],
  };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.sender !== undefined) {
      User.encode(message.sender, writer.uint32(18).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.lastUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdateTime), writer.uint32(186).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(210).fork()).join();
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.formattedText !== "") {
      writer.uint32(346).string(message.formattedText);
    }
    for (const v of message.cards) {
      ContextualAddOnMarkup_Card.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.cardsV2) {
      CardWithId.encode(v!, writer.uint32(178).fork()).join();
    }
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.thread !== undefined) {
      Thread.encode(message.thread, writer.uint32(90).fork()).join();
    }
    if (message.space !== undefined) {
      Space.encode(message.space, writer.uint32(98).fork()).join();
    }
    if (message.fallbackText !== "") {
      writer.uint32(106).string(message.fallbackText);
    }
    if (message.actionResponse !== undefined) {
      ActionResponse.encode(message.actionResponse, writer.uint32(114).fork()).join();
    }
    if (message.argumentText !== "") {
      writer.uint32(122).string(message.argumentText);
    }
    if (message.slashCommand !== undefined) {
      SlashCommand.encode(message.slashCommand, writer.uint32(138).fork()).join();
    }
    for (const v of message.attachment) {
      Attachment.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.matchedUrl !== undefined) {
      MatchedUrl.encode(message.matchedUrl, writer.uint32(162).fork()).join();
    }
    if (message.threadReply !== false) {
      writer.uint32(200).bool(message.threadReply);
    }
    if (message.clientAssignedMessageId !== "") {
      writer.uint32(258).string(message.clientAssignedMessageId);
    }
    for (const v of message.emojiReactionSummaries) {
      EmojiReactionSummary.encode(v!, writer.uint32(266).fork()).join();
    }
    if (message.privateMessageViewer !== undefined) {
      User.encode(message.privateMessageViewer, writer.uint32(290).fork()).join();
    }
    if (message.deletionMetadata !== undefined) {
      DeletionMetadata.encode(message.deletionMetadata, writer.uint32(306).fork()).join();
    }
    if (message.quotedMessageMetadata !== undefined) {
      QuotedMessageMetadata.encode(message.quotedMessageMetadata, writer.uint32(314).fork()).join();
    }
    for (const v of message.attachedGifs) {
      AttachedGif.encode(v!, writer.uint32(338).fork()).join();
    }
    for (const v of message.accessoryWidgets) {
      AccessoryWidget.encode(v!, writer.uint32(354).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sender = User.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.lastUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.formattedText = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cards.push(ContextualAddOnMarkup_Card.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.cardsV2.push(CardWithId.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.thread = Thread.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.space = Space.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.fallbackText = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.actionResponse = ActionResponse.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.argumentText = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.slashCommand = SlashCommand.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.attachment.push(Attachment.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.matchedUrl = MatchedUrl.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.threadReply = reader.bool();
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.clientAssignedMessageId = reader.string();
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.emojiReactionSummaries.push(EmojiReactionSummary.decode(reader, reader.uint32()));
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.privateMessageViewer = User.decode(reader, reader.uint32());
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.deletionMetadata = DeletionMetadata.decode(reader, reader.uint32());
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.quotedMessageMetadata = QuotedMessageMetadata.decode(reader, reader.uint32());
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.attachedGifs.push(AttachedGif.decode(reader, reader.uint32()));
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }

          message.accessoryWidgets.push(AccessoryWidget.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sender: isSet(object.sender) ? User.fromJSON(object.sender) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      lastUpdateTime: isSet(object.lastUpdateTime) ? fromJsonTimestamp(object.lastUpdateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      formattedText: isSet(object.formattedText) ? globalThis.String(object.formattedText) : "",
      cards: globalThis.Array.isArray(object?.cards)
        ? object.cards.map((e: any) => ContextualAddOnMarkup_Card.fromJSON(e))
        : [],
      cardsV2: globalThis.Array.isArray(object?.cardsV2) ? object.cardsV2.map((e: any) => CardWithId.fromJSON(e)) : [],
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      thread: isSet(object.thread) ? Thread.fromJSON(object.thread) : undefined,
      space: isSet(object.space) ? Space.fromJSON(object.space) : undefined,
      fallbackText: isSet(object.fallbackText) ? globalThis.String(object.fallbackText) : "",
      actionResponse: isSet(object.actionResponse) ? ActionResponse.fromJSON(object.actionResponse) : undefined,
      argumentText: isSet(object.argumentText) ? globalThis.String(object.argumentText) : "",
      slashCommand: isSet(object.slashCommand) ? SlashCommand.fromJSON(object.slashCommand) : undefined,
      attachment: globalThis.Array.isArray(object?.attachment)
        ? object.attachment.map((e: any) => Attachment.fromJSON(e))
        : [],
      matchedUrl: isSet(object.matchedUrl) ? MatchedUrl.fromJSON(object.matchedUrl) : undefined,
      threadReply: isSet(object.threadReply) ? globalThis.Boolean(object.threadReply) : false,
      clientAssignedMessageId: isSet(object.clientAssignedMessageId)
        ? globalThis.String(object.clientAssignedMessageId)
        : "",
      emojiReactionSummaries: globalThis.Array.isArray(object?.emojiReactionSummaries)
        ? object.emojiReactionSummaries.map((e: any) => EmojiReactionSummary.fromJSON(e))
        : [],
      privateMessageViewer: isSet(object.privateMessageViewer) ? User.fromJSON(object.privateMessageViewer) : undefined,
      deletionMetadata: isSet(object.deletionMetadata) ? DeletionMetadata.fromJSON(object.deletionMetadata) : undefined,
      quotedMessageMetadata: isSet(object.quotedMessageMetadata)
        ? QuotedMessageMetadata.fromJSON(object.quotedMessageMetadata)
        : undefined,
      attachedGifs: globalThis.Array.isArray(object?.attachedGifs)
        ? object.attachedGifs.map((e: any) => AttachedGif.fromJSON(e))
        : [],
      accessoryWidgets: globalThis.Array.isArray(object?.accessoryWidgets)
        ? object.accessoryWidgets.map((e: any) => AccessoryWidget.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sender !== undefined) {
      obj.sender = User.toJSON(message.sender);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.lastUpdateTime !== undefined) {
      obj.lastUpdateTime = message.lastUpdateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.formattedText !== "") {
      obj.formattedText = message.formattedText;
    }
    if (message.cards?.length) {
      obj.cards = message.cards.map((e) => ContextualAddOnMarkup_Card.toJSON(e));
    }
    if (message.cardsV2?.length) {
      obj.cardsV2 = message.cardsV2.map((e) => CardWithId.toJSON(e));
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => Annotation.toJSON(e));
    }
    if (message.thread !== undefined) {
      obj.thread = Thread.toJSON(message.thread);
    }
    if (message.space !== undefined) {
      obj.space = Space.toJSON(message.space);
    }
    if (message.fallbackText !== "") {
      obj.fallbackText = message.fallbackText;
    }
    if (message.actionResponse !== undefined) {
      obj.actionResponse = ActionResponse.toJSON(message.actionResponse);
    }
    if (message.argumentText !== "") {
      obj.argumentText = message.argumentText;
    }
    if (message.slashCommand !== undefined) {
      obj.slashCommand = SlashCommand.toJSON(message.slashCommand);
    }
    if (message.attachment?.length) {
      obj.attachment = message.attachment.map((e) => Attachment.toJSON(e));
    }
    if (message.matchedUrl !== undefined) {
      obj.matchedUrl = MatchedUrl.toJSON(message.matchedUrl);
    }
    if (message.threadReply !== false) {
      obj.threadReply = message.threadReply;
    }
    if (message.clientAssignedMessageId !== "") {
      obj.clientAssignedMessageId = message.clientAssignedMessageId;
    }
    if (message.emojiReactionSummaries?.length) {
      obj.emojiReactionSummaries = message.emojiReactionSummaries.map((e) => EmojiReactionSummary.toJSON(e));
    }
    if (message.privateMessageViewer !== undefined) {
      obj.privateMessageViewer = User.toJSON(message.privateMessageViewer);
    }
    if (message.deletionMetadata !== undefined) {
      obj.deletionMetadata = DeletionMetadata.toJSON(message.deletionMetadata);
    }
    if (message.quotedMessageMetadata !== undefined) {
      obj.quotedMessageMetadata = QuotedMessageMetadata.toJSON(message.quotedMessageMetadata);
    }
    if (message.attachedGifs?.length) {
      obj.attachedGifs = message.attachedGifs.map((e) => AttachedGif.toJSON(e));
    }
    if (message.accessoryWidgets?.length) {
      obj.accessoryWidgets = message.accessoryWidgets.map((e) => AccessoryWidget.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Message>): Message {
    return Message.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Message>): Message {
    const message = createBaseMessage();
    message.name = object.name ?? "";
    message.sender = (object.sender !== undefined && object.sender !== null)
      ? User.fromPartial(object.sender)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.lastUpdateTime = object.lastUpdateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.text = object.text ?? "";
    message.formattedText = object.formattedText ?? "";
    message.cards = object.cards?.map((e) => ContextualAddOnMarkup_Card.fromPartial(e)) || [];
    message.cardsV2 = object.cardsV2?.map((e) => CardWithId.fromPartial(e)) || [];
    message.annotations = object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.thread = (object.thread !== undefined && object.thread !== null)
      ? Thread.fromPartial(object.thread)
      : undefined;
    message.space = (object.space !== undefined && object.space !== null) ? Space.fromPartial(object.space) : undefined;
    message.fallbackText = object.fallbackText ?? "";
    message.actionResponse = (object.actionResponse !== undefined && object.actionResponse !== null)
      ? ActionResponse.fromPartial(object.actionResponse)
      : undefined;
    message.argumentText = object.argumentText ?? "";
    message.slashCommand = (object.slashCommand !== undefined && object.slashCommand !== null)
      ? SlashCommand.fromPartial(object.slashCommand)
      : undefined;
    message.attachment = object.attachment?.map((e) => Attachment.fromPartial(e)) || [];
    message.matchedUrl = (object.matchedUrl !== undefined && object.matchedUrl !== null)
      ? MatchedUrl.fromPartial(object.matchedUrl)
      : undefined;
    message.threadReply = object.threadReply ?? false;
    message.clientAssignedMessageId = object.clientAssignedMessageId ?? "";
    message.emojiReactionSummaries = object.emojiReactionSummaries?.map((e) => EmojiReactionSummary.fromPartial(e)) ||
      [];
    message.privateMessageViewer = (object.privateMessageViewer !== undefined && object.privateMessageViewer !== null)
      ? User.fromPartial(object.privateMessageViewer)
      : undefined;
    message.deletionMetadata = (object.deletionMetadata !== undefined && object.deletionMetadata !== null)
      ? DeletionMetadata.fromPartial(object.deletionMetadata)
      : undefined;
    message.quotedMessageMetadata =
      (object.quotedMessageMetadata !== undefined && object.quotedMessageMetadata !== null)
        ? QuotedMessageMetadata.fromPartial(object.quotedMessageMetadata)
        : undefined;
    message.attachedGifs = object.attachedGifs?.map((e) => AttachedGif.fromPartial(e)) || [];
    message.accessoryWidgets = object.accessoryWidgets?.map((e) => AccessoryWidget.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAttachedGif(): AttachedGif {
  return { uri: "" };
}

export const AttachedGif: MessageFns<AttachedGif> = {
  encode(message: AttachedGif, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttachedGif {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachedGif();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttachedGif {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: AttachedGif): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<AttachedGif>): AttachedGif {
    return AttachedGif.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttachedGif>): AttachedGif {
    const message = createBaseAttachedGif();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseQuotedMessageMetadata(): QuotedMessageMetadata {
  return { name: "", lastUpdateTime: undefined };
}

export const QuotedMessageMetadata: MessageFns<QuotedMessageMetadata> = {
  encode(message: QuotedMessageMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.lastUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdateTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuotedMessageMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuotedMessageMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuotedMessageMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      lastUpdateTime: isSet(object.lastUpdateTime) ? fromJsonTimestamp(object.lastUpdateTime) : undefined,
    };
  },

  toJSON(message: QuotedMessageMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.lastUpdateTime !== undefined) {
      obj.lastUpdateTime = message.lastUpdateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<QuotedMessageMetadata>): QuotedMessageMetadata {
    return QuotedMessageMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QuotedMessageMetadata>): QuotedMessageMetadata {
    const message = createBaseQuotedMessageMetadata();
    message.name = object.name ?? "";
    message.lastUpdateTime = object.lastUpdateTime ?? undefined;
    return message;
  },
};

function createBaseThread(): Thread {
  return { name: "", threadKey: "" };
}

export const Thread: MessageFns<Thread> = {
  encode(message: Thread, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.threadKey !== "") {
      writer.uint32(26).string(message.threadKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Thread {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseThread();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.threadKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Thread {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      threadKey: isSet(object.threadKey) ? globalThis.String(object.threadKey) : "",
    };
  },

  toJSON(message: Thread): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.threadKey !== "") {
      obj.threadKey = message.threadKey;
    }
    return obj;
  },

  create(base?: DeepPartial<Thread>): Thread {
    return Thread.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Thread>): Thread {
    const message = createBaseThread();
    message.name = object.name ?? "";
    message.threadKey = object.threadKey ?? "";
    return message;
  },
};

function createBaseActionResponse(): ActionResponse {
  return { type: 0, url: "", dialogAction: undefined, updatedWidget: undefined };
}

export const ActionResponse: MessageFns<ActionResponse> = {
  encode(message: ActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.dialogAction !== undefined) {
      DialogAction.encode(message.dialogAction, writer.uint32(26).fork()).join();
    }
    if (message.updatedWidget !== undefined) {
      ActionResponse_UpdatedWidget.encode(message.updatedWidget, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dialogAction = DialogAction.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updatedWidget = ActionResponse_UpdatedWidget.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionResponse {
    return {
      type: isSet(object.type) ? actionResponse_ResponseTypeFromJSON(object.type) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      dialogAction: isSet(object.dialogAction) ? DialogAction.fromJSON(object.dialogAction) : undefined,
      updatedWidget: isSet(object.updatedWidget)
        ? ActionResponse_UpdatedWidget.fromJSON(object.updatedWidget)
        : undefined,
    };
  },

  toJSON(message: ActionResponse): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = actionResponse_ResponseTypeToJSON(message.type);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.dialogAction !== undefined) {
      obj.dialogAction = DialogAction.toJSON(message.dialogAction);
    }
    if (message.updatedWidget !== undefined) {
      obj.updatedWidget = ActionResponse_UpdatedWidget.toJSON(message.updatedWidget);
    }
    return obj;
  },

  create(base?: DeepPartial<ActionResponse>): ActionResponse {
    return ActionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionResponse>): ActionResponse {
    const message = createBaseActionResponse();
    message.type = object.type ?? 0;
    message.url = object.url ?? "";
    message.dialogAction = (object.dialogAction !== undefined && object.dialogAction !== null)
      ? DialogAction.fromPartial(object.dialogAction)
      : undefined;
    message.updatedWidget = (object.updatedWidget !== undefined && object.updatedWidget !== null)
      ? ActionResponse_UpdatedWidget.fromPartial(object.updatedWidget)
      : undefined;
    return message;
  },
};

function createBaseActionResponse_SelectionItems(): ActionResponse_SelectionItems {
  return { items: [] };
}

export const ActionResponse_SelectionItems: MessageFns<ActionResponse_SelectionItems> = {
  encode(message: ActionResponse_SelectionItems, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      SelectionInput_SelectionItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionResponse_SelectionItems {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionResponse_SelectionItems();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(SelectionInput_SelectionItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionResponse_SelectionItems {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => SelectionInput_SelectionItem.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ActionResponse_SelectionItems): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => SelectionInput_SelectionItem.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ActionResponse_SelectionItems>): ActionResponse_SelectionItems {
    return ActionResponse_SelectionItems.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionResponse_SelectionItems>): ActionResponse_SelectionItems {
    const message = createBaseActionResponse_SelectionItems();
    message.items = object.items?.map((e) => SelectionInput_SelectionItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseActionResponse_UpdatedWidget(): ActionResponse_UpdatedWidget {
  return { suggestions: undefined, widget: "" };
}

export const ActionResponse_UpdatedWidget: MessageFns<ActionResponse_UpdatedWidget> = {
  encode(message: ActionResponse_UpdatedWidget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.suggestions !== undefined) {
      ActionResponse_SelectionItems.encode(message.suggestions, writer.uint32(10).fork()).join();
    }
    if (message.widget !== "") {
      writer.uint32(18).string(message.widget);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActionResponse_UpdatedWidget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActionResponse_UpdatedWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.suggestions = ActionResponse_SelectionItems.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.widget = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActionResponse_UpdatedWidget {
    return {
      suggestions: isSet(object.suggestions) ? ActionResponse_SelectionItems.fromJSON(object.suggestions) : undefined,
      widget: isSet(object.widget) ? globalThis.String(object.widget) : "",
    };
  },

  toJSON(message: ActionResponse_UpdatedWidget): unknown {
    const obj: any = {};
    if (message.suggestions !== undefined) {
      obj.suggestions = ActionResponse_SelectionItems.toJSON(message.suggestions);
    }
    if (message.widget !== "") {
      obj.widget = message.widget;
    }
    return obj;
  },

  create(base?: DeepPartial<ActionResponse_UpdatedWidget>): ActionResponse_UpdatedWidget {
    return ActionResponse_UpdatedWidget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActionResponse_UpdatedWidget>): ActionResponse_UpdatedWidget {
    const message = createBaseActionResponse_UpdatedWidget();
    message.suggestions = (object.suggestions !== undefined && object.suggestions !== null)
      ? ActionResponse_SelectionItems.fromPartial(object.suggestions)
      : undefined;
    message.widget = object.widget ?? "";
    return message;
  },
};

function createBaseAccessoryWidget(): AccessoryWidget {
  return { buttonList: undefined };
}

export const AccessoryWidget: MessageFns<AccessoryWidget> = {
  encode(message: AccessoryWidget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buttonList !== undefined) {
      ButtonList.encode(message.buttonList, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessoryWidget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessoryWidget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buttonList = ButtonList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessoryWidget {
    return { buttonList: isSet(object.buttonList) ? ButtonList.fromJSON(object.buttonList) : undefined };
  },

  toJSON(message: AccessoryWidget): unknown {
    const obj: any = {};
    if (message.buttonList !== undefined) {
      obj.buttonList = ButtonList.toJSON(message.buttonList);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessoryWidget>): AccessoryWidget {
    return AccessoryWidget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessoryWidget>): AccessoryWidget {
    const message = createBaseAccessoryWidget();
    message.buttonList = (object.buttonList !== undefined && object.buttonList !== null)
      ? ButtonList.fromPartial(object.buttonList)
      : undefined;
    return message;
  },
};

function createBaseGetMessageRequest(): GetMessageRequest {
  return { name: "" };
}

export const GetMessageRequest: MessageFns<GetMessageRequest> = {
  encode(message: GetMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessageRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetMessageRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetMessageRequest>): GetMessageRequest {
    return GetMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMessageRequest>): GetMessageRequest {
    const message = createBaseGetMessageRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteMessageRequest(): DeleteMessageRequest {
  return { name: "", force: false };
}

export const DeleteMessageRequest: MessageFns<DeleteMessageRequest> = {
  encode(message: DeleteMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteMessageRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteMessageRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteMessageRequest>): DeleteMessageRequest {
    return DeleteMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteMessageRequest>): DeleteMessageRequest {
    const message = createBaseDeleteMessageRequest();
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseUpdateMessageRequest(): UpdateMessageRequest {
  return { message: undefined, updateMask: undefined, allowMissing: false };
}

export const UpdateMessageRequest: MessageFns<UpdateMessageRequest> = {
  encode(message: UpdateMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateMessageRequest {
    return {
      message: isSet(object.message) ? Message.fromJSON(object.message) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateMessageRequest): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateMessageRequest>): UpdateMessageRequest {
    return UpdateMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateMessageRequest>): UpdateMessageRequest {
    const message = createBaseUpdateMessageRequest();
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseCreateMessageRequest(): CreateMessageRequest {
  return { parent: "", message: undefined, threadKey: "", requestId: "", messageReplyOption: 0, messageId: "" };
}

export const CreateMessageRequest: MessageFns<CreateMessageRequest> = {
  encode(message: CreateMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.message !== undefined) {
      Message.encode(message.message, writer.uint32(34).fork()).join();
    }
    if (message.threadKey !== "") {
      writer.uint32(50).string(message.threadKey);
    }
    if (message.requestId !== "") {
      writer.uint32(58).string(message.requestId);
    }
    if (message.messageReplyOption !== 0) {
      writer.uint32(64).int32(message.messageReplyOption);
    }
    if (message.messageId !== "") {
      writer.uint32(74).string(message.messageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = Message.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.threadKey = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.messageReplyOption = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.messageId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateMessageRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      message: isSet(object.message) ? Message.fromJSON(object.message) : undefined,
      threadKey: isSet(object.threadKey) ? globalThis.String(object.threadKey) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      messageReplyOption: isSet(object.messageReplyOption)
        ? createMessageRequest_MessageReplyOptionFromJSON(object.messageReplyOption)
        : 0,
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
    };
  },

  toJSON(message: CreateMessageRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.message !== undefined) {
      obj.message = Message.toJSON(message.message);
    }
    if (message.threadKey !== "") {
      obj.threadKey = message.threadKey;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.messageReplyOption !== 0) {
      obj.messageReplyOption = createMessageRequest_MessageReplyOptionToJSON(message.messageReplyOption);
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateMessageRequest>): CreateMessageRequest {
    return CreateMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateMessageRequest>): CreateMessageRequest {
    const message = createBaseCreateMessageRequest();
    message.parent = object.parent ?? "";
    message.message = (object.message !== undefined && object.message !== null)
      ? Message.fromPartial(object.message)
      : undefined;
    message.threadKey = object.threadKey ?? "";
    message.requestId = object.requestId ?? "";
    message.messageReplyOption = object.messageReplyOption ?? 0;
    message.messageId = object.messageId ?? "";
    return message;
  },
};

function createBaseListMessagesRequest(): ListMessagesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "", showDeleted: false };
}

export const ListMessagesRequest: MessageFns<ListMessagesRequest> = {
  encode(message: ListMessagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    if (message.showDeleted !== false) {
      writer.uint32(48).bool(message.showDeleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMessagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.showDeleted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMessagesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      showDeleted: isSet(object.showDeleted) ? globalThis.Boolean(object.showDeleted) : false,
    };
  },

  toJSON(message: ListMessagesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.showDeleted !== false) {
      obj.showDeleted = message.showDeleted;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMessagesRequest>): ListMessagesRequest {
    return ListMessagesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMessagesRequest>): ListMessagesRequest {
    const message = createBaseListMessagesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.showDeleted = object.showDeleted ?? false;
    return message;
  },
};

function createBaseListMessagesResponse(): ListMessagesResponse {
  return { messages: [], nextPageToken: "" };
}

export const ListMessagesResponse: MessageFns<ListMessagesResponse> = {
  encode(message: ListMessagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListMessagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListMessagesResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListMessagesResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Message.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListMessagesResponse>): ListMessagesResponse {
    return ListMessagesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListMessagesResponse>): ListMessagesResponse {
    const message = createBaseListMessagesResponse();
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDialogAction(): DialogAction {
  return { dialog: undefined, actionStatus: undefined };
}

export const DialogAction: MessageFns<DialogAction> = {
  encode(message: DialogAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dialog !== undefined) {
      Dialog.encode(message.dialog, writer.uint32(10).fork()).join();
    }
    if (message.actionStatus !== undefined) {
      ActionStatus.encode(message.actionStatus, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dialog = Dialog.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actionStatus = ActionStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogAction {
    return {
      dialog: isSet(object.dialog) ? Dialog.fromJSON(object.dialog) : undefined,
      actionStatus: isSet(object.actionStatus) ? ActionStatus.fromJSON(object.actionStatus) : undefined,
    };
  },

  toJSON(message: DialogAction): unknown {
    const obj: any = {};
    if (message.dialog !== undefined) {
      obj.dialog = Dialog.toJSON(message.dialog);
    }
    if (message.actionStatus !== undefined) {
      obj.actionStatus = ActionStatus.toJSON(message.actionStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<DialogAction>): DialogAction {
    return DialogAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DialogAction>): DialogAction {
    const message = createBaseDialogAction();
    message.dialog = (object.dialog !== undefined && object.dialog !== null)
      ? Dialog.fromPartial(object.dialog)
      : undefined;
    message.actionStatus = (object.actionStatus !== undefined && object.actionStatus !== null)
      ? ActionStatus.fromPartial(object.actionStatus)
      : undefined;
    return message;
  },
};

function createBaseDialog(): Dialog {
  return { body: undefined };
}

export const Dialog: MessageFns<Dialog> = {
  encode(message: Dialog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.body !== undefined) {
      Card.encode(message.body, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dialog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.body = Card.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dialog {
    return { body: isSet(object.body) ? Card.fromJSON(object.body) : undefined };
  },

  toJSON(message: Dialog): unknown {
    const obj: any = {};
    if (message.body !== undefined) {
      obj.body = Card.toJSON(message.body);
    }
    return obj;
  },

  create(base?: DeepPartial<Dialog>): Dialog {
    return Dialog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Dialog>): Dialog {
    const message = createBaseDialog();
    message.body = (object.body !== undefined && object.body !== null) ? Card.fromPartial(object.body) : undefined;
    return message;
  },
};

function createBaseCardWithId(): CardWithId {
  return { cardId: "", card: undefined };
}

export const CardWithId: MessageFns<CardWithId> = {
  encode(message: CardWithId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardId !== "") {
      writer.uint32(10).string(message.cardId);
    }
    if (message.card !== undefined) {
      Card.encode(message.card, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CardWithId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCardWithId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cardId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.card = Card.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CardWithId {
    return {
      cardId: isSet(object.cardId) ? globalThis.String(object.cardId) : "",
      card: isSet(object.card) ? Card.fromJSON(object.card) : undefined,
    };
  },

  toJSON(message: CardWithId): unknown {
    const obj: any = {};
    if (message.cardId !== "") {
      obj.cardId = message.cardId;
    }
    if (message.card !== undefined) {
      obj.card = Card.toJSON(message.card);
    }
    return obj;
  },

  create(base?: DeepPartial<CardWithId>): CardWithId {
    return CardWithId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CardWithId>): CardWithId {
    const message = createBaseCardWithId();
    message.cardId = object.cardId ?? "";
    message.card = (object.card !== undefined && object.card !== null) ? Card.fromPartial(object.card) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
