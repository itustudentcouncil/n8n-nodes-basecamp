// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/analytics/admin/v1alpha/audience.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.analytics.admin.v1alpha";

/** Specifies how to evaluate users for joining an Audience. */
export enum AudienceFilterScope {
  /** AUDIENCE_FILTER_SCOPE_UNSPECIFIED - Scope is not specified. */
  AUDIENCE_FILTER_SCOPE_UNSPECIFIED = 0,
  /**
   * AUDIENCE_FILTER_SCOPE_WITHIN_SAME_EVENT - User joins the Audience if the filter condition is met within one
   * event.
   */
  AUDIENCE_FILTER_SCOPE_WITHIN_SAME_EVENT = 1,
  /**
   * AUDIENCE_FILTER_SCOPE_WITHIN_SAME_SESSION - User joins the Audience if the filter condition is met within one
   * session.
   */
  AUDIENCE_FILTER_SCOPE_WITHIN_SAME_SESSION = 2,
  /**
   * AUDIENCE_FILTER_SCOPE_ACROSS_ALL_SESSIONS - User joins the Audience if the filter condition is met by any event
   * across any session.
   */
  AUDIENCE_FILTER_SCOPE_ACROSS_ALL_SESSIONS = 3,
  UNRECOGNIZED = -1,
}

export function audienceFilterScopeFromJSON(object: any): AudienceFilterScope {
  switch (object) {
    case 0:
    case "AUDIENCE_FILTER_SCOPE_UNSPECIFIED":
      return AudienceFilterScope.AUDIENCE_FILTER_SCOPE_UNSPECIFIED;
    case 1:
    case "AUDIENCE_FILTER_SCOPE_WITHIN_SAME_EVENT":
      return AudienceFilterScope.AUDIENCE_FILTER_SCOPE_WITHIN_SAME_EVENT;
    case 2:
    case "AUDIENCE_FILTER_SCOPE_WITHIN_SAME_SESSION":
      return AudienceFilterScope.AUDIENCE_FILTER_SCOPE_WITHIN_SAME_SESSION;
    case 3:
    case "AUDIENCE_FILTER_SCOPE_ACROSS_ALL_SESSIONS":
      return AudienceFilterScope.AUDIENCE_FILTER_SCOPE_ACROSS_ALL_SESSIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudienceFilterScope.UNRECOGNIZED;
  }
}

export function audienceFilterScopeToJSON(object: AudienceFilterScope): string {
  switch (object) {
    case AudienceFilterScope.AUDIENCE_FILTER_SCOPE_UNSPECIFIED:
      return "AUDIENCE_FILTER_SCOPE_UNSPECIFIED";
    case AudienceFilterScope.AUDIENCE_FILTER_SCOPE_WITHIN_SAME_EVENT:
      return "AUDIENCE_FILTER_SCOPE_WITHIN_SAME_EVENT";
    case AudienceFilterScope.AUDIENCE_FILTER_SCOPE_WITHIN_SAME_SESSION:
      return "AUDIENCE_FILTER_SCOPE_WITHIN_SAME_SESSION";
    case AudienceFilterScope.AUDIENCE_FILTER_SCOPE_ACROSS_ALL_SESSIONS:
      return "AUDIENCE_FILTER_SCOPE_ACROSS_ALL_SESSIONS";
    case AudienceFilterScope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A specific filter for a single dimension or metric. */
export interface AudienceDimensionOrMetricFilter {
  /** A filter for a string-type dimension that matches a particular pattern. */
  stringFilter?:
    | AudienceDimensionOrMetricFilter_StringFilter
    | undefined;
  /**
   * A filter for a string dimension that matches a particular list of
   * options.
   */
  inListFilter?:
    | AudienceDimensionOrMetricFilter_InListFilter
    | undefined;
  /** A filter for numeric or date values on a dimension or metric. */
  numericFilter?:
    | AudienceDimensionOrMetricFilter_NumericFilter
    | undefined;
  /**
   * A filter for numeric or date values between certain values on a dimension
   * or metric.
   */
  betweenFilter?:
    | AudienceDimensionOrMetricFilter_BetweenFilter
    | undefined;
  /**
   * Required. Immutable. The dimension name or metric name to filter. If the
   * field name refers to a custom dimension or metric, a scope prefix will be
   * added to the front of the custom dimensions or metric name. For more on
   * scope prefixes or custom dimensions/metrics, reference the [Google
   * Analytics Data API documentation]
   * (https://developers.google.com/analytics/devguides/reporting/data/v1/api-schema#custom_dimensions).
   */
  fieldName: string;
  /**
   * Optional. Indicates whether this filter needs dynamic evaluation or not. If
   * set to true, users join the Audience if they ever met the condition (static
   * evaluation). If unset or set to false, user evaluation for an Audience is
   * dynamic; users are added to an Audience when they meet the conditions and
   * then removed when they no longer meet them.
   *
   * This can only be set when Audience scope is ACROSS_ALL_SESSIONS.
   */
  atAnyPointInTime: boolean;
  /**
   * Optional. If set, specifies the time window for which to evaluate data in
   * number of days. If not set, then audience data is evaluated against
   * lifetime data (For example, infinite time window).
   *
   * For example, if set to 1 day, only the current day's data is evaluated. The
   * reference point is the current day when at_any_point_in_time is unset or
   * false.
   *
   * It can only be set when Audience scope is ACROSS_ALL_SESSIONS and cannot be
   * greater than 60 days.
   */
  inAnyNDayPeriod: number;
}

/** A filter for a string-type dimension that matches a particular pattern. */
export interface AudienceDimensionOrMetricFilter_StringFilter {
  /** Required. The match type for the string filter. */
  matchType: AudienceDimensionOrMetricFilter_StringFilter_MatchType;
  /** Required. The string value to be matched against. */
  value: string;
  /**
   * Optional. If true, the match is case-sensitive. If false, the match is
   * case-insensitive.
   */
  caseSensitive: boolean;
}

/** The match type for the string filter. */
export enum AudienceDimensionOrMetricFilter_StringFilter_MatchType {
  /** MATCH_TYPE_UNSPECIFIED - Unspecified */
  MATCH_TYPE_UNSPECIFIED = 0,
  /** EXACT - Exact match of the string value. */
  EXACT = 1,
  /** BEGINS_WITH - Begins with the string value. */
  BEGINS_WITH = 2,
  /** ENDS_WITH - Ends with the string value. */
  ENDS_WITH = 3,
  /** CONTAINS - Contains the string value. */
  CONTAINS = 4,
  /** FULL_REGEXP - Full regular expression matches with the string value. */
  FULL_REGEXP = 5,
  UNRECOGNIZED = -1,
}

export function audienceDimensionOrMetricFilter_StringFilter_MatchTypeFromJSON(
  object: any,
): AudienceDimensionOrMetricFilter_StringFilter_MatchType {
  switch (object) {
    case 0:
    case "MATCH_TYPE_UNSPECIFIED":
      return AudienceDimensionOrMetricFilter_StringFilter_MatchType.MATCH_TYPE_UNSPECIFIED;
    case 1:
    case "EXACT":
      return AudienceDimensionOrMetricFilter_StringFilter_MatchType.EXACT;
    case 2:
    case "BEGINS_WITH":
      return AudienceDimensionOrMetricFilter_StringFilter_MatchType.BEGINS_WITH;
    case 3:
    case "ENDS_WITH":
      return AudienceDimensionOrMetricFilter_StringFilter_MatchType.ENDS_WITH;
    case 4:
    case "CONTAINS":
      return AudienceDimensionOrMetricFilter_StringFilter_MatchType.CONTAINS;
    case 5:
    case "FULL_REGEXP":
      return AudienceDimensionOrMetricFilter_StringFilter_MatchType.FULL_REGEXP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudienceDimensionOrMetricFilter_StringFilter_MatchType.UNRECOGNIZED;
  }
}

export function audienceDimensionOrMetricFilter_StringFilter_MatchTypeToJSON(
  object: AudienceDimensionOrMetricFilter_StringFilter_MatchType,
): string {
  switch (object) {
    case AudienceDimensionOrMetricFilter_StringFilter_MatchType.MATCH_TYPE_UNSPECIFIED:
      return "MATCH_TYPE_UNSPECIFIED";
    case AudienceDimensionOrMetricFilter_StringFilter_MatchType.EXACT:
      return "EXACT";
    case AudienceDimensionOrMetricFilter_StringFilter_MatchType.BEGINS_WITH:
      return "BEGINS_WITH";
    case AudienceDimensionOrMetricFilter_StringFilter_MatchType.ENDS_WITH:
      return "ENDS_WITH";
    case AudienceDimensionOrMetricFilter_StringFilter_MatchType.CONTAINS:
      return "CONTAINS";
    case AudienceDimensionOrMetricFilter_StringFilter_MatchType.FULL_REGEXP:
      return "FULL_REGEXP";
    case AudienceDimensionOrMetricFilter_StringFilter_MatchType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A filter for a string dimension that matches a particular list of options. */
export interface AudienceDimensionOrMetricFilter_InListFilter {
  /**
   * Required. The list of possible string values to match against. Must be
   * non-empty.
   */
  values: string[];
  /**
   * Optional. If true, the match is case-sensitive. If false, the match is
   * case-insensitive.
   */
  caseSensitive: boolean;
}

/** To represent a number. */
export interface AudienceDimensionOrMetricFilter_NumericValue {
  /** Integer value. */
  int64Value?:
    | Long
    | undefined;
  /** Double value. */
  doubleValue?: number | undefined;
}

/** A filter for numeric or date values on a dimension or metric. */
export interface AudienceDimensionOrMetricFilter_NumericFilter {
  /** Required. The operation applied to a numeric filter. */
  operation: AudienceDimensionOrMetricFilter_NumericFilter_Operation;
  /** Required. The numeric or date value to match against. */
  value: AudienceDimensionOrMetricFilter_NumericValue | undefined;
}

/** The operation applied to a numeric filter. */
export enum AudienceDimensionOrMetricFilter_NumericFilter_Operation {
  /** OPERATION_UNSPECIFIED - Unspecified. */
  OPERATION_UNSPECIFIED = 0,
  /** EQUAL - Equal. */
  EQUAL = 1,
  /** LESS_THAN - Less than. */
  LESS_THAN = 2,
  /** GREATER_THAN - Greater than. */
  GREATER_THAN = 4,
  UNRECOGNIZED = -1,
}

export function audienceDimensionOrMetricFilter_NumericFilter_OperationFromJSON(
  object: any,
): AudienceDimensionOrMetricFilter_NumericFilter_Operation {
  switch (object) {
    case 0:
    case "OPERATION_UNSPECIFIED":
      return AudienceDimensionOrMetricFilter_NumericFilter_Operation.OPERATION_UNSPECIFIED;
    case 1:
    case "EQUAL":
      return AudienceDimensionOrMetricFilter_NumericFilter_Operation.EQUAL;
    case 2:
    case "LESS_THAN":
      return AudienceDimensionOrMetricFilter_NumericFilter_Operation.LESS_THAN;
    case 4:
    case "GREATER_THAN":
      return AudienceDimensionOrMetricFilter_NumericFilter_Operation.GREATER_THAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudienceDimensionOrMetricFilter_NumericFilter_Operation.UNRECOGNIZED;
  }
}

export function audienceDimensionOrMetricFilter_NumericFilter_OperationToJSON(
  object: AudienceDimensionOrMetricFilter_NumericFilter_Operation,
): string {
  switch (object) {
    case AudienceDimensionOrMetricFilter_NumericFilter_Operation.OPERATION_UNSPECIFIED:
      return "OPERATION_UNSPECIFIED";
    case AudienceDimensionOrMetricFilter_NumericFilter_Operation.EQUAL:
      return "EQUAL";
    case AudienceDimensionOrMetricFilter_NumericFilter_Operation.LESS_THAN:
      return "LESS_THAN";
    case AudienceDimensionOrMetricFilter_NumericFilter_Operation.GREATER_THAN:
      return "GREATER_THAN";
    case AudienceDimensionOrMetricFilter_NumericFilter_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A filter for numeric or date values between certain values on a dimension
 * or metric.
 */
export interface AudienceDimensionOrMetricFilter_BetweenFilter {
  /** Required. Begins with this number, inclusive. */
  fromValue:
    | AudienceDimensionOrMetricFilter_NumericValue
    | undefined;
  /** Required. Ends with this number, inclusive. */
  toValue: AudienceDimensionOrMetricFilter_NumericValue | undefined;
}

/**
 * A filter that matches events of a single event name. If an event parameter
 * is specified, only the subset of events that match both the single event name
 * and the parameter filter expressions match this event filter.
 */
export interface AudienceEventFilter {
  /** Required. Immutable. The name of the event to match against. */
  eventName: string;
  /**
   * Optional. If specified, this filter matches events that match both the
   * single event name and the parameter filter expressions. AudienceEventFilter
   * inside the parameter filter expression cannot be set (For example, nested
   * event filters are not supported). This should be a single and_group of
   * dimension_or_metric_filter or not_expression; ANDs of ORs are not
   * supported. Also, if it includes a filter for "eventCount", only that one
   * will be considered; all the other filters will be ignored.
   */
  eventParameterFilterExpression: AudienceFilterExpression | undefined;
}

/** A logical expression of Audience dimension, metric, or event filters. */
export interface AudienceFilterExpression {
  /**
   * A list of expressions to be AND’ed together. It can only contain
   * AudienceFilterExpressions with or_group. This must be set for the top
   * level AudienceFilterExpression.
   */
  andGroup?:
    | AudienceFilterExpressionList
    | undefined;
  /**
   * A list of expressions to OR’ed together. It cannot contain
   * AudienceFilterExpressions with and_group or or_group.
   */
  orGroup?:
    | AudienceFilterExpressionList
    | undefined;
  /**
   * A filter expression to be NOT'ed (For example, inverted, complemented).
   * It can only include a dimension_or_metric_filter. This cannot be set on
   * the top level AudienceFilterExpression.
   */
  notExpression?:
    | AudienceFilterExpression
    | undefined;
  /**
   * A filter on a single dimension or metric. This cannot be set on the top
   * level AudienceFilterExpression.
   */
  dimensionOrMetricFilter?:
    | AudienceDimensionOrMetricFilter
    | undefined;
  /**
   * Creates a filter that matches a specific event. This cannot be set on the
   * top level AudienceFilterExpression.
   */
  eventFilter?: AudienceEventFilter | undefined;
}

/** A list of Audience filter expressions. */
export interface AudienceFilterExpressionList {
  /** A list of Audience filter expressions. */
  filterExpressions: AudienceFilterExpression[];
}

/**
 * Defines a simple filter that a user must satisfy to be a member of the
 * Audience.
 */
export interface AudienceSimpleFilter {
  /** Required. Immutable. Specifies the scope for this filter. */
  scope: AudienceFilterScope;
  /**
   * Required. Immutable. A logical expression of Audience dimension, metric, or
   * event filters.
   */
  filterExpression: AudienceFilterExpression | undefined;
}

/**
 * Defines filters that must occur in a specific order for the user to be a
 * member of the Audience.
 */
export interface AudienceSequenceFilter {
  /** Required. Immutable. Specifies the scope for this filter. */
  scope: AudienceFilterScope;
  /** Optional. Defines the time period in which the whole sequence must occur. */
  sequenceMaximumDuration:
    | Duration
    | undefined;
  /**
   * Required. An ordered sequence of steps. A user must complete each step in
   * order to join the sequence filter.
   */
  sequenceSteps: AudienceSequenceFilter_AudienceSequenceStep[];
}

/**
 * A condition that must occur in the specified step order for this user
 * to match the sequence.
 */
export interface AudienceSequenceFilter_AudienceSequenceStep {
  /** Required. Immutable. Specifies the scope for this step. */
  scope: AudienceFilterScope;
  /**
   * Optional. If true, the event satisfying this step must be the very next
   * event after the event satisfying the last step. If unset or false, this
   * step indirectly follows the prior step; for example, there may be
   * events between the prior step and this step. It is ignored for the
   * first step.
   */
  immediatelyFollows: boolean;
  /**
   * Optional. When set, this step must be satisfied within the
   * constraint_duration of the previous step (For example,  t[i] - t[i-1] <=
   * constraint_duration). If not set, there is no duration requirement (the
   * duration is effectively unlimited). It is ignored for the first step.
   */
  constraintDuration:
    | Duration
    | undefined;
  /**
   * Required. Immutable. A logical expression of Audience dimension, metric,
   * or event filters in each step.
   */
  filterExpression: AudienceFilterExpression | undefined;
}

/**
 * A clause for defining either a simple or sequence filter. A filter can be
 * inclusive (For example, users satisfying the filter clause are included in
 * the Audience) or exclusive (For example, users satisfying the filter clause
 * are excluded from the Audience).
 */
export interface AudienceFilterClause {
  /** A simple filter that a user must satisfy to be a member of the Audience. */
  simpleFilter?:
    | AudienceSimpleFilter
    | undefined;
  /**
   * Filters that must occur in a specific order for the user to be a member
   * of the Audience.
   */
  sequenceFilter?:
    | AudienceSequenceFilter
    | undefined;
  /** Required. Specifies whether this is an include or exclude filter clause. */
  clauseType: AudienceFilterClause_AudienceClauseType;
}

/** Specifies whether this is an include or exclude filter clause. */
export enum AudienceFilterClause_AudienceClauseType {
  /** AUDIENCE_CLAUSE_TYPE_UNSPECIFIED - Unspecified clause type. */
  AUDIENCE_CLAUSE_TYPE_UNSPECIFIED = 0,
  /** INCLUDE - Users will be included in the Audience if the filter clause is met. */
  INCLUDE = 1,
  /** EXCLUDE - Users will be excluded from the Audience if the filter clause is met. */
  EXCLUDE = 2,
  UNRECOGNIZED = -1,
}

export function audienceFilterClause_AudienceClauseTypeFromJSON(object: any): AudienceFilterClause_AudienceClauseType {
  switch (object) {
    case 0:
    case "AUDIENCE_CLAUSE_TYPE_UNSPECIFIED":
      return AudienceFilterClause_AudienceClauseType.AUDIENCE_CLAUSE_TYPE_UNSPECIFIED;
    case 1:
    case "INCLUDE":
      return AudienceFilterClause_AudienceClauseType.INCLUDE;
    case 2:
    case "EXCLUDE":
      return AudienceFilterClause_AudienceClauseType.EXCLUDE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudienceFilterClause_AudienceClauseType.UNRECOGNIZED;
  }
}

export function audienceFilterClause_AudienceClauseTypeToJSON(object: AudienceFilterClause_AudienceClauseType): string {
  switch (object) {
    case AudienceFilterClause_AudienceClauseType.AUDIENCE_CLAUSE_TYPE_UNSPECIFIED:
      return "AUDIENCE_CLAUSE_TYPE_UNSPECIFIED";
    case AudienceFilterClause_AudienceClauseType.INCLUDE:
      return "INCLUDE";
    case AudienceFilterClause_AudienceClauseType.EXCLUDE:
      return "EXCLUDE";
    case AudienceFilterClause_AudienceClauseType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies an event to log when a user joins the Audience. */
export interface AudienceEventTrigger {
  /** Required. The event name that will be logged. */
  eventName: string;
  /** Required. When to log the event. */
  logCondition: AudienceEventTrigger_LogCondition;
}

/** Determines when to log the event. */
export enum AudienceEventTrigger_LogCondition {
  /** LOG_CONDITION_UNSPECIFIED - Log condition is not specified. */
  LOG_CONDITION_UNSPECIFIED = 0,
  /** AUDIENCE_JOINED - The event should be logged only when a user is joined. */
  AUDIENCE_JOINED = 1,
  /**
   * AUDIENCE_MEMBERSHIP_RENEWED - The event should be logged whenever the Audience condition is met, even
   * if the user is already a member of the Audience.
   */
  AUDIENCE_MEMBERSHIP_RENEWED = 2,
  UNRECOGNIZED = -1,
}

export function audienceEventTrigger_LogConditionFromJSON(object: any): AudienceEventTrigger_LogCondition {
  switch (object) {
    case 0:
    case "LOG_CONDITION_UNSPECIFIED":
      return AudienceEventTrigger_LogCondition.LOG_CONDITION_UNSPECIFIED;
    case 1:
    case "AUDIENCE_JOINED":
      return AudienceEventTrigger_LogCondition.AUDIENCE_JOINED;
    case 2:
    case "AUDIENCE_MEMBERSHIP_RENEWED":
      return AudienceEventTrigger_LogCondition.AUDIENCE_MEMBERSHIP_RENEWED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudienceEventTrigger_LogCondition.UNRECOGNIZED;
  }
}

export function audienceEventTrigger_LogConditionToJSON(object: AudienceEventTrigger_LogCondition): string {
  switch (object) {
    case AudienceEventTrigger_LogCondition.LOG_CONDITION_UNSPECIFIED:
      return "LOG_CONDITION_UNSPECIFIED";
    case AudienceEventTrigger_LogCondition.AUDIENCE_JOINED:
      return "AUDIENCE_JOINED";
    case AudienceEventTrigger_LogCondition.AUDIENCE_MEMBERSHIP_RENEWED:
      return "AUDIENCE_MEMBERSHIP_RENEWED";
    case AudienceEventTrigger_LogCondition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A resource message representing a GA4 Audience. */
export interface Audience {
  /**
   * Output only. The resource name for this Audience resource.
   * Format: properties/{propertyId}/audiences/{audienceId}
   */
  name: string;
  /** Required. The display name of the Audience. */
  displayName: string;
  /** Required. The description of the Audience. */
  description: string;
  /**
   * Required. Immutable. The duration a user should stay in an Audience. It
   * cannot be set to more than 540 days.
   */
  membershipDurationDays: number;
  /**
   * Output only. It is automatically set by GA to false if this is an NPA
   * Audience and is excluded from ads personalization.
   */
  adsPersonalizationEnabled: boolean;
  /**
   * Optional. Specifies an event to log when a user joins the Audience. If not
   * set, no event is logged when a user joins the Audience.
   */
  eventTrigger:
    | AudienceEventTrigger
    | undefined;
  /**
   * Immutable. Specifies how long an exclusion lasts for users that meet the
   * exclusion filter. It is applied to all EXCLUDE filter clauses and is
   * ignored when there is no EXCLUDE filter clause in the Audience.
   */
  exclusionDurationMode: Audience_AudienceExclusionDurationMode;
  /**
   * Required. Immutable. Unordered list. Filter clauses that define the
   * Audience. All clauses will be AND’ed together.
   */
  filterClauses: AudienceFilterClause[];
  /** Output only. Time when the Audience was created. */
  createTime: Date | undefined;
}

/**
 * Specifies how long an exclusion lasts for users that meet the exclusion
 * filter.
 */
export enum Audience_AudienceExclusionDurationMode {
  /** AUDIENCE_EXCLUSION_DURATION_MODE_UNSPECIFIED - Not specified. */
  AUDIENCE_EXCLUSION_DURATION_MODE_UNSPECIFIED = 0,
  /**
   * EXCLUDE_TEMPORARILY - Exclude users from the Audience during periods when they meet the
   * filter clause.
   */
  EXCLUDE_TEMPORARILY = 1,
  /** EXCLUDE_PERMANENTLY - Exclude users from the Audience if they've ever met the filter clause. */
  EXCLUDE_PERMANENTLY = 2,
  UNRECOGNIZED = -1,
}

export function audience_AudienceExclusionDurationModeFromJSON(object: any): Audience_AudienceExclusionDurationMode {
  switch (object) {
    case 0:
    case "AUDIENCE_EXCLUSION_DURATION_MODE_UNSPECIFIED":
      return Audience_AudienceExclusionDurationMode.AUDIENCE_EXCLUSION_DURATION_MODE_UNSPECIFIED;
    case 1:
    case "EXCLUDE_TEMPORARILY":
      return Audience_AudienceExclusionDurationMode.EXCLUDE_TEMPORARILY;
    case 2:
    case "EXCLUDE_PERMANENTLY":
      return Audience_AudienceExclusionDurationMode.EXCLUDE_PERMANENTLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Audience_AudienceExclusionDurationMode.UNRECOGNIZED;
  }
}

export function audience_AudienceExclusionDurationModeToJSON(object: Audience_AudienceExclusionDurationMode): string {
  switch (object) {
    case Audience_AudienceExclusionDurationMode.AUDIENCE_EXCLUSION_DURATION_MODE_UNSPECIFIED:
      return "AUDIENCE_EXCLUSION_DURATION_MODE_UNSPECIFIED";
    case Audience_AudienceExclusionDurationMode.EXCLUDE_TEMPORARILY:
      return "EXCLUDE_TEMPORARILY";
    case Audience_AudienceExclusionDurationMode.EXCLUDE_PERMANENTLY:
      return "EXCLUDE_PERMANENTLY";
    case Audience_AudienceExclusionDurationMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseAudienceDimensionOrMetricFilter(): AudienceDimensionOrMetricFilter {
  return {
    stringFilter: undefined,
    inListFilter: undefined,
    numericFilter: undefined,
    betweenFilter: undefined,
    fieldName: "",
    atAnyPointInTime: false,
    inAnyNDayPeriod: 0,
  };
}

export const AudienceDimensionOrMetricFilter: MessageFns<AudienceDimensionOrMetricFilter> = {
  encode(message: AudienceDimensionOrMetricFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringFilter !== undefined) {
      AudienceDimensionOrMetricFilter_StringFilter.encode(message.stringFilter, writer.uint32(18).fork()).join();
    }
    if (message.inListFilter !== undefined) {
      AudienceDimensionOrMetricFilter_InListFilter.encode(message.inListFilter, writer.uint32(26).fork()).join();
    }
    if (message.numericFilter !== undefined) {
      AudienceDimensionOrMetricFilter_NumericFilter.encode(message.numericFilter, writer.uint32(34).fork()).join();
    }
    if (message.betweenFilter !== undefined) {
      AudienceDimensionOrMetricFilter_BetweenFilter.encode(message.betweenFilter, writer.uint32(42).fork()).join();
    }
    if (message.fieldName !== "") {
      writer.uint32(10).string(message.fieldName);
    }
    if (message.atAnyPointInTime !== false) {
      writer.uint32(48).bool(message.atAnyPointInTime);
    }
    if (message.inAnyNDayPeriod !== 0) {
      writer.uint32(56).int32(message.inAnyNDayPeriod);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceDimensionOrMetricFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceDimensionOrMetricFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stringFilter = AudienceDimensionOrMetricFilter_StringFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inListFilter = AudienceDimensionOrMetricFilter_InListFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.numericFilter = AudienceDimensionOrMetricFilter_NumericFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.betweenFilter = AudienceDimensionOrMetricFilter_BetweenFilter.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.atAnyPointInTime = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.inAnyNDayPeriod = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceDimensionOrMetricFilter {
    return {
      stringFilter: isSet(object.stringFilter)
        ? AudienceDimensionOrMetricFilter_StringFilter.fromJSON(object.stringFilter)
        : undefined,
      inListFilter: isSet(object.inListFilter)
        ? AudienceDimensionOrMetricFilter_InListFilter.fromJSON(object.inListFilter)
        : undefined,
      numericFilter: isSet(object.numericFilter)
        ? AudienceDimensionOrMetricFilter_NumericFilter.fromJSON(object.numericFilter)
        : undefined,
      betweenFilter: isSet(object.betweenFilter)
        ? AudienceDimensionOrMetricFilter_BetweenFilter.fromJSON(object.betweenFilter)
        : undefined,
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
      atAnyPointInTime: isSet(object.atAnyPointInTime) ? globalThis.Boolean(object.atAnyPointInTime) : false,
      inAnyNDayPeriod: isSet(object.inAnyNDayPeriod) ? globalThis.Number(object.inAnyNDayPeriod) : 0,
    };
  },

  toJSON(message: AudienceDimensionOrMetricFilter): unknown {
    const obj: any = {};
    if (message.stringFilter !== undefined) {
      obj.stringFilter = AudienceDimensionOrMetricFilter_StringFilter.toJSON(message.stringFilter);
    }
    if (message.inListFilter !== undefined) {
      obj.inListFilter = AudienceDimensionOrMetricFilter_InListFilter.toJSON(message.inListFilter);
    }
    if (message.numericFilter !== undefined) {
      obj.numericFilter = AudienceDimensionOrMetricFilter_NumericFilter.toJSON(message.numericFilter);
    }
    if (message.betweenFilter !== undefined) {
      obj.betweenFilter = AudienceDimensionOrMetricFilter_BetweenFilter.toJSON(message.betweenFilter);
    }
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    if (message.atAnyPointInTime !== false) {
      obj.atAnyPointInTime = message.atAnyPointInTime;
    }
    if (message.inAnyNDayPeriod !== 0) {
      obj.inAnyNDayPeriod = Math.round(message.inAnyNDayPeriod);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceDimensionOrMetricFilter>): AudienceDimensionOrMetricFilter {
    return AudienceDimensionOrMetricFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceDimensionOrMetricFilter>): AudienceDimensionOrMetricFilter {
    const message = createBaseAudienceDimensionOrMetricFilter();
    message.stringFilter = (object.stringFilter !== undefined && object.stringFilter !== null)
      ? AudienceDimensionOrMetricFilter_StringFilter.fromPartial(object.stringFilter)
      : undefined;
    message.inListFilter = (object.inListFilter !== undefined && object.inListFilter !== null)
      ? AudienceDimensionOrMetricFilter_InListFilter.fromPartial(object.inListFilter)
      : undefined;
    message.numericFilter = (object.numericFilter !== undefined && object.numericFilter !== null)
      ? AudienceDimensionOrMetricFilter_NumericFilter.fromPartial(object.numericFilter)
      : undefined;
    message.betweenFilter = (object.betweenFilter !== undefined && object.betweenFilter !== null)
      ? AudienceDimensionOrMetricFilter_BetweenFilter.fromPartial(object.betweenFilter)
      : undefined;
    message.fieldName = object.fieldName ?? "";
    message.atAnyPointInTime = object.atAnyPointInTime ?? false;
    message.inAnyNDayPeriod = object.inAnyNDayPeriod ?? 0;
    return message;
  },
};

function createBaseAudienceDimensionOrMetricFilter_StringFilter(): AudienceDimensionOrMetricFilter_StringFilter {
  return { matchType: 0, value: "", caseSensitive: false };
}

export const AudienceDimensionOrMetricFilter_StringFilter: MessageFns<AudienceDimensionOrMetricFilter_StringFilter> = {
  encode(
    message: AudienceDimensionOrMetricFilter_StringFilter,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.matchType !== 0) {
      writer.uint32(8).int32(message.matchType);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.caseSensitive !== false) {
      writer.uint32(24).bool(message.caseSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceDimensionOrMetricFilter_StringFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceDimensionOrMetricFilter_StringFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.caseSensitive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceDimensionOrMetricFilter_StringFilter {
    return {
      matchType: isSet(object.matchType)
        ? audienceDimensionOrMetricFilter_StringFilter_MatchTypeFromJSON(object.matchType)
        : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      caseSensitive: isSet(object.caseSensitive) ? globalThis.Boolean(object.caseSensitive) : false,
    };
  },

  toJSON(message: AudienceDimensionOrMetricFilter_StringFilter): unknown {
    const obj: any = {};
    if (message.matchType !== 0) {
      obj.matchType = audienceDimensionOrMetricFilter_StringFilter_MatchTypeToJSON(message.matchType);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.caseSensitive !== false) {
      obj.caseSensitive = message.caseSensitive;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AudienceDimensionOrMetricFilter_StringFilter>,
  ): AudienceDimensionOrMetricFilter_StringFilter {
    return AudienceDimensionOrMetricFilter_StringFilter.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AudienceDimensionOrMetricFilter_StringFilter>,
  ): AudienceDimensionOrMetricFilter_StringFilter {
    const message = createBaseAudienceDimensionOrMetricFilter_StringFilter();
    message.matchType = object.matchType ?? 0;
    message.value = object.value ?? "";
    message.caseSensitive = object.caseSensitive ?? false;
    return message;
  },
};

function createBaseAudienceDimensionOrMetricFilter_InListFilter(): AudienceDimensionOrMetricFilter_InListFilter {
  return { values: [], caseSensitive: false };
}

export const AudienceDimensionOrMetricFilter_InListFilter: MessageFns<AudienceDimensionOrMetricFilter_InListFilter> = {
  encode(
    message: AudienceDimensionOrMetricFilter_InListFilter,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    if (message.caseSensitive !== false) {
      writer.uint32(16).bool(message.caseSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceDimensionOrMetricFilter_InListFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceDimensionOrMetricFilter_InListFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.caseSensitive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceDimensionOrMetricFilter_InListFilter {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
      caseSensitive: isSet(object.caseSensitive) ? globalThis.Boolean(object.caseSensitive) : false,
    };
  },

  toJSON(message: AudienceDimensionOrMetricFilter_InListFilter): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.caseSensitive !== false) {
      obj.caseSensitive = message.caseSensitive;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AudienceDimensionOrMetricFilter_InListFilter>,
  ): AudienceDimensionOrMetricFilter_InListFilter {
    return AudienceDimensionOrMetricFilter_InListFilter.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AudienceDimensionOrMetricFilter_InListFilter>,
  ): AudienceDimensionOrMetricFilter_InListFilter {
    const message = createBaseAudienceDimensionOrMetricFilter_InListFilter();
    message.values = object.values?.map((e) => e) || [];
    message.caseSensitive = object.caseSensitive ?? false;
    return message;
  },
};

function createBaseAudienceDimensionOrMetricFilter_NumericValue(): AudienceDimensionOrMetricFilter_NumericValue {
  return { int64Value: undefined, doubleValue: undefined };
}

export const AudienceDimensionOrMetricFilter_NumericValue: MessageFns<AudienceDimensionOrMetricFilter_NumericValue> = {
  encode(
    message: AudienceDimensionOrMetricFilter_NumericValue,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.int64Value !== undefined) {
      writer.uint32(8).int64(message.int64Value.toString());
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(17).double(message.doubleValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceDimensionOrMetricFilter_NumericValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceDimensionOrMetricFilter_NumericValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.int64Value = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceDimensionOrMetricFilter_NumericValue {
    return {
      int64Value: isSet(object.int64Value) ? Long.fromValue(object.int64Value) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
    };
  },

  toJSON(message: AudienceDimensionOrMetricFilter_NumericValue): unknown {
    const obj: any = {};
    if (message.int64Value !== undefined) {
      obj.int64Value = (message.int64Value || Long.ZERO).toString();
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AudienceDimensionOrMetricFilter_NumericValue>,
  ): AudienceDimensionOrMetricFilter_NumericValue {
    return AudienceDimensionOrMetricFilter_NumericValue.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AudienceDimensionOrMetricFilter_NumericValue>,
  ): AudienceDimensionOrMetricFilter_NumericValue {
    const message = createBaseAudienceDimensionOrMetricFilter_NumericValue();
    message.int64Value = (object.int64Value !== undefined && object.int64Value !== null)
      ? Long.fromValue(object.int64Value)
      : undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    return message;
  },
};

function createBaseAudienceDimensionOrMetricFilter_NumericFilter(): AudienceDimensionOrMetricFilter_NumericFilter {
  return { operation: 0, value: undefined };
}

export const AudienceDimensionOrMetricFilter_NumericFilter: MessageFns<AudienceDimensionOrMetricFilter_NumericFilter> =
  {
    encode(
      message: AudienceDimensionOrMetricFilter_NumericFilter,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.operation !== 0) {
        writer.uint32(8).int32(message.operation);
      }
      if (message.value !== undefined) {
        AudienceDimensionOrMetricFilter_NumericValue.encode(message.value, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): AudienceDimensionOrMetricFilter_NumericFilter {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseAudienceDimensionOrMetricFilter_NumericFilter();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 8) {
              break;
            }

            message.operation = reader.int32() as any;
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.value = AudienceDimensionOrMetricFilter_NumericValue.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): AudienceDimensionOrMetricFilter_NumericFilter {
      return {
        operation: isSet(object.operation)
          ? audienceDimensionOrMetricFilter_NumericFilter_OperationFromJSON(object.operation)
          : 0,
        value: isSet(object.value) ? AudienceDimensionOrMetricFilter_NumericValue.fromJSON(object.value) : undefined,
      };
    },

    toJSON(message: AudienceDimensionOrMetricFilter_NumericFilter): unknown {
      const obj: any = {};
      if (message.operation !== 0) {
        obj.operation = audienceDimensionOrMetricFilter_NumericFilter_OperationToJSON(message.operation);
      }
      if (message.value !== undefined) {
        obj.value = AudienceDimensionOrMetricFilter_NumericValue.toJSON(message.value);
      }
      return obj;
    },

    create(
      base?: DeepPartial<AudienceDimensionOrMetricFilter_NumericFilter>,
    ): AudienceDimensionOrMetricFilter_NumericFilter {
      return AudienceDimensionOrMetricFilter_NumericFilter.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<AudienceDimensionOrMetricFilter_NumericFilter>,
    ): AudienceDimensionOrMetricFilter_NumericFilter {
      const message = createBaseAudienceDimensionOrMetricFilter_NumericFilter();
      message.operation = object.operation ?? 0;
      message.value = (object.value !== undefined && object.value !== null)
        ? AudienceDimensionOrMetricFilter_NumericValue.fromPartial(object.value)
        : undefined;
      return message;
    },
  };

function createBaseAudienceDimensionOrMetricFilter_BetweenFilter(): AudienceDimensionOrMetricFilter_BetweenFilter {
  return { fromValue: undefined, toValue: undefined };
}

export const AudienceDimensionOrMetricFilter_BetweenFilter: MessageFns<AudienceDimensionOrMetricFilter_BetweenFilter> =
  {
    encode(
      message: AudienceDimensionOrMetricFilter_BetweenFilter,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.fromValue !== undefined) {
        AudienceDimensionOrMetricFilter_NumericValue.encode(message.fromValue, writer.uint32(10).fork()).join();
      }
      if (message.toValue !== undefined) {
        AudienceDimensionOrMetricFilter_NumericValue.encode(message.toValue, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): AudienceDimensionOrMetricFilter_BetweenFilter {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseAudienceDimensionOrMetricFilter_BetweenFilter();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.fromValue = AudienceDimensionOrMetricFilter_NumericValue.decode(reader, reader.uint32());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.toValue = AudienceDimensionOrMetricFilter_NumericValue.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): AudienceDimensionOrMetricFilter_BetweenFilter {
      return {
        fromValue: isSet(object.fromValue)
          ? AudienceDimensionOrMetricFilter_NumericValue.fromJSON(object.fromValue)
          : undefined,
        toValue: isSet(object.toValue)
          ? AudienceDimensionOrMetricFilter_NumericValue.fromJSON(object.toValue)
          : undefined,
      };
    },

    toJSON(message: AudienceDimensionOrMetricFilter_BetweenFilter): unknown {
      const obj: any = {};
      if (message.fromValue !== undefined) {
        obj.fromValue = AudienceDimensionOrMetricFilter_NumericValue.toJSON(message.fromValue);
      }
      if (message.toValue !== undefined) {
        obj.toValue = AudienceDimensionOrMetricFilter_NumericValue.toJSON(message.toValue);
      }
      return obj;
    },

    create(
      base?: DeepPartial<AudienceDimensionOrMetricFilter_BetweenFilter>,
    ): AudienceDimensionOrMetricFilter_BetweenFilter {
      return AudienceDimensionOrMetricFilter_BetweenFilter.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<AudienceDimensionOrMetricFilter_BetweenFilter>,
    ): AudienceDimensionOrMetricFilter_BetweenFilter {
      const message = createBaseAudienceDimensionOrMetricFilter_BetweenFilter();
      message.fromValue = (object.fromValue !== undefined && object.fromValue !== null)
        ? AudienceDimensionOrMetricFilter_NumericValue.fromPartial(object.fromValue)
        : undefined;
      message.toValue = (object.toValue !== undefined && object.toValue !== null)
        ? AudienceDimensionOrMetricFilter_NumericValue.fromPartial(object.toValue)
        : undefined;
      return message;
    },
  };

function createBaseAudienceEventFilter(): AudienceEventFilter {
  return { eventName: "", eventParameterFilterExpression: undefined };
}

export const AudienceEventFilter: MessageFns<AudienceEventFilter> = {
  encode(message: AudienceEventFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventName !== "") {
      writer.uint32(10).string(message.eventName);
    }
    if (message.eventParameterFilterExpression !== undefined) {
      AudienceFilterExpression.encode(message.eventParameterFilterExpression, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceEventFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceEventFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventParameterFilterExpression = AudienceFilterExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceEventFilter {
    return {
      eventName: isSet(object.eventName) ? globalThis.String(object.eventName) : "",
      eventParameterFilterExpression: isSet(object.eventParameterFilterExpression)
        ? AudienceFilterExpression.fromJSON(object.eventParameterFilterExpression)
        : undefined,
    };
  },

  toJSON(message: AudienceEventFilter): unknown {
    const obj: any = {};
    if (message.eventName !== "") {
      obj.eventName = message.eventName;
    }
    if (message.eventParameterFilterExpression !== undefined) {
      obj.eventParameterFilterExpression = AudienceFilterExpression.toJSON(message.eventParameterFilterExpression);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceEventFilter>): AudienceEventFilter {
    return AudienceEventFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceEventFilter>): AudienceEventFilter {
    const message = createBaseAudienceEventFilter();
    message.eventName = object.eventName ?? "";
    message.eventParameterFilterExpression =
      (object.eventParameterFilterExpression !== undefined && object.eventParameterFilterExpression !== null)
        ? AudienceFilterExpression.fromPartial(object.eventParameterFilterExpression)
        : undefined;
    return message;
  },
};

function createBaseAudienceFilterExpression(): AudienceFilterExpression {
  return {
    andGroup: undefined,
    orGroup: undefined,
    notExpression: undefined,
    dimensionOrMetricFilter: undefined,
    eventFilter: undefined,
  };
}

export const AudienceFilterExpression: MessageFns<AudienceFilterExpression> = {
  encode(message: AudienceFilterExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.andGroup !== undefined) {
      AudienceFilterExpressionList.encode(message.andGroup, writer.uint32(10).fork()).join();
    }
    if (message.orGroup !== undefined) {
      AudienceFilterExpressionList.encode(message.orGroup, writer.uint32(18).fork()).join();
    }
    if (message.notExpression !== undefined) {
      AudienceFilterExpression.encode(message.notExpression, writer.uint32(26).fork()).join();
    }
    if (message.dimensionOrMetricFilter !== undefined) {
      AudienceDimensionOrMetricFilter.encode(message.dimensionOrMetricFilter, writer.uint32(34).fork()).join();
    }
    if (message.eventFilter !== undefined) {
      AudienceEventFilter.encode(message.eventFilter, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceFilterExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceFilterExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.andGroup = AudienceFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orGroup = AudienceFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notExpression = AudienceFilterExpression.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dimensionOrMetricFilter = AudienceDimensionOrMetricFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.eventFilter = AudienceEventFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceFilterExpression {
    return {
      andGroup: isSet(object.andGroup) ? AudienceFilterExpressionList.fromJSON(object.andGroup) : undefined,
      orGroup: isSet(object.orGroup) ? AudienceFilterExpressionList.fromJSON(object.orGroup) : undefined,
      notExpression: isSet(object.notExpression) ? AudienceFilterExpression.fromJSON(object.notExpression) : undefined,
      dimensionOrMetricFilter: isSet(object.dimensionOrMetricFilter)
        ? AudienceDimensionOrMetricFilter.fromJSON(object.dimensionOrMetricFilter)
        : undefined,
      eventFilter: isSet(object.eventFilter) ? AudienceEventFilter.fromJSON(object.eventFilter) : undefined,
    };
  },

  toJSON(message: AudienceFilterExpression): unknown {
    const obj: any = {};
    if (message.andGroup !== undefined) {
      obj.andGroup = AudienceFilterExpressionList.toJSON(message.andGroup);
    }
    if (message.orGroup !== undefined) {
      obj.orGroup = AudienceFilterExpressionList.toJSON(message.orGroup);
    }
    if (message.notExpression !== undefined) {
      obj.notExpression = AudienceFilterExpression.toJSON(message.notExpression);
    }
    if (message.dimensionOrMetricFilter !== undefined) {
      obj.dimensionOrMetricFilter = AudienceDimensionOrMetricFilter.toJSON(message.dimensionOrMetricFilter);
    }
    if (message.eventFilter !== undefined) {
      obj.eventFilter = AudienceEventFilter.toJSON(message.eventFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceFilterExpression>): AudienceFilterExpression {
    return AudienceFilterExpression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceFilterExpression>): AudienceFilterExpression {
    const message = createBaseAudienceFilterExpression();
    message.andGroup = (object.andGroup !== undefined && object.andGroup !== null)
      ? AudienceFilterExpressionList.fromPartial(object.andGroup)
      : undefined;
    message.orGroup = (object.orGroup !== undefined && object.orGroup !== null)
      ? AudienceFilterExpressionList.fromPartial(object.orGroup)
      : undefined;
    message.notExpression = (object.notExpression !== undefined && object.notExpression !== null)
      ? AudienceFilterExpression.fromPartial(object.notExpression)
      : undefined;
    message.dimensionOrMetricFilter =
      (object.dimensionOrMetricFilter !== undefined && object.dimensionOrMetricFilter !== null)
        ? AudienceDimensionOrMetricFilter.fromPartial(object.dimensionOrMetricFilter)
        : undefined;
    message.eventFilter = (object.eventFilter !== undefined && object.eventFilter !== null)
      ? AudienceEventFilter.fromPartial(object.eventFilter)
      : undefined;
    return message;
  },
};

function createBaseAudienceFilterExpressionList(): AudienceFilterExpressionList {
  return { filterExpressions: [] };
}

export const AudienceFilterExpressionList: MessageFns<AudienceFilterExpressionList> = {
  encode(message: AudienceFilterExpressionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.filterExpressions) {
      AudienceFilterExpression.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceFilterExpressionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceFilterExpressionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filterExpressions.push(AudienceFilterExpression.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceFilterExpressionList {
    return {
      filterExpressions: globalThis.Array.isArray(object?.filterExpressions)
        ? object.filterExpressions.map((e: any) => AudienceFilterExpression.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudienceFilterExpressionList): unknown {
    const obj: any = {};
    if (message.filterExpressions?.length) {
      obj.filterExpressions = message.filterExpressions.map((e) => AudienceFilterExpression.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceFilterExpressionList>): AudienceFilterExpressionList {
    return AudienceFilterExpressionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceFilterExpressionList>): AudienceFilterExpressionList {
    const message = createBaseAudienceFilterExpressionList();
    message.filterExpressions = object.filterExpressions?.map((e) => AudienceFilterExpression.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAudienceSimpleFilter(): AudienceSimpleFilter {
  return { scope: 0, filterExpression: undefined };
}

export const AudienceSimpleFilter: MessageFns<AudienceSimpleFilter> = {
  encode(message: AudienceSimpleFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scope !== 0) {
      writer.uint32(8).int32(message.scope);
    }
    if (message.filterExpression !== undefined) {
      AudienceFilterExpression.encode(message.filterExpression, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceSimpleFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceSimpleFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filterExpression = AudienceFilterExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceSimpleFilter {
    return {
      scope: isSet(object.scope) ? audienceFilterScopeFromJSON(object.scope) : 0,
      filterExpression: isSet(object.filterExpression)
        ? AudienceFilterExpression.fromJSON(object.filterExpression)
        : undefined,
    };
  },

  toJSON(message: AudienceSimpleFilter): unknown {
    const obj: any = {};
    if (message.scope !== 0) {
      obj.scope = audienceFilterScopeToJSON(message.scope);
    }
    if (message.filterExpression !== undefined) {
      obj.filterExpression = AudienceFilterExpression.toJSON(message.filterExpression);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceSimpleFilter>): AudienceSimpleFilter {
    return AudienceSimpleFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceSimpleFilter>): AudienceSimpleFilter {
    const message = createBaseAudienceSimpleFilter();
    message.scope = object.scope ?? 0;
    message.filterExpression = (object.filterExpression !== undefined && object.filterExpression !== null)
      ? AudienceFilterExpression.fromPartial(object.filterExpression)
      : undefined;
    return message;
  },
};

function createBaseAudienceSequenceFilter(): AudienceSequenceFilter {
  return { scope: 0, sequenceMaximumDuration: undefined, sequenceSteps: [] };
}

export const AudienceSequenceFilter: MessageFns<AudienceSequenceFilter> = {
  encode(message: AudienceSequenceFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scope !== 0) {
      writer.uint32(8).int32(message.scope);
    }
    if (message.sequenceMaximumDuration !== undefined) {
      Duration.encode(message.sequenceMaximumDuration, writer.uint32(18).fork()).join();
    }
    for (const v of message.sequenceSteps) {
      AudienceSequenceFilter_AudienceSequenceStep.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceSequenceFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceSequenceFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sequenceMaximumDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sequenceSteps.push(AudienceSequenceFilter_AudienceSequenceStep.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceSequenceFilter {
    return {
      scope: isSet(object.scope) ? audienceFilterScopeFromJSON(object.scope) : 0,
      sequenceMaximumDuration: isSet(object.sequenceMaximumDuration)
        ? Duration.fromJSON(object.sequenceMaximumDuration)
        : undefined,
      sequenceSteps: globalThis.Array.isArray(object?.sequenceSteps)
        ? object.sequenceSteps.map((e: any) => AudienceSequenceFilter_AudienceSequenceStep.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudienceSequenceFilter): unknown {
    const obj: any = {};
    if (message.scope !== 0) {
      obj.scope = audienceFilterScopeToJSON(message.scope);
    }
    if (message.sequenceMaximumDuration !== undefined) {
      obj.sequenceMaximumDuration = Duration.toJSON(message.sequenceMaximumDuration);
    }
    if (message.sequenceSteps?.length) {
      obj.sequenceSteps = message.sequenceSteps.map((e) => AudienceSequenceFilter_AudienceSequenceStep.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceSequenceFilter>): AudienceSequenceFilter {
    return AudienceSequenceFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceSequenceFilter>): AudienceSequenceFilter {
    const message = createBaseAudienceSequenceFilter();
    message.scope = object.scope ?? 0;
    message.sequenceMaximumDuration =
      (object.sequenceMaximumDuration !== undefined && object.sequenceMaximumDuration !== null)
        ? Duration.fromPartial(object.sequenceMaximumDuration)
        : undefined;
    message.sequenceSteps =
      object.sequenceSteps?.map((e) => AudienceSequenceFilter_AudienceSequenceStep.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAudienceSequenceFilter_AudienceSequenceStep(): AudienceSequenceFilter_AudienceSequenceStep {
  return { scope: 0, immediatelyFollows: false, constraintDuration: undefined, filterExpression: undefined };
}

export const AudienceSequenceFilter_AudienceSequenceStep: MessageFns<AudienceSequenceFilter_AudienceSequenceStep> = {
  encode(
    message: AudienceSequenceFilter_AudienceSequenceStep,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.scope !== 0) {
      writer.uint32(8).int32(message.scope);
    }
    if (message.immediatelyFollows !== false) {
      writer.uint32(16).bool(message.immediatelyFollows);
    }
    if (message.constraintDuration !== undefined) {
      Duration.encode(message.constraintDuration, writer.uint32(26).fork()).join();
    }
    if (message.filterExpression !== undefined) {
      AudienceFilterExpression.encode(message.filterExpression, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceSequenceFilter_AudienceSequenceStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceSequenceFilter_AudienceSequenceStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.immediatelyFollows = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.constraintDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filterExpression = AudienceFilterExpression.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceSequenceFilter_AudienceSequenceStep {
    return {
      scope: isSet(object.scope) ? audienceFilterScopeFromJSON(object.scope) : 0,
      immediatelyFollows: isSet(object.immediatelyFollows) ? globalThis.Boolean(object.immediatelyFollows) : false,
      constraintDuration: isSet(object.constraintDuration) ? Duration.fromJSON(object.constraintDuration) : undefined,
      filterExpression: isSet(object.filterExpression)
        ? AudienceFilterExpression.fromJSON(object.filterExpression)
        : undefined,
    };
  },

  toJSON(message: AudienceSequenceFilter_AudienceSequenceStep): unknown {
    const obj: any = {};
    if (message.scope !== 0) {
      obj.scope = audienceFilterScopeToJSON(message.scope);
    }
    if (message.immediatelyFollows !== false) {
      obj.immediatelyFollows = message.immediatelyFollows;
    }
    if (message.constraintDuration !== undefined) {
      obj.constraintDuration = Duration.toJSON(message.constraintDuration);
    }
    if (message.filterExpression !== undefined) {
      obj.filterExpression = AudienceFilterExpression.toJSON(message.filterExpression);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceSequenceFilter_AudienceSequenceStep>): AudienceSequenceFilter_AudienceSequenceStep {
    return AudienceSequenceFilter_AudienceSequenceStep.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AudienceSequenceFilter_AudienceSequenceStep>,
  ): AudienceSequenceFilter_AudienceSequenceStep {
    const message = createBaseAudienceSequenceFilter_AudienceSequenceStep();
    message.scope = object.scope ?? 0;
    message.immediatelyFollows = object.immediatelyFollows ?? false;
    message.constraintDuration = (object.constraintDuration !== undefined && object.constraintDuration !== null)
      ? Duration.fromPartial(object.constraintDuration)
      : undefined;
    message.filterExpression = (object.filterExpression !== undefined && object.filterExpression !== null)
      ? AudienceFilterExpression.fromPartial(object.filterExpression)
      : undefined;
    return message;
  },
};

function createBaseAudienceFilterClause(): AudienceFilterClause {
  return { simpleFilter: undefined, sequenceFilter: undefined, clauseType: 0 };
}

export const AudienceFilterClause: MessageFns<AudienceFilterClause> = {
  encode(message: AudienceFilterClause, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.simpleFilter !== undefined) {
      AudienceSimpleFilter.encode(message.simpleFilter, writer.uint32(18).fork()).join();
    }
    if (message.sequenceFilter !== undefined) {
      AudienceSequenceFilter.encode(message.sequenceFilter, writer.uint32(26).fork()).join();
    }
    if (message.clauseType !== 0) {
      writer.uint32(8).int32(message.clauseType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceFilterClause {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceFilterClause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.simpleFilter = AudienceSimpleFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sequenceFilter = AudienceSequenceFilter.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.clauseType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceFilterClause {
    return {
      simpleFilter: isSet(object.simpleFilter) ? AudienceSimpleFilter.fromJSON(object.simpleFilter) : undefined,
      sequenceFilter: isSet(object.sequenceFilter) ? AudienceSequenceFilter.fromJSON(object.sequenceFilter) : undefined,
      clauseType: isSet(object.clauseType) ? audienceFilterClause_AudienceClauseTypeFromJSON(object.clauseType) : 0,
    };
  },

  toJSON(message: AudienceFilterClause): unknown {
    const obj: any = {};
    if (message.simpleFilter !== undefined) {
      obj.simpleFilter = AudienceSimpleFilter.toJSON(message.simpleFilter);
    }
    if (message.sequenceFilter !== undefined) {
      obj.sequenceFilter = AudienceSequenceFilter.toJSON(message.sequenceFilter);
    }
    if (message.clauseType !== 0) {
      obj.clauseType = audienceFilterClause_AudienceClauseTypeToJSON(message.clauseType);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceFilterClause>): AudienceFilterClause {
    return AudienceFilterClause.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceFilterClause>): AudienceFilterClause {
    const message = createBaseAudienceFilterClause();
    message.simpleFilter = (object.simpleFilter !== undefined && object.simpleFilter !== null)
      ? AudienceSimpleFilter.fromPartial(object.simpleFilter)
      : undefined;
    message.sequenceFilter = (object.sequenceFilter !== undefined && object.sequenceFilter !== null)
      ? AudienceSequenceFilter.fromPartial(object.sequenceFilter)
      : undefined;
    message.clauseType = object.clauseType ?? 0;
    return message;
  },
};

function createBaseAudienceEventTrigger(): AudienceEventTrigger {
  return { eventName: "", logCondition: 0 };
}

export const AudienceEventTrigger: MessageFns<AudienceEventTrigger> = {
  encode(message: AudienceEventTrigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventName !== "") {
      writer.uint32(10).string(message.eventName);
    }
    if (message.logCondition !== 0) {
      writer.uint32(16).int32(message.logCondition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceEventTrigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceEventTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.logCondition = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceEventTrigger {
    return {
      eventName: isSet(object.eventName) ? globalThis.String(object.eventName) : "",
      logCondition: isSet(object.logCondition) ? audienceEventTrigger_LogConditionFromJSON(object.logCondition) : 0,
    };
  },

  toJSON(message: AudienceEventTrigger): unknown {
    const obj: any = {};
    if (message.eventName !== "") {
      obj.eventName = message.eventName;
    }
    if (message.logCondition !== 0) {
      obj.logCondition = audienceEventTrigger_LogConditionToJSON(message.logCondition);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceEventTrigger>): AudienceEventTrigger {
    return AudienceEventTrigger.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceEventTrigger>): AudienceEventTrigger {
    const message = createBaseAudienceEventTrigger();
    message.eventName = object.eventName ?? "";
    message.logCondition = object.logCondition ?? 0;
    return message;
  },
};

function createBaseAudience(): Audience {
  return {
    name: "",
    displayName: "",
    description: "",
    membershipDurationDays: 0,
    adsPersonalizationEnabled: false,
    eventTrigger: undefined,
    exclusionDurationMode: 0,
    filterClauses: [],
    createTime: undefined,
  };
}

export const Audience: MessageFns<Audience> = {
  encode(message: Audience, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.membershipDurationDays !== 0) {
      writer.uint32(32).int32(message.membershipDurationDays);
    }
    if (message.adsPersonalizationEnabled !== false) {
      writer.uint32(40).bool(message.adsPersonalizationEnabled);
    }
    if (message.eventTrigger !== undefined) {
      AudienceEventTrigger.encode(message.eventTrigger, writer.uint32(50).fork()).join();
    }
    if (message.exclusionDurationMode !== 0) {
      writer.uint32(56).int32(message.exclusionDurationMode);
    }
    for (const v of message.filterClauses) {
      AudienceFilterClause.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Audience {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudience();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.membershipDurationDays = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.adsPersonalizationEnabled = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.eventTrigger = AudienceEventTrigger.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.exclusionDurationMode = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.filterClauses.push(AudienceFilterClause.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Audience {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      membershipDurationDays: isSet(object.membershipDurationDays)
        ? globalThis.Number(object.membershipDurationDays)
        : 0,
      adsPersonalizationEnabled: isSet(object.adsPersonalizationEnabled)
        ? globalThis.Boolean(object.adsPersonalizationEnabled)
        : false,
      eventTrigger: isSet(object.eventTrigger) ? AudienceEventTrigger.fromJSON(object.eventTrigger) : undefined,
      exclusionDurationMode: isSet(object.exclusionDurationMode)
        ? audience_AudienceExclusionDurationModeFromJSON(object.exclusionDurationMode)
        : 0,
      filterClauses: globalThis.Array.isArray(object?.filterClauses)
        ? object.filterClauses.map((e: any) => AudienceFilterClause.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: Audience): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.membershipDurationDays !== 0) {
      obj.membershipDurationDays = Math.round(message.membershipDurationDays);
    }
    if (message.adsPersonalizationEnabled !== false) {
      obj.adsPersonalizationEnabled = message.adsPersonalizationEnabled;
    }
    if (message.eventTrigger !== undefined) {
      obj.eventTrigger = AudienceEventTrigger.toJSON(message.eventTrigger);
    }
    if (message.exclusionDurationMode !== 0) {
      obj.exclusionDurationMode = audience_AudienceExclusionDurationModeToJSON(message.exclusionDurationMode);
    }
    if (message.filterClauses?.length) {
      obj.filterClauses = message.filterClauses.map((e) => AudienceFilterClause.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Audience>): Audience {
    return Audience.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Audience>): Audience {
    const message = createBaseAudience();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.membershipDurationDays = object.membershipDurationDays ?? 0;
    message.adsPersonalizationEnabled = object.adsPersonalizationEnabled ?? false;
    message.eventTrigger = (object.eventTrigger !== undefined && object.eventTrigger !== null)
      ? AudienceEventTrigger.fromPartial(object.eventTrigger)
      : undefined;
    message.exclusionDurationMode = object.exclusionDurationMode ?? 0;
    message.filterClauses = object.filterClauses?.map((e) => AudienceFilterClause.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
