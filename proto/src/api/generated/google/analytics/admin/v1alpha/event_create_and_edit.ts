// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/analytics/admin/v1alpha/event_create_and_edit.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.analytics.admin.v1alpha";

/** Defines an event parameter to mutate. */
export interface ParameterMutation {
  /**
   * Required. The name of the parameter to mutate.
   * This value must:
   * * be less than 40 characters.
   * * be unique across across all mutations within the rule
   * * consist only of letters, digits or _ (underscores)
   * For event edit rules, the name may also be set to 'event_name' to modify
   * the event_name in place.
   */
  parameter: string;
  /**
   * Required. The value mutation to perform.
   * * Must be less than 100 characters.
   * * To specify a constant value for the param, use the value's string.
   * * To copy value from another parameter, use syntax like
   * "[[other_parameter]]" For more details, see this [help center
   * article](https://support.google.com/analytics/answer/10085872#modify-an-event&zippy=%2Cin-this-article%2Cmodify-parameters).
   */
  parameterValue: string;
}

/**
 * An Event Create Rule defines conditions that will trigger the creation
 * of an entirely new event based upon matched criteria of a source event.
 * Additional mutations of the parameters from the source event can be defined.
 *
 * Unlike Event Edit rules, Event Creation Rules have no defined order.  They
 * will all be run independently.
 *
 * Event Edit and Event Create rules can't be used to modify an event created
 * from an Event Create rule.
 */
export interface EventCreateRule {
  /**
   * Output only. Resource name for this EventCreateRule resource.
   * Format:
   * properties/{property}/dataStreams/{data_stream}/eventCreateRules/{event_create_rule}
   */
  name: string;
  /**
   * Required. The name of the new event to be created.
   *
   * This value must:
   * * be less than 40 characters
   * * consist only of letters, digits or _ (underscores)
   * * start with a letter
   */
  destinationEvent: string;
  /**
   * Required. Must have at least one condition, and can have up to 10 max.
   * Conditions on the source event must match for this rule to be applied.
   */
  eventConditions: MatchingCondition[];
  /**
   * If true, the source parameters are copied to the new event.
   * If false, or unset, all non-internal parameters are not copied from the
   * source event. Parameter mutations are applied after the parameters have
   * been copied.
   */
  sourceCopyParameters: boolean;
  /**
   * Parameter mutations define parameter behavior on the new event, and
   * are applied in order.
   * A maximum of 20 mutations can be applied.
   */
  parameterMutations: ParameterMutation[];
}

/**
 * An Event Edit Rule defines conditions that will trigger the creation of an
 * entirely new event based upon matched criteria of a source event. Additional
 * mutations of the parameters from the source event can be defined.
 *
 * Unlike Event Create rules, Event Edit Rules are applied in their defined
 * order.
 *
 * Event Edit rules can't be used to modify an event created from an Event
 * Create rule.
 */
export interface EventEditRule {
  /**
   * Identifier. Resource name for this EventEditRule resource.
   * Format:
   * properties/{property}/dataStreams/{data_stream}/eventEditRules/{event_edit_rule}
   */
  name: string;
  /**
   * Required. The display name of this event edit rule. Maximum of 255
   * characters.
   */
  displayName: string;
  /**
   * Required. Conditions on the source event must match for this rule to be
   * applied. Must have at least one condition, and can have up to 10 max.
   */
  eventConditions: MatchingCondition[];
  /**
   * Required. Parameter mutations define parameter behavior on the new event,
   * and are applied in order. A maximum of 20 mutations can be applied.
   */
  parameterMutations: ParameterMutation[];
  /**
   * Output only. The order for which this rule will be processed. Rules with an
   * order value lower than this will be processed before this rule, rules with
   * an order value higher than this will be processed after this rule. New
   * event edit rules will be assigned an order value at the end of the order.
   *
   * This value does not apply to event create rules.
   */
  processingOrder: Long;
}

/**
 * Defines a condition for when an Event Edit or Event Creation rule applies to
 * an event.
 */
export interface MatchingCondition {
  /**
   * Required. The name of the field that is compared against for the condition.
   * If 'event_name' is specified this condition will apply to the name of the
   * event.  Otherwise the condition will apply to a parameter with the
   * specified name.
   *
   * This value cannot contain spaces.
   */
  field: string;
  /** Required. The type of comparison to be applied to the value. */
  comparisonType: MatchingCondition_ComparisonType;
  /**
   * Required. The value being compared against for this condition.  The runtime
   * implementation may perform type coercion of this value to evaluate this
   * condition based on the type of the parameter value.
   */
  value: string;
  /**
   * Whether or not the result of the comparison should be negated. For example,
   * if `negated` is true, then 'equals' comparisons would function as 'not
   * equals'.
   */
  negated: boolean;
}

/** Comparison type for matching condition */
export enum MatchingCondition_ComparisonType {
  /** COMPARISON_TYPE_UNSPECIFIED - Unknown */
  COMPARISON_TYPE_UNSPECIFIED = 0,
  /** EQUALS - Equals, case sensitive */
  EQUALS = 1,
  /** EQUALS_CASE_INSENSITIVE - Equals, case insensitive */
  EQUALS_CASE_INSENSITIVE = 2,
  /** CONTAINS - Contains, case sensitive */
  CONTAINS = 3,
  /** CONTAINS_CASE_INSENSITIVE - Contains, case insensitive */
  CONTAINS_CASE_INSENSITIVE = 4,
  /** STARTS_WITH - Starts with, case sensitive */
  STARTS_WITH = 5,
  /** STARTS_WITH_CASE_INSENSITIVE - Starts with, case insensitive */
  STARTS_WITH_CASE_INSENSITIVE = 6,
  /** ENDS_WITH - Ends with, case sensitive */
  ENDS_WITH = 7,
  /** ENDS_WITH_CASE_INSENSITIVE - Ends with, case insensitive */
  ENDS_WITH_CASE_INSENSITIVE = 8,
  /** GREATER_THAN - Greater than */
  GREATER_THAN = 9,
  /** GREATER_THAN_OR_EQUAL - Greater than or equal */
  GREATER_THAN_OR_EQUAL = 10,
  /** LESS_THAN - Less than */
  LESS_THAN = 11,
  /** LESS_THAN_OR_EQUAL - Less than or equal */
  LESS_THAN_OR_EQUAL = 12,
  /** REGULAR_EXPRESSION - regular expression. Only supported for web streams. */
  REGULAR_EXPRESSION = 13,
  /** REGULAR_EXPRESSION_CASE_INSENSITIVE - regular expression, case insensitive. Only supported for web streams. */
  REGULAR_EXPRESSION_CASE_INSENSITIVE = 14,
  UNRECOGNIZED = -1,
}

export function matchingCondition_ComparisonTypeFromJSON(object: any): MatchingCondition_ComparisonType {
  switch (object) {
    case 0:
    case "COMPARISON_TYPE_UNSPECIFIED":
      return MatchingCondition_ComparisonType.COMPARISON_TYPE_UNSPECIFIED;
    case 1:
    case "EQUALS":
      return MatchingCondition_ComparisonType.EQUALS;
    case 2:
    case "EQUALS_CASE_INSENSITIVE":
      return MatchingCondition_ComparisonType.EQUALS_CASE_INSENSITIVE;
    case 3:
    case "CONTAINS":
      return MatchingCondition_ComparisonType.CONTAINS;
    case 4:
    case "CONTAINS_CASE_INSENSITIVE":
      return MatchingCondition_ComparisonType.CONTAINS_CASE_INSENSITIVE;
    case 5:
    case "STARTS_WITH":
      return MatchingCondition_ComparisonType.STARTS_WITH;
    case 6:
    case "STARTS_WITH_CASE_INSENSITIVE":
      return MatchingCondition_ComparisonType.STARTS_WITH_CASE_INSENSITIVE;
    case 7:
    case "ENDS_WITH":
      return MatchingCondition_ComparisonType.ENDS_WITH;
    case 8:
    case "ENDS_WITH_CASE_INSENSITIVE":
      return MatchingCondition_ComparisonType.ENDS_WITH_CASE_INSENSITIVE;
    case 9:
    case "GREATER_THAN":
      return MatchingCondition_ComparisonType.GREATER_THAN;
    case 10:
    case "GREATER_THAN_OR_EQUAL":
      return MatchingCondition_ComparisonType.GREATER_THAN_OR_EQUAL;
    case 11:
    case "LESS_THAN":
      return MatchingCondition_ComparisonType.LESS_THAN;
    case 12:
    case "LESS_THAN_OR_EQUAL":
      return MatchingCondition_ComparisonType.LESS_THAN_OR_EQUAL;
    case 13:
    case "REGULAR_EXPRESSION":
      return MatchingCondition_ComparisonType.REGULAR_EXPRESSION;
    case 14:
    case "REGULAR_EXPRESSION_CASE_INSENSITIVE":
      return MatchingCondition_ComparisonType.REGULAR_EXPRESSION_CASE_INSENSITIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MatchingCondition_ComparisonType.UNRECOGNIZED;
  }
}

export function matchingCondition_ComparisonTypeToJSON(object: MatchingCondition_ComparisonType): string {
  switch (object) {
    case MatchingCondition_ComparisonType.COMPARISON_TYPE_UNSPECIFIED:
      return "COMPARISON_TYPE_UNSPECIFIED";
    case MatchingCondition_ComparisonType.EQUALS:
      return "EQUALS";
    case MatchingCondition_ComparisonType.EQUALS_CASE_INSENSITIVE:
      return "EQUALS_CASE_INSENSITIVE";
    case MatchingCondition_ComparisonType.CONTAINS:
      return "CONTAINS";
    case MatchingCondition_ComparisonType.CONTAINS_CASE_INSENSITIVE:
      return "CONTAINS_CASE_INSENSITIVE";
    case MatchingCondition_ComparisonType.STARTS_WITH:
      return "STARTS_WITH";
    case MatchingCondition_ComparisonType.STARTS_WITH_CASE_INSENSITIVE:
      return "STARTS_WITH_CASE_INSENSITIVE";
    case MatchingCondition_ComparisonType.ENDS_WITH:
      return "ENDS_WITH";
    case MatchingCondition_ComparisonType.ENDS_WITH_CASE_INSENSITIVE:
      return "ENDS_WITH_CASE_INSENSITIVE";
    case MatchingCondition_ComparisonType.GREATER_THAN:
      return "GREATER_THAN";
    case MatchingCondition_ComparisonType.GREATER_THAN_OR_EQUAL:
      return "GREATER_THAN_OR_EQUAL";
    case MatchingCondition_ComparisonType.LESS_THAN:
      return "LESS_THAN";
    case MatchingCondition_ComparisonType.LESS_THAN_OR_EQUAL:
      return "LESS_THAN_OR_EQUAL";
    case MatchingCondition_ComparisonType.REGULAR_EXPRESSION:
      return "REGULAR_EXPRESSION";
    case MatchingCondition_ComparisonType.REGULAR_EXPRESSION_CASE_INSENSITIVE:
      return "REGULAR_EXPRESSION_CASE_INSENSITIVE";
    case MatchingCondition_ComparisonType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseParameterMutation(): ParameterMutation {
  return { parameter: "", parameterValue: "" };
}

export const ParameterMutation: MessageFns<ParameterMutation> = {
  encode(message: ParameterMutation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameter !== "") {
      writer.uint32(10).string(message.parameter);
    }
    if (message.parameterValue !== "") {
      writer.uint32(18).string(message.parameterValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterMutation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterMutation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parameter = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parameterValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterMutation {
    return {
      parameter: isSet(object.parameter) ? globalThis.String(object.parameter) : "",
      parameterValue: isSet(object.parameterValue) ? globalThis.String(object.parameterValue) : "",
    };
  },

  toJSON(message: ParameterMutation): unknown {
    const obj: any = {};
    if (message.parameter !== "") {
      obj.parameter = message.parameter;
    }
    if (message.parameterValue !== "") {
      obj.parameterValue = message.parameterValue;
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterMutation>): ParameterMutation {
    return ParameterMutation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterMutation>): ParameterMutation {
    const message = createBaseParameterMutation();
    message.parameter = object.parameter ?? "";
    message.parameterValue = object.parameterValue ?? "";
    return message;
  },
};

function createBaseEventCreateRule(): EventCreateRule {
  return { name: "", destinationEvent: "", eventConditions: [], sourceCopyParameters: false, parameterMutations: [] };
}

export const EventCreateRule: MessageFns<EventCreateRule> = {
  encode(message: EventCreateRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.destinationEvent !== "") {
      writer.uint32(18).string(message.destinationEvent);
    }
    for (const v of message.eventConditions) {
      MatchingCondition.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.sourceCopyParameters !== false) {
      writer.uint32(32).bool(message.sourceCopyParameters);
    }
    for (const v of message.parameterMutations) {
      ParameterMutation.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventCreateRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCreateRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destinationEvent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventConditions.push(MatchingCondition.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sourceCopyParameters = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parameterMutations.push(ParameterMutation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventCreateRule {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      destinationEvent: isSet(object.destinationEvent) ? globalThis.String(object.destinationEvent) : "",
      eventConditions: globalThis.Array.isArray(object?.eventConditions)
        ? object.eventConditions.map((e: any) => MatchingCondition.fromJSON(e))
        : [],
      sourceCopyParameters: isSet(object.sourceCopyParameters)
        ? globalThis.Boolean(object.sourceCopyParameters)
        : false,
      parameterMutations: globalThis.Array.isArray(object?.parameterMutations)
        ? object.parameterMutations.map((e: any) => ParameterMutation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EventCreateRule): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.destinationEvent !== "") {
      obj.destinationEvent = message.destinationEvent;
    }
    if (message.eventConditions?.length) {
      obj.eventConditions = message.eventConditions.map((e) => MatchingCondition.toJSON(e));
    }
    if (message.sourceCopyParameters !== false) {
      obj.sourceCopyParameters = message.sourceCopyParameters;
    }
    if (message.parameterMutations?.length) {
      obj.parameterMutations = message.parameterMutations.map((e) => ParameterMutation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EventCreateRule>): EventCreateRule {
    return EventCreateRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventCreateRule>): EventCreateRule {
    const message = createBaseEventCreateRule();
    message.name = object.name ?? "";
    message.destinationEvent = object.destinationEvent ?? "";
    message.eventConditions = object.eventConditions?.map((e) => MatchingCondition.fromPartial(e)) || [];
    message.sourceCopyParameters = object.sourceCopyParameters ?? false;
    message.parameterMutations = object.parameterMutations?.map((e) => ParameterMutation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEventEditRule(): EventEditRule {
  return { name: "", displayName: "", eventConditions: [], parameterMutations: [], processingOrder: Long.ZERO };
}

export const EventEditRule: MessageFns<EventEditRule> = {
  encode(message: EventEditRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.eventConditions) {
      MatchingCondition.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.parameterMutations) {
      ParameterMutation.encode(v!, writer.uint32(34).fork()).join();
    }
    if (!message.processingOrder.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.processingOrder.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEditRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEditRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventConditions.push(MatchingCondition.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.parameterMutations.push(ParameterMutation.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.processingOrder = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEditRule {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      eventConditions: globalThis.Array.isArray(object?.eventConditions)
        ? object.eventConditions.map((e: any) => MatchingCondition.fromJSON(e))
        : [],
      parameterMutations: globalThis.Array.isArray(object?.parameterMutations)
        ? object.parameterMutations.map((e: any) => ParameterMutation.fromJSON(e))
        : [],
      processingOrder: isSet(object.processingOrder) ? Long.fromValue(object.processingOrder) : Long.ZERO,
    };
  },

  toJSON(message: EventEditRule): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.eventConditions?.length) {
      obj.eventConditions = message.eventConditions.map((e) => MatchingCondition.toJSON(e));
    }
    if (message.parameterMutations?.length) {
      obj.parameterMutations = message.parameterMutations.map((e) => ParameterMutation.toJSON(e));
    }
    if (!message.processingOrder.equals(Long.ZERO)) {
      obj.processingOrder = (message.processingOrder || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EventEditRule>): EventEditRule {
    return EventEditRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventEditRule>): EventEditRule {
    const message = createBaseEventEditRule();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.eventConditions = object.eventConditions?.map((e) => MatchingCondition.fromPartial(e)) || [];
    message.parameterMutations = object.parameterMutations?.map((e) => ParameterMutation.fromPartial(e)) || [];
    message.processingOrder = (object.processingOrder !== undefined && object.processingOrder !== null)
      ? Long.fromValue(object.processingOrder)
      : Long.ZERO;
    return message;
  },
};

function createBaseMatchingCondition(): MatchingCondition {
  return { field: "", comparisonType: 0, value: "", negated: false };
}

export const MatchingCondition: MessageFns<MatchingCondition> = {
  encode(message: MatchingCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.comparisonType !== 0) {
      writer.uint32(16).int32(message.comparisonType);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    if (message.negated !== false) {
      writer.uint32(32).bool(message.negated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchingCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchingCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.comparisonType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.negated = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MatchingCondition {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      comparisonType: isSet(object.comparisonType)
        ? matchingCondition_ComparisonTypeFromJSON(object.comparisonType)
        : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      negated: isSet(object.negated) ? globalThis.Boolean(object.negated) : false,
    };
  },

  toJSON(message: MatchingCondition): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.comparisonType !== 0) {
      obj.comparisonType = matchingCondition_ComparisonTypeToJSON(message.comparisonType);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.negated !== false) {
      obj.negated = message.negated;
    }
    return obj;
  },

  create(base?: DeepPartial<MatchingCondition>): MatchingCondition {
    return MatchingCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MatchingCondition>): MatchingCondition {
    const message = createBaseMatchingCondition();
    message.field = object.field ?? "";
    message.comparisonType = object.comparisonType ?? 0;
    message.value = object.value ?? "";
    message.negated = object.negated ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
