// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/analytics/admin/v1beta/access_report.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.analytics.admin.v1beta";

/**
 * Dimensions are attributes of your data. For example, the dimension
 * `userEmail` indicates the email of the user that accessed reporting data.
 * Dimension values in report responses are strings.
 */
export interface AccessDimension {
  /**
   * The API name of the dimension. See [Data Access
   * Schema](https://developers.google.com/analytics/devguides/config/admin/v1/access-api-schema)
   * for the list of dimensions supported in this API.
   *
   * Dimensions are referenced by name in `dimensionFilter` and `orderBys`.
   */
  dimensionName: string;
}

/**
 * The quantitative measurements of a report. For example, the metric
 * `accessCount` is the total number of data access records.
 */
export interface AccessMetric {
  /**
   * The API name of the metric. See [Data Access
   * Schema](https://developers.google.com/analytics/devguides/config/admin/v1/access-api-schema)
   * for the list of metrics supported in this API.
   *
   * Metrics are referenced by name in `metricFilter` & `orderBys`.
   */
  metricName: string;
}

/** A contiguous range of days: startDate, startDate + 1, ..., endDate. */
export interface AccessDateRange {
  /**
   * The inclusive start date for the query in the format `YYYY-MM-DD`. Cannot
   * be after `endDate`. The format `NdaysAgo`, `yesterday`, or `today` is also
   * accepted, and in that case, the date is inferred based on the current time
   * in the request's time zone.
   */
  startDate: string;
  /**
   * The inclusive end date for the query in the format `YYYY-MM-DD`. Cannot
   * be before `startDate`. The format `NdaysAgo`, `yesterday`, or `today` is
   * also accepted, and in that case, the date is inferred based on the current
   * time in the request's time zone.
   */
  endDate: string;
}

/**
 * Expresses dimension or metric filters. The fields in the same expression need
 * to be either all dimensions or all metrics.
 */
export interface AccessFilterExpression {
  /** Each of the FilterExpressions in the and_group has an AND relationship. */
  andGroup?:
    | AccessFilterExpressionList
    | undefined;
  /** Each of the FilterExpressions in the or_group has an OR relationship. */
  orGroup?:
    | AccessFilterExpressionList
    | undefined;
  /** The FilterExpression is NOT of not_expression. */
  notExpression?:
    | AccessFilterExpression
    | undefined;
  /**
   * A primitive filter. In the same FilterExpression, all of the filter's
   * field names need to be either all dimensions or all metrics.
   */
  accessFilter?: AccessFilter | undefined;
}

/** A list of filter expressions. */
export interface AccessFilterExpressionList {
  /** A list of filter expressions. */
  expressions: AccessFilterExpression[];
}

/** An expression to filter dimension or metric values. */
export interface AccessFilter {
  /** Strings related filter. */
  stringFilter?:
    | AccessStringFilter
    | undefined;
  /** A filter for in list values. */
  inListFilter?:
    | AccessInListFilter
    | undefined;
  /** A filter for numeric or date values. */
  numericFilter?:
    | AccessNumericFilter
    | undefined;
  /** A filter for two values. */
  betweenFilter?:
    | AccessBetweenFilter
    | undefined;
  /** The dimension name or metric name. */
  fieldName: string;
}

/** The filter for strings. */
export interface AccessStringFilter {
  /** The match type for this filter. */
  matchType: AccessStringFilter_MatchType;
  /** The string value used for the matching. */
  value: string;
  /** If true, the string value is case sensitive. */
  caseSensitive: boolean;
}

/** The match type of a string filter. */
export enum AccessStringFilter_MatchType {
  /** MATCH_TYPE_UNSPECIFIED - Unspecified */
  MATCH_TYPE_UNSPECIFIED = 0,
  /** EXACT - Exact match of the string value. */
  EXACT = 1,
  /** BEGINS_WITH - Begins with the string value. */
  BEGINS_WITH = 2,
  /** ENDS_WITH - Ends with the string value. */
  ENDS_WITH = 3,
  /** CONTAINS - Contains the string value. */
  CONTAINS = 4,
  /** FULL_REGEXP - Full match for the regular expression with the string value. */
  FULL_REGEXP = 5,
  /** PARTIAL_REGEXP - Partial match for the regular expression with the string value. */
  PARTIAL_REGEXP = 6,
  UNRECOGNIZED = -1,
}

export function accessStringFilter_MatchTypeFromJSON(object: any): AccessStringFilter_MatchType {
  switch (object) {
    case 0:
    case "MATCH_TYPE_UNSPECIFIED":
      return AccessStringFilter_MatchType.MATCH_TYPE_UNSPECIFIED;
    case 1:
    case "EXACT":
      return AccessStringFilter_MatchType.EXACT;
    case 2:
    case "BEGINS_WITH":
      return AccessStringFilter_MatchType.BEGINS_WITH;
    case 3:
    case "ENDS_WITH":
      return AccessStringFilter_MatchType.ENDS_WITH;
    case 4:
    case "CONTAINS":
      return AccessStringFilter_MatchType.CONTAINS;
    case 5:
    case "FULL_REGEXP":
      return AccessStringFilter_MatchType.FULL_REGEXP;
    case 6:
    case "PARTIAL_REGEXP":
      return AccessStringFilter_MatchType.PARTIAL_REGEXP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessStringFilter_MatchType.UNRECOGNIZED;
  }
}

export function accessStringFilter_MatchTypeToJSON(object: AccessStringFilter_MatchType): string {
  switch (object) {
    case AccessStringFilter_MatchType.MATCH_TYPE_UNSPECIFIED:
      return "MATCH_TYPE_UNSPECIFIED";
    case AccessStringFilter_MatchType.EXACT:
      return "EXACT";
    case AccessStringFilter_MatchType.BEGINS_WITH:
      return "BEGINS_WITH";
    case AccessStringFilter_MatchType.ENDS_WITH:
      return "ENDS_WITH";
    case AccessStringFilter_MatchType.CONTAINS:
      return "CONTAINS";
    case AccessStringFilter_MatchType.FULL_REGEXP:
      return "FULL_REGEXP";
    case AccessStringFilter_MatchType.PARTIAL_REGEXP:
      return "PARTIAL_REGEXP";
    case AccessStringFilter_MatchType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The result needs to be in a list of string values. */
export interface AccessInListFilter {
  /** The list of string values. Must be non-empty. */
  values: string[];
  /** If true, the string value is case sensitive. */
  caseSensitive: boolean;
}

/** Filters for numeric or date values. */
export interface AccessNumericFilter {
  /** The operation type for this filter. */
  operation: AccessNumericFilter_Operation;
  /** A numeric value or a date value. */
  value: NumericValue | undefined;
}

/** The operation applied to a numeric filter. */
export enum AccessNumericFilter_Operation {
  /** OPERATION_UNSPECIFIED - Unspecified. */
  OPERATION_UNSPECIFIED = 0,
  /** EQUAL - Equal */
  EQUAL = 1,
  /** LESS_THAN - Less than */
  LESS_THAN = 2,
  /** LESS_THAN_OR_EQUAL - Less than or equal */
  LESS_THAN_OR_EQUAL = 3,
  /** GREATER_THAN - Greater than */
  GREATER_THAN = 4,
  /** GREATER_THAN_OR_EQUAL - Greater than or equal */
  GREATER_THAN_OR_EQUAL = 5,
  UNRECOGNIZED = -1,
}

export function accessNumericFilter_OperationFromJSON(object: any): AccessNumericFilter_Operation {
  switch (object) {
    case 0:
    case "OPERATION_UNSPECIFIED":
      return AccessNumericFilter_Operation.OPERATION_UNSPECIFIED;
    case 1:
    case "EQUAL":
      return AccessNumericFilter_Operation.EQUAL;
    case 2:
    case "LESS_THAN":
      return AccessNumericFilter_Operation.LESS_THAN;
    case 3:
    case "LESS_THAN_OR_EQUAL":
      return AccessNumericFilter_Operation.LESS_THAN_OR_EQUAL;
    case 4:
    case "GREATER_THAN":
      return AccessNumericFilter_Operation.GREATER_THAN;
    case 5:
    case "GREATER_THAN_OR_EQUAL":
      return AccessNumericFilter_Operation.GREATER_THAN_OR_EQUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessNumericFilter_Operation.UNRECOGNIZED;
  }
}

export function accessNumericFilter_OperationToJSON(object: AccessNumericFilter_Operation): string {
  switch (object) {
    case AccessNumericFilter_Operation.OPERATION_UNSPECIFIED:
      return "OPERATION_UNSPECIFIED";
    case AccessNumericFilter_Operation.EQUAL:
      return "EQUAL";
    case AccessNumericFilter_Operation.LESS_THAN:
      return "LESS_THAN";
    case AccessNumericFilter_Operation.LESS_THAN_OR_EQUAL:
      return "LESS_THAN_OR_EQUAL";
    case AccessNumericFilter_Operation.GREATER_THAN:
      return "GREATER_THAN";
    case AccessNumericFilter_Operation.GREATER_THAN_OR_EQUAL:
      return "GREATER_THAN_OR_EQUAL";
    case AccessNumericFilter_Operation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** To express that the result needs to be between two numbers (inclusive). */
export interface AccessBetweenFilter {
  /** Begins with this number. */
  fromValue:
    | NumericValue
    | undefined;
  /** Ends with this number. */
  toValue: NumericValue | undefined;
}

/** To represent a number. */
export interface NumericValue {
  /** Integer value */
  int64Value?:
    | Long
    | undefined;
  /** Double value */
  doubleValue?: number | undefined;
}

/**
 * Order bys define how rows will be sorted in the response. For example,
 * ordering rows by descending access count is one ordering, and ordering rows
 * by the country string is a different ordering.
 */
export interface AccessOrderBy {
  /** Sorts results by a metric's values. */
  metric?:
    | AccessOrderBy_MetricOrderBy
    | undefined;
  /** Sorts results by a dimension's values. */
  dimension?:
    | AccessOrderBy_DimensionOrderBy
    | undefined;
  /**
   * If true, sorts by descending order. If false or unspecified, sorts in
   * ascending order.
   */
  desc: boolean;
}

/** Sorts by metric values. */
export interface AccessOrderBy_MetricOrderBy {
  /** A metric name in the request to order by. */
  metricName: string;
}

/** Sorts by dimension values. */
export interface AccessOrderBy_DimensionOrderBy {
  /** A dimension name in the request to order by. */
  dimensionName: string;
  /** Controls the rule for dimension value ordering. */
  orderType: AccessOrderBy_DimensionOrderBy_OrderType;
}

/** Rule to order the string dimension values by. */
export enum AccessOrderBy_DimensionOrderBy_OrderType {
  /** ORDER_TYPE_UNSPECIFIED - Unspecified. */
  ORDER_TYPE_UNSPECIFIED = 0,
  /**
   * ALPHANUMERIC - Alphanumeric sort by Unicode code point. For example, "2" < "A" < "X" <
   * "b" < "z".
   */
  ALPHANUMERIC = 1,
  /**
   * CASE_INSENSITIVE_ALPHANUMERIC - Case insensitive alphanumeric sort by lower case Unicode code point.
   * For example, "2" < "A" < "b" < "X" < "z".
   */
  CASE_INSENSITIVE_ALPHANUMERIC = 2,
  /**
   * NUMERIC - Dimension values are converted to numbers before sorting. For example
   * in NUMERIC sort, "25" < "100", and in `ALPHANUMERIC` sort, "100" <
   * "25". Non-numeric dimension values all have equal ordering value below
   * all numeric values.
   */
  NUMERIC = 3,
  UNRECOGNIZED = -1,
}

export function accessOrderBy_DimensionOrderBy_OrderTypeFromJSON(
  object: any,
): AccessOrderBy_DimensionOrderBy_OrderType {
  switch (object) {
    case 0:
    case "ORDER_TYPE_UNSPECIFIED":
      return AccessOrderBy_DimensionOrderBy_OrderType.ORDER_TYPE_UNSPECIFIED;
    case 1:
    case "ALPHANUMERIC":
      return AccessOrderBy_DimensionOrderBy_OrderType.ALPHANUMERIC;
    case 2:
    case "CASE_INSENSITIVE_ALPHANUMERIC":
      return AccessOrderBy_DimensionOrderBy_OrderType.CASE_INSENSITIVE_ALPHANUMERIC;
    case 3:
    case "NUMERIC":
      return AccessOrderBy_DimensionOrderBy_OrderType.NUMERIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessOrderBy_DimensionOrderBy_OrderType.UNRECOGNIZED;
  }
}

export function accessOrderBy_DimensionOrderBy_OrderTypeToJSON(
  object: AccessOrderBy_DimensionOrderBy_OrderType,
): string {
  switch (object) {
    case AccessOrderBy_DimensionOrderBy_OrderType.ORDER_TYPE_UNSPECIFIED:
      return "ORDER_TYPE_UNSPECIFIED";
    case AccessOrderBy_DimensionOrderBy_OrderType.ALPHANUMERIC:
      return "ALPHANUMERIC";
    case AccessOrderBy_DimensionOrderBy_OrderType.CASE_INSENSITIVE_ALPHANUMERIC:
      return "CASE_INSENSITIVE_ALPHANUMERIC";
    case AccessOrderBy_DimensionOrderBy_OrderType.NUMERIC:
      return "NUMERIC";
    case AccessOrderBy_DimensionOrderBy_OrderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Describes a dimension column in the report. Dimensions requested in a report
 * produce column entries within rows and DimensionHeaders. However, dimensions
 * used exclusively within filters or expressions do not produce columns in a
 * report; correspondingly, those dimensions do not produce headers.
 */
export interface AccessDimensionHeader {
  /** The dimension's name; for example 'userEmail'. */
  dimensionName: string;
}

/**
 * Describes a metric column in the report. Visible metrics requested in a
 * report produce column entries within rows and MetricHeaders. However,
 * metrics used exclusively within filters or expressions do not produce columns
 * in a report; correspondingly, those metrics do not produce headers.
 */
export interface AccessMetricHeader {
  /** The metric's name; for example 'accessCount'. */
  metricName: string;
}

/** Access report data for each row. */
export interface AccessRow {
  /**
   * List of dimension values. These values are in the same order as specified
   * in the request.
   */
  dimensionValues: AccessDimensionValue[];
  /**
   * List of metric values. These values are in the same order as specified
   * in the request.
   */
  metricValues: AccessMetricValue[];
}

/** The value of a dimension. */
export interface AccessDimensionValue {
  /**
   * The dimension value. For example, this value may be 'France' for the
   * 'country' dimension.
   */
  value: string;
}

/** The value of a metric. */
export interface AccessMetricValue {
  /** The measurement value. For example, this value may be '13'. */
  value: string;
}

/**
 * Current state of all quotas for this Analytics property. If any quota for a
 * property is exhausted, all requests to that property will return Resource
 * Exhausted errors.
 */
export interface AccessQuota {
  /**
   * Properties can use 250,000 tokens per day. Most requests consume fewer than
   * 10 tokens.
   */
  tokensPerDay:
    | AccessQuotaStatus
    | undefined;
  /**
   * Properties can use 50,000 tokens per hour. An API request consumes a single
   * number of tokens, and that number is deducted from all of the hourly,
   * daily, and per project hourly quotas.
   */
  tokensPerHour:
    | AccessQuotaStatus
    | undefined;
  /** Properties can use up to 50 concurrent requests. */
  concurrentRequests:
    | AccessQuotaStatus
    | undefined;
  /**
   * Properties and cloud project pairs can have up to 50 server errors per
   * hour.
   */
  serverErrorsPerProjectPerHour:
    | AccessQuotaStatus
    | undefined;
  /**
   * Properties can use up to 25% of their tokens per project per hour. This
   * amounts to Analytics 360 Properties can use 12,500 tokens per project per
   * hour. An API request consumes a single number of tokens, and that number is
   * deducted from all of the hourly, daily, and per project hourly quotas.
   */
  tokensPerProjectPerHour: AccessQuotaStatus | undefined;
}

/** Current state for a particular quota group. */
export interface AccessQuotaStatus {
  /** Quota consumed by this request. */
  consumed: number;
  /** Quota remaining after this request. */
  remaining: number;
}

function createBaseAccessDimension(): AccessDimension {
  return { dimensionName: "" };
}

export const AccessDimension: MessageFns<AccessDimension> = {
  encode(message: AccessDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimensionName !== "") {
      writer.uint32(10).string(message.dimensionName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessDimension {
    return { dimensionName: isSet(object.dimensionName) ? globalThis.String(object.dimensionName) : "" };
  },

  toJSON(message: AccessDimension): unknown {
    const obj: any = {};
    if (message.dimensionName !== "") {
      obj.dimensionName = message.dimensionName;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessDimension>): AccessDimension {
    return AccessDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessDimension>): AccessDimension {
    const message = createBaseAccessDimension();
    message.dimensionName = object.dimensionName ?? "";
    return message;
  },
};

function createBaseAccessMetric(): AccessMetric {
  return { metricName: "" };
}

export const AccessMetric: MessageFns<AccessMetric> = {
  encode(message: AccessMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessMetric {
    return { metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "" };
  },

  toJSON(message: AccessMetric): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessMetric>): AccessMetric {
    return AccessMetric.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessMetric>): AccessMetric {
    const message = createBaseAccessMetric();
    message.metricName = object.metricName ?? "";
    return message;
  },
};

function createBaseAccessDateRange(): AccessDateRange {
  return { startDate: "", endDate: "" };
}

export const AccessDateRange: MessageFns<AccessDateRange> = {
  encode(message: AccessDateRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startDate !== "") {
      writer.uint32(10).string(message.startDate);
    }
    if (message.endDate !== "") {
      writer.uint32(18).string(message.endDate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessDateRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessDateRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startDate = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endDate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessDateRange {
    return {
      startDate: isSet(object.startDate) ? globalThis.String(object.startDate) : "",
      endDate: isSet(object.endDate) ? globalThis.String(object.endDate) : "",
    };
  },

  toJSON(message: AccessDateRange): unknown {
    const obj: any = {};
    if (message.startDate !== "") {
      obj.startDate = message.startDate;
    }
    if (message.endDate !== "") {
      obj.endDate = message.endDate;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessDateRange>): AccessDateRange {
    return AccessDateRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessDateRange>): AccessDateRange {
    const message = createBaseAccessDateRange();
    message.startDate = object.startDate ?? "";
    message.endDate = object.endDate ?? "";
    return message;
  },
};

function createBaseAccessFilterExpression(): AccessFilterExpression {
  return { andGroup: undefined, orGroup: undefined, notExpression: undefined, accessFilter: undefined };
}

export const AccessFilterExpression: MessageFns<AccessFilterExpression> = {
  encode(message: AccessFilterExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.andGroup !== undefined) {
      AccessFilterExpressionList.encode(message.andGroup, writer.uint32(10).fork()).join();
    }
    if (message.orGroup !== undefined) {
      AccessFilterExpressionList.encode(message.orGroup, writer.uint32(18).fork()).join();
    }
    if (message.notExpression !== undefined) {
      AccessFilterExpression.encode(message.notExpression, writer.uint32(26).fork()).join();
    }
    if (message.accessFilter !== undefined) {
      AccessFilter.encode(message.accessFilter, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessFilterExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessFilterExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.andGroup = AccessFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orGroup = AccessFilterExpressionList.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notExpression = AccessFilterExpression.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.accessFilter = AccessFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessFilterExpression {
    return {
      andGroup: isSet(object.andGroup) ? AccessFilterExpressionList.fromJSON(object.andGroup) : undefined,
      orGroup: isSet(object.orGroup) ? AccessFilterExpressionList.fromJSON(object.orGroup) : undefined,
      notExpression: isSet(object.notExpression) ? AccessFilterExpression.fromJSON(object.notExpression) : undefined,
      accessFilter: isSet(object.accessFilter) ? AccessFilter.fromJSON(object.accessFilter) : undefined,
    };
  },

  toJSON(message: AccessFilterExpression): unknown {
    const obj: any = {};
    if (message.andGroup !== undefined) {
      obj.andGroup = AccessFilterExpressionList.toJSON(message.andGroup);
    }
    if (message.orGroup !== undefined) {
      obj.orGroup = AccessFilterExpressionList.toJSON(message.orGroup);
    }
    if (message.notExpression !== undefined) {
      obj.notExpression = AccessFilterExpression.toJSON(message.notExpression);
    }
    if (message.accessFilter !== undefined) {
      obj.accessFilter = AccessFilter.toJSON(message.accessFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessFilterExpression>): AccessFilterExpression {
    return AccessFilterExpression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessFilterExpression>): AccessFilterExpression {
    const message = createBaseAccessFilterExpression();
    message.andGroup = (object.andGroup !== undefined && object.andGroup !== null)
      ? AccessFilterExpressionList.fromPartial(object.andGroup)
      : undefined;
    message.orGroup = (object.orGroup !== undefined && object.orGroup !== null)
      ? AccessFilterExpressionList.fromPartial(object.orGroup)
      : undefined;
    message.notExpression = (object.notExpression !== undefined && object.notExpression !== null)
      ? AccessFilterExpression.fromPartial(object.notExpression)
      : undefined;
    message.accessFilter = (object.accessFilter !== undefined && object.accessFilter !== null)
      ? AccessFilter.fromPartial(object.accessFilter)
      : undefined;
    return message;
  },
};

function createBaseAccessFilterExpressionList(): AccessFilterExpressionList {
  return { expressions: [] };
}

export const AccessFilterExpressionList: MessageFns<AccessFilterExpressionList> = {
  encode(message: AccessFilterExpressionList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.expressions) {
      AccessFilterExpression.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessFilterExpressionList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessFilterExpressionList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expressions.push(AccessFilterExpression.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessFilterExpressionList {
    return {
      expressions: globalThis.Array.isArray(object?.expressions)
        ? object.expressions.map((e: any) => AccessFilterExpression.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AccessFilterExpressionList): unknown {
    const obj: any = {};
    if (message.expressions?.length) {
      obj.expressions = message.expressions.map((e) => AccessFilterExpression.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AccessFilterExpressionList>): AccessFilterExpressionList {
    return AccessFilterExpressionList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessFilterExpressionList>): AccessFilterExpressionList {
    const message = createBaseAccessFilterExpressionList();
    message.expressions = object.expressions?.map((e) => AccessFilterExpression.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAccessFilter(): AccessFilter {
  return {
    stringFilter: undefined,
    inListFilter: undefined,
    numericFilter: undefined,
    betweenFilter: undefined,
    fieldName: "",
  };
}

export const AccessFilter: MessageFns<AccessFilter> = {
  encode(message: AccessFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringFilter !== undefined) {
      AccessStringFilter.encode(message.stringFilter, writer.uint32(18).fork()).join();
    }
    if (message.inListFilter !== undefined) {
      AccessInListFilter.encode(message.inListFilter, writer.uint32(26).fork()).join();
    }
    if (message.numericFilter !== undefined) {
      AccessNumericFilter.encode(message.numericFilter, writer.uint32(34).fork()).join();
    }
    if (message.betweenFilter !== undefined) {
      AccessBetweenFilter.encode(message.betweenFilter, writer.uint32(42).fork()).join();
    }
    if (message.fieldName !== "") {
      writer.uint32(10).string(message.fieldName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stringFilter = AccessStringFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inListFilter = AccessInListFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.numericFilter = AccessNumericFilter.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.betweenFilter = AccessBetweenFilter.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessFilter {
    return {
      stringFilter: isSet(object.stringFilter) ? AccessStringFilter.fromJSON(object.stringFilter) : undefined,
      inListFilter: isSet(object.inListFilter) ? AccessInListFilter.fromJSON(object.inListFilter) : undefined,
      numericFilter: isSet(object.numericFilter) ? AccessNumericFilter.fromJSON(object.numericFilter) : undefined,
      betweenFilter: isSet(object.betweenFilter) ? AccessBetweenFilter.fromJSON(object.betweenFilter) : undefined,
      fieldName: isSet(object.fieldName) ? globalThis.String(object.fieldName) : "",
    };
  },

  toJSON(message: AccessFilter): unknown {
    const obj: any = {};
    if (message.stringFilter !== undefined) {
      obj.stringFilter = AccessStringFilter.toJSON(message.stringFilter);
    }
    if (message.inListFilter !== undefined) {
      obj.inListFilter = AccessInListFilter.toJSON(message.inListFilter);
    }
    if (message.numericFilter !== undefined) {
      obj.numericFilter = AccessNumericFilter.toJSON(message.numericFilter);
    }
    if (message.betweenFilter !== undefined) {
      obj.betweenFilter = AccessBetweenFilter.toJSON(message.betweenFilter);
    }
    if (message.fieldName !== "") {
      obj.fieldName = message.fieldName;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessFilter>): AccessFilter {
    return AccessFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessFilter>): AccessFilter {
    const message = createBaseAccessFilter();
    message.stringFilter = (object.stringFilter !== undefined && object.stringFilter !== null)
      ? AccessStringFilter.fromPartial(object.stringFilter)
      : undefined;
    message.inListFilter = (object.inListFilter !== undefined && object.inListFilter !== null)
      ? AccessInListFilter.fromPartial(object.inListFilter)
      : undefined;
    message.numericFilter = (object.numericFilter !== undefined && object.numericFilter !== null)
      ? AccessNumericFilter.fromPartial(object.numericFilter)
      : undefined;
    message.betweenFilter = (object.betweenFilter !== undefined && object.betweenFilter !== null)
      ? AccessBetweenFilter.fromPartial(object.betweenFilter)
      : undefined;
    message.fieldName = object.fieldName ?? "";
    return message;
  },
};

function createBaseAccessStringFilter(): AccessStringFilter {
  return { matchType: 0, value: "", caseSensitive: false };
}

export const AccessStringFilter: MessageFns<AccessStringFilter> = {
  encode(message: AccessStringFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.matchType !== 0) {
      writer.uint32(8).int32(message.matchType);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.caseSensitive !== false) {
      writer.uint32(24).bool(message.caseSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessStringFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessStringFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.caseSensitive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessStringFilter {
    return {
      matchType: isSet(object.matchType) ? accessStringFilter_MatchTypeFromJSON(object.matchType) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      caseSensitive: isSet(object.caseSensitive) ? globalThis.Boolean(object.caseSensitive) : false,
    };
  },

  toJSON(message: AccessStringFilter): unknown {
    const obj: any = {};
    if (message.matchType !== 0) {
      obj.matchType = accessStringFilter_MatchTypeToJSON(message.matchType);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.caseSensitive !== false) {
      obj.caseSensitive = message.caseSensitive;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessStringFilter>): AccessStringFilter {
    return AccessStringFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessStringFilter>): AccessStringFilter {
    const message = createBaseAccessStringFilter();
    message.matchType = object.matchType ?? 0;
    message.value = object.value ?? "";
    message.caseSensitive = object.caseSensitive ?? false;
    return message;
  },
};

function createBaseAccessInListFilter(): AccessInListFilter {
  return { values: [], caseSensitive: false };
}

export const AccessInListFilter: MessageFns<AccessInListFilter> = {
  encode(message: AccessInListFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    if (message.caseSensitive !== false) {
      writer.uint32(16).bool(message.caseSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessInListFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessInListFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.caseSensitive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessInListFilter {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
      caseSensitive: isSet(object.caseSensitive) ? globalThis.Boolean(object.caseSensitive) : false,
    };
  },

  toJSON(message: AccessInListFilter): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.caseSensitive !== false) {
      obj.caseSensitive = message.caseSensitive;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessInListFilter>): AccessInListFilter {
    return AccessInListFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessInListFilter>): AccessInListFilter {
    const message = createBaseAccessInListFilter();
    message.values = object.values?.map((e) => e) || [];
    message.caseSensitive = object.caseSensitive ?? false;
    return message;
  },
};

function createBaseAccessNumericFilter(): AccessNumericFilter {
  return { operation: 0, value: undefined };
}

export const AccessNumericFilter: MessageFns<AccessNumericFilter> = {
  encode(message: AccessNumericFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== 0) {
      writer.uint32(8).int32(message.operation);
    }
    if (message.value !== undefined) {
      NumericValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessNumericFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessNumericFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = NumericValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessNumericFilter {
    return {
      operation: isSet(object.operation) ? accessNumericFilter_OperationFromJSON(object.operation) : 0,
      value: isSet(object.value) ? NumericValue.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AccessNumericFilter): unknown {
    const obj: any = {};
    if (message.operation !== 0) {
      obj.operation = accessNumericFilter_OperationToJSON(message.operation);
    }
    if (message.value !== undefined) {
      obj.value = NumericValue.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessNumericFilter>): AccessNumericFilter {
    return AccessNumericFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessNumericFilter>): AccessNumericFilter {
    const message = createBaseAccessNumericFilter();
    message.operation = object.operation ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? NumericValue.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAccessBetweenFilter(): AccessBetweenFilter {
  return { fromValue: undefined, toValue: undefined };
}

export const AccessBetweenFilter: MessageFns<AccessBetweenFilter> = {
  encode(message: AccessBetweenFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromValue !== undefined) {
      NumericValue.encode(message.fromValue, writer.uint32(10).fork()).join();
    }
    if (message.toValue !== undefined) {
      NumericValue.encode(message.toValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessBetweenFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessBetweenFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fromValue = NumericValue.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toValue = NumericValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessBetweenFilter {
    return {
      fromValue: isSet(object.fromValue) ? NumericValue.fromJSON(object.fromValue) : undefined,
      toValue: isSet(object.toValue) ? NumericValue.fromJSON(object.toValue) : undefined,
    };
  },

  toJSON(message: AccessBetweenFilter): unknown {
    const obj: any = {};
    if (message.fromValue !== undefined) {
      obj.fromValue = NumericValue.toJSON(message.fromValue);
    }
    if (message.toValue !== undefined) {
      obj.toValue = NumericValue.toJSON(message.toValue);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessBetweenFilter>): AccessBetweenFilter {
    return AccessBetweenFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessBetweenFilter>): AccessBetweenFilter {
    const message = createBaseAccessBetweenFilter();
    message.fromValue = (object.fromValue !== undefined && object.fromValue !== null)
      ? NumericValue.fromPartial(object.fromValue)
      : undefined;
    message.toValue = (object.toValue !== undefined && object.toValue !== null)
      ? NumericValue.fromPartial(object.toValue)
      : undefined;
    return message;
  },
};

function createBaseNumericValue(): NumericValue {
  return { int64Value: undefined, doubleValue: undefined };
}

export const NumericValue: MessageFns<NumericValue> = {
  encode(message: NumericValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.int64Value !== undefined) {
      writer.uint32(8).int64(message.int64Value.toString());
    }
    if (message.doubleValue !== undefined) {
      writer.uint32(17).double(message.doubleValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NumericValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumericValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.int64Value = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.doubleValue = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumericValue {
    return {
      int64Value: isSet(object.int64Value) ? Long.fromValue(object.int64Value) : undefined,
      doubleValue: isSet(object.doubleValue) ? globalThis.Number(object.doubleValue) : undefined,
    };
  },

  toJSON(message: NumericValue): unknown {
    const obj: any = {};
    if (message.int64Value !== undefined) {
      obj.int64Value = (message.int64Value || Long.ZERO).toString();
    }
    if (message.doubleValue !== undefined) {
      obj.doubleValue = message.doubleValue;
    }
    return obj;
  },

  create(base?: DeepPartial<NumericValue>): NumericValue {
    return NumericValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NumericValue>): NumericValue {
    const message = createBaseNumericValue();
    message.int64Value = (object.int64Value !== undefined && object.int64Value !== null)
      ? Long.fromValue(object.int64Value)
      : undefined;
    message.doubleValue = object.doubleValue ?? undefined;
    return message;
  },
};

function createBaseAccessOrderBy(): AccessOrderBy {
  return { metric: undefined, dimension: undefined, desc: false };
}

export const AccessOrderBy: MessageFns<AccessOrderBy> = {
  encode(message: AccessOrderBy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metric !== undefined) {
      AccessOrderBy_MetricOrderBy.encode(message.metric, writer.uint32(10).fork()).join();
    }
    if (message.dimension !== undefined) {
      AccessOrderBy_DimensionOrderBy.encode(message.dimension, writer.uint32(18).fork()).join();
    }
    if (message.desc !== false) {
      writer.uint32(24).bool(message.desc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessOrderBy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessOrderBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metric = AccessOrderBy_MetricOrderBy.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimension = AccessOrderBy_DimensionOrderBy.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.desc = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessOrderBy {
    return {
      metric: isSet(object.metric) ? AccessOrderBy_MetricOrderBy.fromJSON(object.metric) : undefined,
      dimension: isSet(object.dimension) ? AccessOrderBy_DimensionOrderBy.fromJSON(object.dimension) : undefined,
      desc: isSet(object.desc) ? globalThis.Boolean(object.desc) : false,
    };
  },

  toJSON(message: AccessOrderBy): unknown {
    const obj: any = {};
    if (message.metric !== undefined) {
      obj.metric = AccessOrderBy_MetricOrderBy.toJSON(message.metric);
    }
    if (message.dimension !== undefined) {
      obj.dimension = AccessOrderBy_DimensionOrderBy.toJSON(message.dimension);
    }
    if (message.desc !== false) {
      obj.desc = message.desc;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessOrderBy>): AccessOrderBy {
    return AccessOrderBy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessOrderBy>): AccessOrderBy {
    const message = createBaseAccessOrderBy();
    message.metric = (object.metric !== undefined && object.metric !== null)
      ? AccessOrderBy_MetricOrderBy.fromPartial(object.metric)
      : undefined;
    message.dimension = (object.dimension !== undefined && object.dimension !== null)
      ? AccessOrderBy_DimensionOrderBy.fromPartial(object.dimension)
      : undefined;
    message.desc = object.desc ?? false;
    return message;
  },
};

function createBaseAccessOrderBy_MetricOrderBy(): AccessOrderBy_MetricOrderBy {
  return { metricName: "" };
}

export const AccessOrderBy_MetricOrderBy: MessageFns<AccessOrderBy_MetricOrderBy> = {
  encode(message: AccessOrderBy_MetricOrderBy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessOrderBy_MetricOrderBy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessOrderBy_MetricOrderBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessOrderBy_MetricOrderBy {
    return { metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "" };
  },

  toJSON(message: AccessOrderBy_MetricOrderBy): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessOrderBy_MetricOrderBy>): AccessOrderBy_MetricOrderBy {
    return AccessOrderBy_MetricOrderBy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessOrderBy_MetricOrderBy>): AccessOrderBy_MetricOrderBy {
    const message = createBaseAccessOrderBy_MetricOrderBy();
    message.metricName = object.metricName ?? "";
    return message;
  },
};

function createBaseAccessOrderBy_DimensionOrderBy(): AccessOrderBy_DimensionOrderBy {
  return { dimensionName: "", orderType: 0 };
}

export const AccessOrderBy_DimensionOrderBy: MessageFns<AccessOrderBy_DimensionOrderBy> = {
  encode(message: AccessOrderBy_DimensionOrderBy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimensionName !== "") {
      writer.uint32(10).string(message.dimensionName);
    }
    if (message.orderType !== 0) {
      writer.uint32(16).int32(message.orderType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessOrderBy_DimensionOrderBy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessOrderBy_DimensionOrderBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessOrderBy_DimensionOrderBy {
    return {
      dimensionName: isSet(object.dimensionName) ? globalThis.String(object.dimensionName) : "",
      orderType: isSet(object.orderType) ? accessOrderBy_DimensionOrderBy_OrderTypeFromJSON(object.orderType) : 0,
    };
  },

  toJSON(message: AccessOrderBy_DimensionOrderBy): unknown {
    const obj: any = {};
    if (message.dimensionName !== "") {
      obj.dimensionName = message.dimensionName;
    }
    if (message.orderType !== 0) {
      obj.orderType = accessOrderBy_DimensionOrderBy_OrderTypeToJSON(message.orderType);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessOrderBy_DimensionOrderBy>): AccessOrderBy_DimensionOrderBy {
    return AccessOrderBy_DimensionOrderBy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessOrderBy_DimensionOrderBy>): AccessOrderBy_DimensionOrderBy {
    const message = createBaseAccessOrderBy_DimensionOrderBy();
    message.dimensionName = object.dimensionName ?? "";
    message.orderType = object.orderType ?? 0;
    return message;
  },
};

function createBaseAccessDimensionHeader(): AccessDimensionHeader {
  return { dimensionName: "" };
}

export const AccessDimensionHeader: MessageFns<AccessDimensionHeader> = {
  encode(message: AccessDimensionHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimensionName !== "") {
      writer.uint32(10).string(message.dimensionName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessDimensionHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessDimensionHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessDimensionHeader {
    return { dimensionName: isSet(object.dimensionName) ? globalThis.String(object.dimensionName) : "" };
  },

  toJSON(message: AccessDimensionHeader): unknown {
    const obj: any = {};
    if (message.dimensionName !== "") {
      obj.dimensionName = message.dimensionName;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessDimensionHeader>): AccessDimensionHeader {
    return AccessDimensionHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessDimensionHeader>): AccessDimensionHeader {
    const message = createBaseAccessDimensionHeader();
    message.dimensionName = object.dimensionName ?? "";
    return message;
  },
};

function createBaseAccessMetricHeader(): AccessMetricHeader {
  return { metricName: "" };
}

export const AccessMetricHeader: MessageFns<AccessMetricHeader> = {
  encode(message: AccessMetricHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessMetricHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessMetricHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessMetricHeader {
    return { metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "" };
  },

  toJSON(message: AccessMetricHeader): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessMetricHeader>): AccessMetricHeader {
    return AccessMetricHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessMetricHeader>): AccessMetricHeader {
    const message = createBaseAccessMetricHeader();
    message.metricName = object.metricName ?? "";
    return message;
  },
};

function createBaseAccessRow(): AccessRow {
  return { dimensionValues: [], metricValues: [] };
}

export const AccessRow: MessageFns<AccessRow> = {
  encode(message: AccessRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensionValues) {
      AccessDimensionValue.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.metricValues) {
      AccessMetricValue.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionValues.push(AccessDimensionValue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metricValues.push(AccessMetricValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessRow {
    return {
      dimensionValues: globalThis.Array.isArray(object?.dimensionValues)
        ? object.dimensionValues.map((e: any) => AccessDimensionValue.fromJSON(e))
        : [],
      metricValues: globalThis.Array.isArray(object?.metricValues)
        ? object.metricValues.map((e: any) => AccessMetricValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AccessRow): unknown {
    const obj: any = {};
    if (message.dimensionValues?.length) {
      obj.dimensionValues = message.dimensionValues.map((e) => AccessDimensionValue.toJSON(e));
    }
    if (message.metricValues?.length) {
      obj.metricValues = message.metricValues.map((e) => AccessMetricValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AccessRow>): AccessRow {
    return AccessRow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessRow>): AccessRow {
    const message = createBaseAccessRow();
    message.dimensionValues = object.dimensionValues?.map((e) => AccessDimensionValue.fromPartial(e)) || [];
    message.metricValues = object.metricValues?.map((e) => AccessMetricValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAccessDimensionValue(): AccessDimensionValue {
  return { value: "" };
}

export const AccessDimensionValue: MessageFns<AccessDimensionValue> = {
  encode(message: AccessDimensionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessDimensionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessDimensionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessDimensionValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: AccessDimensionValue): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessDimensionValue>): AccessDimensionValue {
    return AccessDimensionValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessDimensionValue>): AccessDimensionValue {
    const message = createBaseAccessDimensionValue();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccessMetricValue(): AccessMetricValue {
  return { value: "" };
}

export const AccessMetricValue: MessageFns<AccessMetricValue> = {
  encode(message: AccessMetricValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessMetricValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessMetricValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessMetricValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: AccessMetricValue): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessMetricValue>): AccessMetricValue {
    return AccessMetricValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessMetricValue>): AccessMetricValue {
    const message = createBaseAccessMetricValue();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAccessQuota(): AccessQuota {
  return {
    tokensPerDay: undefined,
    tokensPerHour: undefined,
    concurrentRequests: undefined,
    serverErrorsPerProjectPerHour: undefined,
    tokensPerProjectPerHour: undefined,
  };
}

export const AccessQuota: MessageFns<AccessQuota> = {
  encode(message: AccessQuota, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokensPerDay !== undefined) {
      AccessQuotaStatus.encode(message.tokensPerDay, writer.uint32(10).fork()).join();
    }
    if (message.tokensPerHour !== undefined) {
      AccessQuotaStatus.encode(message.tokensPerHour, writer.uint32(18).fork()).join();
    }
    if (message.concurrentRequests !== undefined) {
      AccessQuotaStatus.encode(message.concurrentRequests, writer.uint32(26).fork()).join();
    }
    if (message.serverErrorsPerProjectPerHour !== undefined) {
      AccessQuotaStatus.encode(message.serverErrorsPerProjectPerHour, writer.uint32(34).fork()).join();
    }
    if (message.tokensPerProjectPerHour !== undefined) {
      AccessQuotaStatus.encode(message.tokensPerProjectPerHour, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessQuota {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessQuota();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokensPerDay = AccessQuotaStatus.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokensPerHour = AccessQuotaStatus.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.concurrentRequests = AccessQuotaStatus.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serverErrorsPerProjectPerHour = AccessQuotaStatus.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tokensPerProjectPerHour = AccessQuotaStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessQuota {
    return {
      tokensPerDay: isSet(object.tokensPerDay) ? AccessQuotaStatus.fromJSON(object.tokensPerDay) : undefined,
      tokensPerHour: isSet(object.tokensPerHour) ? AccessQuotaStatus.fromJSON(object.tokensPerHour) : undefined,
      concurrentRequests: isSet(object.concurrentRequests)
        ? AccessQuotaStatus.fromJSON(object.concurrentRequests)
        : undefined,
      serverErrorsPerProjectPerHour: isSet(object.serverErrorsPerProjectPerHour)
        ? AccessQuotaStatus.fromJSON(object.serverErrorsPerProjectPerHour)
        : undefined,
      tokensPerProjectPerHour: isSet(object.tokensPerProjectPerHour)
        ? AccessQuotaStatus.fromJSON(object.tokensPerProjectPerHour)
        : undefined,
    };
  },

  toJSON(message: AccessQuota): unknown {
    const obj: any = {};
    if (message.tokensPerDay !== undefined) {
      obj.tokensPerDay = AccessQuotaStatus.toJSON(message.tokensPerDay);
    }
    if (message.tokensPerHour !== undefined) {
      obj.tokensPerHour = AccessQuotaStatus.toJSON(message.tokensPerHour);
    }
    if (message.concurrentRequests !== undefined) {
      obj.concurrentRequests = AccessQuotaStatus.toJSON(message.concurrentRequests);
    }
    if (message.serverErrorsPerProjectPerHour !== undefined) {
      obj.serverErrorsPerProjectPerHour = AccessQuotaStatus.toJSON(message.serverErrorsPerProjectPerHour);
    }
    if (message.tokensPerProjectPerHour !== undefined) {
      obj.tokensPerProjectPerHour = AccessQuotaStatus.toJSON(message.tokensPerProjectPerHour);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessQuota>): AccessQuota {
    return AccessQuota.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessQuota>): AccessQuota {
    const message = createBaseAccessQuota();
    message.tokensPerDay = (object.tokensPerDay !== undefined && object.tokensPerDay !== null)
      ? AccessQuotaStatus.fromPartial(object.tokensPerDay)
      : undefined;
    message.tokensPerHour = (object.tokensPerHour !== undefined && object.tokensPerHour !== null)
      ? AccessQuotaStatus.fromPartial(object.tokensPerHour)
      : undefined;
    message.concurrentRequests = (object.concurrentRequests !== undefined && object.concurrentRequests !== null)
      ? AccessQuotaStatus.fromPartial(object.concurrentRequests)
      : undefined;
    message.serverErrorsPerProjectPerHour =
      (object.serverErrorsPerProjectPerHour !== undefined && object.serverErrorsPerProjectPerHour !== null)
        ? AccessQuotaStatus.fromPartial(object.serverErrorsPerProjectPerHour)
        : undefined;
    message.tokensPerProjectPerHour =
      (object.tokensPerProjectPerHour !== undefined && object.tokensPerProjectPerHour !== null)
        ? AccessQuotaStatus.fromPartial(object.tokensPerProjectPerHour)
        : undefined;
    return message;
  },
};

function createBaseAccessQuotaStatus(): AccessQuotaStatus {
  return { consumed: 0, remaining: 0 };
}

export const AccessQuotaStatus: MessageFns<AccessQuotaStatus> = {
  encode(message: AccessQuotaStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumed !== 0) {
      writer.uint32(8).int32(message.consumed);
    }
    if (message.remaining !== 0) {
      writer.uint32(16).int32(message.remaining);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessQuotaStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessQuotaStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.consumed = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.remaining = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessQuotaStatus {
    return {
      consumed: isSet(object.consumed) ? globalThis.Number(object.consumed) : 0,
      remaining: isSet(object.remaining) ? globalThis.Number(object.remaining) : 0,
    };
  },

  toJSON(message: AccessQuotaStatus): unknown {
    const obj: any = {};
    if (message.consumed !== 0) {
      obj.consumed = Math.round(message.consumed);
    }
    if (message.remaining !== 0) {
      obj.remaining = Math.round(message.remaining);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessQuotaStatus>): AccessQuotaStatus {
    return AccessQuotaStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessQuotaStatus>): AccessQuotaStatus {
    const message = createBaseAccessQuotaStatus();
    message.consumed = object.consumed ?? 0;
    message.remaining = object.remaining ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
