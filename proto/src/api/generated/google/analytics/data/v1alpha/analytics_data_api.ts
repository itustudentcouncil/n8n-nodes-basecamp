// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/analytics/data/v1alpha/analytics_data_api.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  CohortSpec,
  DateRange,
  Dimension,
  DimensionHeader,
  FilterExpression,
  Funnel,
  FunnelBreakdown,
  FunnelNextAction,
  FunnelSubReport,
  Metric,
  MetricAggregation,
  metricAggregationFromJSON,
  metricAggregationToJSON,
  MetricHeader,
  OrderBy,
  PropertyQuota,
  ResponseMetaData,
  Row,
  Segment,
} from "./data.js";

export const protobufPackage = "google.analytics.data.v1alpha";

/** A request to create a new recurring audience list. */
export interface CreateRecurringAudienceListRequest {
  /**
   * Required. The parent resource where this recurring audience list will be
   * created. Format: `properties/{property}`
   */
  parent: string;
  /** Required. The recurring audience list to create. */
  recurringAudienceList: RecurringAudienceList | undefined;
}

/**
 * A recurring audience list produces new audience lists each day. Audience
 * lists are users in an audience at the time of the list's creation. A
 * recurring audience list ensures that you have audience list based on the most
 * recent data available for use each day.
 */
export interface RecurringAudienceList {
  /**
   * Output only. Identifier. The recurring audience list resource name assigned
   * during creation. This resource name identifies this
   * `RecurringAudienceList`.
   *
   * Format:
   * `properties/{property}/recurringAudienceLists/{recurring_audience_list}`
   */
  name: string;
  /**
   * Required. The audience resource name. This resource name identifies the
   * audience being listed and is shared between the Analytics Data & Admin
   * APIs.
   *
   * Format: `properties/{property}/audiences/{audience}`
   */
  audience: string;
  /**
   * Output only. The descriptive display name for this audience. For example,
   * "Purchasers".
   */
  audienceDisplayName: string;
  /**
   * Required. The dimensions requested and displayed in the audience list
   * response.
   */
  dimensions: AudienceDimension[];
  /**
   * Optional. The number of remaining days that a recurring audience export
   * will produce an audience list instance. This counter decreases by one each
   * day, and when it reaches zero, no new audience lists will be created.
   *
   * Recurring audience list request for Analytics 360 properties default to 180
   * days and have a maximum of 365 days. Requests for standard Analytics
   * properties default to 14 days and have a maximum of 30 days.
   *
   * The minimum value allowed during creation is 1. Requests above their
   * respective maximum will be coerced to their maximum.
   */
  activeDaysRemaining?:
    | number
    | undefined;
  /**
   * Output only. Audience list resource names for audience list instances
   * created for this recurring audience list. One audience list is created for
   * each day, and the audience list will be listed here.
   *
   * This list is ordered with the most recently created audience list first.
   */
  audienceLists: string[];
  /**
   * Optional. Configures webhook notifications to be sent from the Google
   * Analytics Data API to your webhook server. Use of webhooks is optional. If
   * unused, you'll need to poll this API to determine when a recurring audience
   * list creates new audience lists. Webhooks allow a notification to be sent
   * to your servers & avoid the need for polling.
   *
   * Two POST requests will be sent each time a recurring audience list creates
   * an audience list. This happens once per day until a recurring audience list
   * reaches 0 active days remaining. The first request will be sent showing a
   * newly created audience list in its CREATING state. The second request will
   * be sent after the audience list completes creation (either the ACTIVE or
   * FAILED state).
   */
  webhookNotification?: WebhookNotification | undefined;
}

/**
 * Configures a long-running operation resource to send a webhook notification
 * from the Google Analytics Data API to your webhook server when the resource
 * updates.
 *
 * Notification configurations contain private values & are only visible to your
 * GCP project. Different GCP projects may attach different webhook
 * notifications to the same long-running operation resource.
 */
export interface WebhookNotification {
  /**
   * Optional. The web address that will receive the webhook notification. This
   * address will receive POST requests as the state of the long running
   * operation resource changes. The POST request will contain both a JSON
   * version of the long running operation resource in the body and a
   * `sentTimestamp` field. The sent timestamp will specify the unix
   * microseconds since the epoch that the request was sent; this lets you
   * identify replayed notifications.
   *
   * An example URI is
   * `https://us-central1-example-project-id.cloudfunctions.net/example-function-1`.
   *
   * The URI must use HTTPS and point to a site with a valid SSL certificate on
   * the web server. The URI must have a maximum string length of 128 characters
   * & use only the allowlisted characters from [RFC
   * 1738](https://www.rfc-editor.org/rfc/rfc1738).
   *
   * When your webhook server receives a notification, it is expected to reply
   * with an HTTP response status code of 200 within 5 seconds.
   *
   * A URI is required to use webhook notifications.
   *
   * Requests to this webhook server will contain an ID token authenticating the
   * service account
   * `google-analytics-audience-export@system.gserviceaccount.com`. To learn
   * more about ID tokens, see
   * https://cloud.google.com/docs/authentication/token-types#id. For Google
   * Cloud Functions, this lets you configure your function to require
   * authentication. In Cloud IAM, you will need to grant the service account
   * permissions to the Cloud Run Invoker (`roles/run.invoker`) & Cloud
   * Functions Invoker (`roles/cloudfunctions.invoker`) roles for the webhook
   * post request to pass Google Cloud Functions authentication. This API can
   * send webhook notifications to arbitrary URIs; for webhook servers other
   * than Google Cloud Functions, this ID token in the authorization bearer
   * header should be ignored if it is not needed.
   */
  uri?:
    | string
    | undefined;
  /**
   * Optional. The channel token is an arbitrary string value and must have a
   * maximum string length of 64 characters. Channel tokens allow you to verify
   * the source of a webhook notification. This guards against the message being
   * spoofed. The channel token will be specified in the `X-Goog-Channel-Token`
   * HTTP header of the webhook POST request.
   *
   * A channel token is not required to use webhook notifications.
   */
  channelToken?: string | undefined;
}

/**
 * A request to retrieve configuration metadata about a specific recurring
 * audience list.
 */
export interface GetRecurringAudienceListRequest {
  /**
   * Required. The recurring audience list resource name.
   * Format:
   * `properties/{property}/recurringAudienceLists/{recurring_audience_list}`
   */
  name: string;
}

/** A request to list all recurring audience lists for a property. */
export interface ListRecurringAudienceListsRequest {
  /**
   * Required. All recurring audience lists for this property will be listed in
   * the response. Format: `properties/{property}`
   */
  parent: string;
  /**
   * Optional. The maximum number of recurring audience lists to return. The
   * service may return fewer than this value. If unspecified, at most 200
   * recurring audience lists will be returned. The maximum value is 1000
   * (higher values will be coerced to the maximum).
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous
   * `ListRecurringAudienceLists` call. Provide this to retrieve the subsequent
   * page.
   *
   * When paginating, all other parameters provided to
   * `ListRecurringAudienceLists` must match the call that provided the page
   * token.
   */
  pageToken: string;
}

/** A list of all recurring audience lists for a property. */
export interface ListRecurringAudienceListsResponse {
  /** Each recurring audience list for a property. */
  recurringAudienceLists: RecurringAudienceList[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken?: string | undefined;
}

/** A request to return the PropertyQuotasSnapshot for a given category. */
export interface GetPropertyQuotasSnapshotRequest {
  /**
   * Required. Quotas from this property will be listed in the response.
   * Format: `properties/{property}/propertyQuotasSnapshot`
   */
  name: string;
}

/** Current state of all Property Quotas organized by quota category. */
export interface PropertyQuotasSnapshot {
  /** Identifier. The property quota snapshot resource name. */
  name: string;
  /** Property Quota for core property tokens */
  corePropertyQuota:
    | PropertyQuota
    | undefined;
  /** Property Quota for realtime property tokens */
  realtimePropertyQuota:
    | PropertyQuota
    | undefined;
  /** Property Quota for funnel property tokens */
  funnelPropertyQuota: PropertyQuota | undefined;
}

/** A request to retrieve configuration metadata about a specific audience list. */
export interface GetAudienceListRequest {
  /**
   * Required. The audience list resource name.
   * Format: `properties/{property}/audienceLists/{audience_list}`
   */
  name: string;
}

/** A request to list all audience lists for a property. */
export interface ListAudienceListsRequest {
  /**
   * Required. All audience lists for this property will be listed in the
   * response. Format: `properties/{property}`
   */
  parent: string;
  /**
   * Optional. The maximum number of audience lists to return. The service may
   * return fewer than this value. If unspecified, at most 200 audience lists
   * will be returned. The maximum value is 1000 (higher values will be coerced
   * to the maximum).
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListAudienceLists` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListAudienceLists` must
   * match the call that provided the page token.
   */
  pageToken: string;
}

/** A list of all audience lists for a property. */
export interface ListAudienceListsResponse {
  /** Each audience list for a property. */
  audienceLists: AudienceList[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken?: string | undefined;
}

/** A request to create a new audience list. */
export interface CreateAudienceListRequest {
  /**
   * Required. The parent resource where this audience list will be created.
   * Format: `properties/{property}`
   */
  parent: string;
  /** Required. The audience list to create. */
  audienceList: AudienceList | undefined;
}

/**
 * An audience list is a list of users in an audience at the time of the list's
 * creation. One audience may have multiple audience lists created for different
 * days.
 */
export interface AudienceList {
  /**
   * Output only. Identifier. The audience list resource name assigned during
   * creation. This resource name identifies this `AudienceList`.
   *
   * Format: `properties/{property}/audienceLists/{audience_list}`
   */
  name: string;
  /**
   * Required. The audience resource name. This resource name identifies the
   * audience being listed and is shared between the Analytics Data & Admin
   * APIs.
   *
   * Format: `properties/{property}/audiences/{audience}`
   */
  audience: string;
  /**
   * Output only. The descriptive display name for this audience. For example,
   * "Purchasers".
   */
  audienceDisplayName: string;
  /** Required. The dimensions requested and displayed in the query response. */
  dimensions: AudienceDimension[];
  /** Output only. The current state for this AudienceList. */
  state?:
    | AudienceList_State
    | undefined;
  /**
   * Output only. The time when CreateAudienceList was called and the
   * AudienceList began the `CREATING` state.
   */
  beginCreatingTime?:
    | Date
    | undefined;
  /**
   * Output only. The total quota tokens charged during creation of the
   * AudienceList. Because this token count is based on activity from the
   * `CREATING` state, this tokens charged will be fixed once an AudienceList
   * enters the `ACTIVE` or `FAILED` states.
   */
  creationQuotaTokensCharged: number;
  /** Output only. The total number of rows in the AudienceList result. */
  rowCount?:
    | number
    | undefined;
  /**
   * Output only. Error message is populated when an audience list fails during
   * creation. A common reason for such a failure is quota exhaustion.
   */
  errorMessage?:
    | string
    | undefined;
  /**
   * Output only. The percentage completed for this audience export ranging
   * between 0 to 100.
   */
  percentageCompleted?:
    | number
    | undefined;
  /**
   * Output only. The recurring audience list that created this audience list.
   * Recurring audience lists create audience lists daily.
   *
   * If audience lists are created directly, they will have no associated
   * recurring audience list, and this field will be blank.
   */
  recurringAudienceList?:
    | string
    | undefined;
  /**
   * Optional. Configures webhook notifications to be sent from the Google
   * Analytics Data API to your webhook server. Use of webhooks is optional. If
   * unused, you'll need to poll this API to determine when an audience list is
   * ready to be used. Webhooks allow a notification to be sent to your servers
   * & avoid the need for polling.
   *
   * Either one or two POST requests will be sent to the webhook. The first POST
   * request will be sent immediately showing the newly created audience list in
   * its CREATING state. The second POST request will be sent after the audience
   * list completes creation (either the ACTIVE or FAILED state).
   *
   * If identical audience lists are requested in quick succession, the second &
   * subsequent audience lists can be served from cache. In that case, the
   * audience list create method can return an audience list is already ACTIVE.
   * In this scenario, only one POST request will be sent to the webhook.
   */
  webhookNotification?: WebhookNotification | undefined;
}

/** The AudienceList currently exists in this state. */
export enum AudienceList_State {
  /** STATE_UNSPECIFIED - Unspecified state will never be used. */
  STATE_UNSPECIFIED = 0,
  /**
   * CREATING - The AudienceList is currently creating and will be available in the
   * future. Creating occurs immediately after the CreateAudienceList call.
   */
  CREATING = 1,
  /**
   * ACTIVE - The AudienceList is fully created and ready for querying. An AudienceList
   * is updated to active asynchronously from a request; this occurs some
   * time (for example 15 minutes) after the initial create call.
   */
  ACTIVE = 2,
  /**
   * FAILED - The AudienceList failed to be created. It is possible that re-requesting
   * this audience list will succeed.
   */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function audienceList_StateFromJSON(object: any): AudienceList_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return AudienceList_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return AudienceList_State.CREATING;
    case 2:
    case "ACTIVE":
      return AudienceList_State.ACTIVE;
    case 3:
    case "FAILED":
      return AudienceList_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AudienceList_State.UNRECOGNIZED;
  }
}

export function audienceList_StateToJSON(object: AudienceList_State): string {
  switch (object) {
    case AudienceList_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case AudienceList_State.CREATING:
      return "CREATING";
    case AudienceList_State.ACTIVE:
      return "ACTIVE";
    case AudienceList_State.FAILED:
      return "FAILED";
    case AudienceList_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** This metadata is currently blank. */
export interface AudienceListMetadata {
}

/** A request to list users in an audience list. */
export interface QueryAudienceListRequest {
  /**
   * Required. The name of the audience list to retrieve users from.
   * Format: `properties/{property}/audienceLists/{audience_list}`
   */
  name: string;
  /**
   * Optional. The row count of the start row. The first row is counted as row
   * 0.
   *
   * When paging, the first request does not specify offset; or equivalently,
   * sets offset to 0; the first request returns the first `limit` of rows. The
   * second request sets offset to the `limit` of the first request; the second
   * request returns the second `limit` of rows.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  offset: Long;
  /**
   * Optional. The number of rows to return. If unspecified, 10,000 rows are
   * returned. The API returns a maximum of 250,000 rows per request, no matter
   * how many you ask for. `limit` must be positive.
   *
   * The API can also return fewer rows than the requested `limit`, if there
   * aren't as many dimension values as the `limit`.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  limit: Long;
}

/** A list of users in an audience list. */
export interface QueryAudienceListResponse {
  /**
   * Configuration data about AudienceList being queried. Returned to help
   * interpret the audience rows in this response. For example, the dimensions
   * in this AudienceList correspond to the columns in the AudienceRows.
   */
  audienceList?:
    | AudienceList
    | undefined;
  /**
   * Rows for each user in an audience list. The number of rows in this
   * response will be less than or equal to request's page size.
   */
  audienceRows: AudienceRow[];
  /**
   * The total number of rows in the AudienceList result. `rowCount` is
   * independent of the number of rows returned in the response, the `limit`
   * request parameter, and the `offset` request parameter. For example if a
   * query returns 175 rows and includes `limit` of 50 in the API request, the
   * response will contain `rowCount` of 175 but only 50 rows.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  rowCount?: number | undefined;
}

/** A request to export users in an audience list to a Google Sheet. */
export interface SheetExportAudienceListRequest {
  /**
   * Required. The name of the audience list to retrieve users from.
   * Format: `properties/{property}/audienceLists/{audience_list}`
   */
  name: string;
  /**
   * Optional. The row count of the start row. The first row is counted as row
   * 0.
   *
   * When paging, the first request does not specify offset; or equivalently,
   * sets offset to 0; the first request returns the first `limit` of rows. The
   * second request sets offset to the `limit` of the first request; the second
   * request returns the second `limit` of rows.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  offset: Long;
  /**
   * Optional. The number of rows to return. If unspecified, 10,000 rows are
   * returned. The API returns a maximum of 250,000 rows per request, no matter
   * how many you ask for. `limit` must be positive.
   *
   * The API can also return fewer rows than the requested `limit`, if there
   * aren't as many dimension values as the `limit`.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  limit: Long;
}

/** The created Google Sheet with the list of users in an audience list. */
export interface SheetExportAudienceListResponse {
  /** A uri for you to visit in your browser to view the Google Sheet. */
  spreadsheetUri?:
    | string
    | undefined;
  /** An ID that identifies the created Google Sheet resource. */
  spreadsheetId?:
    | string
    | undefined;
  /**
   * The total number of rows in the AudienceList result. `rowCount` is
   * independent of the number of rows returned in the response, the `limit`
   * request parameter, and the `offset` request parameter. For example if a
   * query returns 175 rows and includes `limit` of 50 in the API request, the
   * response will contain `rowCount` of 175 but only 50 rows.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  rowCount?:
    | number
    | undefined;
  /**
   * Configuration data about AudienceList being exported. Returned to help
   * interpret the AudienceList in the Google Sheet of this response.
   *
   * For example, the AudienceList may have more rows than are present in the
   * Google Sheet, and in that case, you may want to send an additional sheet
   * export request with a different `offset` value to retrieve the next page of
   * rows in an additional Google Sheet.
   */
  audienceList?: AudienceList | undefined;
}

/** Dimension value attributes for the audience user row. */
export interface AudienceRow {
  /**
   * Each dimension value attribute for an audience user. One dimension value
   * will be added for each dimension column requested.
   */
  dimensionValues: AudienceDimensionValue[];
}

/**
 * An audience dimension is a user attribute. Specific user attributed are
 * requested and then later returned in the `QueryAudienceListResponse`.
 */
export interface AudienceDimension {
  /**
   * Optional. The API name of the dimension. See the [API
   * Dimensions](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-api-schema#dimensions)
   * for the list of dimension names.
   */
  dimensionName: string;
}

/** The value of a dimension. */
export interface AudienceDimensionValue {
  /** Value as a string if the dimension type is a string. */
  value?: string | undefined;
}

/** The request for a funnel report. */
export interface RunFunnelReportRequest {
  /**
   * Optional. A Google Analytics property identifier whose events are tracked.
   * Specified in the URL path and not the body. To learn more, see [where to
   * find your Property
   * ID](https://developers.google.com/analytics/devguides/reporting/data/v1/property-id).
   * Within a batch request, this property should either be unspecified or
   * consistent with the batch-level property.
   *
   * Example: properties/1234
   */
  property: string;
  /**
   * Optional. Date ranges of data to read. If multiple date ranges are
   * requested, each response row will contain a zero based date range index. If
   * two date ranges overlap, the event data for the overlapping days is
   * included in the response rows for both date ranges.
   */
  dateRanges: DateRange[];
  /**
   * Optional. The configuration of this request's funnel. This funnel
   * configuration is required.
   */
  funnel:
    | Funnel
    | undefined;
  /**
   * Optional. If specified, this breakdown adds a dimension to the funnel table
   * sub report response. This breakdown dimension expands each funnel step to
   * the unique values of the breakdown dimension. For example, a breakdown by
   * the `deviceCategory` dimension will create rows for `mobile`, `tablet`,
   * `desktop`, and the total.
   */
  funnelBreakdown:
    | FunnelBreakdown
    | undefined;
  /**
   * Optional. If specified, next action adds a dimension to the funnel
   * visualization sub report response. This next action dimension expands each
   * funnel step to the unique values of the next action. For example a next
   * action of the `eventName` dimension will create rows for several events
   * (for example `session_start` & `click`) and the total.
   *
   * Next action only supports `eventName` and most Page / Screen dimensions
   * like `pageTitle` and `pagePath`.
   */
  funnelNextAction:
    | FunnelNextAction
    | undefined;
  /**
   * Optional. The funnel visualization type controls the dimensions present in
   * the funnel visualization sub report response. If not specified,
   * `STANDARD_FUNNEL` is used.
   */
  funnelVisualizationType: RunFunnelReportRequest_FunnelVisualizationType;
  /**
   * Optional. The configurations of segments. Segments are subsets of a
   * property's data. In a funnel report with segments, the funnel is evaluated
   * in each segment.
   *
   * Each segment specified in this request
   * produces a separate row in the response; in the response, each segment
   * identified by its name.
   *
   * The segments parameter is optional. Requests are limited to 4 segments.
   */
  segments: Segment[];
  /**
   * Optional. The number of rows to return. If unspecified, 10,000 rows are
   * returned. The API returns a maximum of 250,000 rows per request, no matter
   * how many you ask for. `limit` must be positive.
   *
   * The API can also return fewer rows than the requested `limit`, if there
   * aren't as many dimension values as the `limit`.
   */
  limit: Long;
  /**
   * Optional. Dimension filters allow you to ask for only specific dimension
   * values in the report. To learn more, see [Creating a Report: Dimension
   * Filters](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#dimension_filters)
   * for examples. Metrics cannot be used in this filter.
   */
  dimensionFilter:
    | FilterExpression
    | undefined;
  /**
   * Optional. Toggles whether to return the current state of this Analytics
   * Property's quota. Quota is returned in [PropertyQuota](#PropertyQuota).
   */
  returnPropertyQuota: boolean;
}

/**
 * Controls the dimensions present in the funnel visualization sub report
 * response.
 */
export enum RunFunnelReportRequest_FunnelVisualizationType {
  /** FUNNEL_VISUALIZATION_TYPE_UNSPECIFIED - Unspecified type. */
  FUNNEL_VISUALIZATION_TYPE_UNSPECIFIED = 0,
  /**
   * STANDARD_FUNNEL - A standard (stepped) funnel. The funnel visualization sub report in the
   * response will not contain date.
   */
  STANDARD_FUNNEL = 1,
  /**
   * TRENDED_FUNNEL - A trended (line chart) funnel. The funnel visualization sub report in the
   * response will contain the date dimension.
   */
  TRENDED_FUNNEL = 2,
  UNRECOGNIZED = -1,
}

export function runFunnelReportRequest_FunnelVisualizationTypeFromJSON(
  object: any,
): RunFunnelReportRequest_FunnelVisualizationType {
  switch (object) {
    case 0:
    case "FUNNEL_VISUALIZATION_TYPE_UNSPECIFIED":
      return RunFunnelReportRequest_FunnelVisualizationType.FUNNEL_VISUALIZATION_TYPE_UNSPECIFIED;
    case 1:
    case "STANDARD_FUNNEL":
      return RunFunnelReportRequest_FunnelVisualizationType.STANDARD_FUNNEL;
    case 2:
    case "TRENDED_FUNNEL":
      return RunFunnelReportRequest_FunnelVisualizationType.TRENDED_FUNNEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RunFunnelReportRequest_FunnelVisualizationType.UNRECOGNIZED;
  }
}

export function runFunnelReportRequest_FunnelVisualizationTypeToJSON(
  object: RunFunnelReportRequest_FunnelVisualizationType,
): string {
  switch (object) {
    case RunFunnelReportRequest_FunnelVisualizationType.FUNNEL_VISUALIZATION_TYPE_UNSPECIFIED:
      return "FUNNEL_VISUALIZATION_TYPE_UNSPECIFIED";
    case RunFunnelReportRequest_FunnelVisualizationType.STANDARD_FUNNEL:
      return "STANDARD_FUNNEL";
    case RunFunnelReportRequest_FunnelVisualizationType.TRENDED_FUNNEL:
      return "TRENDED_FUNNEL";
    case RunFunnelReportRequest_FunnelVisualizationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The funnel report response contains two sub reports. The two sub reports are
 * different combinations of dimensions and metrics.
 */
export interface RunFunnelReportResponse {
  /**
   * The funnel table is a report with the funnel step, segment, breakdown
   * dimension, active users, completion rate, abandonments, and abandonments
   * rate.
   *
   * The segment dimension is only present in this response if a segment was
   * requested. The breakdown dimension is only present in this response if it
   * was requested.
   */
  funnelTable:
    | FunnelSubReport
    | undefined;
  /**
   * The funnel visualization is a report with the funnel step, segment, date,
   * next action dimension, and active users.
   *
   * The segment dimension is only present in this response if a segment was
   * requested. The date dimension is only present in this response if it was
   * requested through the `TRENDED_FUNNEL` funnel type. The next action
   * dimension is only present in the response if it was requested.
   */
  funnelVisualization:
    | FunnelSubReport
    | undefined;
  /** This Analytics Property's quota state including this request. */
  propertyQuota:
    | PropertyQuota
    | undefined;
  /**
   * Identifies what kind of resource this message is. This `kind` is always the
   * fixed string "analyticsData#runFunnelReport". Useful to distinguish between
   * response types in JSON.
   */
  kind: string;
}

/** A specific report task configuration. */
export interface ReportTask {
  /**
   * Output only. Identifier. The report task resource name assigned during
   * creation. Format: "properties/{property}/reportTasks/{report_task}"
   */
  name: string;
  /**
   * Optional. A report definition to fetch report data, which describes the
   * structure of a report. It typically includes the fields that will be
   * included in the report and the criteria that will be used to filter the
   * data.
   */
  reportDefinition:
    | ReportTask_ReportDefinition
    | undefined;
  /**
   * Output only. The report metadata for a specific report task, which provides
   * information about a report.  It typically includes the following
   * information: the resource name of the report, the state of the report, the
   * timestamp the report was created, etc,
   */
  reportMetadata: ReportTask_ReportMetadata | undefined;
}

/** The definition of how a report should be run. */
export interface ReportTask_ReportDefinition {
  /** Optional. The dimensions requested and displayed. */
  dimensions: Dimension[];
  /** Optional. The metrics requested and displayed. */
  metrics: Metric[];
  /**
   * Optional. Date ranges of data to read. If multiple date ranges are
   * requested, each response row will contain a zero based date range index.
   * If two date ranges overlap, the event data for the overlapping days is
   * included in the response rows for both date ranges. In a cohort request,
   * this `dateRanges` must be unspecified.
   */
  dateRanges: DateRange[];
  /**
   * Optional. Dimension filters let you ask for only specific dimension
   * values in the report. To learn more, see [Fundamentals of Dimension
   * Filters](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#dimension_filters)
   * for examples. Metrics cannot be used in this filter.
   */
  dimensionFilter:
    | FilterExpression
    | undefined;
  /**
   * Optional. The filter clause of metrics. Applied after aggregating the
   * report's rows, similar to SQL having-clause. Dimensions cannot be used in
   * this filter.
   */
  metricFilter:
    | FilterExpression
    | undefined;
  /**
   * Optional. The row count of the start row from Google Analytics Storage.
   * The first row is counted as row 0.
   *
   * When creating a report task, the `offset` and `limit` parameters define
   * the subset of data rows from Google Analytics storage to be included in
   * the generated report. For example, if there are a total of 300,000 rows
   * in Google Analytics storage, the initial report task may have the
   * first 10,000 rows with a limit of 10,000 and an offset of 0.
   * Subsequently, another report task could cover the next 10,000 rows with a
   * limit of 10,000 and an offset of 10,000.
   */
  offset: Long;
  /**
   * Optional. The number of rows to return in the Report. If unspecified,
   * 10,000 rows are returned. The API returns a maximum of 250,000 rows per
   * request, no matter how many you ask for. `limit` must be positive.
   *
   * The API can also return fewer rows than the requested `limit`, if there
   * aren't as many dimension values as the `limit`. For instance, there are
   * fewer than 300 possible values for the dimension `country`, so when
   * reporting on only `country`, you can't get more than 300 rows, even if
   * you set `limit` to a higher value.
   */
  limit: Long;
  /**
   * Optional. Aggregation of metrics. Aggregated metric values will be shown
   * in rows where the dimension_values are set to
   * "RESERVED_(MetricAggregation)".
   */
  metricAggregations: MetricAggregation[];
  /** Optional. Specifies how rows are ordered in the response. */
  orderBys: OrderBy[];
  /**
   * Optional. A currency code in ISO4217 format, such as "AED", "USD", "JPY".
   * If the field is empty, the report uses the property's default currency.
   */
  currencyCode: string;
  /**
   * Optional. Cohort group associated with this request. If there is a cohort
   * group in the request the 'cohort' dimension must be present.
   */
  cohortSpec:
    | CohortSpec
    | undefined;
  /**
   * Optional. If false or unspecified, each row with all metrics equal to 0
   * will not be returned. If true, these rows will be returned if they are
   * not separately removed by a filter.
   *
   * Regardless of this `keep_empty_rows` setting, only data recorded by the
   * Google Analytics property can be displayed in a report.
   *
   * For example if a property never logs a `purchase` event, then a query for
   * the `eventName` dimension and  `eventCount` metric will not have a row
   * containing eventName: "purchase" and eventCount: 0.
   */
  keepEmptyRows: boolean;
}

/** The report metadata for a specific report task. */
export interface ReportTask_ReportMetadata {
  /** Output only. The current state for this report task. */
  state?:
    | ReportTask_ReportMetadata_State
    | undefined;
  /**
   * Output only. The time when `CreateReportTask` was called and the report
   * began the `CREATING` state.
   */
  beginCreatingTime?:
    | Date
    | undefined;
  /**
   * Output only. The total quota tokens charged during creation of the
   * report. Because this token count is based on activity from the `CREATING`
   * state, this tokens charge will be fixed once a report task enters the
   * `ACTIVE` or `FAILED` state.
   */
  creationQuotaTokensCharged: number;
  /**
   * Output only. The total number of rows in the report result. This field
   * will be populated when the state is active. You can utilize
   * `task_row_count` for pagination within the confines of their existing
   * report.
   */
  taskRowCount?:
    | number
    | undefined;
  /**
   * Output only. Error message is populated if a report task fails during
   * creation.
   */
  errorMessage?:
    | string
    | undefined;
  /**
   * Output only. The total number of rows in Google Analytics storage. If you
   * want to query additional data rows beyond the current report, they can
   * initiate a new report task based on the `total_row_count`.
   *
   * The `task_row_count` represents the number of rows specifically
   * pertaining to the current report, whereas `total_row_count` encompasses
   * the total count of rows across all data retrieved from Google
   * Analytics storage.
   *
   * For example, suppose the current report's `task_row_count` is 20,
   * displaying the data from the first 20 rows. Simultaneously, the
   * `total_row_count` is 30, indicating the presence of data for all 30 rows.
   * The `task_row_count` can be utilizated to paginate through the initial 20
   * rows. To expand the report and include data from all 30 rows, a new
   * report task can be created using the total_row_count to access the full
   * set of 30 rows' worth of data.
   */
  totalRowCount?: number | undefined;
}

/** The processing state. */
export enum ReportTask_ReportMetadata_State {
  /** STATE_UNSPECIFIED - Unspecified state will never be used. */
  STATE_UNSPECIFIED = 0,
  /**
   * CREATING - The report is currently creating and will be available in the
   * future. Creating occurs immediately after the CreateReport call.
   */
  CREATING = 1,
  /** ACTIVE - The report is fully created and ready for querying. */
  ACTIVE = 2,
  /** FAILED - The report failed to be created. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function reportTask_ReportMetadata_StateFromJSON(object: any): ReportTask_ReportMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ReportTask_ReportMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return ReportTask_ReportMetadata_State.CREATING;
    case 2:
    case "ACTIVE":
      return ReportTask_ReportMetadata_State.ACTIVE;
    case 3:
    case "FAILED":
      return ReportTask_ReportMetadata_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReportTask_ReportMetadata_State.UNRECOGNIZED;
  }
}

export function reportTask_ReportMetadata_StateToJSON(object: ReportTask_ReportMetadata_State): string {
  switch (object) {
    case ReportTask_ReportMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ReportTask_ReportMetadata_State.CREATING:
      return "CREATING";
    case ReportTask_ReportMetadata_State.ACTIVE:
      return "ACTIVE";
    case ReportTask_ReportMetadata_State.FAILED:
      return "FAILED";
    case ReportTask_ReportMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A request to create a report task. */
export interface CreateReportTaskRequest {
  /**
   * Required. The parent resource where this report task will be created.
   * Format: `properties/{propertyId}`
   */
  parent: string;
  /** Required. The report task configuration to create. */
  reportTask: ReportTask | undefined;
}

/**
 * Represents the metadata of a long-running operation. Currently, this metadata
 * is blank.
 */
export interface ReportTaskMetadata {
}

/** A request to fetch the report content for a report task. */
export interface QueryReportTaskRequest {
  /**
   * Required. The report source name.
   * Format: `properties/{property}/reportTasks/{report}`
   */
  name: string;
  /**
   * Optional. The row count of the start row in the report. The first row is
   * counted as row 0.
   *
   * When paging, the first request does not specify offset; or equivalently,
   * sets offset to 0; the first request returns the first `limit` of rows. The
   * second request sets offset to the `limit` of the first request; the second
   * request returns the second `limit` of rows.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  offset: Long;
  /**
   * Optional. The number of rows to return from the report. If unspecified,
   * 10,000 rows are returned. The API returns a maximum of 250,000 rows per
   * request, no matter how many you ask for. `limit` must be positive.
   *
   * The API can also return fewer rows than the requested `limit`, if there
   * aren't as many dimension values as the `limit`. The number of rows
   * available to a QueryReportTaskRequest is further limited by the limit of
   * the associated ReportTask. A query can retrieve at most ReportTask.limit
   * rows. For example, if the ReportTask has a limit of 1,000, then a
   * QueryReportTask request with offset=900 and limit=500 will return at most
   * 100 rows.
   *
   * To learn more about this pagination parameter, see
   * [Pagination](https://developers.google.com/analytics/devguides/reporting/data/v1/basics#pagination).
   */
  limit: Long;
}

/** The report content corresponding to a report task. */
export interface QueryReportTaskResponse {
  /**
   * Describes dimension columns. The number of DimensionHeaders and ordering of
   * DimensionHeaders matches the dimensions present in rows.
   */
  dimensionHeaders: DimensionHeader[];
  /**
   * Describes metric columns. The number of MetricHeaders and ordering of
   * MetricHeaders matches the metrics present in rows.
   */
  metricHeaders: MetricHeader[];
  /** Rows of dimension value combinations and metric values in the report. */
  rows: Row[];
  /** If requested, the totaled values of metrics. */
  totals: Row[];
  /** If requested, the maximum values of metrics. */
  maximums: Row[];
  /** If requested, the minimum values of metrics. */
  minimums: Row[];
  /** The total number of rows in the query result. */
  rowCount: number;
  /** Metadata for the report. */
  metadata: ResponseMetaData | undefined;
}

/** A request to retrieve configuration metadata about a specific report task. */
export interface GetReportTaskRequest {
  /**
   * Required. The report task resource name.
   * Format: `properties/{property}/reportTasks/{report_task}`
   */
  name: string;
}

/** A request to list all report tasks for a property. */
export interface ListReportTasksRequest {
  /**
   * Required. All report tasks for this property will be listed in the
   * response. Format: `properties/{property}`
   */
  parent: string;
  /** Optional. The maximum number of report tasks to return. */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListReportTasks` call.
   * Provide this to retrieve the subsequent page.
   */
  pageToken: string;
}

/** A list of all report tasks for a property. */
export interface ListReportTasksResponse {
  /** Each report task for a property. */
  reportTasks: ReportTask[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken?: string | undefined;
}

function createBaseCreateRecurringAudienceListRequest(): CreateRecurringAudienceListRequest {
  return { parent: "", recurringAudienceList: undefined };
}

export const CreateRecurringAudienceListRequest: MessageFns<CreateRecurringAudienceListRequest> = {
  encode(message: CreateRecurringAudienceListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.recurringAudienceList !== undefined) {
      RecurringAudienceList.encode(message.recurringAudienceList, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRecurringAudienceListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRecurringAudienceListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.recurringAudienceList = RecurringAudienceList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRecurringAudienceListRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      recurringAudienceList: isSet(object.recurringAudienceList)
        ? RecurringAudienceList.fromJSON(object.recurringAudienceList)
        : undefined,
    };
  },

  toJSON(message: CreateRecurringAudienceListRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.recurringAudienceList !== undefined) {
      obj.recurringAudienceList = RecurringAudienceList.toJSON(message.recurringAudienceList);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRecurringAudienceListRequest>): CreateRecurringAudienceListRequest {
    return CreateRecurringAudienceListRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRecurringAudienceListRequest>): CreateRecurringAudienceListRequest {
    const message = createBaseCreateRecurringAudienceListRequest();
    message.parent = object.parent ?? "";
    message.recurringAudienceList =
      (object.recurringAudienceList !== undefined && object.recurringAudienceList !== null)
        ? RecurringAudienceList.fromPartial(object.recurringAudienceList)
        : undefined;
    return message;
  },
};

function createBaseRecurringAudienceList(): RecurringAudienceList {
  return {
    name: "",
    audience: "",
    audienceDisplayName: "",
    dimensions: [],
    activeDaysRemaining: undefined,
    audienceLists: [],
    webhookNotification: undefined,
  };
}

export const RecurringAudienceList: MessageFns<RecurringAudienceList> = {
  encode(message: RecurringAudienceList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.audience !== "") {
      writer.uint32(18).string(message.audience);
    }
    if (message.audienceDisplayName !== "") {
      writer.uint32(26).string(message.audienceDisplayName);
    }
    for (const v of message.dimensions) {
      AudienceDimension.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.activeDaysRemaining !== undefined) {
      writer.uint32(40).int32(message.activeDaysRemaining);
    }
    for (const v of message.audienceLists) {
      writer.uint32(50).string(v!);
    }
    if (message.webhookNotification !== undefined) {
      WebhookNotification.encode(message.webhookNotification, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecurringAudienceList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecurringAudienceList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audience = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.audienceDisplayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dimensions.push(AudienceDimension.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.activeDaysRemaining = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.audienceLists.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.webhookNotification = WebhookNotification.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecurringAudienceList {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
      audienceDisplayName: isSet(object.audienceDisplayName) ? globalThis.String(object.audienceDisplayName) : "",
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => AudienceDimension.fromJSON(e))
        : [],
      activeDaysRemaining: isSet(object.activeDaysRemaining)
        ? globalThis.Number(object.activeDaysRemaining)
        : undefined,
      audienceLists: globalThis.Array.isArray(object?.audienceLists)
        ? object.audienceLists.map((e: any) => globalThis.String(e))
        : [],
      webhookNotification: isSet(object.webhookNotification)
        ? WebhookNotification.fromJSON(object.webhookNotification)
        : undefined,
    };
  },

  toJSON(message: RecurringAudienceList): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    if (message.audienceDisplayName !== "") {
      obj.audienceDisplayName = message.audienceDisplayName;
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => AudienceDimension.toJSON(e));
    }
    if (message.activeDaysRemaining !== undefined) {
      obj.activeDaysRemaining = Math.round(message.activeDaysRemaining);
    }
    if (message.audienceLists?.length) {
      obj.audienceLists = message.audienceLists;
    }
    if (message.webhookNotification !== undefined) {
      obj.webhookNotification = WebhookNotification.toJSON(message.webhookNotification);
    }
    return obj;
  },

  create(base?: DeepPartial<RecurringAudienceList>): RecurringAudienceList {
    return RecurringAudienceList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecurringAudienceList>): RecurringAudienceList {
    const message = createBaseRecurringAudienceList();
    message.name = object.name ?? "";
    message.audience = object.audience ?? "";
    message.audienceDisplayName = object.audienceDisplayName ?? "";
    message.dimensions = object.dimensions?.map((e) => AudienceDimension.fromPartial(e)) || [];
    message.activeDaysRemaining = object.activeDaysRemaining ?? undefined;
    message.audienceLists = object.audienceLists?.map((e) => e) || [];
    message.webhookNotification = (object.webhookNotification !== undefined && object.webhookNotification !== null)
      ? WebhookNotification.fromPartial(object.webhookNotification)
      : undefined;
    return message;
  },
};

function createBaseWebhookNotification(): WebhookNotification {
  return { uri: undefined, channelToken: undefined };
}

export const WebhookNotification: MessageFns<WebhookNotification> = {
  encode(message: WebhookNotification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== undefined) {
      writer.uint32(10).string(message.uri);
    }
    if (message.channelToken !== undefined) {
      writer.uint32(18).string(message.channelToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WebhookNotification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebhookNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.channelToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebhookNotification {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
      channelToken: isSet(object.channelToken) ? globalThis.String(object.channelToken) : undefined,
    };
  },

  toJSON(message: WebhookNotification): unknown {
    const obj: any = {};
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.channelToken !== undefined) {
      obj.channelToken = message.channelToken;
    }
    return obj;
  },

  create(base?: DeepPartial<WebhookNotification>): WebhookNotification {
    return WebhookNotification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WebhookNotification>): WebhookNotification {
    const message = createBaseWebhookNotification();
    message.uri = object.uri ?? undefined;
    message.channelToken = object.channelToken ?? undefined;
    return message;
  },
};

function createBaseGetRecurringAudienceListRequest(): GetRecurringAudienceListRequest {
  return { name: "" };
}

export const GetRecurringAudienceListRequest: MessageFns<GetRecurringAudienceListRequest> = {
  encode(message: GetRecurringAudienceListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRecurringAudienceListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRecurringAudienceListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRecurringAudienceListRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRecurringAudienceListRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRecurringAudienceListRequest>): GetRecurringAudienceListRequest {
    return GetRecurringAudienceListRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRecurringAudienceListRequest>): GetRecurringAudienceListRequest {
    const message = createBaseGetRecurringAudienceListRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListRecurringAudienceListsRequest(): ListRecurringAudienceListsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListRecurringAudienceListsRequest: MessageFns<ListRecurringAudienceListsRequest> = {
  encode(message: ListRecurringAudienceListsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecurringAudienceListsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecurringAudienceListsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecurringAudienceListsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListRecurringAudienceListsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRecurringAudienceListsRequest>): ListRecurringAudienceListsRequest {
    return ListRecurringAudienceListsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRecurringAudienceListsRequest>): ListRecurringAudienceListsRequest {
    const message = createBaseListRecurringAudienceListsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListRecurringAudienceListsResponse(): ListRecurringAudienceListsResponse {
  return { recurringAudienceLists: [], nextPageToken: undefined };
}

export const ListRecurringAudienceListsResponse: MessageFns<ListRecurringAudienceListsResponse> = {
  encode(message: ListRecurringAudienceListsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.recurringAudienceLists) {
      RecurringAudienceList.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== undefined) {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecurringAudienceListsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecurringAudienceListsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.recurringAudienceLists.push(RecurringAudienceList.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecurringAudienceListsResponse {
    return {
      recurringAudienceLists: globalThis.Array.isArray(object?.recurringAudienceLists)
        ? object.recurringAudienceLists.map((e: any) => RecurringAudienceList.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : undefined,
    };
  },

  toJSON(message: ListRecurringAudienceListsResponse): unknown {
    const obj: any = {};
    if (message.recurringAudienceLists?.length) {
      obj.recurringAudienceLists = message.recurringAudienceLists.map((e) => RecurringAudienceList.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRecurringAudienceListsResponse>): ListRecurringAudienceListsResponse {
    return ListRecurringAudienceListsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRecurringAudienceListsResponse>): ListRecurringAudienceListsResponse {
    const message = createBaseListRecurringAudienceListsResponse();
    message.recurringAudienceLists = object.recurringAudienceLists?.map((e) => RecurringAudienceList.fromPartial(e)) ||
      [];
    message.nextPageToken = object.nextPageToken ?? undefined;
    return message;
  },
};

function createBaseGetPropertyQuotasSnapshotRequest(): GetPropertyQuotasSnapshotRequest {
  return { name: "" };
}

export const GetPropertyQuotasSnapshotRequest: MessageFns<GetPropertyQuotasSnapshotRequest> = {
  encode(message: GetPropertyQuotasSnapshotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPropertyQuotasSnapshotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPropertyQuotasSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPropertyQuotasSnapshotRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetPropertyQuotasSnapshotRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPropertyQuotasSnapshotRequest>): GetPropertyQuotasSnapshotRequest {
    return GetPropertyQuotasSnapshotRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPropertyQuotasSnapshotRequest>): GetPropertyQuotasSnapshotRequest {
    const message = createBaseGetPropertyQuotasSnapshotRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePropertyQuotasSnapshot(): PropertyQuotasSnapshot {
  return { name: "", corePropertyQuota: undefined, realtimePropertyQuota: undefined, funnelPropertyQuota: undefined };
}

export const PropertyQuotasSnapshot: MessageFns<PropertyQuotasSnapshot> = {
  encode(message: PropertyQuotasSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.corePropertyQuota !== undefined) {
      PropertyQuota.encode(message.corePropertyQuota, writer.uint32(10).fork()).join();
    }
    if (message.realtimePropertyQuota !== undefined) {
      PropertyQuota.encode(message.realtimePropertyQuota, writer.uint32(18).fork()).join();
    }
    if (message.funnelPropertyQuota !== undefined) {
      PropertyQuota.encode(message.funnelPropertyQuota, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropertyQuotasSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertyQuotasSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.corePropertyQuota = PropertyQuota.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.realtimePropertyQuota = PropertyQuota.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.funnelPropertyQuota = PropertyQuota.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertyQuotasSnapshot {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      corePropertyQuota: isSet(object.corePropertyQuota) ? PropertyQuota.fromJSON(object.corePropertyQuota) : undefined,
      realtimePropertyQuota: isSet(object.realtimePropertyQuota)
        ? PropertyQuota.fromJSON(object.realtimePropertyQuota)
        : undefined,
      funnelPropertyQuota: isSet(object.funnelPropertyQuota)
        ? PropertyQuota.fromJSON(object.funnelPropertyQuota)
        : undefined,
    };
  },

  toJSON(message: PropertyQuotasSnapshot): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.corePropertyQuota !== undefined) {
      obj.corePropertyQuota = PropertyQuota.toJSON(message.corePropertyQuota);
    }
    if (message.realtimePropertyQuota !== undefined) {
      obj.realtimePropertyQuota = PropertyQuota.toJSON(message.realtimePropertyQuota);
    }
    if (message.funnelPropertyQuota !== undefined) {
      obj.funnelPropertyQuota = PropertyQuota.toJSON(message.funnelPropertyQuota);
    }
    return obj;
  },

  create(base?: DeepPartial<PropertyQuotasSnapshot>): PropertyQuotasSnapshot {
    return PropertyQuotasSnapshot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertyQuotasSnapshot>): PropertyQuotasSnapshot {
    const message = createBasePropertyQuotasSnapshot();
    message.name = object.name ?? "";
    message.corePropertyQuota = (object.corePropertyQuota !== undefined && object.corePropertyQuota !== null)
      ? PropertyQuota.fromPartial(object.corePropertyQuota)
      : undefined;
    message.realtimePropertyQuota =
      (object.realtimePropertyQuota !== undefined && object.realtimePropertyQuota !== null)
        ? PropertyQuota.fromPartial(object.realtimePropertyQuota)
        : undefined;
    message.funnelPropertyQuota = (object.funnelPropertyQuota !== undefined && object.funnelPropertyQuota !== null)
      ? PropertyQuota.fromPartial(object.funnelPropertyQuota)
      : undefined;
    return message;
  },
};

function createBaseGetAudienceListRequest(): GetAudienceListRequest {
  return { name: "" };
}

export const GetAudienceListRequest: MessageFns<GetAudienceListRequest> = {
  encode(message: GetAudienceListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAudienceListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAudienceListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAudienceListRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAudienceListRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAudienceListRequest>): GetAudienceListRequest {
    return GetAudienceListRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAudienceListRequest>): GetAudienceListRequest {
    const message = createBaseGetAudienceListRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListAudienceListsRequest(): ListAudienceListsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListAudienceListsRequest: MessageFns<ListAudienceListsRequest> = {
  encode(message: ListAudienceListsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAudienceListsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAudienceListsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAudienceListsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListAudienceListsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAudienceListsRequest>): ListAudienceListsRequest {
    return ListAudienceListsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAudienceListsRequest>): ListAudienceListsRequest {
    const message = createBaseListAudienceListsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListAudienceListsResponse(): ListAudienceListsResponse {
  return { audienceLists: [], nextPageToken: undefined };
}

export const ListAudienceListsResponse: MessageFns<ListAudienceListsResponse> = {
  encode(message: ListAudienceListsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.audienceLists) {
      AudienceList.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== undefined) {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAudienceListsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAudienceListsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audienceLists.push(AudienceList.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAudienceListsResponse {
    return {
      audienceLists: globalThis.Array.isArray(object?.audienceLists)
        ? object.audienceLists.map((e: any) => AudienceList.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : undefined,
    };
  },

  toJSON(message: ListAudienceListsResponse): unknown {
    const obj: any = {};
    if (message.audienceLists?.length) {
      obj.audienceLists = message.audienceLists.map((e) => AudienceList.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAudienceListsResponse>): ListAudienceListsResponse {
    return ListAudienceListsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAudienceListsResponse>): ListAudienceListsResponse {
    const message = createBaseListAudienceListsResponse();
    message.audienceLists = object.audienceLists?.map((e) => AudienceList.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? undefined;
    return message;
  },
};

function createBaseCreateAudienceListRequest(): CreateAudienceListRequest {
  return { parent: "", audienceList: undefined };
}

export const CreateAudienceListRequest: MessageFns<CreateAudienceListRequest> = {
  encode(message: CreateAudienceListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.audienceList !== undefined) {
      AudienceList.encode(message.audienceList, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAudienceListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAudienceListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audienceList = AudienceList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAudienceListRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      audienceList: isSet(object.audienceList) ? AudienceList.fromJSON(object.audienceList) : undefined,
    };
  },

  toJSON(message: CreateAudienceListRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.audienceList !== undefined) {
      obj.audienceList = AudienceList.toJSON(message.audienceList);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAudienceListRequest>): CreateAudienceListRequest {
    return CreateAudienceListRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAudienceListRequest>): CreateAudienceListRequest {
    const message = createBaseCreateAudienceListRequest();
    message.parent = object.parent ?? "";
    message.audienceList = (object.audienceList !== undefined && object.audienceList !== null)
      ? AudienceList.fromPartial(object.audienceList)
      : undefined;
    return message;
  },
};

function createBaseAudienceList(): AudienceList {
  return {
    name: "",
    audience: "",
    audienceDisplayName: "",
    dimensions: [],
    state: undefined,
    beginCreatingTime: undefined,
    creationQuotaTokensCharged: 0,
    rowCount: undefined,
    errorMessage: undefined,
    percentageCompleted: undefined,
    recurringAudienceList: undefined,
    webhookNotification: undefined,
  };
}

export const AudienceList: MessageFns<AudienceList> = {
  encode(message: AudienceList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.audience !== "") {
      writer.uint32(18).string(message.audience);
    }
    if (message.audienceDisplayName !== "") {
      writer.uint32(26).string(message.audienceDisplayName);
    }
    for (const v of message.dimensions) {
      AudienceDimension.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.state !== undefined) {
      writer.uint32(40).int32(message.state);
    }
    if (message.beginCreatingTime !== undefined) {
      Timestamp.encode(toTimestamp(message.beginCreatingTime), writer.uint32(50).fork()).join();
    }
    if (message.creationQuotaTokensCharged !== 0) {
      writer.uint32(56).int32(message.creationQuotaTokensCharged);
    }
    if (message.rowCount !== undefined) {
      writer.uint32(64).int32(message.rowCount);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(74).string(message.errorMessage);
    }
    if (message.percentageCompleted !== undefined) {
      writer.uint32(89).double(message.percentageCompleted);
    }
    if (message.recurringAudienceList !== undefined) {
      writer.uint32(98).string(message.recurringAudienceList);
    }
    if (message.webhookNotification !== undefined) {
      WebhookNotification.encode(message.webhookNotification, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audience = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.audienceDisplayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dimensions.push(AudienceDimension.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.beginCreatingTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.creationQuotaTokensCharged = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.rowCount = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.percentageCompleted = reader.double();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.recurringAudienceList = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.webhookNotification = WebhookNotification.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceList {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
      audienceDisplayName: isSet(object.audienceDisplayName) ? globalThis.String(object.audienceDisplayName) : "",
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => AudienceDimension.fromJSON(e))
        : [],
      state: isSet(object.state) ? audienceList_StateFromJSON(object.state) : undefined,
      beginCreatingTime: isSet(object.beginCreatingTime) ? fromJsonTimestamp(object.beginCreatingTime) : undefined,
      creationQuotaTokensCharged: isSet(object.creationQuotaTokensCharged)
        ? globalThis.Number(object.creationQuotaTokensCharged)
        : 0,
      rowCount: isSet(object.rowCount) ? globalThis.Number(object.rowCount) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
      percentageCompleted: isSet(object.percentageCompleted)
        ? globalThis.Number(object.percentageCompleted)
        : undefined,
      recurringAudienceList: isSet(object.recurringAudienceList)
        ? globalThis.String(object.recurringAudienceList)
        : undefined,
      webhookNotification: isSet(object.webhookNotification)
        ? WebhookNotification.fromJSON(object.webhookNotification)
        : undefined,
    };
  },

  toJSON(message: AudienceList): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    if (message.audienceDisplayName !== "") {
      obj.audienceDisplayName = message.audienceDisplayName;
    }
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => AudienceDimension.toJSON(e));
    }
    if (message.state !== undefined) {
      obj.state = audienceList_StateToJSON(message.state);
    }
    if (message.beginCreatingTime !== undefined) {
      obj.beginCreatingTime = message.beginCreatingTime.toISOString();
    }
    if (message.creationQuotaTokensCharged !== 0) {
      obj.creationQuotaTokensCharged = Math.round(message.creationQuotaTokensCharged);
    }
    if (message.rowCount !== undefined) {
      obj.rowCount = Math.round(message.rowCount);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.percentageCompleted !== undefined) {
      obj.percentageCompleted = message.percentageCompleted;
    }
    if (message.recurringAudienceList !== undefined) {
      obj.recurringAudienceList = message.recurringAudienceList;
    }
    if (message.webhookNotification !== undefined) {
      obj.webhookNotification = WebhookNotification.toJSON(message.webhookNotification);
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceList>): AudienceList {
    return AudienceList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceList>): AudienceList {
    const message = createBaseAudienceList();
    message.name = object.name ?? "";
    message.audience = object.audience ?? "";
    message.audienceDisplayName = object.audienceDisplayName ?? "";
    message.dimensions = object.dimensions?.map((e) => AudienceDimension.fromPartial(e)) || [];
    message.state = object.state ?? undefined;
    message.beginCreatingTime = object.beginCreatingTime ?? undefined;
    message.creationQuotaTokensCharged = object.creationQuotaTokensCharged ?? 0;
    message.rowCount = object.rowCount ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.percentageCompleted = object.percentageCompleted ?? undefined;
    message.recurringAudienceList = object.recurringAudienceList ?? undefined;
    message.webhookNotification = (object.webhookNotification !== undefined && object.webhookNotification !== null)
      ? WebhookNotification.fromPartial(object.webhookNotification)
      : undefined;
    return message;
  },
};

function createBaseAudienceListMetadata(): AudienceListMetadata {
  return {};
}

export const AudienceListMetadata: MessageFns<AudienceListMetadata> = {
  encode(_: AudienceListMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceListMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceListMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AudienceListMetadata {
    return {};
  },

  toJSON(_: AudienceListMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AudienceListMetadata>): AudienceListMetadata {
    return AudienceListMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AudienceListMetadata>): AudienceListMetadata {
    const message = createBaseAudienceListMetadata();
    return message;
  },
};

function createBaseQueryAudienceListRequest(): QueryAudienceListRequest {
  return { name: "", offset: Long.ZERO, limit: Long.ZERO };
}

export const QueryAudienceListRequest: MessageFns<QueryAudienceListRequest> = {
  encode(message: QueryAudienceListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.offset.toString());
    }
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.limit.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAudienceListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAudienceListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAudienceListRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
    };
  },

  toJSON(message: QueryAudienceListRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAudienceListRequest>): QueryAudienceListRequest {
    return QueryAudienceListRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryAudienceListRequest>): QueryAudienceListRequest {
    const message = createBaseQueryAudienceListRequest();
    message.name = object.name ?? "";
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    return message;
  },
};

function createBaseQueryAudienceListResponse(): QueryAudienceListResponse {
  return { audienceList: undefined, audienceRows: [], rowCount: undefined };
}

export const QueryAudienceListResponse: MessageFns<QueryAudienceListResponse> = {
  encode(message: QueryAudienceListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audienceList !== undefined) {
      AudienceList.encode(message.audienceList, writer.uint32(10).fork()).join();
    }
    for (const v of message.audienceRows) {
      AudienceRow.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.rowCount !== undefined) {
      writer.uint32(24).int32(message.rowCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAudienceListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAudienceListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audienceList = AudienceList.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audienceRows.push(AudienceRow.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rowCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAudienceListResponse {
    return {
      audienceList: isSet(object.audienceList) ? AudienceList.fromJSON(object.audienceList) : undefined,
      audienceRows: globalThis.Array.isArray(object?.audienceRows)
        ? object.audienceRows.map((e: any) => AudienceRow.fromJSON(e))
        : [],
      rowCount: isSet(object.rowCount) ? globalThis.Number(object.rowCount) : undefined,
    };
  },

  toJSON(message: QueryAudienceListResponse): unknown {
    const obj: any = {};
    if (message.audienceList !== undefined) {
      obj.audienceList = AudienceList.toJSON(message.audienceList);
    }
    if (message.audienceRows?.length) {
      obj.audienceRows = message.audienceRows.map((e) => AudienceRow.toJSON(e));
    }
    if (message.rowCount !== undefined) {
      obj.rowCount = Math.round(message.rowCount);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryAudienceListResponse>): QueryAudienceListResponse {
    return QueryAudienceListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryAudienceListResponse>): QueryAudienceListResponse {
    const message = createBaseQueryAudienceListResponse();
    message.audienceList = (object.audienceList !== undefined && object.audienceList !== null)
      ? AudienceList.fromPartial(object.audienceList)
      : undefined;
    message.audienceRows = object.audienceRows?.map((e) => AudienceRow.fromPartial(e)) || [];
    message.rowCount = object.rowCount ?? undefined;
    return message;
  },
};

function createBaseSheetExportAudienceListRequest(): SheetExportAudienceListRequest {
  return { name: "", offset: Long.ZERO, limit: Long.ZERO };
}

export const SheetExportAudienceListRequest: MessageFns<SheetExportAudienceListRequest> = {
  encode(message: SheetExportAudienceListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.offset.toString());
    }
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.limit.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SheetExportAudienceListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSheetExportAudienceListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SheetExportAudienceListRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
    };
  },

  toJSON(message: SheetExportAudienceListRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SheetExportAudienceListRequest>): SheetExportAudienceListRequest {
    return SheetExportAudienceListRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SheetExportAudienceListRequest>): SheetExportAudienceListRequest {
    const message = createBaseSheetExportAudienceListRequest();
    message.name = object.name ?? "";
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    return message;
  },
};

function createBaseSheetExportAudienceListResponse(): SheetExportAudienceListResponse {
  return { spreadsheetUri: undefined, spreadsheetId: undefined, rowCount: undefined, audienceList: undefined };
}

export const SheetExportAudienceListResponse: MessageFns<SheetExportAudienceListResponse> = {
  encode(message: SheetExportAudienceListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.spreadsheetUri !== undefined) {
      writer.uint32(10).string(message.spreadsheetUri);
    }
    if (message.spreadsheetId !== undefined) {
      writer.uint32(18).string(message.spreadsheetId);
    }
    if (message.rowCount !== undefined) {
      writer.uint32(24).int32(message.rowCount);
    }
    if (message.audienceList !== undefined) {
      AudienceList.encode(message.audienceList, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SheetExportAudienceListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSheetExportAudienceListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.spreadsheetUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spreadsheetId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rowCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.audienceList = AudienceList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SheetExportAudienceListResponse {
    return {
      spreadsheetUri: isSet(object.spreadsheetUri) ? globalThis.String(object.spreadsheetUri) : undefined,
      spreadsheetId: isSet(object.spreadsheetId) ? globalThis.String(object.spreadsheetId) : undefined,
      rowCount: isSet(object.rowCount) ? globalThis.Number(object.rowCount) : undefined,
      audienceList: isSet(object.audienceList) ? AudienceList.fromJSON(object.audienceList) : undefined,
    };
  },

  toJSON(message: SheetExportAudienceListResponse): unknown {
    const obj: any = {};
    if (message.spreadsheetUri !== undefined) {
      obj.spreadsheetUri = message.spreadsheetUri;
    }
    if (message.spreadsheetId !== undefined) {
      obj.spreadsheetId = message.spreadsheetId;
    }
    if (message.rowCount !== undefined) {
      obj.rowCount = Math.round(message.rowCount);
    }
    if (message.audienceList !== undefined) {
      obj.audienceList = AudienceList.toJSON(message.audienceList);
    }
    return obj;
  },

  create(base?: DeepPartial<SheetExportAudienceListResponse>): SheetExportAudienceListResponse {
    return SheetExportAudienceListResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SheetExportAudienceListResponse>): SheetExportAudienceListResponse {
    const message = createBaseSheetExportAudienceListResponse();
    message.spreadsheetUri = object.spreadsheetUri ?? undefined;
    message.spreadsheetId = object.spreadsheetId ?? undefined;
    message.rowCount = object.rowCount ?? undefined;
    message.audienceList = (object.audienceList !== undefined && object.audienceList !== null)
      ? AudienceList.fromPartial(object.audienceList)
      : undefined;
    return message;
  },
};

function createBaseAudienceRow(): AudienceRow {
  return { dimensionValues: [] };
}

export const AudienceRow: MessageFns<AudienceRow> = {
  encode(message: AudienceRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensionValues) {
      AudienceDimensionValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionValues.push(AudienceDimensionValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceRow {
    return {
      dimensionValues: globalThis.Array.isArray(object?.dimensionValues)
        ? object.dimensionValues.map((e: any) => AudienceDimensionValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AudienceRow): unknown {
    const obj: any = {};
    if (message.dimensionValues?.length) {
      obj.dimensionValues = message.dimensionValues.map((e) => AudienceDimensionValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceRow>): AudienceRow {
    return AudienceRow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceRow>): AudienceRow {
    const message = createBaseAudienceRow();
    message.dimensionValues = object.dimensionValues?.map((e) => AudienceDimensionValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAudienceDimension(): AudienceDimension {
  return { dimensionName: "" };
}

export const AudienceDimension: MessageFns<AudienceDimension> = {
  encode(message: AudienceDimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dimensionName !== "") {
      writer.uint32(10).string(message.dimensionName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceDimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceDimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceDimension {
    return { dimensionName: isSet(object.dimensionName) ? globalThis.String(object.dimensionName) : "" };
  },

  toJSON(message: AudienceDimension): unknown {
    const obj: any = {};
    if (message.dimensionName !== "") {
      obj.dimensionName = message.dimensionName;
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceDimension>): AudienceDimension {
    return AudienceDimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceDimension>): AudienceDimension {
    const message = createBaseAudienceDimension();
    message.dimensionName = object.dimensionName ?? "";
    return message;
  },
};

function createBaseAudienceDimensionValue(): AudienceDimensionValue {
  return { value: undefined };
}

export const AudienceDimensionValue: MessageFns<AudienceDimensionValue> = {
  encode(message: AudienceDimensionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AudienceDimensionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAudienceDimensionValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AudienceDimensionValue {
    return { value: isSet(object.value) ? globalThis.String(object.value) : undefined };
  },

  toJSON(message: AudienceDimensionValue): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AudienceDimensionValue>): AudienceDimensionValue {
    return AudienceDimensionValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AudienceDimensionValue>): AudienceDimensionValue {
    const message = createBaseAudienceDimensionValue();
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseRunFunnelReportRequest(): RunFunnelReportRequest {
  return {
    property: "",
    dateRanges: [],
    funnel: undefined,
    funnelBreakdown: undefined,
    funnelNextAction: undefined,
    funnelVisualizationType: 0,
    segments: [],
    limit: Long.ZERO,
    dimensionFilter: undefined,
    returnPropertyQuota: false,
  };
}

export const RunFunnelReportRequest: MessageFns<RunFunnelReportRequest> = {
  encode(message: RunFunnelReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== "") {
      writer.uint32(10).string(message.property);
    }
    for (const v of message.dateRanges) {
      DateRange.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.funnel !== undefined) {
      Funnel.encode(message.funnel, writer.uint32(26).fork()).join();
    }
    if (message.funnelBreakdown !== undefined) {
      FunnelBreakdown.encode(message.funnelBreakdown, writer.uint32(34).fork()).join();
    }
    if (message.funnelNextAction !== undefined) {
      FunnelNextAction.encode(message.funnelNextAction, writer.uint32(42).fork()).join();
    }
    if (message.funnelVisualizationType !== 0) {
      writer.uint32(48).int32(message.funnelVisualizationType);
    }
    for (const v of message.segments) {
      Segment.encode(v!, writer.uint32(58).fork()).join();
    }
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.limit.toString());
    }
    if (message.dimensionFilter !== undefined) {
      FilterExpression.encode(message.dimensionFilter, writer.uint32(82).fork()).join();
    }
    if (message.returnPropertyQuota !== false) {
      writer.uint32(96).bool(message.returnPropertyQuota);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFunnelReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFunnelReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dateRanges.push(DateRange.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.funnel = Funnel.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.funnelBreakdown = FunnelBreakdown.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.funnelNextAction = FunnelNextAction.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.funnelVisualizationType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.segments.push(Segment.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.limit = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dimensionFilter = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.returnPropertyQuota = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunFunnelReportRequest {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      dateRanges: globalThis.Array.isArray(object?.dateRanges)
        ? object.dateRanges.map((e: any) => DateRange.fromJSON(e))
        : [],
      funnel: isSet(object.funnel) ? Funnel.fromJSON(object.funnel) : undefined,
      funnelBreakdown: isSet(object.funnelBreakdown) ? FunnelBreakdown.fromJSON(object.funnelBreakdown) : undefined,
      funnelNextAction: isSet(object.funnelNextAction) ? FunnelNextAction.fromJSON(object.funnelNextAction) : undefined,
      funnelVisualizationType: isSet(object.funnelVisualizationType)
        ? runFunnelReportRequest_FunnelVisualizationTypeFromJSON(object.funnelVisualizationType)
        : 0,
      segments: globalThis.Array.isArray(object?.segments) ? object.segments.map((e: any) => Segment.fromJSON(e)) : [],
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
      dimensionFilter: isSet(object.dimensionFilter) ? FilterExpression.fromJSON(object.dimensionFilter) : undefined,
      returnPropertyQuota: isSet(object.returnPropertyQuota) ? globalThis.Boolean(object.returnPropertyQuota) : false,
    };
  },

  toJSON(message: RunFunnelReportRequest): unknown {
    const obj: any = {};
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.dateRanges?.length) {
      obj.dateRanges = message.dateRanges.map((e) => DateRange.toJSON(e));
    }
    if (message.funnel !== undefined) {
      obj.funnel = Funnel.toJSON(message.funnel);
    }
    if (message.funnelBreakdown !== undefined) {
      obj.funnelBreakdown = FunnelBreakdown.toJSON(message.funnelBreakdown);
    }
    if (message.funnelNextAction !== undefined) {
      obj.funnelNextAction = FunnelNextAction.toJSON(message.funnelNextAction);
    }
    if (message.funnelVisualizationType !== 0) {
      obj.funnelVisualizationType = runFunnelReportRequest_FunnelVisualizationTypeToJSON(
        message.funnelVisualizationType,
      );
    }
    if (message.segments?.length) {
      obj.segments = message.segments.map((e) => Segment.toJSON(e));
    }
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    if (message.dimensionFilter !== undefined) {
      obj.dimensionFilter = FilterExpression.toJSON(message.dimensionFilter);
    }
    if (message.returnPropertyQuota !== false) {
      obj.returnPropertyQuota = message.returnPropertyQuota;
    }
    return obj;
  },

  create(base?: DeepPartial<RunFunnelReportRequest>): RunFunnelReportRequest {
    return RunFunnelReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunFunnelReportRequest>): RunFunnelReportRequest {
    const message = createBaseRunFunnelReportRequest();
    message.property = object.property ?? "";
    message.dateRanges = object.dateRanges?.map((e) => DateRange.fromPartial(e)) || [];
    message.funnel = (object.funnel !== undefined && object.funnel !== null)
      ? Funnel.fromPartial(object.funnel)
      : undefined;
    message.funnelBreakdown = (object.funnelBreakdown !== undefined && object.funnelBreakdown !== null)
      ? FunnelBreakdown.fromPartial(object.funnelBreakdown)
      : undefined;
    message.funnelNextAction = (object.funnelNextAction !== undefined && object.funnelNextAction !== null)
      ? FunnelNextAction.fromPartial(object.funnelNextAction)
      : undefined;
    message.funnelVisualizationType = object.funnelVisualizationType ?? 0;
    message.segments = object.segments?.map((e) => Segment.fromPartial(e)) || [];
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    message.dimensionFilter = (object.dimensionFilter !== undefined && object.dimensionFilter !== null)
      ? FilterExpression.fromPartial(object.dimensionFilter)
      : undefined;
    message.returnPropertyQuota = object.returnPropertyQuota ?? false;
    return message;
  },
};

function createBaseRunFunnelReportResponse(): RunFunnelReportResponse {
  return { funnelTable: undefined, funnelVisualization: undefined, propertyQuota: undefined, kind: "" };
}

export const RunFunnelReportResponse: MessageFns<RunFunnelReportResponse> = {
  encode(message: RunFunnelReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.funnelTable !== undefined) {
      FunnelSubReport.encode(message.funnelTable, writer.uint32(10).fork()).join();
    }
    if (message.funnelVisualization !== undefined) {
      FunnelSubReport.encode(message.funnelVisualization, writer.uint32(18).fork()).join();
    }
    if (message.propertyQuota !== undefined) {
      PropertyQuota.encode(message.propertyQuota, writer.uint32(26).fork()).join();
    }
    if (message.kind !== "") {
      writer.uint32(34).string(message.kind);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunFunnelReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunFunnelReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.funnelTable = FunnelSubReport.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.funnelVisualization = FunnelSubReport.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.propertyQuota = PropertyQuota.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.kind = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunFunnelReportResponse {
    return {
      funnelTable: isSet(object.funnelTable) ? FunnelSubReport.fromJSON(object.funnelTable) : undefined,
      funnelVisualization: isSet(object.funnelVisualization)
        ? FunnelSubReport.fromJSON(object.funnelVisualization)
        : undefined,
      propertyQuota: isSet(object.propertyQuota) ? PropertyQuota.fromJSON(object.propertyQuota) : undefined,
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
    };
  },

  toJSON(message: RunFunnelReportResponse): unknown {
    const obj: any = {};
    if (message.funnelTable !== undefined) {
      obj.funnelTable = FunnelSubReport.toJSON(message.funnelTable);
    }
    if (message.funnelVisualization !== undefined) {
      obj.funnelVisualization = FunnelSubReport.toJSON(message.funnelVisualization);
    }
    if (message.propertyQuota !== undefined) {
      obj.propertyQuota = PropertyQuota.toJSON(message.propertyQuota);
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    return obj;
  },

  create(base?: DeepPartial<RunFunnelReportResponse>): RunFunnelReportResponse {
    return RunFunnelReportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunFunnelReportResponse>): RunFunnelReportResponse {
    const message = createBaseRunFunnelReportResponse();
    message.funnelTable = (object.funnelTable !== undefined && object.funnelTable !== null)
      ? FunnelSubReport.fromPartial(object.funnelTable)
      : undefined;
    message.funnelVisualization = (object.funnelVisualization !== undefined && object.funnelVisualization !== null)
      ? FunnelSubReport.fromPartial(object.funnelVisualization)
      : undefined;
    message.propertyQuota = (object.propertyQuota !== undefined && object.propertyQuota !== null)
      ? PropertyQuota.fromPartial(object.propertyQuota)
      : undefined;
    message.kind = object.kind ?? "";
    return message;
  },
};

function createBaseReportTask(): ReportTask {
  return { name: "", reportDefinition: undefined, reportMetadata: undefined };
}

export const ReportTask: MessageFns<ReportTask> = {
  encode(message: ReportTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.reportDefinition !== undefined) {
      ReportTask_ReportDefinition.encode(message.reportDefinition, writer.uint32(18).fork()).join();
    }
    if (message.reportMetadata !== undefined) {
      ReportTask_ReportMetadata.encode(message.reportMetadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reportDefinition = ReportTask_ReportDefinition.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reportMetadata = ReportTask_ReportMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportTask {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      reportDefinition: isSet(object.reportDefinition)
        ? ReportTask_ReportDefinition.fromJSON(object.reportDefinition)
        : undefined,
      reportMetadata: isSet(object.reportMetadata)
        ? ReportTask_ReportMetadata.fromJSON(object.reportMetadata)
        : undefined,
    };
  },

  toJSON(message: ReportTask): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.reportDefinition !== undefined) {
      obj.reportDefinition = ReportTask_ReportDefinition.toJSON(message.reportDefinition);
    }
    if (message.reportMetadata !== undefined) {
      obj.reportMetadata = ReportTask_ReportMetadata.toJSON(message.reportMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<ReportTask>): ReportTask {
    return ReportTask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportTask>): ReportTask {
    const message = createBaseReportTask();
    message.name = object.name ?? "";
    message.reportDefinition = (object.reportDefinition !== undefined && object.reportDefinition !== null)
      ? ReportTask_ReportDefinition.fromPartial(object.reportDefinition)
      : undefined;
    message.reportMetadata = (object.reportMetadata !== undefined && object.reportMetadata !== null)
      ? ReportTask_ReportMetadata.fromPartial(object.reportMetadata)
      : undefined;
    return message;
  },
};

function createBaseReportTask_ReportDefinition(): ReportTask_ReportDefinition {
  return {
    dimensions: [],
    metrics: [],
    dateRanges: [],
    dimensionFilter: undefined,
    metricFilter: undefined,
    offset: Long.ZERO,
    limit: Long.ZERO,
    metricAggregations: [],
    orderBys: [],
    currencyCode: "",
    cohortSpec: undefined,
    keepEmptyRows: false,
  };
}

export const ReportTask_ReportDefinition: MessageFns<ReportTask_ReportDefinition> = {
  encode(message: ReportTask_ReportDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensions) {
      Dimension.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.metrics) {
      Metric.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.dateRanges) {
      DateRange.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.dimensionFilter !== undefined) {
      FilterExpression.encode(message.dimensionFilter, writer.uint32(42).fork()).join();
    }
    if (message.metricFilter !== undefined) {
      FilterExpression.encode(message.metricFilter, writer.uint32(50).fork()).join();
    }
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.offset.toString());
    }
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.limit.toString());
    }
    writer.uint32(74).fork();
    for (const v of message.metricAggregations) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.orderBys) {
      OrderBy.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.currencyCode !== "") {
      writer.uint32(90).string(message.currencyCode);
    }
    if (message.cohortSpec !== undefined) {
      CohortSpec.encode(message.cohortSpec, writer.uint32(98).fork()).join();
    }
    if (message.keepEmptyRows !== false) {
      writer.uint32(104).bool(message.keepEmptyRows);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportTask_ReportDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportTask_ReportDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimensions.push(Dimension.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metrics.push(Metric.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dateRanges.push(DateRange.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dimensionFilter = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metricFilter = FilterExpression.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.limit = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag === 72) {
            message.metricAggregations.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.metricAggregations.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.orderBys.push(OrderBy.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.cohortSpec = CohortSpec.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.keepEmptyRows = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportTask_ReportDefinition {
    return {
      dimensions: globalThis.Array.isArray(object?.dimensions)
        ? object.dimensions.map((e: any) => Dimension.fromJSON(e))
        : [],
      metrics: globalThis.Array.isArray(object?.metrics) ? object.metrics.map((e: any) => Metric.fromJSON(e)) : [],
      dateRanges: globalThis.Array.isArray(object?.dateRanges)
        ? object.dateRanges.map((e: any) => DateRange.fromJSON(e))
        : [],
      dimensionFilter: isSet(object.dimensionFilter) ? FilterExpression.fromJSON(object.dimensionFilter) : undefined,
      metricFilter: isSet(object.metricFilter) ? FilterExpression.fromJSON(object.metricFilter) : undefined,
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
      metricAggregations: globalThis.Array.isArray(object?.metricAggregations)
        ? object.metricAggregations.map((e: any) => metricAggregationFromJSON(e))
        : [],
      orderBys: globalThis.Array.isArray(object?.orderBys) ? object.orderBys.map((e: any) => OrderBy.fromJSON(e)) : [],
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      cohortSpec: isSet(object.cohortSpec) ? CohortSpec.fromJSON(object.cohortSpec) : undefined,
      keepEmptyRows: isSet(object.keepEmptyRows) ? globalThis.Boolean(object.keepEmptyRows) : false,
    };
  },

  toJSON(message: ReportTask_ReportDefinition): unknown {
    const obj: any = {};
    if (message.dimensions?.length) {
      obj.dimensions = message.dimensions.map((e) => Dimension.toJSON(e));
    }
    if (message.metrics?.length) {
      obj.metrics = message.metrics.map((e) => Metric.toJSON(e));
    }
    if (message.dateRanges?.length) {
      obj.dateRanges = message.dateRanges.map((e) => DateRange.toJSON(e));
    }
    if (message.dimensionFilter !== undefined) {
      obj.dimensionFilter = FilterExpression.toJSON(message.dimensionFilter);
    }
    if (message.metricFilter !== undefined) {
      obj.metricFilter = FilterExpression.toJSON(message.metricFilter);
    }
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    if (message.metricAggregations?.length) {
      obj.metricAggregations = message.metricAggregations.map((e) => metricAggregationToJSON(e));
    }
    if (message.orderBys?.length) {
      obj.orderBys = message.orderBys.map((e) => OrderBy.toJSON(e));
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.cohortSpec !== undefined) {
      obj.cohortSpec = CohortSpec.toJSON(message.cohortSpec);
    }
    if (message.keepEmptyRows !== false) {
      obj.keepEmptyRows = message.keepEmptyRows;
    }
    return obj;
  },

  create(base?: DeepPartial<ReportTask_ReportDefinition>): ReportTask_ReportDefinition {
    return ReportTask_ReportDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportTask_ReportDefinition>): ReportTask_ReportDefinition {
    const message = createBaseReportTask_ReportDefinition();
    message.dimensions = object.dimensions?.map((e) => Dimension.fromPartial(e)) || [];
    message.metrics = object.metrics?.map((e) => Metric.fromPartial(e)) || [];
    message.dateRanges = object.dateRanges?.map((e) => DateRange.fromPartial(e)) || [];
    message.dimensionFilter = (object.dimensionFilter !== undefined && object.dimensionFilter !== null)
      ? FilterExpression.fromPartial(object.dimensionFilter)
      : undefined;
    message.metricFilter = (object.metricFilter !== undefined && object.metricFilter !== null)
      ? FilterExpression.fromPartial(object.metricFilter)
      : undefined;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    message.metricAggregations = object.metricAggregations?.map((e) => e) || [];
    message.orderBys = object.orderBys?.map((e) => OrderBy.fromPartial(e)) || [];
    message.currencyCode = object.currencyCode ?? "";
    message.cohortSpec = (object.cohortSpec !== undefined && object.cohortSpec !== null)
      ? CohortSpec.fromPartial(object.cohortSpec)
      : undefined;
    message.keepEmptyRows = object.keepEmptyRows ?? false;
    return message;
  },
};

function createBaseReportTask_ReportMetadata(): ReportTask_ReportMetadata {
  return {
    state: undefined,
    beginCreatingTime: undefined,
    creationQuotaTokensCharged: 0,
    taskRowCount: undefined,
    errorMessage: undefined,
    totalRowCount: undefined,
  };
}

export const ReportTask_ReportMetadata: MessageFns<ReportTask_ReportMetadata> = {
  encode(message: ReportTask_ReportMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== undefined) {
      writer.uint32(8).int32(message.state);
    }
    if (message.beginCreatingTime !== undefined) {
      Timestamp.encode(toTimestamp(message.beginCreatingTime), writer.uint32(18).fork()).join();
    }
    if (message.creationQuotaTokensCharged !== 0) {
      writer.uint32(24).int32(message.creationQuotaTokensCharged);
    }
    if (message.taskRowCount !== undefined) {
      writer.uint32(32).int32(message.taskRowCount);
    }
    if (message.errorMessage !== undefined) {
      writer.uint32(42).string(message.errorMessage);
    }
    if (message.totalRowCount !== undefined) {
      writer.uint32(48).int32(message.totalRowCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportTask_ReportMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportTask_ReportMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.beginCreatingTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.creationQuotaTokensCharged = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.taskRowCount = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.totalRowCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportTask_ReportMetadata {
    return {
      state: isSet(object.state) ? reportTask_ReportMetadata_StateFromJSON(object.state) : undefined,
      beginCreatingTime: isSet(object.beginCreatingTime) ? fromJsonTimestamp(object.beginCreatingTime) : undefined,
      creationQuotaTokensCharged: isSet(object.creationQuotaTokensCharged)
        ? globalThis.Number(object.creationQuotaTokensCharged)
        : 0,
      taskRowCount: isSet(object.taskRowCount) ? globalThis.Number(object.taskRowCount) : undefined,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : undefined,
      totalRowCount: isSet(object.totalRowCount) ? globalThis.Number(object.totalRowCount) : undefined,
    };
  },

  toJSON(message: ReportTask_ReportMetadata): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = reportTask_ReportMetadata_StateToJSON(message.state);
    }
    if (message.beginCreatingTime !== undefined) {
      obj.beginCreatingTime = message.beginCreatingTime.toISOString();
    }
    if (message.creationQuotaTokensCharged !== 0) {
      obj.creationQuotaTokensCharged = Math.round(message.creationQuotaTokensCharged);
    }
    if (message.taskRowCount !== undefined) {
      obj.taskRowCount = Math.round(message.taskRowCount);
    }
    if (message.errorMessage !== undefined) {
      obj.errorMessage = message.errorMessage;
    }
    if (message.totalRowCount !== undefined) {
      obj.totalRowCount = Math.round(message.totalRowCount);
    }
    return obj;
  },

  create(base?: DeepPartial<ReportTask_ReportMetadata>): ReportTask_ReportMetadata {
    return ReportTask_ReportMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportTask_ReportMetadata>): ReportTask_ReportMetadata {
    const message = createBaseReportTask_ReportMetadata();
    message.state = object.state ?? undefined;
    message.beginCreatingTime = object.beginCreatingTime ?? undefined;
    message.creationQuotaTokensCharged = object.creationQuotaTokensCharged ?? 0;
    message.taskRowCount = object.taskRowCount ?? undefined;
    message.errorMessage = object.errorMessage ?? undefined;
    message.totalRowCount = object.totalRowCount ?? undefined;
    return message;
  },
};

function createBaseCreateReportTaskRequest(): CreateReportTaskRequest {
  return { parent: "", reportTask: undefined };
}

export const CreateReportTaskRequest: MessageFns<CreateReportTaskRequest> = {
  encode(message: CreateReportTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.reportTask !== undefined) {
      ReportTask.encode(message.reportTask, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReportTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReportTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reportTask = ReportTask.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReportTaskRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      reportTask: isSet(object.reportTask) ? ReportTask.fromJSON(object.reportTask) : undefined,
    };
  },

  toJSON(message: CreateReportTaskRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.reportTask !== undefined) {
      obj.reportTask = ReportTask.toJSON(message.reportTask);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateReportTaskRequest>): CreateReportTaskRequest {
    return CreateReportTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateReportTaskRequest>): CreateReportTaskRequest {
    const message = createBaseCreateReportTaskRequest();
    message.parent = object.parent ?? "";
    message.reportTask = (object.reportTask !== undefined && object.reportTask !== null)
      ? ReportTask.fromPartial(object.reportTask)
      : undefined;
    return message;
  },
};

function createBaseReportTaskMetadata(): ReportTaskMetadata {
  return {};
}

export const ReportTaskMetadata: MessageFns<ReportTaskMetadata> = {
  encode(_: ReportTaskMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportTaskMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportTaskMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ReportTaskMetadata {
    return {};
  },

  toJSON(_: ReportTaskMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ReportTaskMetadata>): ReportTaskMetadata {
    return ReportTaskMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ReportTaskMetadata>): ReportTaskMetadata {
    const message = createBaseReportTaskMetadata();
    return message;
  },
};

function createBaseQueryReportTaskRequest(): QueryReportTaskRequest {
  return { name: "", offset: Long.ZERO, limit: Long.ZERO };
}

export const QueryReportTaskRequest: MessageFns<QueryReportTaskRequest> = {
  encode(message: QueryReportTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.offset.toString());
    }
    if (!message.limit.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.limit.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryReportTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReportTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.limit = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReportTaskRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO,
      limit: isSet(object.limit) ? Long.fromValue(object.limit) : Long.ZERO,
    };
  },

  toJSON(message: QueryReportTaskRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    if (!message.limit.equals(Long.ZERO)) {
      obj.limit = (message.limit || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<QueryReportTaskRequest>): QueryReportTaskRequest {
    return QueryReportTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryReportTaskRequest>): QueryReportTaskRequest {
    const message = createBaseQueryReportTaskRequest();
    message.name = object.name ?? "";
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Long.fromValue(object.limit) : Long.ZERO;
    return message;
  },
};

function createBaseQueryReportTaskResponse(): QueryReportTaskResponse {
  return {
    dimensionHeaders: [],
    metricHeaders: [],
    rows: [],
    totals: [],
    maximums: [],
    minimums: [],
    rowCount: 0,
    metadata: undefined,
  };
}

export const QueryReportTaskResponse: MessageFns<QueryReportTaskResponse> = {
  encode(message: QueryReportTaskResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dimensionHeaders) {
      DimensionHeader.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.metricHeaders) {
      MetricHeader.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.totals) {
      Row.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.maximums) {
      Row.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.minimums) {
      Row.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.rowCount !== 0) {
      writer.uint32(56).int32(message.rowCount);
    }
    if (message.metadata !== undefined) {
      ResponseMetaData.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryReportTaskResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryReportTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dimensionHeaders.push(DimensionHeader.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metricHeaders.push(MetricHeader.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.totals.push(Row.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.maximums.push(Row.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.minimums.push(Row.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.rowCount = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.metadata = ResponseMetaData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryReportTaskResponse {
    return {
      dimensionHeaders: globalThis.Array.isArray(object?.dimensionHeaders)
        ? object.dimensionHeaders.map((e: any) => DimensionHeader.fromJSON(e))
        : [],
      metricHeaders: globalThis.Array.isArray(object?.metricHeaders)
        ? object.metricHeaders.map((e: any) => MetricHeader.fromJSON(e))
        : [],
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [],
      totals: globalThis.Array.isArray(object?.totals) ? object.totals.map((e: any) => Row.fromJSON(e)) : [],
      maximums: globalThis.Array.isArray(object?.maximums) ? object.maximums.map((e: any) => Row.fromJSON(e)) : [],
      minimums: globalThis.Array.isArray(object?.minimums) ? object.minimums.map((e: any) => Row.fromJSON(e)) : [],
      rowCount: isSet(object.rowCount) ? globalThis.Number(object.rowCount) : 0,
      metadata: isSet(object.metadata) ? ResponseMetaData.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: QueryReportTaskResponse): unknown {
    const obj: any = {};
    if (message.dimensionHeaders?.length) {
      obj.dimensionHeaders = message.dimensionHeaders.map((e) => DimensionHeader.toJSON(e));
    }
    if (message.metricHeaders?.length) {
      obj.metricHeaders = message.metricHeaders.map((e) => MetricHeader.toJSON(e));
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    if (message.totals?.length) {
      obj.totals = message.totals.map((e) => Row.toJSON(e));
    }
    if (message.maximums?.length) {
      obj.maximums = message.maximums.map((e) => Row.toJSON(e));
    }
    if (message.minimums?.length) {
      obj.minimums = message.minimums.map((e) => Row.toJSON(e));
    }
    if (message.rowCount !== 0) {
      obj.rowCount = Math.round(message.rowCount);
    }
    if (message.metadata !== undefined) {
      obj.metadata = ResponseMetaData.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryReportTaskResponse>): QueryReportTaskResponse {
    return QueryReportTaskResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryReportTaskResponse>): QueryReportTaskResponse {
    const message = createBaseQueryReportTaskResponse();
    message.dimensionHeaders = object.dimensionHeaders?.map((e) => DimensionHeader.fromPartial(e)) || [];
    message.metricHeaders = object.metricHeaders?.map((e) => MetricHeader.fromPartial(e)) || [];
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    message.totals = object.totals?.map((e) => Row.fromPartial(e)) || [];
    message.maximums = object.maximums?.map((e) => Row.fromPartial(e)) || [];
    message.minimums = object.minimums?.map((e) => Row.fromPartial(e)) || [];
    message.rowCount = object.rowCount ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetaData.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGetReportTaskRequest(): GetReportTaskRequest {
  return { name: "" };
}

export const GetReportTaskRequest: MessageFns<GetReportTaskRequest> = {
  encode(message: GetReportTaskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReportTaskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReportTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReportTaskRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetReportTaskRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReportTaskRequest>): GetReportTaskRequest {
    return GetReportTaskRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReportTaskRequest>): GetReportTaskRequest {
    const message = createBaseGetReportTaskRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListReportTasksRequest(): ListReportTasksRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListReportTasksRequest: MessageFns<ListReportTasksRequest> = {
  encode(message: ListReportTasksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReportTasksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReportTasksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReportTasksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListReportTasksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReportTasksRequest>): ListReportTasksRequest {
    return ListReportTasksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReportTasksRequest>): ListReportTasksRequest {
    const message = createBaseListReportTasksRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListReportTasksResponse(): ListReportTasksResponse {
  return { reportTasks: [], nextPageToken: undefined };
}

export const ListReportTasksResponse: MessageFns<ListReportTasksResponse> = {
  encode(message: ListReportTasksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reportTasks) {
      ReportTask.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== undefined) {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReportTasksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReportTasksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reportTasks.push(ReportTask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReportTasksResponse {
    return {
      reportTasks: globalThis.Array.isArray(object?.reportTasks)
        ? object.reportTasks.map((e: any) => ReportTask.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : undefined,
    };
  },

  toJSON(message: ListReportTasksResponse): unknown {
    const obj: any = {};
    if (message.reportTasks?.length) {
      obj.reportTasks = message.reportTasks.map((e) => ReportTask.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReportTasksResponse>): ListReportTasksResponse {
    return ListReportTasksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReportTasksResponse>): ListReportTasksResponse {
    const message = createBaseListReportTasksResponse();
    message.reportTasks = object.reportTasks?.map((e) => ReportTask.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? undefined;
    return message;
  },
};

/** Google Analytics reporting data service. */
export type AlphaAnalyticsDataDefinition = typeof AlphaAnalyticsDataDefinition;
export const AlphaAnalyticsDataDefinition = {
  name: "AlphaAnalyticsData",
  fullName: "google.analytics.data.v1alpha.AlphaAnalyticsData",
  methods: {
    /**
     * Returns a customized funnel report of your Google Analytics event data. The
     * data returned from the API is as a table with columns for the requested
     * dimensions and metrics.
     *
     * Funnel exploration lets you visualize the steps your users take to complete
     * a task and quickly see how well they are succeeding or failing at each
     * step. For example, how do prospects become shoppers and then become buyers?
     * How do one time buyers become repeat buyers? With this information, you can
     * improve inefficient or abandoned customer journeys. To learn more, see [GA4
     * Funnel Explorations](https://support.google.com/analytics/answer/9327974).
     *
     * This method is introduced at alpha stability with the intention of
     * gathering feedback on syntax and capabilities before entering beta. To give
     * your feedback on this API, complete the [Google Analytics Data API Funnel
     * Reporting
     * Feedback](https://docs.google.com/forms/d/e/1FAIpQLSdwOlQDJAUoBiIgUZZ3S_Lwi8gr7Bb0k1jhvc-DEg7Rol3UjA/viewform).
     */
    runFunnelReport: {
      name: "RunFunnelReport",
      requestType: RunFunnelReportRequest,
      requestStream: false,
      responseType: RunFunnelReportResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              53,
              58,
              1,
              42,
              34,
              48,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              121,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              117,
              110,
              70,
              117,
              110,
              110,
              101,
              108,
              82,
              101,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an audience list for later retrieval. This method quickly returns
     * the audience list's resource name and initiates a long running asynchronous
     * request to form an audience list. To list the users in an audience list,
     * first create the audience list through this method and then send the
     * audience resource name to the `QueryAudienceList` method.
     *
     * See [Creating an Audience
     * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
     * for an introduction to Audience Lists with examples.
     *
     * An audience list is a snapshot of the users currently in the audience at
     * the time of audience list creation. Creating audience lists for one
     * audience on different days will return different results as users enter and
     * exit the audience.
     *
     * Audiences in Google Analytics 4 allow you to segment your users in the ways
     * that are important to your business. To learn more, see
     * https://support.google.com/analytics/answer/9267572. Audience lists contain
     * the users in each audience.
     *
     * This method is available at beta stability at
     * [audienceExports.create](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/create).
     * To give your feedback on this API, complete the [Google Analytics Audience
     * Export API Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    createAudienceList: {
      name: "CreateAudienceList",
      requestType: CreateAudienceListRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              36,
              10,
              12,
              65,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              76,
              105,
              115,
              116,
              18,
              20,
              65,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              76,
              105,
              115,
              116,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              20,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              95,
              108,
              105,
              115,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              61,
              58,
              13,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              95,
              108,
              105,
              115,
              116,
              34,
              44,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              47,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              76,
              105,
              115,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves an audience list of users. After creating an audience, the users
     * are not immediately available for listing. First, a request to
     * `CreateAudienceList` is necessary to create an audience list of users, and
     * then second, this method is used to retrieve the users in the audience
     * list.
     *
     * See [Creating an Audience
     * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
     * for an introduction to Audience Lists with examples.
     *
     * Audiences in Google Analytics 4 allow you to segment your users in the ways
     * that are important to your business. To learn more, see
     * https://support.google.com/analytics/answer/9267572.
     *
     * This method is available at beta stability at
     * [audienceExports.query](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/query).
     * To give your feedback on this API, complete the [Google Analytics Audience
     * Export API Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    queryAudienceList: {
      name: "QueryAudienceList",
      requestType: QueryAudienceListRequest,
      requestStream: false,
      responseType: QueryAudienceListResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              47,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              76,
              105,
              115,
              116,
              115,
              47,
              42,
              125,
              58,
              113,
              117,
              101,
              114,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Exports an audience list of users to a Google Sheet. After creating an
     * audience, the users are not immediately available for listing. First, a
     * request to `CreateAudienceList` is necessary to create an audience list of
     * users, and then second, this method is used to export those users in the
     * audience list to a Google Sheet.
     *
     * See [Creating an Audience
     * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
     * for an introduction to Audience Lists with examples.
     *
     * Audiences in Google Analytics 4 allow you to segment your users in the ways
     * that are important to your business. To learn more, see
     * https://support.google.com/analytics/answer/9267572.
     *
     * This method is introduced at alpha stability with the intention of
     * gathering feedback on syntax and capabilities before entering beta. To give
     * your feedback on this API, complete the
     * [Google Analytics Audience Export API
     * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    sheetExportAudienceList: {
      name: "SheetExportAudienceList",
      requestType: SheetExportAudienceListRequest,
      requestStream: false,
      responseType: SheetExportAudienceListResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              61,
              58,
              1,
              42,
              34,
              56,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              47,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              76,
              105,
              115,
              116,
              115,
              47,
              42,
              125,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
              83,
              104,
              101,
              101,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Gets configuration metadata about a specific audience list. This method
     * can be used to understand an audience list after it has been created.
     *
     * See [Creating an Audience
     * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
     * for an introduction to Audience Lists with examples.
     *
     * This method is available at beta stability at
     * [audienceExports.get](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/get).
     * To give your feedback on this API, complete the
     * [Google Analytics Audience Export API
     * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    getAudienceList: {
      name: "GetAudienceList",
      requestType: GetAudienceListRequest,
      requestStream: false,
      responseType: AudienceList,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              47,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              76,
              105,
              115,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists all audience lists for a property. This method can be used for you to
     * find and reuse existing audience lists rather than creating unnecessary new
     * audience lists. The same audience can have multiple audience lists that
     * represent the list of users that were in an audience on different days.
     *
     * See [Creating an Audience
     * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
     * for an introduction to Audience Lists with examples.
     *
     * This method is available at beta stability at
     * [audienceExports.list](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/list).
     * To give your feedback on this API, complete the
     * [Google Analytics Audience Export API
     * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    listAudienceLists: {
      name: "ListAudienceLists",
      requestType: ListAudienceListsRequest,
      requestStream: false,
      responseType: ListAudienceListsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              47,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              76,
              105,
              115,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a recurring audience list. Recurring audience lists produces new
     * audience lists each day. Audience lists are users in an audience at the
     * time of the list's creation.
     *
     * A recurring audience list ensures that you have audience list based on the
     * most recent data available for use each day. If you manually create
     * audience list, you don't know when an audience list based on an additional
     * day's data is available. This recurring audience list automates the
     * creation of an audience list when an additional day's data is available.
     * You will consume fewer quota tokens by using recurring audience list versus
     * manually creating audience list at various times of day trying to guess
     * when an additional day's data is ready.
     *
     * This method is introduced at alpha stability with the intention of
     * gathering feedback on syntax and capabilities before entering beta. To give
     * your feedback on this API, complete the
     * [Google Analytics Audience Export API
     * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    createRecurringAudienceList: {
      name: "CreateRecurringAudienceList",
      requestType: CreateRecurringAudienceListRequest,
      requestStream: false,
      responseType: RecurringAudienceList,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              30,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              99,
              117,
              114,
              114,
              105,
              110,
              103,
              95,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              95,
              108,
              105,
              115,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              80,
              58,
              23,
              114,
              101,
              99,
              117,
              114,
              114,
              105,
              110,
              103,
              95,
              97,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              95,
              108,
              105,
              115,
              116,
              34,
              53,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              99,
              117,
              114,
              114,
              105,
              110,
              103,
              65,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              76,
              105,
              115,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets configuration metadata about a specific recurring audience list. This
     * method can be used to understand a recurring audience list's state after it
     * has been created. For example, a recurring audience list resource will
     * generate audience list instances for each day, and this method can be used
     * to get the resource name of the most recent audience list instance.
     *
     * This method is introduced at alpha stability with the intention of
     * gathering feedback on syntax and capabilities before entering beta. To give
     * your feedback on this API, complete the
     * [Google Analytics Audience Export API
     * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    getRecurringAudienceList: {
      name: "GetRecurringAudienceList",
      requestType: GetRecurringAudienceListRequest,
      requestStream: false,
      responseType: RecurringAudienceList,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              99,
              117,
              114,
              114,
              105,
              110,
              103,
              65,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              76,
              105,
              115,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists all recurring audience lists for a property. This method can be used
     * for you to find and reuse existing recurring audience lists rather than
     * creating unnecessary new recurring audience lists. The same audience can
     * have multiple recurring audience lists that represent different dimension
     * combinations; for example, just the dimension `deviceId` or both the
     * dimensions `deviceId` and `userId`.
     *
     * This method is introduced at alpha stability with the intention of
     * gathering feedback on syntax and capabilities before entering beta. To give
     * your feedback on this API, complete the
     * [Google Analytics Audience Export API
     * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
     */
    listRecurringAudienceLists: {
      name: "ListRecurringAudienceLists",
      requestType: ListRecurringAudienceListsRequest,
      requestStream: false,
      responseType: ListRecurringAudienceListsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              99,
              117,
              114,
              114,
              105,
              110,
              103,
              65,
              117,
              100,
              105,
              101,
              110,
              99,
              101,
              76,
              105,
              115,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Get all property quotas organized by quota category for a given property.
     * This will charge 1 property quota from the category with the most quota.
     */
    getPropertyQuotasSnapshot: {
      name: "GetPropertyQuotasSnapshot",
      requestType: GetPropertyQuotasSnapshotRequest,
      requestStream: false,
      responseType: PropertyQuotasSnapshot,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              47,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              121,
              81,
              117,
              111,
              116,
              97,
              115,
              83,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Initiates the creation of a report task. This method quickly
     * returns a report task and initiates a long running
     * asynchronous request to form a customized report of your Google Analytics
     * event data.
     *
     * A report task will be retained and available for querying for 72 hours
     * after it has been created.
     *
     * A report task created by one user can be listed and queried by all users
     * who have access to the property.
     */
    createReportTask: {
      name: "CreateReportTask",
      requestType: CreateReportTaskRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              32,
              10,
              10,
              82,
              101,
              112,
              111,
              114,
              116,
              84,
              97,
              115,
              107,
              18,
              18,
              82,
              101,
              112,
              111,
              114,
              116,
              84,
              97,
              115,
              107,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([18, 112, 97, 114, 101, 110, 116, 44, 114, 101, 112, 111, 114, 116, 95, 116, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              57,
              58,
              11,
              114,
              101,
              112,
              111,
              114,
              116,
              95,
              116,
              97,
              115,
              107,
              34,
              42,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              84,
              97,
              115,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves a report task's content. After requesting the `CreateReportTask`,
     * you are able to retrieve the report content once the report is
     * ACTIVE. This method will return an error if the report task's state is not
     * `ACTIVE`. A query response will return the tabular row & column values of
     * the report.
     */
    queryReportTask: {
      name: "QueryReportTask",
      requestType: QueryReportTaskRequest,
      requestStream: false,
      responseType: QueryReportTaskResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              58,
              1,
              42,
              34,
              48,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              84,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
              58,
              113,
              117,
              101,
              114,
              121,
            ]),
          ],
        },
      },
    },
    /**
     * Gets report metadata about a specific report task. After creating a report
     * task, use this method to check its processing state or inspect its
     * report definition.
     */
    getReportTask: {
      name: "GetReportTask",
      requestType: GetReportTaskRequest,
      requestStream: false,
      responseType: ReportTask,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              84,
              97,
              115,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all report tasks for a property. */
    listReportTasks: {
      name: "ListReportTasks",
      requestType: ListReportTasksRequest,
      requestStream: false,
      responseType: ListReportTasksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              44,
              18,
              42,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              112,
              101,
              114,
              116,
              105,
              101,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              84,
              97,
              115,
              107,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AlphaAnalyticsDataServiceImplementation<CallContextExt = {}> {
  /**
   * Returns a customized funnel report of your Google Analytics event data. The
   * data returned from the API is as a table with columns for the requested
   * dimensions and metrics.
   *
   * Funnel exploration lets you visualize the steps your users take to complete
   * a task and quickly see how well they are succeeding or failing at each
   * step. For example, how do prospects become shoppers and then become buyers?
   * How do one time buyers become repeat buyers? With this information, you can
   * improve inefficient or abandoned customer journeys. To learn more, see [GA4
   * Funnel Explorations](https://support.google.com/analytics/answer/9327974).
   *
   * This method is introduced at alpha stability with the intention of
   * gathering feedback on syntax and capabilities before entering beta. To give
   * your feedback on this API, complete the [Google Analytics Data API Funnel
   * Reporting
   * Feedback](https://docs.google.com/forms/d/e/1FAIpQLSdwOlQDJAUoBiIgUZZ3S_Lwi8gr7Bb0k1jhvc-DEg7Rol3UjA/viewform).
   */
  runFunnelReport(
    request: RunFunnelReportRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RunFunnelReportResponse>>;
  /**
   * Creates an audience list for later retrieval. This method quickly returns
   * the audience list's resource name and initiates a long running asynchronous
   * request to form an audience list. To list the users in an audience list,
   * first create the audience list through this method and then send the
   * audience resource name to the `QueryAudienceList` method.
   *
   * See [Creating an Audience
   * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Lists with examples.
   *
   * An audience list is a snapshot of the users currently in the audience at
   * the time of audience list creation. Creating audience lists for one
   * audience on different days will return different results as users enter and
   * exit the audience.
   *
   * Audiences in Google Analytics 4 allow you to segment your users in the ways
   * that are important to your business. To learn more, see
   * https://support.google.com/analytics/answer/9267572. Audience lists contain
   * the users in each audience.
   *
   * This method is available at beta stability at
   * [audienceExports.create](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/create).
   * To give your feedback on this API, complete the [Google Analytics Audience
   * Export API Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  createAudienceList(
    request: CreateAudienceListRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Retrieves an audience list of users. After creating an audience, the users
   * are not immediately available for listing. First, a request to
   * `CreateAudienceList` is necessary to create an audience list of users, and
   * then second, this method is used to retrieve the users in the audience
   * list.
   *
   * See [Creating an Audience
   * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Lists with examples.
   *
   * Audiences in Google Analytics 4 allow you to segment your users in the ways
   * that are important to your business. To learn more, see
   * https://support.google.com/analytics/answer/9267572.
   *
   * This method is available at beta stability at
   * [audienceExports.query](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/query).
   * To give your feedback on this API, complete the [Google Analytics Audience
   * Export API Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  queryAudienceList(
    request: QueryAudienceListRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryAudienceListResponse>>;
  /**
   * Exports an audience list of users to a Google Sheet. After creating an
   * audience, the users are not immediately available for listing. First, a
   * request to `CreateAudienceList` is necessary to create an audience list of
   * users, and then second, this method is used to export those users in the
   * audience list to a Google Sheet.
   *
   * See [Creating an Audience
   * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Lists with examples.
   *
   * Audiences in Google Analytics 4 allow you to segment your users in the ways
   * that are important to your business. To learn more, see
   * https://support.google.com/analytics/answer/9267572.
   *
   * This method is introduced at alpha stability with the intention of
   * gathering feedback on syntax and capabilities before entering beta. To give
   * your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  sheetExportAudienceList(
    request: SheetExportAudienceListRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SheetExportAudienceListResponse>>;
  /**
   * Gets configuration metadata about a specific audience list. This method
   * can be used to understand an audience list after it has been created.
   *
   * See [Creating an Audience
   * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Lists with examples.
   *
   * This method is available at beta stability at
   * [audienceExports.get](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/get).
   * To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  getAudienceList(
    request: GetAudienceListRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AudienceList>>;
  /**
   * Lists all audience lists for a property. This method can be used for you to
   * find and reuse existing audience lists rather than creating unnecessary new
   * audience lists. The same audience can have multiple audience lists that
   * represent the list of users that were in an audience on different days.
   *
   * See [Creating an Audience
   * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Lists with examples.
   *
   * This method is available at beta stability at
   * [audienceExports.list](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/list).
   * To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  listAudienceLists(
    request: ListAudienceListsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAudienceListsResponse>>;
  /**
   * Creates a recurring audience list. Recurring audience lists produces new
   * audience lists each day. Audience lists are users in an audience at the
   * time of the list's creation.
   *
   * A recurring audience list ensures that you have audience list based on the
   * most recent data available for use each day. If you manually create
   * audience list, you don't know when an audience list based on an additional
   * day's data is available. This recurring audience list automates the
   * creation of an audience list when an additional day's data is available.
   * You will consume fewer quota tokens by using recurring audience list versus
   * manually creating audience list at various times of day trying to guess
   * when an additional day's data is ready.
   *
   * This method is introduced at alpha stability with the intention of
   * gathering feedback on syntax and capabilities before entering beta. To give
   * your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  createRecurringAudienceList(
    request: CreateRecurringAudienceListRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RecurringAudienceList>>;
  /**
   * Gets configuration metadata about a specific recurring audience list. This
   * method can be used to understand a recurring audience list's state after it
   * has been created. For example, a recurring audience list resource will
   * generate audience list instances for each day, and this method can be used
   * to get the resource name of the most recent audience list instance.
   *
   * This method is introduced at alpha stability with the intention of
   * gathering feedback on syntax and capabilities before entering beta. To give
   * your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  getRecurringAudienceList(
    request: GetRecurringAudienceListRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RecurringAudienceList>>;
  /**
   * Lists all recurring audience lists for a property. This method can be used
   * for you to find and reuse existing recurring audience lists rather than
   * creating unnecessary new recurring audience lists. The same audience can
   * have multiple recurring audience lists that represent different dimension
   * combinations; for example, just the dimension `deviceId` or both the
   * dimensions `deviceId` and `userId`.
   *
   * This method is introduced at alpha stability with the intention of
   * gathering feedback on syntax and capabilities before entering beta. To give
   * your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  listRecurringAudienceLists(
    request: ListRecurringAudienceListsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRecurringAudienceListsResponse>>;
  /**
   * Get all property quotas organized by quota category for a given property.
   * This will charge 1 property quota from the category with the most quota.
   */
  getPropertyQuotasSnapshot(
    request: GetPropertyQuotasSnapshotRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PropertyQuotasSnapshot>>;
  /**
   * Initiates the creation of a report task. This method quickly
   * returns a report task and initiates a long running
   * asynchronous request to form a customized report of your Google Analytics
   * event data.
   *
   * A report task will be retained and available for querying for 72 hours
   * after it has been created.
   *
   * A report task created by one user can be listed and queried by all users
   * who have access to the property.
   */
  createReportTask(
    request: CreateReportTaskRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Retrieves a report task's content. After requesting the `CreateReportTask`,
   * you are able to retrieve the report content once the report is
   * ACTIVE. This method will return an error if the report task's state is not
   * `ACTIVE`. A query response will return the tabular row & column values of
   * the report.
   */
  queryReportTask(
    request: QueryReportTaskRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryReportTaskResponse>>;
  /**
   * Gets report metadata about a specific report task. After creating a report
   * task, use this method to check its processing state or inspect its
   * report definition.
   */
  getReportTask(request: GetReportTaskRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ReportTask>>;
  /** Lists all report tasks for a property. */
  listReportTasks(
    request: ListReportTasksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReportTasksResponse>>;
}

export interface AlphaAnalyticsDataClient<CallOptionsExt = {}> {
  /**
   * Returns a customized funnel report of your Google Analytics event data. The
   * data returned from the API is as a table with columns for the requested
   * dimensions and metrics.
   *
   * Funnel exploration lets you visualize the steps your users take to complete
   * a task and quickly see how well they are succeeding or failing at each
   * step. For example, how do prospects become shoppers and then become buyers?
   * How do one time buyers become repeat buyers? With this information, you can
   * improve inefficient or abandoned customer journeys. To learn more, see [GA4
   * Funnel Explorations](https://support.google.com/analytics/answer/9327974).
   *
   * This method is introduced at alpha stability with the intention of
   * gathering feedback on syntax and capabilities before entering beta. To give
   * your feedback on this API, complete the [Google Analytics Data API Funnel
   * Reporting
   * Feedback](https://docs.google.com/forms/d/e/1FAIpQLSdwOlQDJAUoBiIgUZZ3S_Lwi8gr7Bb0k1jhvc-DEg7Rol3UjA/viewform).
   */
  runFunnelReport(
    request: DeepPartial<RunFunnelReportRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RunFunnelReportResponse>;
  /**
   * Creates an audience list for later retrieval. This method quickly returns
   * the audience list's resource name and initiates a long running asynchronous
   * request to form an audience list. To list the users in an audience list,
   * first create the audience list through this method and then send the
   * audience resource name to the `QueryAudienceList` method.
   *
   * See [Creating an Audience
   * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Lists with examples.
   *
   * An audience list is a snapshot of the users currently in the audience at
   * the time of audience list creation. Creating audience lists for one
   * audience on different days will return different results as users enter and
   * exit the audience.
   *
   * Audiences in Google Analytics 4 allow you to segment your users in the ways
   * that are important to your business. To learn more, see
   * https://support.google.com/analytics/answer/9267572. Audience lists contain
   * the users in each audience.
   *
   * This method is available at beta stability at
   * [audienceExports.create](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/create).
   * To give your feedback on this API, complete the [Google Analytics Audience
   * Export API Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  createAudienceList(
    request: DeepPartial<CreateAudienceListRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Retrieves an audience list of users. After creating an audience, the users
   * are not immediately available for listing. First, a request to
   * `CreateAudienceList` is necessary to create an audience list of users, and
   * then second, this method is used to retrieve the users in the audience
   * list.
   *
   * See [Creating an Audience
   * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Lists with examples.
   *
   * Audiences in Google Analytics 4 allow you to segment your users in the ways
   * that are important to your business. To learn more, see
   * https://support.google.com/analytics/answer/9267572.
   *
   * This method is available at beta stability at
   * [audienceExports.query](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/query).
   * To give your feedback on this API, complete the [Google Analytics Audience
   * Export API Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  queryAudienceList(
    request: DeepPartial<QueryAudienceListRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryAudienceListResponse>;
  /**
   * Exports an audience list of users to a Google Sheet. After creating an
   * audience, the users are not immediately available for listing. First, a
   * request to `CreateAudienceList` is necessary to create an audience list of
   * users, and then second, this method is used to export those users in the
   * audience list to a Google Sheet.
   *
   * See [Creating an Audience
   * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Lists with examples.
   *
   * Audiences in Google Analytics 4 allow you to segment your users in the ways
   * that are important to your business. To learn more, see
   * https://support.google.com/analytics/answer/9267572.
   *
   * This method is introduced at alpha stability with the intention of
   * gathering feedback on syntax and capabilities before entering beta. To give
   * your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  sheetExportAudienceList(
    request: DeepPartial<SheetExportAudienceListRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SheetExportAudienceListResponse>;
  /**
   * Gets configuration metadata about a specific audience list. This method
   * can be used to understand an audience list after it has been created.
   *
   * See [Creating an Audience
   * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Lists with examples.
   *
   * This method is available at beta stability at
   * [audienceExports.get](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/get).
   * To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  getAudienceList(
    request: DeepPartial<GetAudienceListRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AudienceList>;
  /**
   * Lists all audience lists for a property. This method can be used for you to
   * find and reuse existing audience lists rather than creating unnecessary new
   * audience lists. The same audience can have multiple audience lists that
   * represent the list of users that were in an audience on different days.
   *
   * See [Creating an Audience
   * List](https://developers.google.com/analytics/devguides/reporting/data/v1/audience-list-basics)
   * for an introduction to Audience Lists with examples.
   *
   * This method is available at beta stability at
   * [audienceExports.list](https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties.audienceExports/list).
   * To give your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  listAudienceLists(
    request: DeepPartial<ListAudienceListsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAudienceListsResponse>;
  /**
   * Creates a recurring audience list. Recurring audience lists produces new
   * audience lists each day. Audience lists are users in an audience at the
   * time of the list's creation.
   *
   * A recurring audience list ensures that you have audience list based on the
   * most recent data available for use each day. If you manually create
   * audience list, you don't know when an audience list based on an additional
   * day's data is available. This recurring audience list automates the
   * creation of an audience list when an additional day's data is available.
   * You will consume fewer quota tokens by using recurring audience list versus
   * manually creating audience list at various times of day trying to guess
   * when an additional day's data is ready.
   *
   * This method is introduced at alpha stability with the intention of
   * gathering feedback on syntax and capabilities before entering beta. To give
   * your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  createRecurringAudienceList(
    request: DeepPartial<CreateRecurringAudienceListRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RecurringAudienceList>;
  /**
   * Gets configuration metadata about a specific recurring audience list. This
   * method can be used to understand a recurring audience list's state after it
   * has been created. For example, a recurring audience list resource will
   * generate audience list instances for each day, and this method can be used
   * to get the resource name of the most recent audience list instance.
   *
   * This method is introduced at alpha stability with the intention of
   * gathering feedback on syntax and capabilities before entering beta. To give
   * your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  getRecurringAudienceList(
    request: DeepPartial<GetRecurringAudienceListRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RecurringAudienceList>;
  /**
   * Lists all recurring audience lists for a property. This method can be used
   * for you to find and reuse existing recurring audience lists rather than
   * creating unnecessary new recurring audience lists. The same audience can
   * have multiple recurring audience lists that represent different dimension
   * combinations; for example, just the dimension `deviceId` or both the
   * dimensions `deviceId` and `userId`.
   *
   * This method is introduced at alpha stability with the intention of
   * gathering feedback on syntax and capabilities before entering beta. To give
   * your feedback on this API, complete the
   * [Google Analytics Audience Export API
   * Feedback](https://forms.gle/EeA5u5LW6PEggtCEA) form.
   */
  listRecurringAudienceLists(
    request: DeepPartial<ListRecurringAudienceListsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRecurringAudienceListsResponse>;
  /**
   * Get all property quotas organized by quota category for a given property.
   * This will charge 1 property quota from the category with the most quota.
   */
  getPropertyQuotasSnapshot(
    request: DeepPartial<GetPropertyQuotasSnapshotRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PropertyQuotasSnapshot>;
  /**
   * Initiates the creation of a report task. This method quickly
   * returns a report task and initiates a long running
   * asynchronous request to form a customized report of your Google Analytics
   * event data.
   *
   * A report task will be retained and available for querying for 72 hours
   * after it has been created.
   *
   * A report task created by one user can be listed and queried by all users
   * who have access to the property.
   */
  createReportTask(
    request: DeepPartial<CreateReportTaskRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Retrieves a report task's content. After requesting the `CreateReportTask`,
   * you are able to retrieve the report content once the report is
   * ACTIVE. This method will return an error if the report task's state is not
   * `ACTIVE`. A query response will return the tabular row & column values of
   * the report.
   */
  queryReportTask(
    request: DeepPartial<QueryReportTaskRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryReportTaskResponse>;
  /**
   * Gets report metadata about a specific report task. After creating a report
   * task, use this method to check its processing state or inspect its
   * report definition.
   */
  getReportTask(
    request: DeepPartial<GetReportTaskRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ReportTask>;
  /** Lists all report tasks for a property. */
  listReportTasks(
    request: DeepPartial<ListReportTasksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReportTasksResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
