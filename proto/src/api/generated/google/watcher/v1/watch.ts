// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/watcher/v1/watch.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Any } from "../../protobuf/any.js";

export const protobufPackage = "google.watcher.v1";

/** The message used by the client to register interest in an entity. */
export interface Request {
  /**
   * The `target` value **must** be a valid URL path pointing to an entity
   * to watch. Note that the service name **must** be
   * removed from the target field (e.g., the target field must say
   * "/foo/bar", not "myservice.googleapis.com/foo/bar"). A client is
   * also allowed to pass system-specific parameters in the URL that
   * are only obeyed by some implementations. Some parameters will be
   * implementation-specific. However, some have predefined meaning
   * and are listed here:
   *
   *  * recursive = true|false [default=false]
   *    If set to true, indicates that the client wants to watch all elements
   *    of entities in the subtree rooted at the entity's name in `target`. For
   *    descendants that are not the immediate children of the target, the
   *    `Change.element` will contain slashes.
   *
   *    Note that some namespaces and entities will not support recursive
   *    watching. When watching such an entity, a client must not set recursive
   *    to true. Otherwise, it will receive an `UNIMPLEMENTED` error.
   *
   * Normal URL encoding must be used inside `target`.  For example, if a query
   * parameter name or value, or the non-query parameter portion of `target`
   * contains a special character, it must be %-encoded.  We recommend that
   * clients and servers use their runtime's URL library to produce and consume
   * target values.
   */
  target: string;
  /**
   * The `resume_marker` specifies how much of the existing underlying state is
   * delivered to the client when the watch request is received by the
   * system. The client can set this marker in one of the following ways to get
   * different semantics:
   *
   * *   Parameter is not specified or has the value "".
   *     Semantics: Fetch initial state.
   *     The client wants the entity's initial state to be delivered. See the
   *     description in "Initial State".
   *
   * *   Parameter is set to the string "now" (UTF-8 encoding).
   *     Semantics: Fetch new changes only.
   *     The client just wants to get the changes received by the system after
   *     the watch point. The system may deliver changes from before the watch
   *     point as well.
   *
   * *   Parameter is set to a value received in an earlier
   *     `Change.resume_marker` field while watching the same entity.
   *     Semantics: Resume from a specific point.
   *     The client wants to receive the changes from a specific point; this
   *     value must correspond to a value received in the `Change.resume_marker`
   *     field. The system may deliver changes from before the `resume_marker`
   *     as well. If the system cannot resume the stream from this point (e.g.,
   *     if it is too far behind in the stream), it can raise the
   *     `FAILED_PRECONDITION` error.
   *
   * An implementation MUST support an unspecified parameter and the
   * empty string "" marker (initial state fetching) and the "now" marker.
   * It need not support resuming from a specific point.
   */
  resumeMarker: Buffer;
}

/** A batch of Change messages. */
export interface ChangeBatch {
  /** A list of Change messages. */
  changes: Change[];
}

/** A Change indicates the most recent state of an element. */
export interface Change {
  /**
   * Name of the element, interpreted relative to the entity's actual
   * name. "" refers to the entity itself. The element name is a valid
   * UTF-8 string.
   */
  element: string;
  /** The state of the `element`. */
  state: Change_State;
  /**
   * The actual change data. This field is present only when `state() == EXISTS`
   * or `state() == ERROR`. Please see
   * [google.protobuf.Any][google.protobuf.Any] about how to use the Any type.
   */
  data:
    | Any
    | undefined;
  /**
   * If present, provides a compact representation of all the messages that have
   * been received by the caller for the given entity, e.g., it could be a
   * sequence number or a multi-part timestamp/version vector. This marker can
   * be provided in the Request message, allowing the caller to resume the
   * stream watching at a specific point without fetching the initial state.
   */
  resumeMarker: Buffer;
  /**
   * If true, this Change is followed by more Changes that are in the same group
   * as this Change.
   */
  continued: boolean;
}

/** A reported value can be in one of the following states: */
export enum Change_State {
  /** EXISTS - The element exists and its full value is included in data. */
  EXISTS = 0,
  /** DOES_NOT_EXIST - The element does not exist. */
  DOES_NOT_EXIST = 1,
  /**
   * INITIAL_STATE_SKIPPED - Element may or may not exist. Used only for initial state delivery when
   * the client is not interested in fetching the initial state. See the
   * "Initial State" section above.
   */
  INITIAL_STATE_SKIPPED = 2,
  /**
   * ERROR - The element may exist, but some error has occurred. More information is
   * available in the data field - the value is a serialized Status
   * proto (from [google.rpc.Status][])
   */
  ERROR = 3,
  UNRECOGNIZED = -1,
}

export function change_StateFromJSON(object: any): Change_State {
  switch (object) {
    case 0:
    case "EXISTS":
      return Change_State.EXISTS;
    case 1:
    case "DOES_NOT_EXIST":
      return Change_State.DOES_NOT_EXIST;
    case 2:
    case "INITIAL_STATE_SKIPPED":
      return Change_State.INITIAL_STATE_SKIPPED;
    case 3:
    case "ERROR":
      return Change_State.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Change_State.UNRECOGNIZED;
  }
}

export function change_StateToJSON(object: Change_State): string {
  switch (object) {
    case Change_State.EXISTS:
      return "EXISTS";
    case Change_State.DOES_NOT_EXIST:
      return "DOES_NOT_EXIST";
    case Change_State.INITIAL_STATE_SKIPPED:
      return "INITIAL_STATE_SKIPPED";
    case Change_State.ERROR:
      return "ERROR";
    case Change_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseRequest(): Request {
  return { target: "", resumeMarker: Buffer.alloc(0) };
}

export const Request: MessageFns<Request> = {
  encode(message: Request, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.resumeMarker.length !== 0) {
      writer.uint32(18).bytes(message.resumeMarker);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Request {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resumeMarker = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Request {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      resumeMarker: isSet(object.resumeMarker) ? Buffer.from(bytesFromBase64(object.resumeMarker)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Request): unknown {
    const obj: any = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.resumeMarker.length !== 0) {
      obj.resumeMarker = base64FromBytes(message.resumeMarker);
    }
    return obj;
  },

  create(base?: DeepPartial<Request>): Request {
    return Request.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Request>): Request {
    const message = createBaseRequest();
    message.target = object.target ?? "";
    message.resumeMarker = object.resumeMarker ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseChangeBatch(): ChangeBatch {
  return { changes: [] };
}

export const ChangeBatch: MessageFns<ChangeBatch> = {
  encode(message: ChangeBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.changes) {
      Change.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeBatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.changes.push(Change.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeBatch {
    return {
      changes: globalThis.Array.isArray(object?.changes) ? object.changes.map((e: any) => Change.fromJSON(e)) : [],
    };
  },

  toJSON(message: ChangeBatch): unknown {
    const obj: any = {};
    if (message.changes?.length) {
      obj.changes = message.changes.map((e) => Change.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeBatch>): ChangeBatch {
    return ChangeBatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeBatch>): ChangeBatch {
    const message = createBaseChangeBatch();
    message.changes = object.changes?.map((e) => Change.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChange(): Change {
  return { element: "", state: 0, data: undefined, resumeMarker: Buffer.alloc(0), continued: false };
}

export const Change: MessageFns<Change> = {
  encode(message: Change, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.element !== "") {
      writer.uint32(10).string(message.element);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.data !== undefined) {
      Any.encode(message.data, writer.uint32(50).fork()).join();
    }
    if (message.resumeMarker.length !== 0) {
      writer.uint32(34).bytes(message.resumeMarker);
    }
    if (message.continued !== false) {
      writer.uint32(40).bool(message.continued);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Change {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.element = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.data = Any.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resumeMarker = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.continued = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Change {
    return {
      element: isSet(object.element) ? globalThis.String(object.element) : "",
      state: isSet(object.state) ? change_StateFromJSON(object.state) : 0,
      data: isSet(object.data) ? Any.fromJSON(object.data) : undefined,
      resumeMarker: isSet(object.resumeMarker) ? Buffer.from(bytesFromBase64(object.resumeMarker)) : Buffer.alloc(0),
      continued: isSet(object.continued) ? globalThis.Boolean(object.continued) : false,
    };
  },

  toJSON(message: Change): unknown {
    const obj: any = {};
    if (message.element !== "") {
      obj.element = message.element;
    }
    if (message.state !== 0) {
      obj.state = change_StateToJSON(message.state);
    }
    if (message.data !== undefined) {
      obj.data = Any.toJSON(message.data);
    }
    if (message.resumeMarker.length !== 0) {
      obj.resumeMarker = base64FromBytes(message.resumeMarker);
    }
    if (message.continued !== false) {
      obj.continued = message.continued;
    }
    return obj;
  },

  create(base?: DeepPartial<Change>): Change {
    return Change.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Change>): Change {
    const message = createBaseChange();
    message.element = object.element ?? "";
    message.state = object.state ?? 0;
    message.data = (object.data !== undefined && object.data !== null) ? Any.fromPartial(object.data) : undefined;
    message.resumeMarker = object.resumeMarker ?? Buffer.alloc(0);
    message.continued = object.continued ?? false;
    return message;
  },
};

/**
 * The service that a client uses to connect to the watcher system.
 * The errors returned by the service are in the canonical error space,
 * see [google.rpc.Code][].
 */
export type WatcherDefinition = typeof WatcherDefinition;
export const WatcherDefinition = {
  name: "Watcher",
  fullName: "google.watcher.v1.Watcher",
  methods: {
    /** Start a streaming RPC to get watch information from the server. */
    watch: {
      name: "Watch",
      requestType: Request,
      requestStream: false,
      responseType: ChangeBatch,
      responseStream: true,
      options: { _unknownFields: { 578365826: [Buffer.from([11, 18, 9, 47, 118, 49, 47, 119, 97, 116, 99, 104])] } },
    },
  },
} as const;

export interface WatcherServiceImplementation<CallContextExt = {}> {
  /** Start a streaming RPC to get watch information from the server. */
  watch(request: Request, context: CallContext & CallContextExt): ServerStreamingMethodResult<DeepPartial<ChangeBatch>>;
}

export interface WatcherClient<CallOptionsExt = {}> {
  /** Start a streaming RPC to get watch information from the server. */
  watch(request: DeepPartial<Request>, options?: CallOptions & CallOptionsExt): AsyncIterable<ChangeBatch>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
