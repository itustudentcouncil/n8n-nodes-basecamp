// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/streetview/publish/v1/rpcmessages.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Status } from "../../../rpc/status.js";
import { Photo, PhotoSequence } from "./resources.js";

export const protobufPackage = "google.streetview.publish.v1";

/**
 * Specifies which view of the [Photo][google.streetview.publish.v1.Photo]
 * to include in the response.
 */
export enum PhotoView {
  /**
   * BASIC - Server responses do not include the download URL for the photo bytes.
   * The default value.
   */
  BASIC = 0,
  /** INCLUDE_DOWNLOAD_URL - Server responses include the download URL for the photo bytes. */
  INCLUDE_DOWNLOAD_URL = 1,
  UNRECOGNIZED = -1,
}

export function photoViewFromJSON(object: any): PhotoView {
  switch (object) {
    case 0:
    case "BASIC":
      return PhotoView.BASIC;
    case 1:
    case "INCLUDE_DOWNLOAD_URL":
      return PhotoView.INCLUDE_DOWNLOAD_URL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PhotoView.UNRECOGNIZED;
  }
}

export function photoViewToJSON(object: PhotoView): string {
  switch (object) {
    case PhotoView.BASIC:
      return "BASIC";
    case PhotoView.INCLUDE_DOWNLOAD_URL:
      return "INCLUDE_DOWNLOAD_URL";
    case PhotoView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request to create a [Photo][google.streetview.publish.v1.Photo]. */
export interface CreatePhotoRequest {
  /** Required. Photo to create. */
  photo: Photo | undefined;
}

/**
 * Request to get a [Photo][google.streetview.publish.v1.Photo].
 *
 * By default
 *
 * * does not return the download URL for the photo bytes.
 *
 * Parameters:
 *
 * * `view` controls if the download URL for the photo bytes is returned.
 */
export interface GetPhotoRequest {
  /** Required. ID of the [Photo][google.streetview.publish.v1.Photo]. */
  photoId: string;
  /**
   * Required. Specifies if a download URL for the photo bytes should be
   * returned in the [Photo][google.streetview.publish.v1.Photo] response.
   */
  view: PhotoView;
  /**
   * The BCP-47 language code, such as "en-US" or "sr-Latn". For more
   * information, see
   * http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
   * If language_code is unspecified, the user's language preference for Google
   * services is used.
   */
  languageCode: string;
}

/**
 * Request to get one or more [Photos][google.streetview.publish.v1.Photo].
 * By default
 *
 * * does not return the download URL for the photo bytes.
 *
 * Parameters:
 *
 * * `view` controls if the download URL for the photo bytes is returned.
 */
export interface BatchGetPhotosRequest {
  /**
   * Required. IDs of the [Photos][google.streetview.publish.v1.Photo]. For HTTP
   * GET requests, the URL query parameter should be
   * `photoIds=<id1>&photoIds=<id2>&...`.
   */
  photoIds: string[];
  /**
   * Required. Specifies if a download URL for the photo bytes should be
   * returned in the Photo response.
   */
  view: PhotoView;
  /**
   * Optional. The BCP-47 language code, such as "en-US" or "sr-Latn". For more
   * information, see
   * http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
   * If language_code is unspecified, the user's language preference for Google
   * services is used.
   */
  languageCode: string;
}

/** Response to batch get of [Photos][google.streetview.publish.v1.Photo]. */
export interface BatchGetPhotosResponse {
  /**
   * List of results for each individual
   * [Photo][google.streetview.publish.v1.Photo] requested, in the same order as
   * the requests in
   * [BatchGetPhotos][google.streetview.publish.v1.StreetViewPublishService.BatchGetPhotos].
   */
  results: PhotoResponse[];
}

/**
 * Response payload for a single
 * [Photo][google.streetview.publish.v1.Photo]
 * in batch operations including
 * [BatchGetPhotos][google.streetview.publish.v1.StreetViewPublishService.BatchGetPhotos]
 * and
 * [BatchUpdatePhotos][google.streetview.publish.v1.StreetViewPublishService.BatchUpdatePhotos].
 */
export interface PhotoResponse {
  /**
   * The status for the operation to get or update a single photo in the batch
   * request.
   */
  status:
    | Status
    | undefined;
  /**
   * The [Photo][google.streetview.publish.v1.Photo] resource, if the request
   * was successful.
   */
  photo: Photo | undefined;
}

/**
 * Request to list all photos that belong to the user sending the request.
 *
 * By default
 *
 * * does not return the download URL for the photo bytes.
 *
 * Parameters:
 *
 * * `view` controls if the download URL for the photo bytes is returned.
 * * `pageSize` determines the maximum number of photos to return.
 * * `pageToken` is the next page token value returned from a previous
 * [ListPhotos][google.streetview.publish.v1.StreetViewPublishService.ListPhotos]
 *     request, if any.
 * * `filter` allows filtering by a given parameter. 'placeId' is the only
 * parameter supported at the moment.
 */
export interface ListPhotosRequest {
  /**
   * Required. Specifies if a download URL for the photos bytes should be
   * returned in the Photos response.
   */
  view: PhotoView;
  /**
   * Optional. The maximum number of photos to return.
   * `pageSize` must be non-negative. If `pageSize` is zero or is not provided,
   * the default page size of 100 is used.
   * The number of photos returned in the response may be less than `pageSize`
   * if the number of photos that belong to the user is less than `pageSize`.
   */
  pageSize: number;
  /**
   * Optional. The
   * [nextPageToken][google.streetview.publish.v1.ListPhotosResponse.next_page_token]
   * value returned from a previous
   * [ListPhotos][google.streetview.publish.v1.StreetViewPublishService.ListPhotos]
   * request, if any.
   */
  pageToken: string;
  /**
   * Optional. The filter expression. For example:
   * `placeId=ChIJj61dQgK6j4AR4GeTYWZsKWw`.
   *
   * The filters supported are: `placeId`, `min_latitude`, `max_latitude`,
   * `min_longitude`, `max_longitude`. See https://google.aip.dev/160 for more
   * information.
   */
  filter: string;
  /**
   * Optional. The BCP-47 language code, such as "en-US" or "sr-Latn". For more
   * information, see
   * http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
   * If language_code is unspecified, the user's language preference for Google
   * services is used.
   */
  languageCode: string;
}

/** Response to list all photos that belong to a user. */
export interface ListPhotosResponse {
  /**
   * List of photos. The
   * [pageSize][google.streetview.publish.v1.ListPhotosRequest.page_size] field
   * in the request determines the number of items returned.
   */
  photos: Photo[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/**
 * Request to update the metadata of a
 * [Photo][google.streetview.publish.v1.Photo]. Updating the pixels of a photo
 * is not supported.
 */
export interface UpdatePhotoRequest {
  /**
   * Required. [Photo][google.streetview.publish.v1.Photo] object containing the
   * new metadata.
   */
  photo:
    | Photo
    | undefined;
  /**
   * Required. Mask that identifies fields on the photo metadata to update.
   * If not present, the old [Photo][google.streetview.publish.v1.Photo]
   * metadata is entirely replaced with the
   * new [Photo][google.streetview.publish.v1.Photo] metadata in this request.
   * The update fails if invalid fields are specified. Multiple fields can be
   * specified in a comma-delimited list.
   *
   * The following fields are valid:
   *
   * * `pose.heading`
   * * `pose.lat_lng_pair`
   * * `pose.pitch`
   * * `pose.roll`
   * * `pose.level`
   * * `pose.altitude`
   * * `connections`
   * * `places`
   *
   * > Note: When
   * [updateMask][google.streetview.publish.v1.UpdatePhotoRequest.update_mask]
   * contains repeated fields, the entire set of repeated values get replaced
   * with the new contents. For example, if
   * [updateMask][google.streetview.publish.v1.UpdatePhotoRequest.update_mask]
   * contains `connections` and `UpdatePhotoRequest.photo.connections` is empty,
   * all connections are removed.
   */
  updateMask: string[] | undefined;
}

/**
 * Request to update the metadata of photos.
 * Updating the pixels of photos is not supported.
 */
export interface BatchUpdatePhotosRequest {
  /**
   * Required. List of
   * [UpdatePhotoRequests][google.streetview.publish.v1.UpdatePhotoRequest].
   */
  updatePhotoRequests: UpdatePhotoRequest[];
}

/**
 * Response to batch update of metadata of one or more
 * [Photos][google.streetview.publish.v1.Photo].
 */
export interface BatchUpdatePhotosResponse {
  /**
   * List of results for each individual
   * [Photo][google.streetview.publish.v1.Photo] updated, in the same order as
   * the request.
   */
  results: PhotoResponse[];
}

/** Request to delete a [Photo][google.streetview.publish.v1.Photo]. */
export interface DeletePhotoRequest {
  /** Required. ID of the [Photo][google.streetview.publish.v1.Photo]. */
  photoId: string;
}

/** Request to delete multiple [Photos][google.streetview.publish.v1.Photo]. */
export interface BatchDeletePhotosRequest {
  /**
   * Required. IDs of the [Photos][google.streetview.publish.v1.Photo]. HTTP
   * GET requests require the following syntax for the URL query parameter:
   * `photoIds=<id1>&photoIds=<id2>&...`.
   */
  photoIds: string[];
}

/**
 * Request to create a
 * [PhotoSequence][google.streetview.publish.v1.PhotoSequence] from a video.
 */
export interface CreatePhotoSequenceRequest {
  /**
   * Required. [PhotoSequence][google.streetview.publish.v1.PhotoSequence] to
   * create.
   */
  photoSequence:
    | PhotoSequence
    | undefined;
  /**
   * Required. The input form of
   * [PhotoSequence][google.streetview.publish.v1.PhotoSequence].
   */
  inputType: CreatePhotoSequenceRequest_InputType;
}

/** Input forms of [PhotoSequence][google.streetview.publish.v1.PhotoSequence]. */
export enum CreatePhotoSequenceRequest_InputType {
  /**
   * INPUT_TYPE_UNSPECIFIED - Not specified. Server will return
   * [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
   */
  INPUT_TYPE_UNSPECIFIED = 0,
  /** VIDEO - 360 Video. */
  VIDEO = 1,
  /** XDM - Extensible Device Metadata, http://www.xdm.org */
  XDM = 2,
  UNRECOGNIZED = -1,
}

export function createPhotoSequenceRequest_InputTypeFromJSON(object: any): CreatePhotoSequenceRequest_InputType {
  switch (object) {
    case 0:
    case "INPUT_TYPE_UNSPECIFIED":
      return CreatePhotoSequenceRequest_InputType.INPUT_TYPE_UNSPECIFIED;
    case 1:
    case "VIDEO":
      return CreatePhotoSequenceRequest_InputType.VIDEO;
    case 2:
    case "XDM":
      return CreatePhotoSequenceRequest_InputType.XDM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CreatePhotoSequenceRequest_InputType.UNRECOGNIZED;
  }
}

export function createPhotoSequenceRequest_InputTypeToJSON(object: CreatePhotoSequenceRequest_InputType): string {
  switch (object) {
    case CreatePhotoSequenceRequest_InputType.INPUT_TYPE_UNSPECIFIED:
      return "INPUT_TYPE_UNSPECIFIED";
    case CreatePhotoSequenceRequest_InputType.VIDEO:
      return "VIDEO";
    case CreatePhotoSequenceRequest_InputType.XDM:
      return "XDM";
    case CreatePhotoSequenceRequest_InputType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Request to get a [PhotoSequence][google.streetview.publish.v1.PhotoSequence].
 *
 * By default
 *
 * * does not return the download URL for the
 * [PhotoSequence][google.streetview.publish.v1.PhotoSequence].
 *
 * Parameters:
 *
 * * `view` controls if the download URL for the
 * [PhotoSequence][google.streetview.publish.v1.PhotoSequence] is
 *   returned.
 */
export interface GetPhotoSequenceRequest {
  /** Required. ID of the photo sequence. */
  sequenceId: string;
  /**
   * Specifies if a download URL for the photo sequence should be returned in
   * `download_url` of individual photos in the
   * [PhotoSequence][google.streetview.publish.v1.PhotoSequence] response.
   * > Note: Currently not implemented.
   *
   * @deprecated
   */
  view: PhotoView;
  /**
   * Optional. The filter expression. For example: `published_status=PUBLISHED`.
   *
   * The filters supported are: `published_status`.  See
   * https://google.aip.dev/160 for more information.
   */
  filter: string;
}

/**
 * Request to delete a
 * [PhotoSequence][google.streetview.publish.v1.PhotoSequence].
 */
export interface DeletePhotoSequenceRequest {
  /**
   * Required. ID of the
   * [PhotoSequence][google.streetview.publish.v1.PhotoSequence].
   */
  sequenceId: string;
}

/**
 * Response to batch delete of one or more
 * [Photos][google.streetview.publish.v1.Photo].
 */
export interface BatchDeletePhotosResponse {
  /**
   * The status for the operation to delete a single
   * [Photo][google.streetview.publish.v1.Photo] in the batch request.
   */
  status: Status[];
}

/**
 * Request to list all photo sequences that belong to the user sending the
 * request.
 *
 * Parameters:
 *
 * * `pageSize` determines the maximum number of photo sequences to return.
 * * `pageToken` is the next page token value returned from a previous
 * [ListPhotoSequences][google.streetview.publish.v1.StreetViewPublishService.ListPhotoSequences]
 *   request, if any.
 */
export interface ListPhotoSequencesRequest {
  /**
   * Optional. The maximum number of photo sequences to return.
   * `pageSize` must be non-negative. If `pageSize` is zero or is not
   * provided, the default page size of 100 is used.
   * The number of photo sequences returned in the response may be less than
   * `pageSize` if the number of matches is less than `pageSize`.
   * This is currently unimplemented but is in process.
   */
  pageSize: number;
  /**
   * Optional. The
   * [nextPageToken][google.streetview.publish.v1.ListPhotosResponse.next_page_token]
   * value returned from a previous
   * [ListPhotoSequences][google.streetview.publish.v1.StreetViewPublishService.ListPhotoSequences]
   * request, if any.
   */
  pageToken: string;
  /**
   * Optional. The filter expression. For example: `imagery_type=SPHERICAL`.
   *
   * The filters supported are: `imagery_type`, `processing_state`,
   * `min_latitude`, `max_latitude`, `min_longitude`, `max_longitude`,
   * `filename_query`, `min_capture_time_seconds`, `max_capture_time_seconds.
   * See https://google.aip.dev/160 for more information. Filename queries
   * should sent as a Phrase in order to support multiple words and special
   * characters by adding escaped quotes. Ex: filename_query="example of a
   * phrase.mp4"
   */
  filter: string;
}

/** Response to list all photo sequences that belong to a user. */
export interface ListPhotoSequencesResponse {
  /**
   * List of photo sequences via [Operation][google.longrunning.Operation]
   * interface.
   *
   * The maximum number of items returned is based on the
   * [pageSize][google.streetview.publish.v1.ListPhotoSequencesRequest.page_size]
   * field in the request.
   *
   * Each item in the list can have three possible states,
   *
   * * `Operation.done` = false, if the processing of
   *   [PhotoSequence][google.streetview.publish.v1.PhotoSequence] is not
   *   finished yet.
   * * `Operation.done` = true and `Operation.error` is populated, if there was
   *   an error in processing.
   * * `Operation.done` = true and `Operation.response` contains a
   *   [PhotoSequence][google.streetview.publish.v1.PhotoSequence] message,
   *   In each sequence, only
   *   [Id][google.streetview.publish.v1.PhotoSequence.id] is populated.
   */
  photoSequences: Operation[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

function createBaseCreatePhotoRequest(): CreatePhotoRequest {
  return { photo: undefined };
}

export const CreatePhotoRequest: MessageFns<CreatePhotoRequest> = {
  encode(message: CreatePhotoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.photo !== undefined) {
      Photo.encode(message.photo, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePhotoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePhotoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.photo = Photo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePhotoRequest {
    return { photo: isSet(object.photo) ? Photo.fromJSON(object.photo) : undefined };
  },

  toJSON(message: CreatePhotoRequest): unknown {
    const obj: any = {};
    if (message.photo !== undefined) {
      obj.photo = Photo.toJSON(message.photo);
    }
    return obj;
  },

  create(base?: DeepPartial<CreatePhotoRequest>): CreatePhotoRequest {
    return CreatePhotoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreatePhotoRequest>): CreatePhotoRequest {
    const message = createBaseCreatePhotoRequest();
    message.photo = (object.photo !== undefined && object.photo !== null) ? Photo.fromPartial(object.photo) : undefined;
    return message;
  },
};

function createBaseGetPhotoRequest(): GetPhotoRequest {
  return { photoId: "", view: 0, languageCode: "" };
}

export const GetPhotoRequest: MessageFns<GetPhotoRequest> = {
  encode(message: GetPhotoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.photoId !== "") {
      writer.uint32(10).string(message.photoId);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPhotoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPhotoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.photoId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPhotoRequest {
    return {
      photoId: isSet(object.photoId) ? globalThis.String(object.photoId) : "",
      view: isSet(object.view) ? photoViewFromJSON(object.view) : 0,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: GetPhotoRequest): unknown {
    const obj: any = {};
    if (message.photoId !== "") {
      obj.photoId = message.photoId;
    }
    if (message.view !== 0) {
      obj.view = photoViewToJSON(message.view);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPhotoRequest>): GetPhotoRequest {
    return GetPhotoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPhotoRequest>): GetPhotoRequest {
    const message = createBaseGetPhotoRequest();
    message.photoId = object.photoId ?? "";
    message.view = object.view ?? 0;
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseBatchGetPhotosRequest(): BatchGetPhotosRequest {
  return { photoIds: [], view: 0, languageCode: "" };
}

export const BatchGetPhotosRequest: MessageFns<BatchGetPhotosRequest> = {
  encode(message: BatchGetPhotosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.photoIds) {
      writer.uint32(10).string(v!);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    if (message.languageCode !== "") {
      writer.uint32(26).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGetPhotosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetPhotosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.photoIds.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetPhotosRequest {
    return {
      photoIds: globalThis.Array.isArray(object?.photoIds) ? object.photoIds.map((e: any) => globalThis.String(e)) : [],
      view: isSet(object.view) ? photoViewFromJSON(object.view) : 0,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: BatchGetPhotosRequest): unknown {
    const obj: any = {};
    if (message.photoIds?.length) {
      obj.photoIds = message.photoIds;
    }
    if (message.view !== 0) {
      obj.view = photoViewToJSON(message.view);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchGetPhotosRequest>): BatchGetPhotosRequest {
    return BatchGetPhotosRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchGetPhotosRequest>): BatchGetPhotosRequest {
    const message = createBaseBatchGetPhotosRequest();
    message.photoIds = object.photoIds?.map((e) => e) || [];
    message.view = object.view ?? 0;
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseBatchGetPhotosResponse(): BatchGetPhotosResponse {
  return { results: [] };
}

export const BatchGetPhotosResponse: MessageFns<BatchGetPhotosResponse> = {
  encode(message: BatchGetPhotosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      PhotoResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchGetPhotosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchGetPhotosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(PhotoResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchGetPhotosResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => PhotoResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchGetPhotosResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => PhotoResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchGetPhotosResponse>): BatchGetPhotosResponse {
    return BatchGetPhotosResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchGetPhotosResponse>): BatchGetPhotosResponse {
    const message = createBaseBatchGetPhotosResponse();
    message.results = object.results?.map((e) => PhotoResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBasePhotoResponse(): PhotoResponse {
  return { status: undefined, photo: undefined };
}

export const PhotoResponse: MessageFns<PhotoResponse> = {
  encode(message: PhotoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.photo !== undefined) {
      Photo.encode(message.photo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhotoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhotoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.photo = Photo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhotoResponse {
    return {
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      photo: isSet(object.photo) ? Photo.fromJSON(object.photo) : undefined,
    };
  },

  toJSON(message: PhotoResponse): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.photo !== undefined) {
      obj.photo = Photo.toJSON(message.photo);
    }
    return obj;
  },

  create(base?: DeepPartial<PhotoResponse>): PhotoResponse {
    return PhotoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhotoResponse>): PhotoResponse {
    const message = createBasePhotoResponse();
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.photo = (object.photo !== undefined && object.photo !== null) ? Photo.fromPartial(object.photo) : undefined;
    return message;
  },
};

function createBaseListPhotosRequest(): ListPhotosRequest {
  return { view: 0, pageSize: 0, pageToken: "", filter: "", languageCode: "" };
}

export const ListPhotosRequest: MessageFns<ListPhotosRequest> = {
  encode(message: ListPhotosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.view !== 0) {
      writer.uint32(8).int32(message.view);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.languageCode !== "") {
      writer.uint32(42).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPhotosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPhotosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPhotosRequest {
    return {
      view: isSet(object.view) ? photoViewFromJSON(object.view) : 0,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: ListPhotosRequest): unknown {
    const obj: any = {};
    if (message.view !== 0) {
      obj.view = photoViewToJSON(message.view);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPhotosRequest>): ListPhotosRequest {
    return ListPhotosRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPhotosRequest>): ListPhotosRequest {
    const message = createBaseListPhotosRequest();
    message.view = object.view ?? 0;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseListPhotosResponse(): ListPhotosResponse {
  return { photos: [], nextPageToken: "" };
}

export const ListPhotosResponse: MessageFns<ListPhotosResponse> = {
  encode(message: ListPhotosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.photos) {
      Photo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPhotosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPhotosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.photos.push(Photo.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPhotosResponse {
    return {
      photos: globalThis.Array.isArray(object?.photos) ? object.photos.map((e: any) => Photo.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPhotosResponse): unknown {
    const obj: any = {};
    if (message.photos?.length) {
      obj.photos = message.photos.map((e) => Photo.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPhotosResponse>): ListPhotosResponse {
    return ListPhotosResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPhotosResponse>): ListPhotosResponse {
    const message = createBaseListPhotosResponse();
    message.photos = object.photos?.map((e) => Photo.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdatePhotoRequest(): UpdatePhotoRequest {
  return { photo: undefined, updateMask: undefined };
}

export const UpdatePhotoRequest: MessageFns<UpdatePhotoRequest> = {
  encode(message: UpdatePhotoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.photo !== undefined) {
      Photo.encode(message.photo, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePhotoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePhotoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.photo = Photo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePhotoRequest {
    return {
      photo: isSet(object.photo) ? Photo.fromJSON(object.photo) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdatePhotoRequest): unknown {
    const obj: any = {};
    if (message.photo !== undefined) {
      obj.photo = Photo.toJSON(message.photo);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePhotoRequest>): UpdatePhotoRequest {
    return UpdatePhotoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePhotoRequest>): UpdatePhotoRequest {
    const message = createBaseUpdatePhotoRequest();
    message.photo = (object.photo !== undefined && object.photo !== null) ? Photo.fromPartial(object.photo) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseBatchUpdatePhotosRequest(): BatchUpdatePhotosRequest {
  return { updatePhotoRequests: [] };
}

export const BatchUpdatePhotosRequest: MessageFns<BatchUpdatePhotosRequest> = {
  encode(message: BatchUpdatePhotosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.updatePhotoRequests) {
      UpdatePhotoRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdatePhotosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdatePhotosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updatePhotoRequests.push(UpdatePhotoRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdatePhotosRequest {
    return {
      updatePhotoRequests: globalThis.Array.isArray(object?.updatePhotoRequests)
        ? object.updatePhotoRequests.map((e: any) => UpdatePhotoRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdatePhotosRequest): unknown {
    const obj: any = {};
    if (message.updatePhotoRequests?.length) {
      obj.updatePhotoRequests = message.updatePhotoRequests.map((e) => UpdatePhotoRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdatePhotosRequest>): BatchUpdatePhotosRequest {
    return BatchUpdatePhotosRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdatePhotosRequest>): BatchUpdatePhotosRequest {
    const message = createBaseBatchUpdatePhotosRequest();
    message.updatePhotoRequests = object.updatePhotoRequests?.map((e) => UpdatePhotoRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchUpdatePhotosResponse(): BatchUpdatePhotosResponse {
  return { results: [] };
}

export const BatchUpdatePhotosResponse: MessageFns<BatchUpdatePhotosResponse> = {
  encode(message: BatchUpdatePhotosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      PhotoResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdatePhotosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdatePhotosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(PhotoResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdatePhotosResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => PhotoResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdatePhotosResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => PhotoResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdatePhotosResponse>): BatchUpdatePhotosResponse {
    return BatchUpdatePhotosResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdatePhotosResponse>): BatchUpdatePhotosResponse {
    const message = createBaseBatchUpdatePhotosResponse();
    message.results = object.results?.map((e) => PhotoResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeletePhotoRequest(): DeletePhotoRequest {
  return { photoId: "" };
}

export const DeletePhotoRequest: MessageFns<DeletePhotoRequest> = {
  encode(message: DeletePhotoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.photoId !== "") {
      writer.uint32(10).string(message.photoId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePhotoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePhotoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.photoId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePhotoRequest {
    return { photoId: isSet(object.photoId) ? globalThis.String(object.photoId) : "" };
  },

  toJSON(message: DeletePhotoRequest): unknown {
    const obj: any = {};
    if (message.photoId !== "") {
      obj.photoId = message.photoId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeletePhotoRequest>): DeletePhotoRequest {
    return DeletePhotoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeletePhotoRequest>): DeletePhotoRequest {
    const message = createBaseDeletePhotoRequest();
    message.photoId = object.photoId ?? "";
    return message;
  },
};

function createBaseBatchDeletePhotosRequest(): BatchDeletePhotosRequest {
  return { photoIds: [] };
}

export const BatchDeletePhotosRequest: MessageFns<BatchDeletePhotosRequest> = {
  encode(message: BatchDeletePhotosRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.photoIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeletePhotosRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeletePhotosRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.photoIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeletePhotosRequest {
    return {
      photoIds: globalThis.Array.isArray(object?.photoIds) ? object.photoIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BatchDeletePhotosRequest): unknown {
    const obj: any = {};
    if (message.photoIds?.length) {
      obj.photoIds = message.photoIds;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeletePhotosRequest>): BatchDeletePhotosRequest {
    return BatchDeletePhotosRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeletePhotosRequest>): BatchDeletePhotosRequest {
    const message = createBaseBatchDeletePhotosRequest();
    message.photoIds = object.photoIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreatePhotoSequenceRequest(): CreatePhotoSequenceRequest {
  return { photoSequence: undefined, inputType: 0 };
}

export const CreatePhotoSequenceRequest: MessageFns<CreatePhotoSequenceRequest> = {
  encode(message: CreatePhotoSequenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.photoSequence !== undefined) {
      PhotoSequence.encode(message.photoSequence, writer.uint32(10).fork()).join();
    }
    if (message.inputType !== 0) {
      writer.uint32(16).int32(message.inputType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePhotoSequenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePhotoSequenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.photoSequence = PhotoSequence.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inputType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePhotoSequenceRequest {
    return {
      photoSequence: isSet(object.photoSequence) ? PhotoSequence.fromJSON(object.photoSequence) : undefined,
      inputType: isSet(object.inputType) ? createPhotoSequenceRequest_InputTypeFromJSON(object.inputType) : 0,
    };
  },

  toJSON(message: CreatePhotoSequenceRequest): unknown {
    const obj: any = {};
    if (message.photoSequence !== undefined) {
      obj.photoSequence = PhotoSequence.toJSON(message.photoSequence);
    }
    if (message.inputType !== 0) {
      obj.inputType = createPhotoSequenceRequest_InputTypeToJSON(message.inputType);
    }
    return obj;
  },

  create(base?: DeepPartial<CreatePhotoSequenceRequest>): CreatePhotoSequenceRequest {
    return CreatePhotoSequenceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreatePhotoSequenceRequest>): CreatePhotoSequenceRequest {
    const message = createBaseCreatePhotoSequenceRequest();
    message.photoSequence = (object.photoSequence !== undefined && object.photoSequence !== null)
      ? PhotoSequence.fromPartial(object.photoSequence)
      : undefined;
    message.inputType = object.inputType ?? 0;
    return message;
  },
};

function createBaseGetPhotoSequenceRequest(): GetPhotoSequenceRequest {
  return { sequenceId: "", view: 0, filter: "" };
}

export const GetPhotoSequenceRequest: MessageFns<GetPhotoSequenceRequest> = {
  encode(message: GetPhotoSequenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sequenceId !== "") {
      writer.uint32(10).string(message.sequenceId);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPhotoSequenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPhotoSequenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sequenceId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPhotoSequenceRequest {
    return {
      sequenceId: isSet(object.sequenceId) ? globalThis.String(object.sequenceId) : "",
      view: isSet(object.view) ? photoViewFromJSON(object.view) : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: GetPhotoSequenceRequest): unknown {
    const obj: any = {};
    if (message.sequenceId !== "") {
      obj.sequenceId = message.sequenceId;
    }
    if (message.view !== 0) {
      obj.view = photoViewToJSON(message.view);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPhotoSequenceRequest>): GetPhotoSequenceRequest {
    return GetPhotoSequenceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPhotoSequenceRequest>): GetPhotoSequenceRequest {
    const message = createBaseGetPhotoSequenceRequest();
    message.sequenceId = object.sequenceId ?? "";
    message.view = object.view ?? 0;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseDeletePhotoSequenceRequest(): DeletePhotoSequenceRequest {
  return { sequenceId: "" };
}

export const DeletePhotoSequenceRequest: MessageFns<DeletePhotoSequenceRequest> = {
  encode(message: DeletePhotoSequenceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sequenceId !== "") {
      writer.uint32(10).string(message.sequenceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePhotoSequenceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePhotoSequenceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sequenceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePhotoSequenceRequest {
    return { sequenceId: isSet(object.sequenceId) ? globalThis.String(object.sequenceId) : "" };
  },

  toJSON(message: DeletePhotoSequenceRequest): unknown {
    const obj: any = {};
    if (message.sequenceId !== "") {
      obj.sequenceId = message.sequenceId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeletePhotoSequenceRequest>): DeletePhotoSequenceRequest {
    return DeletePhotoSequenceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeletePhotoSequenceRequest>): DeletePhotoSequenceRequest {
    const message = createBaseDeletePhotoSequenceRequest();
    message.sequenceId = object.sequenceId ?? "";
    return message;
  },
};

function createBaseBatchDeletePhotosResponse(): BatchDeletePhotosResponse {
  return { status: [] };
}

export const BatchDeletePhotosResponse: MessageFns<BatchDeletePhotosResponse> = {
  encode(message: BatchDeletePhotosResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.status) {
      Status.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeletePhotosResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeletePhotosResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.status.push(Status.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeletePhotosResponse {
    return {
      status: globalThis.Array.isArray(object?.status) ? object.status.map((e: any) => Status.fromJSON(e)) : [],
    };
  },

  toJSON(message: BatchDeletePhotosResponse): unknown {
    const obj: any = {};
    if (message.status?.length) {
      obj.status = message.status.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeletePhotosResponse>): BatchDeletePhotosResponse {
    return BatchDeletePhotosResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeletePhotosResponse>): BatchDeletePhotosResponse {
    const message = createBaseBatchDeletePhotosResponse();
    message.status = object.status?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListPhotoSequencesRequest(): ListPhotoSequencesRequest {
  return { pageSize: 0, pageToken: "", filter: "" };
}

export const ListPhotoSequencesRequest: MessageFns<ListPhotoSequencesRequest> = {
  encode(message: ListPhotoSequencesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPhotoSequencesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPhotoSequencesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPhotoSequencesRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListPhotoSequencesRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPhotoSequencesRequest>): ListPhotoSequencesRequest {
    return ListPhotoSequencesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPhotoSequencesRequest>): ListPhotoSequencesRequest {
    const message = createBaseListPhotoSequencesRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListPhotoSequencesResponse(): ListPhotoSequencesResponse {
  return { photoSequences: [], nextPageToken: "" };
}

export const ListPhotoSequencesResponse: MessageFns<ListPhotoSequencesResponse> = {
  encode(message: ListPhotoSequencesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.photoSequences) {
      Operation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPhotoSequencesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPhotoSequencesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.photoSequences.push(Operation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPhotoSequencesResponse {
    return {
      photoSequences: globalThis.Array.isArray(object?.photoSequences)
        ? object.photoSequences.map((e: any) => Operation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPhotoSequencesResponse): unknown {
    const obj: any = {};
    if (message.photoSequences?.length) {
      obj.photoSequences = message.photoSequences.map((e) => Operation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPhotoSequencesResponse>): ListPhotoSequencesResponse {
    return ListPhotoSequencesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPhotoSequencesResponse>): ListPhotoSequencesResponse {
    const message = createBaseListPhotoSequencesResponse();
    message.photoSequences = object.photoSequences?.map((e) => Operation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
