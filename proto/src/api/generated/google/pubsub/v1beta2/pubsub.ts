// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/pubsub/v1beta2/pubsub.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../protobuf/empty.js";

export const protobufPackage = "google.pubsub.v1beta2";

/** A topic resource. */
export interface Topic {
  /** Name of the topic. */
  name: string;
}

/** A message data and its attributes. */
export interface PubsubMessage {
  /**
   * The message payload. For JSON requests, the value of this field must be
   * base64-encoded.
   */
  data: Buffer;
  /** Optional attributes for this message. */
  attributes: { [key: string]: string };
  /**
   * ID of this message assigned by the server at publication time. Guaranteed
   * to be unique within the topic. This value may be read by a subscriber
   * that receives a PubsubMessage via a Pull call or a push delivery. It must
   * not be populated by a publisher in a Publish call.
   */
  messageId: string;
}

export interface PubsubMessage_AttributesEntry {
  key: string;
  value: string;
}

/** Request for the GetTopic method. */
export interface GetTopicRequest {
  /** The name of the topic to get. */
  topic: string;
}

/** Request for the Publish method. */
export interface PublishRequest {
  /** The messages in the request will be published on this topic. */
  topic: string;
  /** The messages to publish. */
  messages: PubsubMessage[];
}

/** Response for the Publish method. */
export interface PublishResponse {
  /**
   * The server-assigned ID of each published message, in the same order as
   * the messages in the request. IDs are guaranteed to be unique within
   * the topic.
   */
  messageIds: string[];
}

/** Request for the ListTopics method. */
export interface ListTopicsRequest {
  /** The name of the cloud project that topics belong to. */
  project: string;
  /** Maximum number of topics to return. */
  pageSize: number;
  /**
   * The value returned by the last ListTopicsResponse; indicates that this is
   * a continuation of a prior ListTopics call, and that the system should
   * return the next page of data.
   */
  pageToken: string;
}

/** Response for the ListTopics method. */
export interface ListTopicsResponse {
  /** The resulting topics. */
  topics: Topic[];
  /**
   * If not empty, indicates that there may be more topics that match the
   * request; this value should be passed in a new ListTopicsRequest.
   */
  nextPageToken: string;
}

/** Request for the ListTopicSubscriptions method. */
export interface ListTopicSubscriptionsRequest {
  /** The name of the topic that subscriptions are attached to. */
  topic: string;
  /** Maximum number of subscription names to return. */
  pageSize: number;
  /**
   * The value returned by the last ListTopicSubscriptionsResponse; indicates
   * that this is a continuation of a prior ListTopicSubscriptions call, and
   * that the system should return the next page of data.
   */
  pageToken: string;
}

/** Response for the ListTopicSubscriptions method. */
export interface ListTopicSubscriptionsResponse {
  /** The names of the subscriptions that match the request. */
  subscriptions: string[];
  /**
   * If not empty, indicates that there may be more subscriptions that match
   * the request; this value should be passed in a new
   * ListTopicSubscriptionsRequest to get more subscriptions.
   */
  nextPageToken: string;
}

/** Request for the DeleteTopic method. */
export interface DeleteTopicRequest {
  /** Name of the topic to delete. */
  topic: string;
}

/** A subscription resource. */
export interface Subscription {
  /** Name of the subscription. */
  name: string;
  /**
   * The name of the topic from which this subscription is receiving messages.
   * This will be present if and only if the subscription has not been detached
   * from its topic.
   */
  topic: string;
  /**
   * If push delivery is used with this subscription, this field is
   * used to configure it. An empty pushConfig signifies that the subscriber
   * will pull and ack messages using API methods.
   */
  pushConfig:
    | PushConfig
    | undefined;
  /**
   * This value is the maximum time after a subscriber receives a message
   * before the subscriber should acknowledge the message. After message
   * delivery but before the ack deadline expires and before the message is
   * acknowledged, it is an outstanding message and will not be delivered
   * again during that time (on a best-effort basis).
   *
   * For pull delivery this value
   * is used as the initial value for the ack deadline. It may be overridden
   * for a specific message by calling ModifyAckDeadline.
   *
   * For push delivery, this value is also used to set the request timeout for
   * the call to the push endpoint.
   *
   * If the subscriber never acknowledges the message, the Pub/Sub
   * system will eventually redeliver the message.
   */
  ackDeadlineSeconds: number;
}

/** Configuration for a push delivery endpoint. */
export interface PushConfig {
  /**
   * A URL locating the endpoint to which messages should be pushed.
   * For example, a Webhook endpoint might use "https://example.com/push".
   */
  pushEndpoint: string;
  /**
   * Endpoint configuration attributes.
   *
   * Every endpoint has a set of API supported attributes that can be used to
   * control different aspects of the message delivery.
   *
   * The currently supported attribute is `x-goog-version`, which you can
   * use to change the format of the push message. This attribute
   * indicates the version of the data expected by the endpoint. This
   * controls the shape of the envelope (i.e. its fields and metadata).
   * The endpoint version is based on the version of the Pub/Sub
   * API.
   *
   * If not present during the CreateSubscription call, it will default to
   * the version of the API used to make such call. If not present during a
   * ModifyPushConfig call, its value will not be changed. GetSubscription
   * calls will always return a valid version, even if the subscription was
   * created without this attribute.
   *
   * The possible values for this attribute are:
   *
   * * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.
   * * `v1beta2`: uses the push format defined in the v1beta2 Pub/Sub API.
   */
  attributes: { [key: string]: string };
}

export interface PushConfig_AttributesEntry {
  key: string;
  value: string;
}

/** A message and its corresponding acknowledgment ID. */
export interface ReceivedMessage {
  /** This ID can be used to acknowledge the received message. */
  ackId: string;
  /** The message. */
  message: PubsubMessage | undefined;
}

/** Request for the GetSubscription method. */
export interface GetSubscriptionRequest {
  /** The name of the subscription to get. */
  subscription: string;
}

/** Request for the ListSubscriptions method. */
export interface ListSubscriptionsRequest {
  /** The name of the cloud project that subscriptions belong to. */
  project: string;
  /** Maximum number of subscriptions to return. */
  pageSize: number;
  /**
   * The value returned by the last ListSubscriptionsResponse; indicates that
   * this is a continuation of a prior ListSubscriptions call, and that the
   * system should return the next page of data.
   */
  pageToken: string;
}

/** Response for the ListSubscriptions method. */
export interface ListSubscriptionsResponse {
  /** The subscriptions that match the request. */
  subscriptions: Subscription[];
  /**
   * If not empty, indicates that there may be more subscriptions that match
   * the request; this value should be passed in a new ListSubscriptionsRequest
   * to get more subscriptions.
   */
  nextPageToken: string;
}

/** Request for the DeleteSubscription method. */
export interface DeleteSubscriptionRequest {
  /** The subscription to delete. */
  subscription: string;
}

/** Request for the ModifyPushConfig method. */
export interface ModifyPushConfigRequest {
  /** The name of the subscription. */
  subscription: string;
  /**
   * The push configuration for future deliveries.
   *
   * An empty pushConfig indicates that the Pub/Sub system should
   * stop pushing messages from the given subscription and allow
   * messages to be pulled and acknowledged - effectively pausing
   * the subscription if Pull is not called.
   */
  pushConfig: PushConfig | undefined;
}

/** Request for the Pull method. */
export interface PullRequest {
  /** The subscription from which messages should be pulled. */
  subscription: string;
  /**
   * If this is specified as true the system will respond immediately even if
   * it is not able to return a message in the Pull response. Otherwise the
   * system is allowed to wait until at least one message is available rather
   * than returning no messages. The client may cancel the request if it does
   * not wish to wait any longer for the response.
   */
  returnImmediately: boolean;
  /**
   * The maximum number of messages returned for this request. The Pub/Sub
   * system may return fewer than the number specified.
   */
  maxMessages: number;
}

/** Response for the Pull method. */
export interface PullResponse {
  /**
   * Received Pub/Sub messages. The Pub/Sub system will return zero messages if
   * there are no more available in the backlog. The Pub/Sub system may return
   * fewer than the maxMessages requested even if there are more messages
   * available in the backlog.
   */
  receivedMessages: ReceivedMessage[];
}

/** Request for the ModifyAckDeadline method. */
export interface ModifyAckDeadlineRequest {
  /** The name of the subscription. */
  subscription: string;
  /** The acknowledgment ID. */
  ackId: string;
  /**
   * The new ack deadline with respect to the time this request was sent to the
   * Pub/Sub system. Must be >= 0. For example, if the value is 10, the new ack
   * deadline will expire 10 seconds after the ModifyAckDeadline call was made.
   * Specifying zero may immediately make the message available for another pull
   * request.
   */
  ackDeadlineSeconds: number;
}

/** Request for the Acknowledge method. */
export interface AcknowledgeRequest {
  /** The subscription whose message is being acknowledged. */
  subscription: string;
  /**
   * The acknowledgment ID for the messages being acknowledged that was returned
   * by the Pub/Sub system in the Pull response. Must not be empty.
   */
  ackIds: string[];
}

function createBaseTopic(): Topic {
  return { name: "" };
}

export const Topic: MessageFns<Topic> = {
  encode(message: Topic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Topic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Topic {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: Topic): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<Topic>): Topic {
    return Topic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Topic>): Topic {
    const message = createBaseTopic();
    message.name = object.name ?? "";
    return message;
  },
};

function createBasePubsubMessage(): PubsubMessage {
  return { data: Buffer.alloc(0), attributes: {}, messageId: "" };
}

export const PubsubMessage: MessageFns<PubsubMessage> = {
  encode(message: PubsubMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      PubsubMessage_AttributesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.messageId !== "") {
      writer.uint32(26).string(message.messageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubsubMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsubMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = PubsubMessage_AttributesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.attributes[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messageId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubsubMessage {
    return {
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
    };
  },

  toJSON(message: PubsubMessage): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    return obj;
  },

  create(base?: DeepPartial<PubsubMessage>): PubsubMessage {
    return PubsubMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PubsubMessage>): PubsubMessage {
    const message = createBasePubsubMessage();
    message.data = object.data ?? Buffer.alloc(0);
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.messageId = object.messageId ?? "";
    return message;
  },
};

function createBasePubsubMessage_AttributesEntry(): PubsubMessage_AttributesEntry {
  return { key: "", value: "" };
}

export const PubsubMessage_AttributesEntry: MessageFns<PubsubMessage_AttributesEntry> = {
  encode(message: PubsubMessage_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubsubMessage_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubsubMessage_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubsubMessage_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PubsubMessage_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PubsubMessage_AttributesEntry>): PubsubMessage_AttributesEntry {
    return PubsubMessage_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PubsubMessage_AttributesEntry>): PubsubMessage_AttributesEntry {
    const message = createBasePubsubMessage_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetTopicRequest(): GetTopicRequest {
  return { topic: "" };
}

export const GetTopicRequest: MessageFns<GetTopicRequest> = {
  encode(message: GetTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicRequest {
    return { topic: isSet(object.topic) ? globalThis.String(object.topic) : "" };
  },

  toJSON(message: GetTopicRequest): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    return obj;
  },

  create(base?: DeepPartial<GetTopicRequest>): GetTopicRequest {
    return GetTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTopicRequest>): GetTopicRequest {
    const message = createBaseGetTopicRequest();
    message.topic = object.topic ?? "";
    return message;
  },
};

function createBasePublishRequest(): PublishRequest {
  return { topic: "", messages: [] };
}

export const PublishRequest: MessageFns<PublishRequest> = {
  encode(message: PublishRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    for (const v of message.messages) {
      PubsubMessage.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.messages.push(PubsubMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishRequest {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => PubsubMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PublishRequest): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => PubsubMessage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PublishRequest>): PublishRequest {
    return PublishRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishRequest>): PublishRequest {
    const message = createBasePublishRequest();
    message.topic = object.topic ?? "";
    message.messages = object.messages?.map((e) => PubsubMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBasePublishResponse(): PublishResponse {
  return { messageIds: [] };
}

export const PublishResponse: MessageFns<PublishResponse> = {
  encode(message: PublishResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messageIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublishResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublishResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messageIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublishResponse {
    return {
      messageIds: globalThis.Array.isArray(object?.messageIds)
        ? object.messageIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PublishResponse): unknown {
    const obj: any = {};
    if (message.messageIds?.length) {
      obj.messageIds = message.messageIds;
    }
    return obj;
  },

  create(base?: DeepPartial<PublishResponse>): PublishResponse {
    return PublishResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublishResponse>): PublishResponse {
    const message = createBasePublishResponse();
    message.messageIds = object.messageIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseListTopicsRequest(): ListTopicsRequest {
  return { project: "", pageSize: 0, pageToken: "" };
}

export const ListTopicsRequest: MessageFns<ListTopicsRequest> = {
  encode(message: ListTopicsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicsRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTopicsRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTopicsRequest>): ListTopicsRequest {
    return ListTopicsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTopicsRequest>): ListTopicsRequest {
    const message = createBaseListTopicsRequest();
    message.project = object.project ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTopicsResponse(): ListTopicsResponse {
  return { topics: [], nextPageToken: "" };
}

export const ListTopicsResponse: MessageFns<ListTopicsResponse> = {
  encode(message: ListTopicsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topics) {
      Topic.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topics.push(Topic.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicsResponse {
    return {
      topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e: any) => Topic.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTopicsResponse): unknown {
    const obj: any = {};
    if (message.topics?.length) {
      obj.topics = message.topics.map((e) => Topic.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTopicsResponse>): ListTopicsResponse {
    return ListTopicsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTopicsResponse>): ListTopicsResponse {
    const message = createBaseListTopicsResponse();
    message.topics = object.topics?.map((e) => Topic.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListTopicSubscriptionsRequest(): ListTopicSubscriptionsRequest {
  return { topic: "", pageSize: 0, pageToken: "" };
}

export const ListTopicSubscriptionsRequest: MessageFns<ListTopicSubscriptionsRequest> = {
  encode(message: ListTopicSubscriptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicSubscriptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicSubscriptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicSubscriptionsRequest {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTopicSubscriptionsRequest): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTopicSubscriptionsRequest>): ListTopicSubscriptionsRequest {
    return ListTopicSubscriptionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTopicSubscriptionsRequest>): ListTopicSubscriptionsRequest {
    const message = createBaseListTopicSubscriptionsRequest();
    message.topic = object.topic ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListTopicSubscriptionsResponse(): ListTopicSubscriptionsResponse {
  return { subscriptions: [], nextPageToken: "" };
}

export const ListTopicSubscriptionsResponse: MessageFns<ListTopicSubscriptionsResponse> = {
  encode(message: ListTopicSubscriptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subscriptions) {
      writer.uint32(10).string(v!);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicSubscriptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptions.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicSubscriptionsResponse {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => globalThis.String(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTopicSubscriptionsResponse): unknown {
    const obj: any = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTopicSubscriptionsResponse>): ListTopicSubscriptionsResponse {
    return ListTopicSubscriptionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTopicSubscriptionsResponse>): ListTopicSubscriptionsResponse {
    const message = createBaseListTopicSubscriptionsResponse();
    message.subscriptions = object.subscriptions?.map((e) => e) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteTopicRequest(): DeleteTopicRequest {
  return { topic: "" };
}

export const DeleteTopicRequest: MessageFns<DeleteTopicRequest> = {
  encode(message: DeleteTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTopicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTopicRequest {
    return { topic: isSet(object.topic) ? globalThis.String(object.topic) : "" };
  },

  toJSON(message: DeleteTopicRequest): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTopicRequest>): DeleteTopicRequest {
    return DeleteTopicRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTopicRequest>): DeleteTopicRequest {
    const message = createBaseDeleteTopicRequest();
    message.topic = object.topic ?? "";
    return message;
  },
};

function createBaseSubscription(): Subscription {
  return { name: "", topic: "", pushConfig: undefined, ackDeadlineSeconds: 0 };
}

export const Subscription: MessageFns<Subscription> = {
  encode(message: Subscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.topic !== "") {
      writer.uint32(18).string(message.topic);
    }
    if (message.pushConfig !== undefined) {
      PushConfig.encode(message.pushConfig, writer.uint32(34).fork()).join();
    }
    if (message.ackDeadlineSeconds !== 0) {
      writer.uint32(40).int32(message.ackDeadlineSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pushConfig = PushConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ackDeadlineSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subscription {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      pushConfig: isSet(object.pushConfig) ? PushConfig.fromJSON(object.pushConfig) : undefined,
      ackDeadlineSeconds: isSet(object.ackDeadlineSeconds) ? globalThis.Number(object.ackDeadlineSeconds) : 0,
    };
  },

  toJSON(message: Subscription): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.pushConfig !== undefined) {
      obj.pushConfig = PushConfig.toJSON(message.pushConfig);
    }
    if (message.ackDeadlineSeconds !== 0) {
      obj.ackDeadlineSeconds = Math.round(message.ackDeadlineSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<Subscription>): Subscription {
    return Subscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subscription>): Subscription {
    const message = createBaseSubscription();
    message.name = object.name ?? "";
    message.topic = object.topic ?? "";
    message.pushConfig = (object.pushConfig !== undefined && object.pushConfig !== null)
      ? PushConfig.fromPartial(object.pushConfig)
      : undefined;
    message.ackDeadlineSeconds = object.ackDeadlineSeconds ?? 0;
    return message;
  },
};

function createBasePushConfig(): PushConfig {
  return { pushEndpoint: "", attributes: {} };
}

export const PushConfig: MessageFns<PushConfig> = {
  encode(message: PushConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pushEndpoint !== "") {
      writer.uint32(10).string(message.pushEndpoint);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      PushConfig_AttributesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PushConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePushConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pushEndpoint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = PushConfig_AttributesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.attributes[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PushConfig {
    return {
      pushEndpoint: isSet(object.pushEndpoint) ? globalThis.String(object.pushEndpoint) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PushConfig): unknown {
    const obj: any = {};
    if (message.pushEndpoint !== "") {
      obj.pushEndpoint = message.pushEndpoint;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<PushConfig>): PushConfig {
    return PushConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PushConfig>): PushConfig {
    const message = createBasePushConfig();
    message.pushEndpoint = object.pushEndpoint ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBasePushConfig_AttributesEntry(): PushConfig_AttributesEntry {
  return { key: "", value: "" };
}

export const PushConfig_AttributesEntry: MessageFns<PushConfig_AttributesEntry> = {
  encode(message: PushConfig_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PushConfig_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePushConfig_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PushConfig_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PushConfig_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PushConfig_AttributesEntry>): PushConfig_AttributesEntry {
    return PushConfig_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PushConfig_AttributesEntry>): PushConfig_AttributesEntry {
    const message = createBasePushConfig_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseReceivedMessage(): ReceivedMessage {
  return { ackId: "", message: undefined };
}

export const ReceivedMessage: MessageFns<ReceivedMessage> = {
  encode(message: ReceivedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ackId !== "") {
      writer.uint32(10).string(message.ackId);
    }
    if (message.message !== undefined) {
      PubsubMessage.encode(message.message, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReceivedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceivedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ackId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = PubsubMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReceivedMessage {
    return {
      ackId: isSet(object.ackId) ? globalThis.String(object.ackId) : "",
      message: isSet(object.message) ? PubsubMessage.fromJSON(object.message) : undefined,
    };
  },

  toJSON(message: ReceivedMessage): unknown {
    const obj: any = {};
    if (message.ackId !== "") {
      obj.ackId = message.ackId;
    }
    if (message.message !== undefined) {
      obj.message = PubsubMessage.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<ReceivedMessage>): ReceivedMessage {
    return ReceivedMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReceivedMessage>): ReceivedMessage {
    const message = createBaseReceivedMessage();
    message.ackId = object.ackId ?? "";
    message.message = (object.message !== undefined && object.message !== null)
      ? PubsubMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseGetSubscriptionRequest(): GetSubscriptionRequest {
  return { subscription: "" };
}

export const GetSubscriptionRequest: MessageFns<GetSubscriptionRequest> = {
  encode(message: GetSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscription !== "") {
      writer.uint32(10).string(message.subscription);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscription = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubscriptionRequest {
    return { subscription: isSet(object.subscription) ? globalThis.String(object.subscription) : "" };
  },

  toJSON(message: GetSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.subscription !== "") {
      obj.subscription = message.subscription;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSubscriptionRequest>): GetSubscriptionRequest {
    return GetSubscriptionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSubscriptionRequest>): GetSubscriptionRequest {
    const message = createBaseGetSubscriptionRequest();
    message.subscription = object.subscription ?? "";
    return message;
  },
};

function createBaseListSubscriptionsRequest(): ListSubscriptionsRequest {
  return { project: "", pageSize: 0, pageToken: "" };
}

export const ListSubscriptionsRequest: MessageFns<ListSubscriptionsRequest> = {
  encode(message: ListSubscriptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubscriptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscriptionsRequest {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSubscriptionsRequest): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubscriptionsRequest>): ListSubscriptionsRequest {
    return ListSubscriptionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubscriptionsRequest>): ListSubscriptionsRequest {
    const message = createBaseListSubscriptionsRequest();
    message.project = object.project ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSubscriptionsResponse(): ListSubscriptionsResponse {
  return { subscriptions: [], nextPageToken: "" };
}

export const ListSubscriptionsResponse: MessageFns<ListSubscriptionsResponse> = {
  encode(message: ListSubscriptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subscriptions) {
      Subscription.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubscriptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptions.push(Subscription.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubscriptionsResponse {
    return {
      subscriptions: globalThis.Array.isArray(object?.subscriptions)
        ? object.subscriptions.map((e: any) => Subscription.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSubscriptionsResponse): unknown {
    const obj: any = {};
    if (message.subscriptions?.length) {
      obj.subscriptions = message.subscriptions.map((e) => Subscription.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubscriptionsResponse>): ListSubscriptionsResponse {
    return ListSubscriptionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubscriptionsResponse>): ListSubscriptionsResponse {
    const message = createBaseListSubscriptionsResponse();
    message.subscriptions = object.subscriptions?.map((e) => Subscription.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteSubscriptionRequest(): DeleteSubscriptionRequest {
  return { subscription: "" };
}

export const DeleteSubscriptionRequest: MessageFns<DeleteSubscriptionRequest> = {
  encode(message: DeleteSubscriptionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscription !== "") {
      writer.uint32(10).string(message.subscription);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSubscriptionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSubscriptionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscription = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSubscriptionRequest {
    return { subscription: isSet(object.subscription) ? globalThis.String(object.subscription) : "" };
  },

  toJSON(message: DeleteSubscriptionRequest): unknown {
    const obj: any = {};
    if (message.subscription !== "") {
      obj.subscription = message.subscription;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSubscriptionRequest>): DeleteSubscriptionRequest {
    return DeleteSubscriptionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSubscriptionRequest>): DeleteSubscriptionRequest {
    const message = createBaseDeleteSubscriptionRequest();
    message.subscription = object.subscription ?? "";
    return message;
  },
};

function createBaseModifyPushConfigRequest(): ModifyPushConfigRequest {
  return { subscription: "", pushConfig: undefined };
}

export const ModifyPushConfigRequest: MessageFns<ModifyPushConfigRequest> = {
  encode(message: ModifyPushConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscription !== "") {
      writer.uint32(10).string(message.subscription);
    }
    if (message.pushConfig !== undefined) {
      PushConfig.encode(message.pushConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModifyPushConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModifyPushConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscription = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pushConfig = PushConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModifyPushConfigRequest {
    return {
      subscription: isSet(object.subscription) ? globalThis.String(object.subscription) : "",
      pushConfig: isSet(object.pushConfig) ? PushConfig.fromJSON(object.pushConfig) : undefined,
    };
  },

  toJSON(message: ModifyPushConfigRequest): unknown {
    const obj: any = {};
    if (message.subscription !== "") {
      obj.subscription = message.subscription;
    }
    if (message.pushConfig !== undefined) {
      obj.pushConfig = PushConfig.toJSON(message.pushConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ModifyPushConfigRequest>): ModifyPushConfigRequest {
    return ModifyPushConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModifyPushConfigRequest>): ModifyPushConfigRequest {
    const message = createBaseModifyPushConfigRequest();
    message.subscription = object.subscription ?? "";
    message.pushConfig = (object.pushConfig !== undefined && object.pushConfig !== null)
      ? PushConfig.fromPartial(object.pushConfig)
      : undefined;
    return message;
  },
};

function createBasePullRequest(): PullRequest {
  return { subscription: "", returnImmediately: false, maxMessages: 0 };
}

export const PullRequest: MessageFns<PullRequest> = {
  encode(message: PullRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscription !== "") {
      writer.uint32(10).string(message.subscription);
    }
    if (message.returnImmediately !== false) {
      writer.uint32(16).bool(message.returnImmediately);
    }
    if (message.maxMessages !== 0) {
      writer.uint32(24).int32(message.maxMessages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PullRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePullRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscription = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.returnImmediately = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxMessages = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PullRequest {
    return {
      subscription: isSet(object.subscription) ? globalThis.String(object.subscription) : "",
      returnImmediately: isSet(object.returnImmediately) ? globalThis.Boolean(object.returnImmediately) : false,
      maxMessages: isSet(object.maxMessages) ? globalThis.Number(object.maxMessages) : 0,
    };
  },

  toJSON(message: PullRequest): unknown {
    const obj: any = {};
    if (message.subscription !== "") {
      obj.subscription = message.subscription;
    }
    if (message.returnImmediately !== false) {
      obj.returnImmediately = message.returnImmediately;
    }
    if (message.maxMessages !== 0) {
      obj.maxMessages = Math.round(message.maxMessages);
    }
    return obj;
  },

  create(base?: DeepPartial<PullRequest>): PullRequest {
    return PullRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PullRequest>): PullRequest {
    const message = createBasePullRequest();
    message.subscription = object.subscription ?? "";
    message.returnImmediately = object.returnImmediately ?? false;
    message.maxMessages = object.maxMessages ?? 0;
    return message;
  },
};

function createBasePullResponse(): PullResponse {
  return { receivedMessages: [] };
}

export const PullResponse: MessageFns<PullResponse> = {
  encode(message: PullResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.receivedMessages) {
      ReceivedMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PullResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePullResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.receivedMessages.push(ReceivedMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PullResponse {
    return {
      receivedMessages: globalThis.Array.isArray(object?.receivedMessages)
        ? object.receivedMessages.map((e: any) => ReceivedMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PullResponse): unknown {
    const obj: any = {};
    if (message.receivedMessages?.length) {
      obj.receivedMessages = message.receivedMessages.map((e) => ReceivedMessage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PullResponse>): PullResponse {
    return PullResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PullResponse>): PullResponse {
    const message = createBasePullResponse();
    message.receivedMessages = object.receivedMessages?.map((e) => ReceivedMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseModifyAckDeadlineRequest(): ModifyAckDeadlineRequest {
  return { subscription: "", ackId: "", ackDeadlineSeconds: 0 };
}

export const ModifyAckDeadlineRequest: MessageFns<ModifyAckDeadlineRequest> = {
  encode(message: ModifyAckDeadlineRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscription !== "") {
      writer.uint32(10).string(message.subscription);
    }
    if (message.ackId !== "") {
      writer.uint32(18).string(message.ackId);
    }
    if (message.ackDeadlineSeconds !== 0) {
      writer.uint32(24).int32(message.ackDeadlineSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModifyAckDeadlineRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModifyAckDeadlineRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscription = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ackId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ackDeadlineSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModifyAckDeadlineRequest {
    return {
      subscription: isSet(object.subscription) ? globalThis.String(object.subscription) : "",
      ackId: isSet(object.ackId) ? globalThis.String(object.ackId) : "",
      ackDeadlineSeconds: isSet(object.ackDeadlineSeconds) ? globalThis.Number(object.ackDeadlineSeconds) : 0,
    };
  },

  toJSON(message: ModifyAckDeadlineRequest): unknown {
    const obj: any = {};
    if (message.subscription !== "") {
      obj.subscription = message.subscription;
    }
    if (message.ackId !== "") {
      obj.ackId = message.ackId;
    }
    if (message.ackDeadlineSeconds !== 0) {
      obj.ackDeadlineSeconds = Math.round(message.ackDeadlineSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<ModifyAckDeadlineRequest>): ModifyAckDeadlineRequest {
    return ModifyAckDeadlineRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ModifyAckDeadlineRequest>): ModifyAckDeadlineRequest {
    const message = createBaseModifyAckDeadlineRequest();
    message.subscription = object.subscription ?? "";
    message.ackId = object.ackId ?? "";
    message.ackDeadlineSeconds = object.ackDeadlineSeconds ?? 0;
    return message;
  },
};

function createBaseAcknowledgeRequest(): AcknowledgeRequest {
  return { subscription: "", ackIds: [] };
}

export const AcknowledgeRequest: MessageFns<AcknowledgeRequest> = {
  encode(message: AcknowledgeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscription !== "") {
      writer.uint32(10).string(message.subscription);
    }
    for (const v of message.ackIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcknowledgeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscription = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ackIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcknowledgeRequest {
    return {
      subscription: isSet(object.subscription) ? globalThis.String(object.subscription) : "",
      ackIds: globalThis.Array.isArray(object?.ackIds) ? object.ackIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AcknowledgeRequest): unknown {
    const obj: any = {};
    if (message.subscription !== "") {
      obj.subscription = message.subscription;
    }
    if (message.ackIds?.length) {
      obj.ackIds = message.ackIds;
    }
    return obj;
  },

  create(base?: DeepPartial<AcknowledgeRequest>): AcknowledgeRequest {
    return AcknowledgeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcknowledgeRequest>): AcknowledgeRequest {
    const message = createBaseAcknowledgeRequest();
    message.subscription = object.subscription ?? "";
    message.ackIds = object.ackIds?.map((e) => e) || [];
    return message;
  },
};

/**
 * The service that an application uses to manipulate subscriptions and to
 * consume messages from a subscription via the Pull method.
 */
export type SubscriberDefinition = typeof SubscriberDefinition;
export const SubscriberDefinition = {
  name: "Subscriber",
  fullName: "google.pubsub.v1beta2.Subscriber",
  methods: {
    /**
     * Creates a subscription to a given topic for a given subscriber.
     * If the subscription already exists, returns ALREADY_EXISTS.
     * If the corresponding topic doesn't exist, returns NOT_FOUND.
     *
     * If the name is not provided in the request, the server will assign a random
     * name for this subscription on the same project as the topic.
     */
    createSubscription: {
      name: "CreateSubscription",
      requestType: Subscription,
      requestStream: false,
      responseType: Subscription,
      responseStream: false,
      options: {},
    },
    /** Gets the configuration details of a subscription. */
    getSubscription: {
      name: "GetSubscription",
      requestType: GetSubscriptionRequest,
      requestStream: false,
      responseType: Subscription,
      responseStream: false,
      options: {},
    },
    /** Lists matching subscriptions. */
    listSubscriptions: {
      name: "ListSubscriptions",
      requestType: ListSubscriptionsRequest,
      requestStream: false,
      responseType: ListSubscriptionsResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Deletes an existing subscription. All pending messages in the subscription
     * are immediately dropped. Calls to Pull after deletion will return
     * NOT_FOUND. After a subscription is deleted, a new one may be created with
     * the same name, but the new one has no association with the old
     * subscription, or its topic unless the same topic is specified.
     */
    deleteSubscription: {
      name: "DeleteSubscription",
      requestType: DeleteSubscriptionRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /**
     * Modifies the ack deadline for a specific message. This method is useful to
     * indicate that more time is needed to process a message by the subscriber,
     * or to make the message available for redelivery if the processing was
     * interrupted.
     */
    modifyAckDeadline: {
      name: "ModifyAckDeadline",
      requestType: ModifyAckDeadlineRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /**
     * Acknowledges the messages associated with the ack tokens in the
     * AcknowledgeRequest. The Pub/Sub system can remove the relevant messages
     * from the subscription.
     *
     * Acknowledging a message whose ack deadline has expired may succeed,
     * but such a message may be redelivered later. Acknowledging a message more
     * than once will not result in an error.
     */
    acknowledge: {
      name: "Acknowledge",
      requestType: AcknowledgeRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /**
     * Pulls messages from the server. Returns an empty list if there are no
     * messages available in the backlog. The server may return UNAVAILABLE if
     * there are too many concurrent pull requests pending for the given
     * subscription.
     */
    pull: {
      name: "Pull",
      requestType: PullRequest,
      requestStream: false,
      responseType: PullResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Modifies the PushConfig for a specified subscription.
     *
     * This may be used to change a push subscription to a pull one (signified
     * by an empty PushConfig) or vice versa, or change the endpoint URL and other
     * attributes of a push subscription. Messages will accumulate for
     * delivery continuously through the call regardless of changes to the
     * PushConfig.
     */
    modifyPushConfig: {
      name: "ModifyPushConfig",
      requestType: ModifyPushConfigRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface SubscriberServiceImplementation<CallContextExt = {}> {
  /**
   * Creates a subscription to a given topic for a given subscriber.
   * If the subscription already exists, returns ALREADY_EXISTS.
   * If the corresponding topic doesn't exist, returns NOT_FOUND.
   *
   * If the name is not provided in the request, the server will assign a random
   * name for this subscription on the same project as the topic.
   */
  createSubscription(request: Subscription, context: CallContext & CallContextExt): Promise<DeepPartial<Subscription>>;
  /** Gets the configuration details of a subscription. */
  getSubscription(
    request: GetSubscriptionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Subscription>>;
  /** Lists matching subscriptions. */
  listSubscriptions(
    request: ListSubscriptionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSubscriptionsResponse>>;
  /**
   * Deletes an existing subscription. All pending messages in the subscription
   * are immediately dropped. Calls to Pull after deletion will return
   * NOT_FOUND. After a subscription is deleted, a new one may be created with
   * the same name, but the new one has no association with the old
   * subscription, or its topic unless the same topic is specified.
   */
  deleteSubscription(
    request: DeleteSubscriptionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Modifies the ack deadline for a specific message. This method is useful to
   * indicate that more time is needed to process a message by the subscriber,
   * or to make the message available for redelivery if the processing was
   * interrupted.
   */
  modifyAckDeadline(
    request: ModifyAckDeadlineRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Acknowledges the messages associated with the ack tokens in the
   * AcknowledgeRequest. The Pub/Sub system can remove the relevant messages
   * from the subscription.
   *
   * Acknowledging a message whose ack deadline has expired may succeed,
   * but such a message may be redelivered later. Acknowledging a message more
   * than once will not result in an error.
   */
  acknowledge(request: AcknowledgeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Pulls messages from the server. Returns an empty list if there are no
   * messages available in the backlog. The server may return UNAVAILABLE if
   * there are too many concurrent pull requests pending for the given
   * subscription.
   */
  pull(request: PullRequest, context: CallContext & CallContextExt): Promise<DeepPartial<PullResponse>>;
  /**
   * Modifies the PushConfig for a specified subscription.
   *
   * This may be used to change a push subscription to a pull one (signified
   * by an empty PushConfig) or vice versa, or change the endpoint URL and other
   * attributes of a push subscription. Messages will accumulate for
   * delivery continuously through the call regardless of changes to the
   * PushConfig.
   */
  modifyPushConfig(
    request: ModifyPushConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface SubscriberClient<CallOptionsExt = {}> {
  /**
   * Creates a subscription to a given topic for a given subscriber.
   * If the subscription already exists, returns ALREADY_EXISTS.
   * If the corresponding topic doesn't exist, returns NOT_FOUND.
   *
   * If the name is not provided in the request, the server will assign a random
   * name for this subscription on the same project as the topic.
   */
  createSubscription(request: DeepPartial<Subscription>, options?: CallOptions & CallOptionsExt): Promise<Subscription>;
  /** Gets the configuration details of a subscription. */
  getSubscription(
    request: DeepPartial<GetSubscriptionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Subscription>;
  /** Lists matching subscriptions. */
  listSubscriptions(
    request: DeepPartial<ListSubscriptionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSubscriptionsResponse>;
  /**
   * Deletes an existing subscription. All pending messages in the subscription
   * are immediately dropped. Calls to Pull after deletion will return
   * NOT_FOUND. After a subscription is deleted, a new one may be created with
   * the same name, but the new one has no association with the old
   * subscription, or its topic unless the same topic is specified.
   */
  deleteSubscription(
    request: DeepPartial<DeleteSubscriptionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Modifies the ack deadline for a specific message. This method is useful to
   * indicate that more time is needed to process a message by the subscriber,
   * or to make the message available for redelivery if the processing was
   * interrupted.
   */
  modifyAckDeadline(
    request: DeepPartial<ModifyAckDeadlineRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Acknowledges the messages associated with the ack tokens in the
   * AcknowledgeRequest. The Pub/Sub system can remove the relevant messages
   * from the subscription.
   *
   * Acknowledging a message whose ack deadline has expired may succeed,
   * but such a message may be redelivered later. Acknowledging a message more
   * than once will not result in an error.
   */
  acknowledge(request: DeepPartial<AcknowledgeRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Pulls messages from the server. Returns an empty list if there are no
   * messages available in the backlog. The server may return UNAVAILABLE if
   * there are too many concurrent pull requests pending for the given
   * subscription.
   */
  pull(request: DeepPartial<PullRequest>, options?: CallOptions & CallOptionsExt): Promise<PullResponse>;
  /**
   * Modifies the PushConfig for a specified subscription.
   *
   * This may be used to change a push subscription to a pull one (signified
   * by an empty PushConfig) or vice versa, or change the endpoint URL and other
   * attributes of a push subscription. Messages will accumulate for
   * delivery continuously through the call regardless of changes to the
   * PushConfig.
   */
  modifyPushConfig(
    request: DeepPartial<ModifyPushConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

/**
 * The service that an application uses to manipulate topics, and to send
 * messages to a topic.
 */
export type PublisherDefinition = typeof PublisherDefinition;
export const PublisherDefinition = {
  name: "Publisher",
  fullName: "google.pubsub.v1beta2.Publisher",
  methods: {
    /** Creates the given topic with the given name. */
    createTopic: {
      name: "CreateTopic",
      requestType: Topic,
      requestStream: false,
      responseType: Topic,
      responseStream: false,
      options: {},
    },
    /**
     * Adds one or more messages to the topic. Returns NOT_FOUND if the topic does
     * not exist.
     */
    publish: {
      name: "Publish",
      requestType: PublishRequest,
      requestStream: false,
      responseType: PublishResponse,
      responseStream: false,
      options: {},
    },
    /** Gets the configuration of a topic. */
    getTopic: {
      name: "GetTopic",
      requestType: GetTopicRequest,
      requestStream: false,
      responseType: Topic,
      responseStream: false,
      options: {},
    },
    /** Lists matching topics. */
    listTopics: {
      name: "ListTopics",
      requestType: ListTopicsRequest,
      requestStream: false,
      responseType: ListTopicsResponse,
      responseStream: false,
      options: {},
    },
    /** Lists the name of the subscriptions for this topic. */
    listTopicSubscriptions: {
      name: "ListTopicSubscriptions",
      requestType: ListTopicSubscriptionsRequest,
      requestStream: false,
      responseType: ListTopicSubscriptionsResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Deletes the topic with the given name. Returns NOT_FOUND if the topic does
     * not exist. After a topic is deleted, a new topic may be created with the
     * same name; this is an entirely new topic with none of the old
     * configuration or subscriptions. Existing subscriptions to this topic are
     * not deleted.
     */
    deleteTopic: {
      name: "DeleteTopic",
      requestType: DeleteTopicRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface PublisherServiceImplementation<CallContextExt = {}> {
  /** Creates the given topic with the given name. */
  createTopic(request: Topic, context: CallContext & CallContextExt): Promise<DeepPartial<Topic>>;
  /**
   * Adds one or more messages to the topic. Returns NOT_FOUND if the topic does
   * not exist.
   */
  publish(request: PublishRequest, context: CallContext & CallContextExt): Promise<DeepPartial<PublishResponse>>;
  /** Gets the configuration of a topic. */
  getTopic(request: GetTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Topic>>;
  /** Lists matching topics. */
  listTopics(
    request: ListTopicsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTopicsResponse>>;
  /** Lists the name of the subscriptions for this topic. */
  listTopicSubscriptions(
    request: ListTopicSubscriptionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTopicSubscriptionsResponse>>;
  /**
   * Deletes the topic with the given name. Returns NOT_FOUND if the topic does
   * not exist. After a topic is deleted, a new topic may be created with the
   * same name; this is an entirely new topic with none of the old
   * configuration or subscriptions. Existing subscriptions to this topic are
   * not deleted.
   */
  deleteTopic(request: DeleteTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface PublisherClient<CallOptionsExt = {}> {
  /** Creates the given topic with the given name. */
  createTopic(request: DeepPartial<Topic>, options?: CallOptions & CallOptionsExt): Promise<Topic>;
  /**
   * Adds one or more messages to the topic. Returns NOT_FOUND if the topic does
   * not exist.
   */
  publish(request: DeepPartial<PublishRequest>, options?: CallOptions & CallOptionsExt): Promise<PublishResponse>;
  /** Gets the configuration of a topic. */
  getTopic(request: DeepPartial<GetTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Topic>;
  /** Lists matching topics. */
  listTopics(
    request: DeepPartial<ListTopicsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTopicsResponse>;
  /** Lists the name of the subscriptions for this topic. */
  listTopicSubscriptions(
    request: DeepPartial<ListTopicSubscriptionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTopicSubscriptionsResponse>;
  /**
   * Deletes the topic with the given name. Returns NOT_FOUND if the topic does
   * not exist. After a topic is deleted, a new topic may be created with the
   * same name; this is an entirely new topic with none of the old
   * configuration or subscriptions. Existing subscriptions to this topic are
   * not deleted.
   */
  deleteTopic(request: DeepPartial<DeleteTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
