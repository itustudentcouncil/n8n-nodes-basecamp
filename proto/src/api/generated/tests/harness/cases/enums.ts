// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: tests/harness/cases/enums.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  Embed_DoubleEmbed_DoubleEnumerated,
  embed_DoubleEmbed_DoubleEnumeratedFromJSON,
  embed_DoubleEmbed_DoubleEnumeratedToJSON,
  Embed_Enumerated,
  embed_EnumeratedFromJSON,
  embed_EnumeratedToJSON,
  Embed_FooNumber,
  embed_FooNumberFromJSON,
  embed_FooNumberToJSON,
} from "./other_package/embed.js";
import { Direction, directionFromJSON, directionToJSON } from "./sort/sort.js";
import {
  Embed_BarNumber,
  embed_BarNumberFromJSON,
  embed_BarNumberToJSON,
  Embed_Enumerated as Embed_Enumerated1,
  embed_EnumeratedFromJSON as embed_EnumeratedFromJSON2,
  embed_EnumeratedToJSON as embed_EnumeratedToJSON3,
} from "./yet_another_package/embed.js";

export const protobufPackage = "tests.harness.cases";

export enum TestEnum {
  ZERO = 0,
  ONE = 1,
  TWO = 2,
  UNRECOGNIZED = -1,
}

export function testEnumFromJSON(object: any): TestEnum {
  switch (object) {
    case 0:
    case "ZERO":
      return TestEnum.ZERO;
    case 1:
    case "ONE":
      return TestEnum.ONE;
    case 2:
    case "TWO":
      return TestEnum.TWO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestEnum.UNRECOGNIZED;
  }
}

export function testEnumToJSON(object: TestEnum): string {
  switch (object) {
    case TestEnum.ZERO:
      return "ZERO";
    case TestEnum.ONE:
      return "ONE";
    case TestEnum.TWO:
      return "TWO";
    case TestEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TestEnumAlias {
  A = 0,
  B = 1,
  C = 2,
  ALPHA = 0,
  BETA = 1,
  GAMMA = 2,
  UNRECOGNIZED = -1,
}

export function testEnumAliasFromJSON(object: any): TestEnumAlias {
  switch (object) {
    case 0:
    case "A":
      return TestEnumAlias.A;
    case 1:
    case "B":
      return TestEnumAlias.B;
    case 2:
    case "C":
      return TestEnumAlias.C;
    case 0:
    case "ALPHA":
      return TestEnumAlias.ALPHA;
    case 1:
    case "BETA":
      return TestEnumAlias.BETA;
    case 2:
    case "GAMMA":
      return TestEnumAlias.GAMMA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TestEnumAlias.UNRECOGNIZED;
  }
}

export function testEnumAliasToJSON(object: TestEnumAlias): string {
  switch (object) {
    case TestEnumAlias.A:
      return "A";
    case TestEnumAlias.B:
      return "B";
    case TestEnumAlias.C:
      return "C";
    case TestEnumAlias.ALPHA:
      return "ALPHA";
    case TestEnumAlias.BETA:
      return "BETA";
    case TestEnumAlias.GAMMA:
      return "GAMMA";
    case TestEnumAlias.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EnumNone {
  val: TestEnum;
}

export interface EnumConst {
  val: TestEnum;
}

export interface EnumAliasConst {
  val: TestEnumAlias;
}

export interface EnumDefined {
  val: TestEnum;
}

export interface EnumAliasDefined {
  val: TestEnumAlias;
}

export interface EnumIn {
  val: TestEnum;
}

export interface EnumAliasIn {
  val: TestEnumAlias;
}

export interface EnumNotIn {
  val: TestEnum;
}

export interface EnumAliasNotIn {
  val: TestEnumAlias;
}

export interface EnumExternal {
  val: Embed_Enumerated;
}

export interface EnumExternal2 {
  val: Embed_DoubleEmbed_DoubleEnumerated;
}

export interface EnumExternal3 {
  foo: Embed_FooNumber;
  bar: Embed_BarNumber;
}

export interface EnumExternal4 {
  sortDirection: Direction;
}

export interface RepeatedEnumDefined {
  val: TestEnum[];
}

export interface RepeatedExternalEnumDefined {
  val: Embed_Enumerated[];
}

export interface RepeatedYetAnotherExternalEnumDefined {
  val: Embed_Enumerated1[];
}

export interface RepeatedEnumExternal {
  foo: Embed_FooNumber[];
  bar: Embed_BarNumber[];
}

export interface MapEnumDefined {
  val: { [key: string]: TestEnum };
}

export interface MapEnumDefined_ValEntry {
  key: string;
  value: TestEnum;
}

export interface MapExternalEnumDefined {
  val: { [key: string]: Embed_Enumerated };
}

export interface MapExternalEnumDefined_ValEntry {
  key: string;
  value: Embed_Enumerated;
}

export interface EnumInsideOneOf {
  val?: TestEnum | undefined;
  val2?: TestEnum | undefined;
}

function createBaseEnumNone(): EnumNone {
  return { val: 0 };
}

export const EnumNone: MessageFns<EnumNone> = {
  encode(message: EnumNone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumNone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumNone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumNone {
    return { val: isSet(object.val) ? testEnumFromJSON(object.val) : 0 };
  },

  toJSON(message: EnumNone): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = testEnumToJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumNone>): EnumNone {
    return EnumNone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumNone>): EnumNone {
    const message = createBaseEnumNone();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseEnumConst(): EnumConst {
  return { val: 0 };
}

export const EnumConst: MessageFns<EnumConst> = {
  encode(message: EnumConst, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumConst {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumConst();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumConst {
    return { val: isSet(object.val) ? testEnumFromJSON(object.val) : 0 };
  },

  toJSON(message: EnumConst): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = testEnumToJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumConst>): EnumConst {
    return EnumConst.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumConst>): EnumConst {
    const message = createBaseEnumConst();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseEnumAliasConst(): EnumAliasConst {
  return { val: 0 };
}

export const EnumAliasConst: MessageFns<EnumAliasConst> = {
  encode(message: EnumAliasConst, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumAliasConst {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumAliasConst();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumAliasConst {
    return { val: isSet(object.val) ? testEnumAliasFromJSON(object.val) : 0 };
  },

  toJSON(message: EnumAliasConst): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = testEnumAliasToJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumAliasConst>): EnumAliasConst {
    return EnumAliasConst.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumAliasConst>): EnumAliasConst {
    const message = createBaseEnumAliasConst();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseEnumDefined(): EnumDefined {
  return { val: 0 };
}

export const EnumDefined: MessageFns<EnumDefined> = {
  encode(message: EnumDefined, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumDefined {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumDefined();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumDefined {
    return { val: isSet(object.val) ? testEnumFromJSON(object.val) : 0 };
  },

  toJSON(message: EnumDefined): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = testEnumToJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumDefined>): EnumDefined {
    return EnumDefined.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumDefined>): EnumDefined {
    const message = createBaseEnumDefined();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseEnumAliasDefined(): EnumAliasDefined {
  return { val: 0 };
}

export const EnumAliasDefined: MessageFns<EnumAliasDefined> = {
  encode(message: EnumAliasDefined, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumAliasDefined {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumAliasDefined();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumAliasDefined {
    return { val: isSet(object.val) ? testEnumAliasFromJSON(object.val) : 0 };
  },

  toJSON(message: EnumAliasDefined): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = testEnumAliasToJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumAliasDefined>): EnumAliasDefined {
    return EnumAliasDefined.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumAliasDefined>): EnumAliasDefined {
    const message = createBaseEnumAliasDefined();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseEnumIn(): EnumIn {
  return { val: 0 };
}

export const EnumIn: MessageFns<EnumIn> = {
  encode(message: EnumIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumIn {
    return { val: isSet(object.val) ? testEnumFromJSON(object.val) : 0 };
  },

  toJSON(message: EnumIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = testEnumToJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumIn>): EnumIn {
    return EnumIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumIn>): EnumIn {
    const message = createBaseEnumIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseEnumAliasIn(): EnumAliasIn {
  return { val: 0 };
}

export const EnumAliasIn: MessageFns<EnumAliasIn> = {
  encode(message: EnumAliasIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumAliasIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumAliasIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumAliasIn {
    return { val: isSet(object.val) ? testEnumAliasFromJSON(object.val) : 0 };
  },

  toJSON(message: EnumAliasIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = testEnumAliasToJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumAliasIn>): EnumAliasIn {
    return EnumAliasIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumAliasIn>): EnumAliasIn {
    const message = createBaseEnumAliasIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseEnumNotIn(): EnumNotIn {
  return { val: 0 };
}

export const EnumNotIn: MessageFns<EnumNotIn> = {
  encode(message: EnumNotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumNotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumNotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumNotIn {
    return { val: isSet(object.val) ? testEnumFromJSON(object.val) : 0 };
  },

  toJSON(message: EnumNotIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = testEnumToJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumNotIn>): EnumNotIn {
    return EnumNotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumNotIn>): EnumNotIn {
    const message = createBaseEnumNotIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseEnumAliasNotIn(): EnumAliasNotIn {
  return { val: 0 };
}

export const EnumAliasNotIn: MessageFns<EnumAliasNotIn> = {
  encode(message: EnumAliasNotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumAliasNotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumAliasNotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumAliasNotIn {
    return { val: isSet(object.val) ? testEnumAliasFromJSON(object.val) : 0 };
  },

  toJSON(message: EnumAliasNotIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = testEnumAliasToJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumAliasNotIn>): EnumAliasNotIn {
    return EnumAliasNotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumAliasNotIn>): EnumAliasNotIn {
    const message = createBaseEnumAliasNotIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseEnumExternal(): EnumExternal {
  return { val: 0 };
}

export const EnumExternal: MessageFns<EnumExternal> = {
  encode(message: EnumExternal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumExternal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumExternal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumExternal {
    return { val: isSet(object.val) ? embed_EnumeratedFromJSON(object.val) : 0 };
  },

  toJSON(message: EnumExternal): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = embed_EnumeratedToJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumExternal>): EnumExternal {
    return EnumExternal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumExternal>): EnumExternal {
    const message = createBaseEnumExternal();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseEnumExternal2(): EnumExternal2 {
  return { val: 0 };
}

export const EnumExternal2: MessageFns<EnumExternal2> = {
  encode(message: EnumExternal2, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumExternal2 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumExternal2();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumExternal2 {
    return { val: isSet(object.val) ? embed_DoubleEmbed_DoubleEnumeratedFromJSON(object.val) : 0 };
  },

  toJSON(message: EnumExternal2): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = embed_DoubleEmbed_DoubleEnumeratedToJSON(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumExternal2>): EnumExternal2 {
    return EnumExternal2.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumExternal2>): EnumExternal2 {
    const message = createBaseEnumExternal2();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseEnumExternal3(): EnumExternal3 {
  return { foo: 0, bar: 0 };
}

export const EnumExternal3: MessageFns<EnumExternal3> = {
  encode(message: EnumExternal3, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.foo !== 0) {
      writer.uint32(8).int32(message.foo);
    }
    if (message.bar !== 0) {
      writer.uint32(16).int32(message.bar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumExternal3 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumExternal3();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.foo = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.bar = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumExternal3 {
    return {
      foo: isSet(object.foo) ? embed_FooNumberFromJSON(object.foo) : 0,
      bar: isSet(object.bar) ? embed_BarNumberFromJSON(object.bar) : 0,
    };
  },

  toJSON(message: EnumExternal3): unknown {
    const obj: any = {};
    if (message.foo !== 0) {
      obj.foo = embed_FooNumberToJSON(message.foo);
    }
    if (message.bar !== 0) {
      obj.bar = embed_BarNumberToJSON(message.bar);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumExternal3>): EnumExternal3 {
    return EnumExternal3.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumExternal3>): EnumExternal3 {
    const message = createBaseEnumExternal3();
    message.foo = object.foo ?? 0;
    message.bar = object.bar ?? 0;
    return message;
  },
};

function createBaseEnumExternal4(): EnumExternal4 {
  return { sortDirection: 0 };
}

export const EnumExternal4: MessageFns<EnumExternal4> = {
  encode(message: EnumExternal4, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sortDirection !== 0) {
      writer.uint32(8).int32(message.sortDirection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumExternal4 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumExternal4();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sortDirection = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumExternal4 {
    return { sortDirection: isSet(object.sortDirection) ? directionFromJSON(object.sortDirection) : 0 };
  },

  toJSON(message: EnumExternal4): unknown {
    const obj: any = {};
    if (message.sortDirection !== 0) {
      obj.sortDirection = directionToJSON(message.sortDirection);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumExternal4>): EnumExternal4 {
    return EnumExternal4.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumExternal4>): EnumExternal4 {
    const message = createBaseEnumExternal4();
    message.sortDirection = object.sortDirection ?? 0;
    return message;
  },
};

function createBaseRepeatedEnumDefined(): RepeatedEnumDefined {
  return { val: [] };
}

export const RepeatedEnumDefined: MessageFns<RepeatedEnumDefined> = {
  encode(message: RepeatedEnumDefined, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.val) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepeatedEnumDefined {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepeatedEnumDefined();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.val.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.val.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepeatedEnumDefined {
    return { val: globalThis.Array.isArray(object?.val) ? object.val.map((e: any) => testEnumFromJSON(e)) : [] };
  },

  toJSON(message: RepeatedEnumDefined): unknown {
    const obj: any = {};
    if (message.val?.length) {
      obj.val = message.val.map((e) => testEnumToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RepeatedEnumDefined>): RepeatedEnumDefined {
    return RepeatedEnumDefined.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepeatedEnumDefined>): RepeatedEnumDefined {
    const message = createBaseRepeatedEnumDefined();
    message.val = object.val?.map((e) => e) || [];
    return message;
  },
};

function createBaseRepeatedExternalEnumDefined(): RepeatedExternalEnumDefined {
  return { val: [] };
}

export const RepeatedExternalEnumDefined: MessageFns<RepeatedExternalEnumDefined> = {
  encode(message: RepeatedExternalEnumDefined, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.val) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepeatedExternalEnumDefined {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepeatedExternalEnumDefined();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.val.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.val.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepeatedExternalEnumDefined {
    return {
      val: globalThis.Array.isArray(object?.val) ? object.val.map((e: any) => embed_EnumeratedFromJSON(e)) : [],
    };
  },

  toJSON(message: RepeatedExternalEnumDefined): unknown {
    const obj: any = {};
    if (message.val?.length) {
      obj.val = message.val.map((e) => embed_EnumeratedToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RepeatedExternalEnumDefined>): RepeatedExternalEnumDefined {
    return RepeatedExternalEnumDefined.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepeatedExternalEnumDefined>): RepeatedExternalEnumDefined {
    const message = createBaseRepeatedExternalEnumDefined();
    message.val = object.val?.map((e) => e) || [];
    return message;
  },
};

function createBaseRepeatedYetAnotherExternalEnumDefined(): RepeatedYetAnotherExternalEnumDefined {
  return { val: [] };
}

export const RepeatedYetAnotherExternalEnumDefined: MessageFns<RepeatedYetAnotherExternalEnumDefined> = {
  encode(message: RepeatedYetAnotherExternalEnumDefined, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.val) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepeatedYetAnotherExternalEnumDefined {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepeatedYetAnotherExternalEnumDefined();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.val.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.val.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepeatedYetAnotherExternalEnumDefined {
    return {
      val: globalThis.Array.isArray(object?.val) ? object.val.map((e: any) => embed_EnumeratedFromJSON2(e)) : [],
    };
  },

  toJSON(message: RepeatedYetAnotherExternalEnumDefined): unknown {
    const obj: any = {};
    if (message.val?.length) {
      obj.val = message.val.map((e) => embed_EnumeratedToJSON3(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RepeatedYetAnotherExternalEnumDefined>): RepeatedYetAnotherExternalEnumDefined {
    return RepeatedYetAnotherExternalEnumDefined.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepeatedYetAnotherExternalEnumDefined>): RepeatedYetAnotherExternalEnumDefined {
    const message = createBaseRepeatedYetAnotherExternalEnumDefined();
    message.val = object.val?.map((e) => e) || [];
    return message;
  },
};

function createBaseRepeatedEnumExternal(): RepeatedEnumExternal {
  return { foo: [], bar: [] };
}

export const RepeatedEnumExternal: MessageFns<RepeatedEnumExternal> = {
  encode(message: RepeatedEnumExternal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.foo) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(18).fork();
    for (const v of message.bar) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepeatedEnumExternal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepeatedEnumExternal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.foo.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.foo.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag === 16) {
            message.bar.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.bar.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepeatedEnumExternal {
    return {
      foo: globalThis.Array.isArray(object?.foo) ? object.foo.map((e: any) => embed_FooNumberFromJSON(e)) : [],
      bar: globalThis.Array.isArray(object?.bar) ? object.bar.map((e: any) => embed_BarNumberFromJSON(e)) : [],
    };
  },

  toJSON(message: RepeatedEnumExternal): unknown {
    const obj: any = {};
    if (message.foo?.length) {
      obj.foo = message.foo.map((e) => embed_FooNumberToJSON(e));
    }
    if (message.bar?.length) {
      obj.bar = message.bar.map((e) => embed_BarNumberToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RepeatedEnumExternal>): RepeatedEnumExternal {
    return RepeatedEnumExternal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepeatedEnumExternal>): RepeatedEnumExternal {
    const message = createBaseRepeatedEnumExternal();
    message.foo = object.foo?.map((e) => e) || [];
    message.bar = object.bar?.map((e) => e) || [];
    return message;
  },
};

function createBaseMapEnumDefined(): MapEnumDefined {
  return { val: {} };
}

export const MapEnumDefined: MessageFns<MapEnumDefined> = {
  encode(message: MapEnumDefined, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapEnumDefined_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapEnumDefined {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapEnumDefined();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapEnumDefined_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapEnumDefined {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: string]: TestEnum }>((acc, [key, value]) => {
          acc[key] = testEnumFromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapEnumDefined): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = testEnumToJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapEnumDefined>): MapEnumDefined {
    return MapEnumDefined.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapEnumDefined>): MapEnumDefined {
    const message = createBaseMapEnumDefined();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: string]: TestEnum }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value as TestEnum;
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapEnumDefined_ValEntry(): MapEnumDefined_ValEntry {
  return { key: "", value: 0 };
}

export const MapEnumDefined_ValEntry: MessageFns<MapEnumDefined_ValEntry> = {
  encode(message: MapEnumDefined_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapEnumDefined_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapEnumDefined_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapEnumDefined_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? testEnumFromJSON(object.value) : 0,
    };
  },

  toJSON(message: MapEnumDefined_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = testEnumToJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MapEnumDefined_ValEntry>): MapEnumDefined_ValEntry {
    return MapEnumDefined_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapEnumDefined_ValEntry>): MapEnumDefined_ValEntry {
    const message = createBaseMapEnumDefined_ValEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseMapExternalEnumDefined(): MapExternalEnumDefined {
  return { val: {} };
}

export const MapExternalEnumDefined: MessageFns<MapExternalEnumDefined> = {
  encode(message: MapExternalEnumDefined, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.val).forEach(([key, value]) => {
      MapExternalEnumDefined_ValEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapExternalEnumDefined {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapExternalEnumDefined();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = MapExternalEnumDefined_ValEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.val[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapExternalEnumDefined {
    return {
      val: isObject(object.val)
        ? Object.entries(object.val).reduce<{ [key: string]: Embed_Enumerated }>((acc, [key, value]) => {
          acc[key] = embed_EnumeratedFromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapExternalEnumDefined): unknown {
    const obj: any = {};
    if (message.val) {
      const entries = Object.entries(message.val);
      if (entries.length > 0) {
        obj.val = {};
        entries.forEach(([k, v]) => {
          obj.val[k] = embed_EnumeratedToJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<MapExternalEnumDefined>): MapExternalEnumDefined {
    return MapExternalEnumDefined.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapExternalEnumDefined>): MapExternalEnumDefined {
    const message = createBaseMapExternalEnumDefined();
    message.val = Object.entries(object.val ?? {}).reduce<{ [key: string]: Embed_Enumerated }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value as Embed_Enumerated;
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMapExternalEnumDefined_ValEntry(): MapExternalEnumDefined_ValEntry {
  return { key: "", value: 0 };
}

export const MapExternalEnumDefined_ValEntry: MessageFns<MapExternalEnumDefined_ValEntry> = {
  encode(message: MapExternalEnumDefined_ValEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapExternalEnumDefined_ValEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapExternalEnumDefined_ValEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapExternalEnumDefined_ValEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? embed_EnumeratedFromJSON(object.value) : 0,
    };
  },

  toJSON(message: MapExternalEnumDefined_ValEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = embed_EnumeratedToJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<MapExternalEnumDefined_ValEntry>): MapExternalEnumDefined_ValEntry {
    return MapExternalEnumDefined_ValEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MapExternalEnumDefined_ValEntry>): MapExternalEnumDefined_ValEntry {
    const message = createBaseMapExternalEnumDefined_ValEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseEnumInsideOneOf(): EnumInsideOneOf {
  return { val: undefined, val2: undefined };
}

export const EnumInsideOneOf: MessageFns<EnumInsideOneOf> = {
  encode(message: EnumInsideOneOf, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      writer.uint32(8).int32(message.val);
    }
    if (message.val2 !== undefined) {
      writer.uint32(16).int32(message.val2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumInsideOneOf {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumInsideOneOf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.val2 = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumInsideOneOf {
    return {
      val: isSet(object.val) ? testEnumFromJSON(object.val) : undefined,
      val2: isSet(object.val2) ? testEnumFromJSON(object.val2) : undefined,
    };
  },

  toJSON(message: EnumInsideOneOf): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = testEnumToJSON(message.val);
    }
    if (message.val2 !== undefined) {
      obj.val2 = testEnumToJSON(message.val2);
    }
    return obj;
  },

  create(base?: DeepPartial<EnumInsideOneOf>): EnumInsideOneOf {
    return EnumInsideOneOf.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumInsideOneOf>): EnumInsideOneOf {
    const message = createBaseEnumInsideOneOf();
    message.val = object.val ?? undefined;
    message.val2 = object.val2 ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
