// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: tests/harness/cases/strings.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "tests.harness.cases";

export interface StringNone {
  val: string;
}

export interface StringConst {
  val: string;
}

export interface StringIn {
  val: string;
}

export interface StringNotIn {
  val: string;
}

export interface StringLen {
  val: string;
}

export interface StringMinLen {
  val: string;
}

export interface StringMaxLen {
  val: string;
}

export interface StringMinMaxLen {
  val: string;
}

export interface StringEqualMinMaxLen {
  val: string;
}

export interface StringLenBytes {
  val: string;
}

export interface StringMinBytes {
  val: string;
}

export interface StringMaxBytes {
  val: string;
}

export interface StringMinMaxBytes {
  val: string;
}

export interface StringEqualMinMaxBytes {
  val: string;
}

export interface StringPattern {
  val: string;
}

export interface StringPatternEscapes {
  val: string;
}

export interface StringPrefix {
  val: string;
}

export interface StringContains {
  val: string;
}

export interface StringNotContains {
  val: string;
}

export interface StringSuffix {
  val: string;
}

export interface StringEmail {
  val: string;
}

export interface StringAddress {
  val: string;
}

export interface StringHostname {
  val: string;
}

export interface StringIP {
  val: string;
}

export interface StringIPv4 {
  val: string;
}

export interface StringIPv6 {
  val: string;
}

export interface StringURI {
  val: string;
}

export interface StringURIRef {
  val: string;
}

export interface StringUUID {
  val: string;
}

export interface StringHttpHeaderName {
  val: string;
}

export interface StringHttpHeaderValue {
  val: string;
}

export interface StringValidHeader {
  val: string;
}

export interface StringUUIDIgnore {
  val: string;
}

export interface StringInOneOf {
  bar?: string | undefined;
}

function createBaseStringNone(): StringNone {
  return { val: "" };
}

export const StringNone: MessageFns<StringNone> = {
  encode(message: StringNone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringNone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringNone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringNone {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringNone): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringNone>): StringNone {
    return StringNone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringNone>): StringNone {
    const message = createBaseStringNone();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringConst(): StringConst {
  return { val: "" };
}

export const StringConst: MessageFns<StringConst> = {
  encode(message: StringConst, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringConst {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringConst();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringConst {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringConst): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringConst>): StringConst {
    return StringConst.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringConst>): StringConst {
    const message = createBaseStringConst();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringIn(): StringIn {
  return { val: "" };
}

export const StringIn: MessageFns<StringIn> = {
  encode(message: StringIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringIn {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringIn): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringIn>): StringIn {
    return StringIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringIn>): StringIn {
    const message = createBaseStringIn();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringNotIn(): StringNotIn {
  return { val: "" };
}

export const StringNotIn: MessageFns<StringNotIn> = {
  encode(message: StringNotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringNotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringNotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringNotIn {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringNotIn): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringNotIn>): StringNotIn {
    return StringNotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringNotIn>): StringNotIn {
    const message = createBaseStringNotIn();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringLen(): StringLen {
  return { val: "" };
}

export const StringLen: MessageFns<StringLen> = {
  encode(message: StringLen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringLen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringLen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringLen {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringLen): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringLen>): StringLen {
    return StringLen.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringLen>): StringLen {
    const message = createBaseStringLen();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringMinLen(): StringMinLen {
  return { val: "" };
}

export const StringMinLen: MessageFns<StringMinLen> = {
  encode(message: StringMinLen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringMinLen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringMinLen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringMinLen {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringMinLen): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringMinLen>): StringMinLen {
    return StringMinLen.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringMinLen>): StringMinLen {
    const message = createBaseStringMinLen();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringMaxLen(): StringMaxLen {
  return { val: "" };
}

export const StringMaxLen: MessageFns<StringMaxLen> = {
  encode(message: StringMaxLen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringMaxLen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringMaxLen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringMaxLen {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringMaxLen): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringMaxLen>): StringMaxLen {
    return StringMaxLen.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringMaxLen>): StringMaxLen {
    const message = createBaseStringMaxLen();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringMinMaxLen(): StringMinMaxLen {
  return { val: "" };
}

export const StringMinMaxLen: MessageFns<StringMinMaxLen> = {
  encode(message: StringMinMaxLen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringMinMaxLen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringMinMaxLen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringMinMaxLen {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringMinMaxLen): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringMinMaxLen>): StringMinMaxLen {
    return StringMinMaxLen.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringMinMaxLen>): StringMinMaxLen {
    const message = createBaseStringMinMaxLen();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringEqualMinMaxLen(): StringEqualMinMaxLen {
  return { val: "" };
}

export const StringEqualMinMaxLen: MessageFns<StringEqualMinMaxLen> = {
  encode(message: StringEqualMinMaxLen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringEqualMinMaxLen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringEqualMinMaxLen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringEqualMinMaxLen {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringEqualMinMaxLen): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringEqualMinMaxLen>): StringEqualMinMaxLen {
    return StringEqualMinMaxLen.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringEqualMinMaxLen>): StringEqualMinMaxLen {
    const message = createBaseStringEqualMinMaxLen();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringLenBytes(): StringLenBytes {
  return { val: "" };
}

export const StringLenBytes: MessageFns<StringLenBytes> = {
  encode(message: StringLenBytes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringLenBytes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringLenBytes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringLenBytes {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringLenBytes): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringLenBytes>): StringLenBytes {
    return StringLenBytes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringLenBytes>): StringLenBytes {
    const message = createBaseStringLenBytes();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringMinBytes(): StringMinBytes {
  return { val: "" };
}

export const StringMinBytes: MessageFns<StringMinBytes> = {
  encode(message: StringMinBytes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringMinBytes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringMinBytes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringMinBytes {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringMinBytes): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringMinBytes>): StringMinBytes {
    return StringMinBytes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringMinBytes>): StringMinBytes {
    const message = createBaseStringMinBytes();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringMaxBytes(): StringMaxBytes {
  return { val: "" };
}

export const StringMaxBytes: MessageFns<StringMaxBytes> = {
  encode(message: StringMaxBytes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringMaxBytes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringMaxBytes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringMaxBytes {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringMaxBytes): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringMaxBytes>): StringMaxBytes {
    return StringMaxBytes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringMaxBytes>): StringMaxBytes {
    const message = createBaseStringMaxBytes();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringMinMaxBytes(): StringMinMaxBytes {
  return { val: "" };
}

export const StringMinMaxBytes: MessageFns<StringMinMaxBytes> = {
  encode(message: StringMinMaxBytes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringMinMaxBytes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringMinMaxBytes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringMinMaxBytes {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringMinMaxBytes): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringMinMaxBytes>): StringMinMaxBytes {
    return StringMinMaxBytes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringMinMaxBytes>): StringMinMaxBytes {
    const message = createBaseStringMinMaxBytes();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringEqualMinMaxBytes(): StringEqualMinMaxBytes {
  return { val: "" };
}

export const StringEqualMinMaxBytes: MessageFns<StringEqualMinMaxBytes> = {
  encode(message: StringEqualMinMaxBytes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringEqualMinMaxBytes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringEqualMinMaxBytes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringEqualMinMaxBytes {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringEqualMinMaxBytes): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringEqualMinMaxBytes>): StringEqualMinMaxBytes {
    return StringEqualMinMaxBytes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringEqualMinMaxBytes>): StringEqualMinMaxBytes {
    const message = createBaseStringEqualMinMaxBytes();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringPattern(): StringPattern {
  return { val: "" };
}

export const StringPattern: MessageFns<StringPattern> = {
  encode(message: StringPattern, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringPattern {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringPattern();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringPattern {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringPattern): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringPattern>): StringPattern {
    return StringPattern.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringPattern>): StringPattern {
    const message = createBaseStringPattern();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringPatternEscapes(): StringPatternEscapes {
  return { val: "" };
}

export const StringPatternEscapes: MessageFns<StringPatternEscapes> = {
  encode(message: StringPatternEscapes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringPatternEscapes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringPatternEscapes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringPatternEscapes {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringPatternEscapes): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringPatternEscapes>): StringPatternEscapes {
    return StringPatternEscapes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringPatternEscapes>): StringPatternEscapes {
    const message = createBaseStringPatternEscapes();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringPrefix(): StringPrefix {
  return { val: "" };
}

export const StringPrefix: MessageFns<StringPrefix> = {
  encode(message: StringPrefix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringPrefix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringPrefix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringPrefix {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringPrefix): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringPrefix>): StringPrefix {
    return StringPrefix.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringPrefix>): StringPrefix {
    const message = createBaseStringPrefix();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringContains(): StringContains {
  return { val: "" };
}

export const StringContains: MessageFns<StringContains> = {
  encode(message: StringContains, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringContains {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringContains();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringContains {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringContains): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringContains>): StringContains {
    return StringContains.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringContains>): StringContains {
    const message = createBaseStringContains();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringNotContains(): StringNotContains {
  return { val: "" };
}

export const StringNotContains: MessageFns<StringNotContains> = {
  encode(message: StringNotContains, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringNotContains {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringNotContains();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringNotContains {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringNotContains): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringNotContains>): StringNotContains {
    return StringNotContains.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringNotContains>): StringNotContains {
    const message = createBaseStringNotContains();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringSuffix(): StringSuffix {
  return { val: "" };
}

export const StringSuffix: MessageFns<StringSuffix> = {
  encode(message: StringSuffix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringSuffix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringSuffix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringSuffix {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringSuffix): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringSuffix>): StringSuffix {
    return StringSuffix.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringSuffix>): StringSuffix {
    const message = createBaseStringSuffix();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringEmail(): StringEmail {
  return { val: "" };
}

export const StringEmail: MessageFns<StringEmail> = {
  encode(message: StringEmail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringEmail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringEmail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringEmail {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringEmail): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringEmail>): StringEmail {
    return StringEmail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringEmail>): StringEmail {
    const message = createBaseStringEmail();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringAddress(): StringAddress {
  return { val: "" };
}

export const StringAddress: MessageFns<StringAddress> = {
  encode(message: StringAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringAddress {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringAddress): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringAddress>): StringAddress {
    return StringAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringAddress>): StringAddress {
    const message = createBaseStringAddress();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringHostname(): StringHostname {
  return { val: "" };
}

export const StringHostname: MessageFns<StringHostname> = {
  encode(message: StringHostname, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringHostname {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringHostname();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringHostname {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringHostname): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringHostname>): StringHostname {
    return StringHostname.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringHostname>): StringHostname {
    const message = createBaseStringHostname();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringIP(): StringIP {
  return { val: "" };
}

export const StringIP: MessageFns<StringIP> = {
  encode(message: StringIP, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringIP {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringIP();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringIP {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringIP): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringIP>): StringIP {
    return StringIP.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringIP>): StringIP {
    const message = createBaseStringIP();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringIPv4(): StringIPv4 {
  return { val: "" };
}

export const StringIPv4: MessageFns<StringIPv4> = {
  encode(message: StringIPv4, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringIPv4 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringIPv4();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringIPv4 {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringIPv4): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringIPv4>): StringIPv4 {
    return StringIPv4.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringIPv4>): StringIPv4 {
    const message = createBaseStringIPv4();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringIPv6(): StringIPv6 {
  return { val: "" };
}

export const StringIPv6: MessageFns<StringIPv6> = {
  encode(message: StringIPv6, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringIPv6 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringIPv6();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringIPv6 {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringIPv6): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringIPv6>): StringIPv6 {
    return StringIPv6.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringIPv6>): StringIPv6 {
    const message = createBaseStringIPv6();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringURI(): StringURI {
  return { val: "" };
}

export const StringURI: MessageFns<StringURI> = {
  encode(message: StringURI, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringURI {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringURI();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringURI {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringURI): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringURI>): StringURI {
    return StringURI.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringURI>): StringURI {
    const message = createBaseStringURI();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringURIRef(): StringURIRef {
  return { val: "" };
}

export const StringURIRef: MessageFns<StringURIRef> = {
  encode(message: StringURIRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringURIRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringURIRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringURIRef {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringURIRef): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringURIRef>): StringURIRef {
    return StringURIRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringURIRef>): StringURIRef {
    const message = createBaseStringURIRef();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringUUID(): StringUUID {
  return { val: "" };
}

export const StringUUID: MessageFns<StringUUID> = {
  encode(message: StringUUID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringUUID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringUUID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringUUID {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringUUID): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringUUID>): StringUUID {
    return StringUUID.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringUUID>): StringUUID {
    const message = createBaseStringUUID();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringHttpHeaderName(): StringHttpHeaderName {
  return { val: "" };
}

export const StringHttpHeaderName: MessageFns<StringHttpHeaderName> = {
  encode(message: StringHttpHeaderName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringHttpHeaderName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringHttpHeaderName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringHttpHeaderName {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringHttpHeaderName): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringHttpHeaderName>): StringHttpHeaderName {
    return StringHttpHeaderName.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringHttpHeaderName>): StringHttpHeaderName {
    const message = createBaseStringHttpHeaderName();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringHttpHeaderValue(): StringHttpHeaderValue {
  return { val: "" };
}

export const StringHttpHeaderValue: MessageFns<StringHttpHeaderValue> = {
  encode(message: StringHttpHeaderValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringHttpHeaderValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringHttpHeaderValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringHttpHeaderValue {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringHttpHeaderValue): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringHttpHeaderValue>): StringHttpHeaderValue {
    return StringHttpHeaderValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringHttpHeaderValue>): StringHttpHeaderValue {
    const message = createBaseStringHttpHeaderValue();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringValidHeader(): StringValidHeader {
  return { val: "" };
}

export const StringValidHeader: MessageFns<StringValidHeader> = {
  encode(message: StringValidHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringValidHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringValidHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringValidHeader {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringValidHeader): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringValidHeader>): StringValidHeader {
    return StringValidHeader.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringValidHeader>): StringValidHeader {
    const message = createBaseStringValidHeader();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringUUIDIgnore(): StringUUIDIgnore {
  return { val: "" };
}

export const StringUUIDIgnore: MessageFns<StringUUIDIgnore> = {
  encode(message: StringUUIDIgnore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== "") {
      writer.uint32(10).string(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringUUIDIgnore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringUUIDIgnore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.val = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringUUIDIgnore {
    return { val: isSet(object.val) ? globalThis.String(object.val) : "" };
  },

  toJSON(message: StringUUIDIgnore): unknown {
    const obj: any = {};
    if (message.val !== "") {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<StringUUIDIgnore>): StringUUIDIgnore {
    return StringUUIDIgnore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringUUIDIgnore>): StringUUIDIgnore {
    const message = createBaseStringUUIDIgnore();
    message.val = object.val ?? "";
    return message;
  },
};

function createBaseStringInOneOf(): StringInOneOf {
  return { bar: undefined };
}

export const StringInOneOf: MessageFns<StringInOneOf> = {
  encode(message: StringInOneOf, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bar !== undefined) {
      writer.uint32(10).string(message.bar);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringInOneOf {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringInOneOf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bar = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringInOneOf {
    return { bar: isSet(object.bar) ? globalThis.String(object.bar) : undefined };
  },

  toJSON(message: StringInOneOf): unknown {
    const obj: any = {};
    if (message.bar !== undefined) {
      obj.bar = message.bar;
    }
    return obj;
  },

  create(base?: DeepPartial<StringInOneOf>): StringInOneOf {
    return StringInOneOf.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringInOneOf>): StringInOneOf {
    const message = createBaseStringInOneOf();
    message.bar = object.bar ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
