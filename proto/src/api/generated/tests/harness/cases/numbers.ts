// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: tests/harness/cases/numbers.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "tests.harness.cases";

export interface FloatNone {
  val: number;
}

export interface FloatConst {
  val: number;
}

export interface FloatIn {
  val: number;
}

export interface FloatNotIn {
  val: number;
}

export interface FloatLT {
  val: number;
}

export interface FloatLTE {
  val: number;
}

export interface FloatGT {
  val: number;
}

export interface FloatGTE {
  val: number;
}

export interface FloatGTLT {
  val: number;
}

export interface FloatExLTGT {
  val: number;
}

export interface FloatGTELTE {
  val: number;
}

export interface FloatExGTELTE {
  val: number;
}

export interface FloatIgnore {
  val: number;
}

export interface DoubleNone {
  val: number;
}

export interface DoubleConst {
  val: number;
}

export interface DoubleIn {
  val: number;
}

export interface DoubleNotIn {
  val: number;
}

export interface DoubleLT {
  val: number;
}

export interface DoubleLTE {
  val: number;
}

export interface DoubleGT {
  val: number;
}

export interface DoubleGTE {
  val: number;
}

export interface DoubleGTLT {
  val: number;
}

export interface DoubleExLTGT {
  val: number;
}

export interface DoubleGTELTE {
  val: number;
}

export interface DoubleExGTELTE {
  val: number;
}

export interface DoubleIgnore {
  val: number;
}

export interface Int32None {
  val: number;
}

export interface Int32Const {
  val: number;
}

export interface Int32In {
  val: number;
}

export interface Int32NotIn {
  val: number;
}

export interface Int32LT {
  val: number;
}

export interface Int32LTE {
  val: number;
}

export interface Int32GT {
  val: number;
}

export interface Int32GTE {
  val: number;
}

export interface Int32GTLT {
  val: number;
}

export interface Int32ExLTGT {
  val: number;
}

export interface Int32GTELTE {
  val: number;
}

export interface Int32ExGTELTE {
  val: number;
}

export interface Int32Ignore {
  val: number;
}

export interface Int64None {
  val: Long;
}

export interface Int64Const {
  val: Long;
}

export interface Int64In {
  val: Long;
}

export interface Int64NotIn {
  val: Long;
}

export interface Int64LT {
  val: Long;
}

export interface Int64LTE {
  val: Long;
}

export interface Int64GT {
  val: Long;
}

export interface Int64GTE {
  val: Long;
}

export interface Int64GTLT {
  val: Long;
}

export interface Int64ExLTGT {
  val: Long;
}

export interface Int64GTELTE {
  val: Long;
}

export interface Int64ExGTELTE {
  val: Long;
}

export interface Int64Ignore {
  val: Long;
}

export interface UInt32None {
  val: number;
}

export interface UInt32Const {
  val: number;
}

export interface UInt32In {
  val: number;
}

export interface UInt32NotIn {
  val: number;
}

export interface UInt32LT {
  val: number;
}

export interface UInt32LTE {
  val: number;
}

export interface UInt32GT {
  val: number;
}

export interface UInt32GTE {
  val: number;
}

export interface UInt32GTLT {
  val: number;
}

export interface UInt32ExLTGT {
  val: number;
}

export interface UInt32GTELTE {
  val: number;
}

export interface UInt32ExGTELTE {
  val: number;
}

export interface UInt32Ignore {
  val: number;
}

export interface UInt64None {
  val: Long;
}

export interface UInt64Const {
  val: Long;
}

export interface UInt64In {
  val: Long;
}

export interface UInt64NotIn {
  val: Long;
}

export interface UInt64LT {
  val: Long;
}

export interface UInt64LTE {
  val: Long;
}

export interface UInt64GT {
  val: Long;
}

export interface UInt64GTE {
  val: Long;
}

export interface UInt64GTLT {
  val: Long;
}

export interface UInt64ExLTGT {
  val: Long;
}

export interface UInt64GTELTE {
  val: Long;
}

export interface UInt64ExGTELTE {
  val: Long;
}

export interface UInt64Ignore {
  val: Long;
}

export interface SInt32None {
  val: number;
}

export interface SInt32Const {
  val: number;
}

export interface SInt32In {
  val: number;
}

export interface SInt32NotIn {
  val: number;
}

export interface SInt32LT {
  val: number;
}

export interface SInt32LTE {
  val: number;
}

export interface SInt32GT {
  val: number;
}

export interface SInt32GTE {
  val: number;
}

export interface SInt32GTLT {
  val: number;
}

export interface SInt32ExLTGT {
  val: number;
}

export interface SInt32GTELTE {
  val: number;
}

export interface SInt32ExGTELTE {
  val: number;
}

export interface SInt32Ignore {
  val: number;
}

export interface SInt64None {
  val: Long;
}

export interface SInt64Const {
  val: Long;
}

export interface SInt64In {
  val: Long;
}

export interface SInt64NotIn {
  val: Long;
}

export interface SInt64LT {
  val: Long;
}

export interface SInt64LTE {
  val: Long;
}

export interface SInt64GT {
  val: Long;
}

export interface SInt64GTE {
  val: Long;
}

export interface SInt64GTLT {
  val: Long;
}

export interface SInt64ExLTGT {
  val: Long;
}

export interface SInt64GTELTE {
  val: Long;
}

export interface SInt64ExGTELTE {
  val: Long;
}

export interface SInt64Ignore {
  val: Long;
}

export interface Fixed32None {
  val: number;
}

export interface Fixed32Const {
  val: number;
}

export interface Fixed32In {
  val: number;
}

export interface Fixed32NotIn {
  val: number;
}

export interface Fixed32LT {
  val: number;
}

export interface Fixed32LTE {
  val: number;
}

export interface Fixed32GT {
  val: number;
}

export interface Fixed32GTE {
  val: number;
}

export interface Fixed32GTLT {
  val: number;
}

export interface Fixed32ExLTGT {
  val: number;
}

export interface Fixed32GTELTE {
  val: number;
}

export interface Fixed32ExGTELTE {
  val: number;
}

export interface Fixed32Ignore {
  val: number;
}

export interface Fixed64None {
  val: Long;
}

export interface Fixed64Const {
  val: Long;
}

export interface Fixed64In {
  val: Long;
}

export interface Fixed64NotIn {
  val: Long;
}

export interface Fixed64LT {
  val: Long;
}

export interface Fixed64LTE {
  val: Long;
}

export interface Fixed64GT {
  val: Long;
}

export interface Fixed64GTE {
  val: Long;
}

export interface Fixed64GTLT {
  val: Long;
}

export interface Fixed64ExLTGT {
  val: Long;
}

export interface Fixed64GTELTE {
  val: Long;
}

export interface Fixed64ExGTELTE {
  val: Long;
}

export interface Fixed64Ignore {
  val: Long;
}

export interface SFixed32None {
  val: number;
}

export interface SFixed32Const {
  val: number;
}

export interface SFixed32In {
  val: number;
}

export interface SFixed32NotIn {
  val: number;
}

export interface SFixed32LT {
  val: number;
}

export interface SFixed32LTE {
  val: number;
}

export interface SFixed32GT {
  val: number;
}

export interface SFixed32GTE {
  val: number;
}

export interface SFixed32GTLT {
  val: number;
}

export interface SFixed32ExLTGT {
  val: number;
}

export interface SFixed32GTELTE {
  val: number;
}

export interface SFixed32ExGTELTE {
  val: number;
}

export interface SFixed32Ignore {
  val: number;
}

export interface SFixed64None {
  val: Long;
}

export interface SFixed64Const {
  val: Long;
}

export interface SFixed64In {
  val: Long;
}

export interface SFixed64NotIn {
  val: Long;
}

export interface SFixed64LT {
  val: Long;
}

export interface SFixed64LTE {
  val: Long;
}

export interface SFixed64GT {
  val: Long;
}

export interface SFixed64GTE {
  val: Long;
}

export interface SFixed64GTLT {
  val: Long;
}

export interface SFixed64ExLTGT {
  val: Long;
}

export interface SFixed64GTELTE {
  val: Long;
}

export interface SFixed64ExGTELTE {
  val: Long;
}

export interface SFixed64Ignore {
  val: Long;
}

export interface Int64LTEOptional {
  val?: Long | undefined;
}

function createBaseFloatNone(): FloatNone {
  return { val: 0 };
}

export const FloatNone: MessageFns<FloatNone> = {
  encode(message: FloatNone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatNone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatNone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatNone {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatNone): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatNone>): FloatNone {
    return FloatNone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatNone>): FloatNone {
    const message = createBaseFloatNone();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatConst(): FloatConst {
  return { val: 0 };
}

export const FloatConst: MessageFns<FloatConst> = {
  encode(message: FloatConst, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatConst {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatConst();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatConst {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatConst): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatConst>): FloatConst {
    return FloatConst.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatConst>): FloatConst {
    const message = createBaseFloatConst();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatIn(): FloatIn {
  return { val: 0 };
}

export const FloatIn: MessageFns<FloatIn> = {
  encode(message: FloatIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatIn {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatIn>): FloatIn {
    return FloatIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatIn>): FloatIn {
    const message = createBaseFloatIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatNotIn(): FloatNotIn {
  return { val: 0 };
}

export const FloatNotIn: MessageFns<FloatNotIn> = {
  encode(message: FloatNotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatNotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatNotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatNotIn {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatNotIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatNotIn>): FloatNotIn {
    return FloatNotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatNotIn>): FloatNotIn {
    const message = createBaseFloatNotIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatLT(): FloatLT {
  return { val: 0 };
}

export const FloatLT: MessageFns<FloatLT> = {
  encode(message: FloatLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatLT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatLT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatLT>): FloatLT {
    return FloatLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatLT>): FloatLT {
    const message = createBaseFloatLT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatLTE(): FloatLTE {
  return { val: 0 };
}

export const FloatLTE: MessageFns<FloatLTE> = {
  encode(message: FloatLTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatLTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatLTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatLTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatLTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatLTE>): FloatLTE {
    return FloatLTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatLTE>): FloatLTE {
    const message = createBaseFloatLTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatGT(): FloatGT {
  return { val: 0 };
}

export const FloatGT: MessageFns<FloatGT> = {
  encode(message: FloatGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatGT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatGT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatGT>): FloatGT {
    return FloatGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatGT>): FloatGT {
    const message = createBaseFloatGT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatGTE(): FloatGTE {
  return { val: 0 };
}

export const FloatGTE: MessageFns<FloatGTE> = {
  encode(message: FloatGTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatGTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatGTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatGTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatGTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatGTE>): FloatGTE {
    return FloatGTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatGTE>): FloatGTE {
    const message = createBaseFloatGTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatGTLT(): FloatGTLT {
  return { val: 0 };
}

export const FloatGTLT: MessageFns<FloatGTLT> = {
  encode(message: FloatGTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatGTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatGTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatGTLT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatGTLT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatGTLT>): FloatGTLT {
    return FloatGTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatGTLT>): FloatGTLT {
    const message = createBaseFloatGTLT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatExLTGT(): FloatExLTGT {
  return { val: 0 };
}

export const FloatExLTGT: MessageFns<FloatExLTGT> = {
  encode(message: FloatExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatExLTGT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatExLTGT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatExLTGT>): FloatExLTGT {
    return FloatExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatExLTGT>): FloatExLTGT {
    const message = createBaseFloatExLTGT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatGTELTE(): FloatGTELTE {
  return { val: 0 };
}

export const FloatGTELTE: MessageFns<FloatGTELTE> = {
  encode(message: FloatGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatGTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatGTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatGTELTE>): FloatGTELTE {
    return FloatGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatGTELTE>): FloatGTELTE {
    const message = createBaseFloatGTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatExGTELTE(): FloatExGTELTE {
  return { val: 0 };
}

export const FloatExGTELTE: MessageFns<FloatExGTELTE> = {
  encode(message: FloatExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatExGTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatExGTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatExGTELTE>): FloatExGTELTE {
    return FloatExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatExGTELTE>): FloatExGTELTE {
    const message = createBaseFloatExGTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFloatIgnore(): FloatIgnore {
  return { val: 0 };
}

export const FloatIgnore: MessageFns<FloatIgnore> = {
  encode(message: FloatIgnore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).float(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FloatIgnore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFloatIgnore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FloatIgnore {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: FloatIgnore): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<FloatIgnore>): FloatIgnore {
    return FloatIgnore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FloatIgnore>): FloatIgnore {
    const message = createBaseFloatIgnore();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleNone(): DoubleNone {
  return { val: 0 };
}

export const DoubleNone: MessageFns<DoubleNone> = {
  encode(message: DoubleNone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleNone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleNone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleNone {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleNone): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleNone>): DoubleNone {
    return DoubleNone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleNone>): DoubleNone {
    const message = createBaseDoubleNone();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleConst(): DoubleConst {
  return { val: 0 };
}

export const DoubleConst: MessageFns<DoubleConst> = {
  encode(message: DoubleConst, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleConst {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleConst();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleConst {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleConst): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleConst>): DoubleConst {
    return DoubleConst.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleConst>): DoubleConst {
    const message = createBaseDoubleConst();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleIn(): DoubleIn {
  return { val: 0 };
}

export const DoubleIn: MessageFns<DoubleIn> = {
  encode(message: DoubleIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleIn {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleIn>): DoubleIn {
    return DoubleIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleIn>): DoubleIn {
    const message = createBaseDoubleIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleNotIn(): DoubleNotIn {
  return { val: 0 };
}

export const DoubleNotIn: MessageFns<DoubleNotIn> = {
  encode(message: DoubleNotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleNotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleNotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleNotIn {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleNotIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleNotIn>): DoubleNotIn {
    return DoubleNotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleNotIn>): DoubleNotIn {
    const message = createBaseDoubleNotIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleLT(): DoubleLT {
  return { val: 0 };
}

export const DoubleLT: MessageFns<DoubleLT> = {
  encode(message: DoubleLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleLT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleLT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleLT>): DoubleLT {
    return DoubleLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleLT>): DoubleLT {
    const message = createBaseDoubleLT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleLTE(): DoubleLTE {
  return { val: 0 };
}

export const DoubleLTE: MessageFns<DoubleLTE> = {
  encode(message: DoubleLTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleLTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleLTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleLTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleLTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleLTE>): DoubleLTE {
    return DoubleLTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleLTE>): DoubleLTE {
    const message = createBaseDoubleLTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleGT(): DoubleGT {
  return { val: 0 };
}

export const DoubleGT: MessageFns<DoubleGT> = {
  encode(message: DoubleGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleGT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleGT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleGT>): DoubleGT {
    return DoubleGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleGT>): DoubleGT {
    const message = createBaseDoubleGT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleGTE(): DoubleGTE {
  return { val: 0 };
}

export const DoubleGTE: MessageFns<DoubleGTE> = {
  encode(message: DoubleGTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleGTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleGTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleGTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleGTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleGTE>): DoubleGTE {
    return DoubleGTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleGTE>): DoubleGTE {
    const message = createBaseDoubleGTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleGTLT(): DoubleGTLT {
  return { val: 0 };
}

export const DoubleGTLT: MessageFns<DoubleGTLT> = {
  encode(message: DoubleGTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleGTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleGTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleGTLT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleGTLT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleGTLT>): DoubleGTLT {
    return DoubleGTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleGTLT>): DoubleGTLT {
    const message = createBaseDoubleGTLT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleExLTGT(): DoubleExLTGT {
  return { val: 0 };
}

export const DoubleExLTGT: MessageFns<DoubleExLTGT> = {
  encode(message: DoubleExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleExLTGT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleExLTGT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleExLTGT>): DoubleExLTGT {
    return DoubleExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleExLTGT>): DoubleExLTGT {
    const message = createBaseDoubleExLTGT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleGTELTE(): DoubleGTELTE {
  return { val: 0 };
}

export const DoubleGTELTE: MessageFns<DoubleGTELTE> = {
  encode(message: DoubleGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleGTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleGTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleGTELTE>): DoubleGTELTE {
    return DoubleGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleGTELTE>): DoubleGTELTE {
    const message = createBaseDoubleGTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleExGTELTE(): DoubleExGTELTE {
  return { val: 0 };
}

export const DoubleExGTELTE: MessageFns<DoubleExGTELTE> = {
  encode(message: DoubleExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleExGTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleExGTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleExGTELTE>): DoubleExGTELTE {
    return DoubleExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleExGTELTE>): DoubleExGTELTE {
    const message = createBaseDoubleExGTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseDoubleIgnore(): DoubleIgnore {
  return { val: 0 };
}

export const DoubleIgnore: MessageFns<DoubleIgnore> = {
  encode(message: DoubleIgnore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(9).double(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleIgnore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleIgnore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleIgnore {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: DoubleIgnore): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = message.val;
    }
    return obj;
  },

  create(base?: DeepPartial<DoubleIgnore>): DoubleIgnore {
    return DoubleIgnore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DoubleIgnore>): DoubleIgnore {
    const message = createBaseDoubleIgnore();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32None(): Int32None {
  return { val: 0 };
}

export const Int32None: MessageFns<Int32None> = {
  encode(message: Int32None, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32None {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32None();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32None {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32None): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32None>): Int32None {
    return Int32None.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32None>): Int32None {
    const message = createBaseInt32None();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32Const(): Int32Const {
  return { val: 0 };
}

export const Int32Const: MessageFns<Int32Const> = {
  encode(message: Int32Const, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32Const {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32Const();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32Const {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32Const): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32Const>): Int32Const {
    return Int32Const.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32Const>): Int32Const {
    const message = createBaseInt32Const();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32In(): Int32In {
  return { val: 0 };
}

export const Int32In: MessageFns<Int32In> = {
  encode(message: Int32In, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32In {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32In();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32In {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32In): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32In>): Int32In {
    return Int32In.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32In>): Int32In {
    const message = createBaseInt32In();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32NotIn(): Int32NotIn {
  return { val: 0 };
}

export const Int32NotIn: MessageFns<Int32NotIn> = {
  encode(message: Int32NotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32NotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32NotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32NotIn {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32NotIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32NotIn>): Int32NotIn {
    return Int32NotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32NotIn>): Int32NotIn {
    const message = createBaseInt32NotIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32LT(): Int32LT {
  return { val: 0 };
}

export const Int32LT: MessageFns<Int32LT> = {
  encode(message: Int32LT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32LT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32LT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32LT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32LT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32LT>): Int32LT {
    return Int32LT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32LT>): Int32LT {
    const message = createBaseInt32LT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32LTE(): Int32LTE {
  return { val: 0 };
}

export const Int32LTE: MessageFns<Int32LTE> = {
  encode(message: Int32LTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32LTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32LTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32LTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32LTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32LTE>): Int32LTE {
    return Int32LTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32LTE>): Int32LTE {
    const message = createBaseInt32LTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32GT(): Int32GT {
  return { val: 0 };
}

export const Int32GT: MessageFns<Int32GT> = {
  encode(message: Int32GT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32GT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32GT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32GT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32GT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32GT>): Int32GT {
    return Int32GT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32GT>): Int32GT {
    const message = createBaseInt32GT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32GTE(): Int32GTE {
  return { val: 0 };
}

export const Int32GTE: MessageFns<Int32GTE> = {
  encode(message: Int32GTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32GTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32GTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32GTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32GTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32GTE>): Int32GTE {
    return Int32GTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32GTE>): Int32GTE {
    const message = createBaseInt32GTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32GTLT(): Int32GTLT {
  return { val: 0 };
}

export const Int32GTLT: MessageFns<Int32GTLT> = {
  encode(message: Int32GTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32GTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32GTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32GTLT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32GTLT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32GTLT>): Int32GTLT {
    return Int32GTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32GTLT>): Int32GTLT {
    const message = createBaseInt32GTLT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32ExLTGT(): Int32ExLTGT {
  return { val: 0 };
}

export const Int32ExLTGT: MessageFns<Int32ExLTGT> = {
  encode(message: Int32ExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32ExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32ExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32ExLTGT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32ExLTGT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32ExLTGT>): Int32ExLTGT {
    return Int32ExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32ExLTGT>): Int32ExLTGT {
    const message = createBaseInt32ExLTGT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32GTELTE(): Int32GTELTE {
  return { val: 0 };
}

export const Int32GTELTE: MessageFns<Int32GTELTE> = {
  encode(message: Int32GTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32GTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32GTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32GTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32GTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32GTELTE>): Int32GTELTE {
    return Int32GTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32GTELTE>): Int32GTELTE {
    const message = createBaseInt32GTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32ExGTELTE(): Int32ExGTELTE {
  return { val: 0 };
}

export const Int32ExGTELTE: MessageFns<Int32ExGTELTE> = {
  encode(message: Int32ExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32ExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32ExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32ExGTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32ExGTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32ExGTELTE>): Int32ExGTELTE {
    return Int32ExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32ExGTELTE>): Int32ExGTELTE {
    const message = createBaseInt32ExGTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt32Ignore(): Int32Ignore {
  return { val: 0 };
}

export const Int32Ignore: MessageFns<Int32Ignore> = {
  encode(message: Int32Ignore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).int32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int32Ignore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt32Ignore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int32Ignore {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Int32Ignore): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Int32Ignore>): Int32Ignore {
    return Int32Ignore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int32Ignore>): Int32Ignore {
    const message = createBaseInt32Ignore();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseInt64None(): Int64None {
  return { val: Long.ZERO };
}

export const Int64None: MessageFns<Int64None> = {
  encode(message: Int64None, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64None {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64None();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64None {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64None): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64None>): Int64None {
    return Int64None.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64None>): Int64None {
    const message = createBaseInt64None();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64Const(): Int64Const {
  return { val: Long.ZERO };
}

export const Int64Const: MessageFns<Int64Const> = {
  encode(message: Int64Const, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64Const {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64Const();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64Const {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64Const): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64Const>): Int64Const {
    return Int64Const.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64Const>): Int64Const {
    const message = createBaseInt64Const();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64In(): Int64In {
  return { val: Long.ZERO };
}

export const Int64In: MessageFns<Int64In> = {
  encode(message: Int64In, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64In {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64In();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64In {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64In): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64In>): Int64In {
    return Int64In.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64In>): Int64In {
    const message = createBaseInt64In();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64NotIn(): Int64NotIn {
  return { val: Long.ZERO };
}

export const Int64NotIn: MessageFns<Int64NotIn> = {
  encode(message: Int64NotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64NotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64NotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64NotIn {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64NotIn): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64NotIn>): Int64NotIn {
    return Int64NotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64NotIn>): Int64NotIn {
    const message = createBaseInt64NotIn();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64LT(): Int64LT {
  return { val: Long.ZERO };
}

export const Int64LT: MessageFns<Int64LT> = {
  encode(message: Int64LT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64LT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64LT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64LT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64LT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64LT>): Int64LT {
    return Int64LT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64LT>): Int64LT {
    const message = createBaseInt64LT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64LTE(): Int64LTE {
  return { val: Long.ZERO };
}

export const Int64LTE: MessageFns<Int64LTE> = {
  encode(message: Int64LTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64LTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64LTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64LTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64LTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64LTE>): Int64LTE {
    return Int64LTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64LTE>): Int64LTE {
    const message = createBaseInt64LTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64GT(): Int64GT {
  return { val: Long.ZERO };
}

export const Int64GT: MessageFns<Int64GT> = {
  encode(message: Int64GT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64GT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64GT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64GT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64GT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64GT>): Int64GT {
    return Int64GT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64GT>): Int64GT {
    const message = createBaseInt64GT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64GTE(): Int64GTE {
  return { val: Long.ZERO };
}

export const Int64GTE: MessageFns<Int64GTE> = {
  encode(message: Int64GTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64GTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64GTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64GTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64GTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64GTE>): Int64GTE {
    return Int64GTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64GTE>): Int64GTE {
    const message = createBaseInt64GTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64GTLT(): Int64GTLT {
  return { val: Long.ZERO };
}

export const Int64GTLT: MessageFns<Int64GTLT> = {
  encode(message: Int64GTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64GTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64GTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64GTLT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64GTLT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64GTLT>): Int64GTLT {
    return Int64GTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64GTLT>): Int64GTLT {
    const message = createBaseInt64GTLT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64ExLTGT(): Int64ExLTGT {
  return { val: Long.ZERO };
}

export const Int64ExLTGT: MessageFns<Int64ExLTGT> = {
  encode(message: Int64ExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64ExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64ExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64ExLTGT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64ExLTGT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64ExLTGT>): Int64ExLTGT {
    return Int64ExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64ExLTGT>): Int64ExLTGT {
    const message = createBaseInt64ExLTGT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64GTELTE(): Int64GTELTE {
  return { val: Long.ZERO };
}

export const Int64GTELTE: MessageFns<Int64GTELTE> = {
  encode(message: Int64GTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64GTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64GTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64GTELTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64GTELTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64GTELTE>): Int64GTELTE {
    return Int64GTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64GTELTE>): Int64GTELTE {
    const message = createBaseInt64GTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64ExGTELTE(): Int64ExGTELTE {
  return { val: Long.ZERO };
}

export const Int64ExGTELTE: MessageFns<Int64ExGTELTE> = {
  encode(message: Int64ExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64ExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64ExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64ExGTELTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64ExGTELTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64ExGTELTE>): Int64ExGTELTE {
    return Int64ExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64ExGTELTE>): Int64ExGTELTE {
    const message = createBaseInt64ExGTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64Ignore(): Int64Ignore {
  return { val: Long.ZERO };
}

export const Int64Ignore: MessageFns<Int64Ignore> = {
  encode(message: Int64Ignore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64Ignore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64Ignore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64Ignore {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: Int64Ignore): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64Ignore>): Int64Ignore {
    return Int64Ignore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64Ignore>): Int64Ignore {
    const message = createBaseInt64Ignore();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseUInt32None(): UInt32None {
  return { val: 0 };
}

export const UInt32None: MessageFns<UInt32None> = {
  encode(message: UInt32None, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32None {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32None();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32None {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32None): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32None>): UInt32None {
    return UInt32None.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32None>): UInt32None {
    const message = createBaseUInt32None();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32Const(): UInt32Const {
  return { val: 0 };
}

export const UInt32Const: MessageFns<UInt32Const> = {
  encode(message: UInt32Const, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32Const {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32Const();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32Const {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32Const): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32Const>): UInt32Const {
    return UInt32Const.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32Const>): UInt32Const {
    const message = createBaseUInt32Const();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32In(): UInt32In {
  return { val: 0 };
}

export const UInt32In: MessageFns<UInt32In> = {
  encode(message: UInt32In, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32In {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32In();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32In {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32In): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32In>): UInt32In {
    return UInt32In.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32In>): UInt32In {
    const message = createBaseUInt32In();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32NotIn(): UInt32NotIn {
  return { val: 0 };
}

export const UInt32NotIn: MessageFns<UInt32NotIn> = {
  encode(message: UInt32NotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32NotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32NotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32NotIn {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32NotIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32NotIn>): UInt32NotIn {
    return UInt32NotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32NotIn>): UInt32NotIn {
    const message = createBaseUInt32NotIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32LT(): UInt32LT {
  return { val: 0 };
}

export const UInt32LT: MessageFns<UInt32LT> = {
  encode(message: UInt32LT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32LT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32LT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32LT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32LT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32LT>): UInt32LT {
    return UInt32LT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32LT>): UInt32LT {
    const message = createBaseUInt32LT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32LTE(): UInt32LTE {
  return { val: 0 };
}

export const UInt32LTE: MessageFns<UInt32LTE> = {
  encode(message: UInt32LTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32LTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32LTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32LTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32LTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32LTE>): UInt32LTE {
    return UInt32LTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32LTE>): UInt32LTE {
    const message = createBaseUInt32LTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32GT(): UInt32GT {
  return { val: 0 };
}

export const UInt32GT: MessageFns<UInt32GT> = {
  encode(message: UInt32GT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32GT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32GT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32GT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32GT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32GT>): UInt32GT {
    return UInt32GT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32GT>): UInt32GT {
    const message = createBaseUInt32GT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32GTE(): UInt32GTE {
  return { val: 0 };
}

export const UInt32GTE: MessageFns<UInt32GTE> = {
  encode(message: UInt32GTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32GTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32GTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32GTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32GTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32GTE>): UInt32GTE {
    return UInt32GTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32GTE>): UInt32GTE {
    const message = createBaseUInt32GTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32GTLT(): UInt32GTLT {
  return { val: 0 };
}

export const UInt32GTLT: MessageFns<UInt32GTLT> = {
  encode(message: UInt32GTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32GTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32GTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32GTLT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32GTLT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32GTLT>): UInt32GTLT {
    return UInt32GTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32GTLT>): UInt32GTLT {
    const message = createBaseUInt32GTLT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32ExLTGT(): UInt32ExLTGT {
  return { val: 0 };
}

export const UInt32ExLTGT: MessageFns<UInt32ExLTGT> = {
  encode(message: UInt32ExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32ExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32ExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32ExLTGT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32ExLTGT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32ExLTGT>): UInt32ExLTGT {
    return UInt32ExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32ExLTGT>): UInt32ExLTGT {
    const message = createBaseUInt32ExLTGT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32GTELTE(): UInt32GTELTE {
  return { val: 0 };
}

export const UInt32GTELTE: MessageFns<UInt32GTELTE> = {
  encode(message: UInt32GTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32GTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32GTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32GTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32GTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32GTELTE>): UInt32GTELTE {
    return UInt32GTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32GTELTE>): UInt32GTELTE {
    const message = createBaseUInt32GTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32ExGTELTE(): UInt32ExGTELTE {
  return { val: 0 };
}

export const UInt32ExGTELTE: MessageFns<UInt32ExGTELTE> = {
  encode(message: UInt32ExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32ExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32ExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32ExGTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32ExGTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32ExGTELTE>): UInt32ExGTELTE {
    return UInt32ExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32ExGTELTE>): UInt32ExGTELTE {
    const message = createBaseUInt32ExGTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt32Ignore(): UInt32Ignore {
  return { val: 0 };
}

export const UInt32Ignore: MessageFns<UInt32Ignore> = {
  encode(message: UInt32Ignore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).uint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt32Ignore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt32Ignore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt32Ignore {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: UInt32Ignore): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<UInt32Ignore>): UInt32Ignore {
    return UInt32Ignore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt32Ignore>): UInt32Ignore {
    const message = createBaseUInt32Ignore();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseUInt64None(): UInt64None {
  return { val: Long.UZERO };
}

export const UInt64None: MessageFns<UInt64None> = {
  encode(message: UInt64None, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64None {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64None();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64None {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64None): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64None>): UInt64None {
    return UInt64None.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64None>): UInt64None {
    const message = createBaseUInt64None();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64Const(): UInt64Const {
  return { val: Long.UZERO };
}

export const UInt64Const: MessageFns<UInt64Const> = {
  encode(message: UInt64Const, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64Const {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64Const();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64Const {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64Const): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64Const>): UInt64Const {
    return UInt64Const.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64Const>): UInt64Const {
    const message = createBaseUInt64Const();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64In(): UInt64In {
  return { val: Long.UZERO };
}

export const UInt64In: MessageFns<UInt64In> = {
  encode(message: UInt64In, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64In {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64In();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64In {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64In): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64In>): UInt64In {
    return UInt64In.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64In>): UInt64In {
    const message = createBaseUInt64In();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64NotIn(): UInt64NotIn {
  return { val: Long.UZERO };
}

export const UInt64NotIn: MessageFns<UInt64NotIn> = {
  encode(message: UInt64NotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64NotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64NotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64NotIn {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64NotIn): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64NotIn>): UInt64NotIn {
    return UInt64NotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64NotIn>): UInt64NotIn {
    const message = createBaseUInt64NotIn();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64LT(): UInt64LT {
  return { val: Long.UZERO };
}

export const UInt64LT: MessageFns<UInt64LT> = {
  encode(message: UInt64LT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64LT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64LT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64LT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64LT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64LT>): UInt64LT {
    return UInt64LT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64LT>): UInt64LT {
    const message = createBaseUInt64LT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64LTE(): UInt64LTE {
  return { val: Long.UZERO };
}

export const UInt64LTE: MessageFns<UInt64LTE> = {
  encode(message: UInt64LTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64LTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64LTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64LTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64LTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64LTE>): UInt64LTE {
    return UInt64LTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64LTE>): UInt64LTE {
    const message = createBaseUInt64LTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64GT(): UInt64GT {
  return { val: Long.UZERO };
}

export const UInt64GT: MessageFns<UInt64GT> = {
  encode(message: UInt64GT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64GT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64GT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64GT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64GT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64GT>): UInt64GT {
    return UInt64GT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64GT>): UInt64GT {
    const message = createBaseUInt64GT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64GTE(): UInt64GTE {
  return { val: Long.UZERO };
}

export const UInt64GTE: MessageFns<UInt64GTE> = {
  encode(message: UInt64GTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64GTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64GTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64GTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64GTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64GTE>): UInt64GTE {
    return UInt64GTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64GTE>): UInt64GTE {
    const message = createBaseUInt64GTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64GTLT(): UInt64GTLT {
  return { val: Long.UZERO };
}

export const UInt64GTLT: MessageFns<UInt64GTLT> = {
  encode(message: UInt64GTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64GTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64GTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64GTLT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64GTLT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64GTLT>): UInt64GTLT {
    return UInt64GTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64GTLT>): UInt64GTLT {
    const message = createBaseUInt64GTLT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64ExLTGT(): UInt64ExLTGT {
  return { val: Long.UZERO };
}

export const UInt64ExLTGT: MessageFns<UInt64ExLTGT> = {
  encode(message: UInt64ExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64ExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64ExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64ExLTGT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64ExLTGT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64ExLTGT>): UInt64ExLTGT {
    return UInt64ExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64ExLTGT>): UInt64ExLTGT {
    const message = createBaseUInt64ExLTGT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64GTELTE(): UInt64GTELTE {
  return { val: Long.UZERO };
}

export const UInt64GTELTE: MessageFns<UInt64GTELTE> = {
  encode(message: UInt64GTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64GTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64GTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64GTELTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64GTELTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64GTELTE>): UInt64GTELTE {
    return UInt64GTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64GTELTE>): UInt64GTELTE {
    const message = createBaseUInt64GTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64ExGTELTE(): UInt64ExGTELTE {
  return { val: Long.UZERO };
}

export const UInt64ExGTELTE: MessageFns<UInt64ExGTELTE> = {
  encode(message: UInt64ExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64ExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64ExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64ExGTELTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64ExGTELTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64ExGTELTE>): UInt64ExGTELTE {
    return UInt64ExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64ExGTELTE>): UInt64ExGTELTE {
    const message = createBaseUInt64ExGTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseUInt64Ignore(): UInt64Ignore {
  return { val: Long.UZERO };
}

export const UInt64Ignore: MessageFns<UInt64Ignore> = {
  encode(message: UInt64Ignore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UInt64Ignore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUInt64Ignore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.uint64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UInt64Ignore {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: UInt64Ignore): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<UInt64Ignore>): UInt64Ignore {
    return UInt64Ignore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UInt64Ignore>): UInt64Ignore {
    const message = createBaseUInt64Ignore();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseSInt32None(): SInt32None {
  return { val: 0 };
}

export const SInt32None: MessageFns<SInt32None> = {
  encode(message: SInt32None, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32None {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32None();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32None {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32None): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32None>): SInt32None {
    return SInt32None.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32None>): SInt32None {
    const message = createBaseSInt32None();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32Const(): SInt32Const {
  return { val: 0 };
}

export const SInt32Const: MessageFns<SInt32Const> = {
  encode(message: SInt32Const, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32Const {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32Const();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32Const {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32Const): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32Const>): SInt32Const {
    return SInt32Const.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32Const>): SInt32Const {
    const message = createBaseSInt32Const();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32In(): SInt32In {
  return { val: 0 };
}

export const SInt32In: MessageFns<SInt32In> = {
  encode(message: SInt32In, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32In {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32In();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32In {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32In): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32In>): SInt32In {
    return SInt32In.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32In>): SInt32In {
    const message = createBaseSInt32In();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32NotIn(): SInt32NotIn {
  return { val: 0 };
}

export const SInt32NotIn: MessageFns<SInt32NotIn> = {
  encode(message: SInt32NotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32NotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32NotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32NotIn {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32NotIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32NotIn>): SInt32NotIn {
    return SInt32NotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32NotIn>): SInt32NotIn {
    const message = createBaseSInt32NotIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32LT(): SInt32LT {
  return { val: 0 };
}

export const SInt32LT: MessageFns<SInt32LT> = {
  encode(message: SInt32LT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32LT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32LT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32LT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32LT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32LT>): SInt32LT {
    return SInt32LT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32LT>): SInt32LT {
    const message = createBaseSInt32LT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32LTE(): SInt32LTE {
  return { val: 0 };
}

export const SInt32LTE: MessageFns<SInt32LTE> = {
  encode(message: SInt32LTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32LTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32LTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32LTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32LTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32LTE>): SInt32LTE {
    return SInt32LTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32LTE>): SInt32LTE {
    const message = createBaseSInt32LTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32GT(): SInt32GT {
  return { val: 0 };
}

export const SInt32GT: MessageFns<SInt32GT> = {
  encode(message: SInt32GT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32GT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32GT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32GT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32GT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32GT>): SInt32GT {
    return SInt32GT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32GT>): SInt32GT {
    const message = createBaseSInt32GT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32GTE(): SInt32GTE {
  return { val: 0 };
}

export const SInt32GTE: MessageFns<SInt32GTE> = {
  encode(message: SInt32GTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32GTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32GTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32GTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32GTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32GTE>): SInt32GTE {
    return SInt32GTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32GTE>): SInt32GTE {
    const message = createBaseSInt32GTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32GTLT(): SInt32GTLT {
  return { val: 0 };
}

export const SInt32GTLT: MessageFns<SInt32GTLT> = {
  encode(message: SInt32GTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32GTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32GTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32GTLT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32GTLT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32GTLT>): SInt32GTLT {
    return SInt32GTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32GTLT>): SInt32GTLT {
    const message = createBaseSInt32GTLT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32ExLTGT(): SInt32ExLTGT {
  return { val: 0 };
}

export const SInt32ExLTGT: MessageFns<SInt32ExLTGT> = {
  encode(message: SInt32ExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32ExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32ExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32ExLTGT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32ExLTGT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32ExLTGT>): SInt32ExLTGT {
    return SInt32ExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32ExLTGT>): SInt32ExLTGT {
    const message = createBaseSInt32ExLTGT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32GTELTE(): SInt32GTELTE {
  return { val: 0 };
}

export const SInt32GTELTE: MessageFns<SInt32GTELTE> = {
  encode(message: SInt32GTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32GTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32GTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32GTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32GTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32GTELTE>): SInt32GTELTE {
    return SInt32GTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32GTELTE>): SInt32GTELTE {
    const message = createBaseSInt32GTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32ExGTELTE(): SInt32ExGTELTE {
  return { val: 0 };
}

export const SInt32ExGTELTE: MessageFns<SInt32ExGTELTE> = {
  encode(message: SInt32ExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32ExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32ExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32ExGTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32ExGTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32ExGTELTE>): SInt32ExGTELTE {
    return SInt32ExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32ExGTELTE>): SInt32ExGTELTE {
    const message = createBaseSInt32ExGTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt32Ignore(): SInt32Ignore {
  return { val: 0 };
}

export const SInt32Ignore: MessageFns<SInt32Ignore> = {
  encode(message: SInt32Ignore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(8).sint32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt32Ignore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt32Ignore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = reader.sint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt32Ignore {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SInt32Ignore): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SInt32Ignore>): SInt32Ignore {
    return SInt32Ignore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt32Ignore>): SInt32Ignore {
    const message = createBaseSInt32Ignore();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSInt64None(): SInt64None {
  return { val: Long.ZERO };
}

export const SInt64None: MessageFns<SInt64None> = {
  encode(message: SInt64None, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64None {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64None();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64None {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64None): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64None>): SInt64None {
    return SInt64None.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64None>): SInt64None {
    const message = createBaseSInt64None();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64Const(): SInt64Const {
  return { val: Long.ZERO };
}

export const SInt64Const: MessageFns<SInt64Const> = {
  encode(message: SInt64Const, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64Const {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64Const();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64Const {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64Const): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64Const>): SInt64Const {
    return SInt64Const.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64Const>): SInt64Const {
    const message = createBaseSInt64Const();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64In(): SInt64In {
  return { val: Long.ZERO };
}

export const SInt64In: MessageFns<SInt64In> = {
  encode(message: SInt64In, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64In {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64In();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64In {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64In): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64In>): SInt64In {
    return SInt64In.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64In>): SInt64In {
    const message = createBaseSInt64In();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64NotIn(): SInt64NotIn {
  return { val: Long.ZERO };
}

export const SInt64NotIn: MessageFns<SInt64NotIn> = {
  encode(message: SInt64NotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64NotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64NotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64NotIn {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64NotIn): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64NotIn>): SInt64NotIn {
    return SInt64NotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64NotIn>): SInt64NotIn {
    const message = createBaseSInt64NotIn();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64LT(): SInt64LT {
  return { val: Long.ZERO };
}

export const SInt64LT: MessageFns<SInt64LT> = {
  encode(message: SInt64LT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64LT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64LT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64LT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64LT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64LT>): SInt64LT {
    return SInt64LT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64LT>): SInt64LT {
    const message = createBaseSInt64LT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64LTE(): SInt64LTE {
  return { val: Long.ZERO };
}

export const SInt64LTE: MessageFns<SInt64LTE> = {
  encode(message: SInt64LTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64LTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64LTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64LTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64LTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64LTE>): SInt64LTE {
    return SInt64LTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64LTE>): SInt64LTE {
    const message = createBaseSInt64LTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64GT(): SInt64GT {
  return { val: Long.ZERO };
}

export const SInt64GT: MessageFns<SInt64GT> = {
  encode(message: SInt64GT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64GT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64GT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64GT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64GT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64GT>): SInt64GT {
    return SInt64GT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64GT>): SInt64GT {
    const message = createBaseSInt64GT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64GTE(): SInt64GTE {
  return { val: Long.ZERO };
}

export const SInt64GTE: MessageFns<SInt64GTE> = {
  encode(message: SInt64GTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64GTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64GTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64GTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64GTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64GTE>): SInt64GTE {
    return SInt64GTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64GTE>): SInt64GTE {
    const message = createBaseSInt64GTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64GTLT(): SInt64GTLT {
  return { val: Long.ZERO };
}

export const SInt64GTLT: MessageFns<SInt64GTLT> = {
  encode(message: SInt64GTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64GTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64GTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64GTLT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64GTLT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64GTLT>): SInt64GTLT {
    return SInt64GTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64GTLT>): SInt64GTLT {
    const message = createBaseSInt64GTLT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64ExLTGT(): SInt64ExLTGT {
  return { val: Long.ZERO };
}

export const SInt64ExLTGT: MessageFns<SInt64ExLTGT> = {
  encode(message: SInt64ExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64ExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64ExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64ExLTGT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64ExLTGT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64ExLTGT>): SInt64ExLTGT {
    return SInt64ExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64ExLTGT>): SInt64ExLTGT {
    const message = createBaseSInt64ExLTGT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64GTELTE(): SInt64GTELTE {
  return { val: Long.ZERO };
}

export const SInt64GTELTE: MessageFns<SInt64GTELTE> = {
  encode(message: SInt64GTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64GTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64GTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64GTELTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64GTELTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64GTELTE>): SInt64GTELTE {
    return SInt64GTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64GTELTE>): SInt64GTELTE {
    const message = createBaseSInt64GTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64ExGTELTE(): SInt64ExGTELTE {
  return { val: Long.ZERO };
}

export const SInt64ExGTELTE: MessageFns<SInt64ExGTELTE> = {
  encode(message: SInt64ExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64ExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64ExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64ExGTELTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64ExGTELTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64ExGTELTE>): SInt64ExGTELTE {
    return SInt64ExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64ExGTELTE>): SInt64ExGTELTE {
    const message = createBaseSInt64ExGTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSInt64Ignore(): SInt64Ignore {
  return { val: Long.ZERO };
}

export const SInt64Ignore: MessageFns<SInt64Ignore> = {
  encode(message: SInt64Ignore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(8).sint64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SInt64Ignore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSInt64Ignore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.sint64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SInt64Ignore {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SInt64Ignore): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SInt64Ignore>): SInt64Ignore {
    return SInt64Ignore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SInt64Ignore>): SInt64Ignore {
    const message = createBaseSInt64Ignore();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseFixed32None(): Fixed32None {
  return { val: 0 };
}

export const Fixed32None: MessageFns<Fixed32None> = {
  encode(message: Fixed32None, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32None {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32None();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32None {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32None): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32None>): Fixed32None {
    return Fixed32None.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32None>): Fixed32None {
    const message = createBaseFixed32None();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32Const(): Fixed32Const {
  return { val: 0 };
}

export const Fixed32Const: MessageFns<Fixed32Const> = {
  encode(message: Fixed32Const, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32Const {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32Const();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32Const {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32Const): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32Const>): Fixed32Const {
    return Fixed32Const.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32Const>): Fixed32Const {
    const message = createBaseFixed32Const();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32In(): Fixed32In {
  return { val: 0 };
}

export const Fixed32In: MessageFns<Fixed32In> = {
  encode(message: Fixed32In, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32In {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32In();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32In {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32In): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32In>): Fixed32In {
    return Fixed32In.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32In>): Fixed32In {
    const message = createBaseFixed32In();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32NotIn(): Fixed32NotIn {
  return { val: 0 };
}

export const Fixed32NotIn: MessageFns<Fixed32NotIn> = {
  encode(message: Fixed32NotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32NotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32NotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32NotIn {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32NotIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32NotIn>): Fixed32NotIn {
    return Fixed32NotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32NotIn>): Fixed32NotIn {
    const message = createBaseFixed32NotIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32LT(): Fixed32LT {
  return { val: 0 };
}

export const Fixed32LT: MessageFns<Fixed32LT> = {
  encode(message: Fixed32LT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32LT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32LT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32LT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32LT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32LT>): Fixed32LT {
    return Fixed32LT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32LT>): Fixed32LT {
    const message = createBaseFixed32LT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32LTE(): Fixed32LTE {
  return { val: 0 };
}

export const Fixed32LTE: MessageFns<Fixed32LTE> = {
  encode(message: Fixed32LTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32LTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32LTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32LTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32LTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32LTE>): Fixed32LTE {
    return Fixed32LTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32LTE>): Fixed32LTE {
    const message = createBaseFixed32LTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32GT(): Fixed32GT {
  return { val: 0 };
}

export const Fixed32GT: MessageFns<Fixed32GT> = {
  encode(message: Fixed32GT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32GT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32GT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32GT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32GT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32GT>): Fixed32GT {
    return Fixed32GT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32GT>): Fixed32GT {
    const message = createBaseFixed32GT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32GTE(): Fixed32GTE {
  return { val: 0 };
}

export const Fixed32GTE: MessageFns<Fixed32GTE> = {
  encode(message: Fixed32GTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32GTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32GTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32GTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32GTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32GTE>): Fixed32GTE {
    return Fixed32GTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32GTE>): Fixed32GTE {
    const message = createBaseFixed32GTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32GTLT(): Fixed32GTLT {
  return { val: 0 };
}

export const Fixed32GTLT: MessageFns<Fixed32GTLT> = {
  encode(message: Fixed32GTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32GTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32GTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32GTLT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32GTLT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32GTLT>): Fixed32GTLT {
    return Fixed32GTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32GTLT>): Fixed32GTLT {
    const message = createBaseFixed32GTLT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32ExLTGT(): Fixed32ExLTGT {
  return { val: 0 };
}

export const Fixed32ExLTGT: MessageFns<Fixed32ExLTGT> = {
  encode(message: Fixed32ExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32ExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32ExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32ExLTGT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32ExLTGT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32ExLTGT>): Fixed32ExLTGT {
    return Fixed32ExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32ExLTGT>): Fixed32ExLTGT {
    const message = createBaseFixed32ExLTGT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32GTELTE(): Fixed32GTELTE {
  return { val: 0 };
}

export const Fixed32GTELTE: MessageFns<Fixed32GTELTE> = {
  encode(message: Fixed32GTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32GTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32GTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32GTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32GTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32GTELTE>): Fixed32GTELTE {
    return Fixed32GTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32GTELTE>): Fixed32GTELTE {
    const message = createBaseFixed32GTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32ExGTELTE(): Fixed32ExGTELTE {
  return { val: 0 };
}

export const Fixed32ExGTELTE: MessageFns<Fixed32ExGTELTE> = {
  encode(message: Fixed32ExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32ExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32ExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32ExGTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32ExGTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32ExGTELTE>): Fixed32ExGTELTE {
    return Fixed32ExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32ExGTELTE>): Fixed32ExGTELTE {
    const message = createBaseFixed32ExGTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed32Ignore(): Fixed32Ignore {
  return { val: 0 };
}

export const Fixed32Ignore: MessageFns<Fixed32Ignore> = {
  encode(message: Fixed32Ignore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).fixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed32Ignore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed32Ignore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.fixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed32Ignore {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: Fixed32Ignore): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed32Ignore>): Fixed32Ignore {
    return Fixed32Ignore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed32Ignore>): Fixed32Ignore {
    const message = createBaseFixed32Ignore();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseFixed64None(): Fixed64None {
  return { val: Long.UZERO };
}

export const Fixed64None: MessageFns<Fixed64None> = {
  encode(message: Fixed64None, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64None {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64None();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64None {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64None): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64None>): Fixed64None {
    return Fixed64None.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64None>): Fixed64None {
    const message = createBaseFixed64None();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64Const(): Fixed64Const {
  return { val: Long.UZERO };
}

export const Fixed64Const: MessageFns<Fixed64Const> = {
  encode(message: Fixed64Const, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64Const {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64Const();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64Const {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64Const): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64Const>): Fixed64Const {
    return Fixed64Const.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64Const>): Fixed64Const {
    const message = createBaseFixed64Const();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64In(): Fixed64In {
  return { val: Long.UZERO };
}

export const Fixed64In: MessageFns<Fixed64In> = {
  encode(message: Fixed64In, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64In {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64In();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64In {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64In): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64In>): Fixed64In {
    return Fixed64In.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64In>): Fixed64In {
    const message = createBaseFixed64In();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64NotIn(): Fixed64NotIn {
  return { val: Long.UZERO };
}

export const Fixed64NotIn: MessageFns<Fixed64NotIn> = {
  encode(message: Fixed64NotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64NotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64NotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64NotIn {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64NotIn): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64NotIn>): Fixed64NotIn {
    return Fixed64NotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64NotIn>): Fixed64NotIn {
    const message = createBaseFixed64NotIn();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64LT(): Fixed64LT {
  return { val: Long.UZERO };
}

export const Fixed64LT: MessageFns<Fixed64LT> = {
  encode(message: Fixed64LT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64LT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64LT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64LT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64LT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64LT>): Fixed64LT {
    return Fixed64LT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64LT>): Fixed64LT {
    const message = createBaseFixed64LT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64LTE(): Fixed64LTE {
  return { val: Long.UZERO };
}

export const Fixed64LTE: MessageFns<Fixed64LTE> = {
  encode(message: Fixed64LTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64LTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64LTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64LTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64LTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64LTE>): Fixed64LTE {
    return Fixed64LTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64LTE>): Fixed64LTE {
    const message = createBaseFixed64LTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64GT(): Fixed64GT {
  return { val: Long.UZERO };
}

export const Fixed64GT: MessageFns<Fixed64GT> = {
  encode(message: Fixed64GT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64GT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64GT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64GT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64GT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64GT>): Fixed64GT {
    return Fixed64GT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64GT>): Fixed64GT {
    const message = createBaseFixed64GT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64GTE(): Fixed64GTE {
  return { val: Long.UZERO };
}

export const Fixed64GTE: MessageFns<Fixed64GTE> = {
  encode(message: Fixed64GTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64GTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64GTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64GTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64GTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64GTE>): Fixed64GTE {
    return Fixed64GTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64GTE>): Fixed64GTE {
    const message = createBaseFixed64GTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64GTLT(): Fixed64GTLT {
  return { val: Long.UZERO };
}

export const Fixed64GTLT: MessageFns<Fixed64GTLT> = {
  encode(message: Fixed64GTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64GTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64GTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64GTLT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64GTLT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64GTLT>): Fixed64GTLT {
    return Fixed64GTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64GTLT>): Fixed64GTLT {
    const message = createBaseFixed64GTLT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64ExLTGT(): Fixed64ExLTGT {
  return { val: Long.UZERO };
}

export const Fixed64ExLTGT: MessageFns<Fixed64ExLTGT> = {
  encode(message: Fixed64ExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64ExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64ExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64ExLTGT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64ExLTGT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64ExLTGT>): Fixed64ExLTGT {
    return Fixed64ExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64ExLTGT>): Fixed64ExLTGT {
    const message = createBaseFixed64ExLTGT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64GTELTE(): Fixed64GTELTE {
  return { val: Long.UZERO };
}

export const Fixed64GTELTE: MessageFns<Fixed64GTELTE> = {
  encode(message: Fixed64GTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64GTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64GTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64GTELTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64GTELTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64GTELTE>): Fixed64GTELTE {
    return Fixed64GTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64GTELTE>): Fixed64GTELTE {
    const message = createBaseFixed64GTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64ExGTELTE(): Fixed64ExGTELTE {
  return { val: Long.UZERO };
}

export const Fixed64ExGTELTE: MessageFns<Fixed64ExGTELTE> = {
  encode(message: Fixed64ExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64ExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64ExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64ExGTELTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64ExGTELTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64ExGTELTE>): Fixed64ExGTELTE {
    return Fixed64ExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64ExGTELTE>): Fixed64ExGTELTE {
    const message = createBaseFixed64ExGTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseFixed64Ignore(): Fixed64Ignore {
  return { val: Long.UZERO };
}

export const Fixed64Ignore: MessageFns<Fixed64Ignore> = {
  encode(message: Fixed64Ignore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.UZERO)) {
      writer.uint32(9).fixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fixed64Ignore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFixed64Ignore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fixed64Ignore {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.UZERO };
  },

  toJSON(message: Fixed64Ignore): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.UZERO)) {
      obj.val = (message.val || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Fixed64Ignore>): Fixed64Ignore {
    return Fixed64Ignore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Fixed64Ignore>): Fixed64Ignore {
    const message = createBaseFixed64Ignore();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.UZERO;
    return message;
  },
};

function createBaseSFixed32None(): SFixed32None {
  return { val: 0 };
}

export const SFixed32None: MessageFns<SFixed32None> = {
  encode(message: SFixed32None, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32None {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32None();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32None {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32None): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32None>): SFixed32None {
    return SFixed32None.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32None>): SFixed32None {
    const message = createBaseSFixed32None();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32Const(): SFixed32Const {
  return { val: 0 };
}

export const SFixed32Const: MessageFns<SFixed32Const> = {
  encode(message: SFixed32Const, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32Const {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32Const();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32Const {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32Const): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32Const>): SFixed32Const {
    return SFixed32Const.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32Const>): SFixed32Const {
    const message = createBaseSFixed32Const();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32In(): SFixed32In {
  return { val: 0 };
}

export const SFixed32In: MessageFns<SFixed32In> = {
  encode(message: SFixed32In, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32In {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32In();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32In {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32In): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32In>): SFixed32In {
    return SFixed32In.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32In>): SFixed32In {
    const message = createBaseSFixed32In();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32NotIn(): SFixed32NotIn {
  return { val: 0 };
}

export const SFixed32NotIn: MessageFns<SFixed32NotIn> = {
  encode(message: SFixed32NotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32NotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32NotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32NotIn {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32NotIn): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32NotIn>): SFixed32NotIn {
    return SFixed32NotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32NotIn>): SFixed32NotIn {
    const message = createBaseSFixed32NotIn();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32LT(): SFixed32LT {
  return { val: 0 };
}

export const SFixed32LT: MessageFns<SFixed32LT> = {
  encode(message: SFixed32LT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32LT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32LT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32LT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32LT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32LT>): SFixed32LT {
    return SFixed32LT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32LT>): SFixed32LT {
    const message = createBaseSFixed32LT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32LTE(): SFixed32LTE {
  return { val: 0 };
}

export const SFixed32LTE: MessageFns<SFixed32LTE> = {
  encode(message: SFixed32LTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32LTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32LTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32LTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32LTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32LTE>): SFixed32LTE {
    return SFixed32LTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32LTE>): SFixed32LTE {
    const message = createBaseSFixed32LTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32GT(): SFixed32GT {
  return { val: 0 };
}

export const SFixed32GT: MessageFns<SFixed32GT> = {
  encode(message: SFixed32GT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32GT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32GT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32GT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32GT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32GT>): SFixed32GT {
    return SFixed32GT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32GT>): SFixed32GT {
    const message = createBaseSFixed32GT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32GTE(): SFixed32GTE {
  return { val: 0 };
}

export const SFixed32GTE: MessageFns<SFixed32GTE> = {
  encode(message: SFixed32GTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32GTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32GTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32GTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32GTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32GTE>): SFixed32GTE {
    return SFixed32GTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32GTE>): SFixed32GTE {
    const message = createBaseSFixed32GTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32GTLT(): SFixed32GTLT {
  return { val: 0 };
}

export const SFixed32GTLT: MessageFns<SFixed32GTLT> = {
  encode(message: SFixed32GTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32GTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32GTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32GTLT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32GTLT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32GTLT>): SFixed32GTLT {
    return SFixed32GTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32GTLT>): SFixed32GTLT {
    const message = createBaseSFixed32GTLT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32ExLTGT(): SFixed32ExLTGT {
  return { val: 0 };
}

export const SFixed32ExLTGT: MessageFns<SFixed32ExLTGT> = {
  encode(message: SFixed32ExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32ExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32ExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32ExLTGT {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32ExLTGT): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32ExLTGT>): SFixed32ExLTGT {
    return SFixed32ExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32ExLTGT>): SFixed32ExLTGT {
    const message = createBaseSFixed32ExLTGT();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32GTELTE(): SFixed32GTELTE {
  return { val: 0 };
}

export const SFixed32GTELTE: MessageFns<SFixed32GTELTE> = {
  encode(message: SFixed32GTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32GTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32GTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32GTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32GTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32GTELTE>): SFixed32GTELTE {
    return SFixed32GTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32GTELTE>): SFixed32GTELTE {
    const message = createBaseSFixed32GTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32ExGTELTE(): SFixed32ExGTELTE {
  return { val: 0 };
}

export const SFixed32ExGTELTE: MessageFns<SFixed32ExGTELTE> = {
  encode(message: SFixed32ExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32ExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32ExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32ExGTELTE {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32ExGTELTE): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32ExGTELTE>): SFixed32ExGTELTE {
    return SFixed32ExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32ExGTELTE>): SFixed32ExGTELTE {
    const message = createBaseSFixed32ExGTELTE();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed32Ignore(): SFixed32Ignore {
  return { val: 0 };
}

export const SFixed32Ignore: MessageFns<SFixed32Ignore> = {
  encode(message: SFixed32Ignore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== 0) {
      writer.uint32(13).sfixed32(message.val);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed32Ignore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed32Ignore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.val = reader.sfixed32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed32Ignore {
    return { val: isSet(object.val) ? globalThis.Number(object.val) : 0 };
  },

  toJSON(message: SFixed32Ignore): unknown {
    const obj: any = {};
    if (message.val !== 0) {
      obj.val = Math.round(message.val);
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed32Ignore>): SFixed32Ignore {
    return SFixed32Ignore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed32Ignore>): SFixed32Ignore {
    const message = createBaseSFixed32Ignore();
    message.val = object.val ?? 0;
    return message;
  },
};

function createBaseSFixed64None(): SFixed64None {
  return { val: Long.ZERO };
}

export const SFixed64None: MessageFns<SFixed64None> = {
  encode(message: SFixed64None, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64None {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64None();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64None {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64None): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64None>): SFixed64None {
    return SFixed64None.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64None>): SFixed64None {
    const message = createBaseSFixed64None();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64Const(): SFixed64Const {
  return { val: Long.ZERO };
}

export const SFixed64Const: MessageFns<SFixed64Const> = {
  encode(message: SFixed64Const, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64Const {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64Const();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64Const {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64Const): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64Const>): SFixed64Const {
    return SFixed64Const.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64Const>): SFixed64Const {
    const message = createBaseSFixed64Const();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64In(): SFixed64In {
  return { val: Long.ZERO };
}

export const SFixed64In: MessageFns<SFixed64In> = {
  encode(message: SFixed64In, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64In {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64In();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64In {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64In): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64In>): SFixed64In {
    return SFixed64In.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64In>): SFixed64In {
    const message = createBaseSFixed64In();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64NotIn(): SFixed64NotIn {
  return { val: Long.ZERO };
}

export const SFixed64NotIn: MessageFns<SFixed64NotIn> = {
  encode(message: SFixed64NotIn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64NotIn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64NotIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64NotIn {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64NotIn): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64NotIn>): SFixed64NotIn {
    return SFixed64NotIn.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64NotIn>): SFixed64NotIn {
    const message = createBaseSFixed64NotIn();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64LT(): SFixed64LT {
  return { val: Long.ZERO };
}

export const SFixed64LT: MessageFns<SFixed64LT> = {
  encode(message: SFixed64LT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64LT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64LT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64LT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64LT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64LT>): SFixed64LT {
    return SFixed64LT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64LT>): SFixed64LT {
    const message = createBaseSFixed64LT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64LTE(): SFixed64LTE {
  return { val: Long.ZERO };
}

export const SFixed64LTE: MessageFns<SFixed64LTE> = {
  encode(message: SFixed64LTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64LTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64LTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64LTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64LTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64LTE>): SFixed64LTE {
    return SFixed64LTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64LTE>): SFixed64LTE {
    const message = createBaseSFixed64LTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64GT(): SFixed64GT {
  return { val: Long.ZERO };
}

export const SFixed64GT: MessageFns<SFixed64GT> = {
  encode(message: SFixed64GT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64GT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64GT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64GT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64GT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64GT>): SFixed64GT {
    return SFixed64GT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64GT>): SFixed64GT {
    const message = createBaseSFixed64GT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64GTE(): SFixed64GTE {
  return { val: Long.ZERO };
}

export const SFixed64GTE: MessageFns<SFixed64GTE> = {
  encode(message: SFixed64GTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64GTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64GTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64GTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64GTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64GTE>): SFixed64GTE {
    return SFixed64GTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64GTE>): SFixed64GTE {
    const message = createBaseSFixed64GTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64GTLT(): SFixed64GTLT {
  return { val: Long.ZERO };
}

export const SFixed64GTLT: MessageFns<SFixed64GTLT> = {
  encode(message: SFixed64GTLT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64GTLT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64GTLT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64GTLT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64GTLT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64GTLT>): SFixed64GTLT {
    return SFixed64GTLT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64GTLT>): SFixed64GTLT {
    const message = createBaseSFixed64GTLT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64ExLTGT(): SFixed64ExLTGT {
  return { val: Long.ZERO };
}

export const SFixed64ExLTGT: MessageFns<SFixed64ExLTGT> = {
  encode(message: SFixed64ExLTGT, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64ExLTGT {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64ExLTGT();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64ExLTGT {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64ExLTGT): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64ExLTGT>): SFixed64ExLTGT {
    return SFixed64ExLTGT.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64ExLTGT>): SFixed64ExLTGT {
    const message = createBaseSFixed64ExLTGT();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64GTELTE(): SFixed64GTELTE {
  return { val: Long.ZERO };
}

export const SFixed64GTELTE: MessageFns<SFixed64GTELTE> = {
  encode(message: SFixed64GTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64GTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64GTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64GTELTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64GTELTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64GTELTE>): SFixed64GTELTE {
    return SFixed64GTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64GTELTE>): SFixed64GTELTE {
    const message = createBaseSFixed64GTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64ExGTELTE(): SFixed64ExGTELTE {
  return { val: Long.ZERO };
}

export const SFixed64ExGTELTE: MessageFns<SFixed64ExGTELTE> = {
  encode(message: SFixed64ExGTELTE, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64ExGTELTE {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64ExGTELTE();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64ExGTELTE {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64ExGTELTE): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64ExGTELTE>): SFixed64ExGTELTE {
    return SFixed64ExGTELTE.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64ExGTELTE>): SFixed64ExGTELTE {
    const message = createBaseSFixed64ExGTELTE();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseSFixed64Ignore(): SFixed64Ignore {
  return { val: Long.ZERO };
}

export const SFixed64Ignore: MessageFns<SFixed64Ignore> = {
  encode(message: SFixed64Ignore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.val.equals(Long.ZERO)) {
      writer.uint32(9).sfixed64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SFixed64Ignore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSFixed64Ignore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.val = Long.fromString(reader.sfixed64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SFixed64Ignore {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : Long.ZERO };
  },

  toJSON(message: SFixed64Ignore): unknown {
    const obj: any = {};
    if (!message.val.equals(Long.ZERO)) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SFixed64Ignore>): SFixed64Ignore {
    return SFixed64Ignore.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SFixed64Ignore>): SFixed64Ignore {
    const message = createBaseSFixed64Ignore();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : Long.ZERO;
    return message;
  },
};

function createBaseInt64LTEOptional(): Int64LTEOptional {
  return { val: undefined };
}

export const Int64LTEOptional: MessageFns<Int64LTEOptional> = {
  encode(message: Int64LTEOptional, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val !== undefined) {
      writer.uint32(8).int64(message.val.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Int64LTEOptional {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInt64LTEOptional();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.val = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Int64LTEOptional {
    return { val: isSet(object.val) ? Long.fromValue(object.val) : undefined };
  },

  toJSON(message: Int64LTEOptional): unknown {
    const obj: any = {};
    if (message.val !== undefined) {
      obj.val = (message.val || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Int64LTEOptional>): Int64LTEOptional {
    return Int64LTEOptional.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Int64LTEOptional>): Int64LTEOptional {
    const message = createBaseInt64LTEOptional();
    message.val = (object.val !== undefined && object.val !== null) ? Long.fromValue(object.val) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
