// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: zitadel/resources/object/v3alpha/object.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../../google/protobuf/timestamp.js";
import { Owner } from "../../../object/v3alpha/object.js";

export const protobufPackage = "zitadel.resources.object.v3alpha";

export enum TextFilterMethod {
  TEXT_FILTER_METHOD_EQUALS = 0,
  TEXT_FILTER_METHOD_EQUALS_IGNORE_CASE = 1,
  TEXT_FILTER_METHOD_STARTS_WITH = 2,
  TEXT_FILTER_METHOD_STARTS_WITH_IGNORE_CASE = 3,
  TEXT_FILTER_METHOD_CONTAINS = 4,
  UNRECOGNIZED = -1,
}

export function textFilterMethodFromJSON(object: any): TextFilterMethod {
  switch (object) {
    case 0:
    case "TEXT_FILTER_METHOD_EQUALS":
      return TextFilterMethod.TEXT_FILTER_METHOD_EQUALS;
    case 1:
    case "TEXT_FILTER_METHOD_EQUALS_IGNORE_CASE":
      return TextFilterMethod.TEXT_FILTER_METHOD_EQUALS_IGNORE_CASE;
    case 2:
    case "TEXT_FILTER_METHOD_STARTS_WITH":
      return TextFilterMethod.TEXT_FILTER_METHOD_STARTS_WITH;
    case 3:
    case "TEXT_FILTER_METHOD_STARTS_WITH_IGNORE_CASE":
      return TextFilterMethod.TEXT_FILTER_METHOD_STARTS_WITH_IGNORE_CASE;
    case 4:
    case "TEXT_FILTER_METHOD_CONTAINS":
      return TextFilterMethod.TEXT_FILTER_METHOD_CONTAINS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TextFilterMethod.UNRECOGNIZED;
  }
}

export function textFilterMethodToJSON(object: TextFilterMethod): string {
  switch (object) {
    case TextFilterMethod.TEXT_FILTER_METHOD_EQUALS:
      return "TEXT_FILTER_METHOD_EQUALS";
    case TextFilterMethod.TEXT_FILTER_METHOD_EQUALS_IGNORE_CASE:
      return "TEXT_FILTER_METHOD_EQUALS_IGNORE_CASE";
    case TextFilterMethod.TEXT_FILTER_METHOD_STARTS_WITH:
      return "TEXT_FILTER_METHOD_STARTS_WITH";
    case TextFilterMethod.TEXT_FILTER_METHOD_STARTS_WITH_IGNORE_CASE:
      return "TEXT_FILTER_METHOD_STARTS_WITH_IGNORE_CASE";
    case TextFilterMethod.TEXT_FILTER_METHOD_CONTAINS:
      return "TEXT_FILTER_METHOD_CONTAINS";
    case TextFilterMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Details {
  id: string;
  /** the timestamp of the first event applied to the object. */
  created:
    | Date
    | undefined;
  /** the timestamp of the last event applied to the object. */
  changed:
    | Date
    | undefined;
  /** the parent object representing the returned objects context. */
  owner: Owner | undefined;
}

export interface SearchQuery {
  offset: Long;
  limit: number;
  /** If desc is true, the result is sorted by in descending order. Beware that if desc is true or the sorting column is not the creation date, the pagination results might be inconsistent. */
  desc: boolean;
}

export interface ListDetails {
  appliedLimit: Long;
  totalResult: Long;
  timestamp: Date | undefined;
}

function createBaseDetails(): Details {
  return { id: "", created: undefined, changed: undefined, owner: undefined };
}

export const Details: MessageFns<Details> = {
  encode(message: Details, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.created !== undefined) {
      Timestamp.encode(toTimestamp(message.created), writer.uint32(26).fork()).join();
    }
    if (message.changed !== undefined) {
      Timestamp.encode(toTimestamp(message.changed), writer.uint32(34).fork()).join();
    }
    if (message.owner !== undefined) {
      Owner.encode(message.owner, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Details {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.created = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.changed = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.owner = Owner.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Details {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      created: isSet(object.created) ? fromJsonTimestamp(object.created) : undefined,
      changed: isSet(object.changed) ? fromJsonTimestamp(object.changed) : undefined,
      owner: isSet(object.owner) ? Owner.fromJSON(object.owner) : undefined,
    };
  },

  toJSON(message: Details): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.created !== undefined) {
      obj.created = message.created.toISOString();
    }
    if (message.changed !== undefined) {
      obj.changed = message.changed.toISOString();
    }
    if (message.owner !== undefined) {
      obj.owner = Owner.toJSON(message.owner);
    }
    return obj;
  },

  create(base?: DeepPartial<Details>): Details {
    return Details.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Details>): Details {
    const message = createBaseDetails();
    message.id = object.id ?? "";
    message.created = object.created ?? undefined;
    message.changed = object.changed ?? undefined;
    message.owner = (object.owner !== undefined && object.owner !== null) ? Owner.fromPartial(object.owner) : undefined;
    return message;
  },
};

function createBaseSearchQuery(): SearchQuery {
  return { offset: Long.UZERO, limit: 0, desc: false };
}

export const SearchQuery: MessageFns<SearchQuery> = {
  encode(message: SearchQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.offset.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.offset.toString());
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint32(message.limit);
    }
    if (message.desc !== false) {
      writer.uint32(24).bool(message.desc);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.offset = Long.fromString(reader.uint64().toString(), true);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.desc = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchQuery {
    return {
      offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.UZERO,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      desc: isSet(object.desc) ? globalThis.Boolean(object.desc) : false,
    };
  },

  toJSON(message: SearchQuery): unknown {
    const obj: any = {};
    if (!message.offset.equals(Long.UZERO)) {
      obj.offset = (message.offset || Long.UZERO).toString();
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.desc !== false) {
      obj.desc = message.desc;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchQuery>): SearchQuery {
    return SearchQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchQuery>): SearchQuery {
    const message = createBaseSearchQuery();
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.UZERO;
    message.limit = object.limit ?? 0;
    message.desc = object.desc ?? false;
    return message;
  },
};

function createBaseListDetails(): ListDetails {
  return { appliedLimit: Long.UZERO, totalResult: Long.UZERO, timestamp: undefined };
}

export const ListDetails: MessageFns<ListDetails> = {
  encode(message: ListDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.appliedLimit.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.appliedLimit.toString());
    }
    if (!message.totalResult.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.totalResult.toString());
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.appliedLimit = Long.fromString(reader.uint64().toString(), true);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalResult = Long.fromString(reader.uint64().toString(), true);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDetails {
    return {
      appliedLimit: isSet(object.appliedLimit) ? Long.fromValue(object.appliedLimit) : Long.UZERO,
      totalResult: isSet(object.totalResult) ? Long.fromValue(object.totalResult) : Long.UZERO,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: ListDetails): unknown {
    const obj: any = {};
    if (!message.appliedLimit.equals(Long.UZERO)) {
      obj.appliedLimit = (message.appliedLimit || Long.UZERO).toString();
    }
    if (!message.totalResult.equals(Long.UZERO)) {
      obj.totalResult = (message.totalResult || Long.UZERO).toString();
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListDetails>): ListDetails {
    return ListDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDetails>): ListDetails {
    const message = createBaseListDetails();
    message.appliedLimit = (object.appliedLimit !== undefined && object.appliedLimit !== null)
      ? Long.fromValue(object.appliedLimit)
      : Long.UZERO;
    message.totalResult = (object.totalResult !== undefined && object.totalResult !== null)
      ? Long.fromValue(object.totalResult)
      : Long.UZERO;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
