// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/storage/v1/storage_resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../protobuf/timestamp.js";
import { BoolValue, UInt32Value } from "../../protobuf/wrappers.js";

export const protobufPackage = "google.storage.v1";

/** A bucket. */
export interface Bucket {
  /** Access controls on the bucket. */
  acl: BucketAccessControl[];
  /** Default access controls to apply to new objects when no ACL is provided. */
  defaultObjectAcl: ObjectAccessControl[];
  /**
   * The bucket's lifecycle configuration. See
   * [https://developers.google.com/storage/docs/lifecycle]Lifecycle Management]
   * for more information.
   */
  lifecycle:
    | Bucket_Lifecycle
    | undefined;
  /**
   * The creation time of the bucket in
   * [https://tools.ietf.org/html/rfc3339][RFC 3339] format.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  timeCreated:
    | Date
    | undefined;
  /**
   * The ID of the bucket. For buckets, the `id` and `name` properties are the
   * same.
   * Attempting to update this field after the bucket is created will result in
   * a [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  id: string;
  /**
   * The name of the bucket.
   * Attempting to update this field after the bucket is created will result in
   * an error.
   */
  name: string;
  /**
   * The project number of the project the bucket belongs to.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  projectNumber: Long;
  /**
   * The metadata generation of this bucket.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  metageneration: Long;
  /**
   * The bucket's [https://www.w3.org/TR/cors/][Cross-Origin Resource Sharing]
   * (CORS) configuration.
   */
  cors: Bucket_Cors[];
  /**
   * The location of the bucket. Object data for objects in the bucket resides
   * in physical storage within this region.  Defaults to `US`. See the
   * [https://developers.google.com/storage/docs/concepts-techniques#specifyinglocations"][developer's
   * guide] for the authoritative list. Attempting to update this field after
   * the bucket is created will result in an error.
   */
  location: string;
  /**
   * The bucket's default storage class, used whenever no storageClass is
   * specified for a newly-created object. This defines how objects in the
   * bucket are stored and determines the SLA and the cost of storage.
   * If this value is not specified when the bucket is created, it will default
   * to `STANDARD`. For more information, see
   * https://developers.google.com/storage/docs/storage-classes.
   */
  storageClass: string;
  /**
   * HTTP 1.1 [https://tools.ietf.org/html/rfc7232#section-2.3"]Entity tag]
   * for the bucket.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  etag: string;
  /**
   * The modification time of the bucket.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  updated:
    | Date
    | undefined;
  /**
   * The default value for event-based hold on newly created objects in this
   * bucket.  Event-based hold is a way to retain objects indefinitely until an
   * event occurs, signified by the
   * hold's release. After being released, such objects will be subject to
   * bucket-level retention (if any).  One sample use case of this flag is for
   * banks to hold loan documents for at least 3 years after loan is paid in
   * full. Here, bucket-level retention is 3 years and the event is loan being
   * paid in full. In this example, these objects will be held intact for any
   * number of years until the event has occurred (event-based hold on the
   * object is released) and then 3 more years after that. That means retention
   * duration of the objects begins from the moment event-based hold
   * transitioned from true to false.  Objects under event-based hold cannot be
   * deleted, overwritten or archived until the hold is removed.
   */
  defaultEventBasedHold: boolean;
  /** User-provided labels, in key/value pairs. */
  labels: { [key: string]: string };
  /**
   * The bucket's website configuration, controlling how the service behaves
   * when accessing bucket contents as a web site. See the
   * [https://cloud.google.com/storage/docs/static-website][Static Website
   * Examples] for more information.
   */
  website:
    | Bucket_Website
    | undefined;
  /** The bucket's versioning configuration. */
  versioning:
    | Bucket_Versioning
    | undefined;
  /**
   * The bucket's logging configuration, which defines the destination bucket
   * and optional name prefix for the current bucket's logs.
   */
  logging:
    | Bucket_Logging
    | undefined;
  /** The owner of the bucket. This is always the project team's owner group. */
  owner:
    | Owner
    | undefined;
  /** Encryption configuration for a bucket. */
  encryption:
    | Bucket_Encryption
    | undefined;
  /** The bucket's billing configuration. */
  billing:
    | Bucket_Billing
    | undefined;
  /**
   * The bucket's retention policy. The retention policy enforces a minimum
   * retention time for all objects contained in the bucket, based on their
   * creation time. Any attempt to overwrite or delete objects younger than the
   * retention period will result in a PERMISSION_DENIED error.  An unlocked
   * retention policy can be modified or removed from the bucket via a
   * storage.buckets.update operation. A locked retention policy cannot be
   * removed or shortened in duration for the lifetime of the bucket.
   * Attempting to remove or decrease period of a locked retention policy will
   * result in a PERMISSION_DENIED error.
   */
  retentionPolicy:
    | Bucket_RetentionPolicy
    | undefined;
  /** The location type of the bucket (region, dual-region, multi-region, etc). */
  locationType: string;
  /** The bucket's IAM configuration. */
  iamConfiguration:
    | Bucket_IamConfiguration
    | undefined;
  /**
   * The zone or zones from which the bucket is intended to use zonal quota.
   * Requests for data from outside the specified affinities are still allowed
   * but won't be able to use zonal quota. The values are case-insensitive.
   * Attempting to update this field after bucket is created will result in an
   * error.
   *
   * @deprecated
   */
  zoneAffinity: string[];
  /** Reserved for future use. */
  satisfiesPzs: boolean;
  /**
   * The bucket's autoclass configuration. If there is no configuration, the
   * Autoclass feature will be disabled and have no effect on the bucket.
   */
  autoclass: Bucket_Autoclass | undefined;
}

/** Billing properties of a bucket. */
export interface Bucket_Billing {
  /** When set to true, Requester Pays is enabled for this bucket. */
  requesterPays: boolean;
}

/**
 * Cross-Origin Response sharing (CORS) properties for a bucket.
 * For more on GCS and CORS, see
 * https://cloud.google.com/storage/docs/cross-origin.
 * For more on CORS in general, see https://tools.ietf.org/html/rfc6454.
 */
export interface Bucket_Cors {
  /**
   * The list of Origins eligible to receive CORS response headers. See
   * [https://tools.ietf.org/html/rfc6454][RFC 6454] for more on origins.
   * Note: "*" is permitted in the list of origins, and means "any Origin".
   */
  origin: string[];
  /**
   * The list of HTTP methods on which to include CORS response headers,
   * (`GET`, `OPTIONS`, `POST`, etc) Note: "*" is permitted in the list of
   * methods, and means "any method".
   */
  method: string[];
  /**
   * The list of HTTP headers other than the
   * [https://www.w3.org/TR/cors/#simple-response-header][simple response
   * headers] to give permission for the user-agent to share across domains.
   */
  responseHeader: string[];
  /**
   * The value, in seconds, to return in the
   * [https://www.w3.org/TR/cors/#access-control-max-age-response-header][Access-Control-Max-Age
   * header] used in preflight responses.
   */
  maxAgeSeconds: number;
}

/** Encryption properties of a bucket. */
export interface Bucket_Encryption {
  /**
   * A Cloud KMS key that will be used to encrypt objects inserted into this
   * bucket, if no encryption method is specified.
   */
  defaultKmsKeyName: string;
}

/** Bucket restriction options currently enforced on the bucket. */
export interface Bucket_IamConfiguration {
  uniformBucketLevelAccess:
    | Bucket_IamConfiguration_UniformBucketLevelAccess
    | undefined;
  /** Whether IAM will enforce public access prevention. */
  publicAccessPrevention: Bucket_IamConfiguration_PublicAccessPrevention;
}

/** Public Access Prevention configuration values. */
export enum Bucket_IamConfiguration_PublicAccessPrevention {
  /** PUBLIC_ACCESS_PREVENTION_UNSPECIFIED - No specified PublicAccessPrevention. */
  PUBLIC_ACCESS_PREVENTION_UNSPECIFIED = 0,
  /**
   * ENFORCED - Prevents access from being granted to public members 'allUsers' and
   * 'allAuthenticatedUsers'. Prevents attempts to grant new access to
   * public members.
   */
  ENFORCED = 1,
  /**
   * INHERITED - This setting is inherited from Org Policy. Does not prevent access from
   * being granted to public members 'allUsers' or 'allAuthenticatedUsers'.
   */
  INHERITED = 2,
  UNRECOGNIZED = -1,
}

export function bucket_IamConfiguration_PublicAccessPreventionFromJSON(
  object: any,
): Bucket_IamConfiguration_PublicAccessPrevention {
  switch (object) {
    case 0:
    case "PUBLIC_ACCESS_PREVENTION_UNSPECIFIED":
      return Bucket_IamConfiguration_PublicAccessPrevention.PUBLIC_ACCESS_PREVENTION_UNSPECIFIED;
    case 1:
    case "ENFORCED":
      return Bucket_IamConfiguration_PublicAccessPrevention.ENFORCED;
    case 2:
    case "INHERITED":
      return Bucket_IamConfiguration_PublicAccessPrevention.INHERITED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Bucket_IamConfiguration_PublicAccessPrevention.UNRECOGNIZED;
  }
}

export function bucket_IamConfiguration_PublicAccessPreventionToJSON(
  object: Bucket_IamConfiguration_PublicAccessPrevention,
): string {
  switch (object) {
    case Bucket_IamConfiguration_PublicAccessPrevention.PUBLIC_ACCESS_PREVENTION_UNSPECIFIED:
      return "PUBLIC_ACCESS_PREVENTION_UNSPECIFIED";
    case Bucket_IamConfiguration_PublicAccessPrevention.ENFORCED:
      return "ENFORCED";
    case Bucket_IamConfiguration_PublicAccessPrevention.INHERITED:
      return "INHERITED";
    case Bucket_IamConfiguration_PublicAccessPrevention.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Bucket_IamConfiguration_UniformBucketLevelAccess {
  /** If set, access checks only use bucket-level IAM policies or above. */
  enabled: boolean;
  /**
   * The deadline time for changing
   * <code>iamConfiguration.uniformBucketLevelAccess.enabled</code> from
   * true to false in [https://tools.ietf.org/html/rfc3339][RFC 3339]. After
   * the deadline is passed the field is immutable.
   */
  lockedTime: Date | undefined;
}

/**
 * Lifecycle properties of a bucket.
 * For more information, see https://cloud.google.com/storage/docs/lifecycle.
 */
export interface Bucket_Lifecycle {
  /**
   * A lifecycle management rule, which is made of an action to take and the
   * condition(s) under which the action will be taken.
   */
  rule: Bucket_Lifecycle_Rule[];
}

/**
 * A lifecycle Rule, combining an action to take on an object and a
 * condition which will trigger that action.
 */
export interface Bucket_Lifecycle_Rule {
  /** The action to take. */
  action:
    | Bucket_Lifecycle_Rule_Action
    | undefined;
  /** The condition(s) under which the action will be taken. */
  condition: Bucket_Lifecycle_Rule_Condition | undefined;
}

/** An action to take on an object. */
export interface Bucket_Lifecycle_Rule_Action {
  /**
   * Type of the action. Currently, only `Delete`, `SetStorageClass`, and
   * `AbortIncompleteMultipartUpload` are supported.
   */
  type: string;
  /**
   * Target storage class. Required iff the type of the action is
   * SetStorageClass.
   */
  storageClass: string;
}

/** A condition of an object which triggers some action. */
export interface Bucket_Lifecycle_Rule_Condition {
  /**
   * Age of an object (in days). This condition is satisfied when an
   * object reaches the specified age.
   */
  age: number;
  /**
   * A date in [RFC 3339][1] format with only the date part (for
   * instance, "2013-01-15"). This condition is satisfied when an
   * object is created before midnight of the specified date in UTC.
   * [1]: https://tools.ietf.org/html/rfc3339
   */
  createdBefore:
    | Date
    | undefined;
  /**
   * Relevant only for versioned objects. If the value is
   * `true`, this condition matches live objects; if the value
   * is `false`, it matches archived objects.
   */
  isLive:
    | boolean
    | undefined;
  /**
   * Relevant only for versioned objects. If the value is N, this
   * condition is satisfied when there are at least N versions (including
   * the live version) newer than this version of the object.
   */
  numNewerVersions: number;
  /**
   * Objects having any of the storage classes specified by this condition
   * will be matched. Values include `MULTI_REGIONAL`, `REGIONAL`,
   * `NEARLINE`, `COLDLINE`, `STANDARD`, and
   * `DURABLE_REDUCED_AVAILABILITY`.
   */
  matchesStorageClass: string[];
  /**
   * A regular expression that satisfies the RE2 syntax. This condition is
   * satisfied when the name of the object matches the RE2 pattern.  Note:
   * This feature is currently in the "Early Access" launch stage and is
   * only available to an allowlisted set of users; that means that this
   * feature may be changed in backward-incompatible ways and that it is
   * not guaranteed to be released.
   */
  matchesPattern: string;
  /**
   * Number of days that has elapsed since the custom timestamp set on an
   * object.
   */
  daysSinceCustomTime: number;
  /**
   * An object matches this condition if the custom timestamp set on the
   * object is before this timestamp.
   */
  customTimeBefore:
    | Date
    | undefined;
  /**
   * This condition is relevant only for versioned objects. An object
   * version satisfies this condition only if these many days have been
   * passed since it became noncurrent. The value of the field must be a
   * nonnegative integer. If it's zero, the object version will become
   * eligible for Lifecycle action as soon as it becomes noncurrent.
   */
  daysSinceNoncurrentTime: number;
  /**
   * This condition is relevant only for versioned objects. An object
   * version satisfies this condition only if it became noncurrent before
   * the specified timestamp.
   */
  noncurrentTimeBefore:
    | Date
    | undefined;
  /**
   * List of object name prefixes. If any prefix exactly matches the
   * beginning of the object name, the condition evaluates to true.
   */
  matchesPrefix: string[];
  /**
   * List of object name suffixes. If any suffix exactly matches the
   * end of the object name, the condition evaluates to true.
   */
  matchesSuffix: string[];
}

/** Logging-related properties of a bucket. */
export interface Bucket_Logging {
  /** The destination bucket where the current bucket's logs should be placed. */
  logBucket: string;
  /** A prefix for log object names. */
  logObjectPrefix: string;
}

/** Retention policy properties of a bucket. */
export interface Bucket_RetentionPolicy {
  /**
   * Server-determined value that indicates the time from which policy was
   * enforced and effective. This value is in
   * [https://tools.ietf.org/html/rfc3339][RFC 3339] format.
   */
  effectiveTime:
    | Date
    | undefined;
  /** Once locked, an object retention policy cannot be modified. */
  isLocked: boolean;
  /**
   * The duration in seconds that objects need to be retained. Retention
   * duration must be greater than zero and less than 100 years. Note that
   * enforcement of retention periods less than a day is not guaranteed. Such
   * periods should only be used for testing purposes.
   */
  retentionPeriod: Long;
}

/**
 * Properties of a bucket related to versioning.
 * For more on GCS versioning, see
 * https://cloud.google.com/storage/docs/object-versioning.
 */
export interface Bucket_Versioning {
  /** While set to true, versioning is fully enabled for this bucket. */
  enabled: boolean;
}

/**
 * Properties of a bucket related to accessing the contents as a static
 * website. For more on hosting a static website via GCS, see
 * https://cloud.google.com/storage/docs/hosting-static-website.
 */
export interface Bucket_Website {
  /**
   * If the requested object path is missing, the service will ensure the path
   * has a trailing '/', append this suffix, and attempt to retrieve the
   * resulting object. This allows the creation of `index.html`
   * objects to represent directory pages.
   */
  mainPageSuffix: string;
  /**
   * If the requested object path is missing, and any
   * `mainPageSuffix` object is missing, if applicable, the service
   * will return the named object from this bucket as the content for a
   * [https://tools.ietf.org/html/rfc7231#section-6.5.4][404 Not Found]
   * result.
   */
  notFoundPage: string;
}

/** Configuration for a bucket's Autoclass feature. */
export interface Bucket_Autoclass {
  /** Enables Autoclass. */
  enabled: boolean;
  /** Latest instant at which the `enabled` bit was flipped. */
  toggleTime: Date | undefined;
}

export interface Bucket_LabelsEntry {
  key: string;
  value: string;
}

/** An access-control entry. */
export interface BucketAccessControl {
  /** The access permission for the entity. */
  role: string;
  /**
   * HTTP 1.1 ["https://tools.ietf.org/html/rfc7232#section-2.3][Entity tag]
   * for the access-control entry.
   */
  etag: string;
  /** The ID of the access-control entry. */
  id: string;
  /** The name of the bucket. */
  bucket: string;
  /**
   * The entity holding the permission, in one of the following forms:
   * * `user-{userid}`
   * * `user-{email}`
   * * `group-{groupid}`
   * * `group-{email}`
   * * `domain-{domain}`
   * * `project-{team-projectid}`
   * * `allUsers`
   * * `allAuthenticatedUsers`
   * Examples:
   * * The user `liz@example.com` would be `user-liz@example.com`.
   * * The group `example@googlegroups.com` would be
   * `group-example@googlegroups.com`
   * * All members of the Google Apps for Business domain `example.com` would be
   * `domain-example.com`
   */
  entity: string;
  /** The ID for the entity, if any. */
  entityId: string;
  /** The email address associated with the entity, if any. */
  email: string;
  /** The domain associated with the entity, if any. */
  domain: string;
  /** The project team associated with the entity, if any. */
  projectTeam: ProjectTeam | undefined;
}

/** The response to a call to BucketAccessControls.ListBucketAccessControls. */
export interface ListBucketAccessControlsResponse {
  /** The list of items. */
  items: BucketAccessControl[];
}

/** The result of a call to Buckets.ListBuckets */
export interface ListBucketsResponse {
  /** The list of items. */
  items: Bucket[];
  /**
   * The continuation token, used to page through large result sets. Provide
   * this value in a subsequent request to return the next page of results.
   */
  nextPageToken: string;
}

/** An notification channel used to watch for resource changes. */
export interface Channel {
  /** A UUID or similar unique string that identifies this channel. */
  id: string;
  /**
   * An opaque ID that identifies the resource being watched on this channel.
   * Stable across different API versions.
   */
  resourceId: string;
  /** A version-specific identifier for the watched resource. */
  resourceUri: string;
  /**
   * An arbitrary string delivered to the target address with each notification
   * delivered over this channel. Optional.
   */
  token: string;
  /** Date and time of notification channel expiration. Optional. */
  expiration:
    | Date
    | undefined;
  /** The type of delivery mechanism used for this channel. */
  type: string;
  /** The address where notifications are delivered for this channel. */
  address: string;
  /** Additional parameters controlling delivery channel behavior. Optional. */
  params: { [key: string]: string };
  /** A Boolean value to indicate whether payload is wanted. Optional. */
  payload: boolean;
}

export interface Channel_ParamsEntry {
  key: string;
  value: string;
}

/** The result of a call to Channels.ListChannels */
export interface ListChannelsResponse {
  /** The list of notification channels for a bucket. */
  items: ListChannelsResponse_Items[];
}

export interface ListChannelsResponse_Items {
  /** User-specified name for a channel. Needed to unsubscribe. */
  channelId: string;
  /**
   * Opaque value generated by GCS representing a bucket. Needed to
   * unsubscribe.
   */
  resourceId: string;
  /** Url used to identify where notifications are sent to. */
  pushUrl: string;
  /** Email address of the subscriber. */
  subscriberEmail: string;
  /** Time when the channel was created. */
  creationTime: Date | undefined;
}

/**
 * Message used to convey content being read or written, along with its
 * checksum.
 */
export interface ChecksummedData {
  /** The data. */
  content: Buffer;
  /** CRC32C digest of the contents. */
  crc32c: number | undefined;
}

/** Message used for storing full (not subrange) object checksums. */
export interface ObjectChecksums {
  /**
   * CRC32C digest of the object data. Computed by the GCS service for
   * all written objects, and validated by the GCS service against
   * client-supplied values if present in an InsertObjectRequest.
   */
  crc32c:
    | number
    | undefined;
  /**
   * Hex-encoded MD5 hash of the object data (hexdigest). Whether/how this
   * checksum is provided and validated is service-dependent.
   */
  md5Hash: string;
}

/** A collection of enums used in multiple places throughout the API. */
export interface CommonEnums {
}

/** A set of properties to return in a response. */
export enum CommonEnums_Projection {
  /** PROJECTION_UNSPECIFIED - No specified projection. */
  PROJECTION_UNSPECIFIED = 0,
  /** NO_ACL - Omit `owner`, `acl`, and `defaultObjectAcl` properties. */
  NO_ACL = 1,
  /** FULL - Include all properties. */
  FULL = 2,
  UNRECOGNIZED = -1,
}

export function commonEnums_ProjectionFromJSON(object: any): CommonEnums_Projection {
  switch (object) {
    case 0:
    case "PROJECTION_UNSPECIFIED":
      return CommonEnums_Projection.PROJECTION_UNSPECIFIED;
    case 1:
    case "NO_ACL":
      return CommonEnums_Projection.NO_ACL;
    case 2:
    case "FULL":
      return CommonEnums_Projection.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommonEnums_Projection.UNRECOGNIZED;
  }
}

export function commonEnums_ProjectionToJSON(object: CommonEnums_Projection): string {
  switch (object) {
    case CommonEnums_Projection.PROJECTION_UNSPECIFIED:
      return "PROJECTION_UNSPECIFIED";
    case CommonEnums_Projection.NO_ACL:
      return "NO_ACL";
    case CommonEnums_Projection.FULL:
      return "FULL";
    case CommonEnums_Projection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Predefined or "canned" aliases for sets of specific bucket ACL entries. */
export enum CommonEnums_PredefinedBucketAcl {
  /** PREDEFINED_BUCKET_ACL_UNSPECIFIED - No predefined ACL. */
  PREDEFINED_BUCKET_ACL_UNSPECIFIED = 0,
  /**
   * BUCKET_ACL_AUTHENTICATED_READ - Project team owners get `OWNER` access, and
   * `allAuthenticatedUsers` get `READER` access.
   */
  BUCKET_ACL_AUTHENTICATED_READ = 1,
  /** BUCKET_ACL_PRIVATE - Project team owners get `OWNER` access. */
  BUCKET_ACL_PRIVATE = 2,
  /** BUCKET_ACL_PROJECT_PRIVATE - Project team members get access according to their roles. */
  BUCKET_ACL_PROJECT_PRIVATE = 3,
  /**
   * BUCKET_ACL_PUBLIC_READ - Project team owners get `OWNER` access, and
   * `allUsers` get `READER` access.
   */
  BUCKET_ACL_PUBLIC_READ = 4,
  /**
   * BUCKET_ACL_PUBLIC_READ_WRITE - Project team owners get `OWNER` access, and
   * `allUsers` get `WRITER` access.
   */
  BUCKET_ACL_PUBLIC_READ_WRITE = 5,
  UNRECOGNIZED = -1,
}

export function commonEnums_PredefinedBucketAclFromJSON(object: any): CommonEnums_PredefinedBucketAcl {
  switch (object) {
    case 0:
    case "PREDEFINED_BUCKET_ACL_UNSPECIFIED":
      return CommonEnums_PredefinedBucketAcl.PREDEFINED_BUCKET_ACL_UNSPECIFIED;
    case 1:
    case "BUCKET_ACL_AUTHENTICATED_READ":
      return CommonEnums_PredefinedBucketAcl.BUCKET_ACL_AUTHENTICATED_READ;
    case 2:
    case "BUCKET_ACL_PRIVATE":
      return CommonEnums_PredefinedBucketAcl.BUCKET_ACL_PRIVATE;
    case 3:
    case "BUCKET_ACL_PROJECT_PRIVATE":
      return CommonEnums_PredefinedBucketAcl.BUCKET_ACL_PROJECT_PRIVATE;
    case 4:
    case "BUCKET_ACL_PUBLIC_READ":
      return CommonEnums_PredefinedBucketAcl.BUCKET_ACL_PUBLIC_READ;
    case 5:
    case "BUCKET_ACL_PUBLIC_READ_WRITE":
      return CommonEnums_PredefinedBucketAcl.BUCKET_ACL_PUBLIC_READ_WRITE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommonEnums_PredefinedBucketAcl.UNRECOGNIZED;
  }
}

export function commonEnums_PredefinedBucketAclToJSON(object: CommonEnums_PredefinedBucketAcl): string {
  switch (object) {
    case CommonEnums_PredefinedBucketAcl.PREDEFINED_BUCKET_ACL_UNSPECIFIED:
      return "PREDEFINED_BUCKET_ACL_UNSPECIFIED";
    case CommonEnums_PredefinedBucketAcl.BUCKET_ACL_AUTHENTICATED_READ:
      return "BUCKET_ACL_AUTHENTICATED_READ";
    case CommonEnums_PredefinedBucketAcl.BUCKET_ACL_PRIVATE:
      return "BUCKET_ACL_PRIVATE";
    case CommonEnums_PredefinedBucketAcl.BUCKET_ACL_PROJECT_PRIVATE:
      return "BUCKET_ACL_PROJECT_PRIVATE";
    case CommonEnums_PredefinedBucketAcl.BUCKET_ACL_PUBLIC_READ:
      return "BUCKET_ACL_PUBLIC_READ";
    case CommonEnums_PredefinedBucketAcl.BUCKET_ACL_PUBLIC_READ_WRITE:
      return "BUCKET_ACL_PUBLIC_READ_WRITE";
    case CommonEnums_PredefinedBucketAcl.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Predefined or "canned" aliases for sets of specific object ACL entries. */
export enum CommonEnums_PredefinedObjectAcl {
  /** PREDEFINED_OBJECT_ACL_UNSPECIFIED - No predefined ACL. */
  PREDEFINED_OBJECT_ACL_UNSPECIFIED = 0,
  /**
   * OBJECT_ACL_AUTHENTICATED_READ - Object owner gets `OWNER` access, and
   * `allAuthenticatedUsers` get `READER` access.
   */
  OBJECT_ACL_AUTHENTICATED_READ = 1,
  /**
   * OBJECT_ACL_BUCKET_OWNER_FULL_CONTROL - Object owner gets `OWNER` access, and project team owners get
   * `OWNER` access.
   */
  OBJECT_ACL_BUCKET_OWNER_FULL_CONTROL = 2,
  /**
   * OBJECT_ACL_BUCKET_OWNER_READ - Object owner gets `OWNER` access, and project team owners get
   * `READER` access.
   */
  OBJECT_ACL_BUCKET_OWNER_READ = 3,
  /** OBJECT_ACL_PRIVATE - Object owner gets `OWNER` access. */
  OBJECT_ACL_PRIVATE = 4,
  /**
   * OBJECT_ACL_PROJECT_PRIVATE - Object owner gets `OWNER` access, and project team members get
   * access according to their roles.
   */
  OBJECT_ACL_PROJECT_PRIVATE = 5,
  /**
   * OBJECT_ACL_PUBLIC_READ - Object owner gets `OWNER` access, and `allUsers`
   * get `READER` access.
   */
  OBJECT_ACL_PUBLIC_READ = 6,
  UNRECOGNIZED = -1,
}

export function commonEnums_PredefinedObjectAclFromJSON(object: any): CommonEnums_PredefinedObjectAcl {
  switch (object) {
    case 0:
    case "PREDEFINED_OBJECT_ACL_UNSPECIFIED":
      return CommonEnums_PredefinedObjectAcl.PREDEFINED_OBJECT_ACL_UNSPECIFIED;
    case 1:
    case "OBJECT_ACL_AUTHENTICATED_READ":
      return CommonEnums_PredefinedObjectAcl.OBJECT_ACL_AUTHENTICATED_READ;
    case 2:
    case "OBJECT_ACL_BUCKET_OWNER_FULL_CONTROL":
      return CommonEnums_PredefinedObjectAcl.OBJECT_ACL_BUCKET_OWNER_FULL_CONTROL;
    case 3:
    case "OBJECT_ACL_BUCKET_OWNER_READ":
      return CommonEnums_PredefinedObjectAcl.OBJECT_ACL_BUCKET_OWNER_READ;
    case 4:
    case "OBJECT_ACL_PRIVATE":
      return CommonEnums_PredefinedObjectAcl.OBJECT_ACL_PRIVATE;
    case 5:
    case "OBJECT_ACL_PROJECT_PRIVATE":
      return CommonEnums_PredefinedObjectAcl.OBJECT_ACL_PROJECT_PRIVATE;
    case 6:
    case "OBJECT_ACL_PUBLIC_READ":
      return CommonEnums_PredefinedObjectAcl.OBJECT_ACL_PUBLIC_READ;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommonEnums_PredefinedObjectAcl.UNRECOGNIZED;
  }
}

export function commonEnums_PredefinedObjectAclToJSON(object: CommonEnums_PredefinedObjectAcl): string {
  switch (object) {
    case CommonEnums_PredefinedObjectAcl.PREDEFINED_OBJECT_ACL_UNSPECIFIED:
      return "PREDEFINED_OBJECT_ACL_UNSPECIFIED";
    case CommonEnums_PredefinedObjectAcl.OBJECT_ACL_AUTHENTICATED_READ:
      return "OBJECT_ACL_AUTHENTICATED_READ";
    case CommonEnums_PredefinedObjectAcl.OBJECT_ACL_BUCKET_OWNER_FULL_CONTROL:
      return "OBJECT_ACL_BUCKET_OWNER_FULL_CONTROL";
    case CommonEnums_PredefinedObjectAcl.OBJECT_ACL_BUCKET_OWNER_READ:
      return "OBJECT_ACL_BUCKET_OWNER_READ";
    case CommonEnums_PredefinedObjectAcl.OBJECT_ACL_PRIVATE:
      return "OBJECT_ACL_PRIVATE";
    case CommonEnums_PredefinedObjectAcl.OBJECT_ACL_PROJECT_PRIVATE:
      return "OBJECT_ACL_PROJECT_PRIVATE";
    case CommonEnums_PredefinedObjectAcl.OBJECT_ACL_PUBLIC_READ:
      return "OBJECT_ACL_PUBLIC_READ";
    case CommonEnums_PredefinedObjectAcl.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies a requested range of bytes to download. */
export interface ContentRange {
  /** The starting offset of the object data. */
  start: Long;
  /** The ending offset of the object data. */
  end: Long;
  /** The complete length of the object data. */
  completeLength: Long;
}

/** Hmac Key Metadata, which includes all information other than the secret. */
export interface HmacKeyMetadata {
  /** Resource name ID of the key in the format <projectId>/<accessId>. */
  id: string;
  /** Globally unique id for keys. */
  accessId: string;
  /** The project ID that the hmac key is contained in. */
  projectId: string;
  /** Email of the service account the key authenticates as. */
  serviceAccountEmail: string;
  /** State of the key. One of ACTIVE, INACTIVE, or DELETED. */
  state: string;
  /** The creation time of the HMAC key in RFC 3339 format. */
  timeCreated:
    | Date
    | undefined;
  /** The last modification time of the HMAC key metadata in RFC 3339 format. */
  updated:
    | Date
    | undefined;
  /** Tag updated with each key update. */
  etag: string;
}

/** A subscription to receive Google PubSub notifications. */
export interface Notification {
  /**
   * The Cloud PubSub topic to which this subscription publishes. Formatted as:
   * '//pubsub.googleapis.com/projects/{project-identifier}/topics/{my-topic}'
   */
  topic: string;
  /**
   * If present, only send notifications about listed event types. If empty,
   * sent notifications for all event types.
   */
  eventTypes: string[];
  /**
   * An optional list of additional attributes to attach to each Cloud PubSub
   * message published for this notification subscription.
   */
  customAttributes: { [key: string]: string };
  /**
   * HTTP 1.1 [https://tools.ietf.org/html/rfc7232#section-2.3][Entity tag]
   * for this subscription notification.
   */
  etag: string;
  /**
   * If present, only apply this notification configuration to object names that
   * begin with this prefix.
   */
  objectNamePrefix: string;
  /** The desired content of the Payload. */
  payloadFormat: string;
  /** The ID of the notification. */
  id: string;
}

export interface Notification_CustomAttributesEntry {
  key: string;
  value: string;
}

/** The result of a call to Notifications.ListNotifications */
export interface ListNotificationsResponse {
  /** The list of items. */
  items: Notification[];
}

/** An object. */
export interface Object {
  /**
   * Content-Encoding of the object data, matching
   * [https://tools.ietf.org/html/rfc7231#section-3.1.2.2][RFC 7231 §3.1.2.2]
   */
  contentEncoding: string;
  /**
   * Content-Disposition of the object data, matching
   * [https://tools.ietf.org/html/rfc6266][RFC 6266].
   */
  contentDisposition: string;
  /**
   * Cache-Control directive for the object data, matching
   * [https://tools.ietf.org/html/rfc7234#section-5.2"][RFC 7234 §5.2].
   * If omitted, and the object is accessible to all anonymous users, the
   * default will be `public, max-age=3600`.
   */
  cacheControl: string;
  /** Access controls on the object. */
  acl: ObjectAccessControl[];
  /**
   * Content-Language of the object data, matching
   * [https://tools.ietf.org/html/rfc7231#section-3.1.3.2][RFC 7231 §3.1.3.2].
   */
  contentLanguage: string;
  /**
   * The version of the metadata for this object at this generation. Used for
   * preconditions and for detecting changes in metadata. A metageneration
   * number is only meaningful in the context of a particular generation of a
   * particular object.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  metageneration: Long;
  /**
   * The deletion time of the object. Will be returned if and only if this
   * version of the object has been deleted.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  timeDeleted:
    | Date
    | undefined;
  /**
   * Content-Type of the object data, matching
   * [https://tools.ietf.org/html/rfc7231#section-3.1.1.5][RFC 7231 §3.1.1.5].
   * If an object is stored without a Content-Type, it is served as
   * `application/octet-stream`.
   */
  contentType: string;
  /**
   * Content-Length of the object data in bytes, matching
   * [https://tools.ietf.org/html/rfc7230#section-3.3.2][RFC 7230 §3.3.2].
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  size: Long;
  /**
   * The creation time of the object.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  timeCreated:
    | Date
    | undefined;
  /**
   * CRC32c checksum. For more information about using the CRC32c
   * checksum, see
   * [https://cloud.google.com/storage/docs/hashes-etags#json-api][Hashes and
   * ETags: Best Practices]. This is a server determined value and should not be
   * supplied by the user when sending an Object. The server will ignore any
   * value provided. Users should instead use the object_checksums field on the
   * InsertObjectRequest when uploading an object.
   */
  crc32c:
    | number
    | undefined;
  /**
   * Number of underlying components that make up this object. Components are
   * accumulated by compose operations.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  componentCount: number;
  /**
   * MD5 hash of the data; encoded using base64 as per
   * [https://tools.ietf.org/html/rfc4648#section-4][RFC 4648 §4]. For more
   * information about using the MD5 hash, see
   * [https://cloud.google.com/storage/docs/hashes-etags#json-api][Hashes and
   * ETags: Best Practices]. This is a server determined value and should not be
   * supplied by the user when sending an Object. The server will ignore any
   * value provided. Users should instead use the object_checksums field on the
   * InsertObjectRequest when uploading an object.
   */
  md5Hash: string;
  /**
   * HTTP 1.1 Entity tag for the object. See
   * [https://tools.ietf.org/html/rfc7232#section-2.3][RFC 7232 §2.3].
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  etag: string;
  /**
   * The modification time of the object metadata.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  updated:
    | Date
    | undefined;
  /** Storage class of the object. */
  storageClass: string;
  /**
   * Cloud KMS Key used to encrypt this object, if the object is encrypted by
   * such a key.
   */
  kmsKeyName: string;
  /**
   * The time at which the object's storage class was last changed. When the
   * object is initially created, it will be set to time_created.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  timeStorageClassUpdated:
    | Date
    | undefined;
  /**
   * Whether an object is under temporary hold. While this flag is set to true,
   * the object is protected against deletion and overwrites.  A common use case
   * of this flag is regulatory investigations where objects need to be retained
   * while the investigation is ongoing. Note that unlike event-based hold,
   * temporary hold does not impact retention expiration time of an object.
   */
  temporaryHold: boolean;
  /**
   * A server-determined value that specifies the earliest time that the
   * object's retention period expires. This value is in
   * [https://tools.ietf.org/html/rfc3339][RFC 3339] format.
   * Note 1: This field is not provided for objects with an active event-based
   * hold, since retention expiration is unknown until the hold is removed.
   * Note 2: This value can be provided even when temporary hold is set (so that
   * the user can reason about policy without having to first unset the
   * temporary hold).
   */
  retentionExpirationTime:
    | Date
    | undefined;
  /** User-provided metadata, in key/value pairs. */
  metadata: { [key: string]: string };
  /**
   * Whether an object is under event-based hold. Event-based hold is a way to
   * retain objects until an event occurs, which is signified by the
   * hold's release (i.e. this value is set to false). After being released (set
   * to false), such objects will be subject to bucket-level retention (if any).
   * One sample use case of this flag is for banks to hold loan documents for at
   * least 3 years after loan is paid in full. Here, bucket-level retention is 3
   * years and the event is the loan being paid in full. In this example, these
   * objects will be held intact for any number of years until the event has
   * occurred (event-based hold on the object is released) and then 3 more years
   * after that. That means retention duration of the objects begins from the
   * moment event-based hold transitioned from true to false.
   */
  eventBasedHold:
    | boolean
    | undefined;
  /**
   * The name of the object.
   * Attempting to update this field after the object is created will result in
   * an error.
   */
  name: string;
  /**
   * The ID of the object, including the bucket name, object name, and
   * generation number.
   * Attempting to update this field after the object is created will result in
   * an error.
   */
  id: string;
  /**
   * The name of the bucket containing this object.
   * Attempting to update this field after the object is created will result in
   * an error.
   */
  bucket: string;
  /**
   * The content generation of this object. Used for object versioning.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  generation: Long;
  /**
   * The owner of the object. This will always be the uploader of the object.
   * Attempting to set or update this field will result in a
   * [FieldViolation][google.rpc.BadRequest.FieldViolation].
   */
  owner:
    | Owner
    | undefined;
  /**
   * Metadata of customer-supplied encryption key, if the object is encrypted by
   * such a key.
   */
  customerEncryption:
    | Object_CustomerEncryption
    | undefined;
  /** A user-specified timestamp set on an object. */
  customTime: Date | undefined;
}

/** Describes the customer-specified mechanism used to store the data at rest. */
export interface Object_CustomerEncryption {
  /** The encryption algorithm. */
  encryptionAlgorithm: string;
  /** SHA256 hash value of the encryption key. */
  keySha256: string;
}

export interface Object_MetadataEntry {
  key: string;
  value: string;
}

/** An access-control entry. */
export interface ObjectAccessControl {
  /** The access permission for the entity. */
  role: string;
  /**
   * HTTP 1.1 Entity tag for the access-control entry.
   * See [https://tools.ietf.org/html/rfc7232#section-2.3][RFC 7232 §2.3].
   */
  etag: string;
  /** The ID of the access-control entry. */
  id: string;
  /** The name of the bucket. */
  bucket: string;
  /** The name of the object, if applied to an object. */
  object: string;
  /** The content generation of the object, if applied to an object. */
  generation: Long;
  /**
   * The entity holding the permission, in one of the following forms:
   * * `user-{userid}`
   * * `user-{email}`
   * * `group-{groupid}`
   * * `group-{email}`
   * * `domain-{domain}`
   * * `project-{team-projectid}`
   * * `allUsers`
   * * `allAuthenticatedUsers`
   * Examples:
   * * The user `liz@example.com` would be `user-liz@example.com`.
   * * The group `example@googlegroups.com` would be
   * `group-example@googlegroups.com`.
   * * All members of the Google Apps for Business domain `example.com` would be
   * `domain-example.com`.
   */
  entity: string;
  /** The ID for the entity, if any. */
  entityId: string;
  /** The email address associated with the entity, if any. */
  email: string;
  /** The domain associated with the entity, if any. */
  domain: string;
  /** The project team associated with the entity, if any. */
  projectTeam: ProjectTeam | undefined;
}

/** The result of a call to ObjectAccessControls.ListObjectAccessControls. */
export interface ListObjectAccessControlsResponse {
  /** The list of items. */
  items: ObjectAccessControl[];
}

/** The result of a call to Objects.ListObjects */
export interface ListObjectsResponse {
  /**
   * The list of prefixes of objects matching-but-not-listed up to and including
   * the requested delimiter.
   */
  prefixes: string[];
  /** The list of items. */
  items: Object[];
  /**
   * The continuation token, used to page through large result sets. Provide
   * this value in a subsequent request to return the next page of results.
   */
  nextPageToken: string;
}

/** Represents the Viewers, Editors, or Owners of a given project. */
export interface ProjectTeam {
  /** The project number. */
  projectNumber: string;
  /** The team. */
  team: string;
}

/** A subscription to receive Google PubSub notifications. */
export interface ServiceAccount {
  /** The ID of the notification. */
  emailAddress: string;
}

/** The owner of a specific resource. */
export interface Owner {
  /** The entity, in the form `user-`*userId*. */
  entity: string;
  /** The ID for the entity. */
  entityId: string;
}

function createBaseBucket(): Bucket {
  return {
    acl: [],
    defaultObjectAcl: [],
    lifecycle: undefined,
    timeCreated: undefined,
    id: "",
    name: "",
    projectNumber: Long.ZERO,
    metageneration: Long.ZERO,
    cors: [],
    location: "",
    storageClass: "",
    etag: "",
    updated: undefined,
    defaultEventBasedHold: false,
    labels: {},
    website: undefined,
    versioning: undefined,
    logging: undefined,
    owner: undefined,
    encryption: undefined,
    billing: undefined,
    retentionPolicy: undefined,
    locationType: "",
    iamConfiguration: undefined,
    zoneAffinity: [],
    satisfiesPzs: false,
    autoclass: undefined,
  };
}

export const Bucket: MessageFns<Bucket> = {
  encode(message: Bucket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.acl) {
      BucketAccessControl.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.defaultObjectAcl) {
      ObjectAccessControl.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.lifecycle !== undefined) {
      Bucket_Lifecycle.encode(message.lifecycle, writer.uint32(26).fork()).join();
    }
    if (message.timeCreated !== undefined) {
      Timestamp.encode(toTimestamp(message.timeCreated), writer.uint32(34).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (!message.projectNumber.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.projectNumber.toString());
    }
    if (!message.metageneration.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.metageneration.toString());
    }
    for (const v of message.cors) {
      Bucket_Cors.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.location !== "") {
      writer.uint32(82).string(message.location);
    }
    if (message.storageClass !== "") {
      writer.uint32(90).string(message.storageClass);
    }
    if (message.etag !== "") {
      writer.uint32(98).string(message.etag);
    }
    if (message.updated !== undefined) {
      Timestamp.encode(toTimestamp(message.updated), writer.uint32(106).fork()).join();
    }
    if (message.defaultEventBasedHold !== false) {
      writer.uint32(112).bool(message.defaultEventBasedHold);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Bucket_LabelsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.website !== undefined) {
      Bucket_Website.encode(message.website, writer.uint32(130).fork()).join();
    }
    if (message.versioning !== undefined) {
      Bucket_Versioning.encode(message.versioning, writer.uint32(138).fork()).join();
    }
    if (message.logging !== undefined) {
      Bucket_Logging.encode(message.logging, writer.uint32(146).fork()).join();
    }
    if (message.owner !== undefined) {
      Owner.encode(message.owner, writer.uint32(154).fork()).join();
    }
    if (message.encryption !== undefined) {
      Bucket_Encryption.encode(message.encryption, writer.uint32(162).fork()).join();
    }
    if (message.billing !== undefined) {
      Bucket_Billing.encode(message.billing, writer.uint32(170).fork()).join();
    }
    if (message.retentionPolicy !== undefined) {
      Bucket_RetentionPolicy.encode(message.retentionPolicy, writer.uint32(178).fork()).join();
    }
    if (message.locationType !== "") {
      writer.uint32(186).string(message.locationType);
    }
    if (message.iamConfiguration !== undefined) {
      Bucket_IamConfiguration.encode(message.iamConfiguration, writer.uint32(194).fork()).join();
    }
    for (const v of message.zoneAffinity) {
      writer.uint32(202).string(v!);
    }
    if (message.satisfiesPzs !== false) {
      writer.uint32(208).bool(message.satisfiesPzs);
    }
    if (message.autoclass !== undefined) {
      Bucket_Autoclass.encode(message.autoclass, writer.uint32(226).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.acl.push(BucketAccessControl.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.defaultObjectAcl.push(ObjectAccessControl.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lifecycle = Bucket_Lifecycle.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeCreated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.projectNumber = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.metageneration = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.cors.push(Bucket_Cors.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.location = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.storageClass = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.defaultEventBasedHold = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          const entry15 = Bucket_LabelsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.labels[entry15.key] = entry15.value;
          }
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.website = Bucket_Website.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.versioning = Bucket_Versioning.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.logging = Bucket_Logging.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.owner = Owner.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.encryption = Bucket_Encryption.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.billing = Bucket_Billing.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.retentionPolicy = Bucket_RetentionPolicy.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.locationType = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.iamConfiguration = Bucket_IamConfiguration.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.zoneAffinity.push(reader.string());
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.satisfiesPzs = reader.bool();
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.autoclass = Bucket_Autoclass.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket {
    return {
      acl: globalThis.Array.isArray(object?.acl) ? object.acl.map((e: any) => BucketAccessControl.fromJSON(e)) : [],
      defaultObjectAcl: globalThis.Array.isArray(object?.defaultObjectAcl)
        ? object.defaultObjectAcl.map((e: any) => ObjectAccessControl.fromJSON(e))
        : [],
      lifecycle: isSet(object.lifecycle) ? Bucket_Lifecycle.fromJSON(object.lifecycle) : undefined,
      timeCreated: isSet(object.timeCreated) ? fromJsonTimestamp(object.timeCreated) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      projectNumber: isSet(object.projectNumber) ? Long.fromValue(object.projectNumber) : Long.ZERO,
      metageneration: isSet(object.metageneration) ? Long.fromValue(object.metageneration) : Long.ZERO,
      cors: globalThis.Array.isArray(object?.cors) ? object.cors.map((e: any) => Bucket_Cors.fromJSON(e)) : [],
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      storageClass: isSet(object.storageClass) ? globalThis.String(object.storageClass) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      updated: isSet(object.updated) ? fromJsonTimestamp(object.updated) : undefined,
      defaultEventBasedHold: isSet(object.defaultEventBasedHold)
        ? globalThis.Boolean(object.defaultEventBasedHold)
        : false,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      website: isSet(object.website) ? Bucket_Website.fromJSON(object.website) : undefined,
      versioning: isSet(object.versioning) ? Bucket_Versioning.fromJSON(object.versioning) : undefined,
      logging: isSet(object.logging) ? Bucket_Logging.fromJSON(object.logging) : undefined,
      owner: isSet(object.owner) ? Owner.fromJSON(object.owner) : undefined,
      encryption: isSet(object.encryption) ? Bucket_Encryption.fromJSON(object.encryption) : undefined,
      billing: isSet(object.billing) ? Bucket_Billing.fromJSON(object.billing) : undefined,
      retentionPolicy: isSet(object.retentionPolicy)
        ? Bucket_RetentionPolicy.fromJSON(object.retentionPolicy)
        : undefined,
      locationType: isSet(object.locationType) ? globalThis.String(object.locationType) : "",
      iamConfiguration: isSet(object.iamConfiguration)
        ? Bucket_IamConfiguration.fromJSON(object.iamConfiguration)
        : undefined,
      zoneAffinity: globalThis.Array.isArray(object?.zoneAffinity)
        ? object.zoneAffinity.map((e: any) => globalThis.String(e))
        : [],
      satisfiesPzs: isSet(object.satisfiesPzs) ? globalThis.Boolean(object.satisfiesPzs) : false,
      autoclass: isSet(object.autoclass) ? Bucket_Autoclass.fromJSON(object.autoclass) : undefined,
    };
  },

  toJSON(message: Bucket): unknown {
    const obj: any = {};
    if (message.acl?.length) {
      obj.acl = message.acl.map((e) => BucketAccessControl.toJSON(e));
    }
    if (message.defaultObjectAcl?.length) {
      obj.defaultObjectAcl = message.defaultObjectAcl.map((e) => ObjectAccessControl.toJSON(e));
    }
    if (message.lifecycle !== undefined) {
      obj.lifecycle = Bucket_Lifecycle.toJSON(message.lifecycle);
    }
    if (message.timeCreated !== undefined) {
      obj.timeCreated = message.timeCreated.toISOString();
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.projectNumber.equals(Long.ZERO)) {
      obj.projectNumber = (message.projectNumber || Long.ZERO).toString();
    }
    if (!message.metageneration.equals(Long.ZERO)) {
      obj.metageneration = (message.metageneration || Long.ZERO).toString();
    }
    if (message.cors?.length) {
      obj.cors = message.cors.map((e) => Bucket_Cors.toJSON(e));
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.storageClass !== "") {
      obj.storageClass = message.storageClass;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.updated !== undefined) {
      obj.updated = message.updated.toISOString();
    }
    if (message.defaultEventBasedHold !== false) {
      obj.defaultEventBasedHold = message.defaultEventBasedHold;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.website !== undefined) {
      obj.website = Bucket_Website.toJSON(message.website);
    }
    if (message.versioning !== undefined) {
      obj.versioning = Bucket_Versioning.toJSON(message.versioning);
    }
    if (message.logging !== undefined) {
      obj.logging = Bucket_Logging.toJSON(message.logging);
    }
    if (message.owner !== undefined) {
      obj.owner = Owner.toJSON(message.owner);
    }
    if (message.encryption !== undefined) {
      obj.encryption = Bucket_Encryption.toJSON(message.encryption);
    }
    if (message.billing !== undefined) {
      obj.billing = Bucket_Billing.toJSON(message.billing);
    }
    if (message.retentionPolicy !== undefined) {
      obj.retentionPolicy = Bucket_RetentionPolicy.toJSON(message.retentionPolicy);
    }
    if (message.locationType !== "") {
      obj.locationType = message.locationType;
    }
    if (message.iamConfiguration !== undefined) {
      obj.iamConfiguration = Bucket_IamConfiguration.toJSON(message.iamConfiguration);
    }
    if (message.zoneAffinity?.length) {
      obj.zoneAffinity = message.zoneAffinity;
    }
    if (message.satisfiesPzs !== false) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.autoclass !== undefined) {
      obj.autoclass = Bucket_Autoclass.toJSON(message.autoclass);
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket>): Bucket {
    return Bucket.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket>): Bucket {
    const message = createBaseBucket();
    message.acl = object.acl?.map((e) => BucketAccessControl.fromPartial(e)) || [];
    message.defaultObjectAcl = object.defaultObjectAcl?.map((e) => ObjectAccessControl.fromPartial(e)) || [];
    message.lifecycle = (object.lifecycle !== undefined && object.lifecycle !== null)
      ? Bucket_Lifecycle.fromPartial(object.lifecycle)
      : undefined;
    message.timeCreated = object.timeCreated ?? undefined;
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.projectNumber = (object.projectNumber !== undefined && object.projectNumber !== null)
      ? Long.fromValue(object.projectNumber)
      : Long.ZERO;
    message.metageneration = (object.metageneration !== undefined && object.metageneration !== null)
      ? Long.fromValue(object.metageneration)
      : Long.ZERO;
    message.cors = object.cors?.map((e) => Bucket_Cors.fromPartial(e)) || [];
    message.location = object.location ?? "";
    message.storageClass = object.storageClass ?? "";
    message.etag = object.etag ?? "";
    message.updated = object.updated ?? undefined;
    message.defaultEventBasedHold = object.defaultEventBasedHold ?? false;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.website = (object.website !== undefined && object.website !== null)
      ? Bucket_Website.fromPartial(object.website)
      : undefined;
    message.versioning = (object.versioning !== undefined && object.versioning !== null)
      ? Bucket_Versioning.fromPartial(object.versioning)
      : undefined;
    message.logging = (object.logging !== undefined && object.logging !== null)
      ? Bucket_Logging.fromPartial(object.logging)
      : undefined;
    message.owner = (object.owner !== undefined && object.owner !== null) ? Owner.fromPartial(object.owner) : undefined;
    message.encryption = (object.encryption !== undefined && object.encryption !== null)
      ? Bucket_Encryption.fromPartial(object.encryption)
      : undefined;
    message.billing = (object.billing !== undefined && object.billing !== null)
      ? Bucket_Billing.fromPartial(object.billing)
      : undefined;
    message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
      ? Bucket_RetentionPolicy.fromPartial(object.retentionPolicy)
      : undefined;
    message.locationType = object.locationType ?? "";
    message.iamConfiguration = (object.iamConfiguration !== undefined && object.iamConfiguration !== null)
      ? Bucket_IamConfiguration.fromPartial(object.iamConfiguration)
      : undefined;
    message.zoneAffinity = object.zoneAffinity?.map((e) => e) || [];
    message.satisfiesPzs = object.satisfiesPzs ?? false;
    message.autoclass = (object.autoclass !== undefined && object.autoclass !== null)
      ? Bucket_Autoclass.fromPartial(object.autoclass)
      : undefined;
    return message;
  },
};

function createBaseBucket_Billing(): Bucket_Billing {
  return { requesterPays: false };
}

export const Bucket_Billing: MessageFns<Bucket_Billing> = {
  encode(message: Bucket_Billing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requesterPays !== false) {
      writer.uint32(8).bool(message.requesterPays);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_Billing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_Billing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.requesterPays = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_Billing {
    return { requesterPays: isSet(object.requesterPays) ? globalThis.Boolean(object.requesterPays) : false };
  },

  toJSON(message: Bucket_Billing): unknown {
    const obj: any = {};
    if (message.requesterPays !== false) {
      obj.requesterPays = message.requesterPays;
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_Billing>): Bucket_Billing {
    return Bucket_Billing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_Billing>): Bucket_Billing {
    const message = createBaseBucket_Billing();
    message.requesterPays = object.requesterPays ?? false;
    return message;
  },
};

function createBaseBucket_Cors(): Bucket_Cors {
  return { origin: [], method: [], responseHeader: [], maxAgeSeconds: 0 };
}

export const Bucket_Cors: MessageFns<Bucket_Cors> = {
  encode(message: Bucket_Cors, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.origin) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.method) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.responseHeader) {
      writer.uint32(26).string(v!);
    }
    if (message.maxAgeSeconds !== 0) {
      writer.uint32(32).int32(message.maxAgeSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_Cors {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_Cors();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.origin.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.method.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.responseHeader.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxAgeSeconds = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_Cors {
    return {
      origin: globalThis.Array.isArray(object?.origin) ? object.origin.map((e: any) => globalThis.String(e)) : [],
      method: globalThis.Array.isArray(object?.method) ? object.method.map((e: any) => globalThis.String(e)) : [],
      responseHeader: globalThis.Array.isArray(object?.responseHeader)
        ? object.responseHeader.map((e: any) => globalThis.String(e))
        : [],
      maxAgeSeconds: isSet(object.maxAgeSeconds) ? globalThis.Number(object.maxAgeSeconds) : 0,
    };
  },

  toJSON(message: Bucket_Cors): unknown {
    const obj: any = {};
    if (message.origin?.length) {
      obj.origin = message.origin;
    }
    if (message.method?.length) {
      obj.method = message.method;
    }
    if (message.responseHeader?.length) {
      obj.responseHeader = message.responseHeader;
    }
    if (message.maxAgeSeconds !== 0) {
      obj.maxAgeSeconds = Math.round(message.maxAgeSeconds);
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_Cors>): Bucket_Cors {
    return Bucket_Cors.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_Cors>): Bucket_Cors {
    const message = createBaseBucket_Cors();
    message.origin = object.origin?.map((e) => e) || [];
    message.method = object.method?.map((e) => e) || [];
    message.responseHeader = object.responseHeader?.map((e) => e) || [];
    message.maxAgeSeconds = object.maxAgeSeconds ?? 0;
    return message;
  },
};

function createBaseBucket_Encryption(): Bucket_Encryption {
  return { defaultKmsKeyName: "" };
}

export const Bucket_Encryption: MessageFns<Bucket_Encryption> = {
  encode(message: Bucket_Encryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.defaultKmsKeyName !== "") {
      writer.uint32(10).string(message.defaultKmsKeyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_Encryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_Encryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.defaultKmsKeyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_Encryption {
    return { defaultKmsKeyName: isSet(object.defaultKmsKeyName) ? globalThis.String(object.defaultKmsKeyName) : "" };
  },

  toJSON(message: Bucket_Encryption): unknown {
    const obj: any = {};
    if (message.defaultKmsKeyName !== "") {
      obj.defaultKmsKeyName = message.defaultKmsKeyName;
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_Encryption>): Bucket_Encryption {
    return Bucket_Encryption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_Encryption>): Bucket_Encryption {
    const message = createBaseBucket_Encryption();
    message.defaultKmsKeyName = object.defaultKmsKeyName ?? "";
    return message;
  },
};

function createBaseBucket_IamConfiguration(): Bucket_IamConfiguration {
  return { uniformBucketLevelAccess: undefined, publicAccessPrevention: 0 };
}

export const Bucket_IamConfiguration: MessageFns<Bucket_IamConfiguration> = {
  encode(message: Bucket_IamConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uniformBucketLevelAccess !== undefined) {
      Bucket_IamConfiguration_UniformBucketLevelAccess.encode(
        message.uniformBucketLevelAccess,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.publicAccessPrevention !== 0) {
      writer.uint32(16).int32(message.publicAccessPrevention);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_IamConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_IamConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uniformBucketLevelAccess = Bucket_IamConfiguration_UniformBucketLevelAccess.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.publicAccessPrevention = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_IamConfiguration {
    return {
      uniformBucketLevelAccess: isSet(object.uniformBucketLevelAccess)
        ? Bucket_IamConfiguration_UniformBucketLevelAccess.fromJSON(object.uniformBucketLevelAccess)
        : undefined,
      publicAccessPrevention: isSet(object.publicAccessPrevention)
        ? bucket_IamConfiguration_PublicAccessPreventionFromJSON(object.publicAccessPrevention)
        : 0,
    };
  },

  toJSON(message: Bucket_IamConfiguration): unknown {
    const obj: any = {};
    if (message.uniformBucketLevelAccess !== undefined) {
      obj.uniformBucketLevelAccess = Bucket_IamConfiguration_UniformBucketLevelAccess.toJSON(
        message.uniformBucketLevelAccess,
      );
    }
    if (message.publicAccessPrevention !== 0) {
      obj.publicAccessPrevention = bucket_IamConfiguration_PublicAccessPreventionToJSON(message.publicAccessPrevention);
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_IamConfiguration>): Bucket_IamConfiguration {
    return Bucket_IamConfiguration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_IamConfiguration>): Bucket_IamConfiguration {
    const message = createBaseBucket_IamConfiguration();
    message.uniformBucketLevelAccess =
      (object.uniformBucketLevelAccess !== undefined && object.uniformBucketLevelAccess !== null)
        ? Bucket_IamConfiguration_UniformBucketLevelAccess.fromPartial(object.uniformBucketLevelAccess)
        : undefined;
    message.publicAccessPrevention = object.publicAccessPrevention ?? 0;
    return message;
  },
};

function createBaseBucket_IamConfiguration_UniformBucketLevelAccess(): Bucket_IamConfiguration_UniformBucketLevelAccess {
  return { enabled: false, lockedTime: undefined };
}

export const Bucket_IamConfiguration_UniformBucketLevelAccess: MessageFns<
  Bucket_IamConfiguration_UniformBucketLevelAccess
> = {
  encode(
    message: Bucket_IamConfiguration_UniformBucketLevelAccess,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.lockedTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lockedTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_IamConfiguration_UniformBucketLevelAccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_IamConfiguration_UniformBucketLevelAccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lockedTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_IamConfiguration_UniformBucketLevelAccess {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      lockedTime: isSet(object.lockedTime) ? fromJsonTimestamp(object.lockedTime) : undefined,
    };
  },

  toJSON(message: Bucket_IamConfiguration_UniformBucketLevelAccess): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.lockedTime !== undefined) {
      obj.lockedTime = message.lockedTime.toISOString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<Bucket_IamConfiguration_UniformBucketLevelAccess>,
  ): Bucket_IamConfiguration_UniformBucketLevelAccess {
    return Bucket_IamConfiguration_UniformBucketLevelAccess.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Bucket_IamConfiguration_UniformBucketLevelAccess>,
  ): Bucket_IamConfiguration_UniformBucketLevelAccess {
    const message = createBaseBucket_IamConfiguration_UniformBucketLevelAccess();
    message.enabled = object.enabled ?? false;
    message.lockedTime = object.lockedTime ?? undefined;
    return message;
  },
};

function createBaseBucket_Lifecycle(): Bucket_Lifecycle {
  return { rule: [] };
}

export const Bucket_Lifecycle: MessageFns<Bucket_Lifecycle> = {
  encode(message: Bucket_Lifecycle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rule) {
      Bucket_Lifecycle_Rule.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_Lifecycle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_Lifecycle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rule.push(Bucket_Lifecycle_Rule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_Lifecycle {
    return {
      rule: globalThis.Array.isArray(object?.rule)
        ? object.rule.map((e: any) => Bucket_Lifecycle_Rule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Bucket_Lifecycle): unknown {
    const obj: any = {};
    if (message.rule?.length) {
      obj.rule = message.rule.map((e) => Bucket_Lifecycle_Rule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_Lifecycle>): Bucket_Lifecycle {
    return Bucket_Lifecycle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_Lifecycle>): Bucket_Lifecycle {
    const message = createBaseBucket_Lifecycle();
    message.rule = object.rule?.map((e) => Bucket_Lifecycle_Rule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBucket_Lifecycle_Rule(): Bucket_Lifecycle_Rule {
  return { action: undefined, condition: undefined };
}

export const Bucket_Lifecycle_Rule: MessageFns<Bucket_Lifecycle_Rule> = {
  encode(message: Bucket_Lifecycle_Rule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== undefined) {
      Bucket_Lifecycle_Rule_Action.encode(message.action, writer.uint32(10).fork()).join();
    }
    if (message.condition !== undefined) {
      Bucket_Lifecycle_Rule_Condition.encode(message.condition, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_Lifecycle_Rule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_Lifecycle_Rule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.action = Bucket_Lifecycle_Rule_Action.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.condition = Bucket_Lifecycle_Rule_Condition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_Lifecycle_Rule {
    return {
      action: isSet(object.action) ? Bucket_Lifecycle_Rule_Action.fromJSON(object.action) : undefined,
      condition: isSet(object.condition) ? Bucket_Lifecycle_Rule_Condition.fromJSON(object.condition) : undefined,
    };
  },

  toJSON(message: Bucket_Lifecycle_Rule): unknown {
    const obj: any = {};
    if (message.action !== undefined) {
      obj.action = Bucket_Lifecycle_Rule_Action.toJSON(message.action);
    }
    if (message.condition !== undefined) {
      obj.condition = Bucket_Lifecycle_Rule_Condition.toJSON(message.condition);
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_Lifecycle_Rule>): Bucket_Lifecycle_Rule {
    return Bucket_Lifecycle_Rule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_Lifecycle_Rule>): Bucket_Lifecycle_Rule {
    const message = createBaseBucket_Lifecycle_Rule();
    message.action = (object.action !== undefined && object.action !== null)
      ? Bucket_Lifecycle_Rule_Action.fromPartial(object.action)
      : undefined;
    message.condition = (object.condition !== undefined && object.condition !== null)
      ? Bucket_Lifecycle_Rule_Condition.fromPartial(object.condition)
      : undefined;
    return message;
  },
};

function createBaseBucket_Lifecycle_Rule_Action(): Bucket_Lifecycle_Rule_Action {
  return { type: "", storageClass: "" };
}

export const Bucket_Lifecycle_Rule_Action: MessageFns<Bucket_Lifecycle_Rule_Action> = {
  encode(message: Bucket_Lifecycle_Rule_Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.storageClass !== "") {
      writer.uint32(18).string(message.storageClass);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_Lifecycle_Rule_Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_Lifecycle_Rule_Action();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.storageClass = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_Lifecycle_Rule_Action {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      storageClass: isSet(object.storageClass) ? globalThis.String(object.storageClass) : "",
    };
  },

  toJSON(message: Bucket_Lifecycle_Rule_Action): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.storageClass !== "") {
      obj.storageClass = message.storageClass;
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_Lifecycle_Rule_Action>): Bucket_Lifecycle_Rule_Action {
    return Bucket_Lifecycle_Rule_Action.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_Lifecycle_Rule_Action>): Bucket_Lifecycle_Rule_Action {
    const message = createBaseBucket_Lifecycle_Rule_Action();
    message.type = object.type ?? "";
    message.storageClass = object.storageClass ?? "";
    return message;
  },
};

function createBaseBucket_Lifecycle_Rule_Condition(): Bucket_Lifecycle_Rule_Condition {
  return {
    age: 0,
    createdBefore: undefined,
    isLive: undefined,
    numNewerVersions: 0,
    matchesStorageClass: [],
    matchesPattern: "",
    daysSinceCustomTime: 0,
    customTimeBefore: undefined,
    daysSinceNoncurrentTime: 0,
    noncurrentTimeBefore: undefined,
    matchesPrefix: [],
    matchesSuffix: [],
  };
}

export const Bucket_Lifecycle_Rule_Condition: MessageFns<Bucket_Lifecycle_Rule_Condition> = {
  encode(message: Bucket_Lifecycle_Rule_Condition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.age !== 0) {
      writer.uint32(8).int32(message.age);
    }
    if (message.createdBefore !== undefined) {
      Timestamp.encode(toTimestamp(message.createdBefore), writer.uint32(18).fork()).join();
    }
    if (message.isLive !== undefined) {
      BoolValue.encode({ value: message.isLive! }, writer.uint32(26).fork()).join();
    }
    if (message.numNewerVersions !== 0) {
      writer.uint32(32).int32(message.numNewerVersions);
    }
    for (const v of message.matchesStorageClass) {
      writer.uint32(42).string(v!);
    }
    if (message.matchesPattern !== "") {
      writer.uint32(50).string(message.matchesPattern);
    }
    if (message.daysSinceCustomTime !== 0) {
      writer.uint32(56).int32(message.daysSinceCustomTime);
    }
    if (message.customTimeBefore !== undefined) {
      Timestamp.encode(toTimestamp(message.customTimeBefore), writer.uint32(66).fork()).join();
    }
    if (message.daysSinceNoncurrentTime !== 0) {
      writer.uint32(72).int32(message.daysSinceNoncurrentTime);
    }
    if (message.noncurrentTimeBefore !== undefined) {
      Timestamp.encode(toTimestamp(message.noncurrentTimeBefore), writer.uint32(82).fork()).join();
    }
    for (const v of message.matchesPrefix) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.matchesSuffix) {
      writer.uint32(98).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_Lifecycle_Rule_Condition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_Lifecycle_Rule_Condition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.age = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createdBefore = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.isLive = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.numNewerVersions = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.matchesStorageClass.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.matchesPattern = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.daysSinceCustomTime = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.customTimeBefore = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.daysSinceNoncurrentTime = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.noncurrentTimeBefore = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.matchesPrefix.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.matchesSuffix.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_Lifecycle_Rule_Condition {
    return {
      age: isSet(object.age) ? globalThis.Number(object.age) : 0,
      createdBefore: isSet(object.createdBefore) ? fromJsonTimestamp(object.createdBefore) : undefined,
      isLive: isSet(object.isLive) ? Boolean(object.isLive) : undefined,
      numNewerVersions: isSet(object.numNewerVersions) ? globalThis.Number(object.numNewerVersions) : 0,
      matchesStorageClass: globalThis.Array.isArray(object?.matchesStorageClass)
        ? object.matchesStorageClass.map((e: any) => globalThis.String(e))
        : [],
      matchesPattern: isSet(object.matchesPattern) ? globalThis.String(object.matchesPattern) : "",
      daysSinceCustomTime: isSet(object.daysSinceCustomTime) ? globalThis.Number(object.daysSinceCustomTime) : 0,
      customTimeBefore: isSet(object.customTimeBefore) ? fromJsonTimestamp(object.customTimeBefore) : undefined,
      daysSinceNoncurrentTime: isSet(object.daysSinceNoncurrentTime)
        ? globalThis.Number(object.daysSinceNoncurrentTime)
        : 0,
      noncurrentTimeBefore: isSet(object.noncurrentTimeBefore)
        ? fromJsonTimestamp(object.noncurrentTimeBefore)
        : undefined,
      matchesPrefix: globalThis.Array.isArray(object?.matchesPrefix)
        ? object.matchesPrefix.map((e: any) => globalThis.String(e))
        : [],
      matchesSuffix: globalThis.Array.isArray(object?.matchesSuffix)
        ? object.matchesSuffix.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Bucket_Lifecycle_Rule_Condition): unknown {
    const obj: any = {};
    if (message.age !== 0) {
      obj.age = Math.round(message.age);
    }
    if (message.createdBefore !== undefined) {
      obj.createdBefore = message.createdBefore.toISOString();
    }
    if (message.isLive !== undefined) {
      obj.isLive = message.isLive;
    }
    if (message.numNewerVersions !== 0) {
      obj.numNewerVersions = Math.round(message.numNewerVersions);
    }
    if (message.matchesStorageClass?.length) {
      obj.matchesStorageClass = message.matchesStorageClass;
    }
    if (message.matchesPattern !== "") {
      obj.matchesPattern = message.matchesPattern;
    }
    if (message.daysSinceCustomTime !== 0) {
      obj.daysSinceCustomTime = Math.round(message.daysSinceCustomTime);
    }
    if (message.customTimeBefore !== undefined) {
      obj.customTimeBefore = message.customTimeBefore.toISOString();
    }
    if (message.daysSinceNoncurrentTime !== 0) {
      obj.daysSinceNoncurrentTime = Math.round(message.daysSinceNoncurrentTime);
    }
    if (message.noncurrentTimeBefore !== undefined) {
      obj.noncurrentTimeBefore = message.noncurrentTimeBefore.toISOString();
    }
    if (message.matchesPrefix?.length) {
      obj.matchesPrefix = message.matchesPrefix;
    }
    if (message.matchesSuffix?.length) {
      obj.matchesSuffix = message.matchesSuffix;
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_Lifecycle_Rule_Condition>): Bucket_Lifecycle_Rule_Condition {
    return Bucket_Lifecycle_Rule_Condition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_Lifecycle_Rule_Condition>): Bucket_Lifecycle_Rule_Condition {
    const message = createBaseBucket_Lifecycle_Rule_Condition();
    message.age = object.age ?? 0;
    message.createdBefore = object.createdBefore ?? undefined;
    message.isLive = object.isLive ?? undefined;
    message.numNewerVersions = object.numNewerVersions ?? 0;
    message.matchesStorageClass = object.matchesStorageClass?.map((e) => e) || [];
    message.matchesPattern = object.matchesPattern ?? "";
    message.daysSinceCustomTime = object.daysSinceCustomTime ?? 0;
    message.customTimeBefore = object.customTimeBefore ?? undefined;
    message.daysSinceNoncurrentTime = object.daysSinceNoncurrentTime ?? 0;
    message.noncurrentTimeBefore = object.noncurrentTimeBefore ?? undefined;
    message.matchesPrefix = object.matchesPrefix?.map((e) => e) || [];
    message.matchesSuffix = object.matchesSuffix?.map((e) => e) || [];
    return message;
  },
};

function createBaseBucket_Logging(): Bucket_Logging {
  return { logBucket: "", logObjectPrefix: "" };
}

export const Bucket_Logging: MessageFns<Bucket_Logging> = {
  encode(message: Bucket_Logging, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.logBucket !== "") {
      writer.uint32(10).string(message.logBucket);
    }
    if (message.logObjectPrefix !== "") {
      writer.uint32(18).string(message.logObjectPrefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_Logging {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_Logging();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.logBucket = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.logObjectPrefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_Logging {
    return {
      logBucket: isSet(object.logBucket) ? globalThis.String(object.logBucket) : "",
      logObjectPrefix: isSet(object.logObjectPrefix) ? globalThis.String(object.logObjectPrefix) : "",
    };
  },

  toJSON(message: Bucket_Logging): unknown {
    const obj: any = {};
    if (message.logBucket !== "") {
      obj.logBucket = message.logBucket;
    }
    if (message.logObjectPrefix !== "") {
      obj.logObjectPrefix = message.logObjectPrefix;
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_Logging>): Bucket_Logging {
    return Bucket_Logging.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_Logging>): Bucket_Logging {
    const message = createBaseBucket_Logging();
    message.logBucket = object.logBucket ?? "";
    message.logObjectPrefix = object.logObjectPrefix ?? "";
    return message;
  },
};

function createBaseBucket_RetentionPolicy(): Bucket_RetentionPolicy {
  return { effectiveTime: undefined, isLocked: false, retentionPeriod: Long.ZERO };
}

export const Bucket_RetentionPolicy: MessageFns<Bucket_RetentionPolicy> = {
  encode(message: Bucket_RetentionPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.effectiveTime !== undefined) {
      Timestamp.encode(toTimestamp(message.effectiveTime), writer.uint32(10).fork()).join();
    }
    if (message.isLocked !== false) {
      writer.uint32(16).bool(message.isLocked);
    }
    if (!message.retentionPeriod.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.retentionPeriod.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_RetentionPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_RetentionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.effectiveTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isLocked = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.retentionPeriod = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_RetentionPolicy {
    return {
      effectiveTime: isSet(object.effectiveTime) ? fromJsonTimestamp(object.effectiveTime) : undefined,
      isLocked: isSet(object.isLocked) ? globalThis.Boolean(object.isLocked) : false,
      retentionPeriod: isSet(object.retentionPeriod) ? Long.fromValue(object.retentionPeriod) : Long.ZERO,
    };
  },

  toJSON(message: Bucket_RetentionPolicy): unknown {
    const obj: any = {};
    if (message.effectiveTime !== undefined) {
      obj.effectiveTime = message.effectiveTime.toISOString();
    }
    if (message.isLocked !== false) {
      obj.isLocked = message.isLocked;
    }
    if (!message.retentionPeriod.equals(Long.ZERO)) {
      obj.retentionPeriod = (message.retentionPeriod || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_RetentionPolicy>): Bucket_RetentionPolicy {
    return Bucket_RetentionPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_RetentionPolicy>): Bucket_RetentionPolicy {
    const message = createBaseBucket_RetentionPolicy();
    message.effectiveTime = object.effectiveTime ?? undefined;
    message.isLocked = object.isLocked ?? false;
    message.retentionPeriod = (object.retentionPeriod !== undefined && object.retentionPeriod !== null)
      ? Long.fromValue(object.retentionPeriod)
      : Long.ZERO;
    return message;
  },
};

function createBaseBucket_Versioning(): Bucket_Versioning {
  return { enabled: false };
}

export const Bucket_Versioning: MessageFns<Bucket_Versioning> = {
  encode(message: Bucket_Versioning, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_Versioning {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_Versioning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_Versioning {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: Bucket_Versioning): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_Versioning>): Bucket_Versioning {
    return Bucket_Versioning.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_Versioning>): Bucket_Versioning {
    const message = createBaseBucket_Versioning();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseBucket_Website(): Bucket_Website {
  return { mainPageSuffix: "", notFoundPage: "" };
}

export const Bucket_Website: MessageFns<Bucket_Website> = {
  encode(message: Bucket_Website, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mainPageSuffix !== "") {
      writer.uint32(10).string(message.mainPageSuffix);
    }
    if (message.notFoundPage !== "") {
      writer.uint32(18).string(message.notFoundPage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_Website {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_Website();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mainPageSuffix = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.notFoundPage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_Website {
    return {
      mainPageSuffix: isSet(object.mainPageSuffix) ? globalThis.String(object.mainPageSuffix) : "",
      notFoundPage: isSet(object.notFoundPage) ? globalThis.String(object.notFoundPage) : "",
    };
  },

  toJSON(message: Bucket_Website): unknown {
    const obj: any = {};
    if (message.mainPageSuffix !== "") {
      obj.mainPageSuffix = message.mainPageSuffix;
    }
    if (message.notFoundPage !== "") {
      obj.notFoundPage = message.notFoundPage;
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_Website>): Bucket_Website {
    return Bucket_Website.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_Website>): Bucket_Website {
    const message = createBaseBucket_Website();
    message.mainPageSuffix = object.mainPageSuffix ?? "";
    message.notFoundPage = object.notFoundPage ?? "";
    return message;
  },
};

function createBaseBucket_Autoclass(): Bucket_Autoclass {
  return { enabled: false, toggleTime: undefined };
}

export const Bucket_Autoclass: MessageFns<Bucket_Autoclass> = {
  encode(message: Bucket_Autoclass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.toggleTime !== undefined) {
      Timestamp.encode(toTimestamp(message.toggleTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_Autoclass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_Autoclass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.toggleTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_Autoclass {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      toggleTime: isSet(object.toggleTime) ? fromJsonTimestamp(object.toggleTime) : undefined,
    };
  },

  toJSON(message: Bucket_Autoclass): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.toggleTime !== undefined) {
      obj.toggleTime = message.toggleTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_Autoclass>): Bucket_Autoclass {
    return Bucket_Autoclass.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_Autoclass>): Bucket_Autoclass {
    const message = createBaseBucket_Autoclass();
    message.enabled = object.enabled ?? false;
    message.toggleTime = object.toggleTime ?? undefined;
    return message;
  },
};

function createBaseBucket_LabelsEntry(): Bucket_LabelsEntry {
  return { key: "", value: "" };
}

export const Bucket_LabelsEntry: MessageFns<Bucket_LabelsEntry> = {
  encode(message: Bucket_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bucket_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucket_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bucket_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Bucket_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Bucket_LabelsEntry>): Bucket_LabelsEntry {
    return Bucket_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Bucket_LabelsEntry>): Bucket_LabelsEntry {
    const message = createBaseBucket_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBucketAccessControl(): BucketAccessControl {
  return {
    role: "",
    etag: "",
    id: "",
    bucket: "",
    entity: "",
    entityId: "",
    email: "",
    domain: "",
    projectTeam: undefined,
  };
}

export const BucketAccessControl: MessageFns<BucketAccessControl> = {
  encode(message: BucketAccessControl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.bucket !== "") {
      writer.uint32(34).string(message.bucket);
    }
    if (message.entity !== "") {
      writer.uint32(50).string(message.entity);
    }
    if (message.entityId !== "") {
      writer.uint32(58).string(message.entityId);
    }
    if (message.email !== "") {
      writer.uint32(66).string(message.email);
    }
    if (message.domain !== "") {
      writer.uint32(74).string(message.domain);
    }
    if (message.projectTeam !== undefined) {
      ProjectTeam.encode(message.projectTeam, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BucketAccessControl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBucketAccessControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bucket = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.entity = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.entityId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.email = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.projectTeam = ProjectTeam.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BucketAccessControl {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      projectTeam: isSet(object.projectTeam) ? ProjectTeam.fromJSON(object.projectTeam) : undefined,
    };
  },

  toJSON(message: BucketAccessControl): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.projectTeam !== undefined) {
      obj.projectTeam = ProjectTeam.toJSON(message.projectTeam);
    }
    return obj;
  },

  create(base?: DeepPartial<BucketAccessControl>): BucketAccessControl {
    return BucketAccessControl.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BucketAccessControl>): BucketAccessControl {
    const message = createBaseBucketAccessControl();
    message.role = object.role ?? "";
    message.etag = object.etag ?? "";
    message.id = object.id ?? "";
    message.bucket = object.bucket ?? "";
    message.entity = object.entity ?? "";
    message.entityId = object.entityId ?? "";
    message.email = object.email ?? "";
    message.domain = object.domain ?? "";
    message.projectTeam = (object.projectTeam !== undefined && object.projectTeam !== null)
      ? ProjectTeam.fromPartial(object.projectTeam)
      : undefined;
    return message;
  },
};

function createBaseListBucketAccessControlsResponse(): ListBucketAccessControlsResponse {
  return { items: [] };
}

export const ListBucketAccessControlsResponse: MessageFns<ListBucketAccessControlsResponse> = {
  encode(message: ListBucketAccessControlsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      BucketAccessControl.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBucketAccessControlsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBucketAccessControlsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(BucketAccessControl.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBucketAccessControlsResponse {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => BucketAccessControl.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListBucketAccessControlsResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => BucketAccessControl.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListBucketAccessControlsResponse>): ListBucketAccessControlsResponse {
    return ListBucketAccessControlsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBucketAccessControlsResponse>): ListBucketAccessControlsResponse {
    const message = createBaseListBucketAccessControlsResponse();
    message.items = object.items?.map((e) => BucketAccessControl.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListBucketsResponse(): ListBucketsResponse {
  return { items: [], nextPageToken: "" };
}

export const ListBucketsResponse: MessageFns<ListBucketsResponse> = {
  encode(message: ListBucketsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Bucket.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBucketsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBucketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(Bucket.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBucketsResponse {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Bucket.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListBucketsResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Bucket.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBucketsResponse>): ListBucketsResponse {
    return ListBucketsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBucketsResponse>): ListBucketsResponse {
    const message = createBaseListBucketsResponse();
    message.items = object.items?.map((e) => Bucket.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseChannel(): Channel {
  return {
    id: "",
    resourceId: "",
    resourceUri: "",
    token: "",
    expiration: undefined,
    type: "",
    address: "",
    params: {},
    payload: false,
  };
}

export const Channel: MessageFns<Channel> = {
  encode(message: Channel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.resourceId !== "") {
      writer.uint32(18).string(message.resourceId);
    }
    if (message.resourceUri !== "") {
      writer.uint32(26).string(message.resourceUri);
    }
    if (message.token !== "") {
      writer.uint32(34).string(message.token);
    }
    if (message.expiration !== undefined) {
      Timestamp.encode(toTimestamp(message.expiration), writer.uint32(42).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(50).string(message.type);
    }
    if (message.address !== "") {
      writer.uint32(58).string(message.address);
    }
    Object.entries(message.params).forEach(([key, value]) => {
      Channel_ParamsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.payload !== false) {
      writer.uint32(72).bool(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Channel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.token = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expiration = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.type = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.address = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = Channel_ParamsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.params[entry8.key] = entry8.value;
          }
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.payload = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Channel {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      resourceUri: isSet(object.resourceUri) ? globalThis.String(object.resourceUri) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      expiration: isSet(object.expiration) ? fromJsonTimestamp(object.expiration) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      params: isObject(object.params)
        ? Object.entries(object.params).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      payload: isSet(object.payload) ? globalThis.Boolean(object.payload) : false,
    };
  },

  toJSON(message: Channel): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.resourceUri !== "") {
      obj.resourceUri = message.resourceUri;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.expiration !== undefined) {
      obj.expiration = message.expiration.toISOString();
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.params) {
      const entries = Object.entries(message.params);
      if (entries.length > 0) {
        obj.params = {};
        entries.forEach(([k, v]) => {
          obj.params[k] = v;
        });
      }
    }
    if (message.payload !== false) {
      obj.payload = message.payload;
    }
    return obj;
  },

  create(base?: DeepPartial<Channel>): Channel {
    return Channel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Channel>): Channel {
    const message = createBaseChannel();
    message.id = object.id ?? "";
    message.resourceId = object.resourceId ?? "";
    message.resourceUri = object.resourceUri ?? "";
    message.token = object.token ?? "";
    message.expiration = object.expiration ?? undefined;
    message.type = object.type ?? "";
    message.address = object.address ?? "";
    message.params = Object.entries(object.params ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.payload = object.payload ?? false;
    return message;
  },
};

function createBaseChannel_ParamsEntry(): Channel_ParamsEntry {
  return { key: "", value: "" };
}

export const Channel_ParamsEntry: MessageFns<Channel_ParamsEntry> = {
  encode(message: Channel_ParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Channel_ParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannel_ParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Channel_ParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Channel_ParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Channel_ParamsEntry>): Channel_ParamsEntry {
    return Channel_ParamsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Channel_ParamsEntry>): Channel_ParamsEntry {
    const message = createBaseChannel_ParamsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListChannelsResponse(): ListChannelsResponse {
  return { items: [] };
}

export const ListChannelsResponse: MessageFns<ListChannelsResponse> = {
  encode(message: ListChannelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      ListChannelsResponse_Items.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChannelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(ListChannelsResponse_Items.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelsResponse {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => ListChannelsResponse_Items.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListChannelsResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => ListChannelsResponse_Items.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListChannelsResponse>): ListChannelsResponse {
    return ListChannelsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChannelsResponse>): ListChannelsResponse {
    const message = createBaseListChannelsResponse();
    message.items = object.items?.map((e) => ListChannelsResponse_Items.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListChannelsResponse_Items(): ListChannelsResponse_Items {
  return { channelId: "", resourceId: "", pushUrl: "", subscriberEmail: "", creationTime: undefined };
}

export const ListChannelsResponse_Items: MessageFns<ListChannelsResponse_Items> = {
  encode(message: ListChannelsResponse_Items, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== "") {
      writer.uint32(10).string(message.channelId);
    }
    if (message.resourceId !== "") {
      writer.uint32(18).string(message.resourceId);
    }
    if (message.pushUrl !== "") {
      writer.uint32(26).string(message.pushUrl);
    }
    if (message.subscriberEmail !== "") {
      writer.uint32(34).string(message.subscriberEmail);
    }
    if (message.creationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.creationTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChannelsResponse_Items {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChannelsResponse_Items();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pushUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subscriberEmail = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.creationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChannelsResponse_Items {
    return {
      channelId: isSet(object.channelId) ? globalThis.String(object.channelId) : "",
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      pushUrl: isSet(object.pushUrl) ? globalThis.String(object.pushUrl) : "",
      subscriberEmail: isSet(object.subscriberEmail) ? globalThis.String(object.subscriberEmail) : "",
      creationTime: isSet(object.creationTime) ? fromJsonTimestamp(object.creationTime) : undefined,
    };
  },

  toJSON(message: ListChannelsResponse_Items): unknown {
    const obj: any = {};
    if (message.channelId !== "") {
      obj.channelId = message.channelId;
    }
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.pushUrl !== "") {
      obj.pushUrl = message.pushUrl;
    }
    if (message.subscriberEmail !== "") {
      obj.subscriberEmail = message.subscriberEmail;
    }
    if (message.creationTime !== undefined) {
      obj.creationTime = message.creationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListChannelsResponse_Items>): ListChannelsResponse_Items {
    return ListChannelsResponse_Items.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChannelsResponse_Items>): ListChannelsResponse_Items {
    const message = createBaseListChannelsResponse_Items();
    message.channelId = object.channelId ?? "";
    message.resourceId = object.resourceId ?? "";
    message.pushUrl = object.pushUrl ?? "";
    message.subscriberEmail = object.subscriberEmail ?? "";
    message.creationTime = object.creationTime ?? undefined;
    return message;
  },
};

function createBaseChecksummedData(): ChecksummedData {
  return { content: Buffer.alloc(0), crc32c: undefined };
}

export const ChecksummedData: MessageFns<ChecksummedData> = {
  encode(message: ChecksummedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content.length !== 0) {
      writer.uint32(10).bytes(message.content);
    }
    if (message.crc32c !== undefined) {
      UInt32Value.encode({ value: message.crc32c! }, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChecksummedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChecksummedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.crc32c = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChecksummedData {
    return {
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0),
      crc32c: isSet(object.crc32c) ? Number(object.crc32c) : undefined,
    };
  },

  toJSON(message: ChecksummedData): unknown {
    const obj: any = {};
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.crc32c !== undefined) {
      obj.crc32c = message.crc32c;
    }
    return obj;
  },

  create(base?: DeepPartial<ChecksummedData>): ChecksummedData {
    return ChecksummedData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChecksummedData>): ChecksummedData {
    const message = createBaseChecksummedData();
    message.content = object.content ?? Buffer.alloc(0);
    message.crc32c = object.crc32c ?? undefined;
    return message;
  },
};

function createBaseObjectChecksums(): ObjectChecksums {
  return { crc32c: undefined, md5Hash: "" };
}

export const ObjectChecksums: MessageFns<ObjectChecksums> = {
  encode(message: ObjectChecksums, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.crc32c !== undefined) {
      UInt32Value.encode({ value: message.crc32c! }, writer.uint32(10).fork()).join();
    }
    if (message.md5Hash !== "") {
      writer.uint32(18).string(message.md5Hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectChecksums {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectChecksums();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.crc32c = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.md5Hash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectChecksums {
    return {
      crc32c: isSet(object.crc32c) ? Number(object.crc32c) : undefined,
      md5Hash: isSet(object.md5Hash) ? globalThis.String(object.md5Hash) : "",
    };
  },

  toJSON(message: ObjectChecksums): unknown {
    const obj: any = {};
    if (message.crc32c !== undefined) {
      obj.crc32c = message.crc32c;
    }
    if (message.md5Hash !== "") {
      obj.md5Hash = message.md5Hash;
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectChecksums>): ObjectChecksums {
    return ObjectChecksums.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectChecksums>): ObjectChecksums {
    const message = createBaseObjectChecksums();
    message.crc32c = object.crc32c ?? undefined;
    message.md5Hash = object.md5Hash ?? "";
    return message;
  },
};

function createBaseCommonEnums(): CommonEnums {
  return {};
}

export const CommonEnums: MessageFns<CommonEnums> = {
  encode(_: CommonEnums, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonEnums {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonEnums();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CommonEnums {
    return {};
  },

  toJSON(_: CommonEnums): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CommonEnums>): CommonEnums {
    return CommonEnums.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CommonEnums>): CommonEnums {
    const message = createBaseCommonEnums();
    return message;
  },
};

function createBaseContentRange(): ContentRange {
  return { start: Long.ZERO, end: Long.ZERO, completeLength: Long.ZERO };
}

export const ContentRange: MessageFns<ContentRange> = {
  encode(message: ContentRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.start.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.start.toString());
    }
    if (!message.end.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.end.toString());
    }
    if (!message.completeLength.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.completeLength.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContentRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContentRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.completeLength = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContentRange {
    return {
      start: isSet(object.start) ? Long.fromValue(object.start) : Long.ZERO,
      end: isSet(object.end) ? Long.fromValue(object.end) : Long.ZERO,
      completeLength: isSet(object.completeLength) ? Long.fromValue(object.completeLength) : Long.ZERO,
    };
  },

  toJSON(message: ContentRange): unknown {
    const obj: any = {};
    if (!message.start.equals(Long.ZERO)) {
      obj.start = (message.start || Long.ZERO).toString();
    }
    if (!message.end.equals(Long.ZERO)) {
      obj.end = (message.end || Long.ZERO).toString();
    }
    if (!message.completeLength.equals(Long.ZERO)) {
      obj.completeLength = (message.completeLength || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ContentRange>): ContentRange {
    return ContentRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContentRange>): ContentRange {
    const message = createBaseContentRange();
    message.start = (object.start !== undefined && object.start !== null) ? Long.fromValue(object.start) : Long.ZERO;
    message.end = (object.end !== undefined && object.end !== null) ? Long.fromValue(object.end) : Long.ZERO;
    message.completeLength = (object.completeLength !== undefined && object.completeLength !== null)
      ? Long.fromValue(object.completeLength)
      : Long.ZERO;
    return message;
  },
};

function createBaseHmacKeyMetadata(): HmacKeyMetadata {
  return {
    id: "",
    accessId: "",
    projectId: "",
    serviceAccountEmail: "",
    state: "",
    timeCreated: undefined,
    updated: undefined,
    etag: "",
  };
}

export const HmacKeyMetadata: MessageFns<HmacKeyMetadata> = {
  encode(message: HmacKeyMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.accessId !== "") {
      writer.uint32(18).string(message.accessId);
    }
    if (message.projectId !== "") {
      writer.uint32(26).string(message.projectId);
    }
    if (message.serviceAccountEmail !== "") {
      writer.uint32(34).string(message.serviceAccountEmail);
    }
    if (message.state !== "") {
      writer.uint32(42).string(message.state);
    }
    if (message.timeCreated !== undefined) {
      Timestamp.encode(toTimestamp(message.timeCreated), writer.uint32(50).fork()).join();
    }
    if (message.updated !== undefined) {
      Timestamp.encode(toTimestamp(message.updated), writer.uint32(58).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(66).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HmacKeyMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHmacKeyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serviceAccountEmail = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.state = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timeCreated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HmacKeyMetadata {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      accessId: isSet(object.accessId) ? globalThis.String(object.accessId) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      serviceAccountEmail: isSet(object.serviceAccountEmail) ? globalThis.String(object.serviceAccountEmail) : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      timeCreated: isSet(object.timeCreated) ? fromJsonTimestamp(object.timeCreated) : undefined,
      updated: isSet(object.updated) ? fromJsonTimestamp(object.updated) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: HmacKeyMetadata): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.accessId !== "") {
      obj.accessId = message.accessId;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.serviceAccountEmail !== "") {
      obj.serviceAccountEmail = message.serviceAccountEmail;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.timeCreated !== undefined) {
      obj.timeCreated = message.timeCreated.toISOString();
    }
    if (message.updated !== undefined) {
      obj.updated = message.updated.toISOString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<HmacKeyMetadata>): HmacKeyMetadata {
    return HmacKeyMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HmacKeyMetadata>): HmacKeyMetadata {
    const message = createBaseHmacKeyMetadata();
    message.id = object.id ?? "";
    message.accessId = object.accessId ?? "";
    message.projectId = object.projectId ?? "";
    message.serviceAccountEmail = object.serviceAccountEmail ?? "";
    message.state = object.state ?? "";
    message.timeCreated = object.timeCreated ?? undefined;
    message.updated = object.updated ?? undefined;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseNotification(): Notification {
  return { topic: "", eventTypes: [], customAttributes: {}, etag: "", objectNamePrefix: "", payloadFormat: "", id: "" };
}

export const Notification: MessageFns<Notification> = {
  encode(message: Notification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    for (const v of message.eventTypes) {
      writer.uint32(18).string(v!);
    }
    Object.entries(message.customAttributes).forEach(([key, value]) => {
      Notification_CustomAttributesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(34).string(message.etag);
    }
    if (message.objectNamePrefix !== "") {
      writer.uint32(42).string(message.objectNamePrefix);
    }
    if (message.payloadFormat !== "") {
      writer.uint32(50).string(message.payloadFormat);
    }
    if (message.id !== "") {
      writer.uint32(58).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventTypes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Notification_CustomAttributesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.customAttributes[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.objectNamePrefix = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.payloadFormat = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notification {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      eventTypes: globalThis.Array.isArray(object?.eventTypes)
        ? object.eventTypes.map((e: any) => globalThis.String(e))
        : [],
      customAttributes: isObject(object.customAttributes)
        ? Object.entries(object.customAttributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      objectNamePrefix: isSet(object.objectNamePrefix) ? globalThis.String(object.objectNamePrefix) : "",
      payloadFormat: isSet(object.payloadFormat) ? globalThis.String(object.payloadFormat) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: Notification): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.eventTypes?.length) {
      obj.eventTypes = message.eventTypes;
    }
    if (message.customAttributes) {
      const entries = Object.entries(message.customAttributes);
      if (entries.length > 0) {
        obj.customAttributes = {};
        entries.forEach(([k, v]) => {
          obj.customAttributes[k] = v;
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.objectNamePrefix !== "") {
      obj.objectNamePrefix = message.objectNamePrefix;
    }
    if (message.payloadFormat !== "") {
      obj.payloadFormat = message.payloadFormat;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<Notification>): Notification {
    return Notification.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Notification>): Notification {
    const message = createBaseNotification();
    message.topic = object.topic ?? "";
    message.eventTypes = object.eventTypes?.map((e) => e) || [];
    message.customAttributes = Object.entries(object.customAttributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.etag = object.etag ?? "";
    message.objectNamePrefix = object.objectNamePrefix ?? "";
    message.payloadFormat = object.payloadFormat ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseNotification_CustomAttributesEntry(): Notification_CustomAttributesEntry {
  return { key: "", value: "" };
}

export const Notification_CustomAttributesEntry: MessageFns<Notification_CustomAttributesEntry> = {
  encode(message: Notification_CustomAttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notification_CustomAttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotification_CustomAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notification_CustomAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Notification_CustomAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Notification_CustomAttributesEntry>): Notification_CustomAttributesEntry {
    return Notification_CustomAttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Notification_CustomAttributesEntry>): Notification_CustomAttributesEntry {
    const message = createBaseNotification_CustomAttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListNotificationsResponse(): ListNotificationsResponse {
  return { items: [] };
}

export const ListNotificationsResponse: MessageFns<ListNotificationsResponse> = {
  encode(message: ListNotificationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Notification.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNotificationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNotificationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(Notification.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNotificationsResponse {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Notification.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListNotificationsResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Notification.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListNotificationsResponse>): ListNotificationsResponse {
    return ListNotificationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNotificationsResponse>): ListNotificationsResponse {
    const message = createBaseListNotificationsResponse();
    message.items = object.items?.map((e) => Notification.fromPartial(e)) || [];
    return message;
  },
};

function createBaseObject(): Object {
  return {
    contentEncoding: "",
    contentDisposition: "",
    cacheControl: "",
    acl: [],
    contentLanguage: "",
    metageneration: Long.ZERO,
    timeDeleted: undefined,
    contentType: "",
    size: Long.ZERO,
    timeCreated: undefined,
    crc32c: undefined,
    componentCount: 0,
    md5Hash: "",
    etag: "",
    updated: undefined,
    storageClass: "",
    kmsKeyName: "",
    timeStorageClassUpdated: undefined,
    temporaryHold: false,
    retentionExpirationTime: undefined,
    metadata: {},
    eventBasedHold: undefined,
    name: "",
    id: "",
    bucket: "",
    generation: Long.ZERO,
    owner: undefined,
    customerEncryption: undefined,
    customTime: undefined,
  };
}

export const Object: MessageFns<Object> = {
  encode(message: Object, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentEncoding !== "") {
      writer.uint32(10).string(message.contentEncoding);
    }
    if (message.contentDisposition !== "") {
      writer.uint32(18).string(message.contentDisposition);
    }
    if (message.cacheControl !== "") {
      writer.uint32(26).string(message.cacheControl);
    }
    for (const v of message.acl) {
      ObjectAccessControl.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.contentLanguage !== "") {
      writer.uint32(42).string(message.contentLanguage);
    }
    if (!message.metageneration.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.metageneration.toString());
    }
    if (message.timeDeleted !== undefined) {
      Timestamp.encode(toTimestamp(message.timeDeleted), writer.uint32(58).fork()).join();
    }
    if (message.contentType !== "") {
      writer.uint32(66).string(message.contentType);
    }
    if (!message.size.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.size.toString());
    }
    if (message.timeCreated !== undefined) {
      Timestamp.encode(toTimestamp(message.timeCreated), writer.uint32(82).fork()).join();
    }
    if (message.crc32c !== undefined) {
      UInt32Value.encode({ value: message.crc32c! }, writer.uint32(90).fork()).join();
    }
    if (message.componentCount !== 0) {
      writer.uint32(96).int32(message.componentCount);
    }
    if (message.md5Hash !== "") {
      writer.uint32(106).string(message.md5Hash);
    }
    if (message.etag !== "") {
      writer.uint32(114).string(message.etag);
    }
    if (message.updated !== undefined) {
      Timestamp.encode(toTimestamp(message.updated), writer.uint32(122).fork()).join();
    }
    if (message.storageClass !== "") {
      writer.uint32(130).string(message.storageClass);
    }
    if (message.kmsKeyName !== "") {
      writer.uint32(138).string(message.kmsKeyName);
    }
    if (message.timeStorageClassUpdated !== undefined) {
      Timestamp.encode(toTimestamp(message.timeStorageClassUpdated), writer.uint32(146).fork()).join();
    }
    if (message.temporaryHold !== false) {
      writer.uint32(152).bool(message.temporaryHold);
    }
    if (message.retentionExpirationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.retentionExpirationTime), writer.uint32(162).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Object_MetadataEntry.encode({ key: key as any, value }, writer.uint32(170).fork()).join();
    });
    if (message.eventBasedHold !== undefined) {
      BoolValue.encode({ value: message.eventBasedHold! }, writer.uint32(234).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(186).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(194).string(message.id);
    }
    if (message.bucket !== "") {
      writer.uint32(202).string(message.bucket);
    }
    if (!message.generation.equals(Long.ZERO)) {
      writer.uint32(208).int64(message.generation.toString());
    }
    if (message.owner !== undefined) {
      Owner.encode(message.owner, writer.uint32(218).fork()).join();
    }
    if (message.customerEncryption !== undefined) {
      Object_CustomerEncryption.encode(message.customerEncryption, writer.uint32(226).fork()).join();
    }
    if (message.customTime !== undefined) {
      Timestamp.encode(toTimestamp(message.customTime), writer.uint32(242).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Object {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contentEncoding = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contentDisposition = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cacheControl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.acl.push(ObjectAccessControl.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.contentLanguage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.metageneration = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.timeDeleted = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.size = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.timeCreated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.crc32c = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.componentCount = reader.int32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.md5Hash = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.storageClass = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.timeStorageClassUpdated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.temporaryHold = reader.bool();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.retentionExpirationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          const entry21 = Object_MetadataEntry.decode(reader, reader.uint32());
          if (entry21.value !== undefined) {
            message.metadata[entry21.key] = entry21.value;
          }
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.eventBasedHold = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.name = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.id = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.bucket = reader.string();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.generation = Long.fromString(reader.int64().toString());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.owner = Owner.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.customerEncryption = Object_CustomerEncryption.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.customTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Object {
    return {
      contentEncoding: isSet(object.contentEncoding) ? globalThis.String(object.contentEncoding) : "",
      contentDisposition: isSet(object.contentDisposition) ? globalThis.String(object.contentDisposition) : "",
      cacheControl: isSet(object.cacheControl) ? globalThis.String(object.cacheControl) : "",
      acl: globalThis.Array.isArray(object?.acl) ? object.acl.map((e: any) => ObjectAccessControl.fromJSON(e)) : [],
      contentLanguage: isSet(object.contentLanguage) ? globalThis.String(object.contentLanguage) : "",
      metageneration: isSet(object.metageneration) ? Long.fromValue(object.metageneration) : Long.ZERO,
      timeDeleted: isSet(object.timeDeleted) ? fromJsonTimestamp(object.timeDeleted) : undefined,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      size: isSet(object.size) ? Long.fromValue(object.size) : Long.ZERO,
      timeCreated: isSet(object.timeCreated) ? fromJsonTimestamp(object.timeCreated) : undefined,
      crc32c: isSet(object.crc32c) ? Number(object.crc32c) : undefined,
      componentCount: isSet(object.componentCount) ? globalThis.Number(object.componentCount) : 0,
      md5Hash: isSet(object.md5Hash) ? globalThis.String(object.md5Hash) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      updated: isSet(object.updated) ? fromJsonTimestamp(object.updated) : undefined,
      storageClass: isSet(object.storageClass) ? globalThis.String(object.storageClass) : "",
      kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : "",
      timeStorageClassUpdated: isSet(object.timeStorageClassUpdated)
        ? fromJsonTimestamp(object.timeStorageClassUpdated)
        : undefined,
      temporaryHold: isSet(object.temporaryHold) ? globalThis.Boolean(object.temporaryHold) : false,
      retentionExpirationTime: isSet(object.retentionExpirationTime)
        ? fromJsonTimestamp(object.retentionExpirationTime)
        : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      eventBasedHold: isSet(object.eventBasedHold) ? Boolean(object.eventBasedHold) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      generation: isSet(object.generation) ? Long.fromValue(object.generation) : Long.ZERO,
      owner: isSet(object.owner) ? Owner.fromJSON(object.owner) : undefined,
      customerEncryption: isSet(object.customerEncryption)
        ? Object_CustomerEncryption.fromJSON(object.customerEncryption)
        : undefined,
      customTime: isSet(object.customTime) ? fromJsonTimestamp(object.customTime) : undefined,
    };
  },

  toJSON(message: Object): unknown {
    const obj: any = {};
    if (message.contentEncoding !== "") {
      obj.contentEncoding = message.contentEncoding;
    }
    if (message.contentDisposition !== "") {
      obj.contentDisposition = message.contentDisposition;
    }
    if (message.cacheControl !== "") {
      obj.cacheControl = message.cacheControl;
    }
    if (message.acl?.length) {
      obj.acl = message.acl.map((e) => ObjectAccessControl.toJSON(e));
    }
    if (message.contentLanguage !== "") {
      obj.contentLanguage = message.contentLanguage;
    }
    if (!message.metageneration.equals(Long.ZERO)) {
      obj.metageneration = (message.metageneration || Long.ZERO).toString();
    }
    if (message.timeDeleted !== undefined) {
      obj.timeDeleted = message.timeDeleted.toISOString();
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (!message.size.equals(Long.ZERO)) {
      obj.size = (message.size || Long.ZERO).toString();
    }
    if (message.timeCreated !== undefined) {
      obj.timeCreated = message.timeCreated.toISOString();
    }
    if (message.crc32c !== undefined) {
      obj.crc32c = message.crc32c;
    }
    if (message.componentCount !== 0) {
      obj.componentCount = Math.round(message.componentCount);
    }
    if (message.md5Hash !== "") {
      obj.md5Hash = message.md5Hash;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.updated !== undefined) {
      obj.updated = message.updated.toISOString();
    }
    if (message.storageClass !== "") {
      obj.storageClass = message.storageClass;
    }
    if (message.kmsKeyName !== "") {
      obj.kmsKeyName = message.kmsKeyName;
    }
    if (message.timeStorageClassUpdated !== undefined) {
      obj.timeStorageClassUpdated = message.timeStorageClassUpdated.toISOString();
    }
    if (message.temporaryHold !== false) {
      obj.temporaryHold = message.temporaryHold;
    }
    if (message.retentionExpirationTime !== undefined) {
      obj.retentionExpirationTime = message.retentionExpirationTime.toISOString();
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.eventBasedHold !== undefined) {
      obj.eventBasedHold = message.eventBasedHold;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (!message.generation.equals(Long.ZERO)) {
      obj.generation = (message.generation || Long.ZERO).toString();
    }
    if (message.owner !== undefined) {
      obj.owner = Owner.toJSON(message.owner);
    }
    if (message.customerEncryption !== undefined) {
      obj.customerEncryption = Object_CustomerEncryption.toJSON(message.customerEncryption);
    }
    if (message.customTime !== undefined) {
      obj.customTime = message.customTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Object>): Object {
    return Object.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Object>): Object {
    const message = createBaseObject();
    message.contentEncoding = object.contentEncoding ?? "";
    message.contentDisposition = object.contentDisposition ?? "";
    message.cacheControl = object.cacheControl ?? "";
    message.acl = object.acl?.map((e) => ObjectAccessControl.fromPartial(e)) || [];
    message.contentLanguage = object.contentLanguage ?? "";
    message.metageneration = (object.metageneration !== undefined && object.metageneration !== null)
      ? Long.fromValue(object.metageneration)
      : Long.ZERO;
    message.timeDeleted = object.timeDeleted ?? undefined;
    message.contentType = object.contentType ?? "";
    message.size = (object.size !== undefined && object.size !== null) ? Long.fromValue(object.size) : Long.ZERO;
    message.timeCreated = object.timeCreated ?? undefined;
    message.crc32c = object.crc32c ?? undefined;
    message.componentCount = object.componentCount ?? 0;
    message.md5Hash = object.md5Hash ?? "";
    message.etag = object.etag ?? "";
    message.updated = object.updated ?? undefined;
    message.storageClass = object.storageClass ?? "";
    message.kmsKeyName = object.kmsKeyName ?? "";
    message.timeStorageClassUpdated = object.timeStorageClassUpdated ?? undefined;
    message.temporaryHold = object.temporaryHold ?? false;
    message.retentionExpirationTime = object.retentionExpirationTime ?? undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.eventBasedHold = object.eventBasedHold ?? undefined;
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.bucket = object.bucket ?? "";
    message.generation = (object.generation !== undefined && object.generation !== null)
      ? Long.fromValue(object.generation)
      : Long.ZERO;
    message.owner = (object.owner !== undefined && object.owner !== null) ? Owner.fromPartial(object.owner) : undefined;
    message.customerEncryption = (object.customerEncryption !== undefined && object.customerEncryption !== null)
      ? Object_CustomerEncryption.fromPartial(object.customerEncryption)
      : undefined;
    message.customTime = object.customTime ?? undefined;
    return message;
  },
};

function createBaseObject_CustomerEncryption(): Object_CustomerEncryption {
  return { encryptionAlgorithm: "", keySha256: "" };
}

export const Object_CustomerEncryption: MessageFns<Object_CustomerEncryption> = {
  encode(message: Object_CustomerEncryption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.encryptionAlgorithm !== "") {
      writer.uint32(10).string(message.encryptionAlgorithm);
    }
    if (message.keySha256 !== "") {
      writer.uint32(18).string(message.keySha256);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Object_CustomerEncryption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObject_CustomerEncryption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.encryptionAlgorithm = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keySha256 = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Object_CustomerEncryption {
    return {
      encryptionAlgorithm: isSet(object.encryptionAlgorithm) ? globalThis.String(object.encryptionAlgorithm) : "",
      keySha256: isSet(object.keySha256) ? globalThis.String(object.keySha256) : "",
    };
  },

  toJSON(message: Object_CustomerEncryption): unknown {
    const obj: any = {};
    if (message.encryptionAlgorithm !== "") {
      obj.encryptionAlgorithm = message.encryptionAlgorithm;
    }
    if (message.keySha256 !== "") {
      obj.keySha256 = message.keySha256;
    }
    return obj;
  },

  create(base?: DeepPartial<Object_CustomerEncryption>): Object_CustomerEncryption {
    return Object_CustomerEncryption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Object_CustomerEncryption>): Object_CustomerEncryption {
    const message = createBaseObject_CustomerEncryption();
    message.encryptionAlgorithm = object.encryptionAlgorithm ?? "";
    message.keySha256 = object.keySha256 ?? "";
    return message;
  },
};

function createBaseObject_MetadataEntry(): Object_MetadataEntry {
  return { key: "", value: "" };
}

export const Object_MetadataEntry: MessageFns<Object_MetadataEntry> = {
  encode(message: Object_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Object_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObject_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Object_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Object_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Object_MetadataEntry>): Object_MetadataEntry {
    return Object_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Object_MetadataEntry>): Object_MetadataEntry {
    const message = createBaseObject_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseObjectAccessControl(): ObjectAccessControl {
  return {
    role: "",
    etag: "",
    id: "",
    bucket: "",
    object: "",
    generation: Long.ZERO,
    entity: "",
    entityId: "",
    email: "",
    domain: "",
    projectTeam: undefined,
  };
}

export const ObjectAccessControl: MessageFns<ObjectAccessControl> = {
  encode(message: ObjectAccessControl, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.bucket !== "") {
      writer.uint32(34).string(message.bucket);
    }
    if (message.object !== "") {
      writer.uint32(42).string(message.object);
    }
    if (!message.generation.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.generation.toString());
    }
    if (message.entity !== "") {
      writer.uint32(58).string(message.entity);
    }
    if (message.entityId !== "") {
      writer.uint32(66).string(message.entityId);
    }
    if (message.email !== "") {
      writer.uint32(74).string(message.email);
    }
    if (message.domain !== "") {
      writer.uint32(82).string(message.domain);
    }
    if (message.projectTeam !== undefined) {
      ProjectTeam.encode(message.projectTeam, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectAccessControl {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectAccessControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.bucket = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.object = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.generation = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.entity = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.entityId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.email = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.projectTeam = ProjectTeam.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectAccessControl {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      object: isSet(object.object) ? globalThis.String(object.object) : "",
      generation: isSet(object.generation) ? Long.fromValue(object.generation) : Long.ZERO,
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      projectTeam: isSet(object.projectTeam) ? ProjectTeam.fromJSON(object.projectTeam) : undefined,
    };
  },

  toJSON(message: ObjectAccessControl): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.object !== "") {
      obj.object = message.object;
    }
    if (!message.generation.equals(Long.ZERO)) {
      obj.generation = (message.generation || Long.ZERO).toString();
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.projectTeam !== undefined) {
      obj.projectTeam = ProjectTeam.toJSON(message.projectTeam);
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectAccessControl>): ObjectAccessControl {
    return ObjectAccessControl.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectAccessControl>): ObjectAccessControl {
    const message = createBaseObjectAccessControl();
    message.role = object.role ?? "";
    message.etag = object.etag ?? "";
    message.id = object.id ?? "";
    message.bucket = object.bucket ?? "";
    message.object = object.object ?? "";
    message.generation = (object.generation !== undefined && object.generation !== null)
      ? Long.fromValue(object.generation)
      : Long.ZERO;
    message.entity = object.entity ?? "";
    message.entityId = object.entityId ?? "";
    message.email = object.email ?? "";
    message.domain = object.domain ?? "";
    message.projectTeam = (object.projectTeam !== undefined && object.projectTeam !== null)
      ? ProjectTeam.fromPartial(object.projectTeam)
      : undefined;
    return message;
  },
};

function createBaseListObjectAccessControlsResponse(): ListObjectAccessControlsResponse {
  return { items: [] };
}

export const ListObjectAccessControlsResponse: MessageFns<ListObjectAccessControlsResponse> = {
  encode(message: ListObjectAccessControlsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      ObjectAccessControl.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListObjectAccessControlsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListObjectAccessControlsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(ObjectAccessControl.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListObjectAccessControlsResponse {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => ObjectAccessControl.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListObjectAccessControlsResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => ObjectAccessControl.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListObjectAccessControlsResponse>): ListObjectAccessControlsResponse {
    return ListObjectAccessControlsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListObjectAccessControlsResponse>): ListObjectAccessControlsResponse {
    const message = createBaseListObjectAccessControlsResponse();
    message.items = object.items?.map((e) => ObjectAccessControl.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListObjectsResponse(): ListObjectsResponse {
  return { prefixes: [], items: [], nextPageToken: "" };
}

export const ListObjectsResponse: MessageFns<ListObjectsResponse> = {
  encode(message: ListObjectsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.prefixes) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.items) {
      Object.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListObjectsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListObjectsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prefixes.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.items.push(Object.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListObjectsResponse {
    return {
      prefixes: globalThis.Array.isArray(object?.prefixes) ? object.prefixes.map((e: any) => globalThis.String(e)) : [],
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Object.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListObjectsResponse): unknown {
    const obj: any = {};
    if (message.prefixes?.length) {
      obj.prefixes = message.prefixes;
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Object.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListObjectsResponse>): ListObjectsResponse {
    return ListObjectsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListObjectsResponse>): ListObjectsResponse {
    const message = createBaseListObjectsResponse();
    message.prefixes = object.prefixes?.map((e) => e) || [];
    message.items = object.items?.map((e) => Object.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseProjectTeam(): ProjectTeam {
  return { projectNumber: "", team: "" };
}

export const ProjectTeam: MessageFns<ProjectTeam> = {
  encode(message: ProjectTeam, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectNumber !== "") {
      writer.uint32(10).string(message.projectNumber);
    }
    if (message.team !== "") {
      writer.uint32(18).string(message.team);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProjectTeam {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProjectTeam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectNumber = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.team = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProjectTeam {
    return {
      projectNumber: isSet(object.projectNumber) ? globalThis.String(object.projectNumber) : "",
      team: isSet(object.team) ? globalThis.String(object.team) : "",
    };
  },

  toJSON(message: ProjectTeam): unknown {
    const obj: any = {};
    if (message.projectNumber !== "") {
      obj.projectNumber = message.projectNumber;
    }
    if (message.team !== "") {
      obj.team = message.team;
    }
    return obj;
  },

  create(base?: DeepPartial<ProjectTeam>): ProjectTeam {
    return ProjectTeam.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProjectTeam>): ProjectTeam {
    const message = createBaseProjectTeam();
    message.projectNumber = object.projectNumber ?? "";
    message.team = object.team ?? "";
    return message;
  },
};

function createBaseServiceAccount(): ServiceAccount {
  return { emailAddress: "" };
}

export const ServiceAccount: MessageFns<ServiceAccount> = {
  encode(message: ServiceAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.emailAddress !== "") {
      writer.uint32(10).string(message.emailAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.emailAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccount {
    return { emailAddress: isSet(object.emailAddress) ? globalThis.String(object.emailAddress) : "" };
  },

  toJSON(message: ServiceAccount): unknown {
    const obj: any = {};
    if (message.emailAddress !== "") {
      obj.emailAddress = message.emailAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceAccount>): ServiceAccount {
    return ServiceAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceAccount>): ServiceAccount {
    const message = createBaseServiceAccount();
    message.emailAddress = object.emailAddress ?? "";
    return message;
  },
};

function createBaseOwner(): Owner {
  return { entity: "", entityId: "" };
}

export const Owner: MessageFns<Owner> = {
  encode(message: Owner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entity !== "") {
      writer.uint32(10).string(message.entity);
    }
    if (message.entityId !== "") {
      writer.uint32(18).string(message.entityId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Owner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entity = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entityId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Owner {
    return {
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
    };
  },

  toJSON(message: Owner): unknown {
    const obj: any = {};
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    return obj;
  },

  create(base?: DeepPartial<Owner>): Owner {
    return Owner.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Owner>): Owner {
    const message = createBaseOwner();
    message.entity = object.entity ?? "";
    message.entityId = object.entityId ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
