// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/storage/control/v2/storage_control.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Empty } from "../../../protobuf/empty.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.storage.control.v2";

/** Contains information about a pending rename operation. */
export interface PendingRenameInfo {
  /** Output only. The name of the rename operation. */
  operation: string;
}

/**
 * A folder resource. This resource can only exist in a hierarchical namespace
 * enabled bucket.
 */
export interface Folder {
  /**
   * Identifier. The name of this folder.
   * Format: `projects/{project}/buckets/{bucket}/folders/{folder}`
   */
  name: string;
  /**
   * Output only. The version of the metadata for this folder. Used for
   * preconditions and for detecting changes in metadata.
   */
  metageneration: Long;
  /** Output only. The creation time of the folder. */
  createTime:
    | Date
    | undefined;
  /** Output only. The modification time of the folder. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Only present if the folder is part of an ongoing RenameFolder
   * operation. Contains information which can be used to query the operation
   * status. The presence of this field also indicates all write operations are
   * blocked for this folder, including folder, managed folder, and object
   * operations.
   */
  pendingRenameInfo: PendingRenameInfo | undefined;
}

/**
 * Request message for GetFolder. This operation is only applicable to a
 * hierarchical namespace enabled bucket.
 */
export interface GetFolderRequest {
  /**
   * Required. Name of the folder.
   * Format: `projects/{project}/buckets/{bucket}/folders/{folder}`
   */
  name: string;
  /**
   * Makes the operation only succeed conditional on whether the folder's
   * current metageneration matches the given value.
   */
  ifMetagenerationMatch?:
    | Long
    | undefined;
  /**
   * Makes the operation only succeed conditional on whether the folder's
   * current metageneration does not match the given value.
   */
  ifMetagenerationNotMatch?:
    | Long
    | undefined;
  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   */
  requestId: string;
}

/**
 * Request message for CreateFolder. This operation is only applicable to a
 * hierarchical namespace enabled bucket.
 */
export interface CreateFolderRequest {
  /**
   * Required. Name of the bucket in which the folder will reside. The bucket
   * must be a hierarchical namespace enabled bucket.
   */
  parent: string;
  /**
   * Required. Properties of the new folder being created.
   * The bucket and name of the folder are specified in the parent and folder_id
   * fields, respectively. Populating those fields in `folder` will result in an
   * error.
   */
  folder:
    | Folder
    | undefined;
  /**
   * Required. The full name of a folder, including all its parent folders.
   * Folders use single '/' characters as a delimiter.
   * The folder_id must end with a slash.
   * For example, the folder_id of "books/biographies/" would create a new
   * "biographies/" folder under the "books/" folder.
   */
  folderId: string;
  /**
   * Optional. If true, parent folder doesn't have to be present and all missing
   * ancestor folders will be created atomically.
   */
  recursive: boolean;
  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   */
  requestId: string;
}

/**
 * Request message for DeleteFolder. This operation is only applicable to a
 * hierarchical namespace enabled bucket.
 */
export interface DeleteFolderRequest {
  /**
   * Required. Name of the folder.
   * Format: `projects/{project}/buckets/{bucket}/folders/{folder}`
   */
  name: string;
  /**
   * Makes the operation only succeed conditional on whether the folder's
   * current metageneration matches the given value.
   */
  ifMetagenerationMatch?:
    | Long
    | undefined;
  /**
   * Makes the operation only succeed conditional on whether the folder's
   * current metageneration does not match the given value.
   */
  ifMetagenerationNotMatch?:
    | Long
    | undefined;
  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   */
  requestId: string;
}

/**
 * Request message for ListFolders. This operation is only applicable to a
 * hierarchical namespace enabled bucket.
 */
export interface ListFoldersRequest {
  /**
   * Required. Name of the bucket in which to look for folders. The bucket must
   * be a hierarchical namespace enabled bucket.
   */
  parent: string;
  /**
   * Optional. Maximum number of folders to return in a single response. The
   * service will use this parameter or 1,000 items, whichever is smaller.
   */
  pageSize: number;
  /**
   * Optional. A previously-returned page token representing part of the larger
   * set of results to view.
   */
  pageToken: string;
  /**
   * Optional. Filter results to folders whose names begin with this prefix.
   * If set, the value must either be an empty string or end with a '/'.
   */
  prefix: string;
  /**
   * Optional. If set, returns results in a directory-like mode. The results
   * will only include folders that either exactly match the above prefix, or
   * are one level below the prefix. The only supported value is '/'.
   */
  delimiter: string;
  /**
   * Optional. Filter results to folders whose names are lexicographically equal
   * to or after lexicographic_start. If lexicographic_end is also set, the
   * folders listed have names between lexicographic_start (inclusive) and
   * lexicographic_end (exclusive).
   */
  lexicographicStart: string;
  /**
   * Optional. Filter results to folders whose names are lexicographically
   * before lexicographic_end. If lexicographic_start is also set, the folders
   * listed have names between lexicographic_start (inclusive) and
   * lexicographic_end (exclusive).
   */
  lexicographicEnd: string;
  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   */
  requestId: string;
}

/** Response message for ListFolders. */
export interface ListFoldersResponse {
  /** The list of child folders */
  folders: Folder[];
  /**
   * The continuation token, used to page through large result sets. Provide
   * this value in a subsequent request to return the next page of results.
   */
  nextPageToken: string;
}

/**
 * Request message for RenameFolder. This operation is only applicable to a
 * hierarchical namespace enabled bucket.
 */
export interface RenameFolderRequest {
  /**
   * Required. Name of the source folder being renamed.
   * Format: `projects/{project}/buckets/{bucket}/folders/{folder}`
   */
  name: string;
  /** Required. The destination folder ID, e.g. `foo/bar/`. */
  destinationFolderId: string;
  /**
   * Makes the operation only succeed conditional on whether the source
   * folder's current metageneration matches the given value.
   */
  ifMetagenerationMatch?:
    | Long
    | undefined;
  /**
   * Makes the operation only succeed conditional on whether the source
   * folder's current metageneration does not match the given value.
   */
  ifMetagenerationNotMatch?:
    | Long
    | undefined;
  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted. This request is only
   * idempotent if a `request_id` is provided.
   */
  requestId: string;
}

/**
 * The message contains metadata that is common to all Storage Control
 * long-running operations, present in its `google.longrunning.Operation`
 * messages, and accessible via `metadata.common_metadata`.
 */
export interface CommonLongRunningOperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. The time the operation was last modified. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The type of operation invoked. */
  type: string;
  /** Output only. Identifies whether the user has requested cancellation. */
  requestedCancellation: boolean;
  /**
   * Output only. The estimated progress of the operation in percentage [0,
   * 100]. The value -1 means the progress is unknown.
   */
  progressPercent: number;
}

/**
 * Message returned in the metadata field of the Operation resource for
 * RenameFolder operations.
 */
export interface RenameFolderMetadata {
  /** Generic metadata for the long running operation. */
  commonMetadata:
    | CommonLongRunningOperationMetadata
    | undefined;
  /** The path of the source folder. */
  sourceFolderId: string;
  /** The path of the destination folder. */
  destinationFolderId: string;
}

/** The storage layout configuration of a bucket. */
export interface StorageLayout {
  /**
   * Output only. The name of the StorageLayout resource.
   * Format: `projects/{project}/buckets/{bucket}/storageLayout`
   */
  name: string;
  /** Output only. The location of the bucket. */
  location: string;
  /**
   * Output only. The location type of the bucket (region, dual-region,
   * multi-region, etc).
   */
  locationType: string;
  /**
   * Output only. The data placement configuration for custom dual region. If
   * there is no configuration, this is not a custom dual region bucket.
   */
  customPlacementConfig:
    | StorageLayout_CustomPlacementConfig
    | undefined;
  /**
   * Output only. The bucket's hierarchical namespace configuration. If there is
   * no configuration, the hierarchical namespace is disabled.
   */
  hierarchicalNamespace: StorageLayout_HierarchicalNamespace | undefined;
}

/**
 * Configuration for Custom Dual Regions.  It should specify precisely two
 * eligible regions within the same Multiregion. More information on regions
 * may be found [https://cloud.google.com/storage/docs/locations][here].
 */
export interface StorageLayout_CustomPlacementConfig {
  /** List of locations to use for data placement. */
  dataLocations: string[];
}

/** Configuration for a bucket's hierarchical namespace feature. */
export interface StorageLayout_HierarchicalNamespace {
  /** Enables the hierarchical namespace feature. */
  enabled: boolean;
}

/** Request message for GetStorageLayout. */
export interface GetStorageLayoutRequest {
  /**
   * Required. The name of the StorageLayout resource.
   * Format: `projects/{project}/buckets/{bucket}/storageLayout`
   */
  name: string;
  /**
   * An optional prefix used for permission check. It is useful when the caller
   * only has limited permissions under a specific prefix.
   */
  prefix: string;
  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   */
  requestId: string;
}

/** A managed folder. */
export interface ManagedFolder {
  /**
   * Identifier. The name of this managed folder.
   * Format:
   * `projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}`
   */
  name: string;
  /**
   * Output only. The metadata version of this managed folder. It increases
   * whenever the metadata is updated. Used for preconditions and for detecting
   * changes in metadata. Managed folders don't have a generation number.
   */
  metageneration: Long;
  /** Output only. The creation time of the managed folder. */
  createTime:
    | Date
    | undefined;
  /** Output only. The modification time of the managed folder. */
  updateTime: Date | undefined;
}

/** Request message for GetManagedFolder. */
export interface GetManagedFolderRequest {
  /**
   * Required. Name of the managed folder.
   * Format:
   * `projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}`
   */
  name: string;
  /**
   * The operation succeeds conditional on the managed folder's current
   * metageneration matching the value here specified.
   */
  ifMetagenerationMatch?:
    | Long
    | undefined;
  /**
   * The operation succeeds conditional on the managed folder's current
   * metageneration NOT matching the value here specified.
   */
  ifMetagenerationNotMatch?:
    | Long
    | undefined;
  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   */
  requestId: string;
}

/** Request message for CreateManagedFolder. */
export interface CreateManagedFolderRequest {
  /** Required. Name of the bucket this managed folder belongs to. */
  parent: string;
  /**
   * Required. Properties of the managed folder being created.
   * The bucket and managed folder names are specified in the `parent` and
   * `managed_folder_id` fields. Populating these fields in `managed_folder`
   * will result in an error.
   */
  managedFolder:
    | ManagedFolder
    | undefined;
  /**
   * Required. The name of the managed folder. It uses a single `/` as delimiter
   * and leading and trailing `/` are allowed.
   */
  managedFolderId: string;
  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   */
  requestId: string;
}

/** DeleteManagedFolder RPC request message. */
export interface DeleteManagedFolderRequest {
  /**
   * Required. Name of the managed folder.
   * Format:
   * `projects/{project}/buckets/{bucket}/managedFolders/{managedFolder}`
   */
  name: string;
  /**
   * The operation succeeds conditional on the managed folder's current
   * metageneration matching the value here specified.
   */
  ifMetagenerationMatch?:
    | Long
    | undefined;
  /**
   * The operation succeeds conditional on the managed folder's current
   * metageneration NOT matching the value here specified.
   */
  ifMetagenerationNotMatch?:
    | Long
    | undefined;
  /**
   * Allows deletion of a managed folder even if it is not empty.
   * A managed folder is empty if it manages no child managed folders or
   * objects. Caller must have permission for
   * storage.managedFolders.setIamPolicy.
   */
  allowNonEmpty: boolean;
  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   */
  requestId: string;
}

/** Request message for ListManagedFolders. */
export interface ListManagedFoldersRequest {
  /** Required. Name of the bucket this managed folder belongs to. */
  parent: string;
  /**
   * Optional. Maximum number of managed folders to return in a single response.
   * The service will use this parameter or 1,000 items, whichever is smaller.
   */
  pageSize: number;
  /**
   * Optional. A previously-returned page token representing part of the larger
   * set of results to view.
   */
  pageToken: string;
  /**
   * Optional. Filter results to match managed folders with name starting with
   * this prefix.
   */
  prefix: string;
  /**
   * Optional. A unique identifier for this request. UUID is the recommended
   * format, but other formats are still accepted.
   */
  requestId: string;
}

/** Response message for ListManagedFolders. */
export interface ListManagedFoldersResponse {
  /** The list of matching managed folders */
  managedFolders: ManagedFolder[];
  /**
   * The continuation token, used to page through large result sets. Provide
   * this value in a subsequent request to return the next page of results.
   */
  nextPageToken: string;
}

function createBasePendingRenameInfo(): PendingRenameInfo {
  return { operation: "" };
}

export const PendingRenameInfo: MessageFns<PendingRenameInfo> = {
  encode(message: PendingRenameInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== "") {
      writer.uint32(10).string(message.operation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PendingRenameInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePendingRenameInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PendingRenameInfo {
    return { operation: isSet(object.operation) ? globalThis.String(object.operation) : "" };
  },

  toJSON(message: PendingRenameInfo): unknown {
    const obj: any = {};
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    return obj;
  },

  create(base?: DeepPartial<PendingRenameInfo>): PendingRenameInfo {
    return PendingRenameInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PendingRenameInfo>): PendingRenameInfo {
    const message = createBasePendingRenameInfo();
    message.operation = object.operation ?? "";
    return message;
  },
};

function createBaseFolder(): Folder {
  return {
    name: "",
    metageneration: Long.ZERO,
    createTime: undefined,
    updateTime: undefined,
    pendingRenameInfo: undefined,
  };
}

export const Folder: MessageFns<Folder> = {
  encode(message: Folder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.metageneration.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.metageneration.toString());
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    if (message.pendingRenameInfo !== undefined) {
      PendingRenameInfo.encode(message.pendingRenameInfo, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Folder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFolder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.metageneration = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.pendingRenameInfo = PendingRenameInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Folder {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metageneration: isSet(object.metageneration) ? Long.fromValue(object.metageneration) : Long.ZERO,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      pendingRenameInfo: isSet(object.pendingRenameInfo)
        ? PendingRenameInfo.fromJSON(object.pendingRenameInfo)
        : undefined,
    };
  },

  toJSON(message: Folder): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.metageneration.equals(Long.ZERO)) {
      obj.metageneration = (message.metageneration || Long.ZERO).toString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.pendingRenameInfo !== undefined) {
      obj.pendingRenameInfo = PendingRenameInfo.toJSON(message.pendingRenameInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<Folder>): Folder {
    return Folder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Folder>): Folder {
    const message = createBaseFolder();
    message.name = object.name ?? "";
    message.metageneration = (object.metageneration !== undefined && object.metageneration !== null)
      ? Long.fromValue(object.metageneration)
      : Long.ZERO;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.pendingRenameInfo = (object.pendingRenameInfo !== undefined && object.pendingRenameInfo !== null)
      ? PendingRenameInfo.fromPartial(object.pendingRenameInfo)
      : undefined;
    return message;
  },
};

function createBaseGetFolderRequest(): GetFolderRequest {
  return { name: "", ifMetagenerationMatch: undefined, ifMetagenerationNotMatch: undefined, requestId: "" };
}

export const GetFolderRequest: MessageFns<GetFolderRequest> = {
  encode(message: GetFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.ifMetagenerationMatch !== undefined) {
      writer.uint32(24).int64(message.ifMetagenerationMatch.toString());
    }
    if (message.ifMetagenerationNotMatch !== undefined) {
      writer.uint32(32).int64(message.ifMetagenerationNotMatch.toString());
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ifMetagenerationMatch = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ifMetagenerationNotMatch = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFolderRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ifMetagenerationMatch: isSet(object.ifMetagenerationMatch)
        ? Long.fromValue(object.ifMetagenerationMatch)
        : undefined,
      ifMetagenerationNotMatch: isSet(object.ifMetagenerationNotMatch)
        ? Long.fromValue(object.ifMetagenerationNotMatch)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: GetFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ifMetagenerationMatch !== undefined) {
      obj.ifMetagenerationMatch = (message.ifMetagenerationMatch || Long.ZERO).toString();
    }
    if (message.ifMetagenerationNotMatch !== undefined) {
      obj.ifMetagenerationNotMatch = (message.ifMetagenerationNotMatch || Long.ZERO).toString();
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetFolderRequest>): GetFolderRequest {
    return GetFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFolderRequest>): GetFolderRequest {
    const message = createBaseGetFolderRequest();
    message.name = object.name ?? "";
    message.ifMetagenerationMatch =
      (object.ifMetagenerationMatch !== undefined && object.ifMetagenerationMatch !== null)
        ? Long.fromValue(object.ifMetagenerationMatch)
        : undefined;
    message.ifMetagenerationNotMatch =
      (object.ifMetagenerationNotMatch !== undefined && object.ifMetagenerationNotMatch !== null)
        ? Long.fromValue(object.ifMetagenerationNotMatch)
        : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCreateFolderRequest(): CreateFolderRequest {
  return { parent: "", folder: undefined, folderId: "", recursive: false, requestId: "" };
}

export const CreateFolderRequest: MessageFns<CreateFolderRequest> = {
  encode(message: CreateFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.folder !== undefined) {
      Folder.encode(message.folder, writer.uint32(18).fork()).join();
    }
    if (message.folderId !== "") {
      writer.uint32(26).string(message.folderId);
    }
    if (message.recursive !== false) {
      writer.uint32(32).bool(message.recursive);
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.folder = Folder.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.folderId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.recursive = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateFolderRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      folder: isSet(object.folder) ? Folder.fromJSON(object.folder) : undefined,
      folderId: isSet(object.folderId) ? globalThis.String(object.folderId) : "",
      recursive: isSet(object.recursive) ? globalThis.Boolean(object.recursive) : false,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateFolderRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.folder !== undefined) {
      obj.folder = Folder.toJSON(message.folder);
    }
    if (message.folderId !== "") {
      obj.folderId = message.folderId;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateFolderRequest>): CreateFolderRequest {
    return CreateFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateFolderRequest>): CreateFolderRequest {
    const message = createBaseCreateFolderRequest();
    message.parent = object.parent ?? "";
    message.folder = (object.folder !== undefined && object.folder !== null)
      ? Folder.fromPartial(object.folder)
      : undefined;
    message.folderId = object.folderId ?? "";
    message.recursive = object.recursive ?? false;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteFolderRequest(): DeleteFolderRequest {
  return { name: "", ifMetagenerationMatch: undefined, ifMetagenerationNotMatch: undefined, requestId: "" };
}

export const DeleteFolderRequest: MessageFns<DeleteFolderRequest> = {
  encode(message: DeleteFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.ifMetagenerationMatch !== undefined) {
      writer.uint32(24).int64(message.ifMetagenerationMatch.toString());
    }
    if (message.ifMetagenerationNotMatch !== undefined) {
      writer.uint32(32).int64(message.ifMetagenerationNotMatch.toString());
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ifMetagenerationMatch = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ifMetagenerationNotMatch = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFolderRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ifMetagenerationMatch: isSet(object.ifMetagenerationMatch)
        ? Long.fromValue(object.ifMetagenerationMatch)
        : undefined,
      ifMetagenerationNotMatch: isSet(object.ifMetagenerationNotMatch)
        ? Long.fromValue(object.ifMetagenerationNotMatch)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ifMetagenerationMatch !== undefined) {
      obj.ifMetagenerationMatch = (message.ifMetagenerationMatch || Long.ZERO).toString();
    }
    if (message.ifMetagenerationNotMatch !== undefined) {
      obj.ifMetagenerationNotMatch = (message.ifMetagenerationNotMatch || Long.ZERO).toString();
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteFolderRequest>): DeleteFolderRequest {
    return DeleteFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteFolderRequest>): DeleteFolderRequest {
    const message = createBaseDeleteFolderRequest();
    message.name = object.name ?? "";
    message.ifMetagenerationMatch =
      (object.ifMetagenerationMatch !== undefined && object.ifMetagenerationMatch !== null)
        ? Long.fromValue(object.ifMetagenerationMatch)
        : undefined;
    message.ifMetagenerationNotMatch =
      (object.ifMetagenerationNotMatch !== undefined && object.ifMetagenerationNotMatch !== null)
        ? Long.fromValue(object.ifMetagenerationNotMatch)
        : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListFoldersRequest(): ListFoldersRequest {
  return {
    parent: "",
    pageSize: 0,
    pageToken: "",
    prefix: "",
    delimiter: "",
    lexicographicStart: "",
    lexicographicEnd: "",
    requestId: "",
  };
}

export const ListFoldersRequest: MessageFns<ListFoldersRequest> = {
  encode(message: ListFoldersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.prefix !== "") {
      writer.uint32(34).string(message.prefix);
    }
    if (message.delimiter !== "") {
      writer.uint32(66).string(message.delimiter);
    }
    if (message.lexicographicStart !== "") {
      writer.uint32(50).string(message.lexicographicStart);
    }
    if (message.lexicographicEnd !== "") {
      writer.uint32(58).string(message.lexicographicEnd);
    }
    if (message.requestId !== "") {
      writer.uint32(74).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFoldersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFoldersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.prefix = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.delimiter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lexicographicStart = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lexicographicEnd = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFoldersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
      delimiter: isSet(object.delimiter) ? globalThis.String(object.delimiter) : "",
      lexicographicStart: isSet(object.lexicographicStart) ? globalThis.String(object.lexicographicStart) : "",
      lexicographicEnd: isSet(object.lexicographicEnd) ? globalThis.String(object.lexicographicEnd) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: ListFoldersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.delimiter !== "") {
      obj.delimiter = message.delimiter;
    }
    if (message.lexicographicStart !== "") {
      obj.lexicographicStart = message.lexicographicStart;
    }
    if (message.lexicographicEnd !== "") {
      obj.lexicographicEnd = message.lexicographicEnd;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFoldersRequest>): ListFoldersRequest {
    return ListFoldersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFoldersRequest>): ListFoldersRequest {
    const message = createBaseListFoldersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.prefix = object.prefix ?? "";
    message.delimiter = object.delimiter ?? "";
    message.lexicographicStart = object.lexicographicStart ?? "";
    message.lexicographicEnd = object.lexicographicEnd ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListFoldersResponse(): ListFoldersResponse {
  return { folders: [], nextPageToken: "" };
}

export const ListFoldersResponse: MessageFns<ListFoldersResponse> = {
  encode(message: ListFoldersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.folders) {
      Folder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFoldersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFoldersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.folders.push(Folder.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFoldersResponse {
    return {
      folders: globalThis.Array.isArray(object?.folders) ? object.folders.map((e: any) => Folder.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListFoldersResponse): unknown {
    const obj: any = {};
    if (message.folders?.length) {
      obj.folders = message.folders.map((e) => Folder.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFoldersResponse>): ListFoldersResponse {
    return ListFoldersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFoldersResponse>): ListFoldersResponse {
    const message = createBaseListFoldersResponse();
    message.folders = object.folders?.map((e) => Folder.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseRenameFolderRequest(): RenameFolderRequest {
  return {
    name: "",
    destinationFolderId: "",
    ifMetagenerationMatch: undefined,
    ifMetagenerationNotMatch: undefined,
    requestId: "",
  };
}

export const RenameFolderRequest: MessageFns<RenameFolderRequest> = {
  encode(message: RenameFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    if (message.destinationFolderId !== "") {
      writer.uint32(66).string(message.destinationFolderId);
    }
    if (message.ifMetagenerationMatch !== undefined) {
      writer.uint32(32).int64(message.ifMetagenerationMatch.toString());
    }
    if (message.ifMetagenerationNotMatch !== undefined) {
      writer.uint32(40).int64(message.ifMetagenerationNotMatch.toString());
    }
    if (message.requestId !== "") {
      writer.uint32(50).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenameFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.destinationFolderId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ifMetagenerationMatch = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ifMetagenerationNotMatch = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenameFolderRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      destinationFolderId: isSet(object.destinationFolderId) ? globalThis.String(object.destinationFolderId) : "",
      ifMetagenerationMatch: isSet(object.ifMetagenerationMatch)
        ? Long.fromValue(object.ifMetagenerationMatch)
        : undefined,
      ifMetagenerationNotMatch: isSet(object.ifMetagenerationNotMatch)
        ? Long.fromValue(object.ifMetagenerationNotMatch)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: RenameFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.destinationFolderId !== "") {
      obj.destinationFolderId = message.destinationFolderId;
    }
    if (message.ifMetagenerationMatch !== undefined) {
      obj.ifMetagenerationMatch = (message.ifMetagenerationMatch || Long.ZERO).toString();
    }
    if (message.ifMetagenerationNotMatch !== undefined) {
      obj.ifMetagenerationNotMatch = (message.ifMetagenerationNotMatch || Long.ZERO).toString();
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<RenameFolderRequest>): RenameFolderRequest {
    return RenameFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenameFolderRequest>): RenameFolderRequest {
    const message = createBaseRenameFolderRequest();
    message.name = object.name ?? "";
    message.destinationFolderId = object.destinationFolderId ?? "";
    message.ifMetagenerationMatch =
      (object.ifMetagenerationMatch !== undefined && object.ifMetagenerationMatch !== null)
        ? Long.fromValue(object.ifMetagenerationMatch)
        : undefined;
    message.ifMetagenerationNotMatch =
      (object.ifMetagenerationNotMatch !== undefined && object.ifMetagenerationNotMatch !== null)
        ? Long.fromValue(object.ifMetagenerationNotMatch)
        : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCommonLongRunningOperationMetadata(): CommonLongRunningOperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    updateTime: undefined,
    type: "",
    requestedCancellation: false,
    progressPercent: 0,
  };
}

export const CommonLongRunningOperationMetadata: MessageFns<CommonLongRunningOperationMetadata> = {
  encode(message: CommonLongRunningOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(40).bool(message.requestedCancellation);
    }
    if (message.progressPercent !== 0) {
      writer.uint32(48).int32(message.progressPercent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommonLongRunningOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommonLongRunningOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.progressPercent = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommonLongRunningOperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      progressPercent: isSet(object.progressPercent) ? globalThis.Number(object.progressPercent) : 0,
    };
  },

  toJSON(message: CommonLongRunningOperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.progressPercent !== 0) {
      obj.progressPercent = Math.round(message.progressPercent);
    }
    return obj;
  },

  create(base?: DeepPartial<CommonLongRunningOperationMetadata>): CommonLongRunningOperationMetadata {
    return CommonLongRunningOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommonLongRunningOperationMetadata>): CommonLongRunningOperationMetadata {
    const message = createBaseCommonLongRunningOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.type = object.type ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.progressPercent = object.progressPercent ?? 0;
    return message;
  },
};

function createBaseRenameFolderMetadata(): RenameFolderMetadata {
  return { commonMetadata: undefined, sourceFolderId: "", destinationFolderId: "" };
}

export const RenameFolderMetadata: MessageFns<RenameFolderMetadata> = {
  encode(message: RenameFolderMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commonMetadata !== undefined) {
      CommonLongRunningOperationMetadata.encode(message.commonMetadata, writer.uint32(10).fork()).join();
    }
    if (message.sourceFolderId !== "") {
      writer.uint32(18).string(message.sourceFolderId);
    }
    if (message.destinationFolderId !== "") {
      writer.uint32(26).string(message.destinationFolderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenameFolderMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameFolderMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.commonMetadata = CommonLongRunningOperationMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceFolderId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destinationFolderId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenameFolderMetadata {
    return {
      commonMetadata: isSet(object.commonMetadata)
        ? CommonLongRunningOperationMetadata.fromJSON(object.commonMetadata)
        : undefined,
      sourceFolderId: isSet(object.sourceFolderId) ? globalThis.String(object.sourceFolderId) : "",
      destinationFolderId: isSet(object.destinationFolderId) ? globalThis.String(object.destinationFolderId) : "",
    };
  },

  toJSON(message: RenameFolderMetadata): unknown {
    const obj: any = {};
    if (message.commonMetadata !== undefined) {
      obj.commonMetadata = CommonLongRunningOperationMetadata.toJSON(message.commonMetadata);
    }
    if (message.sourceFolderId !== "") {
      obj.sourceFolderId = message.sourceFolderId;
    }
    if (message.destinationFolderId !== "") {
      obj.destinationFolderId = message.destinationFolderId;
    }
    return obj;
  },

  create(base?: DeepPartial<RenameFolderMetadata>): RenameFolderMetadata {
    return RenameFolderMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenameFolderMetadata>): RenameFolderMetadata {
    const message = createBaseRenameFolderMetadata();
    message.commonMetadata = (object.commonMetadata !== undefined && object.commonMetadata !== null)
      ? CommonLongRunningOperationMetadata.fromPartial(object.commonMetadata)
      : undefined;
    message.sourceFolderId = object.sourceFolderId ?? "";
    message.destinationFolderId = object.destinationFolderId ?? "";
    return message;
  },
};

function createBaseStorageLayout(): StorageLayout {
  return {
    name: "",
    location: "",
    locationType: "",
    customPlacementConfig: undefined,
    hierarchicalNamespace: undefined,
  };
}

export const StorageLayout: MessageFns<StorageLayout> = {
  encode(message: StorageLayout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.locationType !== "") {
      writer.uint32(26).string(message.locationType);
    }
    if (message.customPlacementConfig !== undefined) {
      StorageLayout_CustomPlacementConfig.encode(message.customPlacementConfig, writer.uint32(34).fork()).join();
    }
    if (message.hierarchicalNamespace !== undefined) {
      StorageLayout_HierarchicalNamespace.encode(message.hierarchicalNamespace, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageLayout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageLayout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.locationType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.customPlacementConfig = StorageLayout_CustomPlacementConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hierarchicalNamespace = StorageLayout_HierarchicalNamespace.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageLayout {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      locationType: isSet(object.locationType) ? globalThis.String(object.locationType) : "",
      customPlacementConfig: isSet(object.customPlacementConfig)
        ? StorageLayout_CustomPlacementConfig.fromJSON(object.customPlacementConfig)
        : undefined,
      hierarchicalNamespace: isSet(object.hierarchicalNamespace)
        ? StorageLayout_HierarchicalNamespace.fromJSON(object.hierarchicalNamespace)
        : undefined,
    };
  },

  toJSON(message: StorageLayout): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.locationType !== "") {
      obj.locationType = message.locationType;
    }
    if (message.customPlacementConfig !== undefined) {
      obj.customPlacementConfig = StorageLayout_CustomPlacementConfig.toJSON(message.customPlacementConfig);
    }
    if (message.hierarchicalNamespace !== undefined) {
      obj.hierarchicalNamespace = StorageLayout_HierarchicalNamespace.toJSON(message.hierarchicalNamespace);
    }
    return obj;
  },

  create(base?: DeepPartial<StorageLayout>): StorageLayout {
    return StorageLayout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StorageLayout>): StorageLayout {
    const message = createBaseStorageLayout();
    message.name = object.name ?? "";
    message.location = object.location ?? "";
    message.locationType = object.locationType ?? "";
    message.customPlacementConfig =
      (object.customPlacementConfig !== undefined && object.customPlacementConfig !== null)
        ? StorageLayout_CustomPlacementConfig.fromPartial(object.customPlacementConfig)
        : undefined;
    message.hierarchicalNamespace =
      (object.hierarchicalNamespace !== undefined && object.hierarchicalNamespace !== null)
        ? StorageLayout_HierarchicalNamespace.fromPartial(object.hierarchicalNamespace)
        : undefined;
    return message;
  },
};

function createBaseStorageLayout_CustomPlacementConfig(): StorageLayout_CustomPlacementConfig {
  return { dataLocations: [] };
}

export const StorageLayout_CustomPlacementConfig: MessageFns<StorageLayout_CustomPlacementConfig> = {
  encode(message: StorageLayout_CustomPlacementConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dataLocations) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageLayout_CustomPlacementConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageLayout_CustomPlacementConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataLocations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageLayout_CustomPlacementConfig {
    return {
      dataLocations: globalThis.Array.isArray(object?.dataLocations)
        ? object.dataLocations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: StorageLayout_CustomPlacementConfig): unknown {
    const obj: any = {};
    if (message.dataLocations?.length) {
      obj.dataLocations = message.dataLocations;
    }
    return obj;
  },

  create(base?: DeepPartial<StorageLayout_CustomPlacementConfig>): StorageLayout_CustomPlacementConfig {
    return StorageLayout_CustomPlacementConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StorageLayout_CustomPlacementConfig>): StorageLayout_CustomPlacementConfig {
    const message = createBaseStorageLayout_CustomPlacementConfig();
    message.dataLocations = object.dataLocations?.map((e) => e) || [];
    return message;
  },
};

function createBaseStorageLayout_HierarchicalNamespace(): StorageLayout_HierarchicalNamespace {
  return { enabled: false };
}

export const StorageLayout_HierarchicalNamespace: MessageFns<StorageLayout_HierarchicalNamespace> = {
  encode(message: StorageLayout_HierarchicalNamespace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageLayout_HierarchicalNamespace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageLayout_HierarchicalNamespace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageLayout_HierarchicalNamespace {
    return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
  },

  toJSON(message: StorageLayout_HierarchicalNamespace): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<StorageLayout_HierarchicalNamespace>): StorageLayout_HierarchicalNamespace {
    return StorageLayout_HierarchicalNamespace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StorageLayout_HierarchicalNamespace>): StorageLayout_HierarchicalNamespace {
    const message = createBaseStorageLayout_HierarchicalNamespace();
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseGetStorageLayoutRequest(): GetStorageLayoutRequest {
  return { name: "", prefix: "", requestId: "" };
}

export const GetStorageLayoutRequest: MessageFns<GetStorageLayoutRequest> = {
  encode(message: GetStorageLayoutRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.prefix !== "") {
      writer.uint32(18).string(message.prefix);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStorageLayoutRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStorageLayoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStorageLayoutRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: GetStorageLayoutRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetStorageLayoutRequest>): GetStorageLayoutRequest {
    return GetStorageLayoutRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetStorageLayoutRequest>): GetStorageLayoutRequest {
    const message = createBaseGetStorageLayoutRequest();
    message.name = object.name ?? "";
    message.prefix = object.prefix ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseManagedFolder(): ManagedFolder {
  return { name: "", metageneration: Long.ZERO, createTime: undefined, updateTime: undefined };
}

export const ManagedFolder: MessageFns<ManagedFolder> = {
  encode(message: ManagedFolder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.metageneration.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.metageneration.toString());
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManagedFolder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManagedFolder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.metageneration = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManagedFolder {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metageneration: isSet(object.metageneration) ? Long.fromValue(object.metageneration) : Long.ZERO,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: ManagedFolder): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.metageneration.equals(Long.ZERO)) {
      obj.metageneration = (message.metageneration || Long.ZERO).toString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ManagedFolder>): ManagedFolder {
    return ManagedFolder.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManagedFolder>): ManagedFolder {
    const message = createBaseManagedFolder();
    message.name = object.name ?? "";
    message.metageneration = (object.metageneration !== undefined && object.metageneration !== null)
      ? Long.fromValue(object.metageneration)
      : Long.ZERO;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseGetManagedFolderRequest(): GetManagedFolderRequest {
  return { name: "", ifMetagenerationMatch: undefined, ifMetagenerationNotMatch: undefined, requestId: "" };
}

export const GetManagedFolderRequest: MessageFns<GetManagedFolderRequest> = {
  encode(message: GetManagedFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.ifMetagenerationMatch !== undefined) {
      writer.uint32(24).int64(message.ifMetagenerationMatch.toString());
    }
    if (message.ifMetagenerationNotMatch !== undefined) {
      writer.uint32(32).int64(message.ifMetagenerationNotMatch.toString());
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetManagedFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetManagedFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ifMetagenerationMatch = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ifMetagenerationNotMatch = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetManagedFolderRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ifMetagenerationMatch: isSet(object.ifMetagenerationMatch)
        ? Long.fromValue(object.ifMetagenerationMatch)
        : undefined,
      ifMetagenerationNotMatch: isSet(object.ifMetagenerationNotMatch)
        ? Long.fromValue(object.ifMetagenerationNotMatch)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: GetManagedFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ifMetagenerationMatch !== undefined) {
      obj.ifMetagenerationMatch = (message.ifMetagenerationMatch || Long.ZERO).toString();
    }
    if (message.ifMetagenerationNotMatch !== undefined) {
      obj.ifMetagenerationNotMatch = (message.ifMetagenerationNotMatch || Long.ZERO).toString();
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetManagedFolderRequest>): GetManagedFolderRequest {
    return GetManagedFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetManagedFolderRequest>): GetManagedFolderRequest {
    const message = createBaseGetManagedFolderRequest();
    message.name = object.name ?? "";
    message.ifMetagenerationMatch =
      (object.ifMetagenerationMatch !== undefined && object.ifMetagenerationMatch !== null)
        ? Long.fromValue(object.ifMetagenerationMatch)
        : undefined;
    message.ifMetagenerationNotMatch =
      (object.ifMetagenerationNotMatch !== undefined && object.ifMetagenerationNotMatch !== null)
        ? Long.fromValue(object.ifMetagenerationNotMatch)
        : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCreateManagedFolderRequest(): CreateManagedFolderRequest {
  return { parent: "", managedFolder: undefined, managedFolderId: "", requestId: "" };
}

export const CreateManagedFolderRequest: MessageFns<CreateManagedFolderRequest> = {
  encode(message: CreateManagedFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.managedFolder !== undefined) {
      ManagedFolder.encode(message.managedFolder, writer.uint32(18).fork()).join();
    }
    if (message.managedFolderId !== "") {
      writer.uint32(26).string(message.managedFolderId);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateManagedFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateManagedFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.managedFolder = ManagedFolder.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.managedFolderId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateManagedFolderRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      managedFolder: isSet(object.managedFolder) ? ManagedFolder.fromJSON(object.managedFolder) : undefined,
      managedFolderId: isSet(object.managedFolderId) ? globalThis.String(object.managedFolderId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateManagedFolderRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.managedFolder !== undefined) {
      obj.managedFolder = ManagedFolder.toJSON(message.managedFolder);
    }
    if (message.managedFolderId !== "") {
      obj.managedFolderId = message.managedFolderId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateManagedFolderRequest>): CreateManagedFolderRequest {
    return CreateManagedFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateManagedFolderRequest>): CreateManagedFolderRequest {
    const message = createBaseCreateManagedFolderRequest();
    message.parent = object.parent ?? "";
    message.managedFolder = (object.managedFolder !== undefined && object.managedFolder !== null)
      ? ManagedFolder.fromPartial(object.managedFolder)
      : undefined;
    message.managedFolderId = object.managedFolderId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteManagedFolderRequest(): DeleteManagedFolderRequest {
  return {
    name: "",
    ifMetagenerationMatch: undefined,
    ifMetagenerationNotMatch: undefined,
    allowNonEmpty: false,
    requestId: "",
  };
}

export const DeleteManagedFolderRequest: MessageFns<DeleteManagedFolderRequest> = {
  encode(message: DeleteManagedFolderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(58).string(message.name);
    }
    if (message.ifMetagenerationMatch !== undefined) {
      writer.uint32(24).int64(message.ifMetagenerationMatch.toString());
    }
    if (message.ifMetagenerationNotMatch !== undefined) {
      writer.uint32(32).int64(message.ifMetagenerationNotMatch.toString());
    }
    if (message.allowNonEmpty !== false) {
      writer.uint32(40).bool(message.allowNonEmpty);
    }
    if (message.requestId !== "") {
      writer.uint32(50).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteManagedFolderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteManagedFolderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ifMetagenerationMatch = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ifMetagenerationNotMatch = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.allowNonEmpty = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteManagedFolderRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ifMetagenerationMatch: isSet(object.ifMetagenerationMatch)
        ? Long.fromValue(object.ifMetagenerationMatch)
        : undefined,
      ifMetagenerationNotMatch: isSet(object.ifMetagenerationNotMatch)
        ? Long.fromValue(object.ifMetagenerationNotMatch)
        : undefined,
      allowNonEmpty: isSet(object.allowNonEmpty) ? globalThis.Boolean(object.allowNonEmpty) : false,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteManagedFolderRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ifMetagenerationMatch !== undefined) {
      obj.ifMetagenerationMatch = (message.ifMetagenerationMatch || Long.ZERO).toString();
    }
    if (message.ifMetagenerationNotMatch !== undefined) {
      obj.ifMetagenerationNotMatch = (message.ifMetagenerationNotMatch || Long.ZERO).toString();
    }
    if (message.allowNonEmpty !== false) {
      obj.allowNonEmpty = message.allowNonEmpty;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteManagedFolderRequest>): DeleteManagedFolderRequest {
    return DeleteManagedFolderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteManagedFolderRequest>): DeleteManagedFolderRequest {
    const message = createBaseDeleteManagedFolderRequest();
    message.name = object.name ?? "";
    message.ifMetagenerationMatch =
      (object.ifMetagenerationMatch !== undefined && object.ifMetagenerationMatch !== null)
        ? Long.fromValue(object.ifMetagenerationMatch)
        : undefined;
    message.ifMetagenerationNotMatch =
      (object.ifMetagenerationNotMatch !== undefined && object.ifMetagenerationNotMatch !== null)
        ? Long.fromValue(object.ifMetagenerationNotMatch)
        : undefined;
    message.allowNonEmpty = object.allowNonEmpty ?? false;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListManagedFoldersRequest(): ListManagedFoldersRequest {
  return { parent: "", pageSize: 0, pageToken: "", prefix: "", requestId: "" };
}

export const ListManagedFoldersRequest: MessageFns<ListManagedFoldersRequest> = {
  encode(message: ListManagedFoldersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.prefix !== "") {
      writer.uint32(34).string(message.prefix);
    }
    if (message.requestId !== "") {
      writer.uint32(42).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListManagedFoldersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListManagedFoldersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.prefix = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListManagedFoldersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: ListManagedFoldersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<ListManagedFoldersRequest>): ListManagedFoldersRequest {
    return ListManagedFoldersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListManagedFoldersRequest>): ListManagedFoldersRequest {
    const message = createBaseListManagedFoldersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.prefix = object.prefix ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListManagedFoldersResponse(): ListManagedFoldersResponse {
  return { managedFolders: [], nextPageToken: "" };
}

export const ListManagedFoldersResponse: MessageFns<ListManagedFoldersResponse> = {
  encode(message: ListManagedFoldersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.managedFolders) {
      ManagedFolder.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListManagedFoldersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListManagedFoldersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.managedFolders.push(ManagedFolder.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListManagedFoldersResponse {
    return {
      managedFolders: globalThis.Array.isArray(object?.managedFolders)
        ? object.managedFolders.map((e: any) => ManagedFolder.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListManagedFoldersResponse): unknown {
    const obj: any = {};
    if (message.managedFolders?.length) {
      obj.managedFolders = message.managedFolders.map((e) => ManagedFolder.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListManagedFoldersResponse>): ListManagedFoldersResponse {
    return ListManagedFoldersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListManagedFoldersResponse>): ListManagedFoldersResponse {
    const message = createBaseListManagedFoldersResponse();
    message.managedFolders = object.managedFolders?.map((e) => ManagedFolder.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/** StorageControl service includes selected control plane operations. */
export type StorageControlDefinition = typeof StorageControlDefinition;
export const StorageControlDefinition = {
  name: "StorageControl",
  fullName: "google.storage.control.v2.StorageControl",
  methods: {
    /**
     * Creates a new folder. This operation is only applicable to a hierarchical
     * namespace enabled bucket.
     */
    createFolder: {
      name: "CreateFolder",
      requestType: CreateFolderRequest,
      requestStream: false,
      responseType: Folder,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              102,
              111,
              108,
              100,
              101,
              114,
              44,
              102,
              111,
              108,
              100,
              101,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365834: [
            Buffer.from([
              23,
              18,
              21,
              10,
              6,
              112,
              97,
              114,
              101,
              110,
              116,
              18,
              11,
              123,
              98,
              117,
              99,
              107,
              101,
              116,
              61,
              42,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Permanently deletes an empty folder. This operation is only applicable to a
     * hierarchical namespace enabled bucket.
     */
    deleteFolder: {
      name: "DeleteFolder",
      requestType: DeleteFolderRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365834: [
            Buffer.from([
              42,
              18,
              40,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              32,
              123,
              98,
              117,
              99,
              107,
              101,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              117,
              99,
              107,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              42,
              42,
            ]),
          ],
        },
      },
    },
    /**
     * Returns metadata for the specified folder. This operation is only
     * applicable to a hierarchical namespace enabled bucket.
     */
    getFolder: {
      name: "GetFolder",
      requestType: GetFolderRequest,
      requestStream: false,
      responseType: Folder,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365834: [
            Buffer.from([
              42,
              18,
              40,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              32,
              123,
              98,
              117,
              99,
              107,
              101,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              117,
              99,
              107,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              42,
              42,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves a list of folders. This operation is only applicable to a
     * hierarchical namespace enabled bucket.
     */
    listFolders: {
      name: "ListFolders",
      requestType: ListFoldersRequest,
      requestStream: false,
      responseType: ListFoldersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365834: [
            Buffer.from([
              23,
              18,
              21,
              10,
              6,
              112,
              97,
              114,
              101,
              110,
              116,
              18,
              11,
              123,
              98,
              117,
              99,
              107,
              101,
              116,
              61,
              42,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Renames a source folder to a destination folder. This operation is only
     * applicable to a hierarchical namespace enabled bucket. During a rename, the
     * source and destination folders are locked until the long running operation
     * completes.
     */
    renameFolder: {
      name: "RenameFolder",
      requestType: RenameFolderRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              6,
              70,
              111,
              108,
              100,
              101,
              114,
              18,
              20,
              82,
              101,
              110,
              97,
              109,
              101,
              70,
              111,
              108,
              100,
              101,
              114,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              26,
              110,
              97,
              109,
              101,
              44,
              100,
              101,
              115,
              116,
              105,
              110,
              97,
              116,
              105,
              111,
              110,
              95,
              102,
              111,
              108,
              100,
              101,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365834: [
            Buffer.from([
              42,
              18,
              40,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              32,
              123,
              98,
              117,
              99,
              107,
              101,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              117,
              99,
              107,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              42,
              42,
            ]),
          ],
        },
      },
    },
    /** Returns the storage layout configuration for a given bucket. */
    getStorageLayout: {
      name: "GetStorageLayout",
      requestType: GetStorageLayoutRequest,
      requestStream: false,
      responseType: StorageLayout,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365834: [
            Buffer.from([
              42,
              18,
              40,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              32,
              123,
              98,
              117,
              99,
              107,
              101,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              117,
              99,
              107,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              42,
              42,
            ]),
          ],
        },
      },
    },
    /** Creates a new managed folder. */
    createManagedFolder: {
      name: "CreateManagedFolder",
      requestType: CreateManagedFolderRequest,
      requestStream: false,
      responseType: ManagedFolder,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              39,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              109,
              97,
              110,
              97,
              103,
              101,
              100,
              95,
              102,
              111,
              108,
              100,
              101,
              114,
              44,
              109,
              97,
              110,
              97,
              103,
              101,
              100,
              95,
              102,
              111,
              108,
              100,
              101,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365834: [
            Buffer.from([
              23,
              18,
              21,
              10,
              6,
              112,
              97,
              114,
              101,
              110,
              116,
              18,
              11,
              123,
              98,
              117,
              99,
              107,
              101,
              116,
              61,
              42,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Permanently deletes an empty managed folder. */
    deleteManagedFolder: {
      name: "DeleteManagedFolder",
      requestType: DeleteManagedFolderRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365834: [
            Buffer.from([
              42,
              18,
              40,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              32,
              123,
              98,
              117,
              99,
              107,
              101,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              117,
              99,
              107,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              42,
              42,
            ]),
          ],
        },
      },
    },
    /** Returns metadata for the specified managed folder. */
    getManagedFolder: {
      name: "GetManagedFolder",
      requestType: GetManagedFolderRequest,
      requestStream: false,
      responseType: ManagedFolder,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365834: [
            Buffer.from([
              42,
              18,
              40,
              10,
              4,
              110,
              97,
              109,
              101,
              18,
              32,
              123,
              98,
              117,
              99,
              107,
              101,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              98,
              117,
              99,
              107,
              101,
              116,
              115,
              47,
              42,
              125,
              47,
              42,
              42,
            ]),
          ],
        },
      },
    },
    /** Retrieves a list of managed folders for a given bucket. */
    listManagedFolders: {
      name: "ListManagedFolders",
      requestType: ListManagedFoldersRequest,
      requestStream: false,
      responseType: ListManagedFoldersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365834: [
            Buffer.from([
              23,
              18,
              21,
              10,
              6,
              112,
              97,
              114,
              101,
              110,
              116,
              18,
              11,
              123,
              98,
              117,
              99,
              107,
              101,
              116,
              61,
              42,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface StorageControlServiceImplementation<CallContextExt = {}> {
  /**
   * Creates a new folder. This operation is only applicable to a hierarchical
   * namespace enabled bucket.
   */
  createFolder(request: CreateFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Folder>>;
  /**
   * Permanently deletes an empty folder. This operation is only applicable to a
   * hierarchical namespace enabled bucket.
   */
  deleteFolder(request: DeleteFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Returns metadata for the specified folder. This operation is only
   * applicable to a hierarchical namespace enabled bucket.
   */
  getFolder(request: GetFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Folder>>;
  /**
   * Retrieves a list of folders. This operation is only applicable to a
   * hierarchical namespace enabled bucket.
   */
  listFolders(
    request: ListFoldersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListFoldersResponse>>;
  /**
   * Renames a source folder to a destination folder. This operation is only
   * applicable to a hierarchical namespace enabled bucket. During a rename, the
   * source and destination folders are locked until the long running operation
   * completes.
   */
  renameFolder(request: RenameFolderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Returns the storage layout configuration for a given bucket. */
  getStorageLayout(
    request: GetStorageLayoutRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<StorageLayout>>;
  /** Creates a new managed folder. */
  createManagedFolder(
    request: CreateManagedFolderRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ManagedFolder>>;
  /** Permanently deletes an empty managed folder. */
  deleteManagedFolder(
    request: DeleteManagedFolderRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Returns metadata for the specified managed folder. */
  getManagedFolder(
    request: GetManagedFolderRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ManagedFolder>>;
  /** Retrieves a list of managed folders for a given bucket. */
  listManagedFolders(
    request: ListManagedFoldersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListManagedFoldersResponse>>;
}

export interface StorageControlClient<CallOptionsExt = {}> {
  /**
   * Creates a new folder. This operation is only applicable to a hierarchical
   * namespace enabled bucket.
   */
  createFolder(request: DeepPartial<CreateFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Folder>;
  /**
   * Permanently deletes an empty folder. This operation is only applicable to a
   * hierarchical namespace enabled bucket.
   */
  deleteFolder(request: DeepPartial<DeleteFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Returns metadata for the specified folder. This operation is only
   * applicable to a hierarchical namespace enabled bucket.
   */
  getFolder(request: DeepPartial<GetFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Folder>;
  /**
   * Retrieves a list of folders. This operation is only applicable to a
   * hierarchical namespace enabled bucket.
   */
  listFolders(
    request: DeepPartial<ListFoldersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListFoldersResponse>;
  /**
   * Renames a source folder to a destination folder. This operation is only
   * applicable to a hierarchical namespace enabled bucket. During a rename, the
   * source and destination folders are locked until the long running operation
   * completes.
   */
  renameFolder(request: DeepPartial<RenameFolderRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Returns the storage layout configuration for a given bucket. */
  getStorageLayout(
    request: DeepPartial<GetStorageLayoutRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<StorageLayout>;
  /** Creates a new managed folder. */
  createManagedFolder(
    request: DeepPartial<CreateManagedFolderRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ManagedFolder>;
  /** Permanently deletes an empty managed folder. */
  deleteManagedFolder(
    request: DeepPartial<DeleteManagedFolderRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Returns metadata for the specified managed folder. */
  getManagedFolder(
    request: DeepPartial<GetManagedFolderRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ManagedFolder>;
  /** Retrieves a list of managed folders for a given bucket. */
  listManagedFolders(
    request: DeepPartial<ListManagedFoldersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListManagedFoldersResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
