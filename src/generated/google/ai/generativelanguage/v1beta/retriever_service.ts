// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ai/generativelanguage/v1beta/retriever_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Chunk, Corpus, Document, MetadataFilter } from "./retriever.js";

export const protobufPackage = "google.ai.generativelanguage.v1beta";

/** Request to create a `Corpus`. */
export interface CreateCorpusRequest {
  /** Required. The `Corpus` to create. */
  corpus: Corpus | undefined;
}

/** Request for getting information about a specific `Corpus`. */
export interface GetCorpusRequest {
  /**
   * Required. The name of the `Corpus`.
   * Example: `corpora/my-corpus-123`
   */
  name: string;
}

/** Request to update a `Corpus`. */
export interface UpdateCorpusRequest {
  /** Required. The `Corpus` to update. */
  corpus:
    | Corpus
    | undefined;
  /**
   * Required. The list of fields to update.
   * Currently, this only supports updating `display_name`.
   */
  updateMask: string[] | undefined;
}

/** Request to delete a `Corpus`. */
export interface DeleteCorpusRequest {
  /**
   * Required. The resource name of the `Corpus`.
   * Example: `corpora/my-corpus-123`
   */
  name: string;
  /**
   * Optional. If set to true, any `Document`s and objects related to this
   * `Corpus` will also be deleted.
   *
   * If false (the default), a `FAILED_PRECONDITION` error will be returned if
   * `Corpus` contains any `Document`s.
   */
  force: boolean;
}

/** Request for listing `Corpora`. */
export interface ListCorporaRequest {
  /**
   * Optional. The maximum number of `Corpora` to return (per page).
   * The service may return fewer `Corpora`.
   *
   * If unspecified, at most 10 `Corpora` will be returned.
   * The maximum size limit is 20 `Corpora` per page.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListCorpora` call.
   *
   * Provide the `next_page_token` returned in the response as an argument to
   * the next request to retrieve the next page.
   *
   * When paginating, all other parameters provided to `ListCorpora`
   * must match the call that provided the page token.
   */
  pageToken: string;
}

/**
 * Response from `ListCorpora` containing a paginated list of `Corpora`.
 * The results are sorted by ascending `corpus.create_time`.
 */
export interface ListCorporaResponse {
  /** The returned corpora. */
  corpora: Corpus[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no more pages.
   */
  nextPageToken: string;
}

/** Request for querying a `Corpus`. */
export interface QueryCorpusRequest {
  /**
   * Required. The name of the `Corpus` to query.
   * Example: `corpora/my-corpus-123`
   */
  name: string;
  /** Required. Query string to perform semantic search. */
  query: string;
  /**
   * Optional. Filter for `Chunk` and `Document` metadata. Each `MetadataFilter`
   * object should correspond to a unique key. Multiple `MetadataFilter` objects
   * are joined by logical "AND"s.
   *
   * Example query at document level:
   * (year >= 2020 OR year < 2010) AND (genre = drama OR genre = action)
   *
   * `MetadataFilter` object list:
   *  metadata_filters = [
   *  {key = "document.custom_metadata.year"
   *   conditions = [{int_value = 2020, operation = GREATER_EQUAL},
   *                 {int_value = 2010, operation = LESS}]},
   *  {key = "document.custom_metadata.year"
   *   conditions = [{int_value = 2020, operation = GREATER_EQUAL},
   *                 {int_value = 2010, operation = LESS}]},
   *  {key = "document.custom_metadata.genre"
   *   conditions = [{string_value = "drama", operation = EQUAL},
   *                 {string_value = "action", operation = EQUAL}]}]
   *
   * Example query at chunk level for a numeric range of values:
   * (year > 2015 AND year <= 2020)
   *
   * `MetadataFilter` object list:
   *  metadata_filters = [
   *  {key = "chunk.custom_metadata.year"
   *   conditions = [{int_value = 2015, operation = GREATER}]},
   *  {key = "chunk.custom_metadata.year"
   *   conditions = [{int_value = 2020, operation = LESS_EQUAL}]}]
   *
   * Note: "AND"s for the same key are only supported for numeric values. String
   * values only support "OR"s for the same key.
   */
  metadataFilters: MetadataFilter[];
  /**
   * Optional. The maximum number of `Chunk`s to return.
   * The service may return fewer `Chunk`s.
   *
   * If unspecified, at most 10 `Chunk`s will be returned.
   * The maximum specified result count is 100.
   */
  resultsCount: number;
}

/** Response from `QueryCorpus` containing a list of relevant chunks. */
export interface QueryCorpusResponse {
  /** The relevant chunks. */
  relevantChunks: RelevantChunk[];
}

/** The information for a chunk relevant to a query. */
export interface RelevantChunk {
  /** `Chunk` relevance to the query. */
  chunkRelevanceScore: number;
  /** `Chunk` associated with the query. */
  chunk: Chunk | undefined;
}

/** Request to create a `Document`. */
export interface CreateDocumentRequest {
  /**
   * Required. The name of the `Corpus` where this `Document` will be created.
   * Example: `corpora/my-corpus-123`
   */
  parent: string;
  /** Required. The `Document` to create. */
  document: Document | undefined;
}

/** Request for getting information about a specific `Document`. */
export interface GetDocumentRequest {
  /**
   * Required. The name of the `Document` to retrieve.
   * Example: `corpora/my-corpus-123/documents/the-doc-abc`
   */
  name: string;
}

/** Request to update a `Document`. */
export interface UpdateDocumentRequest {
  /** Required. The `Document` to update. */
  document:
    | Document
    | undefined;
  /**
   * Required. The list of fields to update.
   * Currently, this only supports updating `display_name` and
   * `custom_metadata`.
   */
  updateMask: string[] | undefined;
}

/** Request to delete a `Document`. */
export interface DeleteDocumentRequest {
  /**
   * Required. The resource name of the `Document` to delete.
   * Example: `corpora/my-corpus-123/documents/the-doc-abc`
   */
  name: string;
  /**
   * Optional. If set to true, any `Chunk`s and objects related to this
   * `Document` will also be deleted.
   *
   * If false (the default), a `FAILED_PRECONDITION` error will be returned if
   * `Document` contains any `Chunk`s.
   */
  force: boolean;
}

/** Request for listing `Document`s. */
export interface ListDocumentsRequest {
  /**
   * Required. The name of the `Corpus` containing `Document`s.
   * Example: `corpora/my-corpus-123`
   */
  parent: string;
  /**
   * Optional. The maximum number of `Document`s to return (per page).
   * The service may return fewer `Document`s.
   *
   * If unspecified, at most 10 `Document`s will be returned.
   * The maximum size limit is 20 `Document`s per page.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListDocuments` call.
   *
   * Provide the `next_page_token` returned in the response as an argument to
   * the next request to retrieve the next page.
   *
   * When paginating, all other parameters provided to `ListDocuments`
   * must match the call that provided the page token.
   */
  pageToken: string;
}

/**
 * Response from `ListDocuments` containing a paginated list of `Document`s.
 * The `Document`s are sorted by ascending `document.create_time`.
 */
export interface ListDocumentsResponse {
  /** The returned `Document`s. */
  documents: Document[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no more pages.
   */
  nextPageToken: string;
}

/** Request for querying a `Document`. */
export interface QueryDocumentRequest {
  /**
   * Required. The name of the `Document` to query.
   * Example: `corpora/my-corpus-123/documents/the-doc-abc`
   */
  name: string;
  /** Required. Query string to perform semantic search. */
  query: string;
  /**
   * Optional. The maximum number of `Chunk`s to return.
   * The service may return fewer `Chunk`s.
   *
   * If unspecified, at most 10 `Chunk`s will be returned.
   * The maximum specified result count is 100.
   */
  resultsCount: number;
  /**
   * Optional. Filter for `Chunk` metadata. Each `MetadataFilter` object should
   * correspond to a unique key. Multiple `MetadataFilter` objects are joined by
   * logical "AND"s.
   *
   * Note: `Document`-level filtering is not supported for this request because
   * a `Document` name is already specified.
   *
   * Example query:
   * (year >= 2020 OR year < 2010) AND (genre = drama OR genre = action)
   *
   * `MetadataFilter` object list:
   *  metadata_filters = [
   *  {key = "chunk.custom_metadata.year"
   *   conditions = [{int_value = 2020, operation = GREATER_EQUAL},
   *                 {int_value = 2010, operation = LESS}},
   *  {key = "chunk.custom_metadata.genre"
   *   conditions = [{string_value = "drama", operation = EQUAL},
   *                 {string_value = "action", operation = EQUAL}}]
   *
   * Example query for a numeric range of values:
   * (year > 2015 AND year <= 2020)
   *
   * `MetadataFilter` object list:
   *  metadata_filters = [
   *  {key = "chunk.custom_metadata.year"
   *   conditions = [{int_value = 2015, operation = GREATER}]},
   *  {key = "chunk.custom_metadata.year"
   *   conditions = [{int_value = 2020, operation = LESS_EQUAL}]}]
   *
   * Note: "AND"s for the same key are only supported for numeric values. String
   * values only support "OR"s for the same key.
   */
  metadataFilters: MetadataFilter[];
}

/** Response from `QueryDocument` containing a list of relevant chunks. */
export interface QueryDocumentResponse {
  /** The returned relevant chunks. */
  relevantChunks: RelevantChunk[];
}

/** Request to create a `Chunk`. */
export interface CreateChunkRequest {
  /**
   * Required. The name of the `Document` where this `Chunk` will be created.
   * Example: `corpora/my-corpus-123/documents/the-doc-abc`
   */
  parent: string;
  /** Required. The `Chunk` to create. */
  chunk: Chunk | undefined;
}

/** Request to batch create `Chunk`s. */
export interface BatchCreateChunksRequest {
  /**
   * Optional. The name of the `Document` where this batch of `Chunk`s will be
   * created. The parent field in every `CreateChunkRequest` must match this
   * value. Example: `corpora/my-corpus-123/documents/the-doc-abc`
   */
  parent: string;
  /**
   * Required. The request messages specifying the `Chunk`s to create.
   * A maximum of 100 `Chunk`s can be created in a batch.
   */
  requests: CreateChunkRequest[];
}

/** Response from `BatchCreateChunks` containing a list of created `Chunk`s. */
export interface BatchCreateChunksResponse {
  /** `Chunk`s created. */
  chunks: Chunk[];
}

/** Request for getting information about a specific `Chunk`. */
export interface GetChunkRequest {
  /**
   * Required. The name of the `Chunk` to retrieve.
   * Example: `corpora/my-corpus-123/documents/the-doc-abc/chunks/some-chunk`
   */
  name: string;
}

/** Request to update a `Chunk`. */
export interface UpdateChunkRequest {
  /** Required. The `Chunk` to update. */
  chunk:
    | Chunk
    | undefined;
  /**
   * Required. The list of fields to update.
   * Currently, this only supports updating `custom_metadata` and `data`.
   */
  updateMask: string[] | undefined;
}

/** Request to batch update `Chunk`s. */
export interface BatchUpdateChunksRequest {
  /**
   * Optional. The name of the `Document` containing the `Chunk`s to update.
   * The parent field in every `UpdateChunkRequest` must match this value.
   * Example: `corpora/my-corpus-123/documents/the-doc-abc`
   */
  parent: string;
  /**
   * Required. The request messages specifying the `Chunk`s to update.
   * A maximum of 100 `Chunk`s can be updated in a batch.
   */
  requests: UpdateChunkRequest[];
}

/** Response from `BatchUpdateChunks` containing a list of updated `Chunk`s. */
export interface BatchUpdateChunksResponse {
  /** `Chunk`s updated. */
  chunks: Chunk[];
}

/** Request to delete a `Chunk`. */
export interface DeleteChunkRequest {
  /**
   * Required. The resource name of the `Chunk` to delete.
   * Example: `corpora/my-corpus-123/documents/the-doc-abc/chunks/some-chunk`
   */
  name: string;
}

/** Request to batch delete `Chunk`s. */
export interface BatchDeleteChunksRequest {
  /**
   * Optional. The name of the `Document` containing the `Chunk`s to delete.
   * The parent field in every `DeleteChunkRequest` must match this value.
   * Example: `corpora/my-corpus-123/documents/the-doc-abc`
   */
  parent: string;
  /** Required. The request messages specifying the `Chunk`s to delete. */
  requests: DeleteChunkRequest[];
}

/** Request for listing `Chunk`s. */
export interface ListChunksRequest {
  /**
   * Required. The name of the `Document` containing `Chunk`s.
   * Example: `corpora/my-corpus-123/documents/the-doc-abc`
   */
  parent: string;
  /**
   * Optional. The maximum number of `Chunk`s to return (per page).
   * The service may return fewer `Chunk`s.
   *
   * If unspecified, at most 10 `Chunk`s will be returned.
   * The maximum size limit is 100 `Chunk`s per page.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous `ListChunks` call.
   *
   * Provide the `next_page_token` returned in the response as an argument to
   * the next request to retrieve the next page.
   *
   * When paginating, all other parameters provided to `ListChunks`
   * must match the call that provided the page token.
   */
  pageToken: string;
}

/**
 * Response from `ListChunks` containing a paginated list of `Chunk`s.
 * The `Chunk`s are sorted by ascending `chunk.create_time`.
 */
export interface ListChunksResponse {
  /** The returned `Chunk`s. */
  chunks: Chunk[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no more pages.
   */
  nextPageToken: string;
}

function createBaseCreateCorpusRequest(): CreateCorpusRequest {
  return { corpus: undefined };
}

export const CreateCorpusRequest: MessageFns<CreateCorpusRequest> = {
  encode(message: CreateCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.corpus !== undefined) {
      Corpus.encode(message.corpus, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.corpus = Corpus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCorpusRequest {
    return { corpus: isSet(object.corpus) ? Corpus.fromJSON(object.corpus) : undefined };
  },

  toJSON(message: CreateCorpusRequest): unknown {
    const obj: any = {};
    if (message.corpus !== undefined) {
      obj.corpus = Corpus.toJSON(message.corpus);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCorpusRequest>): CreateCorpusRequest {
    return CreateCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCorpusRequest>): CreateCorpusRequest {
    const message = createBaseCreateCorpusRequest();
    message.corpus = (object.corpus !== undefined && object.corpus !== null)
      ? Corpus.fromPartial(object.corpus)
      : undefined;
    return message;
  },
};

function createBaseGetCorpusRequest(): GetCorpusRequest {
  return { name: "" };
}

export const GetCorpusRequest: MessageFns<GetCorpusRequest> = {
  encode(message: GetCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCorpusRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCorpusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCorpusRequest>): GetCorpusRequest {
    return GetCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCorpusRequest>): GetCorpusRequest {
    const message = createBaseGetCorpusRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateCorpusRequest(): UpdateCorpusRequest {
  return { corpus: undefined, updateMask: undefined };
}

export const UpdateCorpusRequest: MessageFns<UpdateCorpusRequest> = {
  encode(message: UpdateCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.corpus !== undefined) {
      Corpus.encode(message.corpus, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.corpus = Corpus.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCorpusRequest {
    return {
      corpus: isSet(object.corpus) ? Corpus.fromJSON(object.corpus) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCorpusRequest): unknown {
    const obj: any = {};
    if (message.corpus !== undefined) {
      obj.corpus = Corpus.toJSON(message.corpus);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCorpusRequest>): UpdateCorpusRequest {
    return UpdateCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCorpusRequest>): UpdateCorpusRequest {
    const message = createBaseUpdateCorpusRequest();
    message.corpus = (object.corpus !== undefined && object.corpus !== null)
      ? Corpus.fromPartial(object.corpus)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteCorpusRequest(): DeleteCorpusRequest {
  return { name: "", force: false };
}

export const DeleteCorpusRequest: MessageFns<DeleteCorpusRequest> = {
  encode(message: DeleteCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCorpusRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteCorpusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCorpusRequest>): DeleteCorpusRequest {
    return DeleteCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCorpusRequest>): DeleteCorpusRequest {
    const message = createBaseDeleteCorpusRequest();
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseListCorporaRequest(): ListCorporaRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListCorporaRequest: MessageFns<ListCorporaRequest> = {
  encode(message: ListCorporaRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCorporaRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCorporaRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCorporaRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListCorporaRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCorporaRequest>): ListCorporaRequest {
    return ListCorporaRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCorporaRequest>): ListCorporaRequest {
    const message = createBaseListCorporaRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListCorporaResponse(): ListCorporaResponse {
  return { corpora: [], nextPageToken: "" };
}

export const ListCorporaResponse: MessageFns<ListCorporaResponse> = {
  encode(message: ListCorporaResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.corpora) {
      Corpus.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCorporaResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCorporaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.corpora.push(Corpus.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCorporaResponse {
    return {
      corpora: globalThis.Array.isArray(object?.corpora) ? object.corpora.map((e: any) => Corpus.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListCorporaResponse): unknown {
    const obj: any = {};
    if (message.corpora?.length) {
      obj.corpora = message.corpora.map((e) => Corpus.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCorporaResponse>): ListCorporaResponse {
    return ListCorporaResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCorporaResponse>): ListCorporaResponse {
    const message = createBaseListCorporaResponse();
    message.corpora = object.corpora?.map((e) => Corpus.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryCorpusRequest(): QueryCorpusRequest {
  return { name: "", query: "", metadataFilters: [], resultsCount: 0 };
}

export const QueryCorpusRequest: MessageFns<QueryCorpusRequest> = {
  encode(message: QueryCorpusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    for (const v of message.metadataFilters) {
      MetadataFilter.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.resultsCount !== 0) {
      writer.uint32(32).int32(message.resultsCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCorpusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCorpusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadataFilters.push(MetadataFilter.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.resultsCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCorpusRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      metadataFilters: globalThis.Array.isArray(object?.metadataFilters)
        ? object.metadataFilters.map((e: any) => MetadataFilter.fromJSON(e))
        : [],
      resultsCount: isSet(object.resultsCount) ? globalThis.Number(object.resultsCount) : 0,
    };
  },

  toJSON(message: QueryCorpusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.metadataFilters?.length) {
      obj.metadataFilters = message.metadataFilters.map((e) => MetadataFilter.toJSON(e));
    }
    if (message.resultsCount !== 0) {
      obj.resultsCount = Math.round(message.resultsCount);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryCorpusRequest>): QueryCorpusRequest {
    return QueryCorpusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryCorpusRequest>): QueryCorpusRequest {
    const message = createBaseQueryCorpusRequest();
    message.name = object.name ?? "";
    message.query = object.query ?? "";
    message.metadataFilters = object.metadataFilters?.map((e) => MetadataFilter.fromPartial(e)) || [];
    message.resultsCount = object.resultsCount ?? 0;
    return message;
  },
};

function createBaseQueryCorpusResponse(): QueryCorpusResponse {
  return { relevantChunks: [] };
}

export const QueryCorpusResponse: MessageFns<QueryCorpusResponse> = {
  encode(message: QueryCorpusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.relevantChunks) {
      RelevantChunk.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCorpusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCorpusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.relevantChunks.push(RelevantChunk.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCorpusResponse {
    return {
      relevantChunks: globalThis.Array.isArray(object?.relevantChunks)
        ? object.relevantChunks.map((e: any) => RelevantChunk.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryCorpusResponse): unknown {
    const obj: any = {};
    if (message.relevantChunks?.length) {
      obj.relevantChunks = message.relevantChunks.map((e) => RelevantChunk.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryCorpusResponse>): QueryCorpusResponse {
    return QueryCorpusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryCorpusResponse>): QueryCorpusResponse {
    const message = createBaseQueryCorpusResponse();
    message.relevantChunks = object.relevantChunks?.map((e) => RelevantChunk.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRelevantChunk(): RelevantChunk {
  return { chunkRelevanceScore: 0, chunk: undefined };
}

export const RelevantChunk: MessageFns<RelevantChunk> = {
  encode(message: RelevantChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chunkRelevanceScore !== 0) {
      writer.uint32(13).float(message.chunkRelevanceScore);
    }
    if (message.chunk !== undefined) {
      Chunk.encode(message.chunk, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelevantChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelevantChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.chunkRelevanceScore = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chunk = Chunk.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelevantChunk {
    return {
      chunkRelevanceScore: isSet(object.chunkRelevanceScore) ? globalThis.Number(object.chunkRelevanceScore) : 0,
      chunk: isSet(object.chunk) ? Chunk.fromJSON(object.chunk) : undefined,
    };
  },

  toJSON(message: RelevantChunk): unknown {
    const obj: any = {};
    if (message.chunkRelevanceScore !== 0) {
      obj.chunkRelevanceScore = message.chunkRelevanceScore;
    }
    if (message.chunk !== undefined) {
      obj.chunk = Chunk.toJSON(message.chunk);
    }
    return obj;
  },

  create(base?: DeepPartial<RelevantChunk>): RelevantChunk {
    return RelevantChunk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RelevantChunk>): RelevantChunk {
    const message = createBaseRelevantChunk();
    message.chunkRelevanceScore = object.chunkRelevanceScore ?? 0;
    message.chunk = (object.chunk !== undefined && object.chunk !== null) ? Chunk.fromPartial(object.chunk) : undefined;
    return message;
  },
};

function createBaseCreateDocumentRequest(): CreateDocumentRequest {
  return { parent: "", document: undefined };
}

export const CreateDocumentRequest: MessageFns<CreateDocumentRequest> = {
  encode(message: CreateDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.document !== undefined) {
      Document.encode(message.document, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.document = Document.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDocumentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      document: isSet(object.document) ? Document.fromJSON(object.document) : undefined,
    };
  },

  toJSON(message: CreateDocumentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.document !== undefined) {
      obj.document = Document.toJSON(message.document);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDocumentRequest>): CreateDocumentRequest {
    return CreateDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDocumentRequest>): CreateDocumentRequest {
    const message = createBaseCreateDocumentRequest();
    message.parent = object.parent ?? "";
    message.document = (object.document !== undefined && object.document !== null)
      ? Document.fromPartial(object.document)
      : undefined;
    return message;
  },
};

function createBaseGetDocumentRequest(): GetDocumentRequest {
  return { name: "" };
}

export const GetDocumentRequest: MessageFns<GetDocumentRequest> = {
  encode(message: GetDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDocumentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDocumentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDocumentRequest>): GetDocumentRequest {
    return GetDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDocumentRequest>): GetDocumentRequest {
    const message = createBaseGetDocumentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateDocumentRequest(): UpdateDocumentRequest {
  return { document: undefined, updateMask: undefined };
}

export const UpdateDocumentRequest: MessageFns<UpdateDocumentRequest> = {
  encode(message: UpdateDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.document !== undefined) {
      Document.encode(message.document, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.document = Document.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDocumentRequest {
    return {
      document: isSet(object.document) ? Document.fromJSON(object.document) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDocumentRequest): unknown {
    const obj: any = {};
    if (message.document !== undefined) {
      obj.document = Document.toJSON(message.document);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDocumentRequest>): UpdateDocumentRequest {
    return UpdateDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDocumentRequest>): UpdateDocumentRequest {
    const message = createBaseUpdateDocumentRequest();
    message.document = (object.document !== undefined && object.document !== null)
      ? Document.fromPartial(object.document)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteDocumentRequest(): DeleteDocumentRequest {
  return { name: "", force: false };
}

export const DeleteDocumentRequest: MessageFns<DeleteDocumentRequest> = {
  encode(message: DeleteDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDocumentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteDocumentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteDocumentRequest>): DeleteDocumentRequest {
    return DeleteDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteDocumentRequest>): DeleteDocumentRequest {
    const message = createBaseDeleteDocumentRequest();
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseListDocumentsRequest(): ListDocumentsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListDocumentsRequest: MessageFns<ListDocumentsRequest> = {
  encode(message: ListDocumentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDocumentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDocumentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDocumentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDocumentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDocumentsRequest>): ListDocumentsRequest {
    return ListDocumentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDocumentsRequest>): ListDocumentsRequest {
    const message = createBaseListDocumentsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDocumentsResponse(): ListDocumentsResponse {
  return { documents: [], nextPageToken: "" };
}

export const ListDocumentsResponse: MessageFns<ListDocumentsResponse> = {
  encode(message: ListDocumentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documents) {
      Document.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDocumentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDocumentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.documents.push(Document.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDocumentsResponse {
    return {
      documents: globalThis.Array.isArray(object?.documents)
        ? object.documents.map((e: any) => Document.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDocumentsResponse): unknown {
    const obj: any = {};
    if (message.documents?.length) {
      obj.documents = message.documents.map((e) => Document.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDocumentsResponse>): ListDocumentsResponse {
    return ListDocumentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDocumentsResponse>): ListDocumentsResponse {
    const message = createBaseListDocumentsResponse();
    message.documents = object.documents?.map((e) => Document.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseQueryDocumentRequest(): QueryDocumentRequest {
  return { name: "", query: "", resultsCount: 0, metadataFilters: [] };
}

export const QueryDocumentRequest: MessageFns<QueryDocumentRequest> = {
  encode(message: QueryDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.resultsCount !== 0) {
      writer.uint32(24).int32(message.resultsCount);
    }
    for (const v of message.metadataFilters) {
      MetadataFilter.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.resultsCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metadataFilters.push(MetadataFilter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDocumentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      resultsCount: isSet(object.resultsCount) ? globalThis.Number(object.resultsCount) : 0,
      metadataFilters: globalThis.Array.isArray(object?.metadataFilters)
        ? object.metadataFilters.map((e: any) => MetadataFilter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryDocumentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.resultsCount !== 0) {
      obj.resultsCount = Math.round(message.resultsCount);
    }
    if (message.metadataFilters?.length) {
      obj.metadataFilters = message.metadataFilters.map((e) => MetadataFilter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryDocumentRequest>): QueryDocumentRequest {
    return QueryDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryDocumentRequest>): QueryDocumentRequest {
    const message = createBaseQueryDocumentRequest();
    message.name = object.name ?? "";
    message.query = object.query ?? "";
    message.resultsCount = object.resultsCount ?? 0;
    message.metadataFilters = object.metadataFilters?.map((e) => MetadataFilter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryDocumentResponse(): QueryDocumentResponse {
  return { relevantChunks: [] };
}

export const QueryDocumentResponse: MessageFns<QueryDocumentResponse> = {
  encode(message: QueryDocumentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.relevantChunks) {
      RelevantChunk.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDocumentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.relevantChunks.push(RelevantChunk.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDocumentResponse {
    return {
      relevantChunks: globalThis.Array.isArray(object?.relevantChunks)
        ? object.relevantChunks.map((e: any) => RelevantChunk.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryDocumentResponse): unknown {
    const obj: any = {};
    if (message.relevantChunks?.length) {
      obj.relevantChunks = message.relevantChunks.map((e) => RelevantChunk.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueryDocumentResponse>): QueryDocumentResponse {
    return QueryDocumentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryDocumentResponse>): QueryDocumentResponse {
    const message = createBaseQueryDocumentResponse();
    message.relevantChunks = object.relevantChunks?.map((e) => RelevantChunk.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateChunkRequest(): CreateChunkRequest {
  return { parent: "", chunk: undefined };
}

export const CreateChunkRequest: MessageFns<CreateChunkRequest> = {
  encode(message: CreateChunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.chunk !== undefined) {
      Chunk.encode(message.chunk, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateChunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateChunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chunk = Chunk.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateChunkRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      chunk: isSet(object.chunk) ? Chunk.fromJSON(object.chunk) : undefined,
    };
  },

  toJSON(message: CreateChunkRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.chunk !== undefined) {
      obj.chunk = Chunk.toJSON(message.chunk);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateChunkRequest>): CreateChunkRequest {
    return CreateChunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateChunkRequest>): CreateChunkRequest {
    const message = createBaseCreateChunkRequest();
    message.parent = object.parent ?? "";
    message.chunk = (object.chunk !== undefined && object.chunk !== null) ? Chunk.fromPartial(object.chunk) : undefined;
    return message;
  },
};

function createBaseBatchCreateChunksRequest(): BatchCreateChunksRequest {
  return { parent: "", requests: [] };
}

export const BatchCreateChunksRequest: MessageFns<BatchCreateChunksRequest> = {
  encode(message: BatchCreateChunksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.requests) {
      CreateChunkRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateChunksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateChunksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(CreateChunkRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateChunksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => CreateChunkRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateChunksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => CreateChunkRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateChunksRequest>): BatchCreateChunksRequest {
    return BatchCreateChunksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateChunksRequest>): BatchCreateChunksRequest {
    const message = createBaseBatchCreateChunksRequest();
    message.parent = object.parent ?? "";
    message.requests = object.requests?.map((e) => CreateChunkRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchCreateChunksResponse(): BatchCreateChunksResponse {
  return { chunks: [] };
}

export const BatchCreateChunksResponse: MessageFns<BatchCreateChunksResponse> = {
  encode(message: BatchCreateChunksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.chunks) {
      Chunk.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateChunksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateChunksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chunks.push(Chunk.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateChunksResponse {
    return { chunks: globalThis.Array.isArray(object?.chunks) ? object.chunks.map((e: any) => Chunk.fromJSON(e)) : [] };
  },

  toJSON(message: BatchCreateChunksResponse): unknown {
    const obj: any = {};
    if (message.chunks?.length) {
      obj.chunks = message.chunks.map((e) => Chunk.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateChunksResponse>): BatchCreateChunksResponse {
    return BatchCreateChunksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateChunksResponse>): BatchCreateChunksResponse {
    const message = createBaseBatchCreateChunksResponse();
    message.chunks = object.chunks?.map((e) => Chunk.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetChunkRequest(): GetChunkRequest {
  return { name: "" };
}

export const GetChunkRequest: MessageFns<GetChunkRequest> = {
  encode(message: GetChunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChunkRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetChunkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetChunkRequest>): GetChunkRequest {
    return GetChunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetChunkRequest>): GetChunkRequest {
    const message = createBaseGetChunkRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateChunkRequest(): UpdateChunkRequest {
  return { chunk: undefined, updateMask: undefined };
}

export const UpdateChunkRequest: MessageFns<UpdateChunkRequest> = {
  encode(message: UpdateChunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chunk !== undefined) {
      Chunk.encode(message.chunk, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateChunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateChunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chunk = Chunk.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateChunkRequest {
    return {
      chunk: isSet(object.chunk) ? Chunk.fromJSON(object.chunk) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateChunkRequest): unknown {
    const obj: any = {};
    if (message.chunk !== undefined) {
      obj.chunk = Chunk.toJSON(message.chunk);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateChunkRequest>): UpdateChunkRequest {
    return UpdateChunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateChunkRequest>): UpdateChunkRequest {
    const message = createBaseUpdateChunkRequest();
    message.chunk = (object.chunk !== undefined && object.chunk !== null) ? Chunk.fromPartial(object.chunk) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseBatchUpdateChunksRequest(): BatchUpdateChunksRequest {
  return { parent: "", requests: [] };
}

export const BatchUpdateChunksRequest: MessageFns<BatchUpdateChunksRequest> = {
  encode(message: BatchUpdateChunksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.requests) {
      UpdateChunkRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateChunksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateChunksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(UpdateChunkRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateChunksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => UpdateChunkRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchUpdateChunksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => UpdateChunkRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateChunksRequest>): BatchUpdateChunksRequest {
    return BatchUpdateChunksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateChunksRequest>): BatchUpdateChunksRequest {
    const message = createBaseBatchUpdateChunksRequest();
    message.parent = object.parent ?? "";
    message.requests = object.requests?.map((e) => UpdateChunkRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchUpdateChunksResponse(): BatchUpdateChunksResponse {
  return { chunks: [] };
}

export const BatchUpdateChunksResponse: MessageFns<BatchUpdateChunksResponse> = {
  encode(message: BatchUpdateChunksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.chunks) {
      Chunk.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchUpdateChunksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchUpdateChunksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chunks.push(Chunk.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchUpdateChunksResponse {
    return { chunks: globalThis.Array.isArray(object?.chunks) ? object.chunks.map((e: any) => Chunk.fromJSON(e)) : [] };
  },

  toJSON(message: BatchUpdateChunksResponse): unknown {
    const obj: any = {};
    if (message.chunks?.length) {
      obj.chunks = message.chunks.map((e) => Chunk.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchUpdateChunksResponse>): BatchUpdateChunksResponse {
    return BatchUpdateChunksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchUpdateChunksResponse>): BatchUpdateChunksResponse {
    const message = createBaseBatchUpdateChunksResponse();
    message.chunks = object.chunks?.map((e) => Chunk.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteChunkRequest(): DeleteChunkRequest {
  return { name: "" };
}

export const DeleteChunkRequest: MessageFns<DeleteChunkRequest> = {
  encode(message: DeleteChunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteChunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChunkRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteChunkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteChunkRequest>): DeleteChunkRequest {
    return DeleteChunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteChunkRequest>): DeleteChunkRequest {
    const message = createBaseDeleteChunkRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseBatchDeleteChunksRequest(): BatchDeleteChunksRequest {
  return { parent: "", requests: [] };
}

export const BatchDeleteChunksRequest: MessageFns<BatchDeleteChunksRequest> = {
  encode(message: BatchDeleteChunksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.requests) {
      DeleteChunkRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeleteChunksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteChunksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(DeleteChunkRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteChunksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => DeleteChunkRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchDeleteChunksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => DeleteChunkRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteChunksRequest>): BatchDeleteChunksRequest {
    return BatchDeleteChunksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteChunksRequest>): BatchDeleteChunksRequest {
    const message = createBaseBatchDeleteChunksRequest();
    message.parent = object.parent ?? "";
    message.requests = object.requests?.map((e) => DeleteChunkRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListChunksRequest(): ListChunksRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListChunksRequest: MessageFns<ListChunksRequest> = {
  encode(message: ListChunksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChunksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChunksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChunksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListChunksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChunksRequest>): ListChunksRequest {
    return ListChunksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChunksRequest>): ListChunksRequest {
    const message = createBaseListChunksRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListChunksResponse(): ListChunksResponse {
  return { chunks: [], nextPageToken: "" };
}

export const ListChunksResponse: MessageFns<ListChunksResponse> = {
  encode(message: ListChunksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.chunks) {
      Chunk.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListChunksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListChunksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chunks.push(Chunk.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListChunksResponse {
    return {
      chunks: globalThis.Array.isArray(object?.chunks) ? object.chunks.map((e: any) => Chunk.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListChunksResponse): unknown {
    const obj: any = {};
    if (message.chunks?.length) {
      obj.chunks = message.chunks.map((e) => Chunk.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListChunksResponse>): ListChunksResponse {
    return ListChunksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListChunksResponse>): ListChunksResponse {
    const message = createBaseListChunksResponse();
    message.chunks = object.chunks?.map((e) => Chunk.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/** An API for semantic search over a corpus of user uploaded content. */
export type RetrieverServiceDefinition = typeof RetrieverServiceDefinition;
export const RetrieverServiceDefinition = {
  name: "RetrieverService",
  fullName: "google.ai.generativelanguage.v1beta.RetrieverService",
  methods: {
    /** Creates an empty `Corpus`. */
    createCorpus: {
      name: "CreateCorpus",
      requestType: CreateCorpusRequest,
      requestStream: false,
      responseType: Corpus,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 99, 111, 114, 112, 117, 115])],
          578365826: [
            Buffer.from([
              25,
              58,
              6,
              99,
              111,
              114,
              112,
              117,
              115,
              34,
              15,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
            ]),
          ],
        },
      },
    },
    /** Gets information about a specific `Corpus`. */
    getCorpus: {
      name: "GetCorpus",
      requestType: GetCorpusRequest,
      requestStream: false,
      responseType: Corpus,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              26,
              18,
              24,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates a `Corpus`. */
    updateCorpus: {
      name: "UpdateCorpus",
      requestType: UpdateCorpusRequest,
      requestStream: false,
      responseType: Corpus,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([18, 99, 111, 114, 112, 117, 115, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              41,
              58,
              6,
              99,
              111,
              114,
              112,
              117,
              115,
              50,
              31,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              99,
              111,
              114,
              112,
              117,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a `Corpus`. */
    deleteCorpus: {
      name: "DeleteCorpus",
      requestType: DeleteCorpusRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              26,
              42,
              24,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all `Corpora` owned by the user. */
    listCorpora: {
      name: "ListCorpora",
      requestType: ListCorporaRequest,
      requestStream: false,
      responseType: ListCorporaResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [Buffer.from([17, 18, 15, 47, 118, 49, 98, 101, 116, 97, 47, 99, 111, 114, 112, 111, 114, 97])],
        },
      },
    },
    /** Performs semantic search over a `Corpus`. */
    queryCorpus: {
      name: "QueryCorpus",
      requestType: QueryCorpusRequest,
      requestStream: false,
      responseType: QueryCorpusResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              35,
              58,
              1,
              42,
              34,
              30,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              58,
              113,
              117,
              101,
              114,
              121,
            ]),
          ],
        },
      },
    },
    /** Creates an empty `Document`. */
    createDocument: {
      name: "CreateDocument",
      requestType: CreateDocumentRequest,
      requestStream: false,
      responseType: Document,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 112, 97, 114, 101, 110, 116, 44, 100, 111, 99, 117, 109, 101, 110, 116])],
          578365826: [
            Buffer.from([
              48,
              58,
              8,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              34,
              36,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets information about a specific `Document`. */
    getDocument: {
      name: "GetDocument",
      requestType: GetDocumentRequest,
      requestStream: false,
      responseType: Document,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              38,
              18,
              36,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates a `Document`. */
    updateDocument: {
      name: "UpdateDocument",
      requestType: UpdateDocumentRequest,
      requestStream: false,
      responseType: Document,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              57,
              58,
              8,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              50,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a `Document`. */
    deleteDocument: {
      name: "DeleteDocument",
      requestType: DeleteDocumentRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              38,
              42,
              36,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists all `Document`s in a `Corpus`. */
    listDocuments: {
      name: "ListDocuments",
      requestType: ListDocumentsRequest,
      requestStream: false,
      responseType: ListDocumentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              38,
              18,
              36,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              125,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Performs semantic search over a `Document`. */
    queryDocument: {
      name: "QueryDocument",
      requestType: QueryDocumentRequest,
      requestStream: false,
      responseType: QueryDocumentResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              47,
              58,
              1,
              42,
              34,
              42,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              113,
              117,
              101,
              114,
              121,
            ]),
          ],
        },
      },
    },
    /** Creates a `Chunk`. */
    createChunk: {
      name: "CreateChunk",
      requestType: CreateChunkRequest,
      requestStream: false,
      responseType: Chunk,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 112, 97, 114, 101, 110, 116, 44, 99, 104, 117, 110, 107])],
          578365826: [
            Buffer.from([
              54,
              58,
              5,
              99,
              104,
              117,
              110,
              107,
              34,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              117,
              110,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /** Batch create `Chunk`s. */
    batchCreateChunks: {
      name: "BatchCreateChunks",
      requestType: BatchCreateChunksRequest,
      requestStream: false,
      responseType: BatchCreateChunksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              62,
              58,
              1,
              42,
              34,
              57,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              117,
              110,
              107,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              67,
              114,
              101,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Gets information about a specific `Chunk`. */
    getChunk: {
      name: "GetChunk",
      requestType: GetChunkRequest,
      requestStream: false,
      responseType: Chunk,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              117,
              110,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates a `Chunk`. */
    updateChunk: {
      name: "UpdateChunk",
      requestType: UpdateChunkRequest,
      requestStream: false,
      responseType: Chunk,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 99, 104, 117, 110, 107, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              60,
              58,
              5,
              99,
              104,
              117,
              110,
              107,
              50,
              51,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              99,
              104,
              117,
              110,
              107,
              46,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              117,
              110,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Batch update `Chunk`s. */
    batchUpdateChunks: {
      name: "BatchUpdateChunks",
      requestType: BatchUpdateChunksRequest,
      requestStream: false,
      responseType: BatchUpdateChunksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              62,
              58,
              1,
              42,
              34,
              57,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              117,
              110,
              107,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              85,
              112,
              100,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Deletes a `Chunk`. */
    deleteChunk: {
      name: "DeleteChunk",
      requestType: DeleteChunkRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              42,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              99,
              104,
              117,
              110,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Batch delete `Chunk`s. */
    batchDeleteChunks: {
      name: "BatchDeleteChunks",
      requestType: BatchDeleteChunksRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              62,
              58,
              1,
              42,
              34,
              57,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              117,
              110,
              107,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              68,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Lists all `Chunk`s in a `Document`. */
    listChunks: {
      name: "ListChunks",
      requestType: ListChunksRequest,
      requestStream: false,
      responseType: ListChunksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              99,
              111,
              114,
              112,
              111,
              114,
              97,
              47,
              42,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              99,
              104,
              117,
              110,
              107,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface RetrieverServiceImplementation<CallContextExt = {}> {
  /** Creates an empty `Corpus`. */
  createCorpus(request: CreateCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Corpus>>;
  /** Gets information about a specific `Corpus`. */
  getCorpus(request: GetCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Corpus>>;
  /** Updates a `Corpus`. */
  updateCorpus(request: UpdateCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Corpus>>;
  /** Deletes a `Corpus`. */
  deleteCorpus(request: DeleteCorpusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Lists all `Corpora` owned by the user. */
  listCorpora(
    request: ListCorporaRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCorporaResponse>>;
  /** Performs semantic search over a `Corpus`. */
  queryCorpus(
    request: QueryCorpusRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryCorpusResponse>>;
  /** Creates an empty `Document`. */
  createDocument(request: CreateDocumentRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Document>>;
  /** Gets information about a specific `Document`. */
  getDocument(request: GetDocumentRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Document>>;
  /** Updates a `Document`. */
  updateDocument(request: UpdateDocumentRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Document>>;
  /** Deletes a `Document`. */
  deleteDocument(request: DeleteDocumentRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Lists all `Document`s in a `Corpus`. */
  listDocuments(
    request: ListDocumentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDocumentsResponse>>;
  /** Performs semantic search over a `Document`. */
  queryDocument(
    request: QueryDocumentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueryDocumentResponse>>;
  /** Creates a `Chunk`. */
  createChunk(request: CreateChunkRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Chunk>>;
  /** Batch create `Chunk`s. */
  batchCreateChunks(
    request: BatchCreateChunksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchCreateChunksResponse>>;
  /** Gets information about a specific `Chunk`. */
  getChunk(request: GetChunkRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Chunk>>;
  /** Updates a `Chunk`. */
  updateChunk(request: UpdateChunkRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Chunk>>;
  /** Batch update `Chunk`s. */
  batchUpdateChunks(
    request: BatchUpdateChunksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchUpdateChunksResponse>>;
  /** Deletes a `Chunk`. */
  deleteChunk(request: DeleteChunkRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Batch delete `Chunk`s. */
  batchDeleteChunks(
    request: BatchDeleteChunksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Lists all `Chunk`s in a `Document`. */
  listChunks(
    request: ListChunksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListChunksResponse>>;
}

export interface RetrieverServiceClient<CallOptionsExt = {}> {
  /** Creates an empty `Corpus`. */
  createCorpus(request: DeepPartial<CreateCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Corpus>;
  /** Gets information about a specific `Corpus`. */
  getCorpus(request: DeepPartial<GetCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Corpus>;
  /** Updates a `Corpus`. */
  updateCorpus(request: DeepPartial<UpdateCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Corpus>;
  /** Deletes a `Corpus`. */
  deleteCorpus(request: DeepPartial<DeleteCorpusRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Lists all `Corpora` owned by the user. */
  listCorpora(
    request: DeepPartial<ListCorporaRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCorporaResponse>;
  /** Performs semantic search over a `Corpus`. */
  queryCorpus(
    request: DeepPartial<QueryCorpusRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryCorpusResponse>;
  /** Creates an empty `Document`. */
  createDocument(
    request: DeepPartial<CreateDocumentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Document>;
  /** Gets information about a specific `Document`. */
  getDocument(request: DeepPartial<GetDocumentRequest>, options?: CallOptions & CallOptionsExt): Promise<Document>;
  /** Updates a `Document`. */
  updateDocument(
    request: DeepPartial<UpdateDocumentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Document>;
  /** Deletes a `Document`. */
  deleteDocument(request: DeepPartial<DeleteDocumentRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Lists all `Document`s in a `Corpus`. */
  listDocuments(
    request: DeepPartial<ListDocumentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDocumentsResponse>;
  /** Performs semantic search over a `Document`. */
  queryDocument(
    request: DeepPartial<QueryDocumentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueryDocumentResponse>;
  /** Creates a `Chunk`. */
  createChunk(request: DeepPartial<CreateChunkRequest>, options?: CallOptions & CallOptionsExt): Promise<Chunk>;
  /** Batch create `Chunk`s. */
  batchCreateChunks(
    request: DeepPartial<BatchCreateChunksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchCreateChunksResponse>;
  /** Gets information about a specific `Chunk`. */
  getChunk(request: DeepPartial<GetChunkRequest>, options?: CallOptions & CallOptionsExt): Promise<Chunk>;
  /** Updates a `Chunk`. */
  updateChunk(request: DeepPartial<UpdateChunkRequest>, options?: CallOptions & CallOptionsExt): Promise<Chunk>;
  /** Batch update `Chunk`s. */
  batchUpdateChunks(
    request: DeepPartial<BatchUpdateChunksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchUpdateChunksResponse>;
  /** Deletes a `Chunk`. */
  deleteChunk(request: DeepPartial<DeleteChunkRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Batch delete `Chunk`s. */
  batchDeleteChunks(
    request: DeepPartial<BatchDeleteChunksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Lists all `Chunk`s in a `Document`. */
  listChunks(
    request: DeepPartial<ListChunksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListChunksResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
