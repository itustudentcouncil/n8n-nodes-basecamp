// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ai/generativelanguage/v1beta/tuned_model.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.ai.generativelanguage.v1beta";

/** A fine-tuned model created using ModelService.CreateTunedModel. */
export interface TunedModel {
  /**
   * Optional. TunedModel to use as the starting point for training the new
   * model.
   */
  tunedModelSource?:
    | TunedModelSource
    | undefined;
  /**
   * Immutable. The name of the `Model` to tune.
   * Example: `models/gemini-1.5-flash-001`
   */
  baseModel?:
    | string
    | undefined;
  /**
   * Output only. The tuned model name. A unique name will be generated on
   * create. Example: `tunedModels/az2mb0bpw6i` If display_name is set on
   * create, the id portion of the name will be set by concatenating the words
   * of the display_name with hyphens and adding a random portion for
   * uniqueness.
   *
   * Example:
   *
   *  * display_name = `Sentence Translator`
   *  * name = `tunedModels/sentence-translator-u3b7m`
   */
  name: string;
  /**
   * Optional. The name to display for this model in user interfaces.
   * The display name must be up to 40 characters including spaces.
   */
  displayName: string;
  /** Optional. A short description of this model. */
  description: string;
  /**
   * Optional. Controls the randomness of the output.
   *
   * Values can range over `[0.0,1.0]`, inclusive. A value closer to `1.0` will
   * produce responses that are more varied, while a value closer to `0.0` will
   * typically result in less surprising responses from the model.
   *
   * This value specifies default to be the one used by the base model while
   * creating the model.
   */
  temperature?:
    | number
    | undefined;
  /**
   * Optional. For Nucleus sampling.
   *
   * Nucleus sampling considers the smallest set of tokens whose probability
   * sum is at least `top_p`.
   *
   * This value specifies default to be the one used by the base model while
   * creating the model.
   */
  topP?:
    | number
    | undefined;
  /**
   * Optional. For Top-k sampling.
   *
   * Top-k sampling considers the set of `top_k` most probable tokens.
   * This value specifies default to be used by the backend while making the
   * call to the model.
   *
   * This value specifies default to be the one used by the base model while
   * creating the model.
   */
  topK?:
    | number
    | undefined;
  /** Output only. The state of the tuned model. */
  state: TunedModel_State;
  /** Output only. The timestamp when this model was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when this model was updated. */
  updateTime:
    | Date
    | undefined;
  /** Required. The tuning task that creates the tuned model. */
  tuningTask:
    | TuningTask
    | undefined;
  /** Optional. List of project numbers that have read access to the tuned model. */
  readerProjectNumbers: Long[];
}

/** The state of the tuned model. */
export enum TunedModel_State {
  /** STATE_UNSPECIFIED - The default value. This value is unused. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The model is being created. */
  CREATING = 1,
  /** ACTIVE - The model is ready to be used. */
  ACTIVE = 2,
  /** FAILED - The model failed to be created. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function tunedModel_StateFromJSON(object: any): TunedModel_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return TunedModel_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return TunedModel_State.CREATING;
    case 2:
    case "ACTIVE":
      return TunedModel_State.ACTIVE;
    case 3:
    case "FAILED":
      return TunedModel_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TunedModel_State.UNRECOGNIZED;
  }
}

export function tunedModel_StateToJSON(object: TunedModel_State): string {
  switch (object) {
    case TunedModel_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case TunedModel_State.CREATING:
      return "CREATING";
    case TunedModel_State.ACTIVE:
      return "ACTIVE";
    case TunedModel_State.FAILED:
      return "FAILED";
    case TunedModel_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Tuned model as a source for training a new model. */
export interface TunedModelSource {
  /**
   * Immutable. The name of the `TunedModel` to use as the starting point for
   * training the new model.
   * Example: `tunedModels/my-tuned-model`
   */
  tunedModel: string;
  /**
   * Output only. The name of the base `Model` this `TunedModel` was tuned from.
   * Example: `models/gemini-1.5-flash-001`
   */
  baseModel: string;
}

/** Tuning tasks that create tuned models. */
export interface TuningTask {
  /** Output only. The timestamp when tuning this model started. */
  startTime:
    | Date
    | undefined;
  /** Output only. The timestamp when tuning this model completed. */
  completeTime:
    | Date
    | undefined;
  /** Output only. Metrics collected during tuning. */
  snapshots: TuningSnapshot[];
  /** Required. Input only. Immutable. The model training data. */
  trainingData:
    | Dataset
    | undefined;
  /**
   * Immutable. Hyperparameters controlling the tuning process. If not provided,
   * default values will be used.
   */
  hyperparameters: Hyperparameters | undefined;
}

/**
 * Hyperparameters controlling the tuning process. Read more at
 * https://ai.google.dev/docs/model_tuning_guidance
 */
export interface Hyperparameters {
  /**
   * Optional. Immutable. The learning rate hyperparameter for tuning.
   * If not set, a default of 0.001 or 0.0002 will be calculated based on the
   * number of training examples.
   */
  learningRate?:
    | number
    | undefined;
  /**
   * Optional. Immutable. The learning rate multiplier is used to calculate a
   * final learning_rate based on the default (recommended) value. Actual
   * learning rate := learning_rate_multiplier * default learning rate Default
   * learning rate is dependent on base model and dataset size. If not set, a
   * default of 1.0 will be used.
   */
  learningRateMultiplier?:
    | number
    | undefined;
  /**
   * Immutable. The number of training epochs. An epoch is one pass through the
   * training data. If not set, a default of 5 will be used.
   */
  epochCount?:
    | number
    | undefined;
  /**
   * Immutable. The batch size hyperparameter for tuning.
   * If not set, a default of 4 or 16 will be used based on the number of
   * training examples.
   */
  batchSize?: number | undefined;
}

/** Dataset for training or validation. */
export interface Dataset {
  /** Optional. Inline examples. */
  examples?: TuningExamples | undefined;
}

/** A set of tuning examples. Can be training or validation data. */
export interface TuningExamples {
  /**
   * Required. The examples. Example input can be for text or discuss, but all
   * examples in a set must be of the same type.
   */
  examples: TuningExample[];
}

/** A single example for tuning. */
export interface TuningExample {
  /** Optional. Text model input. */
  textInput?:
    | string
    | undefined;
  /** Required. The expected model output. */
  output: string;
}

/** Record for a single tuning step. */
export interface TuningSnapshot {
  /** Output only. The tuning step. */
  step: number;
  /** Output only. The epoch this step was part of. */
  epoch: number;
  /** Output only. The mean loss of the training examples for this step. */
  meanLoss: number;
  /** Output only. The timestamp when this metric was computed. */
  computeTime: Date | undefined;
}

function createBaseTunedModel(): TunedModel {
  return {
    tunedModelSource: undefined,
    baseModel: undefined,
    name: "",
    displayName: "",
    description: "",
    temperature: undefined,
    topP: undefined,
    topK: undefined,
    state: 0,
    createTime: undefined,
    updateTime: undefined,
    tuningTask: undefined,
    readerProjectNumbers: [],
  };
}

export const TunedModel: MessageFns<TunedModel> = {
  encode(message: TunedModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunedModelSource !== undefined) {
      TunedModelSource.encode(message.tunedModelSource, writer.uint32(26).fork()).join();
    }
    if (message.baseModel !== undefined) {
      writer.uint32(34).string(message.baseModel);
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.temperature !== undefined) {
      writer.uint32(93).float(message.temperature);
    }
    if (message.topP !== undefined) {
      writer.uint32(101).float(message.topP);
    }
    if (message.topK !== undefined) {
      writer.uint32(104).int32(message.topK);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    if (message.tuningTask !== undefined) {
      TuningTask.encode(message.tuningTask, writer.uint32(82).fork()).join();
    }
    writer.uint32(114).fork();
    for (const v of message.readerProjectNumbers) {
      writer.int64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunedModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunedModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tunedModelSource = TunedModelSource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.baseModel = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.temperature = reader.float();
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.topP = reader.float();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.topK = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.tuningTask = TuningTask.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag === 112) {
            message.readerProjectNumbers.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.readerProjectNumbers.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunedModel {
    return {
      tunedModelSource: isSet(object.tunedModelSource) ? TunedModelSource.fromJSON(object.tunedModelSource) : undefined,
      baseModel: isSet(object.baseModel) ? globalThis.String(object.baseModel) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : undefined,
      topK: isSet(object.topK) ? globalThis.Number(object.topK) : undefined,
      state: isSet(object.state) ? tunedModel_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      tuningTask: isSet(object.tuningTask) ? TuningTask.fromJSON(object.tuningTask) : undefined,
      readerProjectNumbers: globalThis.Array.isArray(object?.readerProjectNumbers)
        ? object.readerProjectNumbers.map((e: any) => Long.fromValue(e))
        : [],
    };
  },

  toJSON(message: TunedModel): unknown {
    const obj: any = {};
    if (message.tunedModelSource !== undefined) {
      obj.tunedModelSource = TunedModelSource.toJSON(message.tunedModelSource);
    }
    if (message.baseModel !== undefined) {
      obj.baseModel = message.baseModel;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    if (message.topP !== undefined) {
      obj.topP = message.topP;
    }
    if (message.topK !== undefined) {
      obj.topK = Math.round(message.topK);
    }
    if (message.state !== 0) {
      obj.state = tunedModel_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.tuningTask !== undefined) {
      obj.tuningTask = TuningTask.toJSON(message.tuningTask);
    }
    if (message.readerProjectNumbers?.length) {
      obj.readerProjectNumbers = message.readerProjectNumbers.map((e) => (e || Long.ZERO).toString());
    }
    return obj;
  },

  create(base?: DeepPartial<TunedModel>): TunedModel {
    return TunedModel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunedModel>): TunedModel {
    const message = createBaseTunedModel();
    message.tunedModelSource = (object.tunedModelSource !== undefined && object.tunedModelSource !== null)
      ? TunedModelSource.fromPartial(object.tunedModelSource)
      : undefined;
    message.baseModel = object.baseModel ?? undefined;
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.temperature = object.temperature ?? undefined;
    message.topP = object.topP ?? undefined;
    message.topK = object.topK ?? undefined;
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.tuningTask = (object.tuningTask !== undefined && object.tuningTask !== null)
      ? TuningTask.fromPartial(object.tuningTask)
      : undefined;
    message.readerProjectNumbers = object.readerProjectNumbers?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBaseTunedModelSource(): TunedModelSource {
  return { tunedModel: "", baseModel: "" };
}

export const TunedModelSource: MessageFns<TunedModelSource> = {
  encode(message: TunedModelSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tunedModel !== "") {
      writer.uint32(10).string(message.tunedModel);
    }
    if (message.baseModel !== "") {
      writer.uint32(18).string(message.baseModel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TunedModelSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTunedModelSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tunedModel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.baseModel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TunedModelSource {
    return {
      tunedModel: isSet(object.tunedModel) ? globalThis.String(object.tunedModel) : "",
      baseModel: isSet(object.baseModel) ? globalThis.String(object.baseModel) : "",
    };
  },

  toJSON(message: TunedModelSource): unknown {
    const obj: any = {};
    if (message.tunedModel !== "") {
      obj.tunedModel = message.tunedModel;
    }
    if (message.baseModel !== "") {
      obj.baseModel = message.baseModel;
    }
    return obj;
  },

  create(base?: DeepPartial<TunedModelSource>): TunedModelSource {
    return TunedModelSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TunedModelSource>): TunedModelSource {
    const message = createBaseTunedModelSource();
    message.tunedModel = object.tunedModel ?? "";
    message.baseModel = object.baseModel ?? "";
    return message;
  },
};

function createBaseTuningTask(): TuningTask {
  return {
    startTime: undefined,
    completeTime: undefined,
    snapshots: [],
    trainingData: undefined,
    hyperparameters: undefined,
  };
}

export const TuningTask: MessageFns<TuningTask> = {
  encode(message: TuningTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.completeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.completeTime), writer.uint32(18).fork()).join();
    }
    for (const v of message.snapshots) {
      TuningSnapshot.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.trainingData !== undefined) {
      Dataset.encode(message.trainingData, writer.uint32(34).fork()).join();
    }
    if (message.hyperparameters !== undefined) {
      Hyperparameters.encode(message.hyperparameters, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuningTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuningTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.completeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.snapshots.push(TuningSnapshot.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.trainingData = Dataset.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hyperparameters = Hyperparameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuningTask {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      completeTime: isSet(object.completeTime) ? fromJsonTimestamp(object.completeTime) : undefined,
      snapshots: globalThis.Array.isArray(object?.snapshots)
        ? object.snapshots.map((e: any) => TuningSnapshot.fromJSON(e))
        : [],
      trainingData: isSet(object.trainingData) ? Dataset.fromJSON(object.trainingData) : undefined,
      hyperparameters: isSet(object.hyperparameters) ? Hyperparameters.fromJSON(object.hyperparameters) : undefined,
    };
  },

  toJSON(message: TuningTask): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.completeTime !== undefined) {
      obj.completeTime = message.completeTime.toISOString();
    }
    if (message.snapshots?.length) {
      obj.snapshots = message.snapshots.map((e) => TuningSnapshot.toJSON(e));
    }
    if (message.trainingData !== undefined) {
      obj.trainingData = Dataset.toJSON(message.trainingData);
    }
    if (message.hyperparameters !== undefined) {
      obj.hyperparameters = Hyperparameters.toJSON(message.hyperparameters);
    }
    return obj;
  },

  create(base?: DeepPartial<TuningTask>): TuningTask {
    return TuningTask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TuningTask>): TuningTask {
    const message = createBaseTuningTask();
    message.startTime = object.startTime ?? undefined;
    message.completeTime = object.completeTime ?? undefined;
    message.snapshots = object.snapshots?.map((e) => TuningSnapshot.fromPartial(e)) || [];
    message.trainingData = (object.trainingData !== undefined && object.trainingData !== null)
      ? Dataset.fromPartial(object.trainingData)
      : undefined;
    message.hyperparameters = (object.hyperparameters !== undefined && object.hyperparameters !== null)
      ? Hyperparameters.fromPartial(object.hyperparameters)
      : undefined;
    return message;
  },
};

function createBaseHyperparameters(): Hyperparameters {
  return { learningRate: undefined, learningRateMultiplier: undefined, epochCount: undefined, batchSize: undefined };
}

export const Hyperparameters: MessageFns<Hyperparameters> = {
  encode(message: Hyperparameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.learningRate !== undefined) {
      writer.uint32(133).float(message.learningRate);
    }
    if (message.learningRateMultiplier !== undefined) {
      writer.uint32(141).float(message.learningRateMultiplier);
    }
    if (message.epochCount !== undefined) {
      writer.uint32(112).int32(message.epochCount);
    }
    if (message.batchSize !== undefined) {
      writer.uint32(120).int32(message.batchSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hyperparameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHyperparameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 16:
          if (tag !== 133) {
            break;
          }

          message.learningRate = reader.float();
          continue;
        case 17:
          if (tag !== 141) {
            break;
          }

          message.learningRateMultiplier = reader.float();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.epochCount = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.batchSize = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hyperparameters {
    return {
      learningRate: isSet(object.learningRate) ? globalThis.Number(object.learningRate) : undefined,
      learningRateMultiplier: isSet(object.learningRateMultiplier)
        ? globalThis.Number(object.learningRateMultiplier)
        : undefined,
      epochCount: isSet(object.epochCount) ? globalThis.Number(object.epochCount) : undefined,
      batchSize: isSet(object.batchSize) ? globalThis.Number(object.batchSize) : undefined,
    };
  },

  toJSON(message: Hyperparameters): unknown {
    const obj: any = {};
    if (message.learningRate !== undefined) {
      obj.learningRate = message.learningRate;
    }
    if (message.learningRateMultiplier !== undefined) {
      obj.learningRateMultiplier = message.learningRateMultiplier;
    }
    if (message.epochCount !== undefined) {
      obj.epochCount = Math.round(message.epochCount);
    }
    if (message.batchSize !== undefined) {
      obj.batchSize = Math.round(message.batchSize);
    }
    return obj;
  },

  create(base?: DeepPartial<Hyperparameters>): Hyperparameters {
    return Hyperparameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Hyperparameters>): Hyperparameters {
    const message = createBaseHyperparameters();
    message.learningRate = object.learningRate ?? undefined;
    message.learningRateMultiplier = object.learningRateMultiplier ?? undefined;
    message.epochCount = object.epochCount ?? undefined;
    message.batchSize = object.batchSize ?? undefined;
    return message;
  },
};

function createBaseDataset(): Dataset {
  return { examples: undefined };
}

export const Dataset: MessageFns<Dataset> = {
  encode(message: Dataset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.examples !== undefined) {
      TuningExamples.encode(message.examples, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dataset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.examples = TuningExamples.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dataset {
    return { examples: isSet(object.examples) ? TuningExamples.fromJSON(object.examples) : undefined };
  },

  toJSON(message: Dataset): unknown {
    const obj: any = {};
    if (message.examples !== undefined) {
      obj.examples = TuningExamples.toJSON(message.examples);
    }
    return obj;
  },

  create(base?: DeepPartial<Dataset>): Dataset {
    return Dataset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Dataset>): Dataset {
    const message = createBaseDataset();
    message.examples = (object.examples !== undefined && object.examples !== null)
      ? TuningExamples.fromPartial(object.examples)
      : undefined;
    return message;
  },
};

function createBaseTuningExamples(): TuningExamples {
  return { examples: [] };
}

export const TuningExamples: MessageFns<TuningExamples> = {
  encode(message: TuningExamples, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.examples) {
      TuningExample.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuningExamples {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuningExamples();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.examples.push(TuningExample.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuningExamples {
    return {
      examples: globalThis.Array.isArray(object?.examples)
        ? object.examples.map((e: any) => TuningExample.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TuningExamples): unknown {
    const obj: any = {};
    if (message.examples?.length) {
      obj.examples = message.examples.map((e) => TuningExample.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TuningExamples>): TuningExamples {
    return TuningExamples.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TuningExamples>): TuningExamples {
    const message = createBaseTuningExamples();
    message.examples = object.examples?.map((e) => TuningExample.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTuningExample(): TuningExample {
  return { textInput: undefined, output: "" };
}

export const TuningExample: MessageFns<TuningExample> = {
  encode(message: TuningExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textInput !== undefined) {
      writer.uint32(10).string(message.textInput);
    }
    if (message.output !== "") {
      writer.uint32(26).string(message.output);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuningExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuningExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textInput = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.output = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuningExample {
    return {
      textInput: isSet(object.textInput) ? globalThis.String(object.textInput) : undefined,
      output: isSet(object.output) ? globalThis.String(object.output) : "",
    };
  },

  toJSON(message: TuningExample): unknown {
    const obj: any = {};
    if (message.textInput !== undefined) {
      obj.textInput = message.textInput;
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    return obj;
  },

  create(base?: DeepPartial<TuningExample>): TuningExample {
    return TuningExample.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TuningExample>): TuningExample {
    const message = createBaseTuningExample();
    message.textInput = object.textInput ?? undefined;
    message.output = object.output ?? "";
    return message;
  },
};

function createBaseTuningSnapshot(): TuningSnapshot {
  return { step: 0, epoch: 0, meanLoss: 0, computeTime: undefined };
}

export const TuningSnapshot: MessageFns<TuningSnapshot> = {
  encode(message: TuningSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.step !== 0) {
      writer.uint32(8).int32(message.step);
    }
    if (message.epoch !== 0) {
      writer.uint32(16).int32(message.epoch);
    }
    if (message.meanLoss !== 0) {
      writer.uint32(29).float(message.meanLoss);
    }
    if (message.computeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.computeTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TuningSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTuningSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.step = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.epoch = reader.int32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.meanLoss = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.computeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TuningSnapshot {
    return {
      step: isSet(object.step) ? globalThis.Number(object.step) : 0,
      epoch: isSet(object.epoch) ? globalThis.Number(object.epoch) : 0,
      meanLoss: isSet(object.meanLoss) ? globalThis.Number(object.meanLoss) : 0,
      computeTime: isSet(object.computeTime) ? fromJsonTimestamp(object.computeTime) : undefined,
    };
  },

  toJSON(message: TuningSnapshot): unknown {
    const obj: any = {};
    if (message.step !== 0) {
      obj.step = Math.round(message.step);
    }
    if (message.epoch !== 0) {
      obj.epoch = Math.round(message.epoch);
    }
    if (message.meanLoss !== 0) {
      obj.meanLoss = message.meanLoss;
    }
    if (message.computeTime !== undefined) {
      obj.computeTime = message.computeTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TuningSnapshot>): TuningSnapshot {
    return TuningSnapshot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TuningSnapshot>): TuningSnapshot {
    const message = createBaseTuningSnapshot();
    message.step = object.step ?? 0;
    message.epoch = object.epoch ?? 0;
    message.meanLoss = object.meanLoss ?? 0;
    message.computeTime = object.computeTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
