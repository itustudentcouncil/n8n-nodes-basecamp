// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/ai/generativelanguage/v1beta/retriever.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.ai.generativelanguage.v1beta";

/**
 * A `Corpus` is a collection of `Document`s.
 * A project can create up to 5 corpora.
 */
export interface Corpus {
  /**
   * Immutable. Identifier. The `Corpus` resource name. The ID (name excluding
   * the "corpora/" prefix) can contain up to 40 characters that are lowercase
   * alphanumeric or dashes
   * (-). The ID cannot start or end with a dash. If the name is empty on
   * create, a unique name will be derived from `display_name` along with a 12
   * character random suffix.
   * Example: `corpora/my-awesome-corpora-123a456b789c`
   */
  name: string;
  /**
   * Optional. The human-readable display name for the `Corpus`. The display
   * name must be no more than 512 characters in length, including spaces.
   * Example: "Docs on Semantic Retriever"
   */
  displayName: string;
  /** Output only. The Timestamp of when the `Corpus` was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The Timestamp of when the `Corpus` was last updated. */
  updateTime: Date | undefined;
}

/**
 * A `Document` is a collection of `Chunk`s.
 * A `Corpus` can have a maximum of 10,000 `Document`s.
 */
export interface Document {
  /**
   * Immutable. Identifier. The `Document` resource name. The ID (name excluding
   * the "corpora/* /documents/" prefix) can contain up to 40 characters that are
   * lowercase alphanumeric or dashes (-). The ID cannot start or end with a
   * dash. If the name is empty on create, a unique name will be derived from
   * `display_name` along with a 12 character random suffix.
   * Example: `corpora/{corpus_id}/documents/my-awesome-doc-123a456b789c`
   */
  name: string;
  /**
   * Optional. The human-readable display name for the `Document`. The display
   * name must be no more than 512 characters in length, including spaces.
   * Example: "Semantic Retriever Documentation"
   */
  displayName: string;
  /**
   * Optional. User provided custom metadata stored as key-value pairs used for
   * querying. A `Document` can have a maximum of 20 `CustomMetadata`.
   */
  customMetadata: CustomMetadata[];
  /** Output only. The Timestamp of when the `Document` was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The Timestamp of when the `Document` was created. */
  createTime: Date | undefined;
}

/** User provided string values assigned to a single metadata key. */
export interface StringList {
  /** The string values of the metadata to store. */
  values: string[];
}

/** User provided metadata stored as key-value pairs. */
export interface CustomMetadata {
  /** The string value of the metadata to store. */
  stringValue?:
    | string
    | undefined;
  /** The StringList value of the metadata to store. */
  stringListValue?:
    | StringList
    | undefined;
  /** The numeric value of the metadata to store. */
  numericValue?:
    | number
    | undefined;
  /** Required. The key of the metadata to store. */
  key: string;
}

/**
 * User provided filter to limit retrieval based on `Chunk` or `Document` level
 * metadata values.
 * Example (genre = drama OR genre = action):
 *   key = "document.custom_metadata.genre"
 *   conditions = [{string_value = "drama", operation = EQUAL},
 *                 {string_value = "action", operation = EQUAL}]
 */
export interface MetadataFilter {
  /** Required. The key of the metadata to filter on. */
  key: string;
  /**
   * Required. The `Condition`s for the given key that will trigger this filter.
   * Multiple `Condition`s are joined by logical ORs.
   */
  conditions: Condition[];
}

/** Filter condition applicable to a single key. */
export interface Condition {
  /** The string value to filter the metadata on. */
  stringValue?:
    | string
    | undefined;
  /** The numeric value to filter the metadata on. */
  numericValue?:
    | number
    | undefined;
  /**
   * Required. Operator applied to the given key-value pair to trigger the
   * condition.
   */
  operation: Condition_Operator;
}

/** Defines the valid operators that can be applied to a key-value pair. */
export enum Condition_Operator {
  /** OPERATOR_UNSPECIFIED - The default value. This value is unused. */
  OPERATOR_UNSPECIFIED = 0,
  /** LESS - Supported by numeric. */
  LESS = 1,
  /** LESS_EQUAL - Supported by numeric. */
  LESS_EQUAL = 2,
  /** EQUAL - Supported by numeric & string. */
  EQUAL = 3,
  /** GREATER_EQUAL - Supported by numeric. */
  GREATER_EQUAL = 4,
  /** GREATER - Supported by numeric. */
  GREATER = 5,
  /** NOT_EQUAL - Supported by numeric & string. */
  NOT_EQUAL = 6,
  /**
   * INCLUDES - Supported by string only when `CustomMetadata` value type for the given
   * key has a `string_list_value`.
   */
  INCLUDES = 7,
  /**
   * EXCLUDES - Supported by string only when `CustomMetadata` value type for the given
   * key has a `string_list_value`.
   */
  EXCLUDES = 8,
  UNRECOGNIZED = -1,
}

export function condition_OperatorFromJSON(object: any): Condition_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return Condition_Operator.OPERATOR_UNSPECIFIED;
    case 1:
    case "LESS":
      return Condition_Operator.LESS;
    case 2:
    case "LESS_EQUAL":
      return Condition_Operator.LESS_EQUAL;
    case 3:
    case "EQUAL":
      return Condition_Operator.EQUAL;
    case 4:
    case "GREATER_EQUAL":
      return Condition_Operator.GREATER_EQUAL;
    case 5:
    case "GREATER":
      return Condition_Operator.GREATER;
    case 6:
    case "NOT_EQUAL":
      return Condition_Operator.NOT_EQUAL;
    case 7:
    case "INCLUDES":
      return Condition_Operator.INCLUDES;
    case 8:
    case "EXCLUDES":
      return Condition_Operator.EXCLUDES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Condition_Operator.UNRECOGNIZED;
  }
}

export function condition_OperatorToJSON(object: Condition_Operator): string {
  switch (object) {
    case Condition_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case Condition_Operator.LESS:
      return "LESS";
    case Condition_Operator.LESS_EQUAL:
      return "LESS_EQUAL";
    case Condition_Operator.EQUAL:
      return "EQUAL";
    case Condition_Operator.GREATER_EQUAL:
      return "GREATER_EQUAL";
    case Condition_Operator.GREATER:
      return "GREATER";
    case Condition_Operator.NOT_EQUAL:
      return "NOT_EQUAL";
    case Condition_Operator.INCLUDES:
      return "INCLUDES";
    case Condition_Operator.EXCLUDES:
      return "EXCLUDES";
    case Condition_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A `Chunk` is a subpart of a `Document` that is treated as an independent unit
 * for the purposes of vector representation and storage.
 * A `Corpus` can have a maximum of 1 million `Chunk`s.
 */
export interface Chunk {
  /**
   * Immutable. Identifier. The `Chunk` resource name. The ID (name excluding
   * the "corpora/* /documents/* /chunks/" prefix) can contain up to 40 characters
   * that are lowercase alphanumeric or dashes (-). The ID cannot start or end
   * with a dash. If the name is empty on create, a random 12-character unique
   * ID will be generated.
   * Example: `corpora/{corpus_id}/documents/{document_id}/chunks/123a456b789c`
   */
  name: string;
  /**
   * Required. The content for the `Chunk`, such as the text string.
   * The maximum number of tokens per chunk is 2043.
   */
  data:
    | ChunkData
    | undefined;
  /**
   * Optional. User provided custom metadata stored as key-value pairs.
   * The maximum number of `CustomMetadata` per chunk is 20.
   */
  customMetadata: CustomMetadata[];
  /** Output only. The Timestamp of when the `Chunk` was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The Timestamp of when the `Chunk` was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. Current state of the `Chunk`. */
  state: Chunk_State;
}

/** States for the lifecycle of a `Chunk`. */
export enum Chunk_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** STATE_PENDING_PROCESSING - `Chunk` is being processed (embedding and vector storage). */
  STATE_PENDING_PROCESSING = 1,
  /** STATE_ACTIVE - `Chunk` is processed and available for querying. */
  STATE_ACTIVE = 2,
  /** STATE_FAILED - `Chunk` failed processing. */
  STATE_FAILED = 10,
  UNRECOGNIZED = -1,
}

export function chunk_StateFromJSON(object: any): Chunk_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Chunk_State.STATE_UNSPECIFIED;
    case 1:
    case "STATE_PENDING_PROCESSING":
      return Chunk_State.STATE_PENDING_PROCESSING;
    case 2:
    case "STATE_ACTIVE":
      return Chunk_State.STATE_ACTIVE;
    case 10:
    case "STATE_FAILED":
      return Chunk_State.STATE_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Chunk_State.UNRECOGNIZED;
  }
}

export function chunk_StateToJSON(object: Chunk_State): string {
  switch (object) {
    case Chunk_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Chunk_State.STATE_PENDING_PROCESSING:
      return "STATE_PENDING_PROCESSING";
    case Chunk_State.STATE_ACTIVE:
      return "STATE_ACTIVE";
    case Chunk_State.STATE_FAILED:
      return "STATE_FAILED";
    case Chunk_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Extracted data that represents the `Chunk` content. */
export interface ChunkData {
  /**
   * The `Chunk` content as a string.
   * The maximum number of tokens per chunk is 2043.
   */
  stringValue?: string | undefined;
}

function createBaseCorpus(): Corpus {
  return { name: "", displayName: "", createTime: undefined, updateTime: undefined };
}

export const Corpus: MessageFns<Corpus> = {
  encode(message: Corpus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Corpus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCorpus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Corpus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Corpus): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Corpus>): Corpus {
    return Corpus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Corpus>): Corpus {
    const message = createBaseCorpus();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseDocument(): Document {
  return { name: "", displayName: "", customMetadata: [], updateTime: undefined, createTime: undefined };
}

export const Document: MessageFns<Document> = {
  encode(message: Document, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.customMetadata) {
      CustomMetadata.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customMetadata.push(CustomMetadata.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      customMetadata: globalThis.Array.isArray(object?.customMetadata)
        ? object.customMetadata.map((e: any) => CustomMetadata.fromJSON(e))
        : [],
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: Document): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.customMetadata?.length) {
      obj.customMetadata = message.customMetadata.map((e) => CustomMetadata.toJSON(e));
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Document>): Document {
    return Document.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document>): Document {
    const message = createBaseDocument();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.customMetadata = object.customMetadata?.map((e) => CustomMetadata.fromPartial(e)) || [];
    message.updateTime = object.updateTime ?? undefined;
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseStringList(): StringList {
  return { values: [] };
}

export const StringList: MessageFns<StringList> = {
  encode(message: StringList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringList {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: StringList): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<StringList>): StringList {
    return StringList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StringList>): StringList {
    const message = createBaseStringList();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseCustomMetadata(): CustomMetadata {
  return { stringValue: undefined, stringListValue: undefined, numericValue: undefined, key: "" };
}

export const CustomMetadata: MessageFns<CustomMetadata> = {
  encode(message: CustomMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      writer.uint32(18).string(message.stringValue);
    }
    if (message.stringListValue !== undefined) {
      StringList.encode(message.stringListValue, writer.uint32(50).fork()).join();
    }
    if (message.numericValue !== undefined) {
      writer.uint32(61).float(message.numericValue);
    }
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stringListValue = StringList.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.numericValue = reader.float();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomMetadata {
    return {
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      stringListValue: isSet(object.stringListValue) ? StringList.fromJSON(object.stringListValue) : undefined,
      numericValue: isSet(object.numericValue) ? globalThis.Number(object.numericValue) : undefined,
      key: isSet(object.key) ? globalThis.String(object.key) : "",
    };
  },

  toJSON(message: CustomMetadata): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.stringListValue !== undefined) {
      obj.stringListValue = StringList.toJSON(message.stringListValue);
    }
    if (message.numericValue !== undefined) {
      obj.numericValue = message.numericValue;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomMetadata>): CustomMetadata {
    return CustomMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomMetadata>): CustomMetadata {
    const message = createBaseCustomMetadata();
    message.stringValue = object.stringValue ?? undefined;
    message.stringListValue = (object.stringListValue !== undefined && object.stringListValue !== null)
      ? StringList.fromPartial(object.stringListValue)
      : undefined;
    message.numericValue = object.numericValue ?? undefined;
    message.key = object.key ?? "";
    return message;
  },
};

function createBaseMetadataFilter(): MetadataFilter {
  return { key: "", conditions: [] };
}

export const MetadataFilter: MessageFns<MetadataFilter> = {
  encode(message: MetadataFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.conditions) {
      Condition.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetadataFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.conditions.push(Condition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataFilter {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => Condition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MetadataFilter): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => Condition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MetadataFilter>): MetadataFilter {
    return MetadataFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetadataFilter>): MetadataFilter {
    const message = createBaseMetadataFilter();
    message.key = object.key ?? "";
    message.conditions = object.conditions?.map((e) => Condition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCondition(): Condition {
  return { stringValue: undefined, numericValue: undefined, operation: 0 };
}

export const Condition: MessageFns<Condition> = {
  encode(message: Condition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      writer.uint32(10).string(message.stringValue);
    }
    if (message.numericValue !== undefined) {
      writer.uint32(53).float(message.numericValue);
    }
    if (message.operation !== 0) {
      writer.uint32(40).int32(message.operation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Condition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.numericValue = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.operation = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Condition {
    return {
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      numericValue: isSet(object.numericValue) ? globalThis.Number(object.numericValue) : undefined,
      operation: isSet(object.operation) ? condition_OperatorFromJSON(object.operation) : 0,
    };
  },

  toJSON(message: Condition): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.numericValue !== undefined) {
      obj.numericValue = message.numericValue;
    }
    if (message.operation !== 0) {
      obj.operation = condition_OperatorToJSON(message.operation);
    }
    return obj;
  },

  create(base?: DeepPartial<Condition>): Condition {
    return Condition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Condition>): Condition {
    const message = createBaseCondition();
    message.stringValue = object.stringValue ?? undefined;
    message.numericValue = object.numericValue ?? undefined;
    message.operation = object.operation ?? 0;
    return message;
  },
};

function createBaseChunk(): Chunk {
  return { name: "", data: undefined, customMetadata: [], createTime: undefined, updateTime: undefined, state: 0 };
}

export const Chunk: MessageFns<Chunk> = {
  encode(message: Chunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.data !== undefined) {
      ChunkData.encode(message.data, writer.uint32(18).fork()).join();
    }
    for (const v of message.customMetadata) {
      CustomMetadata.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Chunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = ChunkData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customMetadata.push(CustomMetadata.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chunk {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      data: isSet(object.data) ? ChunkData.fromJSON(object.data) : undefined,
      customMetadata: globalThis.Array.isArray(object?.customMetadata)
        ? object.customMetadata.map((e: any) => CustomMetadata.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? chunk_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Chunk): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.data !== undefined) {
      obj.data = ChunkData.toJSON(message.data);
    }
    if (message.customMetadata?.length) {
      obj.customMetadata = message.customMetadata.map((e) => CustomMetadata.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = chunk_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<Chunk>): Chunk {
    return Chunk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Chunk>): Chunk {
    const message = createBaseChunk();
    message.name = object.name ?? "";
    message.data = (object.data !== undefined && object.data !== null) ? ChunkData.fromPartial(object.data) : undefined;
    message.customMetadata = object.customMetadata?.map((e) => CustomMetadata.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseChunkData(): ChunkData {
  return { stringValue: undefined };
}

export const ChunkData: MessageFns<ChunkData> = {
  encode(message: ChunkData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      writer.uint32(10).string(message.stringValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChunkData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChunkData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChunkData {
    return { stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined };
  },

  toJSON(message: ChunkData): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    return obj;
  },

  create(base?: DeepPartial<ChunkData>): ChunkData {
    return ChunkData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChunkData>): ChunkData {
    const message = createBaseChunkData();
    message.stringValue = object.stringValue ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
