// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/appengine/v1/deploy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../protobuf/duration.js";

export const protobufPackage = "google.appengine.v1";

/** Code and application artifacts used to deploy a version to App Engine. */
export interface Deployment {
  /**
   * Manifest of the files stored in Google Cloud Storage that are included
   * as part of this version. All files must be readable using the
   * credentials supplied with this call.
   */
  files: { [key: string]: FileInfo };
  /**
   * The Docker image for the container that runs the version.
   * Only applicable for instances running in the App Engine flexible environment.
   */
  container:
    | ContainerInfo
    | undefined;
  /** The zip file for this deployment, if this is a zip deployment. */
  zip:
    | ZipInfo
    | undefined;
  /**
   * Options for any Google Cloud Build builds created as a part of this
   * deployment.
   *
   * These options will only be used if a new build is created, such as when
   * deploying to the App Engine flexible environment using files or zip.
   */
  cloudBuildOptions: CloudBuildOptions | undefined;
}

export interface Deployment_FilesEntry {
  key: string;
  value: FileInfo | undefined;
}

/**
 * Single source file that is part of the version to be deployed. Each source
 * file that is deployed must be specified separately.
 */
export interface FileInfo {
  /**
   * URL source to use to fetch this file. Must be a URL to a resource in
   * Google Cloud Storage in the form
   * 'http(s)://storage.googleapis.com/\<bucket\>/\<object\>'.
   */
  sourceUrl: string;
  /** The SHA1 hash of the file, in hex. */
  sha1Sum: string;
  /**
   * The MIME type of the file.
   *
   * Defaults to the value from Google Cloud Storage.
   */
  mimeType: string;
}

/**
 * Docker image that is used to create a container and start a VM instance for
 * the version that you deploy. Only applicable for instances running in the App
 * Engine flexible environment.
 */
export interface ContainerInfo {
  /**
   * URI to the hosted container image in Google Container Registry. The URI
   * must be fully qualified and include a tag or digest.
   * Examples: "gcr.io/my-project/image:tag" or "gcr.io/my-project/image@digest"
   */
  image: string;
}

/**
 * Options for the build operations performed as a part of the version
 * deployment. Only applicable for App Engine flexible environment when creating
 * a version using source code directly.
 */
export interface CloudBuildOptions {
  /**
   * Path to the yaml file used in deployment, used to determine runtime
   * configuration details.
   *
   * Required for flexible environment builds.
   *
   * See https://cloud.google.com/appengine/docs/standard/python/config/appref
   * for more details.
   */
  appYamlPath: string;
  /**
   * The Cloud Build timeout used as part of any dependent builds performed by
   * version creation. Defaults to 10 minutes.
   */
  cloudBuildTimeout: Duration | undefined;
}

/** The zip file information for a zip deployment. */
export interface ZipInfo {
  /**
   * URL of the zip file to deploy from. Must be a URL to a resource in
   * Google Cloud Storage in the form
   * 'http(s)://storage.googleapis.com/\<bucket\>/\<object\>'.
   */
  sourceUrl: string;
  /**
   * An estimate of the number of files in a zip for a zip deployment.
   * If set, must be greater than or equal to the actual number of files.
   * Used for optimizing performance; if not provided, deployment may be slow.
   */
  filesCount: number;
}

function createBaseDeployment(): Deployment {
  return { files: {}, container: undefined, zip: undefined, cloudBuildOptions: undefined };
}

export const Deployment: MessageFns<Deployment> = {
  encode(message: Deployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.files).forEach(([key, value]) => {
      Deployment_FilesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.container !== undefined) {
      ContainerInfo.encode(message.container, writer.uint32(18).fork()).join();
    }
    if (message.zip !== undefined) {
      ZipInfo.encode(message.zip, writer.uint32(26).fork()).join();
    }
    if (message.cloudBuildOptions !== undefined) {
      CloudBuildOptions.encode(message.cloudBuildOptions, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Deployment_FilesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.files[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.container = ContainerInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.zip = ZipInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cloudBuildOptions = CloudBuildOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deployment {
    return {
      files: isObject(object.files)
        ? Object.entries(object.files).reduce<{ [key: string]: FileInfo }>((acc, [key, value]) => {
          acc[key] = FileInfo.fromJSON(value);
          return acc;
        }, {})
        : {},
      container: isSet(object.container) ? ContainerInfo.fromJSON(object.container) : undefined,
      zip: isSet(object.zip) ? ZipInfo.fromJSON(object.zip) : undefined,
      cloudBuildOptions: isSet(object.cloudBuildOptions)
        ? CloudBuildOptions.fromJSON(object.cloudBuildOptions)
        : undefined,
    };
  },

  toJSON(message: Deployment): unknown {
    const obj: any = {};
    if (message.files) {
      const entries = Object.entries(message.files);
      if (entries.length > 0) {
        obj.files = {};
        entries.forEach(([k, v]) => {
          obj.files[k] = FileInfo.toJSON(v);
        });
      }
    }
    if (message.container !== undefined) {
      obj.container = ContainerInfo.toJSON(message.container);
    }
    if (message.zip !== undefined) {
      obj.zip = ZipInfo.toJSON(message.zip);
    }
    if (message.cloudBuildOptions !== undefined) {
      obj.cloudBuildOptions = CloudBuildOptions.toJSON(message.cloudBuildOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<Deployment>): Deployment {
    return Deployment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Deployment>): Deployment {
    const message = createBaseDeployment();
    message.files = Object.entries(object.files ?? {}).reduce<{ [key: string]: FileInfo }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = FileInfo.fromPartial(value);
      }
      return acc;
    }, {});
    message.container = (object.container !== undefined && object.container !== null)
      ? ContainerInfo.fromPartial(object.container)
      : undefined;
    message.zip = (object.zip !== undefined && object.zip !== null) ? ZipInfo.fromPartial(object.zip) : undefined;
    message.cloudBuildOptions = (object.cloudBuildOptions !== undefined && object.cloudBuildOptions !== null)
      ? CloudBuildOptions.fromPartial(object.cloudBuildOptions)
      : undefined;
    return message;
  },
};

function createBaseDeployment_FilesEntry(): Deployment_FilesEntry {
  return { key: "", value: undefined };
}

export const Deployment_FilesEntry: MessageFns<Deployment_FilesEntry> = {
  encode(message: Deployment_FilesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      FileInfo.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deployment_FilesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployment_FilesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = FileInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deployment_FilesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? FileInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Deployment_FilesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = FileInfo.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Deployment_FilesEntry>): Deployment_FilesEntry {
    return Deployment_FilesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Deployment_FilesEntry>): Deployment_FilesEntry {
    const message = createBaseDeployment_FilesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? FileInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFileInfo(): FileInfo {
  return { sourceUrl: "", sha1Sum: "", mimeType: "" };
}

export const FileInfo: MessageFns<FileInfo> = {
  encode(message: FileInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceUrl !== "") {
      writer.uint32(10).string(message.sourceUrl);
    }
    if (message.sha1Sum !== "") {
      writer.uint32(18).string(message.sha1Sum);
    }
    if (message.mimeType !== "") {
      writer.uint32(26).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sha1Sum = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mimeType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileInfo {
    return {
      sourceUrl: isSet(object.sourceUrl) ? globalThis.String(object.sourceUrl) : "",
      sha1Sum: isSet(object.sha1Sum) ? globalThis.String(object.sha1Sum) : "",
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: FileInfo): unknown {
    const obj: any = {};
    if (message.sourceUrl !== "") {
      obj.sourceUrl = message.sourceUrl;
    }
    if (message.sha1Sum !== "") {
      obj.sha1Sum = message.sha1Sum;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create(base?: DeepPartial<FileInfo>): FileInfo {
    return FileInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileInfo>): FileInfo {
    const message = createBaseFileInfo();
    message.sourceUrl = object.sourceUrl ?? "";
    message.sha1Sum = object.sha1Sum ?? "";
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseContainerInfo(): ContainerInfo {
  return { image: "" };
}

export const ContainerInfo: MessageFns<ContainerInfo> = {
  encode(message: ContainerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.image !== "") {
      writer.uint32(10).string(message.image);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.image = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerInfo {
    return { image: isSet(object.image) ? globalThis.String(object.image) : "" };
  },

  toJSON(message: ContainerInfo): unknown {
    const obj: any = {};
    if (message.image !== "") {
      obj.image = message.image;
    }
    return obj;
  },

  create(base?: DeepPartial<ContainerInfo>): ContainerInfo {
    return ContainerInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContainerInfo>): ContainerInfo {
    const message = createBaseContainerInfo();
    message.image = object.image ?? "";
    return message;
  },
};

function createBaseCloudBuildOptions(): CloudBuildOptions {
  return { appYamlPath: "", cloudBuildTimeout: undefined };
}

export const CloudBuildOptions: MessageFns<CloudBuildOptions> = {
  encode(message: CloudBuildOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appYamlPath !== "") {
      writer.uint32(10).string(message.appYamlPath);
    }
    if (message.cloudBuildTimeout !== undefined) {
      Duration.encode(message.cloudBuildTimeout, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloudBuildOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloudBuildOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appYamlPath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cloudBuildTimeout = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloudBuildOptions {
    return {
      appYamlPath: isSet(object.appYamlPath) ? globalThis.String(object.appYamlPath) : "",
      cloudBuildTimeout: isSet(object.cloudBuildTimeout) ? Duration.fromJSON(object.cloudBuildTimeout) : undefined,
    };
  },

  toJSON(message: CloudBuildOptions): unknown {
    const obj: any = {};
    if (message.appYamlPath !== "") {
      obj.appYamlPath = message.appYamlPath;
    }
    if (message.cloudBuildTimeout !== undefined) {
      obj.cloudBuildTimeout = Duration.toJSON(message.cloudBuildTimeout);
    }
    return obj;
  },

  create(base?: DeepPartial<CloudBuildOptions>): CloudBuildOptions {
    return CloudBuildOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloudBuildOptions>): CloudBuildOptions {
    const message = createBaseCloudBuildOptions();
    message.appYamlPath = object.appYamlPath ?? "";
    message.cloudBuildTimeout = (object.cloudBuildTimeout !== undefined && object.cloudBuildTimeout !== null)
      ? Duration.fromPartial(object.cloudBuildTimeout)
      : undefined;
    return message;
  },
};

function createBaseZipInfo(): ZipInfo {
  return { sourceUrl: "", filesCount: 0 };
}

export const ZipInfo: MessageFns<ZipInfo> = {
  encode(message: ZipInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceUrl !== "") {
      writer.uint32(26).string(message.sourceUrl);
    }
    if (message.filesCount !== 0) {
      writer.uint32(32).int32(message.filesCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZipInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZipInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceUrl = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.filesCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZipInfo {
    return {
      sourceUrl: isSet(object.sourceUrl) ? globalThis.String(object.sourceUrl) : "",
      filesCount: isSet(object.filesCount) ? globalThis.Number(object.filesCount) : 0,
    };
  },

  toJSON(message: ZipInfo): unknown {
    const obj: any = {};
    if (message.sourceUrl !== "") {
      obj.sourceUrl = message.sourceUrl;
    }
    if (message.filesCount !== 0) {
      obj.filesCount = Math.round(message.filesCount);
    }
    return obj;
  },

  create(base?: DeepPartial<ZipInfo>): ZipInfo {
    return ZipInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ZipInfo>): ZipInfo {
    const message = createBaseZipInfo();
    message.sourceUrl = object.sourceUrl ?? "";
    message.filesCount = object.filesCount ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
