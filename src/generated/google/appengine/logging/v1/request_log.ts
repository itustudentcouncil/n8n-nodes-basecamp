// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/appengine/logging/v1/request_log.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { LogSeverity, logSeverityFromJSON, logSeverityToJSON } from "../../../logging/type/log_severity.js";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.appengine.logging.v1";

/** Application log line emitted while processing a request. */
export interface LogLine {
  /** Approximate time when this log entry was made. */
  time:
    | Date
    | undefined;
  /** Severity of this log entry. */
  severity: LogSeverity;
  /** App-provided log message. */
  logMessage: string;
  /** Where in the source code this log message was written. */
  sourceLocation: SourceLocation | undefined;
}

/** Specifies a location in a source code file. */
export interface SourceLocation {
  /**
   * Source file name. Depending on the runtime environment, this might be a
   * simple name or a fully-qualified name.
   */
  file: string;
  /** Line within the source file. */
  line: Long;
  /**
   * Human-readable name of the function or method being invoked, with optional
   * context such as the class or package name. This information is used in
   * contexts such as the logs viewer, where a file and line number are less
   * meaningful. The format can vary by language. For example:
   * `qual.if.ied.Class.method` (Java), `dir/package.func` (Go), `function`
   * (Python).
   */
  functionName: string;
}

/**
 * A reference to a particular snapshot of the source tree used to build and
 * deploy an application.
 */
export interface SourceReference {
  /**
   * Optional. A URI string identifying the repository.
   * Example: "https://github.com/GoogleCloudPlatform/kubernetes.git"
   */
  repository: string;
  /**
   * The canonical and persistent identifier of the deployed revision.
   * Example (git): "0035781c50ec7aa23385dc841529ce8a4b70db1b"
   */
  revisionId: string;
}

/**
 * Complete log information about a single HTTP request to an App Engine
 * application.
 */
export interface RequestLog {
  /** Application that handled this request. */
  appId: string;
  /** Module of the application that handled this request. */
  moduleId: string;
  /** Version of the application that handled this request. */
  versionId: string;
  /**
   * Globally unique identifier for a request, which is based on the request
   * start time.  Request IDs for requests which started later will compare
   * greater as strings than those for requests which started earlier.
   */
  requestId: string;
  /** Origin IP address. */
  ip: string;
  /** Time when the request started. */
  startTime:
    | Date
    | undefined;
  /** Time when the request finished. */
  endTime:
    | Date
    | undefined;
  /** Latency of the request. */
  latency:
    | Duration
    | undefined;
  /** Number of CPU megacycles used to process request. */
  megaCycles: Long;
  /** Request method. Example: `"GET"`, `"HEAD"`, `"PUT"`, `"POST"`, `"DELETE"`. */
  method: string;
  /**
   * Contains the path and query portion of the URL that was requested. For
   * example, if the URL was "http://example.com/app?name=val", the resource
   * would be "/app?name=val".  The fragment identifier, which is identified by
   * the `#` character, is not included.
   */
  resource: string;
  /** HTTP version of request. Example: `"HTTP/1.1"`. */
  httpVersion: string;
  /** HTTP response status code. Example: 200, 404. */
  status: number;
  /** Size in bytes sent back to client by request. */
  responseSize: Long;
  /** Referrer URL of request. */
  referrer: string;
  /** User agent that made the request. */
  userAgent: string;
  /**
   * The logged-in user who made the request.
   *
   * Most likely, this is the part of the user's email before the `@` sign.  The
   * field value is the same for different requests from the same user, but
   * different users can have similar names.  This information is also
   * available to the application via the App Engine Users API.
   *
   * This field will be populated starting with App Engine 1.9.21.
   */
  nickname: string;
  /** File or class that handled the request. */
  urlMapEntry: string;
  /** Internet host and port number of the resource being requested. */
  host: string;
  /** An indication of the relative cost of serving this request. */
  cost: number;
  /** Queue name of the request, in the case of an offline request. */
  taskQueueName: string;
  /** Task name of the request, in the case of an offline request. */
  taskName: string;
  /** Whether this was a loading request for the instance. */
  wasLoadingRequest: boolean;
  /** Time this request spent in the pending request queue. */
  pendingTime:
    | Duration
    | undefined;
  /**
   * If the instance processing this request belongs to a manually scaled
   * module, then this is the 0-based index of the instance. Otherwise, this
   * value is -1.
   */
  instanceIndex: number;
  /** Whether this request is finished or active. */
  finished: boolean;
  /**
   * Whether this is the first `RequestLog` entry for this request.  If an
   * active request has several `RequestLog` entries written to Stackdriver
   * Logging, then this field will be set for one of them.
   */
  first: boolean;
  /** An identifier for the instance that handled the request. */
  instanceId: string;
  /** A list of log lines emitted by the application while serving this request. */
  line: LogLine[];
  /** App Engine release version. */
  appEngineRelease: string;
  /** Stackdriver Trace identifier for this request. */
  traceId: string;
  /**
   * If true, the value in the 'trace_id' field was sampled for storage in a
   * trace backend.
   */
  traceSampled: boolean;
  /**
   * Source code for the application that handled this request. There can be
   * more than one source reference per deployed application if source code is
   * distributed among multiple repositories.
   */
  sourceReference: SourceReference[];
}

function createBaseLogLine(): LogLine {
  return { time: undefined, severity: 0, logMessage: "", sourceLocation: undefined };
}

export const LogLine: MessageFns<LogLine> = {
  encode(message: LogLine, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).join();
    }
    if (message.severity !== 0) {
      writer.uint32(16).int32(message.severity);
    }
    if (message.logMessage !== "") {
      writer.uint32(26).string(message.logMessage);
    }
    if (message.sourceLocation !== undefined) {
      SourceLocation.encode(message.sourceLocation, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogLine {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.logMessage = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sourceLocation = SourceLocation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogLine {
    return {
      time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
      severity: isSet(object.severity) ? logSeverityFromJSON(object.severity) : 0,
      logMessage: isSet(object.logMessage) ? globalThis.String(object.logMessage) : "",
      sourceLocation: isSet(object.sourceLocation) ? SourceLocation.fromJSON(object.sourceLocation) : undefined,
    };
  },

  toJSON(message: LogLine): unknown {
    const obj: any = {};
    if (message.time !== undefined) {
      obj.time = message.time.toISOString();
    }
    if (message.severity !== 0) {
      obj.severity = logSeverityToJSON(message.severity);
    }
    if (message.logMessage !== "") {
      obj.logMessage = message.logMessage;
    }
    if (message.sourceLocation !== undefined) {
      obj.sourceLocation = SourceLocation.toJSON(message.sourceLocation);
    }
    return obj;
  },

  create(base?: DeepPartial<LogLine>): LogLine {
    return LogLine.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogLine>): LogLine {
    const message = createBaseLogLine();
    message.time = object.time ?? undefined;
    message.severity = object.severity ?? 0;
    message.logMessage = object.logMessage ?? "";
    message.sourceLocation = (object.sourceLocation !== undefined && object.sourceLocation !== null)
      ? SourceLocation.fromPartial(object.sourceLocation)
      : undefined;
    return message;
  },
};

function createBaseSourceLocation(): SourceLocation {
  return { file: "", line: Long.ZERO, functionName: "" };
}

export const SourceLocation: MessageFns<SourceLocation> = {
  encode(message: SourceLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.file !== "") {
      writer.uint32(10).string(message.file);
    }
    if (!message.line.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.line.toString());
    }
    if (message.functionName !== "") {
      writer.uint32(26).string(message.functionName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.file = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.line = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.functionName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceLocation {
    return {
      file: isSet(object.file) ? globalThis.String(object.file) : "",
      line: isSet(object.line) ? Long.fromValue(object.line) : Long.ZERO,
      functionName: isSet(object.functionName) ? globalThis.String(object.functionName) : "",
    };
  },

  toJSON(message: SourceLocation): unknown {
    const obj: any = {};
    if (message.file !== "") {
      obj.file = message.file;
    }
    if (!message.line.equals(Long.ZERO)) {
      obj.line = (message.line || Long.ZERO).toString();
    }
    if (message.functionName !== "") {
      obj.functionName = message.functionName;
    }
    return obj;
  },

  create(base?: DeepPartial<SourceLocation>): SourceLocation {
    return SourceLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceLocation>): SourceLocation {
    const message = createBaseSourceLocation();
    message.file = object.file ?? "";
    message.line = (object.line !== undefined && object.line !== null) ? Long.fromValue(object.line) : Long.ZERO;
    message.functionName = object.functionName ?? "";
    return message;
  },
};

function createBaseSourceReference(): SourceReference {
  return { repository: "", revisionId: "" };
}

export const SourceReference: MessageFns<SourceReference> = {
  encode(message: SourceReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repository !== "") {
      writer.uint32(10).string(message.repository);
    }
    if (message.revisionId !== "") {
      writer.uint32(18).string(message.revisionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revisionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceReference {
    return {
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
    };
  },

  toJSON(message: SourceReference): unknown {
    const obj: any = {};
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    return obj;
  },

  create(base?: DeepPartial<SourceReference>): SourceReference {
    return SourceReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SourceReference>): SourceReference {
    const message = createBaseSourceReference();
    message.repository = object.repository ?? "";
    message.revisionId = object.revisionId ?? "";
    return message;
  },
};

function createBaseRequestLog(): RequestLog {
  return {
    appId: "",
    moduleId: "",
    versionId: "",
    requestId: "",
    ip: "",
    startTime: undefined,
    endTime: undefined,
    latency: undefined,
    megaCycles: Long.ZERO,
    method: "",
    resource: "",
    httpVersion: "",
    status: 0,
    responseSize: Long.ZERO,
    referrer: "",
    userAgent: "",
    nickname: "",
    urlMapEntry: "",
    host: "",
    cost: 0,
    taskQueueName: "",
    taskName: "",
    wasLoadingRequest: false,
    pendingTime: undefined,
    instanceIndex: 0,
    finished: false,
    first: false,
    instanceId: "",
    line: [],
    appEngineRelease: "",
    traceId: "",
    traceSampled: false,
    sourceReference: [],
  };
}

export const RequestLog: MessageFns<RequestLog> = {
  encode(message: RequestLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appId !== "") {
      writer.uint32(10).string(message.appId);
    }
    if (message.moduleId !== "") {
      writer.uint32(298).string(message.moduleId);
    }
    if (message.versionId !== "") {
      writer.uint32(18).string(message.versionId);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.ip !== "") {
      writer.uint32(34).string(message.ip);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(50).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(58).fork()).join();
    }
    if (message.latency !== undefined) {
      Duration.encode(message.latency, writer.uint32(66).fork()).join();
    }
    if (!message.megaCycles.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.megaCycles.toString());
    }
    if (message.method !== "") {
      writer.uint32(82).string(message.method);
    }
    if (message.resource !== "") {
      writer.uint32(90).string(message.resource);
    }
    if (message.httpVersion !== "") {
      writer.uint32(98).string(message.httpVersion);
    }
    if (message.status !== 0) {
      writer.uint32(104).int32(message.status);
    }
    if (!message.responseSize.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.responseSize.toString());
    }
    if (message.referrer !== "") {
      writer.uint32(122).string(message.referrer);
    }
    if (message.userAgent !== "") {
      writer.uint32(130).string(message.userAgent);
    }
    if (message.nickname !== "") {
      writer.uint32(322).string(message.nickname);
    }
    if (message.urlMapEntry !== "") {
      writer.uint32(138).string(message.urlMapEntry);
    }
    if (message.host !== "") {
      writer.uint32(162).string(message.host);
    }
    if (message.cost !== 0) {
      writer.uint32(169).double(message.cost);
    }
    if (message.taskQueueName !== "") {
      writer.uint32(178).string(message.taskQueueName);
    }
    if (message.taskName !== "") {
      writer.uint32(186).string(message.taskName);
    }
    if (message.wasLoadingRequest !== false) {
      writer.uint32(192).bool(message.wasLoadingRequest);
    }
    if (message.pendingTime !== undefined) {
      Duration.encode(message.pendingTime, writer.uint32(202).fork()).join();
    }
    if (message.instanceIndex !== 0) {
      writer.uint32(208).int32(message.instanceIndex);
    }
    if (message.finished !== false) {
      writer.uint32(216).bool(message.finished);
    }
    if (message.first !== false) {
      writer.uint32(336).bool(message.first);
    }
    if (message.instanceId !== "") {
      writer.uint32(226).string(message.instanceId);
    }
    for (const v of message.line) {
      LogLine.encode(v!, writer.uint32(234).fork()).join();
    }
    if (message.appEngineRelease !== "") {
      writer.uint32(306).string(message.appEngineRelease);
    }
    if (message.traceId !== "") {
      writer.uint32(314).string(message.traceId);
    }
    if (message.traceSampled !== false) {
      writer.uint32(344).bool(message.traceSampled);
    }
    for (const v of message.sourceReference) {
      SourceReference.encode(v!, writer.uint32(330).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appId = reader.string();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.moduleId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.versionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.latency = Duration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.megaCycles = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.method = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.httpVersion = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.status = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.responseSize = Long.fromString(reader.int64().toString());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.referrer = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.nickname = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.urlMapEntry = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.host = reader.string();
          continue;
        case 21:
          if (tag !== 169) {
            break;
          }

          message.cost = reader.double();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.taskQueueName = reader.string();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.taskName = reader.string();
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.wasLoadingRequest = reader.bool();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.pendingTime = Duration.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.instanceIndex = reader.int32();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.finished = reader.bool();
          continue;
        case 42:
          if (tag !== 336) {
            break;
          }

          message.first = reader.bool();
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.line.push(LogLine.decode(reader, reader.uint32()));
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.appEngineRelease = reader.string();
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.traceId = reader.string();
          continue;
        case 43:
          if (tag !== 344) {
            break;
          }

          message.traceSampled = reader.bool();
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.sourceReference.push(SourceReference.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestLog {
    return {
      appId: isSet(object.appId) ? globalThis.String(object.appId) : "",
      moduleId: isSet(object.moduleId) ? globalThis.String(object.moduleId) : "",
      versionId: isSet(object.versionId) ? globalThis.String(object.versionId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      latency: isSet(object.latency) ? Duration.fromJSON(object.latency) : undefined,
      megaCycles: isSet(object.megaCycles) ? Long.fromValue(object.megaCycles) : Long.ZERO,
      method: isSet(object.method) ? globalThis.String(object.method) : "",
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      httpVersion: isSet(object.httpVersion) ? globalThis.String(object.httpVersion) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
      responseSize: isSet(object.responseSize) ? Long.fromValue(object.responseSize) : Long.ZERO,
      referrer: isSet(object.referrer) ? globalThis.String(object.referrer) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      nickname: isSet(object.nickname) ? globalThis.String(object.nickname) : "",
      urlMapEntry: isSet(object.urlMapEntry) ? globalThis.String(object.urlMapEntry) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
      taskQueueName: isSet(object.taskQueueName) ? globalThis.String(object.taskQueueName) : "",
      taskName: isSet(object.taskName) ? globalThis.String(object.taskName) : "",
      wasLoadingRequest: isSet(object.wasLoadingRequest) ? globalThis.Boolean(object.wasLoadingRequest) : false,
      pendingTime: isSet(object.pendingTime) ? Duration.fromJSON(object.pendingTime) : undefined,
      instanceIndex: isSet(object.instanceIndex) ? globalThis.Number(object.instanceIndex) : 0,
      finished: isSet(object.finished) ? globalThis.Boolean(object.finished) : false,
      first: isSet(object.first) ? globalThis.Boolean(object.first) : false,
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      line: globalThis.Array.isArray(object?.line) ? object.line.map((e: any) => LogLine.fromJSON(e)) : [],
      appEngineRelease: isSet(object.appEngineRelease) ? globalThis.String(object.appEngineRelease) : "",
      traceId: isSet(object.traceId) ? globalThis.String(object.traceId) : "",
      traceSampled: isSet(object.traceSampled) ? globalThis.Boolean(object.traceSampled) : false,
      sourceReference: globalThis.Array.isArray(object?.sourceReference)
        ? object.sourceReference.map((e: any) => SourceReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RequestLog): unknown {
    const obj: any = {};
    if (message.appId !== "") {
      obj.appId = message.appId;
    }
    if (message.moduleId !== "") {
      obj.moduleId = message.moduleId;
    }
    if (message.versionId !== "") {
      obj.versionId = message.versionId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.latency !== undefined) {
      obj.latency = Duration.toJSON(message.latency);
    }
    if (!message.megaCycles.equals(Long.ZERO)) {
      obj.megaCycles = (message.megaCycles || Long.ZERO).toString();
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.httpVersion !== "") {
      obj.httpVersion = message.httpVersion;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    if (!message.responseSize.equals(Long.ZERO)) {
      obj.responseSize = (message.responseSize || Long.ZERO).toString();
    }
    if (message.referrer !== "") {
      obj.referrer = message.referrer;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.nickname !== "") {
      obj.nickname = message.nickname;
    }
    if (message.urlMapEntry !== "") {
      obj.urlMapEntry = message.urlMapEntry;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.cost !== 0) {
      obj.cost = message.cost;
    }
    if (message.taskQueueName !== "") {
      obj.taskQueueName = message.taskQueueName;
    }
    if (message.taskName !== "") {
      obj.taskName = message.taskName;
    }
    if (message.wasLoadingRequest !== false) {
      obj.wasLoadingRequest = message.wasLoadingRequest;
    }
    if (message.pendingTime !== undefined) {
      obj.pendingTime = Duration.toJSON(message.pendingTime);
    }
    if (message.instanceIndex !== 0) {
      obj.instanceIndex = Math.round(message.instanceIndex);
    }
    if (message.finished !== false) {
      obj.finished = message.finished;
    }
    if (message.first !== false) {
      obj.first = message.first;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.line?.length) {
      obj.line = message.line.map((e) => LogLine.toJSON(e));
    }
    if (message.appEngineRelease !== "") {
      obj.appEngineRelease = message.appEngineRelease;
    }
    if (message.traceId !== "") {
      obj.traceId = message.traceId;
    }
    if (message.traceSampled !== false) {
      obj.traceSampled = message.traceSampled;
    }
    if (message.sourceReference?.length) {
      obj.sourceReference = message.sourceReference.map((e) => SourceReference.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RequestLog>): RequestLog {
    return RequestLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestLog>): RequestLog {
    const message = createBaseRequestLog();
    message.appId = object.appId ?? "";
    message.moduleId = object.moduleId ?? "";
    message.versionId = object.versionId ?? "";
    message.requestId = object.requestId ?? "";
    message.ip = object.ip ?? "";
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.latency = (object.latency !== undefined && object.latency !== null)
      ? Duration.fromPartial(object.latency)
      : undefined;
    message.megaCycles = (object.megaCycles !== undefined && object.megaCycles !== null)
      ? Long.fromValue(object.megaCycles)
      : Long.ZERO;
    message.method = object.method ?? "";
    message.resource = object.resource ?? "";
    message.httpVersion = object.httpVersion ?? "";
    message.status = object.status ?? 0;
    message.responseSize = (object.responseSize !== undefined && object.responseSize !== null)
      ? Long.fromValue(object.responseSize)
      : Long.ZERO;
    message.referrer = object.referrer ?? "";
    message.userAgent = object.userAgent ?? "";
    message.nickname = object.nickname ?? "";
    message.urlMapEntry = object.urlMapEntry ?? "";
    message.host = object.host ?? "";
    message.cost = object.cost ?? 0;
    message.taskQueueName = object.taskQueueName ?? "";
    message.taskName = object.taskName ?? "";
    message.wasLoadingRequest = object.wasLoadingRequest ?? false;
    message.pendingTime = (object.pendingTime !== undefined && object.pendingTime !== null)
      ? Duration.fromPartial(object.pendingTime)
      : undefined;
    message.instanceIndex = object.instanceIndex ?? 0;
    message.finished = object.finished ?? false;
    message.first = object.first ?? false;
    message.instanceId = object.instanceId ?? "";
    message.line = object.line?.map((e) => LogLine.fromPartial(e)) || [];
    message.appEngineRelease = object.appEngineRelease ?? "";
    message.traceId = object.traceId ?? "";
    message.traceSampled = object.traceSampled ?? false;
    message.sourceReference = object.sourceReference?.map((e) => SourceReference.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
