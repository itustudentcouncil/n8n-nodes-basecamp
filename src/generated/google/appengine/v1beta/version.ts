// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/appengine/v1beta/version.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../protobuf/duration.js";
import { Timestamp } from "../../protobuf/timestamp.js";
import {
  ApiConfigHandler,
  ErrorHandler,
  HealthCheck,
  Library,
  LivenessCheck,
  ReadinessCheck,
  UrlMap,
} from "./app_yaml.js";
import { Deployment } from "./deploy.js";

export const protobufPackage = "google.appengine.v1beta";

/** Available inbound services. */
export enum InboundServiceType {
  /** INBOUND_SERVICE_UNSPECIFIED - Not specified. */
  INBOUND_SERVICE_UNSPECIFIED = 0,
  /** INBOUND_SERVICE_MAIL - Allows an application to receive mail. */
  INBOUND_SERVICE_MAIL = 1,
  /** INBOUND_SERVICE_MAIL_BOUNCE - Allows an application to receive email-bound notifications. */
  INBOUND_SERVICE_MAIL_BOUNCE = 2,
  /** INBOUND_SERVICE_XMPP_ERROR - Allows an application to receive error stanzas. */
  INBOUND_SERVICE_XMPP_ERROR = 3,
  /** INBOUND_SERVICE_XMPP_MESSAGE - Allows an application to receive instant messages. */
  INBOUND_SERVICE_XMPP_MESSAGE = 4,
  /** INBOUND_SERVICE_XMPP_SUBSCRIBE - Allows an application to receive user subscription POSTs. */
  INBOUND_SERVICE_XMPP_SUBSCRIBE = 5,
  /** INBOUND_SERVICE_XMPP_PRESENCE - Allows an application to receive a user's chat presence. */
  INBOUND_SERVICE_XMPP_PRESENCE = 6,
  /**
   * INBOUND_SERVICE_CHANNEL_PRESENCE - Registers an application for notifications when a client connects or
   * disconnects from a channel.
   */
  INBOUND_SERVICE_CHANNEL_PRESENCE = 7,
  /** INBOUND_SERVICE_WARMUP - Enables warmup requests. */
  INBOUND_SERVICE_WARMUP = 9,
  UNRECOGNIZED = -1,
}

export function inboundServiceTypeFromJSON(object: any): InboundServiceType {
  switch (object) {
    case 0:
    case "INBOUND_SERVICE_UNSPECIFIED":
      return InboundServiceType.INBOUND_SERVICE_UNSPECIFIED;
    case 1:
    case "INBOUND_SERVICE_MAIL":
      return InboundServiceType.INBOUND_SERVICE_MAIL;
    case 2:
    case "INBOUND_SERVICE_MAIL_BOUNCE":
      return InboundServiceType.INBOUND_SERVICE_MAIL_BOUNCE;
    case 3:
    case "INBOUND_SERVICE_XMPP_ERROR":
      return InboundServiceType.INBOUND_SERVICE_XMPP_ERROR;
    case 4:
    case "INBOUND_SERVICE_XMPP_MESSAGE":
      return InboundServiceType.INBOUND_SERVICE_XMPP_MESSAGE;
    case 5:
    case "INBOUND_SERVICE_XMPP_SUBSCRIBE":
      return InboundServiceType.INBOUND_SERVICE_XMPP_SUBSCRIBE;
    case 6:
    case "INBOUND_SERVICE_XMPP_PRESENCE":
      return InboundServiceType.INBOUND_SERVICE_XMPP_PRESENCE;
    case 7:
    case "INBOUND_SERVICE_CHANNEL_PRESENCE":
      return InboundServiceType.INBOUND_SERVICE_CHANNEL_PRESENCE;
    case 9:
    case "INBOUND_SERVICE_WARMUP":
      return InboundServiceType.INBOUND_SERVICE_WARMUP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InboundServiceType.UNRECOGNIZED;
  }
}

export function inboundServiceTypeToJSON(object: InboundServiceType): string {
  switch (object) {
    case InboundServiceType.INBOUND_SERVICE_UNSPECIFIED:
      return "INBOUND_SERVICE_UNSPECIFIED";
    case InboundServiceType.INBOUND_SERVICE_MAIL:
      return "INBOUND_SERVICE_MAIL";
    case InboundServiceType.INBOUND_SERVICE_MAIL_BOUNCE:
      return "INBOUND_SERVICE_MAIL_BOUNCE";
    case InboundServiceType.INBOUND_SERVICE_XMPP_ERROR:
      return "INBOUND_SERVICE_XMPP_ERROR";
    case InboundServiceType.INBOUND_SERVICE_XMPP_MESSAGE:
      return "INBOUND_SERVICE_XMPP_MESSAGE";
    case InboundServiceType.INBOUND_SERVICE_XMPP_SUBSCRIBE:
      return "INBOUND_SERVICE_XMPP_SUBSCRIBE";
    case InboundServiceType.INBOUND_SERVICE_XMPP_PRESENCE:
      return "INBOUND_SERVICE_XMPP_PRESENCE";
    case InboundServiceType.INBOUND_SERVICE_CHANNEL_PRESENCE:
      return "INBOUND_SERVICE_CHANNEL_PRESENCE";
    case InboundServiceType.INBOUND_SERVICE_WARMUP:
      return "INBOUND_SERVICE_WARMUP";
    case InboundServiceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Run states of a version. */
export enum ServingStatus {
  /** SERVING_STATUS_UNSPECIFIED - Not specified. */
  SERVING_STATUS_UNSPECIFIED = 0,
  /**
   * SERVING - Currently serving. Instances are created according to the
   * scaling settings of the version.
   */
  SERVING = 1,
  /**
   * STOPPED - Disabled. No instances will be created and the scaling
   * settings are ignored until the state of the version changes
   * to `SERVING`.
   */
  STOPPED = 2,
  UNRECOGNIZED = -1,
}

export function servingStatusFromJSON(object: any): ServingStatus {
  switch (object) {
    case 0:
    case "SERVING_STATUS_UNSPECIFIED":
      return ServingStatus.SERVING_STATUS_UNSPECIFIED;
    case 1:
    case "SERVING":
      return ServingStatus.SERVING;
    case 2:
    case "STOPPED":
      return ServingStatus.STOPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServingStatus.UNRECOGNIZED;
  }
}

export function servingStatusToJSON(object: ServingStatus): string {
  switch (object) {
    case ServingStatus.SERVING_STATUS_UNSPECIFIED:
      return "SERVING_STATUS_UNSPECIFIED";
    case ServingStatus.SERVING:
      return "SERVING";
    case ServingStatus.STOPPED:
      return "STOPPED";
    case ServingStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A Version resource is a specific set of source code and configuration files
 * that are deployed into a service.
 */
export interface Version {
  /**
   * Full path to the Version resource in the API.  Example:
   * `apps/myapp/services/default/versions/v1`.
   *
   * @OutputOnly
   */
  name: string;
  /**
   * Relative name of the version within the service.  Example: `v1`.
   * Version names can contain only lowercase letters, numbers, or hyphens.
   * Reserved names: "default", "latest", and any name with the prefix "ah-".
   */
  id: string;
  /**
   * Automatic scaling is based on request rate, response latencies, and other
   * application metrics. Instances are dynamically created and destroyed as
   * needed in order to handle traffic.
   */
  automaticScaling?:
    | AutomaticScaling
    | undefined;
  /**
   * A service with basic scaling will create an instance when the application
   * receives a request. The instance will be turned down when the app becomes
   * idle. Basic scaling is ideal for work that is intermittent or driven by
   * user activity.
   */
  basicScaling?:
    | BasicScaling
    | undefined;
  /**
   * A service with manual scaling runs continuously, allowing you to perform
   * complex initialization and rely on the state of its memory over time.
   * Manually scaled versions are sometimes referred to as "backends".
   */
  manualScaling?:
    | ManualScaling
    | undefined;
  /**
   * Before an application can receive email or XMPP messages, the application
   * must be configured to enable the service.
   */
  inboundServices: InboundServiceType[];
  /**
   * Instance class that is used to run this version. Valid values are:
   *
   * * AutomaticScaling: `F1`, `F2`, `F4`, `F4_1G`
   * * ManualScaling or BasicScaling: `B1`, `B2`, `B4`, `B8`, `B4_1G`
   *
   * Defaults to `F1` for AutomaticScaling and `B1` for ManualScaling or
   * BasicScaling.
   */
  instanceClass: string;
  /**
   * Extra network settings.
   * Only applicable in the App Engine flexible environment.
   */
  network:
    | Network
    | undefined;
  /**
   * The Google Compute Engine zones that are supported by this version in the
   * App Engine flexible environment. Deprecated.
   */
  zones: string[];
  /**
   * Machine resources for this version.
   * Only applicable in the App Engine flexible environment.
   */
  resources:
    | Resources
    | undefined;
  /** Desired runtime. Example: `python27`. */
  runtime: string;
  /**
   * The channel of the runtime to use. Only available for some
   * runtimes. Defaults to the `default` channel.
   */
  runtimeChannel: string;
  /** Whether multiple requests can be dispatched to this version at once. */
  threadsafe: boolean;
  /** Whether to deploy this version in a container on a virtual machine. */
  vm: boolean;
  /**
   * app_engine_apis allows second generation runtimes to access the
   * App Engine APIs.
   */
  appEngineApis: boolean;
  /**
   * Metadata settings that are supplied to this version to enable
   * beta runtime features.
   */
  betaSettings: { [key: string]: string };
  /**
   * App Engine execution environment for this version.
   *
   * Defaults to `standard`.
   */
  env: string;
  /**
   * Current serving status of this version. Only the versions with a
   * `SERVING` status create instances and can be billed.
   *
   * `SERVING_STATUS_UNSPECIFIED` is an invalid value. Defaults to `SERVING`.
   */
  servingStatus: ServingStatus;
  /**
   * Email address of the user who created this version.
   *
   * @OutputOnly
   */
  createdBy: string;
  /**
   * Time that this version was created.
   *
   * @OutputOnly
   */
  createTime:
    | Date
    | undefined;
  /**
   * Total size in bytes of all the files that are included in this version
   * and currently hosted on the App Engine disk.
   *
   * @OutputOnly
   */
  diskUsageBytes: Long;
  /**
   * The version of the API in the given runtime environment. Please see the
   * app.yaml reference for valid values at
   * https://cloud.google.com/appengine/docs/standard/<language>/config/appref
   */
  runtimeApiVersion: string;
  /** The path or name of the app's main executable. */
  runtimeMainExecutablePath: string;
  /**
   * The identity that the deployed version will run as.
   * Admin API will use the App Engine Appspot service account as default if
   * this field is neither provided in app.yaml file nor through CLI flag.
   */
  serviceAccount: string;
  /**
   * An ordered list of URL-matching patterns that should be applied to incoming
   * requests. The first matching URL handles the request and other request
   * handlers are not attempted.
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  handlers: UrlMap[];
  /**
   * Custom static error pages. Limited to 10KB per page.
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  errorHandlers: ErrorHandler[];
  /**
   * Configuration for third-party Python runtime libraries that are required
   * by the application.
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  libraries: Library[];
  /**
   * Serving configuration for
   * [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/).
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  apiConfig:
    | ApiConfigHandler
    | undefined;
  /**
   * Environment variables available to the application.
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  envVariables: { [key: string]: string };
  /**
   * Environment variables available to the build environment.
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  buildEnvVariables: { [key: string]: string };
  /**
   * Duration that static files should be cached by web proxies and browsers.
   * Only applicable if the corresponding
   * [StaticFilesHandler](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StaticFilesHandler)
   * does not specify its own expiration time.
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  defaultExpiration:
    | Duration
    | undefined;
  /**
   * Configures health checking for instances. Unhealthy instances are
   * stopped and replaced with new instances.
   * Only applicable in the App Engine flexible environment.
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  healthCheck:
    | HealthCheck
    | undefined;
  /**
   * Configures readiness health checking for instances.
   * Unhealthy instances are not put into the backend traffic rotation.
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  readinessCheck:
    | ReadinessCheck
    | undefined;
  /**
   * Configures liveness health checking for instances.
   * Unhealthy instances are stopped and replaced with new instances
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  livenessCheck:
    | LivenessCheck
    | undefined;
  /**
   * Files that match this pattern will not be built into this version.
   * Only applicable for Go runtimes.
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  nobuildFilesRegex: string;
  /**
   * Code and application artifacts that make up this version.
   *
   * Only returned in `GET` requests if `view=FULL` is set.
   */
  deployment:
    | Deployment
    | undefined;
  /**
   * Serving URL for this version. Example:
   * "https://myversion-dot-myservice-dot-myapp.appspot.com"
   *
   * @OutputOnly
   */
  versionUrl: string;
  /**
   * Cloud Endpoints configuration.
   *
   * If endpoints_api_service is set, the Cloud Endpoints Extensible Service
   * Proxy will be provided to serve the API implemented by the app.
   */
  endpointsApiService:
    | EndpointsApiService
    | undefined;
  /** The entrypoint for the application. */
  entrypoint:
    | Entrypoint
    | undefined;
  /** Enables VPC connectivity for standard apps. */
  vpcAccessConnector: VpcAccessConnector | undefined;
}

export interface Version_BetaSettingsEntry {
  key: string;
  value: string;
}

export interface Version_EnvVariablesEntry {
  key: string;
  value: string;
}

export interface Version_BuildEnvVariablesEntry {
  key: string;
  value: string;
}

/**
 * [Cloud Endpoints](https://cloud.google.com/endpoints) configuration.
 * The Endpoints API Service provides tooling for serving Open API and gRPC
 * endpoints via an NGINX proxy. Only valid for App Engine Flexible environment
 * deployments.
 *
 * The fields here refer to the name and configuration ID of a "service"
 * resource in the [Service Management API](https://cloud.google.com/service-management/overview).
 */
export interface EndpointsApiService {
  /**
   * Endpoints service name which is the name of the "service" resource in the
   * Service Management API. For example "myapi.endpoints.myproject.cloud.goog"
   */
  name: string;
  /**
   * Endpoints service configuration ID as specified by the Service Management
   * API. For example "2016-09-19r1".
   *
   * By default, the rollout strategy for Endpoints is `RolloutStrategy.FIXED`.
   * This means that Endpoints starts up with a particular configuration ID.
   * When a new configuration is rolled out, Endpoints must be given the new
   * configuration ID. The `config_id` field is used to give the configuration
   * ID and is required in this case.
   *
   * Endpoints also has a rollout strategy called `RolloutStrategy.MANAGED`.
   * When using this, Endpoints fetches the latest configuration and does not
   * need the configuration ID. In this case, `config_id` must be omitted.
   */
  configId: string;
  /**
   * Endpoints rollout strategy. If `FIXED`, `config_id` must be specified. If
   * `MANAGED`, `config_id` must be omitted.
   */
  rolloutStrategy: EndpointsApiService_RolloutStrategy;
  /**
   * Enable or disable trace sampling. By default, this is set to false for
   * enabled.
   */
  disableTraceSampling: boolean;
}

/** Available rollout strategies. */
export enum EndpointsApiService_RolloutStrategy {
  /** UNSPECIFIED_ROLLOUT_STRATEGY - Not specified. Defaults to `FIXED`. */
  UNSPECIFIED_ROLLOUT_STRATEGY = 0,
  /**
   * FIXED - Endpoints service configuration ID will be fixed to the configuration ID
   * specified by `config_id`.
   */
  FIXED = 1,
  /** MANAGED - Endpoints service configuration ID will be updated with each rollout. */
  MANAGED = 2,
  UNRECOGNIZED = -1,
}

export function endpointsApiService_RolloutStrategyFromJSON(object: any): EndpointsApiService_RolloutStrategy {
  switch (object) {
    case 0:
    case "UNSPECIFIED_ROLLOUT_STRATEGY":
      return EndpointsApiService_RolloutStrategy.UNSPECIFIED_ROLLOUT_STRATEGY;
    case 1:
    case "FIXED":
      return EndpointsApiService_RolloutStrategy.FIXED;
    case 2:
    case "MANAGED":
      return EndpointsApiService_RolloutStrategy.MANAGED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EndpointsApiService_RolloutStrategy.UNRECOGNIZED;
  }
}

export function endpointsApiService_RolloutStrategyToJSON(object: EndpointsApiService_RolloutStrategy): string {
  switch (object) {
    case EndpointsApiService_RolloutStrategy.UNSPECIFIED_ROLLOUT_STRATEGY:
      return "UNSPECIFIED_ROLLOUT_STRATEGY";
    case EndpointsApiService_RolloutStrategy.FIXED:
      return "FIXED";
    case EndpointsApiService_RolloutStrategy.MANAGED:
      return "MANAGED";
    case EndpointsApiService_RolloutStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Automatic scaling is based on request rate, response latencies, and other
 * application metrics.
 */
export interface AutomaticScaling {
  /**
   * The time period that the
   * [Autoscaler](https://cloud.google.com/compute/docs/autoscaler/)
   * should wait before it starts collecting information from a new instance.
   * This prevents the autoscaler from collecting information when the instance
   * is initializing, during which the collected usage would not be reliable.
   * Only applicable in the App Engine flexible environment.
   */
  coolDownPeriod:
    | Duration
    | undefined;
  /** Target scaling by CPU usage. */
  cpuUtilization:
    | CpuUtilization
    | undefined;
  /**
   * Number of concurrent requests an automatic scaling instance can accept
   * before the scheduler spawns a new instance.
   *
   * Defaults to a runtime-specific value.
   */
  maxConcurrentRequests: number;
  /**
   * Maximum number of idle instances that should be maintained for this
   * version.
   */
  maxIdleInstances: number;
  /**
   * Maximum number of instances that should be started to handle requests for
   * this version.
   */
  maxTotalInstances: number;
  /**
   * Maximum amount of time that a request should wait in the pending queue
   * before starting a new instance to handle it.
   */
  maxPendingLatency:
    | Duration
    | undefined;
  /**
   * Minimum number of idle instances that should be maintained for
   * this version. Only applicable for the default version of a service.
   */
  minIdleInstances: number;
  /**
   * Minimum number of running instances that should be maintained for this
   * version.
   */
  minTotalInstances: number;
  /**
   * Minimum amount of time a request should wait in the pending queue before
   * starting a new instance to handle it.
   */
  minPendingLatency:
    | Duration
    | undefined;
  /** Target scaling by request utilization. */
  requestUtilization:
    | RequestUtilization
    | undefined;
  /** Target scaling by disk usage. */
  diskUtilization:
    | DiskUtilization
    | undefined;
  /** Target scaling by network usage. */
  networkUtilization:
    | NetworkUtilization
    | undefined;
  /**
   * Target scaling by user-provided metrics.
   * Only applicable in the App Engine flexible environment.
   */
  customMetrics: CustomMetric[];
  /** Scheduler settings for standard environment. */
  standardSchedulerSettings: StandardSchedulerSettings | undefined;
}

/**
 * A service with basic scaling will create an instance when the application
 * receives a request. The instance will be turned down when the app becomes
 * idle. Basic scaling is ideal for work that is intermittent or driven by
 * user activity.
 */
export interface BasicScaling {
  /**
   * Duration of time after the last request that an instance must wait before
   * the instance is shut down.
   */
  idleTimeout:
    | Duration
    | undefined;
  /** Maximum number of instances to create for this version. */
  maxInstances: number;
}

/**
 * A service with manual scaling runs continuously, allowing you to perform
 * complex initialization and rely on the state of its memory over time.
 */
export interface ManualScaling {
  /**
   * Number of instances to assign to the service at the start. This number
   * can later be altered by using the
   * [Modules API](https://cloud.google.com/appengine/docs/python/modules/functions)
   * `set_num_instances()` function.
   */
  instances: number;
}

/** Target scaling by CPU usage. */
export interface CpuUtilization {
  /** Period of time over which CPU utilization is calculated. */
  aggregationWindowLength:
    | Duration
    | undefined;
  /**
   * Target CPU utilization ratio to maintain when scaling. Must be between 0
   * and 1.
   */
  targetUtilization: number;
}

/**
 * Target scaling by request utilization.
 * Only applicable in the App Engine flexible environment.
 */
export interface RequestUtilization {
  /** Target requests per second. */
  targetRequestCountPerSecond: number;
  /** Target number of concurrent requests. */
  targetConcurrentRequests: number;
}

/**
 * Target scaling by disk usage.
 * Only applicable in the App Engine flexible environment.
 */
export interface DiskUtilization {
  /** Target bytes written per second. */
  targetWriteBytesPerSecond: number;
  /** Target ops written per second. */
  targetWriteOpsPerSecond: number;
  /** Target bytes read per second. */
  targetReadBytesPerSecond: number;
  /** Target ops read per seconds. */
  targetReadOpsPerSecond: number;
}

/**
 * Target scaling by network usage.
 * Only applicable in the App Engine flexible environment.
 */
export interface NetworkUtilization {
  /** Target bytes sent per second. */
  targetSentBytesPerSecond: number;
  /** Target packets sent per second. */
  targetSentPacketsPerSecond: number;
  /** Target bytes received per second. */
  targetReceivedBytesPerSecond: number;
  /** Target packets received per second. */
  targetReceivedPacketsPerSecond: number;
}

/** Allows autoscaling based on Stackdriver metrics. */
export interface CustomMetric {
  /** The name of the metric. */
  metricName: string;
  /**
   * The type of the metric. Must be a string representing a Stackdriver
   * metric type e.g. GAGUE, DELTA_PER_SECOND, etc.
   */
  targetType: string;
  /** The target value for the metric. */
  targetUtilization?:
    | number
    | undefined;
  /**
   * May be used instead of `target_utilization` when an instance can handle a
   * specific amount of work/resources and the metric value is equal to the
   * current amount of work remaining. The autoscaler will try to keep the
   * number of instances equal to the metric value divided by
   * `single_instance_assignment`.
   */
  singleInstanceAssignment?:
    | number
    | undefined;
  /** Allows filtering on the metric's fields. */
  filter: string;
}

/** Scheduler settings for standard environment. */
export interface StandardSchedulerSettings {
  /** Target CPU utilization ratio to maintain when scaling. */
  targetCpuUtilization: number;
  /** Target throughput utilization ratio to maintain when scaling */
  targetThroughputUtilization: number;
  /**
   * Minimum number of instances to run for this version. Set to zero to disable
   * `min_instances` configuration.
   */
  minInstances: number;
  /**
   * Maximum number of instances to run for this version. Set to zero to disable
   * `max_instances` configuration.
   */
  maxInstances: number;
}

/**
 * Extra network settings.
 * Only applicable in the App Engine flexible environment.
 */
export interface Network {
  /**
   * List of ports, or port pairs, to forward from the virtual machine to the
   * application container.
   * Only applicable in the App Engine flexible environment.
   */
  forwardedPorts: string[];
  /**
   * Tag to apply to the instance during creation.
   * Only applicable in the App Engine flexible environment.
   */
  instanceTag: string;
  /**
   * Google Compute Engine network where the virtual machines are created.
   * Specify the short name, not the resource path.
   *
   * Defaults to `default`.
   */
  name: string;
  /**
   * Google Cloud Platform sub-network where the virtual machines are created.
   * Specify the short name, not the resource path.
   *
   * If a subnetwork name is specified, a network name will also be required
   * unless it is for the default network.
   *
   * * If the network that the instance is being created in is a Legacy network,
   * then the IP address is allocated from the IPv4Range.
   * * If the network that the instance is being created in is an auto Subnet
   * Mode Network, then only network name should be specified (not the
   * subnetwork_name) and the IP address is created from the IPCidrRange of the
   * subnetwork that exists in that zone for that network.
   * * If the network that the instance is being created in is a custom Subnet
   * Mode Network, then the subnetwork_name must be specified and the
   * IP address is created from the IPCidrRange of the subnetwork.
   *
   * If specified, the subnetwork must exist in the same region as the
   * App Engine flexible environment application.
   */
  subnetworkName: string;
  /**
   * Enable session affinity.
   * Only applicable in the App Engine flexible environment.
   */
  sessionAffinity: boolean;
}

/**
 * Volumes mounted within the app container.
 * Only applicable in the App Engine flexible environment.
 */
export interface Volume {
  /** Unique name for the volume. */
  name: string;
  /** Underlying volume type, e.g. 'tmpfs'. */
  volumeType: string;
  /** Volume size in gigabytes. */
  sizeGb: number;
}

/** Machine resources for a version. */
export interface Resources {
  /** Number of CPU cores needed. */
  cpu: number;
  /** Disk size (GB) needed. */
  diskGb: number;
  /** Memory (GB) needed. */
  memoryGb: number;
  /** User specified volumes. */
  volumes: Volume[];
  /**
   * The name of the encryption key that is stored in Google Cloud KMS.
   * Only should be used by Cloud Composer to encrypt the vm disk
   */
  kmsKeyReference: string;
}

/** VPC access connector specification. */
export interface VpcAccessConnector {
  /**
   * Full Serverless VPC Access Connector name e.g.
   * /projects/my-project/locations/us-central1/connectors/c1.
   */
  name: string;
}

/** The entrypoint for the application. */
export interface Entrypoint {
  /** The format should be a shell command that can be fed to `bash -c`. */
  shell?: string | undefined;
}

function createBaseVersion(): Version {
  return {
    name: "",
    id: "",
    automaticScaling: undefined,
    basicScaling: undefined,
    manualScaling: undefined,
    inboundServices: [],
    instanceClass: "",
    network: undefined,
    zones: [],
    resources: undefined,
    runtime: "",
    runtimeChannel: "",
    threadsafe: false,
    vm: false,
    appEngineApis: false,
    betaSettings: {},
    env: "",
    servingStatus: 0,
    createdBy: "",
    createTime: undefined,
    diskUsageBytes: Long.ZERO,
    runtimeApiVersion: "",
    runtimeMainExecutablePath: "",
    serviceAccount: "",
    handlers: [],
    errorHandlers: [],
    libraries: [],
    apiConfig: undefined,
    envVariables: {},
    buildEnvVariables: {},
    defaultExpiration: undefined,
    healthCheck: undefined,
    readinessCheck: undefined,
    livenessCheck: undefined,
    nobuildFilesRegex: "",
    deployment: undefined,
    versionUrl: "",
    endpointsApiService: undefined,
    entrypoint: undefined,
    vpcAccessConnector: undefined,
  };
}

export const Version: MessageFns<Version> = {
  encode(message: Version, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.automaticScaling !== undefined) {
      AutomaticScaling.encode(message.automaticScaling, writer.uint32(26).fork()).join();
    }
    if (message.basicScaling !== undefined) {
      BasicScaling.encode(message.basicScaling, writer.uint32(34).fork()).join();
    }
    if (message.manualScaling !== undefined) {
      ManualScaling.encode(message.manualScaling, writer.uint32(42).fork()).join();
    }
    writer.uint32(50).fork();
    for (const v of message.inboundServices) {
      writer.int32(v);
    }
    writer.join();
    if (message.instanceClass !== "") {
      writer.uint32(58).string(message.instanceClass);
    }
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(66).fork()).join();
    }
    for (const v of message.zones) {
      writer.uint32(946).string(v!);
    }
    if (message.resources !== undefined) {
      Resources.encode(message.resources, writer.uint32(74).fork()).join();
    }
    if (message.runtime !== "") {
      writer.uint32(82).string(message.runtime);
    }
    if (message.runtimeChannel !== "") {
      writer.uint32(938).string(message.runtimeChannel);
    }
    if (message.threadsafe !== false) {
      writer.uint32(88).bool(message.threadsafe);
    }
    if (message.vm !== false) {
      writer.uint32(96).bool(message.vm);
    }
    if (message.appEngineApis !== false) {
      writer.uint32(1024).bool(message.appEngineApis);
    }
    Object.entries(message.betaSettings).forEach(([key, value]) => {
      Version_BetaSettingsEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    if (message.env !== "") {
      writer.uint32(114).string(message.env);
    }
    if (message.servingStatus !== 0) {
      writer.uint32(120).int32(message.servingStatus);
    }
    if (message.createdBy !== "") {
      writer.uint32(130).string(message.createdBy);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(138).fork()).join();
    }
    if (!message.diskUsageBytes.equals(Long.ZERO)) {
      writer.uint32(144).int64(message.diskUsageBytes.toString());
    }
    if (message.runtimeApiVersion !== "") {
      writer.uint32(170).string(message.runtimeApiVersion);
    }
    if (message.runtimeMainExecutablePath !== "") {
      writer.uint32(178).string(message.runtimeMainExecutablePath);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(1018).string(message.serviceAccount);
    }
    for (const v of message.handlers) {
      UrlMap.encode(v!, writer.uint32(802).fork()).join();
    }
    for (const v of message.errorHandlers) {
      ErrorHandler.encode(v!, writer.uint32(810).fork()).join();
    }
    for (const v of message.libraries) {
      Library.encode(v!, writer.uint32(818).fork()).join();
    }
    if (message.apiConfig !== undefined) {
      ApiConfigHandler.encode(message.apiConfig, writer.uint32(826).fork()).join();
    }
    Object.entries(message.envVariables).forEach(([key, value]) => {
      Version_EnvVariablesEntry.encode({ key: key as any, value }, writer.uint32(834).fork()).join();
    });
    Object.entries(message.buildEnvVariables).forEach(([key, value]) => {
      Version_BuildEnvVariablesEntry.encode({ key: key as any, value }, writer.uint32(1002).fork()).join();
    });
    if (message.defaultExpiration !== undefined) {
      Duration.encode(message.defaultExpiration, writer.uint32(842).fork()).join();
    }
    if (message.healthCheck !== undefined) {
      HealthCheck.encode(message.healthCheck, writer.uint32(850).fork()).join();
    }
    if (message.readinessCheck !== undefined) {
      ReadinessCheck.encode(message.readinessCheck, writer.uint32(898).fork()).join();
    }
    if (message.livenessCheck !== undefined) {
      LivenessCheck.encode(message.livenessCheck, writer.uint32(906).fork()).join();
    }
    if (message.nobuildFilesRegex !== "") {
      writer.uint32(858).string(message.nobuildFilesRegex);
    }
    if (message.deployment !== undefined) {
      Deployment.encode(message.deployment, writer.uint32(866).fork()).join();
    }
    if (message.versionUrl !== "") {
      writer.uint32(874).string(message.versionUrl);
    }
    if (message.endpointsApiService !== undefined) {
      EndpointsApiService.encode(message.endpointsApiService, writer.uint32(882).fork()).join();
    }
    if (message.entrypoint !== undefined) {
      Entrypoint.encode(message.entrypoint, writer.uint32(978).fork()).join();
    }
    if (message.vpcAccessConnector !== undefined) {
      VpcAccessConnector.encode(message.vpcAccessConnector, writer.uint32(970).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Version {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.automaticScaling = AutomaticScaling.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.basicScaling = BasicScaling.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.manualScaling = ManualScaling.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag === 48) {
            message.inboundServices.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.inboundServices.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.instanceClass = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        case 118:
          if (tag !== 946) {
            break;
          }

          message.zones.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.resources = Resources.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.runtime = reader.string();
          continue;
        case 117:
          if (tag !== 938) {
            break;
          }

          message.runtimeChannel = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.threadsafe = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.vm = reader.bool();
          continue;
        case 128:
          if (tag !== 1024) {
            break;
          }

          message.appEngineApis = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          const entry13 = Version_BetaSettingsEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.betaSettings[entry13.key] = entry13.value;
          }
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.env = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.servingStatus = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.createdBy = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.diskUsageBytes = Long.fromString(reader.int64().toString());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.runtimeApiVersion = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.runtimeMainExecutablePath = reader.string();
          continue;
        case 127:
          if (tag !== 1018) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.handlers.push(UrlMap.decode(reader, reader.uint32()));
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.errorHandlers.push(ErrorHandler.decode(reader, reader.uint32()));
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.libraries.push(Library.decode(reader, reader.uint32()));
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.apiConfig = ApiConfigHandler.decode(reader, reader.uint32());
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }

          const entry104 = Version_EnvVariablesEntry.decode(reader, reader.uint32());
          if (entry104.value !== undefined) {
            message.envVariables[entry104.key] = entry104.value;
          }
          continue;
        case 125:
          if (tag !== 1002) {
            break;
          }

          const entry125 = Version_BuildEnvVariablesEntry.decode(reader, reader.uint32());
          if (entry125.value !== undefined) {
            message.buildEnvVariables[entry125.key] = entry125.value;
          }
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }

          message.defaultExpiration = Duration.decode(reader, reader.uint32());
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }

          message.healthCheck = HealthCheck.decode(reader, reader.uint32());
          continue;
        case 112:
          if (tag !== 898) {
            break;
          }

          message.readinessCheck = ReadinessCheck.decode(reader, reader.uint32());
          continue;
        case 113:
          if (tag !== 906) {
            break;
          }

          message.livenessCheck = LivenessCheck.decode(reader, reader.uint32());
          continue;
        case 107:
          if (tag !== 858) {
            break;
          }

          message.nobuildFilesRegex = reader.string();
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }

          message.deployment = Deployment.decode(reader, reader.uint32());
          continue;
        case 109:
          if (tag !== 874) {
            break;
          }

          message.versionUrl = reader.string();
          continue;
        case 110:
          if (tag !== 882) {
            break;
          }

          message.endpointsApiService = EndpointsApiService.decode(reader, reader.uint32());
          continue;
        case 122:
          if (tag !== 978) {
            break;
          }

          message.entrypoint = Entrypoint.decode(reader, reader.uint32());
          continue;
        case 121:
          if (tag !== 970) {
            break;
          }

          message.vpcAccessConnector = VpcAccessConnector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Version {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      automaticScaling: isSet(object.automaticScaling) ? AutomaticScaling.fromJSON(object.automaticScaling) : undefined,
      basicScaling: isSet(object.basicScaling) ? BasicScaling.fromJSON(object.basicScaling) : undefined,
      manualScaling: isSet(object.manualScaling) ? ManualScaling.fromJSON(object.manualScaling) : undefined,
      inboundServices: globalThis.Array.isArray(object?.inboundServices)
        ? object.inboundServices.map((e: any) => inboundServiceTypeFromJSON(e))
        : [],
      instanceClass: isSet(object.instanceClass) ? globalThis.String(object.instanceClass) : "",
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      zones: globalThis.Array.isArray(object?.zones) ? object.zones.map((e: any) => globalThis.String(e)) : [],
      resources: isSet(object.resources) ? Resources.fromJSON(object.resources) : undefined,
      runtime: isSet(object.runtime) ? globalThis.String(object.runtime) : "",
      runtimeChannel: isSet(object.runtimeChannel) ? globalThis.String(object.runtimeChannel) : "",
      threadsafe: isSet(object.threadsafe) ? globalThis.Boolean(object.threadsafe) : false,
      vm: isSet(object.vm) ? globalThis.Boolean(object.vm) : false,
      appEngineApis: isSet(object.appEngineApis) ? globalThis.Boolean(object.appEngineApis) : false,
      betaSettings: isObject(object.betaSettings)
        ? Object.entries(object.betaSettings).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      env: isSet(object.env) ? globalThis.String(object.env) : "",
      servingStatus: isSet(object.servingStatus) ? servingStatusFromJSON(object.servingStatus) : 0,
      createdBy: isSet(object.createdBy) ? globalThis.String(object.createdBy) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      diskUsageBytes: isSet(object.diskUsageBytes) ? Long.fromValue(object.diskUsageBytes) : Long.ZERO,
      runtimeApiVersion: isSet(object.runtimeApiVersion) ? globalThis.String(object.runtimeApiVersion) : "",
      runtimeMainExecutablePath: isSet(object.runtimeMainExecutablePath)
        ? globalThis.String(object.runtimeMainExecutablePath)
        : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      handlers: globalThis.Array.isArray(object?.handlers) ? object.handlers.map((e: any) => UrlMap.fromJSON(e)) : [],
      errorHandlers: globalThis.Array.isArray(object?.errorHandlers)
        ? object.errorHandlers.map((e: any) => ErrorHandler.fromJSON(e))
        : [],
      libraries: globalThis.Array.isArray(object?.libraries)
        ? object.libraries.map((e: any) => Library.fromJSON(e))
        : [],
      apiConfig: isSet(object.apiConfig) ? ApiConfigHandler.fromJSON(object.apiConfig) : undefined,
      envVariables: isObject(object.envVariables)
        ? Object.entries(object.envVariables).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      buildEnvVariables: isObject(object.buildEnvVariables)
        ? Object.entries(object.buildEnvVariables).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      defaultExpiration: isSet(object.defaultExpiration) ? Duration.fromJSON(object.defaultExpiration) : undefined,
      healthCheck: isSet(object.healthCheck) ? HealthCheck.fromJSON(object.healthCheck) : undefined,
      readinessCheck: isSet(object.readinessCheck) ? ReadinessCheck.fromJSON(object.readinessCheck) : undefined,
      livenessCheck: isSet(object.livenessCheck) ? LivenessCheck.fromJSON(object.livenessCheck) : undefined,
      nobuildFilesRegex: isSet(object.nobuildFilesRegex) ? globalThis.String(object.nobuildFilesRegex) : "",
      deployment: isSet(object.deployment) ? Deployment.fromJSON(object.deployment) : undefined,
      versionUrl: isSet(object.versionUrl) ? globalThis.String(object.versionUrl) : "",
      endpointsApiService: isSet(object.endpointsApiService)
        ? EndpointsApiService.fromJSON(object.endpointsApiService)
        : undefined,
      entrypoint: isSet(object.entrypoint) ? Entrypoint.fromJSON(object.entrypoint) : undefined,
      vpcAccessConnector: isSet(object.vpcAccessConnector)
        ? VpcAccessConnector.fromJSON(object.vpcAccessConnector)
        : undefined,
    };
  },

  toJSON(message: Version): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.automaticScaling !== undefined) {
      obj.automaticScaling = AutomaticScaling.toJSON(message.automaticScaling);
    }
    if (message.basicScaling !== undefined) {
      obj.basicScaling = BasicScaling.toJSON(message.basicScaling);
    }
    if (message.manualScaling !== undefined) {
      obj.manualScaling = ManualScaling.toJSON(message.manualScaling);
    }
    if (message.inboundServices?.length) {
      obj.inboundServices = message.inboundServices.map((e) => inboundServiceTypeToJSON(e));
    }
    if (message.instanceClass !== "") {
      obj.instanceClass = message.instanceClass;
    }
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.zones?.length) {
      obj.zones = message.zones;
    }
    if (message.resources !== undefined) {
      obj.resources = Resources.toJSON(message.resources);
    }
    if (message.runtime !== "") {
      obj.runtime = message.runtime;
    }
    if (message.runtimeChannel !== "") {
      obj.runtimeChannel = message.runtimeChannel;
    }
    if (message.threadsafe !== false) {
      obj.threadsafe = message.threadsafe;
    }
    if (message.vm !== false) {
      obj.vm = message.vm;
    }
    if (message.appEngineApis !== false) {
      obj.appEngineApis = message.appEngineApis;
    }
    if (message.betaSettings) {
      const entries = Object.entries(message.betaSettings);
      if (entries.length > 0) {
        obj.betaSettings = {};
        entries.forEach(([k, v]) => {
          obj.betaSettings[k] = v;
        });
      }
    }
    if (message.env !== "") {
      obj.env = message.env;
    }
    if (message.servingStatus !== 0) {
      obj.servingStatus = servingStatusToJSON(message.servingStatus);
    }
    if (message.createdBy !== "") {
      obj.createdBy = message.createdBy;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (!message.diskUsageBytes.equals(Long.ZERO)) {
      obj.diskUsageBytes = (message.diskUsageBytes || Long.ZERO).toString();
    }
    if (message.runtimeApiVersion !== "") {
      obj.runtimeApiVersion = message.runtimeApiVersion;
    }
    if (message.runtimeMainExecutablePath !== "") {
      obj.runtimeMainExecutablePath = message.runtimeMainExecutablePath;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.handlers?.length) {
      obj.handlers = message.handlers.map((e) => UrlMap.toJSON(e));
    }
    if (message.errorHandlers?.length) {
      obj.errorHandlers = message.errorHandlers.map((e) => ErrorHandler.toJSON(e));
    }
    if (message.libraries?.length) {
      obj.libraries = message.libraries.map((e) => Library.toJSON(e));
    }
    if (message.apiConfig !== undefined) {
      obj.apiConfig = ApiConfigHandler.toJSON(message.apiConfig);
    }
    if (message.envVariables) {
      const entries = Object.entries(message.envVariables);
      if (entries.length > 0) {
        obj.envVariables = {};
        entries.forEach(([k, v]) => {
          obj.envVariables[k] = v;
        });
      }
    }
    if (message.buildEnvVariables) {
      const entries = Object.entries(message.buildEnvVariables);
      if (entries.length > 0) {
        obj.buildEnvVariables = {};
        entries.forEach(([k, v]) => {
          obj.buildEnvVariables[k] = v;
        });
      }
    }
    if (message.defaultExpiration !== undefined) {
      obj.defaultExpiration = Duration.toJSON(message.defaultExpiration);
    }
    if (message.healthCheck !== undefined) {
      obj.healthCheck = HealthCheck.toJSON(message.healthCheck);
    }
    if (message.readinessCheck !== undefined) {
      obj.readinessCheck = ReadinessCheck.toJSON(message.readinessCheck);
    }
    if (message.livenessCheck !== undefined) {
      obj.livenessCheck = LivenessCheck.toJSON(message.livenessCheck);
    }
    if (message.nobuildFilesRegex !== "") {
      obj.nobuildFilesRegex = message.nobuildFilesRegex;
    }
    if (message.deployment !== undefined) {
      obj.deployment = Deployment.toJSON(message.deployment);
    }
    if (message.versionUrl !== "") {
      obj.versionUrl = message.versionUrl;
    }
    if (message.endpointsApiService !== undefined) {
      obj.endpointsApiService = EndpointsApiService.toJSON(message.endpointsApiService);
    }
    if (message.entrypoint !== undefined) {
      obj.entrypoint = Entrypoint.toJSON(message.entrypoint);
    }
    if (message.vpcAccessConnector !== undefined) {
      obj.vpcAccessConnector = VpcAccessConnector.toJSON(message.vpcAccessConnector);
    }
    return obj;
  },

  create(base?: DeepPartial<Version>): Version {
    return Version.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Version>): Version {
    const message = createBaseVersion();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.automaticScaling = (object.automaticScaling !== undefined && object.automaticScaling !== null)
      ? AutomaticScaling.fromPartial(object.automaticScaling)
      : undefined;
    message.basicScaling = (object.basicScaling !== undefined && object.basicScaling !== null)
      ? BasicScaling.fromPartial(object.basicScaling)
      : undefined;
    message.manualScaling = (object.manualScaling !== undefined && object.manualScaling !== null)
      ? ManualScaling.fromPartial(object.manualScaling)
      : undefined;
    message.inboundServices = object.inboundServices?.map((e) => e) || [];
    message.instanceClass = object.instanceClass ?? "";
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.zones = object.zones?.map((e) => e) || [];
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? Resources.fromPartial(object.resources)
      : undefined;
    message.runtime = object.runtime ?? "";
    message.runtimeChannel = object.runtimeChannel ?? "";
    message.threadsafe = object.threadsafe ?? false;
    message.vm = object.vm ?? false;
    message.appEngineApis = object.appEngineApis ?? false;
    message.betaSettings = Object.entries(object.betaSettings ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.env = object.env ?? "";
    message.servingStatus = object.servingStatus ?? 0;
    message.createdBy = object.createdBy ?? "";
    message.createTime = object.createTime ?? undefined;
    message.diskUsageBytes = (object.diskUsageBytes !== undefined && object.diskUsageBytes !== null)
      ? Long.fromValue(object.diskUsageBytes)
      : Long.ZERO;
    message.runtimeApiVersion = object.runtimeApiVersion ?? "";
    message.runtimeMainExecutablePath = object.runtimeMainExecutablePath ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.handlers = object.handlers?.map((e) => UrlMap.fromPartial(e)) || [];
    message.errorHandlers = object.errorHandlers?.map((e) => ErrorHandler.fromPartial(e)) || [];
    message.libraries = object.libraries?.map((e) => Library.fromPartial(e)) || [];
    message.apiConfig = (object.apiConfig !== undefined && object.apiConfig !== null)
      ? ApiConfigHandler.fromPartial(object.apiConfig)
      : undefined;
    message.envVariables = Object.entries(object.envVariables ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.buildEnvVariables = Object.entries(object.buildEnvVariables ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.defaultExpiration = (object.defaultExpiration !== undefined && object.defaultExpiration !== null)
      ? Duration.fromPartial(object.defaultExpiration)
      : undefined;
    message.healthCheck = (object.healthCheck !== undefined && object.healthCheck !== null)
      ? HealthCheck.fromPartial(object.healthCheck)
      : undefined;
    message.readinessCheck = (object.readinessCheck !== undefined && object.readinessCheck !== null)
      ? ReadinessCheck.fromPartial(object.readinessCheck)
      : undefined;
    message.livenessCheck = (object.livenessCheck !== undefined && object.livenessCheck !== null)
      ? LivenessCheck.fromPartial(object.livenessCheck)
      : undefined;
    message.nobuildFilesRegex = object.nobuildFilesRegex ?? "";
    message.deployment = (object.deployment !== undefined && object.deployment !== null)
      ? Deployment.fromPartial(object.deployment)
      : undefined;
    message.versionUrl = object.versionUrl ?? "";
    message.endpointsApiService = (object.endpointsApiService !== undefined && object.endpointsApiService !== null)
      ? EndpointsApiService.fromPartial(object.endpointsApiService)
      : undefined;
    message.entrypoint = (object.entrypoint !== undefined && object.entrypoint !== null)
      ? Entrypoint.fromPartial(object.entrypoint)
      : undefined;
    message.vpcAccessConnector = (object.vpcAccessConnector !== undefined && object.vpcAccessConnector !== null)
      ? VpcAccessConnector.fromPartial(object.vpcAccessConnector)
      : undefined;
    return message;
  },
};

function createBaseVersion_BetaSettingsEntry(): Version_BetaSettingsEntry {
  return { key: "", value: "" };
}

export const Version_BetaSettingsEntry: MessageFns<Version_BetaSettingsEntry> = {
  encode(message: Version_BetaSettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Version_BetaSettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersion_BetaSettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Version_BetaSettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Version_BetaSettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Version_BetaSettingsEntry>): Version_BetaSettingsEntry {
    return Version_BetaSettingsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Version_BetaSettingsEntry>): Version_BetaSettingsEntry {
    const message = createBaseVersion_BetaSettingsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVersion_EnvVariablesEntry(): Version_EnvVariablesEntry {
  return { key: "", value: "" };
}

export const Version_EnvVariablesEntry: MessageFns<Version_EnvVariablesEntry> = {
  encode(message: Version_EnvVariablesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Version_EnvVariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersion_EnvVariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Version_EnvVariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Version_EnvVariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Version_EnvVariablesEntry>): Version_EnvVariablesEntry {
    return Version_EnvVariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Version_EnvVariablesEntry>): Version_EnvVariablesEntry {
    const message = createBaseVersion_EnvVariablesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVersion_BuildEnvVariablesEntry(): Version_BuildEnvVariablesEntry {
  return { key: "", value: "" };
}

export const Version_BuildEnvVariablesEntry: MessageFns<Version_BuildEnvVariablesEntry> = {
  encode(message: Version_BuildEnvVariablesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Version_BuildEnvVariablesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersion_BuildEnvVariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Version_BuildEnvVariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Version_BuildEnvVariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Version_BuildEnvVariablesEntry>): Version_BuildEnvVariablesEntry {
    return Version_BuildEnvVariablesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Version_BuildEnvVariablesEntry>): Version_BuildEnvVariablesEntry {
    const message = createBaseVersion_BuildEnvVariablesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEndpointsApiService(): EndpointsApiService {
  return { name: "", configId: "", rolloutStrategy: 0, disableTraceSampling: false };
}

export const EndpointsApiService: MessageFns<EndpointsApiService> = {
  encode(message: EndpointsApiService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.configId !== "") {
      writer.uint32(18).string(message.configId);
    }
    if (message.rolloutStrategy !== 0) {
      writer.uint32(24).int32(message.rolloutStrategy);
    }
    if (message.disableTraceSampling !== false) {
      writer.uint32(32).bool(message.disableTraceSampling);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndpointsApiService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndpointsApiService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.configId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rolloutStrategy = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.disableTraceSampling = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndpointsApiService {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      configId: isSet(object.configId) ? globalThis.String(object.configId) : "",
      rolloutStrategy: isSet(object.rolloutStrategy)
        ? endpointsApiService_RolloutStrategyFromJSON(object.rolloutStrategy)
        : 0,
      disableTraceSampling: isSet(object.disableTraceSampling)
        ? globalThis.Boolean(object.disableTraceSampling)
        : false,
    };
  },

  toJSON(message: EndpointsApiService): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.configId !== "") {
      obj.configId = message.configId;
    }
    if (message.rolloutStrategy !== 0) {
      obj.rolloutStrategy = endpointsApiService_RolloutStrategyToJSON(message.rolloutStrategy);
    }
    if (message.disableTraceSampling !== false) {
      obj.disableTraceSampling = message.disableTraceSampling;
    }
    return obj;
  },

  create(base?: DeepPartial<EndpointsApiService>): EndpointsApiService {
    return EndpointsApiService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EndpointsApiService>): EndpointsApiService {
    const message = createBaseEndpointsApiService();
    message.name = object.name ?? "";
    message.configId = object.configId ?? "";
    message.rolloutStrategy = object.rolloutStrategy ?? 0;
    message.disableTraceSampling = object.disableTraceSampling ?? false;
    return message;
  },
};

function createBaseAutomaticScaling(): AutomaticScaling {
  return {
    coolDownPeriod: undefined,
    cpuUtilization: undefined,
    maxConcurrentRequests: 0,
    maxIdleInstances: 0,
    maxTotalInstances: 0,
    maxPendingLatency: undefined,
    minIdleInstances: 0,
    minTotalInstances: 0,
    minPendingLatency: undefined,
    requestUtilization: undefined,
    diskUtilization: undefined,
    networkUtilization: undefined,
    customMetrics: [],
    standardSchedulerSettings: undefined,
  };
}

export const AutomaticScaling: MessageFns<AutomaticScaling> = {
  encode(message: AutomaticScaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coolDownPeriod !== undefined) {
      Duration.encode(message.coolDownPeriod, writer.uint32(10).fork()).join();
    }
    if (message.cpuUtilization !== undefined) {
      CpuUtilization.encode(message.cpuUtilization, writer.uint32(18).fork()).join();
    }
    if (message.maxConcurrentRequests !== 0) {
      writer.uint32(24).int32(message.maxConcurrentRequests);
    }
    if (message.maxIdleInstances !== 0) {
      writer.uint32(32).int32(message.maxIdleInstances);
    }
    if (message.maxTotalInstances !== 0) {
      writer.uint32(40).int32(message.maxTotalInstances);
    }
    if (message.maxPendingLatency !== undefined) {
      Duration.encode(message.maxPendingLatency, writer.uint32(50).fork()).join();
    }
    if (message.minIdleInstances !== 0) {
      writer.uint32(56).int32(message.minIdleInstances);
    }
    if (message.minTotalInstances !== 0) {
      writer.uint32(64).int32(message.minTotalInstances);
    }
    if (message.minPendingLatency !== undefined) {
      Duration.encode(message.minPendingLatency, writer.uint32(74).fork()).join();
    }
    if (message.requestUtilization !== undefined) {
      RequestUtilization.encode(message.requestUtilization, writer.uint32(82).fork()).join();
    }
    if (message.diskUtilization !== undefined) {
      DiskUtilization.encode(message.diskUtilization, writer.uint32(90).fork()).join();
    }
    if (message.networkUtilization !== undefined) {
      NetworkUtilization.encode(message.networkUtilization, writer.uint32(98).fork()).join();
    }
    for (const v of message.customMetrics) {
      CustomMetric.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.standardSchedulerSettings !== undefined) {
      StandardSchedulerSettings.encode(message.standardSchedulerSettings, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutomaticScaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutomaticScaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.coolDownPeriod = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cpuUtilization = CpuUtilization.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxConcurrentRequests = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxIdleInstances = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxTotalInstances = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.maxPendingLatency = Duration.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.minIdleInstances = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.minTotalInstances = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.minPendingLatency = Duration.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.requestUtilization = RequestUtilization.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.diskUtilization = DiskUtilization.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.networkUtilization = NetworkUtilization.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.customMetrics.push(CustomMetric.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.standardSchedulerSettings = StandardSchedulerSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutomaticScaling {
    return {
      coolDownPeriod: isSet(object.coolDownPeriod) ? Duration.fromJSON(object.coolDownPeriod) : undefined,
      cpuUtilization: isSet(object.cpuUtilization) ? CpuUtilization.fromJSON(object.cpuUtilization) : undefined,
      maxConcurrentRequests: isSet(object.maxConcurrentRequests) ? globalThis.Number(object.maxConcurrentRequests) : 0,
      maxIdleInstances: isSet(object.maxIdleInstances) ? globalThis.Number(object.maxIdleInstances) : 0,
      maxTotalInstances: isSet(object.maxTotalInstances) ? globalThis.Number(object.maxTotalInstances) : 0,
      maxPendingLatency: isSet(object.maxPendingLatency) ? Duration.fromJSON(object.maxPendingLatency) : undefined,
      minIdleInstances: isSet(object.minIdleInstances) ? globalThis.Number(object.minIdleInstances) : 0,
      minTotalInstances: isSet(object.minTotalInstances) ? globalThis.Number(object.minTotalInstances) : 0,
      minPendingLatency: isSet(object.minPendingLatency) ? Duration.fromJSON(object.minPendingLatency) : undefined,
      requestUtilization: isSet(object.requestUtilization)
        ? RequestUtilization.fromJSON(object.requestUtilization)
        : undefined,
      diskUtilization: isSet(object.diskUtilization) ? DiskUtilization.fromJSON(object.diskUtilization) : undefined,
      networkUtilization: isSet(object.networkUtilization)
        ? NetworkUtilization.fromJSON(object.networkUtilization)
        : undefined,
      customMetrics: globalThis.Array.isArray(object?.customMetrics)
        ? object.customMetrics.map((e: any) => CustomMetric.fromJSON(e))
        : [],
      standardSchedulerSettings: isSet(object.standardSchedulerSettings)
        ? StandardSchedulerSettings.fromJSON(object.standardSchedulerSettings)
        : undefined,
    };
  },

  toJSON(message: AutomaticScaling): unknown {
    const obj: any = {};
    if (message.coolDownPeriod !== undefined) {
      obj.coolDownPeriod = Duration.toJSON(message.coolDownPeriod);
    }
    if (message.cpuUtilization !== undefined) {
      obj.cpuUtilization = CpuUtilization.toJSON(message.cpuUtilization);
    }
    if (message.maxConcurrentRequests !== 0) {
      obj.maxConcurrentRequests = Math.round(message.maxConcurrentRequests);
    }
    if (message.maxIdleInstances !== 0) {
      obj.maxIdleInstances = Math.round(message.maxIdleInstances);
    }
    if (message.maxTotalInstances !== 0) {
      obj.maxTotalInstances = Math.round(message.maxTotalInstances);
    }
    if (message.maxPendingLatency !== undefined) {
      obj.maxPendingLatency = Duration.toJSON(message.maxPendingLatency);
    }
    if (message.minIdleInstances !== 0) {
      obj.minIdleInstances = Math.round(message.minIdleInstances);
    }
    if (message.minTotalInstances !== 0) {
      obj.minTotalInstances = Math.round(message.minTotalInstances);
    }
    if (message.minPendingLatency !== undefined) {
      obj.minPendingLatency = Duration.toJSON(message.minPendingLatency);
    }
    if (message.requestUtilization !== undefined) {
      obj.requestUtilization = RequestUtilization.toJSON(message.requestUtilization);
    }
    if (message.diskUtilization !== undefined) {
      obj.diskUtilization = DiskUtilization.toJSON(message.diskUtilization);
    }
    if (message.networkUtilization !== undefined) {
      obj.networkUtilization = NetworkUtilization.toJSON(message.networkUtilization);
    }
    if (message.customMetrics?.length) {
      obj.customMetrics = message.customMetrics.map((e) => CustomMetric.toJSON(e));
    }
    if (message.standardSchedulerSettings !== undefined) {
      obj.standardSchedulerSettings = StandardSchedulerSettings.toJSON(message.standardSchedulerSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<AutomaticScaling>): AutomaticScaling {
    return AutomaticScaling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutomaticScaling>): AutomaticScaling {
    const message = createBaseAutomaticScaling();
    message.coolDownPeriod = (object.coolDownPeriod !== undefined && object.coolDownPeriod !== null)
      ? Duration.fromPartial(object.coolDownPeriod)
      : undefined;
    message.cpuUtilization = (object.cpuUtilization !== undefined && object.cpuUtilization !== null)
      ? CpuUtilization.fromPartial(object.cpuUtilization)
      : undefined;
    message.maxConcurrentRequests = object.maxConcurrentRequests ?? 0;
    message.maxIdleInstances = object.maxIdleInstances ?? 0;
    message.maxTotalInstances = object.maxTotalInstances ?? 0;
    message.maxPendingLatency = (object.maxPendingLatency !== undefined && object.maxPendingLatency !== null)
      ? Duration.fromPartial(object.maxPendingLatency)
      : undefined;
    message.minIdleInstances = object.minIdleInstances ?? 0;
    message.minTotalInstances = object.minTotalInstances ?? 0;
    message.minPendingLatency = (object.minPendingLatency !== undefined && object.minPendingLatency !== null)
      ? Duration.fromPartial(object.minPendingLatency)
      : undefined;
    message.requestUtilization = (object.requestUtilization !== undefined && object.requestUtilization !== null)
      ? RequestUtilization.fromPartial(object.requestUtilization)
      : undefined;
    message.diskUtilization = (object.diskUtilization !== undefined && object.diskUtilization !== null)
      ? DiskUtilization.fromPartial(object.diskUtilization)
      : undefined;
    message.networkUtilization = (object.networkUtilization !== undefined && object.networkUtilization !== null)
      ? NetworkUtilization.fromPartial(object.networkUtilization)
      : undefined;
    message.customMetrics = object.customMetrics?.map((e) => CustomMetric.fromPartial(e)) || [];
    message.standardSchedulerSettings =
      (object.standardSchedulerSettings !== undefined && object.standardSchedulerSettings !== null)
        ? StandardSchedulerSettings.fromPartial(object.standardSchedulerSettings)
        : undefined;
    return message;
  },
};

function createBaseBasicScaling(): BasicScaling {
  return { idleTimeout: undefined, maxInstances: 0 };
}

export const BasicScaling: MessageFns<BasicScaling> = {
  encode(message: BasicScaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.idleTimeout !== undefined) {
      Duration.encode(message.idleTimeout, writer.uint32(10).fork()).join();
    }
    if (message.maxInstances !== 0) {
      writer.uint32(16).int32(message.maxInstances);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BasicScaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBasicScaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.idleTimeout = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxInstances = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BasicScaling {
    return {
      idleTimeout: isSet(object.idleTimeout) ? Duration.fromJSON(object.idleTimeout) : undefined,
      maxInstances: isSet(object.maxInstances) ? globalThis.Number(object.maxInstances) : 0,
    };
  },

  toJSON(message: BasicScaling): unknown {
    const obj: any = {};
    if (message.idleTimeout !== undefined) {
      obj.idleTimeout = Duration.toJSON(message.idleTimeout);
    }
    if (message.maxInstances !== 0) {
      obj.maxInstances = Math.round(message.maxInstances);
    }
    return obj;
  },

  create(base?: DeepPartial<BasicScaling>): BasicScaling {
    return BasicScaling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BasicScaling>): BasicScaling {
    const message = createBaseBasicScaling();
    message.idleTimeout = (object.idleTimeout !== undefined && object.idleTimeout !== null)
      ? Duration.fromPartial(object.idleTimeout)
      : undefined;
    message.maxInstances = object.maxInstances ?? 0;
    return message;
  },
};

function createBaseManualScaling(): ManualScaling {
  return { instances: 0 };
}

export const ManualScaling: MessageFns<ManualScaling> = {
  encode(message: ManualScaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instances !== 0) {
      writer.uint32(8).int32(message.instances);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManualScaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManualScaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.instances = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManualScaling {
    return { instances: isSet(object.instances) ? globalThis.Number(object.instances) : 0 };
  },

  toJSON(message: ManualScaling): unknown {
    const obj: any = {};
    if (message.instances !== 0) {
      obj.instances = Math.round(message.instances);
    }
    return obj;
  },

  create(base?: DeepPartial<ManualScaling>): ManualScaling {
    return ManualScaling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManualScaling>): ManualScaling {
    const message = createBaseManualScaling();
    message.instances = object.instances ?? 0;
    return message;
  },
};

function createBaseCpuUtilization(): CpuUtilization {
  return { aggregationWindowLength: undefined, targetUtilization: 0 };
}

export const CpuUtilization: MessageFns<CpuUtilization> = {
  encode(message: CpuUtilization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aggregationWindowLength !== undefined) {
      Duration.encode(message.aggregationWindowLength, writer.uint32(10).fork()).join();
    }
    if (message.targetUtilization !== 0) {
      writer.uint32(17).double(message.targetUtilization);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CpuUtilization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCpuUtilization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.aggregationWindowLength = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.targetUtilization = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CpuUtilization {
    return {
      aggregationWindowLength: isSet(object.aggregationWindowLength)
        ? Duration.fromJSON(object.aggregationWindowLength)
        : undefined,
      targetUtilization: isSet(object.targetUtilization) ? globalThis.Number(object.targetUtilization) : 0,
    };
  },

  toJSON(message: CpuUtilization): unknown {
    const obj: any = {};
    if (message.aggregationWindowLength !== undefined) {
      obj.aggregationWindowLength = Duration.toJSON(message.aggregationWindowLength);
    }
    if (message.targetUtilization !== 0) {
      obj.targetUtilization = message.targetUtilization;
    }
    return obj;
  },

  create(base?: DeepPartial<CpuUtilization>): CpuUtilization {
    return CpuUtilization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CpuUtilization>): CpuUtilization {
    const message = createBaseCpuUtilization();
    message.aggregationWindowLength =
      (object.aggregationWindowLength !== undefined && object.aggregationWindowLength !== null)
        ? Duration.fromPartial(object.aggregationWindowLength)
        : undefined;
    message.targetUtilization = object.targetUtilization ?? 0;
    return message;
  },
};

function createBaseRequestUtilization(): RequestUtilization {
  return { targetRequestCountPerSecond: 0, targetConcurrentRequests: 0 };
}

export const RequestUtilization: MessageFns<RequestUtilization> = {
  encode(message: RequestUtilization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetRequestCountPerSecond !== 0) {
      writer.uint32(8).int32(message.targetRequestCountPerSecond);
    }
    if (message.targetConcurrentRequests !== 0) {
      writer.uint32(16).int32(message.targetConcurrentRequests);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestUtilization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestUtilization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetRequestCountPerSecond = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.targetConcurrentRequests = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestUtilization {
    return {
      targetRequestCountPerSecond: isSet(object.targetRequestCountPerSecond)
        ? globalThis.Number(object.targetRequestCountPerSecond)
        : 0,
      targetConcurrentRequests: isSet(object.targetConcurrentRequests)
        ? globalThis.Number(object.targetConcurrentRequests)
        : 0,
    };
  },

  toJSON(message: RequestUtilization): unknown {
    const obj: any = {};
    if (message.targetRequestCountPerSecond !== 0) {
      obj.targetRequestCountPerSecond = Math.round(message.targetRequestCountPerSecond);
    }
    if (message.targetConcurrentRequests !== 0) {
      obj.targetConcurrentRequests = Math.round(message.targetConcurrentRequests);
    }
    return obj;
  },

  create(base?: DeepPartial<RequestUtilization>): RequestUtilization {
    return RequestUtilization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestUtilization>): RequestUtilization {
    const message = createBaseRequestUtilization();
    message.targetRequestCountPerSecond = object.targetRequestCountPerSecond ?? 0;
    message.targetConcurrentRequests = object.targetConcurrentRequests ?? 0;
    return message;
  },
};

function createBaseDiskUtilization(): DiskUtilization {
  return {
    targetWriteBytesPerSecond: 0,
    targetWriteOpsPerSecond: 0,
    targetReadBytesPerSecond: 0,
    targetReadOpsPerSecond: 0,
  };
}

export const DiskUtilization: MessageFns<DiskUtilization> = {
  encode(message: DiskUtilization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetWriteBytesPerSecond !== 0) {
      writer.uint32(112).int32(message.targetWriteBytesPerSecond);
    }
    if (message.targetWriteOpsPerSecond !== 0) {
      writer.uint32(120).int32(message.targetWriteOpsPerSecond);
    }
    if (message.targetReadBytesPerSecond !== 0) {
      writer.uint32(128).int32(message.targetReadBytesPerSecond);
    }
    if (message.targetReadOpsPerSecond !== 0) {
      writer.uint32(136).int32(message.targetReadOpsPerSecond);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiskUtilization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskUtilization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 14:
          if (tag !== 112) {
            break;
          }

          message.targetWriteBytesPerSecond = reader.int32();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.targetWriteOpsPerSecond = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.targetReadBytesPerSecond = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.targetReadOpsPerSecond = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiskUtilization {
    return {
      targetWriteBytesPerSecond: isSet(object.targetWriteBytesPerSecond)
        ? globalThis.Number(object.targetWriteBytesPerSecond)
        : 0,
      targetWriteOpsPerSecond: isSet(object.targetWriteOpsPerSecond)
        ? globalThis.Number(object.targetWriteOpsPerSecond)
        : 0,
      targetReadBytesPerSecond: isSet(object.targetReadBytesPerSecond)
        ? globalThis.Number(object.targetReadBytesPerSecond)
        : 0,
      targetReadOpsPerSecond: isSet(object.targetReadOpsPerSecond)
        ? globalThis.Number(object.targetReadOpsPerSecond)
        : 0,
    };
  },

  toJSON(message: DiskUtilization): unknown {
    const obj: any = {};
    if (message.targetWriteBytesPerSecond !== 0) {
      obj.targetWriteBytesPerSecond = Math.round(message.targetWriteBytesPerSecond);
    }
    if (message.targetWriteOpsPerSecond !== 0) {
      obj.targetWriteOpsPerSecond = Math.round(message.targetWriteOpsPerSecond);
    }
    if (message.targetReadBytesPerSecond !== 0) {
      obj.targetReadBytesPerSecond = Math.round(message.targetReadBytesPerSecond);
    }
    if (message.targetReadOpsPerSecond !== 0) {
      obj.targetReadOpsPerSecond = Math.round(message.targetReadOpsPerSecond);
    }
    return obj;
  },

  create(base?: DeepPartial<DiskUtilization>): DiskUtilization {
    return DiskUtilization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiskUtilization>): DiskUtilization {
    const message = createBaseDiskUtilization();
    message.targetWriteBytesPerSecond = object.targetWriteBytesPerSecond ?? 0;
    message.targetWriteOpsPerSecond = object.targetWriteOpsPerSecond ?? 0;
    message.targetReadBytesPerSecond = object.targetReadBytesPerSecond ?? 0;
    message.targetReadOpsPerSecond = object.targetReadOpsPerSecond ?? 0;
    return message;
  },
};

function createBaseNetworkUtilization(): NetworkUtilization {
  return {
    targetSentBytesPerSecond: 0,
    targetSentPacketsPerSecond: 0,
    targetReceivedBytesPerSecond: 0,
    targetReceivedPacketsPerSecond: 0,
  };
}

export const NetworkUtilization: MessageFns<NetworkUtilization> = {
  encode(message: NetworkUtilization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetSentBytesPerSecond !== 0) {
      writer.uint32(8).int32(message.targetSentBytesPerSecond);
    }
    if (message.targetSentPacketsPerSecond !== 0) {
      writer.uint32(88).int32(message.targetSentPacketsPerSecond);
    }
    if (message.targetReceivedBytesPerSecond !== 0) {
      writer.uint32(96).int32(message.targetReceivedBytesPerSecond);
    }
    if (message.targetReceivedPacketsPerSecond !== 0) {
      writer.uint32(104).int32(message.targetReceivedPacketsPerSecond);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkUtilization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkUtilization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetSentBytesPerSecond = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.targetSentPacketsPerSecond = reader.int32();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.targetReceivedBytesPerSecond = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.targetReceivedPacketsPerSecond = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkUtilization {
    return {
      targetSentBytesPerSecond: isSet(object.targetSentBytesPerSecond)
        ? globalThis.Number(object.targetSentBytesPerSecond)
        : 0,
      targetSentPacketsPerSecond: isSet(object.targetSentPacketsPerSecond)
        ? globalThis.Number(object.targetSentPacketsPerSecond)
        : 0,
      targetReceivedBytesPerSecond: isSet(object.targetReceivedBytesPerSecond)
        ? globalThis.Number(object.targetReceivedBytesPerSecond)
        : 0,
      targetReceivedPacketsPerSecond: isSet(object.targetReceivedPacketsPerSecond)
        ? globalThis.Number(object.targetReceivedPacketsPerSecond)
        : 0,
    };
  },

  toJSON(message: NetworkUtilization): unknown {
    const obj: any = {};
    if (message.targetSentBytesPerSecond !== 0) {
      obj.targetSentBytesPerSecond = Math.round(message.targetSentBytesPerSecond);
    }
    if (message.targetSentPacketsPerSecond !== 0) {
      obj.targetSentPacketsPerSecond = Math.round(message.targetSentPacketsPerSecond);
    }
    if (message.targetReceivedBytesPerSecond !== 0) {
      obj.targetReceivedBytesPerSecond = Math.round(message.targetReceivedBytesPerSecond);
    }
    if (message.targetReceivedPacketsPerSecond !== 0) {
      obj.targetReceivedPacketsPerSecond = Math.round(message.targetReceivedPacketsPerSecond);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkUtilization>): NetworkUtilization {
    return NetworkUtilization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkUtilization>): NetworkUtilization {
    const message = createBaseNetworkUtilization();
    message.targetSentBytesPerSecond = object.targetSentBytesPerSecond ?? 0;
    message.targetSentPacketsPerSecond = object.targetSentPacketsPerSecond ?? 0;
    message.targetReceivedBytesPerSecond = object.targetReceivedBytesPerSecond ?? 0;
    message.targetReceivedPacketsPerSecond = object.targetReceivedPacketsPerSecond ?? 0;
    return message;
  },
};

function createBaseCustomMetric(): CustomMetric {
  return {
    metricName: "",
    targetType: "",
    targetUtilization: undefined,
    singleInstanceAssignment: undefined,
    filter: "",
  };
}

export const CustomMetric: MessageFns<CustomMetric> = {
  encode(message: CustomMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metricName !== "") {
      writer.uint32(10).string(message.metricName);
    }
    if (message.targetType !== "") {
      writer.uint32(18).string(message.targetType);
    }
    if (message.targetUtilization !== undefined) {
      writer.uint32(25).double(message.targetUtilization);
    }
    if (message.singleInstanceAssignment !== undefined) {
      writer.uint32(33).double(message.singleInstanceAssignment);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metricName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetType = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.targetUtilization = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.singleInstanceAssignment = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomMetric {
    return {
      metricName: isSet(object.metricName) ? globalThis.String(object.metricName) : "",
      targetType: isSet(object.targetType) ? globalThis.String(object.targetType) : "",
      targetUtilization: isSet(object.targetUtilization) ? globalThis.Number(object.targetUtilization) : undefined,
      singleInstanceAssignment: isSet(object.singleInstanceAssignment)
        ? globalThis.Number(object.singleInstanceAssignment)
        : undefined,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: CustomMetric): unknown {
    const obj: any = {};
    if (message.metricName !== "") {
      obj.metricName = message.metricName;
    }
    if (message.targetType !== "") {
      obj.targetType = message.targetType;
    }
    if (message.targetUtilization !== undefined) {
      obj.targetUtilization = message.targetUtilization;
    }
    if (message.singleInstanceAssignment !== undefined) {
      obj.singleInstanceAssignment = message.singleInstanceAssignment;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomMetric>): CustomMetric {
    return CustomMetric.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomMetric>): CustomMetric {
    const message = createBaseCustomMetric();
    message.metricName = object.metricName ?? "";
    message.targetType = object.targetType ?? "";
    message.targetUtilization = object.targetUtilization ?? undefined;
    message.singleInstanceAssignment = object.singleInstanceAssignment ?? undefined;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseStandardSchedulerSettings(): StandardSchedulerSettings {
  return { targetCpuUtilization: 0, targetThroughputUtilization: 0, minInstances: 0, maxInstances: 0 };
}

export const StandardSchedulerSettings: MessageFns<StandardSchedulerSettings> = {
  encode(message: StandardSchedulerSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetCpuUtilization !== 0) {
      writer.uint32(9).double(message.targetCpuUtilization);
    }
    if (message.targetThroughputUtilization !== 0) {
      writer.uint32(17).double(message.targetThroughputUtilization);
    }
    if (message.minInstances !== 0) {
      writer.uint32(24).int32(message.minInstances);
    }
    if (message.maxInstances !== 0) {
      writer.uint32(32).int32(message.maxInstances);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StandardSchedulerSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStandardSchedulerSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.targetCpuUtilization = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.targetThroughputUtilization = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.minInstances = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.maxInstances = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StandardSchedulerSettings {
    return {
      targetCpuUtilization: isSet(object.targetCpuUtilization) ? globalThis.Number(object.targetCpuUtilization) : 0,
      targetThroughputUtilization: isSet(object.targetThroughputUtilization)
        ? globalThis.Number(object.targetThroughputUtilization)
        : 0,
      minInstances: isSet(object.minInstances) ? globalThis.Number(object.minInstances) : 0,
      maxInstances: isSet(object.maxInstances) ? globalThis.Number(object.maxInstances) : 0,
    };
  },

  toJSON(message: StandardSchedulerSettings): unknown {
    const obj: any = {};
    if (message.targetCpuUtilization !== 0) {
      obj.targetCpuUtilization = message.targetCpuUtilization;
    }
    if (message.targetThroughputUtilization !== 0) {
      obj.targetThroughputUtilization = message.targetThroughputUtilization;
    }
    if (message.minInstances !== 0) {
      obj.minInstances = Math.round(message.minInstances);
    }
    if (message.maxInstances !== 0) {
      obj.maxInstances = Math.round(message.maxInstances);
    }
    return obj;
  },

  create(base?: DeepPartial<StandardSchedulerSettings>): StandardSchedulerSettings {
    return StandardSchedulerSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StandardSchedulerSettings>): StandardSchedulerSettings {
    const message = createBaseStandardSchedulerSettings();
    message.targetCpuUtilization = object.targetCpuUtilization ?? 0;
    message.targetThroughputUtilization = object.targetThroughputUtilization ?? 0;
    message.minInstances = object.minInstances ?? 0;
    message.maxInstances = object.maxInstances ?? 0;
    return message;
  },
};

function createBaseNetwork(): Network {
  return { forwardedPorts: [], instanceTag: "", name: "", subnetworkName: "", sessionAffinity: false };
}

export const Network: MessageFns<Network> = {
  encode(message: Network, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.forwardedPorts) {
      writer.uint32(10).string(v!);
    }
    if (message.instanceTag !== "") {
      writer.uint32(18).string(message.instanceTag);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.subnetworkName !== "") {
      writer.uint32(34).string(message.subnetworkName);
    }
    if (message.sessionAffinity !== false) {
      writer.uint32(40).bool(message.sessionAffinity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Network {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetwork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.forwardedPorts.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceTag = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subnetworkName = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sessionAffinity = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Network {
    return {
      forwardedPorts: globalThis.Array.isArray(object?.forwardedPorts)
        ? object.forwardedPorts.map((e: any) => globalThis.String(e))
        : [],
      instanceTag: isSet(object.instanceTag) ? globalThis.String(object.instanceTag) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      subnetworkName: isSet(object.subnetworkName) ? globalThis.String(object.subnetworkName) : "",
      sessionAffinity: isSet(object.sessionAffinity) ? globalThis.Boolean(object.sessionAffinity) : false,
    };
  },

  toJSON(message: Network): unknown {
    const obj: any = {};
    if (message.forwardedPorts?.length) {
      obj.forwardedPorts = message.forwardedPorts;
    }
    if (message.instanceTag !== "") {
      obj.instanceTag = message.instanceTag;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.subnetworkName !== "") {
      obj.subnetworkName = message.subnetworkName;
    }
    if (message.sessionAffinity !== false) {
      obj.sessionAffinity = message.sessionAffinity;
    }
    return obj;
  },

  create(base?: DeepPartial<Network>): Network {
    return Network.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Network>): Network {
    const message = createBaseNetwork();
    message.forwardedPorts = object.forwardedPorts?.map((e) => e) || [];
    message.instanceTag = object.instanceTag ?? "";
    message.name = object.name ?? "";
    message.subnetworkName = object.subnetworkName ?? "";
    message.sessionAffinity = object.sessionAffinity ?? false;
    return message;
  },
};

function createBaseVolume(): Volume {
  return { name: "", volumeType: "", sizeGb: 0 };
}

export const Volume: MessageFns<Volume> = {
  encode(message: Volume, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.volumeType !== "") {
      writer.uint32(18).string(message.volumeType);
    }
    if (message.sizeGb !== 0) {
      writer.uint32(25).double(message.sizeGb);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Volume {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.volumeType = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.sizeGb = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Volume {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      volumeType: isSet(object.volumeType) ? globalThis.String(object.volumeType) : "",
      sizeGb: isSet(object.sizeGb) ? globalThis.Number(object.sizeGb) : 0,
    };
  },

  toJSON(message: Volume): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.volumeType !== "") {
      obj.volumeType = message.volumeType;
    }
    if (message.sizeGb !== 0) {
      obj.sizeGb = message.sizeGb;
    }
    return obj;
  },

  create(base?: DeepPartial<Volume>): Volume {
    return Volume.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Volume>): Volume {
    const message = createBaseVolume();
    message.name = object.name ?? "";
    message.volumeType = object.volumeType ?? "";
    message.sizeGb = object.sizeGb ?? 0;
    return message;
  },
};

function createBaseResources(): Resources {
  return { cpu: 0, diskGb: 0, memoryGb: 0, volumes: [], kmsKeyReference: "" };
}

export const Resources: MessageFns<Resources> = {
  encode(message: Resources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpu !== 0) {
      writer.uint32(9).double(message.cpu);
    }
    if (message.diskGb !== 0) {
      writer.uint32(17).double(message.diskGb);
    }
    if (message.memoryGb !== 0) {
      writer.uint32(25).double(message.memoryGb);
    }
    for (const v of message.volumes) {
      Volume.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.kmsKeyReference !== "") {
      writer.uint32(42).string(message.kmsKeyReference);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.cpu = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.diskGb = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.memoryGb = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.volumes.push(Volume.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.kmsKeyReference = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resources {
    return {
      cpu: isSet(object.cpu) ? globalThis.Number(object.cpu) : 0,
      diskGb: isSet(object.diskGb) ? globalThis.Number(object.diskGb) : 0,
      memoryGb: isSet(object.memoryGb) ? globalThis.Number(object.memoryGb) : 0,
      volumes: globalThis.Array.isArray(object?.volumes) ? object.volumes.map((e: any) => Volume.fromJSON(e)) : [],
      kmsKeyReference: isSet(object.kmsKeyReference) ? globalThis.String(object.kmsKeyReference) : "",
    };
  },

  toJSON(message: Resources): unknown {
    const obj: any = {};
    if (message.cpu !== 0) {
      obj.cpu = message.cpu;
    }
    if (message.diskGb !== 0) {
      obj.diskGb = message.diskGb;
    }
    if (message.memoryGb !== 0) {
      obj.memoryGb = message.memoryGb;
    }
    if (message.volumes?.length) {
      obj.volumes = message.volumes.map((e) => Volume.toJSON(e));
    }
    if (message.kmsKeyReference !== "") {
      obj.kmsKeyReference = message.kmsKeyReference;
    }
    return obj;
  },

  create(base?: DeepPartial<Resources>): Resources {
    return Resources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Resources>): Resources {
    const message = createBaseResources();
    message.cpu = object.cpu ?? 0;
    message.diskGb = object.diskGb ?? 0;
    message.memoryGb = object.memoryGb ?? 0;
    message.volumes = object.volumes?.map((e) => Volume.fromPartial(e)) || [];
    message.kmsKeyReference = object.kmsKeyReference ?? "";
    return message;
  },
};

function createBaseVpcAccessConnector(): VpcAccessConnector {
  return { name: "" };
}

export const VpcAccessConnector: MessageFns<VpcAccessConnector> = {
  encode(message: VpcAccessConnector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpcAccessConnector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpcAccessConnector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpcAccessConnector {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: VpcAccessConnector): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<VpcAccessConnector>): VpcAccessConnector {
    return VpcAccessConnector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpcAccessConnector>): VpcAccessConnector {
    const message = createBaseVpcAccessConnector();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseEntrypoint(): Entrypoint {
  return { shell: undefined };
}

export const Entrypoint: MessageFns<Entrypoint> = {
  encode(message: Entrypoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shell !== undefined) {
      writer.uint32(10).string(message.shell);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entrypoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntrypoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.shell = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entrypoint {
    return { shell: isSet(object.shell) ? globalThis.String(object.shell) : undefined };
  },

  toJSON(message: Entrypoint): unknown {
    const obj: any = {};
    if (message.shell !== undefined) {
      obj.shell = message.shell;
    }
    return obj;
  },

  create(base?: DeepPartial<Entrypoint>): Entrypoint {
    return Entrypoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entrypoint>): Entrypoint {
    const message = createBaseEntrypoint();
    message.shell = object.shell ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
