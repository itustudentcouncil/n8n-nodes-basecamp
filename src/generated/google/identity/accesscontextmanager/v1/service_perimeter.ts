// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/identity/accesscontextmanager/v1/service_perimeter.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.identity.accesscontextmanager.v1";

/**
 * `ServicePerimeter` describes a set of Google Cloud resources which can freely
 * import and export data amongst themselves, but not export outside of the
 * `ServicePerimeter`. If a request with a source within this `ServicePerimeter`
 * has a target outside of the `ServicePerimeter`, the request will be blocked.
 * Otherwise the request is allowed. There are two types of Service Perimeter -
 * Regular and Bridge. Regular Service Perimeters cannot overlap, a single
 * Google Cloud project can only belong to a single regular Service Perimeter.
 * Service Perimeter Bridges can contain only Google Cloud projects as members,
 * a single Google Cloud project may belong to multiple Service Perimeter
 * Bridges.
 */
export interface ServicePerimeter {
  /**
   * Required. Resource name for the ServicePerimeter.  The `short_name`
   * component must begin with a letter and only include alphanumeric and '_'.
   * Format:
   * `accessPolicies/{access_policy}/servicePerimeters/{service_perimeter}`
   */
  name: string;
  /** Human readable title. Must be unique within the Policy. */
  title: string;
  /**
   * Description of the `ServicePerimeter` and its use. Does not affect
   * behavior.
   */
  description: string;
  /** Output only. Time the `ServicePerimeter` was created in UTC. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time the `ServicePerimeter` was updated in UTC. */
  updateTime:
    | Date
    | undefined;
  /**
   * Perimeter type indicator. A single project is
   * allowed to be a member of single regular perimeter, but multiple service
   * perimeter bridges. A project cannot be a included in a perimeter bridge
   * without being included in regular perimeter. For perimeter bridges,
   * the restricted service list as well as access level lists must be
   * empty.
   */
  perimeterType: ServicePerimeter_PerimeterType;
  /**
   * Current ServicePerimeter configuration. Specifies sets of resources,
   * restricted services and access levels that determine perimeter
   * content and boundaries.
   */
  status:
    | ServicePerimeterConfig
    | undefined;
  /**
   * Proposed (or dry run) ServicePerimeter configuration. This configuration
   * allows to specify and test ServicePerimeter configuration without enforcing
   * actual access restrictions. Only allowed to be set when the
   * "use_explicit_dry_run_spec" flag is set.
   */
  spec:
    | ServicePerimeterConfig
    | undefined;
  /**
   * Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly
   * exists  for all Service Perimeters, and that spec is identical to the
   * status for those Service Perimeters. When this flag is set, it inhibits the
   * generation of the implicit spec, thereby allowing the user to explicitly
   * provide a configuration ("spec") to use in a dry-run version of the Service
   * Perimeter. This allows the user to test changes to the enforced config
   * ("status") without actually enforcing them. This testing is done through
   * analyzing the differences between currently enforced and suggested
   * restrictions. use_explicit_dry_run_spec must bet set to True if any of the
   * fields in the spec are set to non-default values.
   */
  useExplicitDryRunSpec: boolean;
}

/**
 * Specifies the type of the Perimeter. There are two types: regular and
 * bridge. Regular Service Perimeter contains resources, access levels, and
 * restricted services. Every resource can be in at most ONE
 * regular Service Perimeter.
 *
 * In addition to being in a regular service perimeter, a resource can also
 * be in zero or more perimeter bridges.  A perimeter bridge only contains
 * resources.  Cross project operations are permitted if all effected
 * resources share some perimeter (whether bridge or regular). Perimeter
 * Bridge does not contain access levels or services: those are governed
 * entirely by the regular perimeter that resource is in.
 *
 * Perimeter Bridges are typically useful when building more complex toplogies
 * with many independent perimeters that need to share some data with a common
 * perimeter, but should not be able to share data among themselves.
 */
export enum ServicePerimeter_PerimeterType {
  /** PERIMETER_TYPE_REGULAR - Regular Perimeter. */
  PERIMETER_TYPE_REGULAR = 0,
  /** PERIMETER_TYPE_BRIDGE - Perimeter Bridge. */
  PERIMETER_TYPE_BRIDGE = 1,
  UNRECOGNIZED = -1,
}

export function servicePerimeter_PerimeterTypeFromJSON(object: any): ServicePerimeter_PerimeterType {
  switch (object) {
    case 0:
    case "PERIMETER_TYPE_REGULAR":
      return ServicePerimeter_PerimeterType.PERIMETER_TYPE_REGULAR;
    case 1:
    case "PERIMETER_TYPE_BRIDGE":
      return ServicePerimeter_PerimeterType.PERIMETER_TYPE_BRIDGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServicePerimeter_PerimeterType.UNRECOGNIZED;
  }
}

export function servicePerimeter_PerimeterTypeToJSON(object: ServicePerimeter_PerimeterType): string {
  switch (object) {
    case ServicePerimeter_PerimeterType.PERIMETER_TYPE_REGULAR:
      return "PERIMETER_TYPE_REGULAR";
    case ServicePerimeter_PerimeterType.PERIMETER_TYPE_BRIDGE:
      return "PERIMETER_TYPE_BRIDGE";
    case ServicePerimeter_PerimeterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * `ServicePerimeterConfig` specifies a set of Google Cloud resources that
 * describe specific Service Perimeter configuration.
 */
export interface ServicePerimeterConfig {
  /**
   * A list of Google Cloud resources that are inside of the service perimeter.
   * Currently only projects are allowed. Format: `projects/{project_number}`
   */
  resources: string[];
  /**
   * A list of `AccessLevel` resource names that allow resources within the
   * `ServicePerimeter` to be accessed from the internet. `AccessLevels` listed
   * must be in the same policy as this `ServicePerimeter`. Referencing a
   * nonexistent `AccessLevel` is a syntax error. If no `AccessLevel` names are
   * listed, resources within the perimeter can only be accessed via Google
   * Cloud calls with request origins within the perimeter. Example:
   * `"accessPolicies/MY_POLICY/accessLevels/MY_LEVEL"`.
   * For Service Perimeter Bridge, must be empty.
   */
  accessLevels: string[];
  /**
   * Google Cloud services that are subject to the Service Perimeter
   * restrictions. For example, if `storage.googleapis.com` is specified, access
   * to the storage buckets inside the perimeter must meet the perimeter's
   * access restrictions.
   */
  restrictedServices: string[];
  /** Configuration for APIs allowed within Perimeter. */
  vpcAccessibleServices:
    | ServicePerimeterConfig_VpcAccessibleServices
    | undefined;
  /**
   * List of [IngressPolicies]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * to apply to the perimeter. A perimeter may have multiple [IngressPolicies]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy],
   * each of which is evaluated separately. Access is granted if any [Ingress
   * Policy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * grants it. Must be empty for a perimeter bridge.
   */
  ingressPolicies: ServicePerimeterConfig_IngressPolicy[];
  /**
   * List of [EgressPolicies]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
   * to apply to the perimeter. A perimeter may have multiple [EgressPolicies]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy],
   * each of which is evaluated separately. Access is granted if any
   * [EgressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
   * grants it. Must be empty for a perimeter bridge.
   */
  egressPolicies: ServicePerimeterConfig_EgressPolicy[];
}

/**
 * Specifies the types of identities that are allowed access in either
 * [IngressFrom]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom]
 * or [EgressFrom]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom]
 * rules.
 */
export enum ServicePerimeterConfig_IdentityType {
  /** IDENTITY_TYPE_UNSPECIFIED - No blanket identity group specified. */
  IDENTITY_TYPE_UNSPECIFIED = 0,
  /** ANY_IDENTITY - Authorize access from all identities outside the perimeter. */
  ANY_IDENTITY = 1,
  /** ANY_USER_ACCOUNT - Authorize access from all human users outside the perimeter. */
  ANY_USER_ACCOUNT = 2,
  /** ANY_SERVICE_ACCOUNT - Authorize access from all service accounts outside the perimeter. */
  ANY_SERVICE_ACCOUNT = 3,
  UNRECOGNIZED = -1,
}

export function servicePerimeterConfig_IdentityTypeFromJSON(object: any): ServicePerimeterConfig_IdentityType {
  switch (object) {
    case 0:
    case "IDENTITY_TYPE_UNSPECIFIED":
      return ServicePerimeterConfig_IdentityType.IDENTITY_TYPE_UNSPECIFIED;
    case 1:
    case "ANY_IDENTITY":
      return ServicePerimeterConfig_IdentityType.ANY_IDENTITY;
    case 2:
    case "ANY_USER_ACCOUNT":
      return ServicePerimeterConfig_IdentityType.ANY_USER_ACCOUNT;
    case 3:
    case "ANY_SERVICE_ACCOUNT":
      return ServicePerimeterConfig_IdentityType.ANY_SERVICE_ACCOUNT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServicePerimeterConfig_IdentityType.UNRECOGNIZED;
  }
}

export function servicePerimeterConfig_IdentityTypeToJSON(object: ServicePerimeterConfig_IdentityType): string {
  switch (object) {
    case ServicePerimeterConfig_IdentityType.IDENTITY_TYPE_UNSPECIFIED:
      return "IDENTITY_TYPE_UNSPECIFIED";
    case ServicePerimeterConfig_IdentityType.ANY_IDENTITY:
      return "ANY_IDENTITY";
    case ServicePerimeterConfig_IdentityType.ANY_USER_ACCOUNT:
      return "ANY_USER_ACCOUNT";
    case ServicePerimeterConfig_IdentityType.ANY_SERVICE_ACCOUNT:
      return "ANY_SERVICE_ACCOUNT";
    case ServicePerimeterConfig_IdentityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies how APIs are allowed to communicate within the Service
 * Perimeter.
 */
export interface ServicePerimeterConfig_VpcAccessibleServices {
  /**
   * Whether to restrict API calls within the Service Perimeter to the list of
   * APIs specified in 'allowed_services'.
   */
  enableRestriction: boolean;
  /**
   * The list of APIs usable within the Service Perimeter. Must be empty
   * unless 'enable_restriction' is True. You can specify a list of individual
   * services, as well as include the 'RESTRICTED-SERVICES' value, which
   * automatically includes all of the services protected by the perimeter.
   */
  allowedServices: string[];
}

/**
 * An allowed method or permission of a service specified in [ApiOperation]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation].
 */
export interface ServicePerimeterConfig_MethodSelector {
  /**
   * Value for `method` should be a valid method name for the corresponding
   * `service_name` in [ApiOperation]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation].
   * If `*` used as value for `method`, then ALL methods and permissions are
   * allowed.
   */
  method?:
    | string
    | undefined;
  /**
   * Value for `permission` should be a valid Cloud IAM permission for the
   * corresponding `service_name` in [ApiOperation]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation].
   */
  permission?: string | undefined;
}

/** Identification for an API Operation. */
export interface ServicePerimeterConfig_ApiOperation {
  /**
   * The name of the API whose methods or permissions the [IngressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * or [EgressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
   * want to allow. A single [ApiOperation]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
   * with `service_name` field set to `*` will allow all methods AND
   * permissions for all services.
   */
  serviceName: string;
  /**
   * API methods or permissions to allow. Method or permission must belong to
   * the service specified by `service_name` field. A single [MethodSelector]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.MethodSelector]
   * entry with `*` specified for the `method` field will allow all methods
   * AND permissions for the service specified in `service_name`.
   */
  methodSelectors: ServicePerimeterConfig_MethodSelector[];
}

/**
 * The source that [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * authorizes access from.
 */
export interface ServicePerimeterConfig_IngressSource {
  /**
   * An [AccessLevel]
   * [google.identity.accesscontextmanager.v1.AccessLevel] resource
   * name that allow resources within the [ServicePerimeters]
   * [google.identity.accesscontextmanager.v1.ServicePerimeter] to be
   * accessed from the internet. [AccessLevels]
   * [google.identity.accesscontextmanager.v1.AccessLevel] listed must
   * be in the same policy as this [ServicePerimeter]
   * [google.identity.accesscontextmanager.v1.ServicePerimeter].
   * Referencing a nonexistent [AccessLevel]
   * [google.identity.accesscontextmanager.v1.AccessLevel] will cause
   * an error. If no [AccessLevel]
   * [google.identity.accesscontextmanager.v1.AccessLevel] names are
   * listed, resources within the perimeter can only be accessed via Google
   * Cloud calls with request origins within the perimeter. Example:
   * `accessPolicies/MY_POLICY/accessLevels/MY_LEVEL`. If a single `*` is
   * specified for `access_level`, then all [IngressSources]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressSource]
   * will be allowed.
   */
  accessLevel?:
    | string
    | undefined;
  /**
   * A Google Cloud resource that is allowed to ingress the perimeter.
   * Requests from these resources will be allowed to access perimeter data.
   * Currently only projects are allowed.
   * Format: `projects/{project_number}`
   * The project may be in any Google Cloud organization, not just the
   * organization that the perimeter is defined in. `*` is not allowed, the
   * case of allowing all Google Cloud resources only is not supported.
   */
  resource?: string | undefined;
}

/**
 * Defines the conditions under which an [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * matches a request. Conditions are based on information about the source of
 * the request. The request must satisfy what is defined in `sources` AND
 * identity related fields in order to match.
 */
export interface ServicePerimeterConfig_IngressFrom {
  /**
   * Sources that this [IngressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * authorizes access from.
   */
  sources: ServicePerimeterConfig_IngressSource[];
  /**
   * A list of identities that are allowed access through this ingress
   * policy. Should be in the format of email address. The email address
   * should represent individual user or service account only.
   */
  identities: string[];
  /**
   * Specifies the type of identities that are allowed access from outside the
   * perimeter. If left unspecified, then members of `identities` field will
   * be allowed access.
   */
  identityType: ServicePerimeterConfig_IdentityType;
}

/**
 * Defines the conditions under which an [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * matches a request. Conditions are based on information about the
 * [ApiOperation]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
 * intended to be performed on the target resource of the request. The request
 * must satisfy what is defined in `operations` AND `resources` in order to
 * match.
 */
export interface ServicePerimeterConfig_IngressTo {
  /**
   * A list of [ApiOperations]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
   * allowed to be performed by the sources specified in corresponding
   * [IngressFrom]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom]
   * in this [ServicePerimeter]
   * [google.identity.accesscontextmanager.v1.ServicePerimeter].
   */
  operations: ServicePerimeterConfig_ApiOperation[];
  /**
   * A list of resources, currently only projects in the form
   * `projects/<projectnumber>`, protected by this [ServicePerimeter]
   * [google.identity.accesscontextmanager.v1.ServicePerimeter] that are
   * allowed to be accessed by sources defined in the corresponding
   * [IngressFrom]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressFrom].
   * If a single `*` is specified, then access to all resources inside the
   * perimeter are allowed.
   */
  resources: string[];
}

/**
 * Policy for ingress into [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter].
 *
 * [IngressPolicies]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * match requests based on `ingress_from` and `ingress_to` stanzas.  For an
 * ingress policy to match, both the `ingress_from` and `ingress_to` stanzas
 * must be matched. If an [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * matches a request, the request is allowed through the perimeter boundary
 * from outside the perimeter.
 *
 * For example, access from the internet can be allowed either
 * based on an [AccessLevel]
 * [google.identity.accesscontextmanager.v1.AccessLevel] or, for traffic
 * hosted on Google Cloud, the project of the source network. For access from
 * private networks, using the project of the hosting network is required.
 *
 * Individual ingress policies can be limited by restricting which
 * services and/or actions they match using the `ingress_to` field.
 */
export interface ServicePerimeterConfig_IngressPolicy {
  /**
   * Defines the conditions on the source of a request causing this
   * [IngressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * to apply.
   */
  ingressFrom:
    | ServicePerimeterConfig_IngressFrom
    | undefined;
  /**
   * Defines the conditions on the [ApiOperation]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
   * and request destination that cause this [IngressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
   * to apply.
   */
  ingressTo: ServicePerimeterConfig_IngressTo | undefined;
}

/**
 * Defines the conditions under which an [EgressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * matches a request. Conditions based on information about the source of the
 * request. Note that if the destination of the request is also protected by a
 * [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter], then that
 * [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter] must have
 * an [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * which allows access in order for this request to succeed.
 */
export interface ServicePerimeterConfig_EgressFrom {
  /**
   * A list of identities that are allowed access through this [EgressPolicy].
   * Should be in the format of email address. The email address should
   * represent individual user or service account only.
   */
  identities: string[];
  /**
   * Specifies the type of identities that are allowed access to outside the
   * perimeter. If left unspecified, then members of `identities` field will
   * be allowed access.
   */
  identityType: ServicePerimeterConfig_IdentityType;
}

/**
 * Defines the conditions under which an [EgressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * matches a request. Conditions are based on information about the
 * [ApiOperation]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
 * intended to be performed on the `resources` specified. Note that if the
 * destination of the request is also protected by a [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter], then that
 * [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter] must have
 * an [IngressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.IngressPolicy]
 * which allows access in order for this request to succeed. The request must
 * match `operations` AND `resources` fields in order to be allowed egress out
 * of the perimeter.
 */
export interface ServicePerimeterConfig_EgressTo {
  /**
   * A list of resources, currently only projects in the form
   * `projects/<projectnumber>`, that are allowed to be accessed by sources
   * defined in the corresponding [EgressFrom]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom].
   * A request matches if it contains a resource in this list.  If `*` is
   * specified for `resources`, then this [EgressTo]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressTo]
   * rule will authorize access to all resources outside the perimeter.
   */
  resources: string[];
  /**
   * A list of [ApiOperations]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
   * allowed to be performed by the sources specified in the corresponding
   * [EgressFrom]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom].
   * A request matches if it uses an operation/service in this list.
   */
  operations: ServicePerimeterConfig_ApiOperation[];
  /**
   * A list of external resources that are allowed to be accessed. Only AWS
   * and Azure resources are supported. For Amazon S3, the supported format is
   * s3://BUCKET_NAME. For Azure Storage, the supported format is
   * azure://myaccount.blob.core.windows.net/CONTAINER_NAME. A request matches
   * if it contains an external resource in this list (Example:
   * s3://bucket/path). Currently '*' is not allowed.
   */
  externalResources: string[];
}

/**
 * Policy for egress from perimeter.
 *
 * [EgressPolicies]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * match requests based on `egress_from` and `egress_to` stanzas.  For an
 * [EgressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * to match, both `egress_from` and `egress_to` stanzas must be matched. If an
 * [EgressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * matches a request, the request is allowed to span the [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter] boundary.
 * For example, an [EgressPolicy]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * can be used to allow VMs on networks within the [ServicePerimeter]
 * [google.identity.accesscontextmanager.v1.ServicePerimeter] to access a
 * defined set of projects outside the perimeter in certain contexts (e.g. to
 * read data from a Cloud Storage bucket or query against a BigQuery dataset).
 *
 * [EgressPolicies]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
 * are concerned with the *resources* that a request relates as well as the
 * API services and API actions being used.  They do not related to the
 * direction of data movement.  More detailed documentation for this concept
 * can be found in the descriptions of [EgressFrom]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressFrom]
 * and [EgressTo]
 * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressTo].
 */
export interface ServicePerimeterConfig_EgressPolicy {
  /**
   * Defines conditions on the source of a request causing this [EgressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
   * to apply.
   */
  egressFrom:
    | ServicePerimeterConfig_EgressFrom
    | undefined;
  /**
   * Defines the conditions on the [ApiOperation]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.ApiOperation]
   * and destination resources that cause this [EgressPolicy]
   * [google.identity.accesscontextmanager.v1.ServicePerimeterConfig.EgressPolicy]
   * to apply.
   */
  egressTo: ServicePerimeterConfig_EgressTo | undefined;
}

function createBaseServicePerimeter(): ServicePerimeter {
  return {
    name: "",
    title: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    perimeterType: 0,
    status: undefined,
    spec: undefined,
    useExplicitDryRunSpec: false,
  };
}

export const ServicePerimeter: MessageFns<ServicePerimeter> = {
  encode(message: ServicePerimeter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    if (message.perimeterType !== 0) {
      writer.uint32(48).int32(message.perimeterType);
    }
    if (message.status !== undefined) {
      ServicePerimeterConfig.encode(message.status, writer.uint32(58).fork()).join();
    }
    if (message.spec !== undefined) {
      ServicePerimeterConfig.encode(message.spec, writer.uint32(66).fork()).join();
    }
    if (message.useExplicitDryRunSpec !== false) {
      writer.uint32(72).bool(message.useExplicitDryRunSpec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.perimeterType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.status = ServicePerimeterConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.spec = ServicePerimeterConfig.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.useExplicitDryRunSpec = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      perimeterType: isSet(object.perimeterType) ? servicePerimeter_PerimeterTypeFromJSON(object.perimeterType) : 0,
      status: isSet(object.status) ? ServicePerimeterConfig.fromJSON(object.status) : undefined,
      spec: isSet(object.spec) ? ServicePerimeterConfig.fromJSON(object.spec) : undefined,
      useExplicitDryRunSpec: isSet(object.useExplicitDryRunSpec)
        ? globalThis.Boolean(object.useExplicitDryRunSpec)
        : false,
    };
  },

  toJSON(message: ServicePerimeter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.perimeterType !== 0) {
      obj.perimeterType = servicePerimeter_PerimeterTypeToJSON(message.perimeterType);
    }
    if (message.status !== undefined) {
      obj.status = ServicePerimeterConfig.toJSON(message.status);
    }
    if (message.spec !== undefined) {
      obj.spec = ServicePerimeterConfig.toJSON(message.spec);
    }
    if (message.useExplicitDryRunSpec !== false) {
      obj.useExplicitDryRunSpec = message.useExplicitDryRunSpec;
    }
    return obj;
  },

  create(base?: DeepPartial<ServicePerimeter>): ServicePerimeter {
    return ServicePerimeter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServicePerimeter>): ServicePerimeter {
    const message = createBaseServicePerimeter();
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.perimeterType = object.perimeterType ?? 0;
    message.status = (object.status !== undefined && object.status !== null)
      ? ServicePerimeterConfig.fromPartial(object.status)
      : undefined;
    message.spec = (object.spec !== undefined && object.spec !== null)
      ? ServicePerimeterConfig.fromPartial(object.spec)
      : undefined;
    message.useExplicitDryRunSpec = object.useExplicitDryRunSpec ?? false;
    return message;
  },
};

function createBaseServicePerimeterConfig(): ServicePerimeterConfig {
  return {
    resources: [],
    accessLevels: [],
    restrictedServices: [],
    vpcAccessibleServices: undefined,
    ingressPolicies: [],
    egressPolicies: [],
  };
}

export const ServicePerimeterConfig: MessageFns<ServicePerimeterConfig> = {
  encode(message: ServicePerimeterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.resources) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.accessLevels) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.restrictedServices) {
      writer.uint32(34).string(v!);
    }
    if (message.vpcAccessibleServices !== undefined) {
      ServicePerimeterConfig_VpcAccessibleServices.encode(message.vpcAccessibleServices, writer.uint32(82).fork())
        .join();
    }
    for (const v of message.ingressPolicies) {
      ServicePerimeterConfig_IngressPolicy.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.egressPolicies) {
      ServicePerimeterConfig_EgressPolicy.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resources.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessLevels.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.restrictedServices.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.vpcAccessibleServices = ServicePerimeterConfig_VpcAccessibleServices.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ingressPolicies.push(ServicePerimeterConfig_IngressPolicy.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.egressPolicies.push(ServicePerimeterConfig_EgressPolicy.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeterConfig {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => globalThis.String(e))
        : [],
      accessLevels: globalThis.Array.isArray(object?.accessLevels)
        ? object.accessLevels.map((e: any) => globalThis.String(e))
        : [],
      restrictedServices: globalThis.Array.isArray(object?.restrictedServices)
        ? object.restrictedServices.map((e: any) => globalThis.String(e))
        : [],
      vpcAccessibleServices: isSet(object.vpcAccessibleServices)
        ? ServicePerimeterConfig_VpcAccessibleServices.fromJSON(object.vpcAccessibleServices)
        : undefined,
      ingressPolicies: globalThis.Array.isArray(object?.ingressPolicies)
        ? object.ingressPolicies.map((e: any) => ServicePerimeterConfig_IngressPolicy.fromJSON(e))
        : [],
      egressPolicies: globalThis.Array.isArray(object?.egressPolicies)
        ? object.egressPolicies.map((e: any) => ServicePerimeterConfig_EgressPolicy.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ServicePerimeterConfig): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources;
    }
    if (message.accessLevels?.length) {
      obj.accessLevels = message.accessLevels;
    }
    if (message.restrictedServices?.length) {
      obj.restrictedServices = message.restrictedServices;
    }
    if (message.vpcAccessibleServices !== undefined) {
      obj.vpcAccessibleServices = ServicePerimeterConfig_VpcAccessibleServices.toJSON(message.vpcAccessibleServices);
    }
    if (message.ingressPolicies?.length) {
      obj.ingressPolicies = message.ingressPolicies.map((e) => ServicePerimeterConfig_IngressPolicy.toJSON(e));
    }
    if (message.egressPolicies?.length) {
      obj.egressPolicies = message.egressPolicies.map((e) => ServicePerimeterConfig_EgressPolicy.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ServicePerimeterConfig>): ServicePerimeterConfig {
    return ServicePerimeterConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServicePerimeterConfig>): ServicePerimeterConfig {
    const message = createBaseServicePerimeterConfig();
    message.resources = object.resources?.map((e) => e) || [];
    message.accessLevels = object.accessLevels?.map((e) => e) || [];
    message.restrictedServices = object.restrictedServices?.map((e) => e) || [];
    message.vpcAccessibleServices =
      (object.vpcAccessibleServices !== undefined && object.vpcAccessibleServices !== null)
        ? ServicePerimeterConfig_VpcAccessibleServices.fromPartial(object.vpcAccessibleServices)
        : undefined;
    message.ingressPolicies = object.ingressPolicies?.map((e) => ServicePerimeterConfig_IngressPolicy.fromPartial(e)) ||
      [];
    message.egressPolicies = object.egressPolicies?.map((e) => ServicePerimeterConfig_EgressPolicy.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseServicePerimeterConfig_VpcAccessibleServices(): ServicePerimeterConfig_VpcAccessibleServices {
  return { enableRestriction: false, allowedServices: [] };
}

export const ServicePerimeterConfig_VpcAccessibleServices: MessageFns<ServicePerimeterConfig_VpcAccessibleServices> = {
  encode(
    message: ServicePerimeterConfig_VpcAccessibleServices,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.enableRestriction !== false) {
      writer.uint32(8).bool(message.enableRestriction);
    }
    for (const v of message.allowedServices) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeterConfig_VpcAccessibleServices {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeterConfig_VpcAccessibleServices();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableRestriction = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.allowedServices.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeterConfig_VpcAccessibleServices {
    return {
      enableRestriction: isSet(object.enableRestriction) ? globalThis.Boolean(object.enableRestriction) : false,
      allowedServices: globalThis.Array.isArray(object?.allowedServices)
        ? object.allowedServices.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ServicePerimeterConfig_VpcAccessibleServices): unknown {
    const obj: any = {};
    if (message.enableRestriction !== false) {
      obj.enableRestriction = message.enableRestriction;
    }
    if (message.allowedServices?.length) {
      obj.allowedServices = message.allowedServices;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ServicePerimeterConfig_VpcAccessibleServices>,
  ): ServicePerimeterConfig_VpcAccessibleServices {
    return ServicePerimeterConfig_VpcAccessibleServices.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ServicePerimeterConfig_VpcAccessibleServices>,
  ): ServicePerimeterConfig_VpcAccessibleServices {
    const message = createBaseServicePerimeterConfig_VpcAccessibleServices();
    message.enableRestriction = object.enableRestriction ?? false;
    message.allowedServices = object.allowedServices?.map((e) => e) || [];
    return message;
  },
};

function createBaseServicePerimeterConfig_MethodSelector(): ServicePerimeterConfig_MethodSelector {
  return { method: undefined, permission: undefined };
}

export const ServicePerimeterConfig_MethodSelector: MessageFns<ServicePerimeterConfig_MethodSelector> = {
  encode(message: ServicePerimeterConfig_MethodSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.method !== undefined) {
      writer.uint32(10).string(message.method);
    }
    if (message.permission !== undefined) {
      writer.uint32(18).string(message.permission);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeterConfig_MethodSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeterConfig_MethodSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.method = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.permission = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeterConfig_MethodSelector {
    return {
      method: isSet(object.method) ? globalThis.String(object.method) : undefined,
      permission: isSet(object.permission) ? globalThis.String(object.permission) : undefined,
    };
  },

  toJSON(message: ServicePerimeterConfig_MethodSelector): unknown {
    const obj: any = {};
    if (message.method !== undefined) {
      obj.method = message.method;
    }
    if (message.permission !== undefined) {
      obj.permission = message.permission;
    }
    return obj;
  },

  create(base?: DeepPartial<ServicePerimeterConfig_MethodSelector>): ServicePerimeterConfig_MethodSelector {
    return ServicePerimeterConfig_MethodSelector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServicePerimeterConfig_MethodSelector>): ServicePerimeterConfig_MethodSelector {
    const message = createBaseServicePerimeterConfig_MethodSelector();
    message.method = object.method ?? undefined;
    message.permission = object.permission ?? undefined;
    return message;
  },
};

function createBaseServicePerimeterConfig_ApiOperation(): ServicePerimeterConfig_ApiOperation {
  return { serviceName: "", methodSelectors: [] };
}

export const ServicePerimeterConfig_ApiOperation: MessageFns<ServicePerimeterConfig_ApiOperation> = {
  encode(message: ServicePerimeterConfig_ApiOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    for (const v of message.methodSelectors) {
      ServicePerimeterConfig_MethodSelector.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeterConfig_ApiOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeterConfig_ApiOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.methodSelectors.push(ServicePerimeterConfig_MethodSelector.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeterConfig_ApiOperation {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      methodSelectors: globalThis.Array.isArray(object?.methodSelectors)
        ? object.methodSelectors.map((e: any) => ServicePerimeterConfig_MethodSelector.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ServicePerimeterConfig_ApiOperation): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.methodSelectors?.length) {
      obj.methodSelectors = message.methodSelectors.map((e) => ServicePerimeterConfig_MethodSelector.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ServicePerimeterConfig_ApiOperation>): ServicePerimeterConfig_ApiOperation {
    return ServicePerimeterConfig_ApiOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServicePerimeterConfig_ApiOperation>): ServicePerimeterConfig_ApiOperation {
    const message = createBaseServicePerimeterConfig_ApiOperation();
    message.serviceName = object.serviceName ?? "";
    message.methodSelectors =
      object.methodSelectors?.map((e) => ServicePerimeterConfig_MethodSelector.fromPartial(e)) || [];
    return message;
  },
};

function createBaseServicePerimeterConfig_IngressSource(): ServicePerimeterConfig_IngressSource {
  return { accessLevel: undefined, resource: undefined };
}

export const ServicePerimeterConfig_IngressSource: MessageFns<ServicePerimeterConfig_IngressSource> = {
  encode(message: ServicePerimeterConfig_IngressSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessLevel !== undefined) {
      writer.uint32(10).string(message.accessLevel);
    }
    if (message.resource !== undefined) {
      writer.uint32(18).string(message.resource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeterConfig_IngressSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeterConfig_IngressSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessLevel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resource = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeterConfig_IngressSource {
    return {
      accessLevel: isSet(object.accessLevel) ? globalThis.String(object.accessLevel) : undefined,
      resource: isSet(object.resource) ? globalThis.String(object.resource) : undefined,
    };
  },

  toJSON(message: ServicePerimeterConfig_IngressSource): unknown {
    const obj: any = {};
    if (message.accessLevel !== undefined) {
      obj.accessLevel = message.accessLevel;
    }
    if (message.resource !== undefined) {
      obj.resource = message.resource;
    }
    return obj;
  },

  create(base?: DeepPartial<ServicePerimeterConfig_IngressSource>): ServicePerimeterConfig_IngressSource {
    return ServicePerimeterConfig_IngressSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServicePerimeterConfig_IngressSource>): ServicePerimeterConfig_IngressSource {
    const message = createBaseServicePerimeterConfig_IngressSource();
    message.accessLevel = object.accessLevel ?? undefined;
    message.resource = object.resource ?? undefined;
    return message;
  },
};

function createBaseServicePerimeterConfig_IngressFrom(): ServicePerimeterConfig_IngressFrom {
  return { sources: [], identities: [], identityType: 0 };
}

export const ServicePerimeterConfig_IngressFrom: MessageFns<ServicePerimeterConfig_IngressFrom> = {
  encode(message: ServicePerimeterConfig_IngressFrom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sources) {
      ServicePerimeterConfig_IngressSource.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.identities) {
      writer.uint32(18).string(v!);
    }
    if (message.identityType !== 0) {
      writer.uint32(24).int32(message.identityType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeterConfig_IngressFrom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeterConfig_IngressFrom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sources.push(ServicePerimeterConfig_IngressSource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.identities.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.identityType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeterConfig_IngressFrom {
    return {
      sources: globalThis.Array.isArray(object?.sources)
        ? object.sources.map((e: any) => ServicePerimeterConfig_IngressSource.fromJSON(e))
        : [],
      identities: globalThis.Array.isArray(object?.identities)
        ? object.identities.map((e: any) => globalThis.String(e))
        : [],
      identityType: isSet(object.identityType) ? servicePerimeterConfig_IdentityTypeFromJSON(object.identityType) : 0,
    };
  },

  toJSON(message: ServicePerimeterConfig_IngressFrom): unknown {
    const obj: any = {};
    if (message.sources?.length) {
      obj.sources = message.sources.map((e) => ServicePerimeterConfig_IngressSource.toJSON(e));
    }
    if (message.identities?.length) {
      obj.identities = message.identities;
    }
    if (message.identityType !== 0) {
      obj.identityType = servicePerimeterConfig_IdentityTypeToJSON(message.identityType);
    }
    return obj;
  },

  create(base?: DeepPartial<ServicePerimeterConfig_IngressFrom>): ServicePerimeterConfig_IngressFrom {
    return ServicePerimeterConfig_IngressFrom.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServicePerimeterConfig_IngressFrom>): ServicePerimeterConfig_IngressFrom {
    const message = createBaseServicePerimeterConfig_IngressFrom();
    message.sources = object.sources?.map((e) => ServicePerimeterConfig_IngressSource.fromPartial(e)) || [];
    message.identities = object.identities?.map((e) => e) || [];
    message.identityType = object.identityType ?? 0;
    return message;
  },
};

function createBaseServicePerimeterConfig_IngressTo(): ServicePerimeterConfig_IngressTo {
  return { operations: [], resources: [] };
}

export const ServicePerimeterConfig_IngressTo: MessageFns<ServicePerimeterConfig_IngressTo> = {
  encode(message: ServicePerimeterConfig_IngressTo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operations) {
      ServicePerimeterConfig_ApiOperation.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.resources) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeterConfig_IngressTo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeterConfig_IngressTo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operations.push(ServicePerimeterConfig_ApiOperation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resources.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeterConfig_IngressTo {
    return {
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => ServicePerimeterConfig_ApiOperation.fromJSON(e))
        : [],
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ServicePerimeterConfig_IngressTo): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => ServicePerimeterConfig_ApiOperation.toJSON(e));
    }
    if (message.resources?.length) {
      obj.resources = message.resources;
    }
    return obj;
  },

  create(base?: DeepPartial<ServicePerimeterConfig_IngressTo>): ServicePerimeterConfig_IngressTo {
    return ServicePerimeterConfig_IngressTo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServicePerimeterConfig_IngressTo>): ServicePerimeterConfig_IngressTo {
    const message = createBaseServicePerimeterConfig_IngressTo();
    message.operations = object.operations?.map((e) => ServicePerimeterConfig_ApiOperation.fromPartial(e)) || [];
    message.resources = object.resources?.map((e) => e) || [];
    return message;
  },
};

function createBaseServicePerimeterConfig_IngressPolicy(): ServicePerimeterConfig_IngressPolicy {
  return { ingressFrom: undefined, ingressTo: undefined };
}

export const ServicePerimeterConfig_IngressPolicy: MessageFns<ServicePerimeterConfig_IngressPolicy> = {
  encode(message: ServicePerimeterConfig_IngressPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ingressFrom !== undefined) {
      ServicePerimeterConfig_IngressFrom.encode(message.ingressFrom, writer.uint32(10).fork()).join();
    }
    if (message.ingressTo !== undefined) {
      ServicePerimeterConfig_IngressTo.encode(message.ingressTo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeterConfig_IngressPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeterConfig_IngressPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ingressFrom = ServicePerimeterConfig_IngressFrom.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ingressTo = ServicePerimeterConfig_IngressTo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeterConfig_IngressPolicy {
    return {
      ingressFrom: isSet(object.ingressFrom)
        ? ServicePerimeterConfig_IngressFrom.fromJSON(object.ingressFrom)
        : undefined,
      ingressTo: isSet(object.ingressTo) ? ServicePerimeterConfig_IngressTo.fromJSON(object.ingressTo) : undefined,
    };
  },

  toJSON(message: ServicePerimeterConfig_IngressPolicy): unknown {
    const obj: any = {};
    if (message.ingressFrom !== undefined) {
      obj.ingressFrom = ServicePerimeterConfig_IngressFrom.toJSON(message.ingressFrom);
    }
    if (message.ingressTo !== undefined) {
      obj.ingressTo = ServicePerimeterConfig_IngressTo.toJSON(message.ingressTo);
    }
    return obj;
  },

  create(base?: DeepPartial<ServicePerimeterConfig_IngressPolicy>): ServicePerimeterConfig_IngressPolicy {
    return ServicePerimeterConfig_IngressPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServicePerimeterConfig_IngressPolicy>): ServicePerimeterConfig_IngressPolicy {
    const message = createBaseServicePerimeterConfig_IngressPolicy();
    message.ingressFrom = (object.ingressFrom !== undefined && object.ingressFrom !== null)
      ? ServicePerimeterConfig_IngressFrom.fromPartial(object.ingressFrom)
      : undefined;
    message.ingressTo = (object.ingressTo !== undefined && object.ingressTo !== null)
      ? ServicePerimeterConfig_IngressTo.fromPartial(object.ingressTo)
      : undefined;
    return message;
  },
};

function createBaseServicePerimeterConfig_EgressFrom(): ServicePerimeterConfig_EgressFrom {
  return { identities: [], identityType: 0 };
}

export const ServicePerimeterConfig_EgressFrom: MessageFns<ServicePerimeterConfig_EgressFrom> = {
  encode(message: ServicePerimeterConfig_EgressFrom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.identities) {
      writer.uint32(10).string(v!);
    }
    if (message.identityType !== 0) {
      writer.uint32(16).int32(message.identityType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeterConfig_EgressFrom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeterConfig_EgressFrom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.identities.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.identityType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeterConfig_EgressFrom {
    return {
      identities: globalThis.Array.isArray(object?.identities)
        ? object.identities.map((e: any) => globalThis.String(e))
        : [],
      identityType: isSet(object.identityType) ? servicePerimeterConfig_IdentityTypeFromJSON(object.identityType) : 0,
    };
  },

  toJSON(message: ServicePerimeterConfig_EgressFrom): unknown {
    const obj: any = {};
    if (message.identities?.length) {
      obj.identities = message.identities;
    }
    if (message.identityType !== 0) {
      obj.identityType = servicePerimeterConfig_IdentityTypeToJSON(message.identityType);
    }
    return obj;
  },

  create(base?: DeepPartial<ServicePerimeterConfig_EgressFrom>): ServicePerimeterConfig_EgressFrom {
    return ServicePerimeterConfig_EgressFrom.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServicePerimeterConfig_EgressFrom>): ServicePerimeterConfig_EgressFrom {
    const message = createBaseServicePerimeterConfig_EgressFrom();
    message.identities = object.identities?.map((e) => e) || [];
    message.identityType = object.identityType ?? 0;
    return message;
  },
};

function createBaseServicePerimeterConfig_EgressTo(): ServicePerimeterConfig_EgressTo {
  return { resources: [], operations: [], externalResources: [] };
}

export const ServicePerimeterConfig_EgressTo: MessageFns<ServicePerimeterConfig_EgressTo> = {
  encode(message: ServicePerimeterConfig_EgressTo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.resources) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.operations) {
      ServicePerimeterConfig_ApiOperation.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.externalResources) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeterConfig_EgressTo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeterConfig_EgressTo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resources.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operations.push(ServicePerimeterConfig_ApiOperation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalResources.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeterConfig_EgressTo {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => globalThis.String(e))
        : [],
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => ServicePerimeterConfig_ApiOperation.fromJSON(e))
        : [],
      externalResources: globalThis.Array.isArray(object?.externalResources)
        ? object.externalResources.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ServicePerimeterConfig_EgressTo): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources;
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => ServicePerimeterConfig_ApiOperation.toJSON(e));
    }
    if (message.externalResources?.length) {
      obj.externalResources = message.externalResources;
    }
    return obj;
  },

  create(base?: DeepPartial<ServicePerimeterConfig_EgressTo>): ServicePerimeterConfig_EgressTo {
    return ServicePerimeterConfig_EgressTo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServicePerimeterConfig_EgressTo>): ServicePerimeterConfig_EgressTo {
    const message = createBaseServicePerimeterConfig_EgressTo();
    message.resources = object.resources?.map((e) => e) || [];
    message.operations = object.operations?.map((e) => ServicePerimeterConfig_ApiOperation.fromPartial(e)) || [];
    message.externalResources = object.externalResources?.map((e) => e) || [];
    return message;
  },
};

function createBaseServicePerimeterConfig_EgressPolicy(): ServicePerimeterConfig_EgressPolicy {
  return { egressFrom: undefined, egressTo: undefined };
}

export const ServicePerimeterConfig_EgressPolicy: MessageFns<ServicePerimeterConfig_EgressPolicy> = {
  encode(message: ServicePerimeterConfig_EgressPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.egressFrom !== undefined) {
      ServicePerimeterConfig_EgressFrom.encode(message.egressFrom, writer.uint32(10).fork()).join();
    }
    if (message.egressTo !== undefined) {
      ServicePerimeterConfig_EgressTo.encode(message.egressTo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServicePerimeterConfig_EgressPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServicePerimeterConfig_EgressPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.egressFrom = ServicePerimeterConfig_EgressFrom.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.egressTo = ServicePerimeterConfig_EgressTo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServicePerimeterConfig_EgressPolicy {
    return {
      egressFrom: isSet(object.egressFrom) ? ServicePerimeterConfig_EgressFrom.fromJSON(object.egressFrom) : undefined,
      egressTo: isSet(object.egressTo) ? ServicePerimeterConfig_EgressTo.fromJSON(object.egressTo) : undefined,
    };
  },

  toJSON(message: ServicePerimeterConfig_EgressPolicy): unknown {
    const obj: any = {};
    if (message.egressFrom !== undefined) {
      obj.egressFrom = ServicePerimeterConfig_EgressFrom.toJSON(message.egressFrom);
    }
    if (message.egressTo !== undefined) {
      obj.egressTo = ServicePerimeterConfig_EgressTo.toJSON(message.egressTo);
    }
    return obj;
  },

  create(base?: DeepPartial<ServicePerimeterConfig_EgressPolicy>): ServicePerimeterConfig_EgressPolicy {
    return ServicePerimeterConfig_EgressPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServicePerimeterConfig_EgressPolicy>): ServicePerimeterConfig_EgressPolicy {
    const message = createBaseServicePerimeterConfig_EgressPolicy();
    message.egressFrom = (object.egressFrom !== undefined && object.egressFrom !== null)
      ? ServicePerimeterConfig_EgressFrom.fromPartial(object.egressFrom)
      : undefined;
    message.egressTo = (object.egressTo !== undefined && object.egressTo !== null)
      ? ServicePerimeterConfig_EgressTo.fromPartial(object.egressTo)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
