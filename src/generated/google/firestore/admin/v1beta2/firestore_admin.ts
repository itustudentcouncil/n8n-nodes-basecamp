// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/firestore/admin/v1beta2/firestore_admin.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Field } from "./field.js";
import { Index } from "./index.js";

export const protobufPackage = "google.firestore.admin.v1beta2";

/** The request for [FirestoreAdmin.CreateIndex][google.firestore.admin.v1beta2.FirestoreAdmin.CreateIndex]. */
export interface CreateIndexRequest {
  /**
   * A parent name of the form
   * `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
   */
  parent: string;
  /** The composite index to create. */
  index: Index | undefined;
}

/** The request for [FirestoreAdmin.ListIndexes][google.firestore.admin.v1beta2.FirestoreAdmin.ListIndexes]. */
export interface ListIndexesRequest {
  /**
   * A parent name of the form
   * `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
   */
  parent: string;
  /** The filter to apply to list results. */
  filter: string;
  /** The number of results to return. */
  pageSize: number;
  /**
   * A page token, returned from a previous call to
   * [FirestoreAdmin.ListIndexes][google.firestore.admin.v1beta2.FirestoreAdmin.ListIndexes], that may be used to get the next
   * page of results.
   */
  pageToken: string;
}

/** The response for [FirestoreAdmin.ListIndexes][google.firestore.admin.v1beta2.FirestoreAdmin.ListIndexes]. */
export interface ListIndexesResponse {
  /** The requested indexes. */
  indexes: Index[];
  /**
   * A page token that may be used to request another page of results. If blank,
   * this is the last page.
   */
  nextPageToken: string;
}

/** The request for [FirestoreAdmin.GetIndex][google.firestore.admin.v1beta2.FirestoreAdmin.GetIndex]. */
export interface GetIndexRequest {
  /**
   * A name of the form
   * `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`
   */
  name: string;
}

/** The request for [FirestoreAdmin.DeleteIndex][google.firestore.admin.v1beta2.FirestoreAdmin.DeleteIndex]. */
export interface DeleteIndexRequest {
  /**
   * A name of the form
   * `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{index_id}`
   */
  name: string;
}

/** The request for [FirestoreAdmin.UpdateField][google.firestore.admin.v1beta2.FirestoreAdmin.UpdateField]. */
export interface UpdateFieldRequest {
  /** The field to be updated. */
  field:
    | Field
    | undefined;
  /**
   * A mask, relative to the field. If specified, only configuration specified
   * by this field_mask will be updated in the field.
   */
  updateMask: string[] | undefined;
}

/** The request for [FirestoreAdmin.GetField][google.firestore.admin.v1beta2.FirestoreAdmin.GetField]. */
export interface GetFieldRequest {
  /**
   * A name of the form
   * `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_id}`
   */
  name: string;
}

/** The request for [FirestoreAdmin.ListFields][google.firestore.admin.v1beta2.FirestoreAdmin.ListFields]. */
export interface ListFieldsRequest {
  /**
   * A parent name of the form
   * `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}`
   */
  parent: string;
  /**
   * The filter to apply to list results. Currently,
   * [FirestoreAdmin.ListFields][google.firestore.admin.v1beta2.FirestoreAdmin.ListFields] only supports listing fields
   * that have been explicitly overridden. To issue this query, call
   * [FirestoreAdmin.ListFields][google.firestore.admin.v1beta2.FirestoreAdmin.ListFields] with the filter set to
   * `indexConfig.usesAncestorConfig:false`.
   */
  filter: string;
  /** The number of results to return. */
  pageSize: number;
  /**
   * A page token, returned from a previous call to
   * [FirestoreAdmin.ListFields][google.firestore.admin.v1beta2.FirestoreAdmin.ListFields], that may be used to get the next
   * page of results.
   */
  pageToken: string;
}

/** The response for [FirestoreAdmin.ListFields][google.firestore.admin.v1beta2.FirestoreAdmin.ListFields]. */
export interface ListFieldsResponse {
  /** The requested fields. */
  fields: Field[];
  /**
   * A page token that may be used to request another page of results. If blank,
   * this is the last page.
   */
  nextPageToken: string;
}

/** The request for [FirestoreAdmin.ExportDocuments][google.firestore.admin.v1beta2.FirestoreAdmin.ExportDocuments]. */
export interface ExportDocumentsRequest {
  /**
   * Database to export. Should be of the form:
   * `projects/{project_id}/databases/{database_id}`.
   */
  name: string;
  /** Which collection ids to export. Unspecified means all collections. */
  collectionIds: string[];
  /**
   * The output URI. Currently only supports Google Cloud Storage URIs of the
   * form: `gs://BUCKET_NAME[/NAMESPACE_PATH]`, where `BUCKET_NAME` is the name
   * of the Google Cloud Storage bucket and `NAMESPACE_PATH` is an optional
   * Google Cloud Storage namespace path. When
   * choosing a name, be sure to consider Google Cloud Storage naming
   * guidelines: https://cloud.google.com/storage/docs/naming.
   * If the URI is a bucket (without a namespace path), a prefix will be
   * generated based on the start time.
   */
  outputUriPrefix: string;
}

/** The request for [FirestoreAdmin.ImportDocuments][google.firestore.admin.v1beta2.FirestoreAdmin.ImportDocuments]. */
export interface ImportDocumentsRequest {
  /**
   * Database to import into. Should be of the form:
   * `projects/{project_id}/databases/{database_id}`.
   */
  name: string;
  /**
   * Which collection ids to import. Unspecified means all collections included
   * in the import.
   */
  collectionIds: string[];
  /**
   * Location of the exported files.
   * This must match the output_uri_prefix of an ExportDocumentsResponse from
   * an export that has completed successfully.
   * See:
   * [google.firestore.admin.v1beta2.ExportDocumentsResponse.output_uri_prefix][google.firestore.admin.v1beta2.ExportDocumentsResponse.output_uri_prefix].
   */
  inputUriPrefix: string;
}

function createBaseCreateIndexRequest(): CreateIndexRequest {
  return { parent: "", index: undefined };
}

export const CreateIndexRequest: MessageFns<CreateIndexRequest> = {
  encode(message: CreateIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.index !== undefined) {
      Index.encode(message.index, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.index = Index.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateIndexRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      index: isSet(object.index) ? Index.fromJSON(object.index) : undefined,
    };
  },

  toJSON(message: CreateIndexRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.index !== undefined) {
      obj.index = Index.toJSON(message.index);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateIndexRequest>): CreateIndexRequest {
    return CreateIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateIndexRequest>): CreateIndexRequest {
    const message = createBaseCreateIndexRequest();
    message.parent = object.parent ?? "";
    message.index = (object.index !== undefined && object.index !== null) ? Index.fromPartial(object.index) : undefined;
    return message;
  },
};

function createBaseListIndexesRequest(): ListIndexesRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListIndexesRequest: MessageFns<ListIndexesRequest> = {
  encode(message: ListIndexesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIndexesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIndexesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIndexesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListIndexesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIndexesRequest>): ListIndexesRequest {
    return ListIndexesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIndexesRequest>): ListIndexesRequest {
    const message = createBaseListIndexesRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListIndexesResponse(): ListIndexesResponse {
  return { indexes: [], nextPageToken: "" };
}

export const ListIndexesResponse: MessageFns<ListIndexesResponse> = {
  encode(message: ListIndexesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.indexes) {
      Index.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListIndexesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListIndexesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.indexes.push(Index.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListIndexesResponse {
    return {
      indexes: globalThis.Array.isArray(object?.indexes) ? object.indexes.map((e: any) => Index.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListIndexesResponse): unknown {
    const obj: any = {};
    if (message.indexes?.length) {
      obj.indexes = message.indexes.map((e) => Index.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListIndexesResponse>): ListIndexesResponse {
    return ListIndexesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListIndexesResponse>): ListIndexesResponse {
    const message = createBaseListIndexesResponse();
    message.indexes = object.indexes?.map((e) => Index.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetIndexRequest(): GetIndexRequest {
  return { name: "" };
}

export const GetIndexRequest: MessageFns<GetIndexRequest> = {
  encode(message: GetIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetIndexRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetIndexRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetIndexRequest>): GetIndexRequest {
    return GetIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetIndexRequest>): GetIndexRequest {
    const message = createBaseGetIndexRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteIndexRequest(): DeleteIndexRequest {
  return { name: "" };
}

export const DeleteIndexRequest: MessageFns<DeleteIndexRequest> = {
  encode(message: DeleteIndexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteIndexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteIndexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteIndexRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteIndexRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteIndexRequest>): DeleteIndexRequest {
    return DeleteIndexRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteIndexRequest>): DeleteIndexRequest {
    const message = createBaseDeleteIndexRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateFieldRequest(): UpdateFieldRequest {
  return { field: undefined, updateMask: undefined };
}

export const UpdateFieldRequest: MessageFns<UpdateFieldRequest> = {
  encode(message: UpdateFieldRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined) {
      Field.encode(message.field, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFieldRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFieldRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = Field.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFieldRequest {
    return {
      field: isSet(object.field) ? Field.fromJSON(object.field) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateFieldRequest): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = Field.toJSON(message.field);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateFieldRequest>): UpdateFieldRequest {
    return UpdateFieldRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateFieldRequest>): UpdateFieldRequest {
    const message = createBaseUpdateFieldRequest();
    message.field = (object.field !== undefined && object.field !== null) ? Field.fromPartial(object.field) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetFieldRequest(): GetFieldRequest {
  return { name: "" };
}

export const GetFieldRequest: MessageFns<GetFieldRequest> = {
  encode(message: GetFieldRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFieldRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFieldRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFieldRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetFieldRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetFieldRequest>): GetFieldRequest {
    return GetFieldRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetFieldRequest>): GetFieldRequest {
    const message = createBaseGetFieldRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListFieldsRequest(): ListFieldsRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListFieldsRequest: MessageFns<ListFieldsRequest> = {
  encode(message: ListFieldsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFieldsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFieldsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFieldsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListFieldsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFieldsRequest>): ListFieldsRequest {
    return ListFieldsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFieldsRequest>): ListFieldsRequest {
    const message = createBaseListFieldsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListFieldsResponse(): ListFieldsResponse {
  return { fields: [], nextPageToken: "" };
}

export const ListFieldsResponse: MessageFns<ListFieldsResponse> = {
  encode(message: ListFieldsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      Field.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFieldsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFieldsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fields.push(Field.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFieldsResponse {
    return {
      fields: globalThis.Array.isArray(object?.fields) ? object.fields.map((e: any) => Field.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListFieldsResponse): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => Field.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFieldsResponse>): ListFieldsResponse {
    return ListFieldsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFieldsResponse>): ListFieldsResponse {
    const message = createBaseListFieldsResponse();
    message.fields = object.fields?.map((e) => Field.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseExportDocumentsRequest(): ExportDocumentsRequest {
  return { name: "", collectionIds: [], outputUriPrefix: "" };
}

export const ExportDocumentsRequest: MessageFns<ExportDocumentsRequest> = {
  encode(message: ExportDocumentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.collectionIds) {
      writer.uint32(18).string(v!);
    }
    if (message.outputUriPrefix !== "") {
      writer.uint32(26).string(message.outputUriPrefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportDocumentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportDocumentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.collectionIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.outputUriPrefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportDocumentsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      collectionIds: globalThis.Array.isArray(object?.collectionIds)
        ? object.collectionIds.map((e: any) => globalThis.String(e))
        : [],
      outputUriPrefix: isSet(object.outputUriPrefix) ? globalThis.String(object.outputUriPrefix) : "",
    };
  },

  toJSON(message: ExportDocumentsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.collectionIds?.length) {
      obj.collectionIds = message.collectionIds;
    }
    if (message.outputUriPrefix !== "") {
      obj.outputUriPrefix = message.outputUriPrefix;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportDocumentsRequest>): ExportDocumentsRequest {
    return ExportDocumentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportDocumentsRequest>): ExportDocumentsRequest {
    const message = createBaseExportDocumentsRequest();
    message.name = object.name ?? "";
    message.collectionIds = object.collectionIds?.map((e) => e) || [];
    message.outputUriPrefix = object.outputUriPrefix ?? "";
    return message;
  },
};

function createBaseImportDocumentsRequest(): ImportDocumentsRequest {
  return { name: "", collectionIds: [], inputUriPrefix: "" };
}

export const ImportDocumentsRequest: MessageFns<ImportDocumentsRequest> = {
  encode(message: ImportDocumentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.collectionIds) {
      writer.uint32(18).string(v!);
    }
    if (message.inputUriPrefix !== "") {
      writer.uint32(26).string(message.inputUriPrefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportDocumentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportDocumentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.collectionIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.inputUriPrefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportDocumentsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      collectionIds: globalThis.Array.isArray(object?.collectionIds)
        ? object.collectionIds.map((e: any) => globalThis.String(e))
        : [],
      inputUriPrefix: isSet(object.inputUriPrefix) ? globalThis.String(object.inputUriPrefix) : "",
    };
  },

  toJSON(message: ImportDocumentsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.collectionIds?.length) {
      obj.collectionIds = message.collectionIds;
    }
    if (message.inputUriPrefix !== "") {
      obj.inputUriPrefix = message.inputUriPrefix;
    }
    return obj;
  },

  create(base?: DeepPartial<ImportDocumentsRequest>): ImportDocumentsRequest {
    return ImportDocumentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportDocumentsRequest>): ImportDocumentsRequest {
    const message = createBaseImportDocumentsRequest();
    message.name = object.name ?? "";
    message.collectionIds = object.collectionIds?.map((e) => e) || [];
    message.inputUriPrefix = object.inputUriPrefix ?? "";
    return message;
  },
};

/**
 * Operations are created by service `FirestoreAdmin`, but are accessed via
 * service `google.longrunning.Operations`.
 */
export type FirestoreAdminDefinition = typeof FirestoreAdminDefinition;
export const FirestoreAdminDefinition = {
  name: "FirestoreAdmin",
  fullName: "google.firestore.admin.v1beta2.FirestoreAdmin",
  methods: {
    /**
     * Creates a composite index. This returns a [google.longrunning.Operation][google.longrunning.Operation]
     * which may be used to track the status of the creation. The metadata for
     * the operation will be the type [IndexOperationMetadata][google.firestore.admin.v1beta2.IndexOperationMetadata].
     */
    createIndex: {
      name: "CreateIndex",
      requestType: CreateIndexRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              76,
              58,
              5,
              105,
              110,
              100,
              101,
              120,
              34,
              67,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists composite indexes. */
    listIndexes: {
      name: "ListIndexes",
      requestType: ListIndexesRequest,
      requestStream: false,
      responseType: ListIndexesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              69,
              18,
              67,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a composite index. */
    getIndex: {
      name: "GetIndex",
      requestType: GetIndexRequest,
      requestStream: false,
      responseType: Index,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              69,
              18,
              67,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a composite index. */
    deleteIndex: {
      name: "DeleteIndex",
      requestType: DeleteIndexRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              69,
              42,
              67,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              47,
              105,
              110,
              100,
              101,
              120,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets the metadata and configuration for a Field. */
    getField: {
      name: "GetField",
      requestType: GetFieldRequest,
      requestStream: false,
      responseType: Field,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              68,
              18,
              66,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              47,
              102,
              105,
              101,
              108,
              100,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a field configuration. Currently, field updates apply only to
     * single field index configuration. However, calls to
     * [FirestoreAdmin.UpdateField][google.firestore.admin.v1beta2.FirestoreAdmin.UpdateField] should provide a field mask to avoid
     * changing any configuration that the caller isn't aware of. The field mask
     * should be specified as: `{ paths: "index_config" }`.
     *
     * This call returns a [google.longrunning.Operation][google.longrunning.Operation] which may be used to
     * track the status of the field update. The metadata for
     * the operation will be the type [FieldOperationMetadata][google.firestore.admin.v1beta2.FieldOperationMetadata].
     *
     * To configure the default field settings for the database, use
     * the special `Field` with resource name:
     * `projects/{project_id}/databases/{database_id}/collectionGroups/__default__/fields/*`.
     */
    updateField: {
      name: "UpdateField",
      requestType: UpdateFieldRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              81,
              58,
              5,
              102,
              105,
              101,
              108,
              100,
              50,
              72,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              102,
              105,
              101,
              108,
              100,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              47,
              102,
              105,
              101,
              108,
              100,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the field configuration and metadata for this database.
     *
     * Currently, [FirestoreAdmin.ListFields][google.firestore.admin.v1beta2.FirestoreAdmin.ListFields] only supports listing fields
     * that have been explicitly overridden. To issue this query, call
     * [FirestoreAdmin.ListFields][google.firestore.admin.v1beta2.FirestoreAdmin.ListFields] with the filter set to
     * `indexConfig.usesAncestorConfig:false`.
     */
    listFields: {
      name: "ListFields",
      requestType: ListFieldsRequest,
      requestStream: false,
      responseType: ListFieldsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              68,
              18,
              66,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              47,
              99,
              111,
              108,
              108,
              101,
              99,
              116,
              105,
              111,
              110,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              47,
              102,
              105,
              101,
              108,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Exports a copy of all or a subset of documents from Google Cloud Firestore
     * to another storage system, such as Google Cloud Storage. Recent updates to
     * documents may not be reflected in the export. The export occurs in the
     * background and its progress can be monitored and managed via the
     * Operation resource that is created. The output of an export may only be
     * used once the associated operation is done. If an export operation is
     * cancelled before completion it may leave partial data behind in Google
     * Cloud Storage.
     */
    exportDocuments: {
      name: "ExportDocuments",
      requestType: ExportDocumentsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              59,
              58,
              1,
              42,
              34,
              54,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
              68,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Imports documents into Google Cloud Firestore. Existing documents with the
     * same name are overwritten. The import occurs in the background and its
     * progress can be monitored and managed via the Operation resource that is
     * created. If an ImportDocuments operation is cancelled, it is possible
     * that a subset of the data has already been imported to Cloud Firestore.
     */
    importDocuments: {
      name: "ImportDocuments",
      requestType: ImportDocumentsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              59,
              58,
              1,
              42,
              34,
              54,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              100,
              97,
              116,
              97,
              98,
              97,
              115,
              101,
              115,
              47,
              42,
              125,
              58,
              105,
              109,
              112,
              111,
              114,
              116,
              68,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface FirestoreAdminServiceImplementation<CallContextExt = {}> {
  /**
   * Creates a composite index. This returns a [google.longrunning.Operation][google.longrunning.Operation]
   * which may be used to track the status of the creation. The metadata for
   * the operation will be the type [IndexOperationMetadata][google.firestore.admin.v1beta2.IndexOperationMetadata].
   */
  createIndex(request: CreateIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Lists composite indexes. */
  listIndexes(
    request: ListIndexesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListIndexesResponse>>;
  /** Gets a composite index. */
  getIndex(request: GetIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Index>>;
  /** Deletes a composite index. */
  deleteIndex(request: DeleteIndexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Gets the metadata and configuration for a Field. */
  getField(request: GetFieldRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Field>>;
  /**
   * Updates a field configuration. Currently, field updates apply only to
   * single field index configuration. However, calls to
   * [FirestoreAdmin.UpdateField][google.firestore.admin.v1beta2.FirestoreAdmin.UpdateField] should provide a field mask to avoid
   * changing any configuration that the caller isn't aware of. The field mask
   * should be specified as: `{ paths: "index_config" }`.
   *
   * This call returns a [google.longrunning.Operation][google.longrunning.Operation] which may be used to
   * track the status of the field update. The metadata for
   * the operation will be the type [FieldOperationMetadata][google.firestore.admin.v1beta2.FieldOperationMetadata].
   *
   * To configure the default field settings for the database, use
   * the special `Field` with resource name:
   * `projects/{project_id}/databases/{database_id}/collectionGroups/__default__/fields/*`.
   */
  updateField(request: UpdateFieldRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Lists the field configuration and metadata for this database.
   *
   * Currently, [FirestoreAdmin.ListFields][google.firestore.admin.v1beta2.FirestoreAdmin.ListFields] only supports listing fields
   * that have been explicitly overridden. To issue this query, call
   * [FirestoreAdmin.ListFields][google.firestore.admin.v1beta2.FirestoreAdmin.ListFields] with the filter set to
   * `indexConfig.usesAncestorConfig:false`.
   */
  listFields(
    request: ListFieldsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListFieldsResponse>>;
  /**
   * Exports a copy of all or a subset of documents from Google Cloud Firestore
   * to another storage system, such as Google Cloud Storage. Recent updates to
   * documents may not be reflected in the export. The export occurs in the
   * background and its progress can be monitored and managed via the
   * Operation resource that is created. The output of an export may only be
   * used once the associated operation is done. If an export operation is
   * cancelled before completion it may leave partial data behind in Google
   * Cloud Storage.
   */
  exportDocuments(
    request: ExportDocumentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Imports documents into Google Cloud Firestore. Existing documents with the
   * same name are overwritten. The import occurs in the background and its
   * progress can be monitored and managed via the Operation resource that is
   * created. If an ImportDocuments operation is cancelled, it is possible
   * that a subset of the data has already been imported to Cloud Firestore.
   */
  importDocuments(
    request: ImportDocumentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface FirestoreAdminClient<CallOptionsExt = {}> {
  /**
   * Creates a composite index. This returns a [google.longrunning.Operation][google.longrunning.Operation]
   * which may be used to track the status of the creation. The metadata for
   * the operation will be the type [IndexOperationMetadata][google.firestore.admin.v1beta2.IndexOperationMetadata].
   */
  createIndex(request: DeepPartial<CreateIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Lists composite indexes. */
  listIndexes(
    request: DeepPartial<ListIndexesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListIndexesResponse>;
  /** Gets a composite index. */
  getIndex(request: DeepPartial<GetIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Index>;
  /** Deletes a composite index. */
  deleteIndex(request: DeepPartial<DeleteIndexRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Gets the metadata and configuration for a Field. */
  getField(request: DeepPartial<GetFieldRequest>, options?: CallOptions & CallOptionsExt): Promise<Field>;
  /**
   * Updates a field configuration. Currently, field updates apply only to
   * single field index configuration. However, calls to
   * [FirestoreAdmin.UpdateField][google.firestore.admin.v1beta2.FirestoreAdmin.UpdateField] should provide a field mask to avoid
   * changing any configuration that the caller isn't aware of. The field mask
   * should be specified as: `{ paths: "index_config" }`.
   *
   * This call returns a [google.longrunning.Operation][google.longrunning.Operation] which may be used to
   * track the status of the field update. The metadata for
   * the operation will be the type [FieldOperationMetadata][google.firestore.admin.v1beta2.FieldOperationMetadata].
   *
   * To configure the default field settings for the database, use
   * the special `Field` with resource name:
   * `projects/{project_id}/databases/{database_id}/collectionGroups/__default__/fields/*`.
   */
  updateField(request: DeepPartial<UpdateFieldRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Lists the field configuration and metadata for this database.
   *
   * Currently, [FirestoreAdmin.ListFields][google.firestore.admin.v1beta2.FirestoreAdmin.ListFields] only supports listing fields
   * that have been explicitly overridden. To issue this query, call
   * [FirestoreAdmin.ListFields][google.firestore.admin.v1beta2.FirestoreAdmin.ListFields] with the filter set to
   * `indexConfig.usesAncestorConfig:false`.
   */
  listFields(
    request: DeepPartial<ListFieldsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListFieldsResponse>;
  /**
   * Exports a copy of all or a subset of documents from Google Cloud Firestore
   * to another storage system, such as Google Cloud Storage. Recent updates to
   * documents may not be reflected in the export. The export occurs in the
   * background and its progress can be monitored and managed via the
   * Operation resource that is created. The output of an export may only be
   * used once the associated operation is done. If an export operation is
   * cancelled before completion it may leave partial data behind in Google
   * Cloud Storage.
   */
  exportDocuments(
    request: DeepPartial<ExportDocumentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Imports documents into Google Cloud Firestore. Existing documents with the
   * same name are overwritten. The import occurs in the background and its
   * progress can be monitored and managed via the Operation resource that is
   * created. If an ImportDocuments operation is cancelled, it is possible
   * that a subset of the data has already been imported to Cloud Firestore.
   */
  importDocuments(
    request: DeepPartial<ImportDocumentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
