// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/firestore/v1beta1/write.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../protobuf/timestamp.js";
import { DocumentMask, Precondition } from "./common.js";
import { ArrayValue, Document, Value } from "./document.js";

export const protobufPackage = "google.firestore.v1beta1";

/** A write on a document. */
export interface Write {
  /** A document to write. */
  update?:
    | Document
    | undefined;
  /**
   * A document name to delete. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   */
  delete?:
    | string
    | undefined;
  /** Applies a transformation to a document. */
  transform?:
    | DocumentTransform
    | undefined;
  /**
   * The fields to update in this write.
   *
   * This field can be set only when the operation is `update`.
   * If the mask is not set for an `update` and the document exists, any
   * existing data will be overwritten.
   * If the mask is set and the document on the server has fields not covered by
   * the mask, they are left unchanged.
   * Fields referenced in the mask, but not present in the input document, are
   * deleted from the document on the server.
   * The field paths in this mask must not contain a reserved field name.
   */
  updateMask:
    | DocumentMask
    | undefined;
  /**
   * The transforms to perform after update.
   *
   * This field can be set only when the operation is `update`. If present, this
   * write is equivalent to performing `update` and `transform` to the same
   * document atomically and in order.
   */
  updateTransforms: DocumentTransform_FieldTransform[];
  /**
   * An optional precondition on the document.
   *
   * The write will fail if this is set and not met by the target document.
   */
  currentDocument: Precondition | undefined;
}

/** A transformation of a document. */
export interface DocumentTransform {
  /** The name of the document to transform. */
  document: string;
  /**
   * The list of transformations to apply to the fields of the document, in
   * order.
   * This must not be empty.
   */
  fieldTransforms: DocumentTransform_FieldTransform[];
}

/** A transformation of a field of the document. */
export interface DocumentTransform_FieldTransform {
  /**
   * The path of the field. See [Document.fields][google.firestore.v1beta1.Document.fields] for the field path syntax
   * reference.
   */
  fieldPath: string;
  /** Sets the field to the given server value. */
  setToServerValue?:
    | DocumentTransform_FieldTransform_ServerValue
    | undefined;
  /**
   * Adds the given value to the field's current value.
   *
   * This must be an integer or a double value.
   * If the field is not an integer or double, or if the field does not yet
   * exist, the transformation will set the field to the given value.
   * If either of the given value or the current field value are doubles,
   * both values will be interpreted as doubles. Double arithmetic and
   * representation of double values follow IEEE 754 semantics.
   * If there is positive/negative integer overflow, the field is resolved
   * to the largest magnitude positive/negative integer.
   */
  increment?:
    | Value
    | undefined;
  /**
   * Sets the field to the maximum of its current value and the given value.
   *
   * This must be an integer or a double value.
   * If the field is not an integer or double, or if the field does not yet
   * exist, the transformation will set the field to the given value.
   * If a maximum operation is applied where the field and the input value
   * are of mixed types (that is - one is an integer and one is a double)
   * the field takes on the type of the larger operand. If the operands are
   * equivalent (e.g. 3 and 3.0), the field does not change.
   * 0, 0.0, and -0.0 are all zero. The maximum of a zero stored value and
   * zero input value is always the stored value.
   * The maximum of any numeric value x and NaN is NaN.
   */
  maximum?:
    | Value
    | undefined;
  /**
   * Sets the field to the minimum of its current value and the given value.
   *
   * This must be an integer or a double value.
   * If the field is not an integer or double, or if the field does not yet
   * exist, the transformation will set the field to the input value.
   * If a minimum operation is applied where the field and the input value
   * are of mixed types (that is - one is an integer and one is a double)
   * the field takes on the type of the smaller operand. If the operands are
   * equivalent (e.g. 3 and 3.0), the field does not change.
   * 0, 0.0, and -0.0 are all zero. The minimum of a zero stored value and
   * zero input value is always the stored value.
   * The minimum of any numeric value x and NaN is NaN.
   */
  minimum?:
    | Value
    | undefined;
  /**
   * Append the given elements in order if they are not already present in
   * the current field value.
   * If the field is not an array, or if the field does not yet exist, it is
   * first set to the empty array.
   *
   * Equivalent numbers of different types (e.g. 3L and 3.0) are
   * considered equal when checking if a value is missing.
   * NaN is equal to NaN, and Null is equal to Null.
   * If the input contains multiple equivalent values, only the first will
   * be considered.
   *
   * The corresponding transform_result will be the null value.
   */
  appendMissingElements?:
    | ArrayValue
    | undefined;
  /**
   * Remove all of the given elements from the array in the field.
   * If the field is not an array, or if the field does not yet exist, it is
   * set to the empty array.
   *
   * Equivalent numbers of the different types (e.g. 3L and 3.0) are
   * considered equal when deciding whether an element should be removed.
   * NaN is equal to NaN, and Null is equal to Null.
   * This will remove all equivalent values if there are duplicates.
   *
   * The corresponding transform_result will be the null value.
   */
  removeAllFromArray?: ArrayValue | undefined;
}

/** A value that is calculated by the server. */
export enum DocumentTransform_FieldTransform_ServerValue {
  /** SERVER_VALUE_UNSPECIFIED - Unspecified. This value must not be used. */
  SERVER_VALUE_UNSPECIFIED = 0,
  /**
   * REQUEST_TIME - The time at which the server processed the request, with millisecond
   * precision. If used on multiple fields (same or different documents) in
   * a transaction, all the fields will get the same server timestamp.
   */
  REQUEST_TIME = 1,
  UNRECOGNIZED = -1,
}

export function documentTransform_FieldTransform_ServerValueFromJSON(
  object: any,
): DocumentTransform_FieldTransform_ServerValue {
  switch (object) {
    case 0:
    case "SERVER_VALUE_UNSPECIFIED":
      return DocumentTransform_FieldTransform_ServerValue.SERVER_VALUE_UNSPECIFIED;
    case 1:
    case "REQUEST_TIME":
      return DocumentTransform_FieldTransform_ServerValue.REQUEST_TIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DocumentTransform_FieldTransform_ServerValue.UNRECOGNIZED;
  }
}

export function documentTransform_FieldTransform_ServerValueToJSON(
  object: DocumentTransform_FieldTransform_ServerValue,
): string {
  switch (object) {
    case DocumentTransform_FieldTransform_ServerValue.SERVER_VALUE_UNSPECIFIED:
      return "SERVER_VALUE_UNSPECIFIED";
    case DocumentTransform_FieldTransform_ServerValue.REQUEST_TIME:
      return "REQUEST_TIME";
    case DocumentTransform_FieldTransform_ServerValue.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The result of applying a write. */
export interface WriteResult {
  /**
   * The last update time of the document after applying the write. Not set
   * after a `delete`.
   *
   * If the write did not actually change the document, this will be the
   * previous update_time.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * The results of applying each [DocumentTransform.FieldTransform][google.firestore.v1beta1.DocumentTransform.FieldTransform], in the
   * same order.
   */
  transformResults: Value[];
}

/**
 * A [Document][google.firestore.v1beta1.Document] has changed.
 *
 * May be the result of multiple [writes][google.firestore.v1beta1.Write], including deletes, that
 * ultimately resulted in a new value for the [Document][google.firestore.v1beta1.Document].
 *
 * Multiple [DocumentChange][google.firestore.v1beta1.DocumentChange] messages may be returned for the same logical
 * change, if multiple targets are affected.
 */
export interface DocumentChange {
  /**
   * The new state of the [Document][google.firestore.v1beta1.Document].
   *
   * If `mask` is set, contains only fields that were updated or added.
   */
  document:
    | Document
    | undefined;
  /** A set of target IDs of targets that match this document. */
  targetIds: number[];
  /** A set of target IDs for targets that no longer match this document. */
  removedTargetIds: number[];
}

/**
 * A [Document][google.firestore.v1beta1.Document] has been deleted.
 *
 * May be the result of multiple [writes][google.firestore.v1beta1.Write], including updates, the
 * last of which deleted the [Document][google.firestore.v1beta1.Document].
 *
 * Multiple [DocumentDelete][google.firestore.v1beta1.DocumentDelete] messages may be returned for the same logical
 * delete, if multiple targets are affected.
 */
export interface DocumentDelete {
  /** The resource name of the [Document][google.firestore.v1beta1.Document] that was deleted. */
  document: string;
  /** A set of target IDs for targets that previously matched this entity. */
  removedTargetIds: number[];
  /**
   * The read timestamp at which the delete was observed.
   *
   * Greater or equal to the `commit_time` of the delete.
   */
  readTime: Date | undefined;
}

/**
 * A [Document][google.firestore.v1beta1.Document] has been removed from the view of the targets.
 *
 * Sent if the document is no longer relevant to a target and is out of view.
 * Can be sent instead of a DocumentDelete or a DocumentChange if the server
 * can not send the new value of the document.
 *
 * Multiple [DocumentRemove][google.firestore.v1beta1.DocumentRemove] messages may be returned for the same logical
 * write or delete, if multiple targets are affected.
 */
export interface DocumentRemove {
  /** The resource name of the [Document][google.firestore.v1beta1.Document] that has gone out of view. */
  document: string;
  /** A set of target IDs for targets that previously matched this document. */
  removedTargetIds: number[];
  /**
   * The read timestamp at which the remove was observed.
   *
   * Greater or equal to the `commit_time` of the change/delete/remove.
   */
  readTime: Date | undefined;
}

/** A digest of all the documents that match a given target. */
export interface ExistenceFilter {
  /** The target ID to which this filter applies. */
  targetId: number;
  /**
   * The total count of documents that match [target_id][google.firestore.v1beta1.ExistenceFilter.target_id].
   *
   * If different from the count of documents in the client that match, the
   * client must manually determine which documents no longer match the target.
   */
  count: number;
}

function createBaseWrite(): Write {
  return {
    update: undefined,
    delete: undefined,
    transform: undefined,
    updateMask: undefined,
    updateTransforms: [],
    currentDocument: undefined,
  };
}

export const Write: MessageFns<Write> = {
  encode(message: Write, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.update !== undefined) {
      Document.encode(message.update, writer.uint32(10).fork()).join();
    }
    if (message.delete !== undefined) {
      writer.uint32(18).string(message.delete);
    }
    if (message.transform !== undefined) {
      DocumentTransform.encode(message.transform, writer.uint32(50).fork()).join();
    }
    if (message.updateMask !== undefined) {
      DocumentMask.encode(message.updateMask, writer.uint32(26).fork()).join();
    }
    for (const v of message.updateTransforms) {
      DocumentTransform_FieldTransform.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.currentDocument !== undefined) {
      Precondition.encode(message.currentDocument, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Write {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWrite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.update = Document.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.delete = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.transform = DocumentTransform.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = DocumentMask.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTransforms.push(DocumentTransform_FieldTransform.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currentDocument = Precondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Write {
    return {
      update: isSet(object.update) ? Document.fromJSON(object.update) : undefined,
      delete: isSet(object.delete) ? globalThis.String(object.delete) : undefined,
      transform: isSet(object.transform) ? DocumentTransform.fromJSON(object.transform) : undefined,
      updateMask: isSet(object.updateMask) ? DocumentMask.fromJSON(object.updateMask) : undefined,
      updateTransforms: globalThis.Array.isArray(object?.updateTransforms)
        ? object.updateTransforms.map((e: any) => DocumentTransform_FieldTransform.fromJSON(e))
        : [],
      currentDocument: isSet(object.currentDocument) ? Precondition.fromJSON(object.currentDocument) : undefined,
    };
  },

  toJSON(message: Write): unknown {
    const obj: any = {};
    if (message.update !== undefined) {
      obj.update = Document.toJSON(message.update);
    }
    if (message.delete !== undefined) {
      obj.delete = message.delete;
    }
    if (message.transform !== undefined) {
      obj.transform = DocumentTransform.toJSON(message.transform);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = DocumentMask.toJSON(message.updateMask);
    }
    if (message.updateTransforms?.length) {
      obj.updateTransforms = message.updateTransforms.map((e) => DocumentTransform_FieldTransform.toJSON(e));
    }
    if (message.currentDocument !== undefined) {
      obj.currentDocument = Precondition.toJSON(message.currentDocument);
    }
    return obj;
  },

  create(base?: DeepPartial<Write>): Write {
    return Write.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Write>): Write {
    const message = createBaseWrite();
    message.update = (object.update !== undefined && object.update !== null)
      ? Document.fromPartial(object.update)
      : undefined;
    message.delete = object.delete ?? undefined;
    message.transform = (object.transform !== undefined && object.transform !== null)
      ? DocumentTransform.fromPartial(object.transform)
      : undefined;
    message.updateMask = (object.updateMask !== undefined && object.updateMask !== null)
      ? DocumentMask.fromPartial(object.updateMask)
      : undefined;
    message.updateTransforms = object.updateTransforms?.map((e) => DocumentTransform_FieldTransform.fromPartial(e)) ||
      [];
    message.currentDocument = (object.currentDocument !== undefined && object.currentDocument !== null)
      ? Precondition.fromPartial(object.currentDocument)
      : undefined;
    return message;
  },
};

function createBaseDocumentTransform(): DocumentTransform {
  return { document: "", fieldTransforms: [] };
}

export const DocumentTransform: MessageFns<DocumentTransform> = {
  encode(message: DocumentTransform, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.document !== "") {
      writer.uint32(10).string(message.document);
    }
    for (const v of message.fieldTransforms) {
      DocumentTransform_FieldTransform.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentTransform {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentTransform();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.document = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldTransforms.push(DocumentTransform_FieldTransform.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentTransform {
    return {
      document: isSet(object.document) ? globalThis.String(object.document) : "",
      fieldTransforms: globalThis.Array.isArray(object?.fieldTransforms)
        ? object.fieldTransforms.map((e: any) => DocumentTransform_FieldTransform.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DocumentTransform): unknown {
    const obj: any = {};
    if (message.document !== "") {
      obj.document = message.document;
    }
    if (message.fieldTransforms?.length) {
      obj.fieldTransforms = message.fieldTransforms.map((e) => DocumentTransform_FieldTransform.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentTransform>): DocumentTransform {
    return DocumentTransform.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentTransform>): DocumentTransform {
    const message = createBaseDocumentTransform();
    message.document = object.document ?? "";
    message.fieldTransforms = object.fieldTransforms?.map((e) => DocumentTransform_FieldTransform.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocumentTransform_FieldTransform(): DocumentTransform_FieldTransform {
  return {
    fieldPath: "",
    setToServerValue: undefined,
    increment: undefined,
    maximum: undefined,
    minimum: undefined,
    appendMissingElements: undefined,
    removeAllFromArray: undefined,
  };
}

export const DocumentTransform_FieldTransform: MessageFns<DocumentTransform_FieldTransform> = {
  encode(message: DocumentTransform_FieldTransform, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldPath !== "") {
      writer.uint32(10).string(message.fieldPath);
    }
    if (message.setToServerValue !== undefined) {
      writer.uint32(16).int32(message.setToServerValue);
    }
    if (message.increment !== undefined) {
      Value.encode(message.increment, writer.uint32(26).fork()).join();
    }
    if (message.maximum !== undefined) {
      Value.encode(message.maximum, writer.uint32(34).fork()).join();
    }
    if (message.minimum !== undefined) {
      Value.encode(message.minimum, writer.uint32(42).fork()).join();
    }
    if (message.appendMissingElements !== undefined) {
      ArrayValue.encode(message.appendMissingElements, writer.uint32(50).fork()).join();
    }
    if (message.removeAllFromArray !== undefined) {
      ArrayValue.encode(message.removeAllFromArray, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentTransform_FieldTransform {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentTransform_FieldTransform();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldPath = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.setToServerValue = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.increment = Value.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maximum = Value.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.minimum = Value.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.appendMissingElements = ArrayValue.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.removeAllFromArray = ArrayValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentTransform_FieldTransform {
    return {
      fieldPath: isSet(object.fieldPath) ? globalThis.String(object.fieldPath) : "",
      setToServerValue: isSet(object.setToServerValue)
        ? documentTransform_FieldTransform_ServerValueFromJSON(object.setToServerValue)
        : undefined,
      increment: isSet(object.increment) ? Value.fromJSON(object.increment) : undefined,
      maximum: isSet(object.maximum) ? Value.fromJSON(object.maximum) : undefined,
      minimum: isSet(object.minimum) ? Value.fromJSON(object.minimum) : undefined,
      appendMissingElements: isSet(object.appendMissingElements)
        ? ArrayValue.fromJSON(object.appendMissingElements)
        : undefined,
      removeAllFromArray: isSet(object.removeAllFromArray) ? ArrayValue.fromJSON(object.removeAllFromArray) : undefined,
    };
  },

  toJSON(message: DocumentTransform_FieldTransform): unknown {
    const obj: any = {};
    if (message.fieldPath !== "") {
      obj.fieldPath = message.fieldPath;
    }
    if (message.setToServerValue !== undefined) {
      obj.setToServerValue = documentTransform_FieldTransform_ServerValueToJSON(message.setToServerValue);
    }
    if (message.increment !== undefined) {
      obj.increment = Value.toJSON(message.increment);
    }
    if (message.maximum !== undefined) {
      obj.maximum = Value.toJSON(message.maximum);
    }
    if (message.minimum !== undefined) {
      obj.minimum = Value.toJSON(message.minimum);
    }
    if (message.appendMissingElements !== undefined) {
      obj.appendMissingElements = ArrayValue.toJSON(message.appendMissingElements);
    }
    if (message.removeAllFromArray !== undefined) {
      obj.removeAllFromArray = ArrayValue.toJSON(message.removeAllFromArray);
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentTransform_FieldTransform>): DocumentTransform_FieldTransform {
    return DocumentTransform_FieldTransform.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentTransform_FieldTransform>): DocumentTransform_FieldTransform {
    const message = createBaseDocumentTransform_FieldTransform();
    message.fieldPath = object.fieldPath ?? "";
    message.setToServerValue = object.setToServerValue ?? undefined;
    message.increment = (object.increment !== undefined && object.increment !== null)
      ? Value.fromPartial(object.increment)
      : undefined;
    message.maximum = (object.maximum !== undefined && object.maximum !== null)
      ? Value.fromPartial(object.maximum)
      : undefined;
    message.minimum = (object.minimum !== undefined && object.minimum !== null)
      ? Value.fromPartial(object.minimum)
      : undefined;
    message.appendMissingElements =
      (object.appendMissingElements !== undefined && object.appendMissingElements !== null)
        ? ArrayValue.fromPartial(object.appendMissingElements)
        : undefined;
    message.removeAllFromArray = (object.removeAllFromArray !== undefined && object.removeAllFromArray !== null)
      ? ArrayValue.fromPartial(object.removeAllFromArray)
      : undefined;
    return message;
  },
};

function createBaseWriteResult(): WriteResult {
  return { updateTime: undefined, transformResults: [] };
}

export const WriteResult: MessageFns<WriteResult> = {
  encode(message: WriteResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(10).fork()).join();
    }
    for (const v of message.transformResults) {
      Value.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transformResults.push(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteResult {
    return {
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      transformResults: globalThis.Array.isArray(object?.transformResults)
        ? object.transformResults.map((e: any) => Value.fromJSON(e))
        : [],
    };
  },

  toJSON(message: WriteResult): unknown {
    const obj: any = {};
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.transformResults?.length) {
      obj.transformResults = message.transformResults.map((e) => Value.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<WriteResult>): WriteResult {
    return WriteResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WriteResult>): WriteResult {
    const message = createBaseWriteResult();
    message.updateTime = object.updateTime ?? undefined;
    message.transformResults = object.transformResults?.map((e) => Value.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocumentChange(): DocumentChange {
  return { document: undefined, targetIds: [], removedTargetIds: [] };
}

export const DocumentChange: MessageFns<DocumentChange> = {
  encode(message: DocumentChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.document !== undefined) {
      Document.encode(message.document, writer.uint32(10).fork()).join();
    }
    writer.uint32(42).fork();
    for (const v of message.targetIds) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(50).fork();
    for (const v of message.removedTargetIds) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.document = Document.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag === 40) {
            message.targetIds.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.targetIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 6:
          if (tag === 48) {
            message.removedTargetIds.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.removedTargetIds.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentChange {
    return {
      document: isSet(object.document) ? Document.fromJSON(object.document) : undefined,
      targetIds: globalThis.Array.isArray(object?.targetIds)
        ? object.targetIds.map((e: any) => globalThis.Number(e))
        : [],
      removedTargetIds: globalThis.Array.isArray(object?.removedTargetIds)
        ? object.removedTargetIds.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: DocumentChange): unknown {
    const obj: any = {};
    if (message.document !== undefined) {
      obj.document = Document.toJSON(message.document);
    }
    if (message.targetIds?.length) {
      obj.targetIds = message.targetIds.map((e) => Math.round(e));
    }
    if (message.removedTargetIds?.length) {
      obj.removedTargetIds = message.removedTargetIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentChange>): DocumentChange {
    return DocumentChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentChange>): DocumentChange {
    const message = createBaseDocumentChange();
    message.document = (object.document !== undefined && object.document !== null)
      ? Document.fromPartial(object.document)
      : undefined;
    message.targetIds = object.targetIds?.map((e) => e) || [];
    message.removedTargetIds = object.removedTargetIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseDocumentDelete(): DocumentDelete {
  return { document: "", removedTargetIds: [], readTime: undefined };
}

export const DocumentDelete: MessageFns<DocumentDelete> = {
  encode(message: DocumentDelete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.document !== "") {
      writer.uint32(10).string(message.document);
    }
    writer.uint32(50).fork();
    for (const v of message.removedTargetIds) {
      writer.int32(v);
    }
    writer.join();
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentDelete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentDelete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.document = reader.string();
          continue;
        case 6:
          if (tag === 48) {
            message.removedTargetIds.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.removedTargetIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentDelete {
    return {
      document: isSet(object.document) ? globalThis.String(object.document) : "",
      removedTargetIds: globalThis.Array.isArray(object?.removedTargetIds)
        ? object.removedTargetIds.map((e: any) => globalThis.Number(e))
        : [],
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
    };
  },

  toJSON(message: DocumentDelete): unknown {
    const obj: any = {};
    if (message.document !== "") {
      obj.document = message.document;
    }
    if (message.removedTargetIds?.length) {
      obj.removedTargetIds = message.removedTargetIds.map((e) => Math.round(e));
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentDelete>): DocumentDelete {
    return DocumentDelete.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentDelete>): DocumentDelete {
    const message = createBaseDocumentDelete();
    message.document = object.document ?? "";
    message.removedTargetIds = object.removedTargetIds?.map((e) => e) || [];
    message.readTime = object.readTime ?? undefined;
    return message;
  },
};

function createBaseDocumentRemove(): DocumentRemove {
  return { document: "", removedTargetIds: [], readTime: undefined };
}

export const DocumentRemove: MessageFns<DocumentRemove> = {
  encode(message: DocumentRemove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.document !== "") {
      writer.uint32(10).string(message.document);
    }
    writer.uint32(18).fork();
    for (const v of message.removedTargetIds) {
      writer.int32(v);
    }
    writer.join();
    if (message.readTime !== undefined) {
      Timestamp.encode(toTimestamp(message.readTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DocumentRemove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentRemove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.document = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.removedTargetIds.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.removedTargetIds.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.readTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DocumentRemove {
    return {
      document: isSet(object.document) ? globalThis.String(object.document) : "",
      removedTargetIds: globalThis.Array.isArray(object?.removedTargetIds)
        ? object.removedTargetIds.map((e: any) => globalThis.Number(e))
        : [],
      readTime: isSet(object.readTime) ? fromJsonTimestamp(object.readTime) : undefined,
    };
  },

  toJSON(message: DocumentRemove): unknown {
    const obj: any = {};
    if (message.document !== "") {
      obj.document = message.document;
    }
    if (message.removedTargetIds?.length) {
      obj.removedTargetIds = message.removedTargetIds.map((e) => Math.round(e));
    }
    if (message.readTime !== undefined) {
      obj.readTime = message.readTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<DocumentRemove>): DocumentRemove {
    return DocumentRemove.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DocumentRemove>): DocumentRemove {
    const message = createBaseDocumentRemove();
    message.document = object.document ?? "";
    message.removedTargetIds = object.removedTargetIds?.map((e) => e) || [];
    message.readTime = object.readTime ?? undefined;
    return message;
  },
};

function createBaseExistenceFilter(): ExistenceFilter {
  return { targetId: 0, count: 0 };
}

export const ExistenceFilter: MessageFns<ExistenceFilter> = {
  encode(message: ExistenceFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetId !== 0) {
      writer.uint32(8).int32(message.targetId);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExistenceFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExistenceFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetId = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExistenceFilter {
    return {
      targetId: isSet(object.targetId) ? globalThis.Number(object.targetId) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: ExistenceFilter): unknown {
    const obj: any = {};
    if (message.targetId !== 0) {
      obj.targetId = Math.round(message.targetId);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<ExistenceFilter>): ExistenceFilter {
    return ExistenceFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExistenceFilter>): ExistenceFilter {
    const message = createBaseExistenceFilter();
    message.targetId = object.targetId ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
