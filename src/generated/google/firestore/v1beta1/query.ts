// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/firestore/v1beta1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Int32Value } from "../../protobuf/wrappers.js";
import { Value } from "./document.js";

export const protobufPackage = "google.firestore.v1beta1";

/** A Firestore query. */
export interface StructuredQuery {
  /** The projection to return. */
  select:
    | StructuredQuery_Projection
    | undefined;
  /** The collections to query. */
  from: StructuredQuery_CollectionSelector[];
  /** The filter to apply. */
  where:
    | StructuredQuery_Filter
    | undefined;
  /**
   * The order to apply to the query results.
   *
   * Firestore guarantees a stable ordering through the following rules:
   *
   *  * Any field required to appear in `order_by`, that is not already
   *    specified in `order_by`, is appended to the order in field name order
   *    by default.
   *  * If an order on `__name__` is not specified, it is appended by default.
   *
   * Fields are appended with the same sort direction as the last order
   * specified, or 'ASCENDING' if no order was specified. For example:
   *
   *  * `SELECT * FROM Foo ORDER BY A` becomes
   *    `SELECT * FROM Foo ORDER BY A, __name__`
   *  * `SELECT * FROM Foo ORDER BY A DESC` becomes
   *    `SELECT * FROM Foo ORDER BY A DESC, __name__ DESC`
   *  * `SELECT * FROM Foo WHERE A > 1` becomes
   *    `SELECT * FROM Foo WHERE A > 1 ORDER BY A, __name__`
   */
  orderBy: StructuredQuery_Order[];
  /** A starting point for the query results. */
  startAt:
    | Cursor
    | undefined;
  /** A end point for the query results. */
  endAt:
    | Cursor
    | undefined;
  /**
   * The number of results to skip.
   *
   * Applies before limit, but after all other constraints. Must be >= 0 if
   * specified.
   */
  offset: number;
  /**
   * The maximum number of results to return.
   *
   * Applies after all other constraints.
   * Must be >= 0 if specified.
   */
  limit: number | undefined;
}

/** A sort direction. */
export enum StructuredQuery_Direction {
  /** DIRECTION_UNSPECIFIED - Unspecified. */
  DIRECTION_UNSPECIFIED = 0,
  /** ASCENDING - Ascending. */
  ASCENDING = 1,
  /** DESCENDING - Descending. */
  DESCENDING = 2,
  UNRECOGNIZED = -1,
}

export function structuredQuery_DirectionFromJSON(object: any): StructuredQuery_Direction {
  switch (object) {
    case 0:
    case "DIRECTION_UNSPECIFIED":
      return StructuredQuery_Direction.DIRECTION_UNSPECIFIED;
    case 1:
    case "ASCENDING":
      return StructuredQuery_Direction.ASCENDING;
    case 2:
    case "DESCENDING":
      return StructuredQuery_Direction.DESCENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StructuredQuery_Direction.UNRECOGNIZED;
  }
}

export function structuredQuery_DirectionToJSON(object: StructuredQuery_Direction): string {
  switch (object) {
    case StructuredQuery_Direction.DIRECTION_UNSPECIFIED:
      return "DIRECTION_UNSPECIFIED";
    case StructuredQuery_Direction.ASCENDING:
      return "ASCENDING";
    case StructuredQuery_Direction.DESCENDING:
      return "DESCENDING";
    case StructuredQuery_Direction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A selection of a collection, such as `messages as m1`. */
export interface StructuredQuery_CollectionSelector {
  /**
   * The collection ID.
   * When set, selects only collections with this ID.
   */
  collectionId: string;
  /**
   * When false, selects only collections that are immediate children of
   * the `parent` specified in the containing `RunQueryRequest`.
   * When true, selects all descendant collections.
   */
  allDescendants: boolean;
}

/** A filter. */
export interface StructuredQuery_Filter {
  /** A composite filter. */
  compositeFilter?:
    | StructuredQuery_CompositeFilter
    | undefined;
  /** A filter on a document field. */
  fieldFilter?:
    | StructuredQuery_FieldFilter
    | undefined;
  /** A filter that takes exactly one argument. */
  unaryFilter?: StructuredQuery_UnaryFilter | undefined;
}

/** A filter that merges multiple other filters using the given operator. */
export interface StructuredQuery_CompositeFilter {
  /** The operator for combining multiple filters. */
  op: StructuredQuery_CompositeFilter_Operator;
  /**
   * The list of filters to combine.
   * Must contain at least one filter.
   */
  filters: StructuredQuery_Filter[];
}

/** A composite filter operator. */
export enum StructuredQuery_CompositeFilter_Operator {
  /** OPERATOR_UNSPECIFIED - Unspecified. This value must not be used. */
  OPERATOR_UNSPECIFIED = 0,
  /** AND - The results are required to satisfy each of the combined filters. */
  AND = 1,
  UNRECOGNIZED = -1,
}

export function structuredQuery_CompositeFilter_OperatorFromJSON(
  object: any,
): StructuredQuery_CompositeFilter_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return StructuredQuery_CompositeFilter_Operator.OPERATOR_UNSPECIFIED;
    case 1:
    case "AND":
      return StructuredQuery_CompositeFilter_Operator.AND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StructuredQuery_CompositeFilter_Operator.UNRECOGNIZED;
  }
}

export function structuredQuery_CompositeFilter_OperatorToJSON(
  object: StructuredQuery_CompositeFilter_Operator,
): string {
  switch (object) {
    case StructuredQuery_CompositeFilter_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case StructuredQuery_CompositeFilter_Operator.AND:
      return "AND";
    case StructuredQuery_CompositeFilter_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A filter on a specific field. */
export interface StructuredQuery_FieldFilter {
  /** The field to filter by. */
  field:
    | StructuredQuery_FieldReference
    | undefined;
  /** The operator to filter by. */
  op: StructuredQuery_FieldFilter_Operator;
  /** The value to compare to. */
  value: Value | undefined;
}

/** A field filter operator. */
export enum StructuredQuery_FieldFilter_Operator {
  /** OPERATOR_UNSPECIFIED - Unspecified. This value must not be used. */
  OPERATOR_UNSPECIFIED = 0,
  /**
   * LESS_THAN - The given `field` is less than the given `value`.
   *
   * Requires:
   *
   * * That `field` come first in `order_by`.
   */
  LESS_THAN = 1,
  /**
   * LESS_THAN_OR_EQUAL - The given `field` is less than or equal to the given `value`.
   *
   * Requires:
   *
   * * That `field` come first in `order_by`.
   */
  LESS_THAN_OR_EQUAL = 2,
  /**
   * GREATER_THAN - The given `field` is greater than the given `value`.
   *
   * Requires:
   *
   * * That `field` come first in `order_by`.
   */
  GREATER_THAN = 3,
  /**
   * GREATER_THAN_OR_EQUAL - The given `field` is greater than or equal to the given `value`.
   *
   * Requires:
   *
   * * That `field` come first in `order_by`.
   */
  GREATER_THAN_OR_EQUAL = 4,
  /** EQUAL - The given `field` is equal to the given `value`. */
  EQUAL = 5,
  /**
   * NOT_EQUAL - The given `field` is not equal to the given `value`.
   *
   * Requires:
   *
   * * No other `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
   * * That `field` comes first in the `order_by`.
   */
  NOT_EQUAL = 6,
  /** ARRAY_CONTAINS - The given `field` is an array that contains the given `value`. */
  ARRAY_CONTAINS = 7,
  /**
   * IN - The given `field` is equal to at least one value in the given array.
   *
   * Requires:
   *
   * * That `value` is a non-empty `ArrayValue` with at most 10 values.
   * * No other `IN` or `ARRAY_CONTAINS_ANY` or `NOT_IN`.
   */
  IN = 8,
  /**
   * ARRAY_CONTAINS_ANY - The given `field` is an array that contains any of the values in the
   * given array.
   *
   * Requires:
   *
   * * That `value` is a non-empty `ArrayValue` with at most 10 values.
   * * No other `IN` or `ARRAY_CONTAINS_ANY` or `NOT_IN`.
   */
  ARRAY_CONTAINS_ANY = 9,
  /**
   * NOT_IN - The value of the `field` is not in the given array.
   *
   * Requires:
   *
   * * That `value` is a non-empty `ArrayValue` with at most 10 values.
   * * No other `IN`, `ARRAY_CONTAINS_ANY`, `NOT_IN`, `NOT_EQUAL`,
   *   `IS_NOT_NULL`, or `IS_NOT_NAN`.
   * * That `field` comes first in the `order_by`.
   */
  NOT_IN = 10,
  UNRECOGNIZED = -1,
}

export function structuredQuery_FieldFilter_OperatorFromJSON(object: any): StructuredQuery_FieldFilter_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return StructuredQuery_FieldFilter_Operator.OPERATOR_UNSPECIFIED;
    case 1:
    case "LESS_THAN":
      return StructuredQuery_FieldFilter_Operator.LESS_THAN;
    case 2:
    case "LESS_THAN_OR_EQUAL":
      return StructuredQuery_FieldFilter_Operator.LESS_THAN_OR_EQUAL;
    case 3:
    case "GREATER_THAN":
      return StructuredQuery_FieldFilter_Operator.GREATER_THAN;
    case 4:
    case "GREATER_THAN_OR_EQUAL":
      return StructuredQuery_FieldFilter_Operator.GREATER_THAN_OR_EQUAL;
    case 5:
    case "EQUAL":
      return StructuredQuery_FieldFilter_Operator.EQUAL;
    case 6:
    case "NOT_EQUAL":
      return StructuredQuery_FieldFilter_Operator.NOT_EQUAL;
    case 7:
    case "ARRAY_CONTAINS":
      return StructuredQuery_FieldFilter_Operator.ARRAY_CONTAINS;
    case 8:
    case "IN":
      return StructuredQuery_FieldFilter_Operator.IN;
    case 9:
    case "ARRAY_CONTAINS_ANY":
      return StructuredQuery_FieldFilter_Operator.ARRAY_CONTAINS_ANY;
    case 10:
    case "NOT_IN":
      return StructuredQuery_FieldFilter_Operator.NOT_IN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StructuredQuery_FieldFilter_Operator.UNRECOGNIZED;
  }
}

export function structuredQuery_FieldFilter_OperatorToJSON(object: StructuredQuery_FieldFilter_Operator): string {
  switch (object) {
    case StructuredQuery_FieldFilter_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case StructuredQuery_FieldFilter_Operator.LESS_THAN:
      return "LESS_THAN";
    case StructuredQuery_FieldFilter_Operator.LESS_THAN_OR_EQUAL:
      return "LESS_THAN_OR_EQUAL";
    case StructuredQuery_FieldFilter_Operator.GREATER_THAN:
      return "GREATER_THAN";
    case StructuredQuery_FieldFilter_Operator.GREATER_THAN_OR_EQUAL:
      return "GREATER_THAN_OR_EQUAL";
    case StructuredQuery_FieldFilter_Operator.EQUAL:
      return "EQUAL";
    case StructuredQuery_FieldFilter_Operator.NOT_EQUAL:
      return "NOT_EQUAL";
    case StructuredQuery_FieldFilter_Operator.ARRAY_CONTAINS:
      return "ARRAY_CONTAINS";
    case StructuredQuery_FieldFilter_Operator.IN:
      return "IN";
    case StructuredQuery_FieldFilter_Operator.ARRAY_CONTAINS_ANY:
      return "ARRAY_CONTAINS_ANY";
    case StructuredQuery_FieldFilter_Operator.NOT_IN:
      return "NOT_IN";
    case StructuredQuery_FieldFilter_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A filter with a single operand. */
export interface StructuredQuery_UnaryFilter {
  /** The unary operator to apply. */
  op: StructuredQuery_UnaryFilter_Operator;
  /** The field to which to apply the operator. */
  field?: StructuredQuery_FieldReference | undefined;
}

/** A unary operator. */
export enum StructuredQuery_UnaryFilter_Operator {
  /** OPERATOR_UNSPECIFIED - Unspecified. This value must not be used. */
  OPERATOR_UNSPECIFIED = 0,
  /** IS_NAN - The given `field` is equal to `NaN`. */
  IS_NAN = 2,
  /** IS_NULL - The given `field` is equal to `NULL`. */
  IS_NULL = 3,
  /**
   * IS_NOT_NAN - The given `field` is not equal to `NaN`.
   *
   * Requires:
   *
   * * No other `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
   * * That `field` comes first in the `order_by`.
   */
  IS_NOT_NAN = 4,
  /**
   * IS_NOT_NULL - The given `field` is not equal to `NULL`.
   *
   * Requires:
   *
   * * A single `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
   * * That `field` comes first in the `order_by`.
   */
  IS_NOT_NULL = 5,
  UNRECOGNIZED = -1,
}

export function structuredQuery_UnaryFilter_OperatorFromJSON(object: any): StructuredQuery_UnaryFilter_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return StructuredQuery_UnaryFilter_Operator.OPERATOR_UNSPECIFIED;
    case 2:
    case "IS_NAN":
      return StructuredQuery_UnaryFilter_Operator.IS_NAN;
    case 3:
    case "IS_NULL":
      return StructuredQuery_UnaryFilter_Operator.IS_NULL;
    case 4:
    case "IS_NOT_NAN":
      return StructuredQuery_UnaryFilter_Operator.IS_NOT_NAN;
    case 5:
    case "IS_NOT_NULL":
      return StructuredQuery_UnaryFilter_Operator.IS_NOT_NULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StructuredQuery_UnaryFilter_Operator.UNRECOGNIZED;
  }
}

export function structuredQuery_UnaryFilter_OperatorToJSON(object: StructuredQuery_UnaryFilter_Operator): string {
  switch (object) {
    case StructuredQuery_UnaryFilter_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case StructuredQuery_UnaryFilter_Operator.IS_NAN:
      return "IS_NAN";
    case StructuredQuery_UnaryFilter_Operator.IS_NULL:
      return "IS_NULL";
    case StructuredQuery_UnaryFilter_Operator.IS_NOT_NAN:
      return "IS_NOT_NAN";
    case StructuredQuery_UnaryFilter_Operator.IS_NOT_NULL:
      return "IS_NOT_NULL";
    case StructuredQuery_UnaryFilter_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A reference to a field, such as `max(messages.time) as max_time`. */
export interface StructuredQuery_FieldReference {
  fieldPath: string;
}

/** An order on a field. */
export interface StructuredQuery_Order {
  /** The field to order by. */
  field:
    | StructuredQuery_FieldReference
    | undefined;
  /** The direction to order by. Defaults to `ASCENDING`. */
  direction: StructuredQuery_Direction;
}

/** The projection of document's fields to return. */
export interface StructuredQuery_Projection {
  /**
   * The fields to return.
   *
   * If empty, all fields are returned. To only return the name
   * of the document, use `['__name__']`.
   */
  fields: StructuredQuery_FieldReference[];
}

/** A position in a query result set. */
export interface Cursor {
  /**
   * The values that represent a position, in the order they appear in
   * the order by clause of a query.
   *
   * Can contain fewer values than specified in the order by clause.
   */
  values: Value[];
  /**
   * If the position is just before or just after the given values, relative
   * to the sort order defined by the query.
   */
  before: boolean;
}

function createBaseStructuredQuery(): StructuredQuery {
  return {
    select: undefined,
    from: [],
    where: undefined,
    orderBy: [],
    startAt: undefined,
    endAt: undefined,
    offset: 0,
    limit: undefined,
  };
}

export const StructuredQuery: MessageFns<StructuredQuery> = {
  encode(message: StructuredQuery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.select !== undefined) {
      StructuredQuery_Projection.encode(message.select, writer.uint32(10).fork()).join();
    }
    for (const v of message.from) {
      StructuredQuery_CollectionSelector.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.where !== undefined) {
      StructuredQuery_Filter.encode(message.where, writer.uint32(26).fork()).join();
    }
    for (const v of message.orderBy) {
      StructuredQuery_Order.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.startAt !== undefined) {
      Cursor.encode(message.startAt, writer.uint32(58).fork()).join();
    }
    if (message.endAt !== undefined) {
      Cursor.encode(message.endAt, writer.uint32(66).fork()).join();
    }
    if (message.offset !== 0) {
      writer.uint32(48).int32(message.offset);
    }
    if (message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.select = StructuredQuery_Projection.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.from.push(StructuredQuery_CollectionSelector.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.where = StructuredQuery_Filter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orderBy.push(StructuredQuery_Order.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.startAt = Cursor.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endAt = Cursor.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.offset = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery {
    return {
      select: isSet(object.select) ? StructuredQuery_Projection.fromJSON(object.select) : undefined,
      from: globalThis.Array.isArray(object?.from)
        ? object.from.map((e: any) => StructuredQuery_CollectionSelector.fromJSON(e))
        : [],
      where: isSet(object.where) ? StructuredQuery_Filter.fromJSON(object.where) : undefined,
      orderBy: globalThis.Array.isArray(object?.orderBy)
        ? object.orderBy.map((e: any) => StructuredQuery_Order.fromJSON(e))
        : [],
      startAt: isSet(object.startAt) ? Cursor.fromJSON(object.startAt) : undefined,
      endAt: isSet(object.endAt) ? Cursor.fromJSON(object.endAt) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      limit: isSet(object.limit) ? Number(object.limit) : undefined,
    };
  },

  toJSON(message: StructuredQuery): unknown {
    const obj: any = {};
    if (message.select !== undefined) {
      obj.select = StructuredQuery_Projection.toJSON(message.select);
    }
    if (message.from?.length) {
      obj.from = message.from.map((e) => StructuredQuery_CollectionSelector.toJSON(e));
    }
    if (message.where !== undefined) {
      obj.where = StructuredQuery_Filter.toJSON(message.where);
    }
    if (message.orderBy?.length) {
      obj.orderBy = message.orderBy.map((e) => StructuredQuery_Order.toJSON(e));
    }
    if (message.startAt !== undefined) {
      obj.startAt = Cursor.toJSON(message.startAt);
    }
    if (message.endAt !== undefined) {
      obj.endAt = Cursor.toJSON(message.endAt);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery>): StructuredQuery {
    return StructuredQuery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery>): StructuredQuery {
    const message = createBaseStructuredQuery();
    message.select = (object.select !== undefined && object.select !== null)
      ? StructuredQuery_Projection.fromPartial(object.select)
      : undefined;
    message.from = object.from?.map((e) => StructuredQuery_CollectionSelector.fromPartial(e)) || [];
    message.where = (object.where !== undefined && object.where !== null)
      ? StructuredQuery_Filter.fromPartial(object.where)
      : undefined;
    message.orderBy = object.orderBy?.map((e) => StructuredQuery_Order.fromPartial(e)) || [];
    message.startAt = (object.startAt !== undefined && object.startAt !== null)
      ? Cursor.fromPartial(object.startAt)
      : undefined;
    message.endAt = (object.endAt !== undefined && object.endAt !== null)
      ? Cursor.fromPartial(object.endAt)
      : undefined;
    message.offset = object.offset ?? 0;
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBaseStructuredQuery_CollectionSelector(): StructuredQuery_CollectionSelector {
  return { collectionId: "", allDescendants: false };
}

export const StructuredQuery_CollectionSelector: MessageFns<StructuredQuery_CollectionSelector> = {
  encode(message: StructuredQuery_CollectionSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.collectionId !== "") {
      writer.uint32(18).string(message.collectionId);
    }
    if (message.allDescendants !== false) {
      writer.uint32(24).bool(message.allDescendants);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_CollectionSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_CollectionSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.collectionId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allDescendants = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_CollectionSelector {
    return {
      collectionId: isSet(object.collectionId) ? globalThis.String(object.collectionId) : "",
      allDescendants: isSet(object.allDescendants) ? globalThis.Boolean(object.allDescendants) : false,
    };
  },

  toJSON(message: StructuredQuery_CollectionSelector): unknown {
    const obj: any = {};
    if (message.collectionId !== "") {
      obj.collectionId = message.collectionId;
    }
    if (message.allDescendants !== false) {
      obj.allDescendants = message.allDescendants;
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_CollectionSelector>): StructuredQuery_CollectionSelector {
    return StructuredQuery_CollectionSelector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_CollectionSelector>): StructuredQuery_CollectionSelector {
    const message = createBaseStructuredQuery_CollectionSelector();
    message.collectionId = object.collectionId ?? "";
    message.allDescendants = object.allDescendants ?? false;
    return message;
  },
};

function createBaseStructuredQuery_Filter(): StructuredQuery_Filter {
  return { compositeFilter: undefined, fieldFilter: undefined, unaryFilter: undefined };
}

export const StructuredQuery_Filter: MessageFns<StructuredQuery_Filter> = {
  encode(message: StructuredQuery_Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.compositeFilter !== undefined) {
      StructuredQuery_CompositeFilter.encode(message.compositeFilter, writer.uint32(10).fork()).join();
    }
    if (message.fieldFilter !== undefined) {
      StructuredQuery_FieldFilter.encode(message.fieldFilter, writer.uint32(18).fork()).join();
    }
    if (message.unaryFilter !== undefined) {
      StructuredQuery_UnaryFilter.encode(message.unaryFilter, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_Filter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.compositeFilter = StructuredQuery_CompositeFilter.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldFilter = StructuredQuery_FieldFilter.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unaryFilter = StructuredQuery_UnaryFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_Filter {
    return {
      compositeFilter: isSet(object.compositeFilter)
        ? StructuredQuery_CompositeFilter.fromJSON(object.compositeFilter)
        : undefined,
      fieldFilter: isSet(object.fieldFilter) ? StructuredQuery_FieldFilter.fromJSON(object.fieldFilter) : undefined,
      unaryFilter: isSet(object.unaryFilter) ? StructuredQuery_UnaryFilter.fromJSON(object.unaryFilter) : undefined,
    };
  },

  toJSON(message: StructuredQuery_Filter): unknown {
    const obj: any = {};
    if (message.compositeFilter !== undefined) {
      obj.compositeFilter = StructuredQuery_CompositeFilter.toJSON(message.compositeFilter);
    }
    if (message.fieldFilter !== undefined) {
      obj.fieldFilter = StructuredQuery_FieldFilter.toJSON(message.fieldFilter);
    }
    if (message.unaryFilter !== undefined) {
      obj.unaryFilter = StructuredQuery_UnaryFilter.toJSON(message.unaryFilter);
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_Filter>): StructuredQuery_Filter {
    return StructuredQuery_Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_Filter>): StructuredQuery_Filter {
    const message = createBaseStructuredQuery_Filter();
    message.compositeFilter = (object.compositeFilter !== undefined && object.compositeFilter !== null)
      ? StructuredQuery_CompositeFilter.fromPartial(object.compositeFilter)
      : undefined;
    message.fieldFilter = (object.fieldFilter !== undefined && object.fieldFilter !== null)
      ? StructuredQuery_FieldFilter.fromPartial(object.fieldFilter)
      : undefined;
    message.unaryFilter = (object.unaryFilter !== undefined && object.unaryFilter !== null)
      ? StructuredQuery_UnaryFilter.fromPartial(object.unaryFilter)
      : undefined;
    return message;
  },
};

function createBaseStructuredQuery_CompositeFilter(): StructuredQuery_CompositeFilter {
  return { op: 0, filters: [] };
}

export const StructuredQuery_CompositeFilter: MessageFns<StructuredQuery_CompositeFilter> = {
  encode(message: StructuredQuery_CompositeFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    for (const v of message.filters) {
      StructuredQuery_Filter.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_CompositeFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_CompositeFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filters.push(StructuredQuery_Filter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_CompositeFilter {
    return {
      op: isSet(object.op) ? structuredQuery_CompositeFilter_OperatorFromJSON(object.op) : 0,
      filters: globalThis.Array.isArray(object?.filters)
        ? object.filters.map((e: any) => StructuredQuery_Filter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StructuredQuery_CompositeFilter): unknown {
    const obj: any = {};
    if (message.op !== 0) {
      obj.op = structuredQuery_CompositeFilter_OperatorToJSON(message.op);
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => StructuredQuery_Filter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_CompositeFilter>): StructuredQuery_CompositeFilter {
    return StructuredQuery_CompositeFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_CompositeFilter>): StructuredQuery_CompositeFilter {
    const message = createBaseStructuredQuery_CompositeFilter();
    message.op = object.op ?? 0;
    message.filters = object.filters?.map((e) => StructuredQuery_Filter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStructuredQuery_FieldFilter(): StructuredQuery_FieldFilter {
  return { field: undefined, op: 0, value: undefined };
}

export const StructuredQuery_FieldFilter: MessageFns<StructuredQuery_FieldFilter> = {
  encode(message: StructuredQuery_FieldFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined) {
      StructuredQuery_FieldReference.encode(message.field, writer.uint32(10).fork()).join();
    }
    if (message.op !== 0) {
      writer.uint32(16).int32(message.op);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_FieldFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_FieldFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = StructuredQuery_FieldReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_FieldFilter {
    return {
      field: isSet(object.field) ? StructuredQuery_FieldReference.fromJSON(object.field) : undefined,
      op: isSet(object.op) ? structuredQuery_FieldFilter_OperatorFromJSON(object.op) : 0,
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: StructuredQuery_FieldFilter): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = StructuredQuery_FieldReference.toJSON(message.field);
    }
    if (message.op !== 0) {
      obj.op = structuredQuery_FieldFilter_OperatorToJSON(message.op);
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_FieldFilter>): StructuredQuery_FieldFilter {
    return StructuredQuery_FieldFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_FieldFilter>): StructuredQuery_FieldFilter {
    const message = createBaseStructuredQuery_FieldFilter();
    message.field = (object.field !== undefined && object.field !== null)
      ? StructuredQuery_FieldReference.fromPartial(object.field)
      : undefined;
    message.op = object.op ?? 0;
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseStructuredQuery_UnaryFilter(): StructuredQuery_UnaryFilter {
  return { op: 0, field: undefined };
}

export const StructuredQuery_UnaryFilter: MessageFns<StructuredQuery_UnaryFilter> = {
  encode(message: StructuredQuery_UnaryFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.field !== undefined) {
      StructuredQuery_FieldReference.encode(message.field, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_UnaryFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_UnaryFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.field = StructuredQuery_FieldReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_UnaryFilter {
    return {
      op: isSet(object.op) ? structuredQuery_UnaryFilter_OperatorFromJSON(object.op) : 0,
      field: isSet(object.field) ? StructuredQuery_FieldReference.fromJSON(object.field) : undefined,
    };
  },

  toJSON(message: StructuredQuery_UnaryFilter): unknown {
    const obj: any = {};
    if (message.op !== 0) {
      obj.op = structuredQuery_UnaryFilter_OperatorToJSON(message.op);
    }
    if (message.field !== undefined) {
      obj.field = StructuredQuery_FieldReference.toJSON(message.field);
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_UnaryFilter>): StructuredQuery_UnaryFilter {
    return StructuredQuery_UnaryFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_UnaryFilter>): StructuredQuery_UnaryFilter {
    const message = createBaseStructuredQuery_UnaryFilter();
    message.op = object.op ?? 0;
    message.field = (object.field !== undefined && object.field !== null)
      ? StructuredQuery_FieldReference.fromPartial(object.field)
      : undefined;
    return message;
  },
};

function createBaseStructuredQuery_FieldReference(): StructuredQuery_FieldReference {
  return { fieldPath: "" };
}

export const StructuredQuery_FieldReference: MessageFns<StructuredQuery_FieldReference> = {
  encode(message: StructuredQuery_FieldReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldPath !== "") {
      writer.uint32(18).string(message.fieldPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_FieldReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_FieldReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldPath = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_FieldReference {
    return { fieldPath: isSet(object.fieldPath) ? globalThis.String(object.fieldPath) : "" };
  },

  toJSON(message: StructuredQuery_FieldReference): unknown {
    const obj: any = {};
    if (message.fieldPath !== "") {
      obj.fieldPath = message.fieldPath;
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_FieldReference>): StructuredQuery_FieldReference {
    return StructuredQuery_FieldReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_FieldReference>): StructuredQuery_FieldReference {
    const message = createBaseStructuredQuery_FieldReference();
    message.fieldPath = object.fieldPath ?? "";
    return message;
  },
};

function createBaseStructuredQuery_Order(): StructuredQuery_Order {
  return { field: undefined, direction: 0 };
}

export const StructuredQuery_Order: MessageFns<StructuredQuery_Order> = {
  encode(message: StructuredQuery_Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== undefined) {
      StructuredQuery_FieldReference.encode(message.field, writer.uint32(10).fork()).join();
    }
    if (message.direction !== 0) {
      writer.uint32(16).int32(message.direction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_Order();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = StructuredQuery_FieldReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_Order {
    return {
      field: isSet(object.field) ? StructuredQuery_FieldReference.fromJSON(object.field) : undefined,
      direction: isSet(object.direction) ? structuredQuery_DirectionFromJSON(object.direction) : 0,
    };
  },

  toJSON(message: StructuredQuery_Order): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = StructuredQuery_FieldReference.toJSON(message.field);
    }
    if (message.direction !== 0) {
      obj.direction = structuredQuery_DirectionToJSON(message.direction);
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_Order>): StructuredQuery_Order {
    return StructuredQuery_Order.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_Order>): StructuredQuery_Order {
    const message = createBaseStructuredQuery_Order();
    message.field = (object.field !== undefined && object.field !== null)
      ? StructuredQuery_FieldReference.fromPartial(object.field)
      : undefined;
    message.direction = object.direction ?? 0;
    return message;
  },
};

function createBaseStructuredQuery_Projection(): StructuredQuery_Projection {
  return { fields: [] };
}

export const StructuredQuery_Projection: MessageFns<StructuredQuery_Projection> = {
  encode(message: StructuredQuery_Projection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      StructuredQuery_FieldReference.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StructuredQuery_Projection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStructuredQuery_Projection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fields.push(StructuredQuery_FieldReference.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StructuredQuery_Projection {
    return {
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => StructuredQuery_FieldReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StructuredQuery_Projection): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => StructuredQuery_FieldReference.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StructuredQuery_Projection>): StructuredQuery_Projection {
    return StructuredQuery_Projection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StructuredQuery_Projection>): StructuredQuery_Projection {
    const message = createBaseStructuredQuery_Projection();
    message.fields = object.fields?.map((e) => StructuredQuery_FieldReference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCursor(): Cursor {
  return { values: [], before: false };
}

export const Cursor: MessageFns<Cursor> = {
  encode(message: Cursor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      Value.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.before !== false) {
      writer.uint32(16).bool(message.before);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cursor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCursor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(Value.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.before = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cursor {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Value.fromJSON(e)) : [],
      before: isSet(object.before) ? globalThis.Boolean(object.before) : false,
    };
  },

  toJSON(message: Cursor): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Value.toJSON(e));
    }
    if (message.before !== false) {
      obj.before = message.before;
    }
    return obj;
  },

  create(base?: DeepPartial<Cursor>): Cursor {
    return Cursor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cursor>): Cursor {
    const message = createBaseCursor();
    message.values = object.values?.map((e) => Value.fromPartial(e)) || [];
    message.before = object.before ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
