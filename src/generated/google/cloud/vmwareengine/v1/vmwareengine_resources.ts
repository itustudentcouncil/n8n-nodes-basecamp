// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/vmwareengine/v1/vmwareengine_resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.vmwareengine.v1";

/**
 * Network configuration in the consumer project
 * with which the peering has to be done.
 */
export interface NetworkConfig {
  /** Required. Management CIDR used by VMware management appliances. */
  managementCidr: string;
  /**
   * Optional. The relative resource name of the VMware Engine network attached
   * to the private cloud. Specify the name in the following form:
   * `projects/{project}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
   * where `{project}` can either be a project number or a project ID.
   */
  vmwareEngineNetwork: string;
  /**
   * Output only. The canonical name of the VMware Engine network in the form:
   * `projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
   */
  vmwareEngineNetworkCanonical: string;
  /**
   * Output only. The IP address layout version of the management IP address
   * range. Possible versions include:
   * * `managementIpAddressLayoutVersion=1`: Indicates the legacy IP address
   * layout used by some existing private clouds. This is no longer supported
   * for new private clouds as it does not support all features.
   * * `managementIpAddressLayoutVersion=2`: Indicates the latest IP address
   * layout used by all newly created private clouds. This version supports all
   * current features.
   */
  managementIpAddressLayoutVersion: number;
  /**
   * Output only. DNS Server IP of the Private Cloud.
   * All DNS queries can be forwarded to this address for name resolution of
   * Private Cloud's management entities like vCenter, NSX-T Manager and
   * ESXi hosts.
   */
  dnsServerIp: string;
}

/** Information about the type and number of nodes associated with the cluster. */
export interface NodeTypeConfig {
  /** Required. The number of nodes of this type in the cluster */
  nodeCount: number;
  /**
   * Optional. Customized number of cores available to each node of the type.
   * This number must always be one of `nodeType.availableCustomCoreCounts`.
   * If zero is provided max value from `nodeType.availableCustomCoreCounts`
   * will be used.
   */
  customCoreCount: number;
}

/** Configuration of a stretched cluster. */
export interface StretchedClusterConfig {
  /**
   * Required. Zone that will remain operational when connection between the two
   * zones is lost. Specify the resource name of a zone that belongs to the
   * region of the private cloud. For example:
   * `projects/{project}/locations/europe-west3-a` where `{project}` can either
   * be a project number or a project ID.
   */
  preferredLocation: string;
  /**
   * Required. Additional zone for a higher level of availability and load
   * balancing. Specify the resource name of a zone that belongs to the region
   * of the private cloud. For example:
   * `projects/{project}/locations/europe-west3-b` where `{project}` can either
   * be a project number or a project ID.
   */
  secondaryLocation: string;
}

/**
 * Represents a private cloud resource. Private clouds of type `STANDARD` and
 * `TIME_LIMITED` are zonal resources, `STRETCHED` private clouds are
 * regional.
 */
export interface PrivateCloud {
  /**
   * Output only. The resource name of this private cloud.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  name: string;
  /** Output only. Creation time of this resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update time of this resource. */
  updateTime:
    | Date
    | undefined;
  /** Output only. Time when the resource was scheduled for deletion. */
  deleteTime:
    | Date
    | undefined;
  /** Output only. Time when the resource will be irreversibly deleted. */
  expireTime:
    | Date
    | undefined;
  /**
   * Output only. State of the resource. New values may be added to this enum
   * when appropriate.
   */
  state: PrivateCloud_State;
  /** Required. Network configuration of the private cloud. */
  networkConfig:
    | NetworkConfig
    | undefined;
  /**
   * Required. Input only. The management cluster for this private cloud.
   * This field is required during creation of the private cloud to provide
   * details for the default cluster.
   *
   * The following fields can't be changed after private cloud creation:
   * `ManagementCluster.clusterId`, `ManagementCluster.nodeTypeId`.
   */
  managementCluster:
    | PrivateCloud_ManagementCluster
    | undefined;
  /** User-provided description for this private cloud. */
  description: string;
  /** Output only. HCX appliance. */
  hcx:
    | Hcx
    | undefined;
  /** Output only. NSX appliance. */
  nsx:
    | Nsx
    | undefined;
  /** Output only. Vcenter appliance. */
  vcenter:
    | Vcenter
    | undefined;
  /** Output only. System-generated unique identifier for the resource. */
  uid: string;
  /** Optional. Type of the private cloud. Defaults to STANDARD. */
  type: PrivateCloud_Type;
}

/** Enum State defines possible states of private clouds. */
export enum PrivateCloud_State {
  /** STATE_UNSPECIFIED - The default value. This value should never be used. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The private cloud is ready. */
  ACTIVE = 1,
  /** CREATING - The private cloud is being created. */
  CREATING = 2,
  /** UPDATING - The private cloud is being updated. */
  UPDATING = 3,
  /** FAILED - The private cloud is in failed state. */
  FAILED = 5,
  /**
   * DELETED - The private cloud is scheduled for deletion. The deletion process can be
   * cancelled by using the corresponding undelete method.
   */
  DELETED = 6,
  /**
   * PURGING - The private cloud is irreversibly deleted and is being removed from the
   * system.
   */
  PURGING = 7,
  UNRECOGNIZED = -1,
}

export function privateCloud_StateFromJSON(object: any): PrivateCloud_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return PrivateCloud_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return PrivateCloud_State.ACTIVE;
    case 2:
    case "CREATING":
      return PrivateCloud_State.CREATING;
    case 3:
    case "UPDATING":
      return PrivateCloud_State.UPDATING;
    case 5:
    case "FAILED":
      return PrivateCloud_State.FAILED;
    case 6:
    case "DELETED":
      return PrivateCloud_State.DELETED;
    case 7:
    case "PURGING":
      return PrivateCloud_State.PURGING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PrivateCloud_State.UNRECOGNIZED;
  }
}

export function privateCloud_StateToJSON(object: PrivateCloud_State): string {
  switch (object) {
    case PrivateCloud_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case PrivateCloud_State.ACTIVE:
      return "ACTIVE";
    case PrivateCloud_State.CREATING:
      return "CREATING";
    case PrivateCloud_State.UPDATING:
      return "UPDATING";
    case PrivateCloud_State.FAILED:
      return "FAILED";
    case PrivateCloud_State.DELETED:
      return "DELETED";
    case PrivateCloud_State.PURGING:
      return "PURGING";
    case PrivateCloud_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enum Type defines private cloud type. */
export enum PrivateCloud_Type {
  /** STANDARD - Standard private is a zonal resource, with 3+ nodes. Default type. */
  STANDARD = 0,
  /**
   * TIME_LIMITED - Time limited private cloud is a zonal resource, can have only 1 node and
   * has limited life span. Will be deleted after defined period of time,
   * can be converted into standard private cloud by expanding it up to 3
   * or more nodes.
   */
  TIME_LIMITED = 1,
  /**
   * STRETCHED - Stretched private cloud is a regional resource with redundancy,
   * with a minimum of 6 nodes, nodes count has to be even.
   */
  STRETCHED = 2,
  UNRECOGNIZED = -1,
}

export function privateCloud_TypeFromJSON(object: any): PrivateCloud_Type {
  switch (object) {
    case 0:
    case "STANDARD":
      return PrivateCloud_Type.STANDARD;
    case 1:
    case "TIME_LIMITED":
      return PrivateCloud_Type.TIME_LIMITED;
    case 2:
    case "STRETCHED":
      return PrivateCloud_Type.STRETCHED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PrivateCloud_Type.UNRECOGNIZED;
  }
}

export function privateCloud_TypeToJSON(object: PrivateCloud_Type): string {
  switch (object) {
    case PrivateCloud_Type.STANDARD:
      return "STANDARD";
    case PrivateCloud_Type.TIME_LIMITED:
      return "TIME_LIMITED";
    case PrivateCloud_Type.STRETCHED:
      return "STRETCHED";
    case PrivateCloud_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Management cluster configuration. */
export interface PrivateCloud_ManagementCluster {
  /**
   * Required. The user-provided identifier of the new `Cluster`.
   * The identifier must meet the following requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC
   * 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
   */
  clusterId: string;
  /**
   * Required. The map of cluster node types in this cluster, where the key is
   * canonical identifier of the node type (corresponds to the `NodeType`).
   */
  nodeTypeConfigs: { [key: string]: NodeTypeConfig };
  /**
   * Optional. Configuration of a stretched cluster. Required for STRETCHED
   * private clouds.
   */
  stretchedClusterConfig: StretchedClusterConfig | undefined;
}

export interface PrivateCloud_ManagementCluster_NodeTypeConfigsEntry {
  key: string;
  value: NodeTypeConfig | undefined;
}

/** A cluster in a private cloud. */
export interface Cluster {
  /**
   * Output only. The resource name of this cluster.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/clusters/my-cluster`
   */
  name: string;
  /** Output only. Creation time of this resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update time of this resource. */
  updateTime:
    | Date
    | undefined;
  /** Output only. State of the resource. */
  state: Cluster_State;
  /**
   * Output only. True if the cluster is a management cluster; false otherwise.
   * There can only be one management cluster in a private cloud
   * and it has to be the first one.
   */
  management: boolean;
  /** Optional. Configuration of the autoscaling applied to this cluster. */
  autoscalingSettings:
    | AutoscalingSettings
    | undefined;
  /** Output only. System-generated unique identifier for the resource. */
  uid: string;
  /**
   * Required. The map of cluster node types in this cluster, where the key is
   * canonical identifier of the node type (corresponds to the `NodeType`).
   */
  nodeTypeConfigs: { [key: string]: NodeTypeConfig };
  /**
   * Optional. Configuration of a stretched cluster. Required for clusters that
   * belong to a STRETCHED private cloud.
   */
  stretchedClusterConfig: StretchedClusterConfig | undefined;
}

/** Enum State defines possible states of private cloud clusters. */
export enum Cluster_State {
  /** STATE_UNSPECIFIED - The default value. This value should never be used. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The Cluster is operational and can be used by the user. */
  ACTIVE = 1,
  /** CREATING - The Cluster is being deployed. */
  CREATING = 2,
  /**
   * UPDATING - Adding or removing of a node to the cluster, any other cluster specific
   * updates.
   */
  UPDATING = 3,
  /** DELETING - The Cluster is being deleted. */
  DELETING = 4,
  /**
   * REPAIRING - The Cluster is undergoing maintenance, for example: a failed node is
   * getting replaced.
   */
  REPAIRING = 5,
  UNRECOGNIZED = -1,
}

export function cluster_StateFromJSON(object: any): Cluster_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Cluster_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Cluster_State.ACTIVE;
    case 2:
    case "CREATING":
      return Cluster_State.CREATING;
    case 3:
    case "UPDATING":
      return Cluster_State.UPDATING;
    case 4:
    case "DELETING":
      return Cluster_State.DELETING;
    case 5:
    case "REPAIRING":
      return Cluster_State.REPAIRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Cluster_State.UNRECOGNIZED;
  }
}

export function cluster_StateToJSON(object: Cluster_State): string {
  switch (object) {
    case Cluster_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Cluster_State.ACTIVE:
      return "ACTIVE";
    case Cluster_State.CREATING:
      return "CREATING";
    case Cluster_State.UPDATING:
      return "UPDATING";
    case Cluster_State.DELETING:
      return "DELETING";
    case Cluster_State.REPAIRING:
      return "REPAIRING";
    case Cluster_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Cluster_NodeTypeConfigsEntry {
  key: string;
  value: NodeTypeConfig | undefined;
}

/** Node in a cluster. */
export interface Node {
  /**
   * Output only. The resource name of this node.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * projects/my-project/locations/us-central1-a/privateClouds/my-cloud/clusters/my-cluster/nodes/my-node
   */
  name: string;
  /** Output only. Fully qualified domain name of the node. */
  fqdn: string;
  /** Output only. Internal IP address of the node. */
  internalIp: string;
  /**
   * Output only. The canonical identifier of the node type (corresponds to the
   * `NodeType`).
   * For example: standard-72.
   */
  nodeTypeId: string;
  /**
   * Output only. The version number of the VMware ESXi
   * management component in this cluster.
   */
  version: string;
  /** Output only. Customized number of cores */
  customCoreCount: Long;
  /** Output only. The state of the appliance. */
  state: Node_State;
}

/** Enum State defines possible states of a node in a cluster. */
export enum Node_State {
  /** STATE_UNSPECIFIED - The default value. This value should never be used. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - Node is operational and can be used by the user. */
  ACTIVE = 1,
  /** CREATING - Node is being provisioned. */
  CREATING = 2,
  /** FAILED - Node is in a failed state. */
  FAILED = 3,
  /** UPGRADING - Node is undergoing maintenance, e.g.: during private cloud upgrade. */
  UPGRADING = 4,
  UNRECOGNIZED = -1,
}

export function node_StateFromJSON(object: any): Node_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Node_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Node_State.ACTIVE;
    case 2:
    case "CREATING":
      return Node_State.CREATING;
    case 3:
    case "FAILED":
      return Node_State.FAILED;
    case 4:
    case "UPGRADING":
      return Node_State.UPGRADING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Node_State.UNRECOGNIZED;
  }
}

export function node_StateToJSON(object: Node_State): string {
  switch (object) {
    case Node_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Node_State.ACTIVE:
      return "ACTIVE";
    case Node_State.CREATING:
      return "CREATING";
    case Node_State.FAILED:
      return "FAILED";
    case Node_State.UPGRADING:
      return "UPGRADING";
    case Node_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents an allocated external IP address and its corresponding internal IP
 * address in a private cloud.
 */
export interface ExternalAddress {
  /**
   * Output only. The resource name of this external IP address.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/externalAddresses/my-address`
   */
  name: string;
  /** Output only. Creation time of this resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update time of this resource. */
  updateTime:
    | Date
    | undefined;
  /** The internal IP address of a workload VM. */
  internalIp: string;
  /** Output only. The external IP address of a workload VM. */
  externalIp: string;
  /** Output only. The state of the resource. */
  state: ExternalAddress_State;
  /** Output only. System-generated unique identifier for the resource. */
  uid: string;
  /** User-provided description for this resource. */
  description: string;
}

/** Enum State defines possible states of external addresses. */
export enum ExternalAddress_State {
  /** STATE_UNSPECIFIED - The default value. This value should never be used. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The address is ready. */
  ACTIVE = 1,
  /** CREATING - The address is being created. */
  CREATING = 2,
  /** UPDATING - The address is being updated. */
  UPDATING = 3,
  /** DELETING - The address is being deleted. */
  DELETING = 4,
  UNRECOGNIZED = -1,
}

export function externalAddress_StateFromJSON(object: any): ExternalAddress_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ExternalAddress_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return ExternalAddress_State.ACTIVE;
    case 2:
    case "CREATING":
      return ExternalAddress_State.CREATING;
    case 3:
    case "UPDATING":
      return ExternalAddress_State.UPDATING;
    case 4:
    case "DELETING":
      return ExternalAddress_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExternalAddress_State.UNRECOGNIZED;
  }
}

export function externalAddress_StateToJSON(object: ExternalAddress_State): string {
  switch (object) {
    case ExternalAddress_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ExternalAddress_State.ACTIVE:
      return "ACTIVE";
    case ExternalAddress_State.CREATING:
      return "CREATING";
    case ExternalAddress_State.UPDATING:
      return "UPDATING";
    case ExternalAddress_State.DELETING:
      return "DELETING";
    case ExternalAddress_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Subnet in a private cloud. Either `management` subnets (such as vMotion) that
 * are read-only, or `userDefined`, which can also be updated.
 */
export interface Subnet {
  /**
   * Output only. The resource name of this subnet.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/subnets/my-subnet`
   */
  name: string;
  /** The IP address range of the subnet in CIDR format '10.0.0.0/24'. */
  ipCidrRange: string;
  /**
   * The IP address of the gateway of this subnet.
   * Must fall within the IP prefix defined above.
   */
  gatewayIp: string;
  /**
   * Output only. The type of the subnet. For example "management" or
   * "userDefined".
   */
  type: string;
  /** Output only. The state of the resource. */
  state: Subnet_State;
  /** Output only. VLAN ID of the VLAN on which the subnet is configured */
  vlanId: number;
}

/** Defines possible states of subnets. */
export enum Subnet_State {
  /** STATE_UNSPECIFIED - The default value. This value should never be used. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The subnet is ready. */
  ACTIVE = 1,
  /** CREATING - The subnet is being created. */
  CREATING = 2,
  /** UPDATING - The subnet is being updated. */
  UPDATING = 3,
  /** DELETING - The subnet is being deleted. */
  DELETING = 4,
  /** RECONCILING - Changes requested in the last operation are being propagated. */
  RECONCILING = 5,
  /**
   * FAILED - Last operation on the subnet did not succeed. Subnet's payload is
   * reverted back to its most recent working state.
   */
  FAILED = 6,
  UNRECOGNIZED = -1,
}

export function subnet_StateFromJSON(object: any): Subnet_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Subnet_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Subnet_State.ACTIVE;
    case 2:
    case "CREATING":
      return Subnet_State.CREATING;
    case 3:
    case "UPDATING":
      return Subnet_State.UPDATING;
    case 4:
    case "DELETING":
      return Subnet_State.DELETING;
    case 5:
    case "RECONCILING":
      return Subnet_State.RECONCILING;
    case 6:
    case "FAILED":
      return Subnet_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Subnet_State.UNRECOGNIZED;
  }
}

export function subnet_StateToJSON(object: Subnet_State): string {
  switch (object) {
    case Subnet_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Subnet_State.ACTIVE:
      return "ACTIVE";
    case Subnet_State.CREATING:
      return "CREATING";
    case Subnet_State.UPDATING:
      return "UPDATING";
    case Subnet_State.DELETING:
      return "DELETING";
    case Subnet_State.RECONCILING:
      return "RECONCILING";
    case Subnet_State.FAILED:
      return "FAILED";
    case Subnet_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * External access firewall rules for filtering incoming traffic destined to
 * `ExternalAddress` resources.
 */
export interface ExternalAccessRule {
  /**
   * Output only. The resource name of this external access rule.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/networkPolicies/my-policy/externalAccessRules/my-rule`
   */
  name: string;
  /** Output only. Creation time of this resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update time of this resource. */
  updateTime:
    | Date
    | undefined;
  /** User-provided description for this external access rule. */
  description: string;
  /**
   * External access rule priority, which determines the external access rule to
   * use when multiple rules apply. If multiple rules have the same priority,
   * their ordering is non-deterministic. If specific ordering is required,
   * assign unique priorities to enforce such ordering. The external access rule
   * priority is an integer from 100 to 4096, both inclusive. Lower integers
   * indicate higher precedence. For example, a rule with priority `100` has
   * higher precedence than a rule with priority `101`.
   */
  priority: number;
  /** The action that the external access rule performs. */
  action: ExternalAccessRule_Action;
  /**
   * The IP protocol to which the external access rule applies. This value can
   * be one of the following three protocol strings (not case-sensitive):
   * `tcp`, `udp`, or `icmp`.
   */
  ipProtocol: string;
  /**
   * If source ranges are specified, the external access rule applies only to
   * traffic that has a source IP address in these ranges. These ranges can
   * either be expressed in the CIDR format or as an IP address. As only inbound
   * rules are supported, `ExternalAddress` resources cannot be the source IP
   * addresses of an external access rule. To match all source addresses,
   * specify `0.0.0.0/0`.
   */
  sourceIpRanges: ExternalAccessRule_IpRange[];
  /**
   * A list of source ports to which the external access rule applies. This
   * field is only applicable for the UDP or TCP protocol.
   * Each entry must be either an integer or a range. For example: `["22"]`,
   * `["80","443"]`, or `["12345-12349"]`. To match all source ports, specify
   * `["0-65535"]`.
   */
  sourcePorts: string[];
  /**
   * If destination ranges are specified, the external access rule applies only
   * to the traffic that has a destination IP address in these ranges. The
   * specified IP addresses must have reserved external IP addresses in the
   * scope of the parent network policy. To match all external IP addresses in
   * the scope of the parent network policy, specify `0.0.0.0/0`. To match a
   * specific external IP address, specify it using the
   * `IpRange.external_address` property.
   */
  destinationIpRanges: ExternalAccessRule_IpRange[];
  /**
   * A list of destination ports to which the external access rule applies. This
   * field is only applicable for the UDP or TCP protocol.
   * Each entry must be either an integer or a range. For example: `["22"]`,
   * `["80","443"]`, or `["12345-12349"]`. To match all destination ports,
   * specify `["0-65535"]`.
   */
  destinationPorts: string[];
  /** Output only. The state of the resource. */
  state: ExternalAccessRule_State;
  /** Output only. System-generated unique identifier for the resource. */
  uid: string;
}

/**
 * Action determines whether the external access rule permits or blocks
 * traffic, subject to the other components of the rule matching the traffic.
 */
export enum ExternalAccessRule_Action {
  /** ACTION_UNSPECIFIED - Defaults to allow. */
  ACTION_UNSPECIFIED = 0,
  /** ALLOW - Allows connections that match the other specified components. */
  ALLOW = 1,
  /** DENY - Blocks connections that match the other specified components. */
  DENY = 2,
  UNRECOGNIZED = -1,
}

export function externalAccessRule_ActionFromJSON(object: any): ExternalAccessRule_Action {
  switch (object) {
    case 0:
    case "ACTION_UNSPECIFIED":
      return ExternalAccessRule_Action.ACTION_UNSPECIFIED;
    case 1:
    case "ALLOW":
      return ExternalAccessRule_Action.ALLOW;
    case 2:
    case "DENY":
      return ExternalAccessRule_Action.DENY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExternalAccessRule_Action.UNRECOGNIZED;
  }
}

export function externalAccessRule_ActionToJSON(object: ExternalAccessRule_Action): string {
  switch (object) {
    case ExternalAccessRule_Action.ACTION_UNSPECIFIED:
      return "ACTION_UNSPECIFIED";
    case ExternalAccessRule_Action.ALLOW:
      return "ALLOW";
    case ExternalAccessRule_Action.DENY:
      return "DENY";
    case ExternalAccessRule_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines possible states of external access firewall rules. */
export enum ExternalAccessRule_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The rule is ready. */
  ACTIVE = 1,
  /** CREATING - The rule is being created. */
  CREATING = 2,
  /** UPDATING - The rule is being updated. */
  UPDATING = 3,
  /** DELETING - The rule is being deleted. */
  DELETING = 4,
  UNRECOGNIZED = -1,
}

export function externalAccessRule_StateFromJSON(object: any): ExternalAccessRule_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ExternalAccessRule_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return ExternalAccessRule_State.ACTIVE;
    case 2:
    case "CREATING":
      return ExternalAccessRule_State.CREATING;
    case 3:
    case "UPDATING":
      return ExternalAccessRule_State.UPDATING;
    case 4:
    case "DELETING":
      return ExternalAccessRule_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExternalAccessRule_State.UNRECOGNIZED;
  }
}

export function externalAccessRule_StateToJSON(object: ExternalAccessRule_State): string {
  switch (object) {
    case ExternalAccessRule_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ExternalAccessRule_State.ACTIVE:
      return "ACTIVE";
    case ExternalAccessRule_State.CREATING:
      return "CREATING";
    case ExternalAccessRule_State.UPDATING:
      return "UPDATING";
    case ExternalAccessRule_State.DELETING:
      return "DELETING";
    case ExternalAccessRule_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An IP range provided in any one of the supported formats. */
export interface ExternalAccessRule_IpRange {
  /** A single IP address. For example: `10.0.0.5`. */
  ipAddress?:
    | string
    | undefined;
  /** An IP address range in the CIDR format. For example: `10.0.0.0/24`. */
  ipAddressRange?:
    | string
    | undefined;
  /**
   * The name of an `ExternalAddress` resource. The external address must
   * have been reserved in the scope of this external access rule's parent
   * network policy.  Provide the external address name in the form of
   * `projects/{project}/locations/{location}/privateClouds/{private_cloud}/externalAddresses/{external_address}`.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/externalAddresses/my-address`.
   */
  externalAddress?: string | undefined;
}

/** Logging server to receive vCenter or ESXi logs. */
export interface LoggingServer {
  /**
   * Output only. The resource name of this logging server.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/loggingServers/my-logging-server`
   */
  name: string;
  /** Output only. Creation time of this resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update time of this resource. */
  updateTime:
    | Date
    | undefined;
  /**
   * Required. Fully-qualified domain name (FQDN) or IP Address of the logging
   * server.
   */
  hostname: string;
  /** Required. Port number at which the logging server receives logs. */
  port: number;
  /** Required. Protocol used by vCenter to send logs to a logging server. */
  protocol: LoggingServer_Protocol;
  /**
   * Required. The type of component that produces logs that will be forwarded
   * to this logging server.
   */
  sourceType: LoggingServer_SourceType;
  /** Output only. System-generated unique identifier for the resource. */
  uid: string;
}

/**
 * Defines possible protocols used to send logs to
 * a logging server.
 */
export enum LoggingServer_Protocol {
  /** PROTOCOL_UNSPECIFIED - Unspecified communications protocol. This is the default value. */
  PROTOCOL_UNSPECIFIED = 0,
  /** UDP - UDP */
  UDP = 1,
  /** TCP - TCP */
  TCP = 2,
  /** TLS - TLS */
  TLS = 3,
  /** SSL - SSL */
  SSL = 4,
  /** RELP - RELP */
  RELP = 5,
  UNRECOGNIZED = -1,
}

export function loggingServer_ProtocolFromJSON(object: any): LoggingServer_Protocol {
  switch (object) {
    case 0:
    case "PROTOCOL_UNSPECIFIED":
      return LoggingServer_Protocol.PROTOCOL_UNSPECIFIED;
    case 1:
    case "UDP":
      return LoggingServer_Protocol.UDP;
    case 2:
    case "TCP":
      return LoggingServer_Protocol.TCP;
    case 3:
    case "TLS":
      return LoggingServer_Protocol.TLS;
    case 4:
    case "SSL":
      return LoggingServer_Protocol.SSL;
    case 5:
    case "RELP":
      return LoggingServer_Protocol.RELP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoggingServer_Protocol.UNRECOGNIZED;
  }
}

export function loggingServer_ProtocolToJSON(object: LoggingServer_Protocol): string {
  switch (object) {
    case LoggingServer_Protocol.PROTOCOL_UNSPECIFIED:
      return "PROTOCOL_UNSPECIFIED";
    case LoggingServer_Protocol.UDP:
      return "UDP";
    case LoggingServer_Protocol.TCP:
      return "TCP";
    case LoggingServer_Protocol.TLS:
      return "TLS";
    case LoggingServer_Protocol.SSL:
      return "SSL";
    case LoggingServer_Protocol.RELP:
      return "RELP";
    case LoggingServer_Protocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines possible types of component that produces logs. */
export enum LoggingServer_SourceType {
  /** SOURCE_TYPE_UNSPECIFIED - The default value. This value should never be used. */
  SOURCE_TYPE_UNSPECIFIED = 0,
  /** ESXI - Logs produced by ESXI hosts */
  ESXI = 1,
  /** VCSA - Logs produced by vCenter server */
  VCSA = 2,
  UNRECOGNIZED = -1,
}

export function loggingServer_SourceTypeFromJSON(object: any): LoggingServer_SourceType {
  switch (object) {
    case 0:
    case "SOURCE_TYPE_UNSPECIFIED":
      return LoggingServer_SourceType.SOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "ESXI":
      return LoggingServer_SourceType.ESXI;
    case 2:
    case "VCSA":
      return LoggingServer_SourceType.VCSA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LoggingServer_SourceType.UNRECOGNIZED;
  }
}

export function loggingServer_SourceTypeToJSON(object: LoggingServer_SourceType): string {
  switch (object) {
    case LoggingServer_SourceType.SOURCE_TYPE_UNSPECIFIED:
      return "SOURCE_TYPE_UNSPECIFIED";
    case LoggingServer_SourceType.ESXI:
      return "ESXI";
    case LoggingServer_SourceType.VCSA:
      return "VCSA";
    case LoggingServer_SourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes node type. */
export interface NodeType {
  /**
   * Output only. The resource name of this node type.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-proj/locations/us-central1-a/nodeTypes/standard-72`
   */
  name: string;
  /**
   * Output only. The canonical identifier of the node type
   * (corresponds to the `NodeType`). For example: standard-72.
   */
  nodeTypeId: string;
  /**
   * Output only. The friendly name for this node type.
   * For example: ve1-standard-72
   */
  displayName: string;
  /** Output only. The total number of virtual CPUs in a single node. */
  virtualCpuCount: number;
  /** Output only. The total number of CPU cores in a single node. */
  totalCoreCount: number;
  /** Output only. The amount of physical memory available, defined in GB. */
  memoryGb: number;
  /** Output only. The amount of storage available, defined in GB. */
  diskSizeGb: number;
  /** Output only. List of possible values of custom core count. */
  availableCustomCoreCounts: number[];
  /** Output only. The type of the resource. */
  kind: NodeType_Kind;
  /**
   * Output only. Families of the node type.
   * For node types to be in the same cluster
   * they must share at least one element in the `families`.
   */
  families: string[];
  /** Output only. Capabilities of this node type. */
  capabilities: NodeType_Capability[];
}

/** Enum Kind defines possible types of a NodeType. */
export enum NodeType_Kind {
  /** KIND_UNSPECIFIED - The default value. This value should never be used. */
  KIND_UNSPECIFIED = 0,
  /** STANDARD - Standard HCI node. */
  STANDARD = 1,
  /** STORAGE_ONLY - Storage only Node. */
  STORAGE_ONLY = 2,
  UNRECOGNIZED = -1,
}

export function nodeType_KindFromJSON(object: any): NodeType_Kind {
  switch (object) {
    case 0:
    case "KIND_UNSPECIFIED":
      return NodeType_Kind.KIND_UNSPECIFIED;
    case 1:
    case "STANDARD":
      return NodeType_Kind.STANDARD;
    case 2:
    case "STORAGE_ONLY":
      return NodeType_Kind.STORAGE_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeType_Kind.UNRECOGNIZED;
  }
}

export function nodeType_KindToJSON(object: NodeType_Kind): string {
  switch (object) {
    case NodeType_Kind.KIND_UNSPECIFIED:
      return "KIND_UNSPECIFIED";
    case NodeType_Kind.STANDARD:
      return "STANDARD";
    case NodeType_Kind.STORAGE_ONLY:
      return "STORAGE_ONLY";
    case NodeType_Kind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Capability of a node type. */
export enum NodeType_Capability {
  /**
   * CAPABILITY_UNSPECIFIED - The default value. This value is used if the capability is omitted or
   * unknown.
   */
  CAPABILITY_UNSPECIFIED = 0,
  /** STRETCHED_CLUSTERS - This node type supports stretch clusters. */
  STRETCHED_CLUSTERS = 1,
  UNRECOGNIZED = -1,
}

export function nodeType_CapabilityFromJSON(object: any): NodeType_Capability {
  switch (object) {
    case 0:
    case "CAPABILITY_UNSPECIFIED":
      return NodeType_Capability.CAPABILITY_UNSPECIFIED;
    case 1:
    case "STRETCHED_CLUSTERS":
      return NodeType_Capability.STRETCHED_CLUSTERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NodeType_Capability.UNRECOGNIZED;
  }
}

export function nodeType_CapabilityToJSON(object: NodeType_Capability): string {
  switch (object) {
    case NodeType_Capability.CAPABILITY_UNSPECIFIED:
      return "CAPABILITY_UNSPECIFIED";
    case NodeType_Capability.STRETCHED_CLUSTERS:
      return "STRETCHED_CLUSTERS";
    case NodeType_Capability.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Credentials for a private cloud. */
export interface Credentials {
  /** Initial username. */
  username: string;
  /** Initial password. */
  password: string;
}

/**
 * HCX activation key. A default key is created during
 * private cloud provisioning, but this behavior is subject to change
 * and you should always verify active keys.
 * Use
 * [VmwareEngine.ListHcxActivationKeys][google.cloud.vmwareengine.v1.VmwareEngine.ListHcxActivationKeys]
 * to retrieve existing keys and
 * [VmwareEngine.CreateHcxActivationKey][google.cloud.vmwareengine.v1.VmwareEngine.CreateHcxActivationKey]
 * to create new ones.
 */
export interface HcxActivationKey {
  /**
   * Output only. The resource name of this HcxActivationKey.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/privateClouds/my-cloud/hcxActivationKeys/my-key`
   */
  name: string;
  /** Output only. Creation time of HCX activation key. */
  createTime:
    | Date
    | undefined;
  /** Output only. State of HCX activation key. */
  state: HcxActivationKey_State;
  /** Output only. HCX activation key. */
  activationKey: string;
  /** Output only. System-generated unique identifier for the resource. */
  uid: string;
}

/** State of HCX activation key */
export enum HcxActivationKey_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** AVAILABLE - State of a newly generated activation key. */
  AVAILABLE = 1,
  /** CONSUMED - State of key when it has been used to activate HCX appliance. */
  CONSUMED = 2,
  /** CREATING - State of key when it is being created. */
  CREATING = 3,
  UNRECOGNIZED = -1,
}

export function hcxActivationKey_StateFromJSON(object: any): HcxActivationKey_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return HcxActivationKey_State.STATE_UNSPECIFIED;
    case 1:
    case "AVAILABLE":
      return HcxActivationKey_State.AVAILABLE;
    case 2:
    case "CONSUMED":
      return HcxActivationKey_State.CONSUMED;
    case 3:
    case "CREATING":
      return HcxActivationKey_State.CREATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HcxActivationKey_State.UNRECOGNIZED;
  }
}

export function hcxActivationKey_StateToJSON(object: HcxActivationKey_State): string {
  switch (object) {
    case HcxActivationKey_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case HcxActivationKey_State.AVAILABLE:
      return "AVAILABLE";
    case HcxActivationKey_State.CONSUMED:
      return "CONSUMED";
    case HcxActivationKey_State.CREATING:
      return "CREATING";
    case HcxActivationKey_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details about a HCX Cloud Manager appliance. */
export interface Hcx {
  /** Internal IP address of the appliance. */
  internalIp: string;
  /** Version of the appliance. */
  version: string;
  /** Output only. The state of the appliance. */
  state: Hcx_State;
  /** Fully qualified domain name of the appliance. */
  fqdn: string;
}

/** State of the appliance */
export enum Hcx_State {
  /** STATE_UNSPECIFIED - Unspecified appliance state. This is the default value. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The appliance is operational and can be used. */
  ACTIVE = 1,
  /** CREATING - The appliance is being deployed. */
  CREATING = 2,
  /** ACTIVATING - The appliance is being activated. */
  ACTIVATING = 3,
  UNRECOGNIZED = -1,
}

export function hcx_StateFromJSON(object: any): Hcx_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Hcx_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Hcx_State.ACTIVE;
    case 2:
    case "CREATING":
      return Hcx_State.CREATING;
    case 3:
    case "ACTIVATING":
      return Hcx_State.ACTIVATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Hcx_State.UNRECOGNIZED;
  }
}

export function hcx_StateToJSON(object: Hcx_State): string {
  switch (object) {
    case Hcx_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Hcx_State.ACTIVE:
      return "ACTIVE";
    case Hcx_State.CREATING:
      return "CREATING";
    case Hcx_State.ACTIVATING:
      return "ACTIVATING";
    case Hcx_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details about a NSX Manager appliance. */
export interface Nsx {
  /** Internal IP address of the appliance. */
  internalIp: string;
  /** Version of the appliance. */
  version: string;
  /** Output only. The state of the appliance. */
  state: Nsx_State;
  /** Fully qualified domain name of the appliance. */
  fqdn: string;
}

/** State of the appliance */
export enum Nsx_State {
  /** STATE_UNSPECIFIED - Unspecified appliance state. This is the default value. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The appliance is operational and can be used. */
  ACTIVE = 1,
  /** CREATING - The appliance is being deployed. */
  CREATING = 2,
  UNRECOGNIZED = -1,
}

export function nsx_StateFromJSON(object: any): Nsx_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Nsx_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Nsx_State.ACTIVE;
    case 2:
    case "CREATING":
      return Nsx_State.CREATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Nsx_State.UNRECOGNIZED;
  }
}

export function nsx_StateToJSON(object: Nsx_State): string {
  switch (object) {
    case Nsx_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Nsx_State.ACTIVE:
      return "ACTIVE";
    case Nsx_State.CREATING:
      return "CREATING";
    case Nsx_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details about a vCenter Server management appliance. */
export interface Vcenter {
  /** Internal IP address of the appliance. */
  internalIp: string;
  /** Version of the appliance. */
  version: string;
  /** Output only. The state of the appliance. */
  state: Vcenter_State;
  /** Fully qualified domain name of the appliance. */
  fqdn: string;
}

/** State of the appliance */
export enum Vcenter_State {
  /** STATE_UNSPECIFIED - Unspecified appliance state. This is the default value. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The appliance is operational and can be used. */
  ACTIVE = 1,
  /** CREATING - The appliance is being deployed. */
  CREATING = 2,
  UNRECOGNIZED = -1,
}

export function vcenter_StateFromJSON(object: any): Vcenter_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Vcenter_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Vcenter_State.ACTIVE;
    case 2:
    case "CREATING":
      return Vcenter_State.CREATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Vcenter_State.UNRECOGNIZED;
  }
}

export function vcenter_StateToJSON(object: Vcenter_State): string {
  switch (object) {
    case Vcenter_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Vcenter_State.ACTIVE:
      return "ACTIVE";
    case Vcenter_State.CREATING:
      return "CREATING";
    case Vcenter_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Autoscaling settings define the rules used by VMware Engine to
 * automatically scale-out and scale-in the clusters in a private cloud.
 */
export interface AutoscalingSettings {
  /**
   * Required. The map with autoscaling policies applied to the cluster.
   * The key is the identifier of the policy.
   * It must meet the following requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC
   * 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
   *
   * Currently there map must contain only one element
   * that describes the autoscaling policy for compute nodes.
   */
  autoscalingPolicies: { [key: string]: AutoscalingSettings_AutoscalingPolicy };
  /**
   * Optional. Minimum number of nodes of any type in a cluster.
   * If not specified the default limits apply.
   */
  minClusterNodeCount: number;
  /**
   * Optional. Maximum number of nodes of any type in a cluster.
   * If not specified the default limits apply.
   */
  maxClusterNodeCount: number;
  /**
   * Optional. The minimum duration between consecutive autoscale operations.
   * It starts once addition or removal of nodes is fully completed.
   * Defaults to 30 minutes if not specified. Cool down period must be in whole
   * minutes (for example, 30, 31, 50, 180 minutes).
   */
  coolDownPeriod: Duration | undefined;
}

/**
 * Thresholds define the utilization of resources triggering
 * scale-out and scale-in operations.
 */
export interface AutoscalingSettings_Thresholds {
  /** Required. The utilization triggering the scale-out operation in percent. */
  scaleOut: number;
  /** Required. The utilization triggering the scale-in operation in percent. */
  scaleIn: number;
}

/**
 * Autoscaling policy describes the behavior of the autoscaling
 * with respect to the resource utilization.
 * The scale-out operation is initiated if the utilization
 * exceeds ANY of the respective thresholds.
 * The scale-in operation is initiated if the utilization
 * is below ALL of the respective thresholds.
 */
export interface AutoscalingSettings_AutoscalingPolicy {
  /**
   * Required. The canonical identifier of the node type to add or remove.
   * Corresponds to the `NodeType`.
   */
  nodeTypeId: string;
  /**
   * Required. Number of nodes to add to a cluster during a scale-out
   * operation. Must be divisible by 2 for stretched clusters. During a
   * scale-in operation only one node (or 2 for stretched clusters) are
   * removed in a single iteration.
   */
  scaleOutSize: number;
  /** Optional. Utilization thresholds pertaining to CPU utilization. */
  cpuThresholds:
    | AutoscalingSettings_Thresholds
    | undefined;
  /** Optional. Utilization thresholds pertaining to amount of granted memory. */
  grantedMemoryThresholds:
    | AutoscalingSettings_Thresholds
    | undefined;
  /** Optional. Utilization thresholds pertaining to amount of consumed memory. */
  consumedMemoryThresholds:
    | AutoscalingSettings_Thresholds
    | undefined;
  /**
   * Optional. Utilization thresholds pertaining to amount of consumed
   * storage.
   */
  storageThresholds: AutoscalingSettings_Thresholds | undefined;
}

export interface AutoscalingSettings_AutoscalingPoliciesEntry {
  key: string;
  value: AutoscalingSettings_AutoscalingPolicy | undefined;
}

/**
 * DNS forwarding config.
 * This config defines a list of domain to name server mappings,
 * and is attached to the private cloud for custom domain resolution.
 */
export interface DnsForwarding {
  /**
   * Output only. The resource name of this DNS profile.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/dnsForwarding`
   */
  name: string;
  /** Output only. Creation time of this resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update time of this resource. */
  updateTime:
    | Date
    | undefined;
  /** Required. List of domain mappings to configure */
  forwardingRules: DnsForwarding_ForwardingRule[];
}

/**
 * A forwarding rule is a mapping of a `domain` to `name_servers`.
 * This mapping allows VMware Engine to resolve domains for attached private
 * clouds by forwarding DNS requests for a given domain to the specified
 * nameservers.
 */
export interface DnsForwarding_ForwardingRule {
  /** Required. Domain used to resolve a `name_servers` list. */
  domain: string;
  /** Required. List of DNS servers to use for domain resolution */
  nameServers: string[];
}

/** Details of a network peering. */
export interface NetworkPeering {
  /**
   * Output only. The resource name of the network peering. NetworkPeering is a
   * global resource and location can only be global. Resource names are
   * scheme-less URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/global/networkPeerings/my-peering`
   */
  name: string;
  /** Output only. Creation time of this resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update time of this resource. */
  updateTime:
    | Date
    | undefined;
  /**
   * Required. The relative resource name of the network to peer with
   * a standard VMware Engine network. The provided network can be a
   * consumer VPC network or another standard VMware Engine network. If the
   * `peer_network_type` is VMWARE_ENGINE_NETWORK, specify the name in the form:
   * `projects/{project}/locations/global/vmwareEngineNetworks/{vmware_engine_network_id}`.
   * Otherwise specify the name in the form:
   * `projects/{project}/global/networks/{network_id}`, where
   * `{project}` can either be a project number or a project ID.
   */
  peerNetwork: string;
  /**
   * Optional. True if custom routes are exported to the peered network;
   * false otherwise. The default value is true.
   */
  exportCustomRoutes?:
    | boolean
    | undefined;
  /**
   * Optional. True if custom routes are imported from the peered network;
   * false otherwise. The default value is true.
   */
  importCustomRoutes?:
    | boolean
    | undefined;
  /**
   * Optional. True if full mesh connectivity is created and managed
   * automatically between peered networks; false otherwise. Currently this
   * field is always true because Google Compute Engine automatically creates
   * and manages subnetwork routes between two VPC networks when peering state
   * is 'ACTIVE'.
   */
  exchangeSubnetRoutes?:
    | boolean
    | undefined;
  /**
   * Optional. True if all subnet routes with a public IP address range are
   * exported; false otherwise. The default value is true. IPv4 special-use
   * ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always
   * exported to peers and are not controlled by this field.
   */
  exportCustomRoutesWithPublicIp?:
    | boolean
    | undefined;
  /**
   * Optional. True if all subnet routes with public IP address range are
   * imported; false otherwise. The default value is true. IPv4 special-use
   * ranges (https://en.wikipedia.org/wiki/IPv4#Special_addresses) are always
   * imported to peers and are not controlled by this field.
   */
  importCustomRoutesWithPublicIp?:
    | boolean
    | undefined;
  /**
   * Output only. State of the network peering. This field
   * has a value of 'ACTIVE' when there's a matching configuration in the peer
   * network. New values may be added to this enum when appropriate.
   */
  state: NetworkPeering_State;
  /**
   * Output only. Output Only. Details about the current state of the network
   * peering.
   */
  stateDetails: string;
  /**
   * Optional. Maximum transmission unit (MTU) in bytes.
   * The default value is `1500`. If a value of `0` is provided for this field,
   * VMware Engine uses the default value instead.
   */
  peerMtu: number;
  /** Required. The type of the network to peer with the VMware Engine network. */
  peerNetworkType: NetworkPeering_PeerNetworkType;
  /** Output only. System-generated unique identifier for the resource. */
  uid: string;
  /**
   * Required. The relative resource name of the VMware Engine network.
   * Specify the name in the following form:
   * `projects/{project}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
   * where `{project}` can either be a project number or a project ID.
   */
  vmwareEngineNetwork: string;
  /** Optional. User-provided description for this network peering. */
  description: string;
}

/** Possible states of a network peering. */
export enum NetworkPeering_State {
  /** STATE_UNSPECIFIED - Unspecified network peering state. This is the default value. */
  STATE_UNSPECIFIED = 0,
  /** INACTIVE - The peering is not active. */
  INACTIVE = 1,
  /** ACTIVE - The peering is active. */
  ACTIVE = 2,
  /** CREATING - The peering is being created. */
  CREATING = 3,
  /** DELETING - The peering is being deleted. */
  DELETING = 4,
  UNRECOGNIZED = -1,
}

export function networkPeering_StateFromJSON(object: any): NetworkPeering_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return NetworkPeering_State.STATE_UNSPECIFIED;
    case 1:
    case "INACTIVE":
      return NetworkPeering_State.INACTIVE;
    case 2:
    case "ACTIVE":
      return NetworkPeering_State.ACTIVE;
    case 3:
    case "CREATING":
      return NetworkPeering_State.CREATING;
    case 4:
    case "DELETING":
      return NetworkPeering_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkPeering_State.UNRECOGNIZED;
  }
}

export function networkPeering_StateToJSON(object: NetworkPeering_State): string {
  switch (object) {
    case NetworkPeering_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case NetworkPeering_State.INACTIVE:
      return "INACTIVE";
    case NetworkPeering_State.ACTIVE:
      return "ACTIVE";
    case NetworkPeering_State.CREATING:
      return "CREATING";
    case NetworkPeering_State.DELETING:
      return "DELETING";
    case NetworkPeering_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type or purpose of the network peering connection. */
export enum NetworkPeering_PeerNetworkType {
  /** PEER_NETWORK_TYPE_UNSPECIFIED - Unspecified */
  PEER_NETWORK_TYPE_UNSPECIFIED = 0,
  /**
   * STANDARD - Peering connection used for connecting to another VPC network established
   * by the same user. For example, a peering connection to another VPC
   * network in the same project or to an on-premises network.
   */
  STANDARD = 1,
  /** VMWARE_ENGINE_NETWORK - Peering connection used for connecting to another VMware Engine network. */
  VMWARE_ENGINE_NETWORK = 2,
  /**
   * PRIVATE_SERVICES_ACCESS - Peering connection used for establishing [private services
   * access](https://cloud.google.com/vpc/docs/private-services-access).
   */
  PRIVATE_SERVICES_ACCESS = 3,
  /** NETAPP_CLOUD_VOLUMES - Peering connection used for connecting to NetApp Cloud Volumes. */
  NETAPP_CLOUD_VOLUMES = 4,
  /**
   * THIRD_PARTY_SERVICE - Peering connection used for connecting to third-party services. Most
   * third-party services require manual setup of reverse peering on the VPC
   * network associated with the third-party service.
   */
  THIRD_PARTY_SERVICE = 5,
  /** DELL_POWERSCALE - Peering connection used for connecting to Dell PowerScale Filers */
  DELL_POWERSCALE = 6,
  /** GOOGLE_CLOUD_NETAPP_VOLUMES - Peering connection used for connecting to Google Cloud NetApp Volumes. */
  GOOGLE_CLOUD_NETAPP_VOLUMES = 7,
  UNRECOGNIZED = -1,
}

export function networkPeering_PeerNetworkTypeFromJSON(object: any): NetworkPeering_PeerNetworkType {
  switch (object) {
    case 0:
    case "PEER_NETWORK_TYPE_UNSPECIFIED":
      return NetworkPeering_PeerNetworkType.PEER_NETWORK_TYPE_UNSPECIFIED;
    case 1:
    case "STANDARD":
      return NetworkPeering_PeerNetworkType.STANDARD;
    case 2:
    case "VMWARE_ENGINE_NETWORK":
      return NetworkPeering_PeerNetworkType.VMWARE_ENGINE_NETWORK;
    case 3:
    case "PRIVATE_SERVICES_ACCESS":
      return NetworkPeering_PeerNetworkType.PRIVATE_SERVICES_ACCESS;
    case 4:
    case "NETAPP_CLOUD_VOLUMES":
      return NetworkPeering_PeerNetworkType.NETAPP_CLOUD_VOLUMES;
    case 5:
    case "THIRD_PARTY_SERVICE":
      return NetworkPeering_PeerNetworkType.THIRD_PARTY_SERVICE;
    case 6:
    case "DELL_POWERSCALE":
      return NetworkPeering_PeerNetworkType.DELL_POWERSCALE;
    case 7:
    case "GOOGLE_CLOUD_NETAPP_VOLUMES":
      return NetworkPeering_PeerNetworkType.GOOGLE_CLOUD_NETAPP_VOLUMES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkPeering_PeerNetworkType.UNRECOGNIZED;
  }
}

export function networkPeering_PeerNetworkTypeToJSON(object: NetworkPeering_PeerNetworkType): string {
  switch (object) {
    case NetworkPeering_PeerNetworkType.PEER_NETWORK_TYPE_UNSPECIFIED:
      return "PEER_NETWORK_TYPE_UNSPECIFIED";
    case NetworkPeering_PeerNetworkType.STANDARD:
      return "STANDARD";
    case NetworkPeering_PeerNetworkType.VMWARE_ENGINE_NETWORK:
      return "VMWARE_ENGINE_NETWORK";
    case NetworkPeering_PeerNetworkType.PRIVATE_SERVICES_ACCESS:
      return "PRIVATE_SERVICES_ACCESS";
    case NetworkPeering_PeerNetworkType.NETAPP_CLOUD_VOLUMES:
      return "NETAPP_CLOUD_VOLUMES";
    case NetworkPeering_PeerNetworkType.THIRD_PARTY_SERVICE:
      return "THIRD_PARTY_SERVICE";
    case NetworkPeering_PeerNetworkType.DELL_POWERSCALE:
      return "DELL_POWERSCALE";
    case NetworkPeering_PeerNetworkType.GOOGLE_CLOUD_NETAPP_VOLUMES:
      return "GOOGLE_CLOUD_NETAPP_VOLUMES";
    case NetworkPeering_PeerNetworkType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Exchanged network peering route. */
export interface PeeringRoute {
  /** Output only. Destination range of the peering route in CIDR notation. */
  destRange: string;
  /** Output only. Type of the route in the peer VPC network. */
  type: PeeringRoute_Type;
  /**
   * Output only. Region containing the next hop of the peering route. This
   * field only applies to dynamic routes in the peer VPC network.
   */
  nextHopRegion: string;
  /** Output only. The priority of the peering route. */
  priority: Long;
  /**
   * Output only. True if the peering route has been imported from a peered
   * VPC network; false otherwise. The import happens if the field
   * `NetworkPeering.importCustomRoutes` is true for this network,
   * `NetworkPeering.exportCustomRoutes` is true for the peer VPC network, and
   * the import does not result in a route conflict.
   */
  imported: boolean;
  /**
   * Output only. Direction of the routes exchanged with the peer network, from
   * the VMware Engine network perspective:
   *
   * * Routes of direction `INCOMING` are imported from the peer network.
   * * Routes of direction `OUTGOING` are exported from the intranet VPC network
   * of the VMware Engine network.
   */
  direction: PeeringRoute_Direction;
}

/** The type of the peering route. */
export enum PeeringRoute_Type {
  /** TYPE_UNSPECIFIED - Unspecified peering route type. This is the default value. */
  TYPE_UNSPECIFIED = 0,
  /** DYNAMIC_PEERING_ROUTE - Dynamic routes in the peer network. */
  DYNAMIC_PEERING_ROUTE = 1,
  /** STATIC_PEERING_ROUTE - Static routes in the peer network. */
  STATIC_PEERING_ROUTE = 2,
  /**
   * SUBNET_PEERING_ROUTE - Created, updated, and removed automatically by Google Cloud when subnets
   * are created, modified, or deleted in the peer network.
   */
  SUBNET_PEERING_ROUTE = 3,
  UNRECOGNIZED = -1,
}

export function peeringRoute_TypeFromJSON(object: any): PeeringRoute_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return PeeringRoute_Type.TYPE_UNSPECIFIED;
    case 1:
    case "DYNAMIC_PEERING_ROUTE":
      return PeeringRoute_Type.DYNAMIC_PEERING_ROUTE;
    case 2:
    case "STATIC_PEERING_ROUTE":
      return PeeringRoute_Type.STATIC_PEERING_ROUTE;
    case 3:
    case "SUBNET_PEERING_ROUTE":
      return PeeringRoute_Type.SUBNET_PEERING_ROUTE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PeeringRoute_Type.UNRECOGNIZED;
  }
}

export function peeringRoute_TypeToJSON(object: PeeringRoute_Type): string {
  switch (object) {
    case PeeringRoute_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case PeeringRoute_Type.DYNAMIC_PEERING_ROUTE:
      return "DYNAMIC_PEERING_ROUTE";
    case PeeringRoute_Type.STATIC_PEERING_ROUTE:
      return "STATIC_PEERING_ROUTE";
    case PeeringRoute_Type.SUBNET_PEERING_ROUTE:
      return "SUBNET_PEERING_ROUTE";
    case PeeringRoute_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The direction of the exchanged routes. */
export enum PeeringRoute_Direction {
  /** DIRECTION_UNSPECIFIED - Unspecified exchanged routes direction. This is default. */
  DIRECTION_UNSPECIFIED = 0,
  /** INCOMING - Routes imported from the peer network. */
  INCOMING = 1,
  /** OUTGOING - Routes exported to the peer network. */
  OUTGOING = 2,
  UNRECOGNIZED = -1,
}

export function peeringRoute_DirectionFromJSON(object: any): PeeringRoute_Direction {
  switch (object) {
    case 0:
    case "DIRECTION_UNSPECIFIED":
      return PeeringRoute_Direction.DIRECTION_UNSPECIFIED;
    case 1:
    case "INCOMING":
      return PeeringRoute_Direction.INCOMING;
    case 2:
    case "OUTGOING":
      return PeeringRoute_Direction.OUTGOING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PeeringRoute_Direction.UNRECOGNIZED;
  }
}

export function peeringRoute_DirectionToJSON(object: PeeringRoute_Direction): string {
  switch (object) {
    case PeeringRoute_Direction.DIRECTION_UNSPECIFIED:
      return "DIRECTION_UNSPECIFIED";
    case PeeringRoute_Direction.INCOMING:
      return "INCOMING";
    case PeeringRoute_Direction.OUTGOING:
      return "OUTGOING";
    case PeeringRoute_Direction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents a network policy resource. Network policies are regional
 * resources. You can use a network policy to enable or disable internet access
 * and external IP access. Network policies are associated with a VMware Engine
 * network, which might span across regions. For a given region, a network
 * policy applies to all private clouds in the VMware Engine network associated
 * with the policy.
 */
export interface NetworkPolicy {
  /**
   * Output only. The resource name of this network policy.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/networkPolicies/my-network-policy`
   */
  name: string;
  /** Output only. Creation time of this resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update time of this resource. */
  updateTime:
    | Date
    | undefined;
  /** Network service that allows VMware workloads to access the internet. */
  internetAccess:
    | NetworkPolicy_NetworkService
    | undefined;
  /**
   * Network service that allows External IP addresses to be assigned to VMware
   * workloads. This service can only be enabled when `internet_access` is also
   * enabled.
   */
  externalIp:
    | NetworkPolicy_NetworkService
    | undefined;
  /**
   * Required. IP address range in CIDR notation used to create internet access
   * and external IP access. An RFC 1918 CIDR block, with a "/26" prefix, is
   * required. The range cannot overlap with any prefixes either in the consumer
   * VPC network or in use by the private clouds attached to that VPC network.
   */
  edgeServicesCidr: string;
  /** Output only. System-generated unique identifier for the resource. */
  uid: string;
  /**
   * Optional. The relative resource name of the VMware Engine network.
   * Specify the name in the following form:
   * `projects/{project}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
   * where `{project}` can either be a project number or a project ID.
   */
  vmwareEngineNetwork: string;
  /** Optional. User-provided description for this network policy. */
  description: string;
  /**
   * Output only. The canonical name of the VMware Engine network in the form:
   * `projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
   */
  vmwareEngineNetworkCanonical: string;
}

/**
 * Represents a network service that is managed by a `NetworkPolicy` resource.
 * A network service provides a way to control an aspect of external access to
 * VMware workloads. For example, whether the VMware workloads in the
 * private clouds governed by a network policy can access or be accessed from
 * the internet.
 */
export interface NetworkPolicy_NetworkService {
  /** True if the service is enabled; false otherwise. */
  enabled: boolean;
  /**
   * Output only. State of the service. New values may be added to this enum
   * when appropriate.
   */
  state: NetworkPolicy_NetworkService_State;
}

/**
 * Enum State defines possible states of a network policy controlled
 * service.
 */
export enum NetworkPolicy_NetworkService_State {
  /** STATE_UNSPECIFIED - Unspecified service state. This is the default value. */
  STATE_UNSPECIFIED = 0,
  /** UNPROVISIONED - Service is not provisioned. */
  UNPROVISIONED = 1,
  /** RECONCILING - Service is in the process of being provisioned/deprovisioned. */
  RECONCILING = 2,
  /** ACTIVE - Service is active. */
  ACTIVE = 3,
  UNRECOGNIZED = -1,
}

export function networkPolicy_NetworkService_StateFromJSON(object: any): NetworkPolicy_NetworkService_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return NetworkPolicy_NetworkService_State.STATE_UNSPECIFIED;
    case 1:
    case "UNPROVISIONED":
      return NetworkPolicy_NetworkService_State.UNPROVISIONED;
    case 2:
    case "RECONCILING":
      return NetworkPolicy_NetworkService_State.RECONCILING;
    case 3:
    case "ACTIVE":
      return NetworkPolicy_NetworkService_State.ACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkPolicy_NetworkService_State.UNRECOGNIZED;
  }
}

export function networkPolicy_NetworkService_StateToJSON(object: NetworkPolicy_NetworkService_State): string {
  switch (object) {
    case NetworkPolicy_NetworkService_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case NetworkPolicy_NetworkService_State.UNPROVISIONED:
      return "UNPROVISIONED";
    case NetworkPolicy_NetworkService_State.RECONCILING:
      return "RECONCILING";
    case NetworkPolicy_NetworkService_State.ACTIVE:
      return "ACTIVE";
    case NetworkPolicy_NetworkService_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents a binding between a network and the management DNS zone.
 * A management DNS zone is the Cloud DNS cross-project binding zone that
 * VMware Engine creates for each private cloud. It contains FQDNs and
 * corresponding IP addresses for the private cloud's ESXi hosts and management
 * VM appliances like vCenter and NSX Manager.
 */
export interface ManagementDnsZoneBinding {
  /**
   * Output only. The resource name of this binding.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/managementDnsZoneBindings/my-management-dns-zone-binding`
   */
  name: string;
  /** Output only. Creation time of this resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update time of this resource. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The state of the resource. */
  state: ManagementDnsZoneBinding_State;
  /** User-provided description for this resource. */
  description: string;
  /**
   * Network to bind is a standard consumer VPC.
   * Specify the name in the following form for consumer
   * VPC network: `projects/{project}/global/networks/{network_id}`.
   * `{project}` can either be a project number or a project ID.
   */
  vpcNetwork?:
    | string
    | undefined;
  /**
   * Network to bind is a VMware Engine network.
   * Specify the name in the following form for VMware engine network:
   * `projects/{project}/locations/global/vmwareEngineNetworks/{vmware_engine_network_id}`.
   * `{project}` can either be a project number or a project ID.
   */
  vmwareEngineNetwork?:
    | string
    | undefined;
  /** Output only. System-generated unique identifier for the resource. */
  uid: string;
}

/**
 * Enum State defines possible states of binding between the consumer VPC
 * network and the management DNS zone.
 */
export enum ManagementDnsZoneBinding_State {
  /** STATE_UNSPECIFIED - The default value. This value should never be used. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The binding is ready. */
  ACTIVE = 1,
  /** CREATING - The binding is being created. */
  CREATING = 2,
  /** UPDATING - The binding is being updated. */
  UPDATING = 3,
  /** DELETING - The binding is being deleted. */
  DELETING = 4,
  /** FAILED - The binding has failed. */
  FAILED = 5,
  UNRECOGNIZED = -1,
}

export function managementDnsZoneBinding_StateFromJSON(object: any): ManagementDnsZoneBinding_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ManagementDnsZoneBinding_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return ManagementDnsZoneBinding_State.ACTIVE;
    case 2:
    case "CREATING":
      return ManagementDnsZoneBinding_State.CREATING;
    case 3:
    case "UPDATING":
      return ManagementDnsZoneBinding_State.UPDATING;
    case 4:
    case "DELETING":
      return ManagementDnsZoneBinding_State.DELETING;
    case 5:
    case "FAILED":
      return ManagementDnsZoneBinding_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ManagementDnsZoneBinding_State.UNRECOGNIZED;
  }
}

export function managementDnsZoneBinding_StateToJSON(object: ManagementDnsZoneBinding_State): string {
  switch (object) {
    case ManagementDnsZoneBinding_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ManagementDnsZoneBinding_State.ACTIVE:
      return "ACTIVE";
    case ManagementDnsZoneBinding_State.CREATING:
      return "CREATING";
    case ManagementDnsZoneBinding_State.UPDATING:
      return "UPDATING";
    case ManagementDnsZoneBinding_State.DELETING:
      return "DELETING";
    case ManagementDnsZoneBinding_State.FAILED:
      return "FAILED";
    case ManagementDnsZoneBinding_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * VMware Engine network resource that provides connectivity for VMware Engine
 * private clouds.
 */
export interface VmwareEngineNetwork {
  /**
   * Output only. The resource name of the VMware Engine network.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/global/vmwareEngineNetworks/my-network`
   */
  name: string;
  /** Output only. Creation time of this resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update time of this resource. */
  updateTime:
    | Date
    | undefined;
  /** User-provided description for this VMware Engine network. */
  description: string;
  /**
   * Output only. VMware Engine service VPC networks that provide connectivity
   * from a private cloud to customer projects, the internet, and other Google
   * Cloud services.
   */
  vpcNetworks: VmwareEngineNetwork_VpcNetwork[];
  /** Output only. State of the VMware Engine network. */
  state: VmwareEngineNetwork_State;
  /** Required. VMware Engine network type. */
  type: VmwareEngineNetwork_Type;
  /** Output only. System-generated unique identifier for the resource. */
  uid: string;
  /**
   * Checksum that may be sent on update and delete requests to ensure that the
   * user-provided value is up to date before the server processes a request.
   * The server computes checksums based on the value of other fields in the
   * request.
   */
  etag: string;
}

/** Enum State defines possible states of VMware Engine network. */
export enum VmwareEngineNetwork_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The VMware Engine network is being created. */
  CREATING = 1,
  /** ACTIVE - The VMware Engine network is ready. */
  ACTIVE = 2,
  /** UPDATING - The VMware Engine network is being updated. */
  UPDATING = 3,
  /** DELETING - The VMware Engine network is being deleted. */
  DELETING = 4,
  UNRECOGNIZED = -1,
}

export function vmwareEngineNetwork_StateFromJSON(object: any): VmwareEngineNetwork_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return VmwareEngineNetwork_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return VmwareEngineNetwork_State.CREATING;
    case 2:
    case "ACTIVE":
      return VmwareEngineNetwork_State.ACTIVE;
    case 3:
    case "UPDATING":
      return VmwareEngineNetwork_State.UPDATING;
    case 4:
    case "DELETING":
      return VmwareEngineNetwork_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VmwareEngineNetwork_State.UNRECOGNIZED;
  }
}

export function vmwareEngineNetwork_StateToJSON(object: VmwareEngineNetwork_State): string {
  switch (object) {
    case VmwareEngineNetwork_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case VmwareEngineNetwork_State.CREATING:
      return "CREATING";
    case VmwareEngineNetwork_State.ACTIVE:
      return "ACTIVE";
    case VmwareEngineNetwork_State.UPDATING:
      return "UPDATING";
    case VmwareEngineNetwork_State.DELETING:
      return "DELETING";
    case VmwareEngineNetwork_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enum Type defines possible types of VMware Engine network. */
export enum VmwareEngineNetwork_Type {
  /** TYPE_UNSPECIFIED - The default value. This value should never be used. */
  TYPE_UNSPECIFIED = 0,
  /**
   * LEGACY - Network type used by private clouds created in projects without a network
   * of type `STANDARD`. This network type is no longer used for new VMware
   * Engine private cloud deployments.
   */
  LEGACY = 1,
  /** STANDARD - Standard network type used for private cloud connectivity. */
  STANDARD = 2,
  UNRECOGNIZED = -1,
}

export function vmwareEngineNetwork_TypeFromJSON(object: any): VmwareEngineNetwork_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return VmwareEngineNetwork_Type.TYPE_UNSPECIFIED;
    case 1:
    case "LEGACY":
      return VmwareEngineNetwork_Type.LEGACY;
    case 2:
    case "STANDARD":
      return VmwareEngineNetwork_Type.STANDARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VmwareEngineNetwork_Type.UNRECOGNIZED;
  }
}

export function vmwareEngineNetwork_TypeToJSON(object: VmwareEngineNetwork_Type): string {
  switch (object) {
    case VmwareEngineNetwork_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case VmwareEngineNetwork_Type.LEGACY:
      return "LEGACY";
    case VmwareEngineNetwork_Type.STANDARD:
      return "STANDARD";
    case VmwareEngineNetwork_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents a VMware Engine VPC network that is managed by a
 * VMware Engine network resource.
 */
export interface VmwareEngineNetwork_VpcNetwork {
  /**
   * Output only. Type of VPC network (INTRANET, INTERNET, or
   * GOOGLE_CLOUD)
   */
  type: VmwareEngineNetwork_VpcNetwork_Type;
  /**
   * Output only. The relative resource name of the service VPC network this
   * VMware Engine network is attached to. For example:
   * `projects/123123/global/networks/my-network`
   */
  network: string;
}

/**
 * Enum Type defines possible types of a VMware Engine network controlled
 * service.
 */
export enum VmwareEngineNetwork_VpcNetwork_Type {
  /** TYPE_UNSPECIFIED - The default value. This value should never be used. */
  TYPE_UNSPECIFIED = 0,
  /**
   * INTRANET - VPC network that will be peered with a consumer VPC network or the
   * intranet VPC of another VMware Engine network. Access a private cloud
   * through Compute Engine VMs on a peered VPC network or an on-premises
   * resource connected to a peered consumer VPC network.
   */
  INTRANET = 1,
  /** INTERNET - VPC network used for internet access to and from a private cloud. */
  INTERNET = 2,
  /**
   * GOOGLE_CLOUD - VPC network used for access to Google Cloud services like
   * Cloud Storage.
   */
  GOOGLE_CLOUD = 3,
  UNRECOGNIZED = -1,
}

export function vmwareEngineNetwork_VpcNetwork_TypeFromJSON(object: any): VmwareEngineNetwork_VpcNetwork_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return VmwareEngineNetwork_VpcNetwork_Type.TYPE_UNSPECIFIED;
    case 1:
    case "INTRANET":
      return VmwareEngineNetwork_VpcNetwork_Type.INTRANET;
    case 2:
    case "INTERNET":
      return VmwareEngineNetwork_VpcNetwork_Type.INTERNET;
    case 3:
    case "GOOGLE_CLOUD":
      return VmwareEngineNetwork_VpcNetwork_Type.GOOGLE_CLOUD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VmwareEngineNetwork_VpcNetwork_Type.UNRECOGNIZED;
  }
}

export function vmwareEngineNetwork_VpcNetwork_TypeToJSON(object: VmwareEngineNetwork_VpcNetwork_Type): string {
  switch (object) {
    case VmwareEngineNetwork_VpcNetwork_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case VmwareEngineNetwork_VpcNetwork_Type.INTRANET:
      return "INTRANET";
    case VmwareEngineNetwork_VpcNetwork_Type.INTERNET:
      return "INTERNET";
    case VmwareEngineNetwork_VpcNetwork_Type.GOOGLE_CLOUD:
      return "GOOGLE_CLOUD";
    case VmwareEngineNetwork_VpcNetwork_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Private connection resource that provides connectivity for VMware Engine
 * private clouds.
 */
export interface PrivateConnection {
  /**
   * Output only. The resource name of the private connection.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/privateConnections/my-connection`
   */
  name: string;
  /** Output only. Creation time of this resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update time of this resource. */
  updateTime:
    | Date
    | undefined;
  /** Optional. User-provided description for this private connection. */
  description: string;
  /** Output only. State of the private connection. */
  state: PrivateConnection_State;
  /**
   * Required. The relative resource name of Legacy VMware Engine network.
   * Specify the name in the following form:
   * `projects/{project}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
   * where `{project}`, `{location}` will be same as specified in private
   * connection resource name and `{vmware_engine_network_id}` will be in the
   * form of `{location}`-default e.g.
   * projects/project/locations/us-central1/vmwareEngineNetworks/us-central1-default.
   */
  vmwareEngineNetwork: string;
  /**
   * Output only. The canonical name of the VMware Engine network in the form:
   * `projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmware_engine_network_id}`
   */
  vmwareEngineNetworkCanonical: string;
  /** Required. Private connection type. */
  type: PrivateConnection_Type;
  /**
   * Output only. VPC network peering id between given network VPC and
   * VMwareEngineNetwork.
   */
  peeringId: string;
  /**
   * Optional. Routing Mode.
   * Default value is set to GLOBAL.
   * For type = PRIVATE_SERVICE_ACCESS, this field can be set to GLOBAL or
   * REGIONAL, for other types only GLOBAL is supported.
   */
  routingMode: PrivateConnection_RoutingMode;
  /** Output only. System-generated unique identifier for the resource. */
  uid: string;
  /**
   * Required. Service network to create private connection.
   * Specify the name in the following form:
   * `projects/{project}/global/networks/{network_id}`
   * For type = PRIVATE_SERVICE_ACCESS, this field represents servicenetworking
   * VPC, e.g. projects/project-tp/global/networks/servicenetworking.
   * For type = NETAPP_CLOUD_VOLUME, this field represents NetApp service VPC,
   * e.g. projects/project-tp/global/networks/netapp-tenant-vpc.
   * For type = DELL_POWERSCALE, this field represent Dell service VPC, e.g.
   * projects/project-tp/global/networks/dell-tenant-vpc.
   * For type= THIRD_PARTY_SERVICE, this field could represent a consumer VPC or
   * any other producer VPC to which the VMware Engine Network needs to be
   * connected, e.g. projects/project/global/networks/vpc.
   */
  serviceNetwork: string;
  /**
   * Output only. Peering state between service network and VMware Engine
   * network.
   */
  peeringState: PrivateConnection_PeeringState;
}

/** Enum State defines possible states of private connection. */
export enum PrivateConnection_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The private connection is being created. */
  CREATING = 1,
  /** ACTIVE - The private connection is ready. */
  ACTIVE = 2,
  /** UPDATING - The private connection is being updated. */
  UPDATING = 3,
  /** DELETING - The private connection is being deleted. */
  DELETING = 4,
  /**
   * UNPROVISIONED - The private connection is not provisioned, since no private cloud is
   * present for which this private connection is needed.
   */
  UNPROVISIONED = 5,
  /** FAILED - The private connection is in failed state. */
  FAILED = 6,
  UNRECOGNIZED = -1,
}

export function privateConnection_StateFromJSON(object: any): PrivateConnection_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return PrivateConnection_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return PrivateConnection_State.CREATING;
    case 2:
    case "ACTIVE":
      return PrivateConnection_State.ACTIVE;
    case 3:
    case "UPDATING":
      return PrivateConnection_State.UPDATING;
    case 4:
    case "DELETING":
      return PrivateConnection_State.DELETING;
    case 5:
    case "UNPROVISIONED":
      return PrivateConnection_State.UNPROVISIONED;
    case 6:
    case "FAILED":
      return PrivateConnection_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PrivateConnection_State.UNRECOGNIZED;
  }
}

export function privateConnection_StateToJSON(object: PrivateConnection_State): string {
  switch (object) {
    case PrivateConnection_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case PrivateConnection_State.CREATING:
      return "CREATING";
    case PrivateConnection_State.ACTIVE:
      return "ACTIVE";
    case PrivateConnection_State.UPDATING:
      return "UPDATING";
    case PrivateConnection_State.DELETING:
      return "DELETING";
    case PrivateConnection_State.UNPROVISIONED:
      return "UNPROVISIONED";
    case PrivateConnection_State.FAILED:
      return "FAILED";
    case PrivateConnection_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enum Type defines possible types of private connection. */
export enum PrivateConnection_Type {
  /** TYPE_UNSPECIFIED - The default value. This value should never be used. */
  TYPE_UNSPECIFIED = 0,
  /**
   * PRIVATE_SERVICE_ACCESS - Connection used for establishing [private services
   * access](https://cloud.google.com/vpc/docs/private-services-access).
   */
  PRIVATE_SERVICE_ACCESS = 1,
  /** NETAPP_CLOUD_VOLUMES - Connection used for connecting to NetApp Cloud Volumes. */
  NETAPP_CLOUD_VOLUMES = 2,
  /** DELL_POWERSCALE - Connection used for connecting to Dell PowerScale. */
  DELL_POWERSCALE = 3,
  /** THIRD_PARTY_SERVICE - Connection used for connecting to third-party services. */
  THIRD_PARTY_SERVICE = 4,
  UNRECOGNIZED = -1,
}

export function privateConnection_TypeFromJSON(object: any): PrivateConnection_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return PrivateConnection_Type.TYPE_UNSPECIFIED;
    case 1:
    case "PRIVATE_SERVICE_ACCESS":
      return PrivateConnection_Type.PRIVATE_SERVICE_ACCESS;
    case 2:
    case "NETAPP_CLOUD_VOLUMES":
      return PrivateConnection_Type.NETAPP_CLOUD_VOLUMES;
    case 3:
    case "DELL_POWERSCALE":
      return PrivateConnection_Type.DELL_POWERSCALE;
    case 4:
    case "THIRD_PARTY_SERVICE":
      return PrivateConnection_Type.THIRD_PARTY_SERVICE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PrivateConnection_Type.UNRECOGNIZED;
  }
}

export function privateConnection_TypeToJSON(object: PrivateConnection_Type): string {
  switch (object) {
    case PrivateConnection_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case PrivateConnection_Type.PRIVATE_SERVICE_ACCESS:
      return "PRIVATE_SERVICE_ACCESS";
    case PrivateConnection_Type.NETAPP_CLOUD_VOLUMES:
      return "NETAPP_CLOUD_VOLUMES";
    case PrivateConnection_Type.DELL_POWERSCALE:
      return "DELL_POWERSCALE";
    case PrivateConnection_Type.THIRD_PARTY_SERVICE:
      return "THIRD_PARTY_SERVICE";
    case PrivateConnection_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible types for RoutingMode */
export enum PrivateConnection_RoutingMode {
  /** ROUTING_MODE_UNSPECIFIED - The default value. This value should never be used. */
  ROUTING_MODE_UNSPECIFIED = 0,
  /** GLOBAL - Global Routing Mode */
  GLOBAL = 1,
  /** REGIONAL - Regional Routing Mode */
  REGIONAL = 2,
  UNRECOGNIZED = -1,
}

export function privateConnection_RoutingModeFromJSON(object: any): PrivateConnection_RoutingMode {
  switch (object) {
    case 0:
    case "ROUTING_MODE_UNSPECIFIED":
      return PrivateConnection_RoutingMode.ROUTING_MODE_UNSPECIFIED;
    case 1:
    case "GLOBAL":
      return PrivateConnection_RoutingMode.GLOBAL;
    case 2:
    case "REGIONAL":
      return PrivateConnection_RoutingMode.REGIONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PrivateConnection_RoutingMode.UNRECOGNIZED;
  }
}

export function privateConnection_RoutingModeToJSON(object: PrivateConnection_RoutingMode): string {
  switch (object) {
    case PrivateConnection_RoutingMode.ROUTING_MODE_UNSPECIFIED:
      return "ROUTING_MODE_UNSPECIFIED";
    case PrivateConnection_RoutingMode.GLOBAL:
      return "GLOBAL";
    case PrivateConnection_RoutingMode.REGIONAL:
      return "REGIONAL";
    case PrivateConnection_RoutingMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Enum PeeringState defines the possible states of peering between service
 * network and the vpc network peered to service network
 */
export enum PrivateConnection_PeeringState {
  /**
   * PEERING_STATE_UNSPECIFIED - The default value. This value is used if the peering state is omitted or
   * unknown.
   */
  PEERING_STATE_UNSPECIFIED = 0,
  /** PEERING_ACTIVE - The peering is in active state. */
  PEERING_ACTIVE = 1,
  /** PEERING_INACTIVE - The peering is in inactive state. */
  PEERING_INACTIVE = 2,
  UNRECOGNIZED = -1,
}

export function privateConnection_PeeringStateFromJSON(object: any): PrivateConnection_PeeringState {
  switch (object) {
    case 0:
    case "PEERING_STATE_UNSPECIFIED":
      return PrivateConnection_PeeringState.PEERING_STATE_UNSPECIFIED;
    case 1:
    case "PEERING_ACTIVE":
      return PrivateConnection_PeeringState.PEERING_ACTIVE;
    case 2:
    case "PEERING_INACTIVE":
      return PrivateConnection_PeeringState.PEERING_INACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PrivateConnection_PeeringState.UNRECOGNIZED;
  }
}

export function privateConnection_PeeringStateToJSON(object: PrivateConnection_PeeringState): string {
  switch (object) {
    case PrivateConnection_PeeringState.PEERING_STATE_UNSPECIFIED:
      return "PEERING_STATE_UNSPECIFIED";
    case PrivateConnection_PeeringState.PEERING_ACTIVE:
      return "PEERING_ACTIVE";
    case PrivateConnection_PeeringState.PEERING_INACTIVE:
      return "PEERING_INACTIVE";
    case PrivateConnection_PeeringState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * VmwareEngine specific metadata for the given
 * [google.cloud.location.Location][google.cloud.location.Location]. It is
 * returned as a content of the `google.cloud.location.Location.metadata` field.
 */
export interface LocationMetadata {
  /** Output only. Capabilities of this location. */
  capabilities: LocationMetadata_Capability[];
}

/** Capability of a location. */
export enum LocationMetadata_Capability {
  /**
   * CAPABILITY_UNSPECIFIED - The default value. This value is used if the capability is omitted or
   * unknown.
   */
  CAPABILITY_UNSPECIFIED = 0,
  /** STRETCHED_CLUSTERS - Stretch clusters are supported in this location. */
  STRETCHED_CLUSTERS = 1,
  UNRECOGNIZED = -1,
}

export function locationMetadata_CapabilityFromJSON(object: any): LocationMetadata_Capability {
  switch (object) {
    case 0:
    case "CAPABILITY_UNSPECIFIED":
      return LocationMetadata_Capability.CAPABILITY_UNSPECIFIED;
    case 1:
    case "STRETCHED_CLUSTERS":
      return LocationMetadata_Capability.STRETCHED_CLUSTERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LocationMetadata_Capability.UNRECOGNIZED;
  }
}

export function locationMetadata_CapabilityToJSON(object: LocationMetadata_Capability): string {
  switch (object) {
    case LocationMetadata_Capability.CAPABILITY_UNSPECIFIED:
      return "CAPABILITY_UNSPECIFIED";
    case LocationMetadata_Capability.STRETCHED_CLUSTERS:
      return "STRETCHED_CLUSTERS";
    case LocationMetadata_Capability.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * DnsBindPermission resource that contains the accounts having the consumer DNS
 * bind permission on the corresponding intranet VPC of the consumer project.
 */
export interface DnsBindPermission {
  /**
   * Required. Output only. The name of the resource which stores the
   * users/service accounts having the permission to bind to the corresponding
   * intranet VPC of the consumer project. DnsBindPermission is a global
   * resource and location can only be global. Resource names are schemeless
   * URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names. For example:
   * `projects/my-project/locations/global/dnsBindPermission`
   */
  name: string;
  /**
   * Output only. Users/Service accounts which have access for binding on the
   * intranet VPC project corresponding to the consumer project.
   */
  principals: Principal[];
}

/**
 * Users/Service accounts which have access for DNS binding on the intranet
 * VPC corresponding to the consumer project.
 */
export interface Principal {
  /** The user who needs to be granted permission. */
  user?:
    | string
    | undefined;
  /** The service account which needs to be granted the permission. */
  serviceAccount?: string | undefined;
}

function createBaseNetworkConfig(): NetworkConfig {
  return {
    managementCidr: "",
    vmwareEngineNetwork: "",
    vmwareEngineNetworkCanonical: "",
    managementIpAddressLayoutVersion: 0,
    dnsServerIp: "",
  };
}

export const NetworkConfig: MessageFns<NetworkConfig> = {
  encode(message: NetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.managementCidr !== "") {
      writer.uint32(34).string(message.managementCidr);
    }
    if (message.vmwareEngineNetwork !== "") {
      writer.uint32(42).string(message.vmwareEngineNetwork);
    }
    if (message.vmwareEngineNetworkCanonical !== "") {
      writer.uint32(50).string(message.vmwareEngineNetworkCanonical);
    }
    if (message.managementIpAddressLayoutVersion !== 0) {
      writer.uint32(64).int32(message.managementIpAddressLayoutVersion);
    }
    if (message.dnsServerIp !== "") {
      writer.uint32(74).string(message.dnsServerIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.managementCidr = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.vmwareEngineNetwork = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.vmwareEngineNetworkCanonical = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.managementIpAddressLayoutVersion = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.dnsServerIp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConfig {
    return {
      managementCidr: isSet(object.managementCidr) ? globalThis.String(object.managementCidr) : "",
      vmwareEngineNetwork: isSet(object.vmwareEngineNetwork) ? globalThis.String(object.vmwareEngineNetwork) : "",
      vmwareEngineNetworkCanonical: isSet(object.vmwareEngineNetworkCanonical)
        ? globalThis.String(object.vmwareEngineNetworkCanonical)
        : "",
      managementIpAddressLayoutVersion: isSet(object.managementIpAddressLayoutVersion)
        ? globalThis.Number(object.managementIpAddressLayoutVersion)
        : 0,
      dnsServerIp: isSet(object.dnsServerIp) ? globalThis.String(object.dnsServerIp) : "",
    };
  },

  toJSON(message: NetworkConfig): unknown {
    const obj: any = {};
    if (message.managementCidr !== "") {
      obj.managementCidr = message.managementCidr;
    }
    if (message.vmwareEngineNetwork !== "") {
      obj.vmwareEngineNetwork = message.vmwareEngineNetwork;
    }
    if (message.vmwareEngineNetworkCanonical !== "") {
      obj.vmwareEngineNetworkCanonical = message.vmwareEngineNetworkCanonical;
    }
    if (message.managementIpAddressLayoutVersion !== 0) {
      obj.managementIpAddressLayoutVersion = Math.round(message.managementIpAddressLayoutVersion);
    }
    if (message.dnsServerIp !== "") {
      obj.dnsServerIp = message.dnsServerIp;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkConfig>): NetworkConfig {
    return NetworkConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkConfig>): NetworkConfig {
    const message = createBaseNetworkConfig();
    message.managementCidr = object.managementCidr ?? "";
    message.vmwareEngineNetwork = object.vmwareEngineNetwork ?? "";
    message.vmwareEngineNetworkCanonical = object.vmwareEngineNetworkCanonical ?? "";
    message.managementIpAddressLayoutVersion = object.managementIpAddressLayoutVersion ?? 0;
    message.dnsServerIp = object.dnsServerIp ?? "";
    return message;
  },
};

function createBaseNodeTypeConfig(): NodeTypeConfig {
  return { nodeCount: 0, customCoreCount: 0 };
}

export const NodeTypeConfig: MessageFns<NodeTypeConfig> = {
  encode(message: NodeTypeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeCount !== 0) {
      writer.uint32(8).int32(message.nodeCount);
    }
    if (message.customCoreCount !== 0) {
      writer.uint32(16).int32(message.customCoreCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeTypeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeTypeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.customCoreCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeTypeConfig {
    return {
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      customCoreCount: isSet(object.customCoreCount) ? globalThis.Number(object.customCoreCount) : 0,
    };
  },

  toJSON(message: NodeTypeConfig): unknown {
    const obj: any = {};
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.customCoreCount !== 0) {
      obj.customCoreCount = Math.round(message.customCoreCount);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeTypeConfig>): NodeTypeConfig {
    return NodeTypeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeTypeConfig>): NodeTypeConfig {
    const message = createBaseNodeTypeConfig();
    message.nodeCount = object.nodeCount ?? 0;
    message.customCoreCount = object.customCoreCount ?? 0;
    return message;
  },
};

function createBaseStretchedClusterConfig(): StretchedClusterConfig {
  return { preferredLocation: "", secondaryLocation: "" };
}

export const StretchedClusterConfig: MessageFns<StretchedClusterConfig> = {
  encode(message: StretchedClusterConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preferredLocation !== "") {
      writer.uint32(10).string(message.preferredLocation);
    }
    if (message.secondaryLocation !== "") {
      writer.uint32(18).string(message.secondaryLocation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StretchedClusterConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStretchedClusterConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.preferredLocation = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.secondaryLocation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StretchedClusterConfig {
    return {
      preferredLocation: isSet(object.preferredLocation) ? globalThis.String(object.preferredLocation) : "",
      secondaryLocation: isSet(object.secondaryLocation) ? globalThis.String(object.secondaryLocation) : "",
    };
  },

  toJSON(message: StretchedClusterConfig): unknown {
    const obj: any = {};
    if (message.preferredLocation !== "") {
      obj.preferredLocation = message.preferredLocation;
    }
    if (message.secondaryLocation !== "") {
      obj.secondaryLocation = message.secondaryLocation;
    }
    return obj;
  },

  create(base?: DeepPartial<StretchedClusterConfig>): StretchedClusterConfig {
    return StretchedClusterConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StretchedClusterConfig>): StretchedClusterConfig {
    const message = createBaseStretchedClusterConfig();
    message.preferredLocation = object.preferredLocation ?? "";
    message.secondaryLocation = object.secondaryLocation ?? "";
    return message;
  },
};

function createBasePrivateCloud(): PrivateCloud {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    expireTime: undefined,
    state: 0,
    networkConfig: undefined,
    managementCluster: undefined,
    description: "",
    hcx: undefined,
    nsx: undefined,
    vcenter: undefined,
    uid: "",
    type: 0,
  };
}

export const PrivateCloud: MessageFns<PrivateCloud> = {
  encode(message: PrivateCloud, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(34).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(42).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.networkConfig !== undefined) {
      NetworkConfig.encode(message.networkConfig, writer.uint32(74).fork()).join();
    }
    if (message.managementCluster !== undefined) {
      PrivateCloud_ManagementCluster.encode(message.managementCluster, writer.uint32(82).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    if (message.hcx !== undefined) {
      Hcx.encode(message.hcx, writer.uint32(138).fork()).join();
    }
    if (message.nsx !== undefined) {
      Nsx.encode(message.nsx, writer.uint32(146).fork()).join();
    }
    if (message.vcenter !== undefined) {
      Vcenter.encode(message.vcenter, writer.uint32(154).fork()).join();
    }
    if (message.uid !== "") {
      writer.uint32(162).string(message.uid);
    }
    if (message.type !== 0) {
      writer.uint32(176).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateCloud {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateCloud();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.networkConfig = NetworkConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.managementCluster = PrivateCloud_ManagementCluster.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.hcx = Hcx.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.nsx = Nsx.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.vcenter = Vcenter.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateCloud {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      state: isSet(object.state) ? privateCloud_StateFromJSON(object.state) : 0,
      networkConfig: isSet(object.networkConfig) ? NetworkConfig.fromJSON(object.networkConfig) : undefined,
      managementCluster: isSet(object.managementCluster)
        ? PrivateCloud_ManagementCluster.fromJSON(object.managementCluster)
        : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      hcx: isSet(object.hcx) ? Hcx.fromJSON(object.hcx) : undefined,
      nsx: isSet(object.nsx) ? Nsx.fromJSON(object.nsx) : undefined,
      vcenter: isSet(object.vcenter) ? Vcenter.fromJSON(object.vcenter) : undefined,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      type: isSet(object.type) ? privateCloud_TypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: PrivateCloud): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = privateCloud_StateToJSON(message.state);
    }
    if (message.networkConfig !== undefined) {
      obj.networkConfig = NetworkConfig.toJSON(message.networkConfig);
    }
    if (message.managementCluster !== undefined) {
      obj.managementCluster = PrivateCloud_ManagementCluster.toJSON(message.managementCluster);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.hcx !== undefined) {
      obj.hcx = Hcx.toJSON(message.hcx);
    }
    if (message.nsx !== undefined) {
      obj.nsx = Nsx.toJSON(message.nsx);
    }
    if (message.vcenter !== undefined) {
      obj.vcenter = Vcenter.toJSON(message.vcenter);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.type !== 0) {
      obj.type = privateCloud_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateCloud>): PrivateCloud {
    return PrivateCloud.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateCloud>): PrivateCloud {
    const message = createBasePrivateCloud();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.state = object.state ?? 0;
    message.networkConfig = (object.networkConfig !== undefined && object.networkConfig !== null)
      ? NetworkConfig.fromPartial(object.networkConfig)
      : undefined;
    message.managementCluster = (object.managementCluster !== undefined && object.managementCluster !== null)
      ? PrivateCloud_ManagementCluster.fromPartial(object.managementCluster)
      : undefined;
    message.description = object.description ?? "";
    message.hcx = (object.hcx !== undefined && object.hcx !== null) ? Hcx.fromPartial(object.hcx) : undefined;
    message.nsx = (object.nsx !== undefined && object.nsx !== null) ? Nsx.fromPartial(object.nsx) : undefined;
    message.vcenter = (object.vcenter !== undefined && object.vcenter !== null)
      ? Vcenter.fromPartial(object.vcenter)
      : undefined;
    message.uid = object.uid ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBasePrivateCloud_ManagementCluster(): PrivateCloud_ManagementCluster {
  return { clusterId: "", nodeTypeConfigs: {}, stretchedClusterConfig: undefined };
}

export const PrivateCloud_ManagementCluster: MessageFns<PrivateCloud_ManagementCluster> = {
  encode(message: PrivateCloud_ManagementCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusterId !== "") {
      writer.uint32(10).string(message.clusterId);
    }
    Object.entries(message.nodeTypeConfigs).forEach(([key, value]) => {
      PrivateCloud_ManagementCluster_NodeTypeConfigsEntry.encode({ key: key as any, value }, writer.uint32(58).fork())
        .join();
    });
    if (message.stretchedClusterConfig !== undefined) {
      StretchedClusterConfig.encode(message.stretchedClusterConfig, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateCloud_ManagementCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateCloud_ManagementCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = PrivateCloud_ManagementCluster_NodeTypeConfigsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.nodeTypeConfigs[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.stretchedClusterConfig = StretchedClusterConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateCloud_ManagementCluster {
    return {
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      nodeTypeConfigs: isObject(object.nodeTypeConfigs)
        ? Object.entries(object.nodeTypeConfigs).reduce<{ [key: string]: NodeTypeConfig }>((acc, [key, value]) => {
          acc[key] = NodeTypeConfig.fromJSON(value);
          return acc;
        }, {})
        : {},
      stretchedClusterConfig: isSet(object.stretchedClusterConfig)
        ? StretchedClusterConfig.fromJSON(object.stretchedClusterConfig)
        : undefined,
    };
  },

  toJSON(message: PrivateCloud_ManagementCluster): unknown {
    const obj: any = {};
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.nodeTypeConfigs) {
      const entries = Object.entries(message.nodeTypeConfigs);
      if (entries.length > 0) {
        obj.nodeTypeConfigs = {};
        entries.forEach(([k, v]) => {
          obj.nodeTypeConfigs[k] = NodeTypeConfig.toJSON(v);
        });
      }
    }
    if (message.stretchedClusterConfig !== undefined) {
      obj.stretchedClusterConfig = StretchedClusterConfig.toJSON(message.stretchedClusterConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateCloud_ManagementCluster>): PrivateCloud_ManagementCluster {
    return PrivateCloud_ManagementCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateCloud_ManagementCluster>): PrivateCloud_ManagementCluster {
    const message = createBasePrivateCloud_ManagementCluster();
    message.clusterId = object.clusterId ?? "";
    message.nodeTypeConfigs = Object.entries(object.nodeTypeConfigs ?? {}).reduce<{ [key: string]: NodeTypeConfig }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = NodeTypeConfig.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.stretchedClusterConfig =
      (object.stretchedClusterConfig !== undefined && object.stretchedClusterConfig !== null)
        ? StretchedClusterConfig.fromPartial(object.stretchedClusterConfig)
        : undefined;
    return message;
  },
};

function createBasePrivateCloud_ManagementCluster_NodeTypeConfigsEntry(): PrivateCloud_ManagementCluster_NodeTypeConfigsEntry {
  return { key: "", value: undefined };
}

export const PrivateCloud_ManagementCluster_NodeTypeConfigsEntry: MessageFns<
  PrivateCloud_ManagementCluster_NodeTypeConfigsEntry
> = {
  encode(
    message: PrivateCloud_ManagementCluster_NodeTypeConfigsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      NodeTypeConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateCloud_ManagementCluster_NodeTypeConfigsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateCloud_ManagementCluster_NodeTypeConfigsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = NodeTypeConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateCloud_ManagementCluster_NodeTypeConfigsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? NodeTypeConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PrivateCloud_ManagementCluster_NodeTypeConfigsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = NodeTypeConfig.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<PrivateCloud_ManagementCluster_NodeTypeConfigsEntry>,
  ): PrivateCloud_ManagementCluster_NodeTypeConfigsEntry {
    return PrivateCloud_ManagementCluster_NodeTypeConfigsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PrivateCloud_ManagementCluster_NodeTypeConfigsEntry>,
  ): PrivateCloud_ManagementCluster_NodeTypeConfigsEntry {
    const message = createBasePrivateCloud_ManagementCluster_NodeTypeConfigsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? NodeTypeConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCluster(): Cluster {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    state: 0,
    management: false,
    autoscalingSettings: undefined,
    uid: "",
    nodeTypeConfigs: {},
    stretchedClusterConfig: undefined,
  };
}

export const Cluster: MessageFns<Cluster> = {
  encode(message: Cluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.management !== false) {
      writer.uint32(56).bool(message.management);
    }
    if (message.autoscalingSettings !== undefined) {
      AutoscalingSettings.encode(message.autoscalingSettings, writer.uint32(146).fork()).join();
    }
    if (message.uid !== "") {
      writer.uint32(114).string(message.uid);
    }
    Object.entries(message.nodeTypeConfigs).forEach(([key, value]) => {
      Cluster_NodeTypeConfigsEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    if (message.stretchedClusterConfig !== undefined) {
      StretchedClusterConfig.encode(message.stretchedClusterConfig, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.management = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.autoscalingSettings = AutoscalingSettings.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          const entry16 = Cluster_NodeTypeConfigsEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.nodeTypeConfigs[entry16.key] = entry16.value;
          }
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.stretchedClusterConfig = StretchedClusterConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? cluster_StateFromJSON(object.state) : 0,
      management: isSet(object.management) ? globalThis.Boolean(object.management) : false,
      autoscalingSettings: isSet(object.autoscalingSettings)
        ? AutoscalingSettings.fromJSON(object.autoscalingSettings)
        : undefined,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      nodeTypeConfigs: isObject(object.nodeTypeConfigs)
        ? Object.entries(object.nodeTypeConfigs).reduce<{ [key: string]: NodeTypeConfig }>((acc, [key, value]) => {
          acc[key] = NodeTypeConfig.fromJSON(value);
          return acc;
        }, {})
        : {},
      stretchedClusterConfig: isSet(object.stretchedClusterConfig)
        ? StretchedClusterConfig.fromJSON(object.stretchedClusterConfig)
        : undefined,
    };
  },

  toJSON(message: Cluster): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = cluster_StateToJSON(message.state);
    }
    if (message.management !== false) {
      obj.management = message.management;
    }
    if (message.autoscalingSettings !== undefined) {
      obj.autoscalingSettings = AutoscalingSettings.toJSON(message.autoscalingSettings);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.nodeTypeConfigs) {
      const entries = Object.entries(message.nodeTypeConfigs);
      if (entries.length > 0) {
        obj.nodeTypeConfigs = {};
        entries.forEach(([k, v]) => {
          obj.nodeTypeConfigs[k] = NodeTypeConfig.toJSON(v);
        });
      }
    }
    if (message.stretchedClusterConfig !== undefined) {
      obj.stretchedClusterConfig = StretchedClusterConfig.toJSON(message.stretchedClusterConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster>): Cluster {
    return Cluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster>): Cluster {
    const message = createBaseCluster();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    message.management = object.management ?? false;
    message.autoscalingSettings = (object.autoscalingSettings !== undefined && object.autoscalingSettings !== null)
      ? AutoscalingSettings.fromPartial(object.autoscalingSettings)
      : undefined;
    message.uid = object.uid ?? "";
    message.nodeTypeConfigs = Object.entries(object.nodeTypeConfigs ?? {}).reduce<{ [key: string]: NodeTypeConfig }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = NodeTypeConfig.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.stretchedClusterConfig =
      (object.stretchedClusterConfig !== undefined && object.stretchedClusterConfig !== null)
        ? StretchedClusterConfig.fromPartial(object.stretchedClusterConfig)
        : undefined;
    return message;
  },
};

function createBaseCluster_NodeTypeConfigsEntry(): Cluster_NodeTypeConfigsEntry {
  return { key: "", value: undefined };
}

export const Cluster_NodeTypeConfigsEntry: MessageFns<Cluster_NodeTypeConfigsEntry> = {
  encode(message: Cluster_NodeTypeConfigsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      NodeTypeConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cluster_NodeTypeConfigsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCluster_NodeTypeConfigsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = NodeTypeConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cluster_NodeTypeConfigsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? NodeTypeConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Cluster_NodeTypeConfigsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = NodeTypeConfig.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Cluster_NodeTypeConfigsEntry>): Cluster_NodeTypeConfigsEntry {
    return Cluster_NodeTypeConfigsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cluster_NodeTypeConfigsEntry>): Cluster_NodeTypeConfigsEntry {
    const message = createBaseCluster_NodeTypeConfigsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? NodeTypeConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseNode(): Node {
  return { name: "", fqdn: "", internalIp: "", nodeTypeId: "", version: "", customCoreCount: Long.ZERO, state: 0 };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fqdn !== "") {
      writer.uint32(18).string(message.fqdn);
    }
    if (message.internalIp !== "") {
      writer.uint32(26).string(message.internalIp);
    }
    if (message.nodeTypeId !== "") {
      writer.uint32(34).string(message.nodeTypeId);
    }
    if (message.version !== "") {
      writer.uint32(42).string(message.version);
    }
    if (!message.customCoreCount.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.customCoreCount.toString());
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fqdn = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodeTypeId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.customCoreCount = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fqdn: isSet(object.fqdn) ? globalThis.String(object.fqdn) : "",
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      nodeTypeId: isSet(object.nodeTypeId) ? globalThis.String(object.nodeTypeId) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      customCoreCount: isSet(object.customCoreCount) ? Long.fromValue(object.customCoreCount) : Long.ZERO,
      state: isSet(object.state) ? node_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fqdn !== "") {
      obj.fqdn = message.fqdn;
    }
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.nodeTypeId !== "") {
      obj.nodeTypeId = message.nodeTypeId;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (!message.customCoreCount.equals(Long.ZERO)) {
      obj.customCoreCount = (message.customCoreCount || Long.ZERO).toString();
    }
    if (message.state !== 0) {
      obj.state = node_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<Node>): Node {
    return Node.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node>): Node {
    const message = createBaseNode();
    message.name = object.name ?? "";
    message.fqdn = object.fqdn ?? "";
    message.internalIp = object.internalIp ?? "";
    message.nodeTypeId = object.nodeTypeId ?? "";
    message.version = object.version ?? "";
    message.customCoreCount = (object.customCoreCount !== undefined && object.customCoreCount !== null)
      ? Long.fromValue(object.customCoreCount)
      : Long.ZERO;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseExternalAddress(): ExternalAddress {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    internalIp: "",
    externalIp: "",
    state: 0,
    uid: "",
    description: "",
  };
}

export const ExternalAddress: MessageFns<ExternalAddress> = {
  encode(message: ExternalAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.internalIp !== "") {
      writer.uint32(50).string(message.internalIp);
    }
    if (message.externalIp !== "") {
      writer.uint32(58).string(message.externalIp);
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.uid !== "") {
      writer.uint32(74).string(message.uid);
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalIp = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalAddress {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      externalIp: isSet(object.externalIp) ? globalThis.String(object.externalIp) : "",
      state: isSet(object.state) ? externalAddress_StateFromJSON(object.state) : 0,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ExternalAddress): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.externalIp !== "") {
      obj.externalIp = message.externalIp;
    }
    if (message.state !== 0) {
      obj.state = externalAddress_StateToJSON(message.state);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalAddress>): ExternalAddress {
    return ExternalAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalAddress>): ExternalAddress {
    const message = createBaseExternalAddress();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.internalIp = object.internalIp ?? "";
    message.externalIp = object.externalIp ?? "";
    message.state = object.state ?? 0;
    message.uid = object.uid ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseSubnet(): Subnet {
  return { name: "", ipCidrRange: "", gatewayIp: "", type: "", state: 0, vlanId: 0 };
}

export const Subnet: MessageFns<Subnet> = {
  encode(message: Subnet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ipCidrRange !== "") {
      writer.uint32(58).string(message.ipCidrRange);
    }
    if (message.gatewayIp !== "") {
      writer.uint32(66).string(message.gatewayIp);
    }
    if (message.type !== "") {
      writer.uint32(90).string(message.type);
    }
    if (message.state !== 0) {
      writer.uint32(104).int32(message.state);
    }
    if (message.vlanId !== 0) {
      writer.uint32(128).int32(message.vlanId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subnet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubnet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ipCidrRange = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.gatewayIp = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.type = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.vlanId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subnet {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ipCidrRange: isSet(object.ipCidrRange) ? globalThis.String(object.ipCidrRange) : "",
      gatewayIp: isSet(object.gatewayIp) ? globalThis.String(object.gatewayIp) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      state: isSet(object.state) ? subnet_StateFromJSON(object.state) : 0,
      vlanId: isSet(object.vlanId) ? globalThis.Number(object.vlanId) : 0,
    };
  },

  toJSON(message: Subnet): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ipCidrRange !== "") {
      obj.ipCidrRange = message.ipCidrRange;
    }
    if (message.gatewayIp !== "") {
      obj.gatewayIp = message.gatewayIp;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.state !== 0) {
      obj.state = subnet_StateToJSON(message.state);
    }
    if (message.vlanId !== 0) {
      obj.vlanId = Math.round(message.vlanId);
    }
    return obj;
  },

  create(base?: DeepPartial<Subnet>): Subnet {
    return Subnet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subnet>): Subnet {
    const message = createBaseSubnet();
    message.name = object.name ?? "";
    message.ipCidrRange = object.ipCidrRange ?? "";
    message.gatewayIp = object.gatewayIp ?? "";
    message.type = object.type ?? "";
    message.state = object.state ?? 0;
    message.vlanId = object.vlanId ?? 0;
    return message;
  },
};

function createBaseExternalAccessRule(): ExternalAccessRule {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    description: "",
    priority: 0,
    action: 0,
    ipProtocol: "",
    sourceIpRanges: [],
    sourcePorts: [],
    destinationIpRanges: [],
    destinationPorts: [],
    state: 0,
    uid: "",
  };
}

export const ExternalAccessRule: MessageFns<ExternalAccessRule> = {
  encode(message: ExternalAccessRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.priority !== 0) {
      writer.uint32(48).int32(message.priority);
    }
    if (message.action !== 0) {
      writer.uint32(56).int32(message.action);
    }
    if (message.ipProtocol !== "") {
      writer.uint32(66).string(message.ipProtocol);
    }
    for (const v of message.sourceIpRanges) {
      ExternalAccessRule_IpRange.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.sourcePorts) {
      writer.uint32(82).string(v!);
    }
    for (const v of message.destinationIpRanges) {
      ExternalAccessRule_IpRange.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.destinationPorts) {
      writer.uint32(98).string(v!);
    }
    if (message.state !== 0) {
      writer.uint32(104).int32(message.state);
    }
    if (message.uid !== "") {
      writer.uint32(114).string(message.uid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalAccessRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalAccessRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.priority = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ipProtocol = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.sourceIpRanges.push(ExternalAccessRule_IpRange.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.sourcePorts.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.destinationIpRanges.push(ExternalAccessRule_IpRange.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.destinationPorts.push(reader.string());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.uid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalAccessRule {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      action: isSet(object.action) ? externalAccessRule_ActionFromJSON(object.action) : 0,
      ipProtocol: isSet(object.ipProtocol) ? globalThis.String(object.ipProtocol) : "",
      sourceIpRanges: globalThis.Array.isArray(object?.sourceIpRanges)
        ? object.sourceIpRanges.map((e: any) => ExternalAccessRule_IpRange.fromJSON(e))
        : [],
      sourcePorts: globalThis.Array.isArray(object?.sourcePorts)
        ? object.sourcePorts.map((e: any) => globalThis.String(e))
        : [],
      destinationIpRanges: globalThis.Array.isArray(object?.destinationIpRanges)
        ? object.destinationIpRanges.map((e: any) => ExternalAccessRule_IpRange.fromJSON(e))
        : [],
      destinationPorts: globalThis.Array.isArray(object?.destinationPorts)
        ? object.destinationPorts.map((e: any) => globalThis.String(e))
        : [],
      state: isSet(object.state) ? externalAccessRule_StateFromJSON(object.state) : 0,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
    };
  },

  toJSON(message: ExternalAccessRule): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.action !== 0) {
      obj.action = externalAccessRule_ActionToJSON(message.action);
    }
    if (message.ipProtocol !== "") {
      obj.ipProtocol = message.ipProtocol;
    }
    if (message.sourceIpRanges?.length) {
      obj.sourceIpRanges = message.sourceIpRanges.map((e) => ExternalAccessRule_IpRange.toJSON(e));
    }
    if (message.sourcePorts?.length) {
      obj.sourcePorts = message.sourcePorts;
    }
    if (message.destinationIpRanges?.length) {
      obj.destinationIpRanges = message.destinationIpRanges.map((e) => ExternalAccessRule_IpRange.toJSON(e));
    }
    if (message.destinationPorts?.length) {
      obj.destinationPorts = message.destinationPorts;
    }
    if (message.state !== 0) {
      obj.state = externalAccessRule_StateToJSON(message.state);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalAccessRule>): ExternalAccessRule {
    return ExternalAccessRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalAccessRule>): ExternalAccessRule {
    const message = createBaseExternalAccessRule();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.description = object.description ?? "";
    message.priority = object.priority ?? 0;
    message.action = object.action ?? 0;
    message.ipProtocol = object.ipProtocol ?? "";
    message.sourceIpRanges = object.sourceIpRanges?.map((e) => ExternalAccessRule_IpRange.fromPartial(e)) || [];
    message.sourcePorts = object.sourcePorts?.map((e) => e) || [];
    message.destinationIpRanges = object.destinationIpRanges?.map((e) => ExternalAccessRule_IpRange.fromPartial(e)) ||
      [];
    message.destinationPorts = object.destinationPorts?.map((e) => e) || [];
    message.state = object.state ?? 0;
    message.uid = object.uid ?? "";
    return message;
  },
};

function createBaseExternalAccessRule_IpRange(): ExternalAccessRule_IpRange {
  return { ipAddress: undefined, ipAddressRange: undefined, externalAddress: undefined };
}

export const ExternalAccessRule_IpRange: MessageFns<ExternalAccessRule_IpRange> = {
  encode(message: ExternalAccessRule_IpRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== undefined) {
      writer.uint32(10).string(message.ipAddress);
    }
    if (message.ipAddressRange !== undefined) {
      writer.uint32(18).string(message.ipAddressRange);
    }
    if (message.externalAddress !== undefined) {
      writer.uint32(26).string(message.externalAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalAccessRule_IpRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalAccessRule_IpRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipAddressRange = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalAccessRule_IpRange {
    return {
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : undefined,
      ipAddressRange: isSet(object.ipAddressRange) ? globalThis.String(object.ipAddressRange) : undefined,
      externalAddress: isSet(object.externalAddress) ? globalThis.String(object.externalAddress) : undefined,
    };
  },

  toJSON(message: ExternalAccessRule_IpRange): unknown {
    const obj: any = {};
    if (message.ipAddress !== undefined) {
      obj.ipAddress = message.ipAddress;
    }
    if (message.ipAddressRange !== undefined) {
      obj.ipAddressRange = message.ipAddressRange;
    }
    if (message.externalAddress !== undefined) {
      obj.externalAddress = message.externalAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalAccessRule_IpRange>): ExternalAccessRule_IpRange {
    return ExternalAccessRule_IpRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalAccessRule_IpRange>): ExternalAccessRule_IpRange {
    const message = createBaseExternalAccessRule_IpRange();
    message.ipAddress = object.ipAddress ?? undefined;
    message.ipAddressRange = object.ipAddressRange ?? undefined;
    message.externalAddress = object.externalAddress ?? undefined;
    return message;
  },
};

function createBaseLoggingServer(): LoggingServer {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    hostname: "",
    port: 0,
    protocol: 0,
    sourceType: 0,
    uid: "",
  };
}

export const LoggingServer: MessageFns<LoggingServer> = {
  encode(message: LoggingServer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.hostname !== "") {
      writer.uint32(42).string(message.hostname);
    }
    if (message.port !== 0) {
      writer.uint32(56).int32(message.port);
    }
    if (message.protocol !== 0) {
      writer.uint32(48).int32(message.protocol);
    }
    if (message.sourceType !== 0) {
      writer.uint32(80).int32(message.sourceType);
    }
    if (message.uid !== "") {
      writer.uint32(66).string(message.uid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggingServer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggingServer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.protocol = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.sourceType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.uid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggingServer {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      protocol: isSet(object.protocol) ? loggingServer_ProtocolFromJSON(object.protocol) : 0,
      sourceType: isSet(object.sourceType) ? loggingServer_SourceTypeFromJSON(object.sourceType) : 0,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
    };
  },

  toJSON(message: LoggingServer): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.protocol !== 0) {
      obj.protocol = loggingServer_ProtocolToJSON(message.protocol);
    }
    if (message.sourceType !== 0) {
      obj.sourceType = loggingServer_SourceTypeToJSON(message.sourceType);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    return obj;
  },

  create(base?: DeepPartial<LoggingServer>): LoggingServer {
    return LoggingServer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LoggingServer>): LoggingServer {
    const message = createBaseLoggingServer();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.hostname = object.hostname ?? "";
    message.port = object.port ?? 0;
    message.protocol = object.protocol ?? 0;
    message.sourceType = object.sourceType ?? 0;
    message.uid = object.uid ?? "";
    return message;
  },
};

function createBaseNodeType(): NodeType {
  return {
    name: "",
    nodeTypeId: "",
    displayName: "",
    virtualCpuCount: 0,
    totalCoreCount: 0,
    memoryGb: 0,
    diskSizeGb: 0,
    availableCustomCoreCounts: [],
    kind: 0,
    families: [],
    capabilities: [],
  };
}

export const NodeType: MessageFns<NodeType> = {
  encode(message: NodeType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.nodeTypeId !== "") {
      writer.uint32(18).string(message.nodeTypeId);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.virtualCpuCount !== 0) {
      writer.uint32(32).int32(message.virtualCpuCount);
    }
    if (message.totalCoreCount !== 0) {
      writer.uint32(40).int32(message.totalCoreCount);
    }
    if (message.memoryGb !== 0) {
      writer.uint32(56).int32(message.memoryGb);
    }
    if (message.diskSizeGb !== 0) {
      writer.uint32(64).int32(message.diskSizeGb);
    }
    writer.uint32(90).fork();
    for (const v of message.availableCustomCoreCounts) {
      writer.int32(v);
    }
    writer.join();
    if (message.kind !== 0) {
      writer.uint32(96).int32(message.kind);
    }
    for (const v of message.families) {
      writer.uint32(106).string(v!);
    }
    writer.uint32(114).fork();
    for (const v of message.capabilities) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeTypeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.virtualCpuCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalCoreCount = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.memoryGb = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.diskSizeGb = reader.int32();
          continue;
        case 11:
          if (tag === 88) {
            message.availableCustomCoreCounts.push(reader.int32());

            continue;
          }

          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.availableCustomCoreCounts.push(reader.int32());
            }

            continue;
          }

          break;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.families.push(reader.string());
          continue;
        case 14:
          if (tag === 112) {
            message.capabilities.push(reader.int32() as any);

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.capabilities.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nodeTypeId: isSet(object.nodeTypeId) ? globalThis.String(object.nodeTypeId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      virtualCpuCount: isSet(object.virtualCpuCount) ? globalThis.Number(object.virtualCpuCount) : 0,
      totalCoreCount: isSet(object.totalCoreCount) ? globalThis.Number(object.totalCoreCount) : 0,
      memoryGb: isSet(object.memoryGb) ? globalThis.Number(object.memoryGb) : 0,
      diskSizeGb: isSet(object.diskSizeGb) ? globalThis.Number(object.diskSizeGb) : 0,
      availableCustomCoreCounts: globalThis.Array.isArray(object?.availableCustomCoreCounts)
        ? object.availableCustomCoreCounts.map((e: any) => globalThis.Number(e))
        : [],
      kind: isSet(object.kind) ? nodeType_KindFromJSON(object.kind) : 0,
      families: globalThis.Array.isArray(object?.families) ? object.families.map((e: any) => globalThis.String(e)) : [],
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => nodeType_CapabilityFromJSON(e))
        : [],
    };
  },

  toJSON(message: NodeType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nodeTypeId !== "") {
      obj.nodeTypeId = message.nodeTypeId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.virtualCpuCount !== 0) {
      obj.virtualCpuCount = Math.round(message.virtualCpuCount);
    }
    if (message.totalCoreCount !== 0) {
      obj.totalCoreCount = Math.round(message.totalCoreCount);
    }
    if (message.memoryGb !== 0) {
      obj.memoryGb = Math.round(message.memoryGb);
    }
    if (message.diskSizeGb !== 0) {
      obj.diskSizeGb = Math.round(message.diskSizeGb);
    }
    if (message.availableCustomCoreCounts?.length) {
      obj.availableCustomCoreCounts = message.availableCustomCoreCounts.map((e) => Math.round(e));
    }
    if (message.kind !== 0) {
      obj.kind = nodeType_KindToJSON(message.kind);
    }
    if (message.families?.length) {
      obj.families = message.families;
    }
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities.map((e) => nodeType_CapabilityToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NodeType>): NodeType {
    return NodeType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeType>): NodeType {
    const message = createBaseNodeType();
    message.name = object.name ?? "";
    message.nodeTypeId = object.nodeTypeId ?? "";
    message.displayName = object.displayName ?? "";
    message.virtualCpuCount = object.virtualCpuCount ?? 0;
    message.totalCoreCount = object.totalCoreCount ?? 0;
    message.memoryGb = object.memoryGb ?? 0;
    message.diskSizeGb = object.diskSizeGb ?? 0;
    message.availableCustomCoreCounts = object.availableCustomCoreCounts?.map((e) => e) || [];
    message.kind = object.kind ?? 0;
    message.families = object.families?.map((e) => e) || [];
    message.capabilities = object.capabilities?.map((e) => e) || [];
    return message;
  },
};

function createBaseCredentials(): Credentials {
  return { username: "", password: "" };
}

export const Credentials: MessageFns<Credentials> = {
  encode(message: Credentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Credentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Credentials {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: Credentials): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create(base?: DeepPartial<Credentials>): Credentials {
    return Credentials.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Credentials>): Credentials {
    const message = createBaseCredentials();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseHcxActivationKey(): HcxActivationKey {
  return { name: "", createTime: undefined, state: 0, activationKey: "", uid: "" };
}

export const HcxActivationKey: MessageFns<HcxActivationKey> = {
  encode(message: HcxActivationKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.activationKey !== "") {
      writer.uint32(34).string(message.activationKey);
    }
    if (message.uid !== "") {
      writer.uint32(42).string(message.uid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HcxActivationKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHcxActivationKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.activationKey = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.uid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HcxActivationKey {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      state: isSet(object.state) ? hcxActivationKey_StateFromJSON(object.state) : 0,
      activationKey: isSet(object.activationKey) ? globalThis.String(object.activationKey) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
    };
  },

  toJSON(message: HcxActivationKey): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = hcxActivationKey_StateToJSON(message.state);
    }
    if (message.activationKey !== "") {
      obj.activationKey = message.activationKey;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    return obj;
  },

  create(base?: DeepPartial<HcxActivationKey>): HcxActivationKey {
    return HcxActivationKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HcxActivationKey>): HcxActivationKey {
    const message = createBaseHcxActivationKey();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.state = object.state ?? 0;
    message.activationKey = object.activationKey ?? "";
    message.uid = object.uid ?? "";
    return message;
  },
};

function createBaseHcx(): Hcx {
  return { internalIp: "", version: "", state: 0, fqdn: "" };
}

export const Hcx: MessageFns<Hcx> = {
  encode(message: Hcx, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.internalIp !== "") {
      writer.uint32(18).string(message.internalIp);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.fqdn !== "") {
      writer.uint32(50).string(message.fqdn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hcx {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHcx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fqdn = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hcx {
    return {
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      state: isSet(object.state) ? hcx_StateFromJSON(object.state) : 0,
      fqdn: isSet(object.fqdn) ? globalThis.String(object.fqdn) : "",
    };
  },

  toJSON(message: Hcx): unknown {
    const obj: any = {};
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.state !== 0) {
      obj.state = hcx_StateToJSON(message.state);
    }
    if (message.fqdn !== "") {
      obj.fqdn = message.fqdn;
    }
    return obj;
  },

  create(base?: DeepPartial<Hcx>): Hcx {
    return Hcx.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Hcx>): Hcx {
    const message = createBaseHcx();
    message.internalIp = object.internalIp ?? "";
    message.version = object.version ?? "";
    message.state = object.state ?? 0;
    message.fqdn = object.fqdn ?? "";
    return message;
  },
};

function createBaseNsx(): Nsx {
  return { internalIp: "", version: "", state: 0, fqdn: "" };
}

export const Nsx: MessageFns<Nsx> = {
  encode(message: Nsx, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.internalIp !== "") {
      writer.uint32(18).string(message.internalIp);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.fqdn !== "") {
      writer.uint32(50).string(message.fqdn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Nsx {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNsx();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fqdn = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Nsx {
    return {
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      state: isSet(object.state) ? nsx_StateFromJSON(object.state) : 0,
      fqdn: isSet(object.fqdn) ? globalThis.String(object.fqdn) : "",
    };
  },

  toJSON(message: Nsx): unknown {
    const obj: any = {};
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.state !== 0) {
      obj.state = nsx_StateToJSON(message.state);
    }
    if (message.fqdn !== "") {
      obj.fqdn = message.fqdn;
    }
    return obj;
  },

  create(base?: DeepPartial<Nsx>): Nsx {
    return Nsx.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Nsx>): Nsx {
    const message = createBaseNsx();
    message.internalIp = object.internalIp ?? "";
    message.version = object.version ?? "";
    message.state = object.state ?? 0;
    message.fqdn = object.fqdn ?? "";
    return message;
  },
};

function createBaseVcenter(): Vcenter {
  return { internalIp: "", version: "", state: 0, fqdn: "" };
}

export const Vcenter: MessageFns<Vcenter> = {
  encode(message: Vcenter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.internalIp !== "") {
      writer.uint32(18).string(message.internalIp);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.fqdn !== "") {
      writer.uint32(50).string(message.fqdn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vcenter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVcenter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.internalIp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fqdn = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vcenter {
    return {
      internalIp: isSet(object.internalIp) ? globalThis.String(object.internalIp) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      state: isSet(object.state) ? vcenter_StateFromJSON(object.state) : 0,
      fqdn: isSet(object.fqdn) ? globalThis.String(object.fqdn) : "",
    };
  },

  toJSON(message: Vcenter): unknown {
    const obj: any = {};
    if (message.internalIp !== "") {
      obj.internalIp = message.internalIp;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.state !== 0) {
      obj.state = vcenter_StateToJSON(message.state);
    }
    if (message.fqdn !== "") {
      obj.fqdn = message.fqdn;
    }
    return obj;
  },

  create(base?: DeepPartial<Vcenter>): Vcenter {
    return Vcenter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vcenter>): Vcenter {
    const message = createBaseVcenter();
    message.internalIp = object.internalIp ?? "";
    message.version = object.version ?? "";
    message.state = object.state ?? 0;
    message.fqdn = object.fqdn ?? "";
    return message;
  },
};

function createBaseAutoscalingSettings(): AutoscalingSettings {
  return { autoscalingPolicies: {}, minClusterNodeCount: 0, maxClusterNodeCount: 0, coolDownPeriod: undefined };
}

export const AutoscalingSettings: MessageFns<AutoscalingSettings> = {
  encode(message: AutoscalingSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.autoscalingPolicies).forEach(([key, value]) => {
      AutoscalingSettings_AutoscalingPoliciesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.minClusterNodeCount !== 0) {
      writer.uint32(16).int32(message.minClusterNodeCount);
    }
    if (message.maxClusterNodeCount !== 0) {
      writer.uint32(24).int32(message.maxClusterNodeCount);
    }
    if (message.coolDownPeriod !== undefined) {
      Duration.encode(message.coolDownPeriod, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoscalingSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoscalingSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = AutoscalingSettings_AutoscalingPoliciesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.autoscalingPolicies[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minClusterNodeCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxClusterNodeCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.coolDownPeriod = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoscalingSettings {
    return {
      autoscalingPolicies: isObject(object.autoscalingPolicies)
        ? Object.entries(object.autoscalingPolicies).reduce<{ [key: string]: AutoscalingSettings_AutoscalingPolicy }>(
          (acc, [key, value]) => {
            acc[key] = AutoscalingSettings_AutoscalingPolicy.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      minClusterNodeCount: isSet(object.minClusterNodeCount) ? globalThis.Number(object.minClusterNodeCount) : 0,
      maxClusterNodeCount: isSet(object.maxClusterNodeCount) ? globalThis.Number(object.maxClusterNodeCount) : 0,
      coolDownPeriod: isSet(object.coolDownPeriod) ? Duration.fromJSON(object.coolDownPeriod) : undefined,
    };
  },

  toJSON(message: AutoscalingSettings): unknown {
    const obj: any = {};
    if (message.autoscalingPolicies) {
      const entries = Object.entries(message.autoscalingPolicies);
      if (entries.length > 0) {
        obj.autoscalingPolicies = {};
        entries.forEach(([k, v]) => {
          obj.autoscalingPolicies[k] = AutoscalingSettings_AutoscalingPolicy.toJSON(v);
        });
      }
    }
    if (message.minClusterNodeCount !== 0) {
      obj.minClusterNodeCount = Math.round(message.minClusterNodeCount);
    }
    if (message.maxClusterNodeCount !== 0) {
      obj.maxClusterNodeCount = Math.round(message.maxClusterNodeCount);
    }
    if (message.coolDownPeriod !== undefined) {
      obj.coolDownPeriod = Duration.toJSON(message.coolDownPeriod);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoscalingSettings>): AutoscalingSettings {
    return AutoscalingSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoscalingSettings>): AutoscalingSettings {
    const message = createBaseAutoscalingSettings();
    message.autoscalingPolicies = Object.entries(object.autoscalingPolicies ?? {}).reduce<
      { [key: string]: AutoscalingSettings_AutoscalingPolicy }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = AutoscalingSettings_AutoscalingPolicy.fromPartial(value);
      }
      return acc;
    }, {});
    message.minClusterNodeCount = object.minClusterNodeCount ?? 0;
    message.maxClusterNodeCount = object.maxClusterNodeCount ?? 0;
    message.coolDownPeriod = (object.coolDownPeriod !== undefined && object.coolDownPeriod !== null)
      ? Duration.fromPartial(object.coolDownPeriod)
      : undefined;
    return message;
  },
};

function createBaseAutoscalingSettings_Thresholds(): AutoscalingSettings_Thresholds {
  return { scaleOut: 0, scaleIn: 0 };
}

export const AutoscalingSettings_Thresholds: MessageFns<AutoscalingSettings_Thresholds> = {
  encode(message: AutoscalingSettings_Thresholds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scaleOut !== 0) {
      writer.uint32(8).int32(message.scaleOut);
    }
    if (message.scaleIn !== 0) {
      writer.uint32(16).int32(message.scaleIn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoscalingSettings_Thresholds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoscalingSettings_Thresholds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scaleOut = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.scaleIn = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoscalingSettings_Thresholds {
    return {
      scaleOut: isSet(object.scaleOut) ? globalThis.Number(object.scaleOut) : 0,
      scaleIn: isSet(object.scaleIn) ? globalThis.Number(object.scaleIn) : 0,
    };
  },

  toJSON(message: AutoscalingSettings_Thresholds): unknown {
    const obj: any = {};
    if (message.scaleOut !== 0) {
      obj.scaleOut = Math.round(message.scaleOut);
    }
    if (message.scaleIn !== 0) {
      obj.scaleIn = Math.round(message.scaleIn);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoscalingSettings_Thresholds>): AutoscalingSettings_Thresholds {
    return AutoscalingSettings_Thresholds.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoscalingSettings_Thresholds>): AutoscalingSettings_Thresholds {
    const message = createBaseAutoscalingSettings_Thresholds();
    message.scaleOut = object.scaleOut ?? 0;
    message.scaleIn = object.scaleIn ?? 0;
    return message;
  },
};

function createBaseAutoscalingSettings_AutoscalingPolicy(): AutoscalingSettings_AutoscalingPolicy {
  return {
    nodeTypeId: "",
    scaleOutSize: 0,
    cpuThresholds: undefined,
    grantedMemoryThresholds: undefined,
    consumedMemoryThresholds: undefined,
    storageThresholds: undefined,
  };
}

export const AutoscalingSettings_AutoscalingPolicy: MessageFns<AutoscalingSettings_AutoscalingPolicy> = {
  encode(message: AutoscalingSettings_AutoscalingPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeTypeId !== "") {
      writer.uint32(10).string(message.nodeTypeId);
    }
    if (message.scaleOutSize !== 0) {
      writer.uint32(16).int32(message.scaleOutSize);
    }
    if (message.cpuThresholds !== undefined) {
      AutoscalingSettings_Thresholds.encode(message.cpuThresholds, writer.uint32(90).fork()).join();
    }
    if (message.grantedMemoryThresholds !== undefined) {
      AutoscalingSettings_Thresholds.encode(message.grantedMemoryThresholds, writer.uint32(98).fork()).join();
    }
    if (message.consumedMemoryThresholds !== undefined) {
      AutoscalingSettings_Thresholds.encode(message.consumedMemoryThresholds, writer.uint32(106).fork()).join();
    }
    if (message.storageThresholds !== undefined) {
      AutoscalingSettings_Thresholds.encode(message.storageThresholds, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoscalingSettings_AutoscalingPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoscalingSettings_AutoscalingPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeTypeId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.scaleOutSize = reader.int32();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.cpuThresholds = AutoscalingSettings_Thresholds.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.grantedMemoryThresholds = AutoscalingSettings_Thresholds.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.consumedMemoryThresholds = AutoscalingSettings_Thresholds.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.storageThresholds = AutoscalingSettings_Thresholds.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoscalingSettings_AutoscalingPolicy {
    return {
      nodeTypeId: isSet(object.nodeTypeId) ? globalThis.String(object.nodeTypeId) : "",
      scaleOutSize: isSet(object.scaleOutSize) ? globalThis.Number(object.scaleOutSize) : 0,
      cpuThresholds: isSet(object.cpuThresholds)
        ? AutoscalingSettings_Thresholds.fromJSON(object.cpuThresholds)
        : undefined,
      grantedMemoryThresholds: isSet(object.grantedMemoryThresholds)
        ? AutoscalingSettings_Thresholds.fromJSON(object.grantedMemoryThresholds)
        : undefined,
      consumedMemoryThresholds: isSet(object.consumedMemoryThresholds)
        ? AutoscalingSettings_Thresholds.fromJSON(object.consumedMemoryThresholds)
        : undefined,
      storageThresholds: isSet(object.storageThresholds)
        ? AutoscalingSettings_Thresholds.fromJSON(object.storageThresholds)
        : undefined,
    };
  },

  toJSON(message: AutoscalingSettings_AutoscalingPolicy): unknown {
    const obj: any = {};
    if (message.nodeTypeId !== "") {
      obj.nodeTypeId = message.nodeTypeId;
    }
    if (message.scaleOutSize !== 0) {
      obj.scaleOutSize = Math.round(message.scaleOutSize);
    }
    if (message.cpuThresholds !== undefined) {
      obj.cpuThresholds = AutoscalingSettings_Thresholds.toJSON(message.cpuThresholds);
    }
    if (message.grantedMemoryThresholds !== undefined) {
      obj.grantedMemoryThresholds = AutoscalingSettings_Thresholds.toJSON(message.grantedMemoryThresholds);
    }
    if (message.consumedMemoryThresholds !== undefined) {
      obj.consumedMemoryThresholds = AutoscalingSettings_Thresholds.toJSON(message.consumedMemoryThresholds);
    }
    if (message.storageThresholds !== undefined) {
      obj.storageThresholds = AutoscalingSettings_Thresholds.toJSON(message.storageThresholds);
    }
    return obj;
  },

  create(base?: DeepPartial<AutoscalingSettings_AutoscalingPolicy>): AutoscalingSettings_AutoscalingPolicy {
    return AutoscalingSettings_AutoscalingPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoscalingSettings_AutoscalingPolicy>): AutoscalingSettings_AutoscalingPolicy {
    const message = createBaseAutoscalingSettings_AutoscalingPolicy();
    message.nodeTypeId = object.nodeTypeId ?? "";
    message.scaleOutSize = object.scaleOutSize ?? 0;
    message.cpuThresholds = (object.cpuThresholds !== undefined && object.cpuThresholds !== null)
      ? AutoscalingSettings_Thresholds.fromPartial(object.cpuThresholds)
      : undefined;
    message.grantedMemoryThresholds =
      (object.grantedMemoryThresholds !== undefined && object.grantedMemoryThresholds !== null)
        ? AutoscalingSettings_Thresholds.fromPartial(object.grantedMemoryThresholds)
        : undefined;
    message.consumedMemoryThresholds =
      (object.consumedMemoryThresholds !== undefined && object.consumedMemoryThresholds !== null)
        ? AutoscalingSettings_Thresholds.fromPartial(object.consumedMemoryThresholds)
        : undefined;
    message.storageThresholds = (object.storageThresholds !== undefined && object.storageThresholds !== null)
      ? AutoscalingSettings_Thresholds.fromPartial(object.storageThresholds)
      : undefined;
    return message;
  },
};

function createBaseAutoscalingSettings_AutoscalingPoliciesEntry(): AutoscalingSettings_AutoscalingPoliciesEntry {
  return { key: "", value: undefined };
}

export const AutoscalingSettings_AutoscalingPoliciesEntry: MessageFns<AutoscalingSettings_AutoscalingPoliciesEntry> = {
  encode(
    message: AutoscalingSettings_AutoscalingPoliciesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AutoscalingSettings_AutoscalingPolicy.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoscalingSettings_AutoscalingPoliciesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoscalingSettings_AutoscalingPoliciesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AutoscalingSettings_AutoscalingPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoscalingSettings_AutoscalingPoliciesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AutoscalingSettings_AutoscalingPolicy.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AutoscalingSettings_AutoscalingPoliciesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AutoscalingSettings_AutoscalingPolicy.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AutoscalingSettings_AutoscalingPoliciesEntry>,
  ): AutoscalingSettings_AutoscalingPoliciesEntry {
    return AutoscalingSettings_AutoscalingPoliciesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AutoscalingSettings_AutoscalingPoliciesEntry>,
  ): AutoscalingSettings_AutoscalingPoliciesEntry {
    const message = createBaseAutoscalingSettings_AutoscalingPoliciesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AutoscalingSettings_AutoscalingPolicy.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDnsForwarding(): DnsForwarding {
  return { name: "", createTime: undefined, updateTime: undefined, forwardingRules: [] };
}

export const DnsForwarding: MessageFns<DnsForwarding> = {
  encode(message: DnsForwarding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    for (const v of message.forwardingRules) {
      DnsForwarding_ForwardingRule.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsForwarding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsForwarding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.forwardingRules.push(DnsForwarding_ForwardingRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsForwarding {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      forwardingRules: globalThis.Array.isArray(object?.forwardingRules)
        ? object.forwardingRules.map((e: any) => DnsForwarding_ForwardingRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DnsForwarding): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.forwardingRules?.length) {
      obj.forwardingRules = message.forwardingRules.map((e) => DnsForwarding_ForwardingRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DnsForwarding>): DnsForwarding {
    return DnsForwarding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsForwarding>): DnsForwarding {
    const message = createBaseDnsForwarding();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.forwardingRules = object.forwardingRules?.map((e) => DnsForwarding_ForwardingRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDnsForwarding_ForwardingRule(): DnsForwarding_ForwardingRule {
  return { domain: "", nameServers: [] };
}

export const DnsForwarding_ForwardingRule: MessageFns<DnsForwarding_ForwardingRule> = {
  encode(message: DnsForwarding_ForwardingRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domain !== "") {
      writer.uint32(10).string(message.domain);
    }
    for (const v of message.nameServers) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsForwarding_ForwardingRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsForwarding_ForwardingRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domain = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nameServers.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsForwarding_ForwardingRule {
    return {
      domain: isSet(object.domain) ? globalThis.String(object.domain) : "",
      nameServers: globalThis.Array.isArray(object?.nameServers)
        ? object.nameServers.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DnsForwarding_ForwardingRule): unknown {
    const obj: any = {};
    if (message.domain !== "") {
      obj.domain = message.domain;
    }
    if (message.nameServers?.length) {
      obj.nameServers = message.nameServers;
    }
    return obj;
  },

  create(base?: DeepPartial<DnsForwarding_ForwardingRule>): DnsForwarding_ForwardingRule {
    return DnsForwarding_ForwardingRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsForwarding_ForwardingRule>): DnsForwarding_ForwardingRule {
    const message = createBaseDnsForwarding_ForwardingRule();
    message.domain = object.domain ?? "";
    message.nameServers = object.nameServers?.map((e) => e) || [];
    return message;
  },
};

function createBaseNetworkPeering(): NetworkPeering {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    peerNetwork: "",
    exportCustomRoutes: undefined,
    importCustomRoutes: undefined,
    exchangeSubnetRoutes: undefined,
    exportCustomRoutesWithPublicIp: undefined,
    importCustomRoutesWithPublicIp: undefined,
    state: 0,
    stateDetails: "",
    peerMtu: 0,
    peerNetworkType: 0,
    uid: "",
    vmwareEngineNetwork: "",
    description: "",
  };
}

export const NetworkPeering: MessageFns<NetworkPeering> = {
  encode(message: NetworkPeering, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.peerNetwork !== "") {
      writer.uint32(42).string(message.peerNetwork);
    }
    if (message.exportCustomRoutes !== undefined) {
      writer.uint32(64).bool(message.exportCustomRoutes);
    }
    if (message.importCustomRoutes !== undefined) {
      writer.uint32(72).bool(message.importCustomRoutes);
    }
    if (message.exchangeSubnetRoutes !== undefined) {
      writer.uint32(80).bool(message.exchangeSubnetRoutes);
    }
    if (message.exportCustomRoutesWithPublicIp !== undefined) {
      writer.uint32(88).bool(message.exportCustomRoutesWithPublicIp);
    }
    if (message.importCustomRoutesWithPublicIp !== undefined) {
      writer.uint32(96).bool(message.importCustomRoutesWithPublicIp);
    }
    if (message.state !== 0) {
      writer.uint32(104).int32(message.state);
    }
    if (message.stateDetails !== "") {
      writer.uint32(58).string(message.stateDetails);
    }
    if (message.peerMtu !== 0) {
      writer.uint32(112).int32(message.peerMtu);
    }
    if (message.peerNetworkType !== 0) {
      writer.uint32(128).int32(message.peerNetworkType);
    }
    if (message.uid !== "") {
      writer.uint32(138).string(message.uid);
    }
    if (message.vmwareEngineNetwork !== "") {
      writer.uint32(162).string(message.vmwareEngineNetwork);
    }
    if (message.description !== "") {
      writer.uint32(170).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkPeering {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkPeering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.peerNetwork = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.exportCustomRoutes = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.importCustomRoutes = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.exchangeSubnetRoutes = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.exportCustomRoutesWithPublicIp = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.importCustomRoutesWithPublicIp = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.stateDetails = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.peerMtu = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.peerNetworkType = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.vmwareEngineNetwork = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkPeering {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      peerNetwork: isSet(object.peerNetwork) ? globalThis.String(object.peerNetwork) : "",
      exportCustomRoutes: isSet(object.exportCustomRoutes) ? globalThis.Boolean(object.exportCustomRoutes) : undefined,
      importCustomRoutes: isSet(object.importCustomRoutes) ? globalThis.Boolean(object.importCustomRoutes) : undefined,
      exchangeSubnetRoutes: isSet(object.exchangeSubnetRoutes)
        ? globalThis.Boolean(object.exchangeSubnetRoutes)
        : undefined,
      exportCustomRoutesWithPublicIp: isSet(object.exportCustomRoutesWithPublicIp)
        ? globalThis.Boolean(object.exportCustomRoutesWithPublicIp)
        : undefined,
      importCustomRoutesWithPublicIp: isSet(object.importCustomRoutesWithPublicIp)
        ? globalThis.Boolean(object.importCustomRoutesWithPublicIp)
        : undefined,
      state: isSet(object.state) ? networkPeering_StateFromJSON(object.state) : 0,
      stateDetails: isSet(object.stateDetails) ? globalThis.String(object.stateDetails) : "",
      peerMtu: isSet(object.peerMtu) ? globalThis.Number(object.peerMtu) : 0,
      peerNetworkType: isSet(object.peerNetworkType)
        ? networkPeering_PeerNetworkTypeFromJSON(object.peerNetworkType)
        : 0,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      vmwareEngineNetwork: isSet(object.vmwareEngineNetwork) ? globalThis.String(object.vmwareEngineNetwork) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: NetworkPeering): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.peerNetwork !== "") {
      obj.peerNetwork = message.peerNetwork;
    }
    if (message.exportCustomRoutes !== undefined) {
      obj.exportCustomRoutes = message.exportCustomRoutes;
    }
    if (message.importCustomRoutes !== undefined) {
      obj.importCustomRoutes = message.importCustomRoutes;
    }
    if (message.exchangeSubnetRoutes !== undefined) {
      obj.exchangeSubnetRoutes = message.exchangeSubnetRoutes;
    }
    if (message.exportCustomRoutesWithPublicIp !== undefined) {
      obj.exportCustomRoutesWithPublicIp = message.exportCustomRoutesWithPublicIp;
    }
    if (message.importCustomRoutesWithPublicIp !== undefined) {
      obj.importCustomRoutesWithPublicIp = message.importCustomRoutesWithPublicIp;
    }
    if (message.state !== 0) {
      obj.state = networkPeering_StateToJSON(message.state);
    }
    if (message.stateDetails !== "") {
      obj.stateDetails = message.stateDetails;
    }
    if (message.peerMtu !== 0) {
      obj.peerMtu = Math.round(message.peerMtu);
    }
    if (message.peerNetworkType !== 0) {
      obj.peerNetworkType = networkPeering_PeerNetworkTypeToJSON(message.peerNetworkType);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.vmwareEngineNetwork !== "") {
      obj.vmwareEngineNetwork = message.vmwareEngineNetwork;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkPeering>): NetworkPeering {
    return NetworkPeering.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkPeering>): NetworkPeering {
    const message = createBaseNetworkPeering();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.peerNetwork = object.peerNetwork ?? "";
    message.exportCustomRoutes = object.exportCustomRoutes ?? undefined;
    message.importCustomRoutes = object.importCustomRoutes ?? undefined;
    message.exchangeSubnetRoutes = object.exchangeSubnetRoutes ?? undefined;
    message.exportCustomRoutesWithPublicIp = object.exportCustomRoutesWithPublicIp ?? undefined;
    message.importCustomRoutesWithPublicIp = object.importCustomRoutesWithPublicIp ?? undefined;
    message.state = object.state ?? 0;
    message.stateDetails = object.stateDetails ?? "";
    message.peerMtu = object.peerMtu ?? 0;
    message.peerNetworkType = object.peerNetworkType ?? 0;
    message.uid = object.uid ?? "";
    message.vmwareEngineNetwork = object.vmwareEngineNetwork ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBasePeeringRoute(): PeeringRoute {
  return { destRange: "", type: 0, nextHopRegion: "", priority: Long.ZERO, imported: false, direction: 0 };
}

export const PeeringRoute: MessageFns<PeeringRoute> = {
  encode(message: PeeringRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.destRange !== "") {
      writer.uint32(10).string(message.destRange);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.nextHopRegion !== "") {
      writer.uint32(26).string(message.nextHopRegion);
    }
    if (!message.priority.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.priority.toString());
    }
    if (message.imported !== false) {
      writer.uint32(40).bool(message.imported);
    }
    if (message.direction !== 0) {
      writer.uint32(48).int32(message.direction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PeeringRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeeringRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destRange = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextHopRegion = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.priority = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.imported = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PeeringRoute {
    return {
      destRange: isSet(object.destRange) ? globalThis.String(object.destRange) : "",
      type: isSet(object.type) ? peeringRoute_TypeFromJSON(object.type) : 0,
      nextHopRegion: isSet(object.nextHopRegion) ? globalThis.String(object.nextHopRegion) : "",
      priority: isSet(object.priority) ? Long.fromValue(object.priority) : Long.ZERO,
      imported: isSet(object.imported) ? globalThis.Boolean(object.imported) : false,
      direction: isSet(object.direction) ? peeringRoute_DirectionFromJSON(object.direction) : 0,
    };
  },

  toJSON(message: PeeringRoute): unknown {
    const obj: any = {};
    if (message.destRange !== "") {
      obj.destRange = message.destRange;
    }
    if (message.type !== 0) {
      obj.type = peeringRoute_TypeToJSON(message.type);
    }
    if (message.nextHopRegion !== "") {
      obj.nextHopRegion = message.nextHopRegion;
    }
    if (!message.priority.equals(Long.ZERO)) {
      obj.priority = (message.priority || Long.ZERO).toString();
    }
    if (message.imported !== false) {
      obj.imported = message.imported;
    }
    if (message.direction !== 0) {
      obj.direction = peeringRoute_DirectionToJSON(message.direction);
    }
    return obj;
  },

  create(base?: DeepPartial<PeeringRoute>): PeeringRoute {
    return PeeringRoute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PeeringRoute>): PeeringRoute {
    const message = createBasePeeringRoute();
    message.destRange = object.destRange ?? "";
    message.type = object.type ?? 0;
    message.nextHopRegion = object.nextHopRegion ?? "";
    message.priority = (object.priority !== undefined && object.priority !== null)
      ? Long.fromValue(object.priority)
      : Long.ZERO;
    message.imported = object.imported ?? false;
    message.direction = object.direction ?? 0;
    return message;
  },
};

function createBaseNetworkPolicy(): NetworkPolicy {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    internetAccess: undefined,
    externalIp: undefined,
    edgeServicesCidr: "",
    uid: "",
    vmwareEngineNetwork: "",
    description: "",
    vmwareEngineNetworkCanonical: "",
  };
}

export const NetworkPolicy: MessageFns<NetworkPolicy> = {
  encode(message: NetworkPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.internetAccess !== undefined) {
      NetworkPolicy_NetworkService.encode(message.internetAccess, writer.uint32(50).fork()).join();
    }
    if (message.externalIp !== undefined) {
      NetworkPolicy_NetworkService.encode(message.externalIp, writer.uint32(58).fork()).join();
    }
    if (message.edgeServicesCidr !== "") {
      writer.uint32(74).string(message.edgeServicesCidr);
    }
    if (message.uid !== "") {
      writer.uint32(82).string(message.uid);
    }
    if (message.vmwareEngineNetwork !== "") {
      writer.uint32(98).string(message.vmwareEngineNetwork);
    }
    if (message.description !== "") {
      writer.uint32(106).string(message.description);
    }
    if (message.vmwareEngineNetworkCanonical !== "") {
      writer.uint32(114).string(message.vmwareEngineNetworkCanonical);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.internetAccess = NetworkPolicy_NetworkService.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.externalIp = NetworkPolicy_NetworkService.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.edgeServicesCidr = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.vmwareEngineNetwork = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.description = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.vmwareEngineNetworkCanonical = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkPolicy {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      internetAccess: isSet(object.internetAccess)
        ? NetworkPolicy_NetworkService.fromJSON(object.internetAccess)
        : undefined,
      externalIp: isSet(object.externalIp) ? NetworkPolicy_NetworkService.fromJSON(object.externalIp) : undefined,
      edgeServicesCidr: isSet(object.edgeServicesCidr) ? globalThis.String(object.edgeServicesCidr) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      vmwareEngineNetwork: isSet(object.vmwareEngineNetwork) ? globalThis.String(object.vmwareEngineNetwork) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      vmwareEngineNetworkCanonical: isSet(object.vmwareEngineNetworkCanonical)
        ? globalThis.String(object.vmwareEngineNetworkCanonical)
        : "",
    };
  },

  toJSON(message: NetworkPolicy): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.internetAccess !== undefined) {
      obj.internetAccess = NetworkPolicy_NetworkService.toJSON(message.internetAccess);
    }
    if (message.externalIp !== undefined) {
      obj.externalIp = NetworkPolicy_NetworkService.toJSON(message.externalIp);
    }
    if (message.edgeServicesCidr !== "") {
      obj.edgeServicesCidr = message.edgeServicesCidr;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.vmwareEngineNetwork !== "") {
      obj.vmwareEngineNetwork = message.vmwareEngineNetwork;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.vmwareEngineNetworkCanonical !== "") {
      obj.vmwareEngineNetworkCanonical = message.vmwareEngineNetworkCanonical;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkPolicy>): NetworkPolicy {
    return NetworkPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkPolicy>): NetworkPolicy {
    const message = createBaseNetworkPolicy();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.internetAccess = (object.internetAccess !== undefined && object.internetAccess !== null)
      ? NetworkPolicy_NetworkService.fromPartial(object.internetAccess)
      : undefined;
    message.externalIp = (object.externalIp !== undefined && object.externalIp !== null)
      ? NetworkPolicy_NetworkService.fromPartial(object.externalIp)
      : undefined;
    message.edgeServicesCidr = object.edgeServicesCidr ?? "";
    message.uid = object.uid ?? "";
    message.vmwareEngineNetwork = object.vmwareEngineNetwork ?? "";
    message.description = object.description ?? "";
    message.vmwareEngineNetworkCanonical = object.vmwareEngineNetworkCanonical ?? "";
    return message;
  },
};

function createBaseNetworkPolicy_NetworkService(): NetworkPolicy_NetworkService {
  return { enabled: false, state: 0 };
}

export const NetworkPolicy_NetworkService: MessageFns<NetworkPolicy_NetworkService> = {
  encode(message: NetworkPolicy_NetworkService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkPolicy_NetworkService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkPolicy_NetworkService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkPolicy_NetworkService {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      state: isSet(object.state) ? networkPolicy_NetworkService_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: NetworkPolicy_NetworkService): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.state !== 0) {
      obj.state = networkPolicy_NetworkService_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkPolicy_NetworkService>): NetworkPolicy_NetworkService {
    return NetworkPolicy_NetworkService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkPolicy_NetworkService>): NetworkPolicy_NetworkService {
    const message = createBaseNetworkPolicy_NetworkService();
    message.enabled = object.enabled ?? false;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseManagementDnsZoneBinding(): ManagementDnsZoneBinding {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    state: 0,
    description: "",
    vpcNetwork: undefined,
    vmwareEngineNetwork: undefined,
    uid: "",
  };
}

export const ManagementDnsZoneBinding: MessageFns<ManagementDnsZoneBinding> = {
  encode(message: ManagementDnsZoneBinding, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.description !== "") {
      writer.uint32(106).string(message.description);
    }
    if (message.vpcNetwork !== undefined) {
      writer.uint32(114).string(message.vpcNetwork);
    }
    if (message.vmwareEngineNetwork !== undefined) {
      writer.uint32(122).string(message.vmwareEngineNetwork);
    }
    if (message.uid !== "") {
      writer.uint32(74).string(message.uid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManagementDnsZoneBinding {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManagementDnsZoneBinding();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.description = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.vpcNetwork = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.vmwareEngineNetwork = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.uid = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManagementDnsZoneBinding {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? managementDnsZoneBinding_StateFromJSON(object.state) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      vpcNetwork: isSet(object.vpcNetwork) ? globalThis.String(object.vpcNetwork) : undefined,
      vmwareEngineNetwork: isSet(object.vmwareEngineNetwork)
        ? globalThis.String(object.vmwareEngineNetwork)
        : undefined,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
    };
  },

  toJSON(message: ManagementDnsZoneBinding): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = managementDnsZoneBinding_StateToJSON(message.state);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.vpcNetwork !== undefined) {
      obj.vpcNetwork = message.vpcNetwork;
    }
    if (message.vmwareEngineNetwork !== undefined) {
      obj.vmwareEngineNetwork = message.vmwareEngineNetwork;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    return obj;
  },

  create(base?: DeepPartial<ManagementDnsZoneBinding>): ManagementDnsZoneBinding {
    return ManagementDnsZoneBinding.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManagementDnsZoneBinding>): ManagementDnsZoneBinding {
    const message = createBaseManagementDnsZoneBinding();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    message.description = object.description ?? "";
    message.vpcNetwork = object.vpcNetwork ?? undefined;
    message.vmwareEngineNetwork = object.vmwareEngineNetwork ?? undefined;
    message.uid = object.uid ?? "";
    return message;
  },
};

function createBaseVmwareEngineNetwork(): VmwareEngineNetwork {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    description: "",
    vpcNetworks: [],
    state: 0,
    type: 0,
    uid: "",
    etag: "",
  };
}

export const VmwareEngineNetwork: MessageFns<VmwareEngineNetwork> = {
  encode(message: VmwareEngineNetwork, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.vpcNetworks) {
      VmwareEngineNetwork_VpcNetwork.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    if (message.uid !== "") {
      writer.uint32(74).string(message.uid);
    }
    if (message.etag !== "") {
      writer.uint32(82).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmwareEngineNetwork {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmwareEngineNetwork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.vpcNetworks.push(VmwareEngineNetwork_VpcNetwork.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmwareEngineNetwork {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      vpcNetworks: globalThis.Array.isArray(object?.vpcNetworks)
        ? object.vpcNetworks.map((e: any) => VmwareEngineNetwork_VpcNetwork.fromJSON(e))
        : [],
      state: isSet(object.state) ? vmwareEngineNetwork_StateFromJSON(object.state) : 0,
      type: isSet(object.type) ? vmwareEngineNetwork_TypeFromJSON(object.type) : 0,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: VmwareEngineNetwork): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.vpcNetworks?.length) {
      obj.vpcNetworks = message.vpcNetworks.map((e) => VmwareEngineNetwork_VpcNetwork.toJSON(e));
    }
    if (message.state !== 0) {
      obj.state = vmwareEngineNetwork_StateToJSON(message.state);
    }
    if (message.type !== 0) {
      obj.type = vmwareEngineNetwork_TypeToJSON(message.type);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<VmwareEngineNetwork>): VmwareEngineNetwork {
    return VmwareEngineNetwork.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VmwareEngineNetwork>): VmwareEngineNetwork {
    const message = createBaseVmwareEngineNetwork();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.description = object.description ?? "";
    message.vpcNetworks = object.vpcNetworks?.map((e) => VmwareEngineNetwork_VpcNetwork.fromPartial(e)) || [];
    message.state = object.state ?? 0;
    message.type = object.type ?? 0;
    message.uid = object.uid ?? "";
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseVmwareEngineNetwork_VpcNetwork(): VmwareEngineNetwork_VpcNetwork {
  return { type: 0, network: "" };
}

export const VmwareEngineNetwork_VpcNetwork: MessageFns<VmwareEngineNetwork_VpcNetwork> = {
  encode(message: VmwareEngineNetwork_VpcNetwork, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.network !== "") {
      writer.uint32(18).string(message.network);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VmwareEngineNetwork_VpcNetwork {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVmwareEngineNetwork_VpcNetwork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.network = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VmwareEngineNetwork_VpcNetwork {
    return {
      type: isSet(object.type) ? vmwareEngineNetwork_VpcNetwork_TypeFromJSON(object.type) : 0,
      network: isSet(object.network) ? globalThis.String(object.network) : "",
    };
  },

  toJSON(message: VmwareEngineNetwork_VpcNetwork): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = vmwareEngineNetwork_VpcNetwork_TypeToJSON(message.type);
    }
    if (message.network !== "") {
      obj.network = message.network;
    }
    return obj;
  },

  create(base?: DeepPartial<VmwareEngineNetwork_VpcNetwork>): VmwareEngineNetwork_VpcNetwork {
    return VmwareEngineNetwork_VpcNetwork.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VmwareEngineNetwork_VpcNetwork>): VmwareEngineNetwork_VpcNetwork {
    const message = createBaseVmwareEngineNetwork_VpcNetwork();
    message.type = object.type ?? 0;
    message.network = object.network ?? "";
    return message;
  },
};

function createBasePrivateConnection(): PrivateConnection {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    description: "",
    state: 0,
    vmwareEngineNetwork: "",
    vmwareEngineNetworkCanonical: "",
    type: 0,
    peeringId: "",
    routingMode: 0,
    uid: "",
    serviceNetwork: "",
    peeringState: 0,
  };
}

export const PrivateConnection: MessageFns<PrivateConnection> = {
  encode(message: PrivateConnection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.vmwareEngineNetwork !== "") {
      writer.uint32(66).string(message.vmwareEngineNetwork);
    }
    if (message.vmwareEngineNetworkCanonical !== "") {
      writer.uint32(74).string(message.vmwareEngineNetworkCanonical);
    }
    if (message.type !== 0) {
      writer.uint32(80).int32(message.type);
    }
    if (message.peeringId !== "") {
      writer.uint32(98).string(message.peeringId);
    }
    if (message.routingMode !== 0) {
      writer.uint32(104).int32(message.routingMode);
    }
    if (message.uid !== "") {
      writer.uint32(114).string(message.uid);
    }
    if (message.serviceNetwork !== "") {
      writer.uint32(130).string(message.serviceNetwork);
    }
    if (message.peeringState !== 0) {
      writer.uint32(136).int32(message.peeringState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivateConnection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivateConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.vmwareEngineNetwork = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.vmwareEngineNetworkCanonical = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.peeringId = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.routingMode = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.serviceNetwork = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.peeringState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivateConnection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? privateConnection_StateFromJSON(object.state) : 0,
      vmwareEngineNetwork: isSet(object.vmwareEngineNetwork) ? globalThis.String(object.vmwareEngineNetwork) : "",
      vmwareEngineNetworkCanonical: isSet(object.vmwareEngineNetworkCanonical)
        ? globalThis.String(object.vmwareEngineNetworkCanonical)
        : "",
      type: isSet(object.type) ? privateConnection_TypeFromJSON(object.type) : 0,
      peeringId: isSet(object.peeringId) ? globalThis.String(object.peeringId) : "",
      routingMode: isSet(object.routingMode) ? privateConnection_RoutingModeFromJSON(object.routingMode) : 0,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      serviceNetwork: isSet(object.serviceNetwork) ? globalThis.String(object.serviceNetwork) : "",
      peeringState: isSet(object.peeringState) ? privateConnection_PeeringStateFromJSON(object.peeringState) : 0,
    };
  },

  toJSON(message: PrivateConnection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = privateConnection_StateToJSON(message.state);
    }
    if (message.vmwareEngineNetwork !== "") {
      obj.vmwareEngineNetwork = message.vmwareEngineNetwork;
    }
    if (message.vmwareEngineNetworkCanonical !== "") {
      obj.vmwareEngineNetworkCanonical = message.vmwareEngineNetworkCanonical;
    }
    if (message.type !== 0) {
      obj.type = privateConnection_TypeToJSON(message.type);
    }
    if (message.peeringId !== "") {
      obj.peeringId = message.peeringId;
    }
    if (message.routingMode !== 0) {
      obj.routingMode = privateConnection_RoutingModeToJSON(message.routingMode);
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.serviceNetwork !== "") {
      obj.serviceNetwork = message.serviceNetwork;
    }
    if (message.peeringState !== 0) {
      obj.peeringState = privateConnection_PeeringStateToJSON(message.peeringState);
    }
    return obj;
  },

  create(base?: DeepPartial<PrivateConnection>): PrivateConnection {
    return PrivateConnection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivateConnection>): PrivateConnection {
    const message = createBasePrivateConnection();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.vmwareEngineNetwork = object.vmwareEngineNetwork ?? "";
    message.vmwareEngineNetworkCanonical = object.vmwareEngineNetworkCanonical ?? "";
    message.type = object.type ?? 0;
    message.peeringId = object.peeringId ?? "";
    message.routingMode = object.routingMode ?? 0;
    message.uid = object.uid ?? "";
    message.serviceNetwork = object.serviceNetwork ?? "";
    message.peeringState = object.peeringState ?? 0;
    return message;
  },
};

function createBaseLocationMetadata(): LocationMetadata {
  return { capabilities: [] };
}

export const LocationMetadata: MessageFns<LocationMetadata> = {
  encode(message: LocationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.capabilities) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.capabilities.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.capabilities.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationMetadata {
    return {
      capabilities: globalThis.Array.isArray(object?.capabilities)
        ? object.capabilities.map((e: any) => locationMetadata_CapabilityFromJSON(e))
        : [],
    };
  },

  toJSON(message: LocationMetadata): unknown {
    const obj: any = {};
    if (message.capabilities?.length) {
      obj.capabilities = message.capabilities.map((e) => locationMetadata_CapabilityToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<LocationMetadata>): LocationMetadata {
    return LocationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LocationMetadata>): LocationMetadata {
    const message = createBaseLocationMetadata();
    message.capabilities = object.capabilities?.map((e) => e) || [];
    return message;
  },
};

function createBaseDnsBindPermission(): DnsBindPermission {
  return { name: "", principals: [] };
}

export const DnsBindPermission: MessageFns<DnsBindPermission> = {
  encode(message: DnsBindPermission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.principals) {
      Principal.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsBindPermission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsBindPermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.principals.push(Principal.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsBindPermission {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      principals: globalThis.Array.isArray(object?.principals)
        ? object.principals.map((e: any) => Principal.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DnsBindPermission): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.principals?.length) {
      obj.principals = message.principals.map((e) => Principal.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DnsBindPermission>): DnsBindPermission {
    return DnsBindPermission.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsBindPermission>): DnsBindPermission {
    const message = createBaseDnsBindPermission();
    message.name = object.name ?? "";
    message.principals = object.principals?.map((e) => Principal.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrincipal(): Principal {
  return { user: undefined, serviceAccount: undefined };
}

export const Principal: MessageFns<Principal> = {
  encode(message: Principal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      writer.uint32(10).string(message.user);
    }
    if (message.serviceAccount !== undefined) {
      writer.uint32(18).string(message.serviceAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Principal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrincipal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Principal {
    return {
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : undefined,
    };
  },

  toJSON(message: Principal): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.serviceAccount !== undefined) {
      obj.serviceAccount = message.serviceAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<Principal>): Principal {
    return Principal.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Principal>): Principal {
    const message = createBasePrincipal();
    message.user = object.user ?? undefined;
    message.serviceAccount = object.serviceAccount ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
