// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/vmwareengine/v1/vmwareengine.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  Cluster,
  Credentials,
  DnsBindPermission,
  DnsForwarding,
  ExternalAccessRule,
  ExternalAddress,
  HcxActivationKey,
  LoggingServer,
  ManagementDnsZoneBinding,
  NetworkPeering,
  NetworkPolicy,
  Node,
  NodeType,
  PeeringRoute,
  Principal,
  PrivateCloud,
  PrivateConnection,
  Subnet,
  VmwareEngineNetwork,
} from "./vmwareengine_resources.js";

export const protobufPackage = "google.cloud.vmwareengine.v1";

/**
 * Request message for
 * [VmwareEngine.ListPrivateClouds][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateClouds]
 */
export interface ListPrivateCloudsRequest {
  /**
   * Required. The resource name of the private cloud to be queried for
   * clusters. Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a`
   */
  parent: string;
  /**
   * The maximum number of private clouds to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListPrivateClouds` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListPrivateClouds` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /**
   * A filter expression that matches resources returned in the response.
   * The expression must specify the field name, a comparison operator, and the
   * value that you want to use for filtering. The value must be a string, a
   * number, or a boolean. The comparison operator must be `=`, `!=`, `>`, or
   * `<`.
   *
   * For example, if you are filtering a list of private clouds, you can exclude
   * the ones named `example-pc` by specifying `name != "example-pc"`.
   *
   * You can also filter nested fields. For example, you could specify
   * `networkConfig.managementCidr = "192.168.0.0/24"` to include private clouds
   * only if they have a matching address in their network configuration.
   *
   * To filter on multiple expressions, provide each separate expression within
   * parentheses. For example:
   * ```
   * (name = "example-pc")
   * (createTime > "2021-04-12T08:15:10.40Z")
   * ```
   *
   * By default, each expression is an `AND` expression. However, you can
   * include `AND` and `OR` expressions explicitly. For example:
   * ```
   * (name = "private-cloud-1") AND
   * (createTime > "2021-04-12T08:15:10.40Z") OR
   * (name = "private-cloud-2")
   * ```
   */
  filter: string;
  /**
   * Sorts list results by a certain order. By default, returned results are
   * ordered by `name` in ascending order. You can also sort results in
   * descending order based on the `name` value using `orderBy="name desc"`.
   * Currently, only ordering by `name` is supported.
   */
  orderBy: string;
}

/**
 * Response message for
 * [VmwareEngine.ListPrivateClouds][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateClouds]
 */
export interface ListPrivateCloudsResponse {
  /** A list of private clouds. */
  privateClouds: PrivateCloud[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * Locations that could not be reached when making an aggregated query using
   * wildcards.
   */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.GetPrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.GetPrivateCloud]
 */
export interface GetPrivateCloudRequest {
  /**
   * Required. The resource name of the private cloud to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.CreatePrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.CreatePrivateCloud]
 */
export interface CreatePrivateCloudRequest {
  /**
   * Required. The resource name of the location to create the new
   * private cloud in. Resource names are schemeless URIs that follow the
   * conventions in https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a`
   */
  parent: string;
  /**
   * Required. The user-provided identifier of the private cloud to be created.
   * This identifier must be unique among each `PrivateCloud` within the parent
   * and becomes the final token in the name URI.
   * The identifier must meet the following requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
   * (section 3.5)
   */
  privateCloudId: string;
  /** Required. The initial description of the new private cloud. */
  privateCloud:
    | PrivateCloud
    | undefined;
  /**
   * Optional. The request ID must be a valid UUID with the exception that zero
   * UUID is not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. True if you want the request to be validated and not executed;
   * false otherwise.
   */
  validateOnly: boolean;
}

/**
 * Request message for
 * [VmwareEngine.UpdatePrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.UpdatePrivateCloud]
 */
export interface UpdatePrivateCloudRequest {
  /** Required. Private cloud description. */
  privateCloud:
    | PrivateCloud
    | undefined;
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `PrivateCloud` resource by the update. The fields specified in `updateMask`
   * are relative to the resource, not the full request. A field will be
   * overwritten if it is in the mask. If the user does not provide a mask then
   * all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. The request ID must be a valid UUID with the exception that zero
   * UUID is not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.DeletePrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.DeletePrivateCloud]
 */
export interface DeletePrivateCloudRequest {
  /**
   * Required. The resource name of the private cloud to delete.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  name: string;
  /**
   * Optional. The request ID must be a valid UUID with the exception that zero
   * UUID is not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, cascade delete is enabled and all children of
   * this private cloud resource are also deleted. When this flag is set to
   * false, the private cloud will not be deleted if there are any children
   * other than the management cluster. The management cluster is always
   * deleted.
   */
  force: boolean;
  /**
   * Optional. Time delay of the deletion specified in hours. The default value
   * is `3`. Specifying a non-zero value for this field changes the value of
   * `PrivateCloud.state` to `DELETED` and sets `expire_time` to the planned
   * deletion time. Deletion can be cancelled before `expire_time` elapses using
   * [VmwareEngine.UndeletePrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.UndeletePrivateCloud].
   * Specifying a value of `0` for this field instead begins the deletion
   * process and ceases billing immediately. During the final deletion process,
   * the value of `PrivateCloud.state` becomes `PURGING`.
   */
  delayHours?: number | undefined;
}

/**
 * Request message for
 * [VmwareEngine.UndeletePrivateCloud][google.cloud.vmwareengine.v1.VmwareEngine.UndeletePrivateCloud]
 */
export interface UndeletePrivateCloudRequest {
  /**
   * Required. The resource name of the private cloud scheduled for deletion.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  name: string;
  /**
   * Optional. The request ID must be a valid UUID with the exception that zero
   * UUID is not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.ListClusters][google.cloud.vmwareengine.v1.VmwareEngine.ListClusters]
 */
export interface ListClustersRequest {
  /**
   * Required. The resource name of the private cloud to query for clusters.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  parent: string;
  /**
   * The maximum number of clusters to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListClusters` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to `ListClusters`
   * must match the call that provided the page token.
   */
  pageToken: string;
  /**
   * To filter on multiple expressions, provide each separate expression within
   * parentheses. For example:
   * ```
   * (name = "example-cluster")
   * (nodeCount = "3")
   * ```
   *
   * By default, each expression is an `AND` expression. However, you can
   * include `AND` and `OR` expressions explicitly. For example:
   * ```
   * (name = "example-cluster-1") AND
   * (createTime > "2021-04-12T08:15:10.40Z") OR
   * (name = "example-cluster-2")
   * ```
   */
  filter: string;
  /**
   * Sorts list results by a certain order. By default, returned results are
   * ordered by `name` in ascending order. You can also sort results in
   * descending order based on the `name` value using `orderBy="name desc"`.
   * Currently, only ordering by `name` is supported.
   */
  orderBy: string;
}

/**
 * Response message for
 * [VmwareEngine.ListClusters][google.cloud.vmwareengine.v1.VmwareEngine.ListClusters]
 */
export interface ListClustersResponse {
  /** A list of private cloud clusters. */
  clusters: Cluster[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * Locations that could not be reached when making an aggregated query using
   * wildcards.
   */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.GetCluster][google.cloud.vmwareengine.v1.VmwareEngine.GetCluster]
 */
export interface GetClusterRequest {
  /**
   * Required. The cluster resource name to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/clusters/my-cluster`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.CreateCluster][google.cloud.vmwareengine.v1.VmwareEngine.CreateCluster]
 */
export interface CreateClusterRequest {
  /**
   * Required. The resource name of the private cloud to create a new cluster
   * in. Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  parent: string;
  /**
   * Required. The user-provided identifier of the new `Cluster`.
   * This identifier must be unique among clusters within the parent and becomes
   * the final token in the name URI.
   * The identifier must meet the following requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
   * (section 3.5)
   */
  clusterId: string;
  /** Required. The initial description of the new cluster. */
  cluster:
    | Cluster
    | undefined;
  /**
   * Optional. The request ID must be a valid UUID with the exception that zero
   * UUID is not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. True if you want the request to be validated and not executed;
   * false otherwise.
   */
  validateOnly: boolean;
}

/**
 * Request message for
 * [VmwareEngine.UpdateCluster][google.cloud.vmwareengine.v1.VmwareEngine.UpdateCluster]
 */
export interface UpdateClusterRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `Cluster` resource by the update. The fields specified in the `updateMask`
   * are relative to the resource, not the full request. A field will be
   * overwritten if it is in the mask. If the user does not provide a mask then
   * all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The description of the cluster. */
  cluster:
    | Cluster
    | undefined;
  /**
   * Optional. The request ID must be a valid UUID with the exception that
   * zero UUID is not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. True if you want the request to be validated and not executed;
   * false otherwise.
   */
  validateOnly: boolean;
}

/**
 * Request message for
 * [VmwareEngine.DeleteCluster][google.cloud.vmwareengine.v1.VmwareEngine.DeleteCluster]
 */
export interface DeleteClusterRequest {
  /**
   * Required. The resource name of the cluster to delete.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/clusters/my-cluster`
   */
  name: string;
  /**
   * Optional. The request ID must be a valid UUID with the exception that zero
   * UUID is not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.ListNodes][google.cloud.vmwareengine.v1.VmwareEngine.ListNodes]
 */
export interface ListNodesRequest {
  /**
   * Required. The resource name of the cluster to be queried for nodes.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/clusters/my-cluster`
   */
  parent: string;
  /**
   * The maximum number of nodes to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListNodes` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListNodes` must match the call that provided the page
   * token.
   */
  pageToken: string;
}

/**
 * Response message for
 * [VmwareEngine.ListNodes][google.cloud.vmwareengine.v1.VmwareEngine.ListNodes]
 */
export interface ListNodesResponse {
  /** The nodes. */
  nodes: Node[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [VmwareEngine.GetNode][google.cloud.vmwareengine.v1.VmwareEngine.GetNode]
 */
export interface GetNodeRequest {
  /**
   * Required. The resource name of the node to retrieve.
   * For example:
   * `projects/{project}/locations/{location}/privateClouds/{private_cloud}/clusters/{cluster}/nodes/{node}`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.ListExternalAddresses][google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAddresses]
 */
export interface ListExternalAddressesRequest {
  /**
   * Required. The resource name of the private cloud to be queried for
   * external IP addresses.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  parent: string;
  /**
   * The maximum number of external IP addresses to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListExternalAddresses` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListExternalAddresses` must match the call that provided the page token.
   */
  pageToken: string;
  /**
   * A filter expression that matches resources returned in the response.
   * The expression must specify the field name, a comparison
   * operator, and the value that you want to use for filtering. The value
   * must be a string, a number, or a boolean. The comparison operator
   * must be `=`, `!=`, `>`, or `<`.
   *
   * For example, if you are filtering a list of IP addresses, you can
   * exclude the ones named `example-ip` by specifying
   * `name != "example-ip"`.
   *
   * To filter on multiple expressions, provide each separate expression within
   * parentheses. For example:
   * ```
   * (name = "example-ip")
   * (createTime > "2021-04-12T08:15:10.40Z")
   * ```
   *
   * By default, each expression is an `AND` expression. However, you
   * can include `AND` and `OR` expressions explicitly.
   * For example:
   * ```
   * (name = "example-ip-1") AND
   * (createTime > "2021-04-12T08:15:10.40Z") OR
   * (name = "example-ip-2")
   * ```
   */
  filter: string;
  /**
   * Sorts list results by a certain order. By default, returned results
   * are ordered by `name` in ascending order.
   * You can also sort results in descending order based on the `name` value
   * using `orderBy="name desc"`.
   * Currently, only ordering by `name` is supported.
   */
  orderBy: string;
}

/**
 * Response message for
 * [VmwareEngine.ListExternalAddresses][google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAddresses]
 */
export interface ListExternalAddressesResponse {
  /** A list of external IP addresses. */
  externalAddresses: ExternalAddress[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * Locations that could not be reached when making an aggregated query using
   * wildcards.
   */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.FetchNetworkPolicyExternalAddresses][google.cloud.vmwareengine.v1.VmwareEngine.FetchNetworkPolicyExternalAddresses]
 */
export interface FetchNetworkPolicyExternalAddressesRequest {
  /**
   * Required. The resource name of the network policy to query for assigned
   * external IP addresses. Resource names are schemeless URIs that follow the
   * conventions in https://cloud.google.com/apis/design/resource_names. For
   * example:
   * `projects/my-project/locations/us-central1/networkPolicies/my-policy`
   */
  networkPolicy: string;
  /**
   * The maximum number of external IP addresses to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous
   * `FetchNetworkPolicyExternalAddresses` call. Provide this to retrieve the
   * subsequent page.
   *
   * When paginating, all parameters provided to
   * `FetchNetworkPolicyExternalAddresses`, except for `page_size` and
   * `page_token`, must match the call that provided the page token.
   */
  pageToken: string;
}

/**
 * Response message for
 * [VmwareEngine.FetchNetworkPolicyExternalAddresses][google.cloud.vmwareengine.v1.VmwareEngine.FetchNetworkPolicyExternalAddresses]
 */
export interface FetchNetworkPolicyExternalAddressesResponse {
  /**
   * A list of external IP addresses assigned to VMware workload VMs within the
   * scope of the given network policy.
   */
  externalAddresses: ExternalAddress[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [VmwareEngine.GetExternalAddress][google.cloud.vmwareengine.v1.VmwareEngine.GetExternalAddress]
 */
export interface GetExternalAddressRequest {
  /**
   * Required. The resource name of the external IP address to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/externalAddresses/my-ip`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.CreateExternalAddress][google.cloud.vmwareengine.v1.VmwareEngine.CreateExternalAddress]
 */
export interface CreateExternalAddressRequest {
  /**
   * Required. The resource name of the private cloud
   * to create a new external IP address in.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  parent: string;
  /** Required. The initial description of a new external IP address. */
  externalAddress:
    | ExternalAddress
    | undefined;
  /**
   * Required. The user-provided identifier of the `ExternalAddress` to be
   * created. This identifier must be unique among `ExternalAddress` resources
   * within the parent and becomes the final token in the name URI. The
   * identifier must meet the following requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
   * (section 3.5)
   */
  externalAddressId: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if the original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.UpdateExternalAddress][google.cloud.vmwareengine.v1.VmwareEngine.UpdateExternalAddress]
 */
export interface UpdateExternalAddressRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `ExternalAddress` resource by the update.
   * The fields specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. External IP address description. */
  externalAddress:
    | ExternalAddress
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if the original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.DeleteExternalAddress][google.cloud.vmwareengine.v1.VmwareEngine.DeleteExternalAddress]
 */
export interface DeleteExternalAddressRequest {
  /**
   * Required. The resource name of the external IP address to delete.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/externalAddresses/my-ip`
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if the original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.ListSubnets][google.cloud.vmwareengine.v1.VmwareEngine.ListSubnets]
 */
export interface ListSubnetsRequest {
  /**
   * Required. The resource name of the private cloud to be queried for
   * subnets.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  parent: string;
  /**
   * The maximum number of subnets to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListSubnetsRequest` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListSubnetsRequest` must match the call that provided the page token.
   */
  pageToken: string;
}

/**
 * Response message for
 * [VmwareEngine.ListSubnets][google.cloud.vmwareengine.v1.VmwareEngine.ListSubnets]
 */
export interface ListSubnetsResponse {
  /** A list of subnets. */
  subnets: Subnet[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * Locations that could not be reached when making an aggregated query using
   * wildcards.
   */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.GetSubnet][google.cloud.vmwareengine.v1.VmwareEngine.GetSubnet]
 */
export interface GetSubnetRequest {
  /**
   * Required. The resource name of the subnet to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/subnets/my-subnet`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.UpdateSubnet][google.cloud.vmwareengine.v1.VmwareEngine.UpdateSubnet]
 */
export interface UpdateSubnetRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `Subnet` resource by the update.
   * The fields specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. Subnet description. */
  subnet: Subnet | undefined;
}

/**
 * Request message for
 * [VmwareEngine.ListExternalAccessRules][google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAccessRules]
 */
export interface ListExternalAccessRulesRequest {
  /**
   * Required. The resource name of the network policy to query for external
   * access firewall rules. Resource names are schemeless URIs that follow the
   * conventions in https://cloud.google.com/apis/design/resource_names. For
   * example:
   * `projects/my-project/locations/us-central1/networkPolicies/my-policy`
   */
  parent: string;
  /**
   * The maximum number of external access rules to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListExternalAccessRulesRequest`
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListExternalAccessRulesRequest` must match the call that provided the page
   * token.
   */
  pageToken: string;
  /**
   * A filter expression that matches resources returned in the response.
   * The expression must specify the field name, a comparison
   * operator, and the value that you want to use for filtering. The value
   * must be a string, a number, or a boolean. The comparison operator
   * must be `=`, `!=`, `>`, or `<`.
   *
   * For example, if you are filtering a list of external access rules, you can
   * exclude the ones named `example-rule` by specifying
   * `name != "example-rule"`.
   *
   * To filter on multiple expressions, provide each separate expression within
   * parentheses. For example:
   * ```
   * (name = "example-rule")
   * (createTime > "2021-04-12T08:15:10.40Z")
   * ```
   *
   * By default, each expression is an `AND` expression. However, you
   * can include `AND` and `OR` expressions explicitly.
   * For example:
   * ```
   * (name = "example-rule-1") AND
   * (createTime > "2021-04-12T08:15:10.40Z") OR
   * (name = "example-rule-2")
   * ```
   */
  filter: string;
  /**
   * Sorts list results by a certain order. By default, returned results
   * are ordered by `name` in ascending order.
   * You can also sort results in descending order based on the `name` value
   * using `orderBy="name desc"`.
   * Currently, only ordering by `name` is supported.
   */
  orderBy: string;
}

/**
 * Response message for
 * [VmwareEngine.ListExternalAccessRules][google.cloud.vmwareengine.v1.VmwareEngine.ListExternalAccessRules]
 */
export interface ListExternalAccessRulesResponse {
  /** A list of external access firewall rules. */
  externalAccessRules: ExternalAccessRule[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * Locations that could not be reached when making an aggregated query using
   * wildcards.
   */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.GetExternalAccessRule][google.cloud.vmwareengine.v1.VmwareEngine.GetExternalAccessRule]
 */
export interface GetExternalAccessRuleRequest {
  /**
   * Required. The resource name of the external access firewall rule to
   * retrieve. Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/networkPolicies/my-policy/externalAccessRules/my-rule`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.CreateExternalAccessRule][google.cloud.vmwareengine.v1.VmwareEngine.CreateExternalAccessRule]
 */
export interface CreateExternalAccessRuleRequest {
  /**
   * Required. The resource name of the network policy
   * to create a new external access firewall rule in.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/networkPolicies/my-policy`
   */
  parent: string;
  /** Required. The initial description of a new external access rule. */
  externalAccessRule:
    | ExternalAccessRule
    | undefined;
  /**
   * Required. The user-provided identifier of the `ExternalAccessRule` to be
   * created. This identifier must be unique among `ExternalAccessRule`
   * resources within the parent and becomes the final token in the name URI.
   * The identifier must meet the following requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
   * (section 3.5)
   */
  externalAccessRuleId: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if the original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.UpdateExternalAccessRule][google.cloud.vmwareengine.v1.VmwareEngine.UpdateExternalAccessRule]
 */
export interface UpdateExternalAccessRuleRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `ExternalAccessRule` resource by the update.
   * The fields specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. Description of the external access rule. */
  externalAccessRule:
    | ExternalAccessRule
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if the original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.DeleteExternalAccessRule][google.cloud.vmwareengine.v1.VmwareEngine.DeleteExternalAccessRule]
 */
export interface DeleteExternalAccessRuleRequest {
  /**
   * Required. The resource name of the external access firewall rule to delete.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/networkPolicies/my-policy/externalAccessRules/my-rule`
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if the original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.ListLoggingServers][google.cloud.vmwareengine.v1.VmwareEngine.ListLoggingServers]
 */
export interface ListLoggingServersRequest {
  /**
   * Required. The resource name of the private cloud to be queried for
   * logging servers.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  parent: string;
  /**
   * The maximum number of logging servers to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListLoggingServersRequest` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListLoggingServersRequest` must match the call that provided the page
   * token.
   */
  pageToken: string;
  /**
   * A filter expression that matches resources returned in the response.
   * The expression must specify the field name, a comparison
   * operator, and the value that you want to use for filtering. The value
   * must be a string, a number, or a boolean. The comparison operator
   * must be `=`, `!=`, `>`, or `<`.
   *
   * For example, if you are filtering a list of logging servers, you can
   * exclude the ones named `example-server` by specifying
   * `name != "example-server"`.
   *
   * To filter on multiple expressions, provide each separate expression within
   * parentheses. For example:
   * ```
   * (name = "example-server")
   * (createTime > "2021-04-12T08:15:10.40Z")
   * ```
   *
   * By default, each expression is an `AND` expression. However, you
   * can include `AND` and `OR` expressions explicitly.
   * For example:
   * ```
   * (name = "example-server-1") AND
   * (createTime > "2021-04-12T08:15:10.40Z") OR
   * (name = "example-server-2")
   * ```
   */
  filter: string;
  /**
   * Sorts list results by a certain order. By default, returned results
   * are ordered by `name` in ascending order.
   * You can also sort results in descending order based on the `name` value
   * using `orderBy="name desc"`.
   * Currently, only ordering by `name` is supported.
   */
  orderBy: string;
}

/**
 * Response message for
 * [VmwareEngine.ListLoggingServers][google.cloud.vmwareengine.v1.VmwareEngine.ListLoggingServers]
 */
export interface ListLoggingServersResponse {
  /** A list of Logging Servers. */
  loggingServers: LoggingServer[];
  /**
   * A token, which can be send as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * Locations that could not be reached when making an aggregated query using
   * wildcards.
   */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.GetLoggingServer][google.cloud.vmwareengine.v1.VmwareEngine.GetLoggingServer]
 */
export interface GetLoggingServerRequest {
  /**
   * Required. The resource name of the Logging Server to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/loggingServers/my-logging-server`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.CreateLoggingServer][google.cloud.vmwareengine.v1.VmwareEngine.CreateLoggingServer]
 */
export interface CreateLoggingServerRequest {
  /**
   * Required. The resource name of the private cloud
   * to create a new Logging Server in.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  parent: string;
  /** Required. The initial description of a new logging server. */
  loggingServer:
    | LoggingServer
    | undefined;
  /**
   * Required. The user-provided identifier of the `LoggingServer` to be
   * created. This identifier must be unique among `LoggingServer` resources
   * within the parent and becomes the final token in the name URI.
   * The identifier must meet the following requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
   * (section 3.5)
   */
  loggingServerId: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.UpdateLoggingServer][google.cloud.vmwareengine.v1.VmwareEngine.UpdateLoggingServer]
 */
export interface UpdateLoggingServerRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `LoggingServer` resource by the update.
   * The fields specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. Logging server description. */
  loggingServer:
    | LoggingServer
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.DeleteLoggingServer][google.cloud.vmwareengine.v1.VmwareEngine.DeleteLoggingServer]
 */
export interface DeleteLoggingServerRequest {
  /**
   * Required. The resource name of the logging server to delete.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/loggingServers/my-logging-server`
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. True if the user has requested cancellation
   * of the operation; false otherwise.
   * Operations that have successfully been cancelled
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

/**
 * Request message for
 * [VmwareEngine.ListNodeTypes][google.cloud.vmwareengine.v1.VmwareEngine.ListNodeTypes]
 */
export interface ListNodeTypesRequest {
  /**
   * Required. The resource name of the location to be queried for node types.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a`
   */
  parent: string;
  /**
   * The maximum number of node types to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListNodeTypes` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListNodeTypes` must match the call that provided the page token.
   */
  pageToken: string;
  /**
   * A filter expression that matches resources returned in the response.
   * The expression must specify the field name, a comparison
   * operator, and the value that you want to use for filtering. The value
   * must be a string, a number, or a boolean. The comparison operator
   * must be `=`, `!=`, `>`, or `<`.
   *
   * For example, if you are filtering a list of node types, you can
   * exclude the ones named `standard-72` by specifying
   * `name != "standard-72"`.
   *
   * To filter on multiple expressions, provide each separate expression within
   * parentheses. For example:
   * ```
   * (name = "standard-72")
   * (virtual_cpu_count > 2)
   * ```
   *
   * By default, each expression is an `AND` expression. However, you
   * can include `AND` and `OR` expressions explicitly.
   * For example:
   * ```
   * (name = "standard-96") AND
   * (virtual_cpu_count > 2) OR
   * (name = "standard-72")
   * ```
   */
  filter: string;
}

/**
 * Response message for
 * [VmwareEngine.ListNodeTypes][google.cloud.vmwareengine.v1.VmwareEngine.ListNodeTypes]
 */
export interface ListNodeTypesResponse {
  /** A list of Node Types. */
  nodeTypes: NodeType[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * Locations that could not be reached when making an aggregated query using
   * wildcards.
   */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.GetNodeType][google.cloud.vmwareengine.v1.VmwareEngine.GetNodeType]
 */
export interface GetNodeTypeRequest {
  /**
   * Required. The resource name of the node type to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-proj/locations/us-central1-a/nodeTypes/standard-72`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.ShowNsxCredentials][google.cloud.vmwareengine.v1.VmwareEngine.ShowNsxCredentials]
 */
export interface ShowNsxCredentialsRequest {
  /**
   * Required. The resource name of the private cloud
   * to be queried for credentials.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  privateCloud: string;
}

/**
 * Request message for
 * [VmwareEngine.ShowVcenterCredentials][google.cloud.vmwareengine.v1.VmwareEngine.ShowVcenterCredentials]
 */
export interface ShowVcenterCredentialsRequest {
  /**
   * Required. The resource name of the private cloud
   * to be queried for credentials.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  privateCloud: string;
  /**
   * Optional. The username of the user to be queried for credentials.
   * The default value of this field is CloudOwner@gve.local.
   * The provided value must be one of the following:
   * CloudOwner@gve.local,
   * solution-user-01@gve.local,
   * solution-user-02@gve.local,
   * solution-user-03@gve.local,
   * solution-user-04@gve.local,
   * solution-user-05@gve.local,
   * zertoadmin@gve.local.
   */
  username: string;
}

/**
 * Request message for
 * [VmwareEngine.ResetNsxCredentials][google.cloud.vmwareengine.v1.VmwareEngine.ResetNsxCredentials]
 */
export interface ResetNsxCredentialsRequest {
  /**
   * Required. The resource name of the private cloud
   * to reset credentials for.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  privateCloud: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.ResetVcenterCredentials][google.cloud.vmwareengine.v1.VmwareEngine.ResetVcenterCredentials]
 */
export interface ResetVcenterCredentialsRequest {
  /**
   * Required. The resource name of the private cloud
   * to reset credentials for.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  privateCloud: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. The username of the user to be to reset the credentials.
   * The default value of this field is CloudOwner@gve.local.
   * The provided value should be one of the following:
   * solution-user-01@gve.local,
   * solution-user-02@gve.local,
   * solution-user-03@gve.local,
   * solution-user-04@gve.local,
   * solution-user-05@gve.local,
   * zertoadmin@gve.local.
   */
  username: string;
}

/**
 * Response message for
 * [VmwareEngine.ListHcxActivationKeys][google.cloud.vmwareengine.v1.VmwareEngine.ListHcxActivationKeys]
 */
export interface ListHcxActivationKeysResponse {
  /** List of HCX activation keys. */
  hcxActivationKeys: HcxActivationKey[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * Locations that could not be reached when making an aggregated query using
   * wildcards.
   */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.ListHcxActivationKeys][google.cloud.vmwareengine.v1.VmwareEngine.ListHcxActivationKeys]
 */
export interface ListHcxActivationKeysRequest {
  /**
   * Required. The resource name of the private cloud
   * to be queried for HCX activation keys.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/privateClouds/my-cloud`
   */
  parent: string;
  /**
   * The maximum number of HCX activation keys to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListHcxActivationKeys` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListHcxActivationKeys` must match the call that provided the page
   * token.
   */
  pageToken: string;
}

/** Request message for [VmwareEngine.GetHcxActivationKeys][] */
export interface GetHcxActivationKeyRequest {
  /**
   * Required. The resource name of the HCX activation key to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/privateClouds/my-cloud/hcxActivationKeys/my-key`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.CreateHcxActivationKey][google.cloud.vmwareengine.v1.VmwareEngine.CreateHcxActivationKey]
 */
export interface CreateHcxActivationKeyRequest {
  /**
   * Required. The resource name of the private cloud to create the key for.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/privateClouds/my-cloud`
   */
  parent: string;
  /**
   * Required. The initial description of a new HCX activation key. When
   * creating a new key, this field must be an empty object.
   */
  hcxActivationKey:
    | HcxActivationKey
    | undefined;
  /**
   * Required. The user-provided identifier of the `HcxActivationKey` to be
   * created. This identifier must be unique among `HcxActivationKey` resources
   * within the parent and becomes the final token in the name URI.
   * The identifier must meet the following requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
   * (section 3.5)
   */
  hcxActivationKeyId: string;
  /**
   * A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.GetDnsForwarding][google.cloud.vmwareengine.v1.VmwareEngine.GetDnsForwarding]
 */
export interface GetDnsForwardingRequest {
  /**
   * Required. The resource name of a `DnsForwarding` to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/dnsForwarding`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.UpdateDnsForwarding][google.cloud.vmwareengine.v1.VmwareEngine.UpdateDnsForwarding]
 */
export interface UpdateDnsForwardingRequest {
  /** Required. DnsForwarding config details. */
  dnsForwarding:
    | DnsForwarding
    | undefined;
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `DnsForwarding` resource by the update.
   * The fields specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.CreateNetworkPeering][google.cloud.vmwareengine.v1.VmwareEngine.CreateNetworkPeering]
 */
export interface CreateNetworkPeeringRequest {
  /**
   * Required. The resource name of the location to create the new network
   * peering in. This value is always `global`, because `NetworkPeering` is a
   * global resource. Resource names are schemeless URIs that follow the
   * conventions in https://cloud.google.com/apis/design/resource_names. For
   * example: `projects/my-project/locations/global`
   */
  parent: string;
  /**
   * Required. The user-provided identifier of the new `NetworkPeering`.
   * This identifier must be unique among `NetworkPeering` resources within the
   * parent and becomes the final token in the name URI.
   * The identifier must meet the following requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
   * (section 3.5)
   */
  networkPeeringId: string;
  /** Required. The initial description of the new network peering. */
  networkPeering:
    | NetworkPeering
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.DeleteNetworkPeering][google.cloud.vmwareengine.v1.VmwareEngine.DeleteNetworkPeering]
 */
export interface DeleteNetworkPeeringRequest {
  /**
   * Required. The resource name of the network peering to be deleted.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/global/networkPeerings/my-peering`
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.GetNetworkPeering][google.cloud.vmwareengine.v1.VmwareEngine.GetNetworkPeering]
 */
export interface GetNetworkPeeringRequest {
  /**
   * Required. The resource name of the network peering to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/global/networkPeerings/my-peering`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.ListNetworkPeerings][google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPeerings]
 */
export interface ListNetworkPeeringsRequest {
  /**
   * Required. The resource name of the location (global) to query for
   * network peerings. Resource names are schemeless URIs that follow the
   * conventions in https://cloud.google.com/apis/design/resource_names. For
   * example: `projects/my-project/locations/global`
   */
  parent: string;
  /**
   * The maximum number of network peerings to return in one page.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListNetworkPeerings` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListNetworkPeerings` must match the call that provided the page
   * token.
   */
  pageToken: string;
  /**
   * A filter expression that matches resources returned in the response.
   * The expression must specify the field name, a comparison
   * operator, and the value that you want to use for filtering. The value
   * must be a string, a number, or a boolean. The comparison operator
   * must be `=`, `!=`, `>`, or `<`.
   *
   * For example, if you are filtering a list of network peerings, you can
   * exclude the ones named `example-peering` by specifying
   * `name != "example-peering"`.
   *
   * To filter on multiple expressions, provide each separate expression within
   * parentheses. For example:
   * ```
   * (name = "example-peering")
   * (createTime > "2021-04-12T08:15:10.40Z")
   * ```
   *
   * By default, each expression is an `AND` expression. However, you
   * can include `AND` and `OR` expressions explicitly.
   * For example:
   * ```
   * (name = "example-peering-1") AND
   * (createTime > "2021-04-12T08:15:10.40Z") OR
   * (name = "example-peering-2")
   * ```
   */
  filter: string;
  /**
   * Sorts list results by a certain order. By default, returned results
   * are ordered by `name` in ascending order.
   * You can also sort results in descending order based on the `name` value
   * using `orderBy="name desc"`.
   * Currently, only ordering by `name` is supported.
   */
  orderBy: string;
}

/**
 * Request message for
 * [VmwareEngine.UpdateNetworkPeering][google.cloud.vmwareengine.v1.VmwareEngine.UpdateNetworkPeering]
 */
export interface UpdateNetworkPeeringRequest {
  /** Required. Network peering description. */
  networkPeering:
    | NetworkPeering
    | undefined;
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `NetworkPeering` resource by the update.
   * The fields specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Response message for
 * [VmwareEngine.ListNetworkPeerings][google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPeerings]
 */
export interface ListNetworkPeeringsResponse {
  /** A list of network peerings. */
  networkPeerings: NetworkPeering[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Unreachable resources. */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.ListPeeringRoutes][google.cloud.vmwareengine.v1.VmwareEngine.ListPeeringRoutes]
 */
export interface ListPeeringRoutesRequest {
  /**
   * Required. The resource name of the network peering to retrieve peering
   * routes from. Resource names are schemeless URIs that follow the conventions
   * in https://cloud.google.com/apis/design/resource_names. For example:
   * `projects/my-project/locations/global/networkPeerings/my-peering`
   */
  parent: string;
  /**
   * The maximum number of peering routes to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListPeeringRoutes` call.
   * Provide this to retrieve the subsequent page.
   * When paginating, all other parameters provided to `ListPeeringRoutes` must
   * match the call that provided the page token.
   */
  pageToken: string;
  /**
   * A filter expression that matches resources returned in the response.
   * Currently, only filtering on the `direction` field is supported. To return
   * routes imported from the peer network, provide "direction=INCOMING". To
   * return routes exported from the VMware Engine network, provide
   * "direction=OUTGOING". Other filter expressions return an error.
   */
  filter: string;
}

/**
 * Response message for
 * [VmwareEngine.ListPeeringRoutes][google.cloud.vmwareengine.v1.VmwareEngine.ListPeeringRoutes]
 */
export interface ListPeeringRoutesResponse {
  /** A list of peering routes. */
  peeringRoutes: PeeringRoute[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [VmwareEngine.ListNetworkPolicies][google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPolicies]
 */
export interface ListNetworkPoliciesRequest {
  /**
   * Required. The resource name of the location (region) to query for
   * network policies. Resource names are schemeless URIs that follow the
   * conventions in https://cloud.google.com/apis/design/resource_names. For
   * example: `projects/my-project/locations/us-central1`
   */
  parent: string;
  /**
   * The maximum number of network policies to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListNetworkPolicies` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListNetworkPolicies` must match the call that provided the page
   * token.
   */
  pageToken: string;
  /**
   * A filter expression that matches resources returned in the response.
   * The expression must specify the field name, a comparison
   * operator, and the value that you want to use for filtering. The value
   * must be a string, a number, or a boolean. The comparison operator
   * must be `=`, `!=`, `>`, or `<`.
   *
   * For example, if you are filtering a list of network policies, you can
   * exclude the ones named `example-policy` by specifying
   * `name != "example-policy"`.
   *
   * To filter on multiple expressions, provide each separate expression within
   * parentheses. For example:
   * ```
   * (name = "example-policy")
   * (createTime > "2021-04-12T08:15:10.40Z")
   * ```
   *
   * By default, each expression is an `AND` expression. However, you
   * can include `AND` and `OR` expressions explicitly.
   * For example:
   * ```
   * (name = "example-policy-1") AND
   * (createTime > "2021-04-12T08:15:10.40Z") OR
   * (name = "example-policy-2")
   * ```
   */
  filter: string;
  /**
   * Sorts list results by a certain order. By default, returned results
   * are ordered by `name` in ascending order.
   * You can also sort results in descending order based on the `name` value
   * using `orderBy="name desc"`.
   * Currently, only ordering by `name` is supported.
   */
  orderBy: string;
}

/**
 * Response message for
 * [VmwareEngine.ListNetworkPolicies][google.cloud.vmwareengine.v1.VmwareEngine.ListNetworkPolicies]
 */
export interface ListNetworkPoliciesResponse {
  /** A list of network policies. */
  networkPolicies: NetworkPolicy[];
  /**
   * A token, which can be send as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * Locations that could not be reached when making an aggregated query using
   * wildcards.
   */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.GetNetworkPolicy][google.cloud.vmwareengine.v1.VmwareEngine.GetNetworkPolicy]
 */
export interface GetNetworkPolicyRequest {
  /**
   * Required. The resource name of the network policy to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/networkPolicies/my-network-policy`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.UpdateNetworkPolicy][google.cloud.vmwareengine.v1.VmwareEngine.UpdateNetworkPolicy]
 */
export interface UpdateNetworkPolicyRequest {
  /** Required. Network policy description. */
  networkPolicy:
    | NetworkPolicy
    | undefined;
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `NetworkPolicy` resource by the update.
   * The fields specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.CreateNetworkPolicy][google.cloud.vmwareengine.v1.VmwareEngine.CreateNetworkPolicy]
 */
export interface CreateNetworkPolicyRequest {
  /**
   * Required. The resource name of the location (region)
   * to create the new network policy in.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   *  `projects/my-project/locations/us-central1`
   */
  parent: string;
  /**
   * Required. The user-provided identifier of the network policy to be created.
   * This identifier must be unique within parent
   * `projects/{my-project}/locations/{us-central1}/networkPolicies` and becomes
   * the final token in the name URI.
   * The identifier must meet the following requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
   * (section 3.5)
   */
  networkPolicyId: string;
  /** Required. The network policy configuration to use in the request. */
  networkPolicy:
    | NetworkPolicy
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.DeleteNetworkPolicy][google.cloud.vmwareengine.v1.VmwareEngine.DeleteNetworkPolicy]
 */
export interface DeleteNetworkPolicyRequest {
  /**
   * Required. The resource name of the network policy to delete.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/networkPolicies/my-network-policy`
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.ListManagementDnsZoneBindings][google.cloud.vmwareengine.v1.VmwareEngine.ListManagementDnsZoneBindings]
 */
export interface ListManagementDnsZoneBindingsRequest {
  /**
   * Required. The resource name of the private cloud to be queried for
   * management DNS zone bindings.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  parent: string;
  /**
   * The maximum number of management DNS zone bindings to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListManagementDnsZoneBindings`
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListManagementDnsZoneBindings` must match the call that provided the page
   * token.
   */
  pageToken: string;
  /**
   * A filter expression that matches resources returned in the response.
   * The expression must specify the field name, a comparison
   * operator, and the value that you want to use for filtering. The value
   * must be a string, a number, or a boolean. The comparison operator
   * must be `=`, `!=`, `>`, or `<`.
   *
   * For example, if you are filtering a list of Management DNS Zone Bindings,
   * you can exclude the ones named `example-management-dns-zone-binding` by
   * specifying `name != "example-management-dns-zone-binding"`.
   *
   * To filter on multiple expressions, provide each separate expression within
   * parentheses. For example:
   * ```
   * (name = "example-management-dns-zone-binding")
   * (createTime > "2021-04-12T08:15:10.40Z")
   * ```
   *
   * By default, each expression is an `AND` expression. However, you
   * can include `AND` and `OR` expressions explicitly.
   * For example:
   * ```
   * (name = "example-management-dns-zone-binding-1") AND
   * (createTime > "2021-04-12T08:15:10.40Z") OR
   * (name = "example-management-dns-zone-binding-2")
   * ```
   */
  filter: string;
  /**
   * Sorts list results by a certain order. By default, returned results
   * are ordered by `name` in ascending order.
   * You can also sort results in descending order based on the `name` value
   * using `orderBy="name desc"`.
   * Currently, only ordering by `name` is supported.
   */
  orderBy: string;
}

/**
 * Response message for
 * [VmwareEngine.ListManagementDnsZoneBindings][google.cloud.vmwareengine.v1.VmwareEngine.ListManagementDnsZoneBindings]
 */
export interface ListManagementDnsZoneBindingsResponse {
  /** A list of management DNS zone bindings. */
  managementDnsZoneBindings: ManagementDnsZoneBinding[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /**
   * Locations that could not be reached when making an aggregated query using
   * wildcards.
   */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.GetManagementDnsZoneBinding][google.cloud.vmwareengine.v1.VmwareEngine.GetManagementDnsZoneBinding]
 */
export interface GetManagementDnsZoneBindingRequest {
  /**
   * Required. The resource name of the management DNS zone binding to
   * retrieve. Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/managementDnsZoneBindings/my-management-dns-zone-binding`
   */
  name: string;
}

/** Request message for [VmwareEngine.CreateManagementDnsZoneBindings][] */
export interface CreateManagementDnsZoneBindingRequest {
  /**
   * Required. The resource name of the private cloud
   * to create a new management DNS zone binding for.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud`
   */
  parent: string;
  /** Required. The initial values for a new management DNS zone binding. */
  managementDnsZoneBinding:
    | ManagementDnsZoneBinding
    | undefined;
  /**
   * Required. The user-provided identifier of the `ManagementDnsZoneBinding`
   * resource to be created. This identifier must be unique among
   * `ManagementDnsZoneBinding` resources within the parent and becomes the
   * final token in the name URI. The identifier must meet the following
   * requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
   * (section 3.5)
   */
  managementDnsZoneBindingId: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if the original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.UpdateManagementDnsZoneBinding][google.cloud.vmwareengine.v1.VmwareEngine.UpdateManagementDnsZoneBinding]
 */
export interface UpdateManagementDnsZoneBindingRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `ManagementDnsZoneBinding` resource by the update.
   * The fields specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. New values to update the management DNS zone binding with. */
  managementDnsZoneBinding:
    | ManagementDnsZoneBinding
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if the original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.DeleteManagementDnsZoneBinding][google.cloud.vmwareengine.v1.VmwareEngine.DeleteManagementDnsZoneBinding]
 */
export interface DeleteManagementDnsZoneBindingRequest {
  /**
   * Required. The resource name of the management DNS zone binding to delete.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/managementDnsZoneBindings/my-management-dns-zone-binding`
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if the original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for [VmwareEngine.RepairManagementDnsZoneBindings][] */
export interface RepairManagementDnsZoneBindingRequest {
  /**
   * Required. The resource name of the management DNS zone binding to repair.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1-a/privateClouds/my-cloud/managementDnsZoneBindings/my-management-dns-zone-binding`
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request ID,
   * the server can check if the original operation with the same request ID was
   * received, and if so, will ignore the second request. This prevents clients
   * from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.CreateVmwareEngineNetwork][google.cloud.vmwareengine.v1.VmwareEngine.CreateVmwareEngineNetwork]
 */
export interface CreateVmwareEngineNetworkRequest {
  /**
   * Required. The resource name of the location to create the new VMware Engine
   * network in. A VMware Engine network of type
   * `LEGACY` is a regional resource, and a VMware
   * Engine network of type `STANDARD` is a global resource.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names. For example:
   * `projects/my-project/locations/global`
   */
  parent: string;
  /**
   * Required. The user-provided identifier of the new VMware Engine network.
   * This identifier must be unique among VMware Engine network resources
   * within the parent and becomes the final token in the name URI. The
   * identifier must meet the following requirements:
   *
   * * For networks of type LEGACY, adheres to the format:
   * `{region-id}-default`. Replace `{region-id}` with the region where you want
   * to create the VMware Engine network. For example, "us-central1-default".
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
   * (section 3.5)
   */
  vmwareEngineNetworkId: string;
  /** Required. The initial description of the new VMware Engine network. */
  vmwareEngineNetwork:
    | VmwareEngineNetwork
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.UpdateVmwareEngineNetwork][google.cloud.vmwareengine.v1.VmwareEngine.UpdateVmwareEngineNetwork]
 */
export interface UpdateVmwareEngineNetworkRequest {
  /** Required. VMware Engine network description. */
  vmwareEngineNetwork:
    | VmwareEngineNetwork
    | undefined;
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * VMware Engine network resource by the update.
   * The fields specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten. Only the
   * following fields can be updated: `description`.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.DeleteVmwareEngineNetwork][google.cloud.vmwareengine.v1.VmwareEngine.DeleteVmwareEngineNetwork]
 */
export interface DeleteVmwareEngineNetworkRequest {
  /**
   * Required. The resource name of the VMware Engine network to be deleted.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/global/vmwareEngineNetworks/my-network`
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. Checksum used to ensure that the user-provided value is up to
   * date before the server processes the request. The server compares provided
   * checksum with the current checksum of the resource. If the user-provided
   * value is out of date, this request returns an `ABORTED` error.
   */
  etag: string;
}

/**
 * Request message for
 * [VmwareEngine.GetVmwareEngineNetwork][google.cloud.vmwareengine.v1.VmwareEngine.GetVmwareEngineNetwork]
 */
export interface GetVmwareEngineNetworkRequest {
  /**
   * Required. The resource name of the VMware Engine network to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/global/vmwareEngineNetworks/my-network`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.ListVmwareEngineNetworks][google.cloud.vmwareengine.v1.VmwareEngine.ListVmwareEngineNetworks]
 */
export interface ListVmwareEngineNetworksRequest {
  /**
   * Required. The resource name of the location to query for
   * VMware Engine networks. Resource names are schemeless URIs that follow the
   * conventions in https://cloud.google.com/apis/design/resource_names. For
   * example: `projects/my-project/locations/global`
   */
  parent: string;
  /**
   * The maximum number of results to return in one page.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListVmwareEngineNetworks` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListVmwareEngineNetworks` must match the call that provided the page
   * token.
   */
  pageToken: string;
  /**
   * A filter expression that matches resources returned in the response.
   * The expression must specify the field name, a comparison
   * operator, and the value that you want to use for filtering. The value
   * must be a string, a number, or a boolean. The comparison operator
   * must be `=`, `!=`, `>`, or `<`.
   *
   * For example, if you are filtering a list of network peerings, you can
   * exclude the ones named `example-network` by specifying
   * `name != "example-network"`.
   *
   * To filter on multiple expressions, provide each separate expression within
   * parentheses. For example:
   * ```
   * (name = "example-network")
   * (createTime > "2021-04-12T08:15:10.40Z")
   * ```
   *
   * By default, each expression is an `AND` expression. However, you
   * can include `AND` and `OR` expressions explicitly.
   * For example:
   * ```
   * (name = "example-network-1") AND
   * (createTime > "2021-04-12T08:15:10.40Z") OR
   * (name = "example-network-2")
   * ```
   */
  filter: string;
  /**
   * Sorts list results by a certain order. By default, returned results
   * are ordered by `name` in ascending order.
   * You can also sort results in descending order based on the `name` value
   * using `orderBy="name desc"`.
   * Currently, only ordering by `name` is supported.
   */
  orderBy: string;
}

/**
 * Response message for
 * [VmwareEngine.ListVmwareEngineNetworks][google.cloud.vmwareengine.v1.VmwareEngine.ListVmwareEngineNetworks]
 */
export interface ListVmwareEngineNetworksResponse {
  /** A list of VMware Engine networks. */
  vmwareEngineNetworks: VmwareEngineNetwork[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Unreachable resources. */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.CreatePrivateConnection][google.cloud.vmwareengine.v1.VmwareEngine.CreatePrivateConnection]
 */
export interface CreatePrivateConnectionRequest {
  /**
   * Required. The resource name of the location to create the new private
   * connection in. Private connection is a regional resource.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names. For example:
   * `projects/my-project/locations/us-central1`
   */
  parent: string;
  /**
   * Required. The user-provided identifier of the new private connection.
   * This identifier must be unique among private connection resources
   * within the parent and becomes the final token in the name URI. The
   * identifier must meet the following requirements:
   *
   * * Only contains 1-63 alphanumeric characters and hyphens
   * * Begins with an alphabetical character
   * * Ends with a non-hyphen character
   * * Not formatted as a UUID
   * * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034)
   * (section 3.5)
   */
  privateConnectionId: string;
  /** Required. The initial description of the new private connection. */
  privateConnection:
    | PrivateConnection
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.GetPrivateConnection][google.cloud.vmwareengine.v1.VmwareEngine.GetPrivateConnection]
 */
export interface GetPrivateConnectionRequest {
  /**
   * Required. The resource name of the private connection to retrieve.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/privateConnections/my-connection`
   */
  name: string;
}

/**
 * Request message for
 * [VmwareEngine.ListPrivateConnections][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnections]
 */
export interface ListPrivateConnectionsRequest {
  /**
   * Required. The resource name of the location to query for
   * private connections. Resource names are schemeless URIs that follow the
   * conventions in https://cloud.google.com/apis/design/resource_names. For
   * example: `projects/my-project/locations/us-central1`
   */
  parent: string;
  /**
   * The maximum number of private connections to return in one page.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListPrivateConnections` call.
   * Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * `ListPrivateConnections` must match the call that provided the page
   * token.
   */
  pageToken: string;
  /**
   * A filter expression that matches resources returned in the response.
   * The expression must specify the field name, a comparison
   * operator, and the value that you want to use for filtering. The value
   * must be a string, a number, or a boolean. The comparison operator
   * must be `=`, `!=`, `>`, or `<`.
   *
   * For example, if you are filtering a list of private connections, you can
   * exclude the ones named `example-connection` by specifying
   * `name != "example-connection"`.
   *
   * To filter on multiple expressions, provide each separate expression within
   * parentheses. For example:
   * ```
   * (name = "example-connection")
   * (createTime > "2022-09-22T08:15:10.40Z")
   * ```
   *
   * By default, each expression is an `AND` expression. However, you
   * can include `AND` and `OR` expressions explicitly.
   * For example:
   * ```
   * (name = "example-connection-1") AND
   * (createTime > "2021-04-12T08:15:10.40Z") OR
   * (name = "example-connection-2")
   * ```
   */
  filter: string;
  /**
   * Sorts list results by a certain order. By default, returned results
   * are ordered by `name` in ascending order.
   * You can also sort results in descending order based on the `name` value
   * using `orderBy="name desc"`.
   * Currently, only ordering by `name` is supported.
   */
  orderBy: string;
}

/**
 * Response message for
 * [VmwareEngine.ListPrivateConnections][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnections]
 */
export interface ListPrivateConnectionsResponse {
  /** A list of private connections. */
  privateConnections: PrivateConnection[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
  /** Unreachable resources. */
  unreachable: string[];
}

/**
 * Request message for
 * [VmwareEngine.UpdatePrivateConnection][google.cloud.vmwareengine.v1.VmwareEngine.UpdatePrivateConnection]
 */
export interface UpdatePrivateConnectionRequest {
  /** Required. Private connection description. */
  privateConnection:
    | PrivateConnection
    | undefined;
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * `PrivateConnection` resource by the update.
   * The fields specified in the `update_mask` are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.DeletePrivateConnection][google.cloud.vmwareengine.v1.VmwareEngine.DeletePrivateConnection]
 */
export interface DeletePrivateConnectionRequest {
  /**
   * Required. The resource name of the private connection to be deleted.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * For example:
   * `projects/my-project/locations/us-central1/privateConnections/my-connection`
   */
  name: string;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.ListPrivateConnectionPeeringRoutes][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnectionPeeringRoutes]
 */
export interface ListPrivateConnectionPeeringRoutesRequest {
  /**
   * Required. The resource name of the private connection to retrieve peering
   * routes from. Resource names are schemeless URIs that follow the conventions
   * in https://cloud.google.com/apis/design/resource_names. For example:
   * `projects/my-project/locations/us-west1/privateConnections/my-connection`
   */
  parent: string;
  /**
   * The maximum number of peering routes to return in one page.
   * The service may return fewer than this value.
   * The maximum value is coerced to 1000.
   * The default value of this field is 500.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListPrivateConnectionPeeringRoutes`
   * call. Provide this to retrieve the subsequent page. When paginating, all
   * other parameters provided to `ListPrivateConnectionPeeringRoutes` must
   * match the call that provided the page token.
   */
  pageToken: string;
}

/**
 * Response message for
 * [VmwareEngine.ListPrivateConnectionPeeringRoutes][google.cloud.vmwareengine.v1.VmwareEngine.ListPrivateConnectionPeeringRoutes]
 */
export interface ListPrivateConnectionPeeringRoutesResponse {
  /** A list of peering routes. */
  peeringRoutes: PeeringRoute[];
  /**
   * A token, which can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [VmwareEngine.GrantDnsBindPermission][google.cloud.vmwareengine.v1.VmwareEngine.GrantDnsBindPermission]
 */
export interface GrantDnsBindPermissionRequest {
  /**
   * Required. The name of the resource which stores the users/service accounts
   * having the permission to bind to the corresponding intranet VPC of the
   * consumer project. DnsBindPermission is a global resource. Resource names
   * are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names. For example:
   * `projects/my-project/locations/global/dnsBindPermission`
   */
  name: string;
  /**
   * Required. The consumer provided user/service account which needs to be
   * granted permission to bind with the intranet VPC corresponding to the
   * consumer project.
   */
  principal:
    | Principal
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.RevokeDnsBindPermission][google.cloud.vmwareengine.v1.VmwareEngine.RevokeDnsBindPermission]
 */
export interface RevokeDnsBindPermissionRequest {
  /**
   * Required. The name of the resource which stores the users/service accounts
   * having the permission to bind to the corresponding intranet VPC of the
   * consumer project. DnsBindPermission is a global resource. Resource names
   * are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names. For example:
   * `projects/my-project/locations/global/dnsBindPermission`
   */
  name: string;
  /**
   * Required. The consumer provided user/service account which needs to be
   * granted permission to bind with the intranet VPC corresponding to the
   * consumer project.
   */
  principal:
    | Principal
    | undefined;
  /**
   * Optional. A request ID to identify requests. Specify a unique request ID
   * so that if you must retry your request, the server will know to ignore
   * the request if it has already been completed. The server guarantees that a
   * request doesn't result in creation of duplicate commitments for at least 60
   * minutes.
   *
   * For example, consider a situation where you make an initial request and the
   * request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/**
 * Request message for
 * [VmwareEngine.GetDnsBindPermission][google.cloud.vmwareengine.v1.VmwareEngine.GetDnsBindPermission]
 */
export interface GetDnsBindPermissionRequest {
  /**
   * Required. The name of the resource which stores the users/service accounts
   * having the permission to bind to the corresponding intranet VPC of the
   * consumer project. DnsBindPermission is a global resource. Resource names
   * are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names. For example:
   * `projects/my-project/locations/global/dnsBindPermission`
   */
  name: string;
}

function createBaseListPrivateCloudsRequest(): ListPrivateCloudsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListPrivateCloudsRequest: MessageFns<ListPrivateCloudsRequest> = {
  encode(message: ListPrivateCloudsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPrivateCloudsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPrivateCloudsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPrivateCloudsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListPrivateCloudsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPrivateCloudsRequest>): ListPrivateCloudsRequest {
    return ListPrivateCloudsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPrivateCloudsRequest>): ListPrivateCloudsRequest {
    const message = createBaseListPrivateCloudsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListPrivateCloudsResponse(): ListPrivateCloudsResponse {
  return { privateClouds: [], nextPageToken: "", unreachable: [] };
}

export const ListPrivateCloudsResponse: MessageFns<ListPrivateCloudsResponse> = {
  encode(message: ListPrivateCloudsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.privateClouds) {
      PrivateCloud.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPrivateCloudsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPrivateCloudsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateClouds.push(PrivateCloud.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPrivateCloudsResponse {
    return {
      privateClouds: globalThis.Array.isArray(object?.privateClouds)
        ? object.privateClouds.map((e: any) => PrivateCloud.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListPrivateCloudsResponse): unknown {
    const obj: any = {};
    if (message.privateClouds?.length) {
      obj.privateClouds = message.privateClouds.map((e) => PrivateCloud.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPrivateCloudsResponse>): ListPrivateCloudsResponse {
    return ListPrivateCloudsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPrivateCloudsResponse>): ListPrivateCloudsResponse {
    const message = createBaseListPrivateCloudsResponse();
    message.privateClouds = object.privateClouds?.map((e) => PrivateCloud.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetPrivateCloudRequest(): GetPrivateCloudRequest {
  return { name: "" };
}

export const GetPrivateCloudRequest: MessageFns<GetPrivateCloudRequest> = {
  encode(message: GetPrivateCloudRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPrivateCloudRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPrivateCloudRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPrivateCloudRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetPrivateCloudRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPrivateCloudRequest>): GetPrivateCloudRequest {
    return GetPrivateCloudRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPrivateCloudRequest>): GetPrivateCloudRequest {
    const message = createBaseGetPrivateCloudRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreatePrivateCloudRequest(): CreatePrivateCloudRequest {
  return { parent: "", privateCloudId: "", privateCloud: undefined, requestId: "", validateOnly: false };
}

export const CreatePrivateCloudRequest: MessageFns<CreatePrivateCloudRequest> = {
  encode(message: CreatePrivateCloudRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.privateCloudId !== "") {
      writer.uint32(18).string(message.privateCloudId);
    }
    if (message.privateCloud !== undefined) {
      PrivateCloud.encode(message.privateCloud, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePrivateCloudRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePrivateCloudRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.privateCloudId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.privateCloud = PrivateCloud.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePrivateCloudRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      privateCloudId: isSet(object.privateCloudId) ? globalThis.String(object.privateCloudId) : "",
      privateCloud: isSet(object.privateCloud) ? PrivateCloud.fromJSON(object.privateCloud) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreatePrivateCloudRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.privateCloudId !== "") {
      obj.privateCloudId = message.privateCloudId;
    }
    if (message.privateCloud !== undefined) {
      obj.privateCloud = PrivateCloud.toJSON(message.privateCloud);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreatePrivateCloudRequest>): CreatePrivateCloudRequest {
    return CreatePrivateCloudRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreatePrivateCloudRequest>): CreatePrivateCloudRequest {
    const message = createBaseCreatePrivateCloudRequest();
    message.parent = object.parent ?? "";
    message.privateCloudId = object.privateCloudId ?? "";
    message.privateCloud = (object.privateCloud !== undefined && object.privateCloud !== null)
      ? PrivateCloud.fromPartial(object.privateCloud)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdatePrivateCloudRequest(): UpdatePrivateCloudRequest {
  return { privateCloud: undefined, updateMask: undefined, requestId: "" };
}

export const UpdatePrivateCloudRequest: MessageFns<UpdatePrivateCloudRequest> = {
  encode(message: UpdatePrivateCloudRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateCloud !== undefined) {
      PrivateCloud.encode(message.privateCloud, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePrivateCloudRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePrivateCloudRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateCloud = PrivateCloud.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePrivateCloudRequest {
    return {
      privateCloud: isSet(object.privateCloud) ? PrivateCloud.fromJSON(object.privateCloud) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdatePrivateCloudRequest): unknown {
    const obj: any = {};
    if (message.privateCloud !== undefined) {
      obj.privateCloud = PrivateCloud.toJSON(message.privateCloud);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePrivateCloudRequest>): UpdatePrivateCloudRequest {
    return UpdatePrivateCloudRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePrivateCloudRequest>): UpdatePrivateCloudRequest {
    const message = createBaseUpdatePrivateCloudRequest();
    message.privateCloud = (object.privateCloud !== undefined && object.privateCloud !== null)
      ? PrivateCloud.fromPartial(object.privateCloud)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeletePrivateCloudRequest(): DeletePrivateCloudRequest {
  return { name: "", requestId: "", force: false, delayHours: undefined };
}

export const DeletePrivateCloudRequest: MessageFns<DeletePrivateCloudRequest> = {
  encode(message: DeletePrivateCloudRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    if (message.delayHours !== undefined) {
      writer.uint32(32).int32(message.delayHours);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePrivateCloudRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePrivateCloudRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.delayHours = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePrivateCloudRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
      delayHours: isSet(object.delayHours) ? globalThis.Number(object.delayHours) : undefined,
    };
  },

  toJSON(message: DeletePrivateCloudRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    if (message.delayHours !== undefined) {
      obj.delayHours = Math.round(message.delayHours);
    }
    return obj;
  },

  create(base?: DeepPartial<DeletePrivateCloudRequest>): DeletePrivateCloudRequest {
    return DeletePrivateCloudRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeletePrivateCloudRequest>): DeletePrivateCloudRequest {
    const message = createBaseDeletePrivateCloudRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.force = object.force ?? false;
    message.delayHours = object.delayHours ?? undefined;
    return message;
  },
};

function createBaseUndeletePrivateCloudRequest(): UndeletePrivateCloudRequest {
  return { name: "", requestId: "" };
}

export const UndeletePrivateCloudRequest: MessageFns<UndeletePrivateCloudRequest> = {
  encode(message: UndeletePrivateCloudRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UndeletePrivateCloudRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUndeletePrivateCloudRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UndeletePrivateCloudRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UndeletePrivateCloudRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UndeletePrivateCloudRequest>): UndeletePrivateCloudRequest {
    return UndeletePrivateCloudRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UndeletePrivateCloudRequest>): UndeletePrivateCloudRequest {
    const message = createBaseUndeletePrivateCloudRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListClustersRequest(): ListClustersRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListClustersRequest: MessageFns<ListClustersRequest> = {
  encode(message: ListClustersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClustersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClustersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClustersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListClustersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListClustersRequest>): ListClustersRequest {
    return ListClustersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListClustersRequest>): ListClustersRequest {
    const message = createBaseListClustersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListClustersResponse(): ListClustersResponse {
  return { clusters: [], nextPageToken: "", unreachable: [] };
}

export const ListClustersResponse: MessageFns<ListClustersResponse> = {
  encode(message: ListClustersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.clusters) {
      Cluster.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListClustersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListClustersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clusters.push(Cluster.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListClustersResponse {
    return {
      clusters: globalThis.Array.isArray(object?.clusters) ? object.clusters.map((e: any) => Cluster.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListClustersResponse): unknown {
    const obj: any = {};
    if (message.clusters?.length) {
      obj.clusters = message.clusters.map((e) => Cluster.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListClustersResponse>): ListClustersResponse {
    return ListClustersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListClustersResponse>): ListClustersResponse {
    const message = createBaseListClustersResponse();
    message.clusters = object.clusters?.map((e) => Cluster.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetClusterRequest(): GetClusterRequest {
  return { name: "" };
}

export const GetClusterRequest: MessageFns<GetClusterRequest> = {
  encode(message: GetClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetClusterRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetClusterRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetClusterRequest>): GetClusterRequest {
    return GetClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetClusterRequest>): GetClusterRequest {
    const message = createBaseGetClusterRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateClusterRequest(): CreateClusterRequest {
  return { parent: "", clusterId: "", cluster: undefined, requestId: "", validateOnly: false };
}

export const CreateClusterRequest: MessageFns<CreateClusterRequest> = {
  encode(message: CreateClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.clusterId !== "") {
      writer.uint32(18).string(message.clusterId);
    }
    if (message.cluster !== undefined) {
      Cluster.encode(message.cluster, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cluster = Cluster.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateClusterRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      clusterId: isSet(object.clusterId) ? globalThis.String(object.clusterId) : "",
      cluster: isSet(object.cluster) ? Cluster.fromJSON(object.cluster) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateClusterRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.clusterId !== "") {
      obj.clusterId = message.clusterId;
    }
    if (message.cluster !== undefined) {
      obj.cluster = Cluster.toJSON(message.cluster);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateClusterRequest>): CreateClusterRequest {
    return CreateClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateClusterRequest>): CreateClusterRequest {
    const message = createBaseCreateClusterRequest();
    message.parent = object.parent ?? "";
    message.clusterId = object.clusterId ?? "";
    message.cluster = (object.cluster !== undefined && object.cluster !== null)
      ? Cluster.fromPartial(object.cluster)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateClusterRequest(): UpdateClusterRequest {
  return { updateMask: undefined, cluster: undefined, requestId: "", validateOnly: false };
}

export const UpdateClusterRequest: MessageFns<UpdateClusterRequest> = {
  encode(message: UpdateClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.cluster !== undefined) {
      Cluster.encode(message.cluster, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cluster = Cluster.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateClusterRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      cluster: isSet(object.cluster) ? Cluster.fromJSON(object.cluster) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateClusterRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.cluster !== undefined) {
      obj.cluster = Cluster.toJSON(message.cluster);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateClusterRequest>): UpdateClusterRequest {
    return UpdateClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateClusterRequest>): UpdateClusterRequest {
    const message = createBaseUpdateClusterRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.cluster = (object.cluster !== undefined && object.cluster !== null)
      ? Cluster.fromPartial(object.cluster)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteClusterRequest(): DeleteClusterRequest {
  return { name: "", requestId: "" };
}

export const DeleteClusterRequest: MessageFns<DeleteClusterRequest> = {
  encode(message: DeleteClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteClusterRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteClusterRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteClusterRequest>): DeleteClusterRequest {
    return DeleteClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteClusterRequest>): DeleteClusterRequest {
    const message = createBaseDeleteClusterRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListNodesRequest(): ListNodesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListNodesRequest: MessageFns<ListNodesRequest> = {
  encode(message: ListNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListNodesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodesRequest>): ListNodesRequest {
    return ListNodesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodesRequest>): ListNodesRequest {
    const message = createBaseListNodesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListNodesResponse(): ListNodesResponse {
  return { nodes: [], nextPageToken: "" };
}

export const ListNodesResponse: MessageFns<ListNodesResponse> = {
  encode(message: ListNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodesResponse {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListNodesResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodesResponse>): ListNodesResponse {
    return ListNodesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodesResponse>): ListNodesResponse {
    const message = createBaseListNodesResponse();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetNodeRequest(): GetNodeRequest {
  return { name: "" };
}

export const GetNodeRequest: MessageFns<GetNodeRequest> = {
  encode(message: GetNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNodeRequest>): GetNodeRequest {
    return GetNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNodeRequest>): GetNodeRequest {
    const message = createBaseGetNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListExternalAddressesRequest(): ListExternalAddressesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListExternalAddressesRequest: MessageFns<ListExternalAddressesRequest> = {
  encode(message: ListExternalAddressesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExternalAddressesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExternalAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExternalAddressesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListExternalAddressesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListExternalAddressesRequest>): ListExternalAddressesRequest {
    return ListExternalAddressesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListExternalAddressesRequest>): ListExternalAddressesRequest {
    const message = createBaseListExternalAddressesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListExternalAddressesResponse(): ListExternalAddressesResponse {
  return { externalAddresses: [], nextPageToken: "", unreachable: [] };
}

export const ListExternalAddressesResponse: MessageFns<ListExternalAddressesResponse> = {
  encode(message: ListExternalAddressesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.externalAddresses) {
      ExternalAddress.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExternalAddressesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExternalAddressesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalAddresses.push(ExternalAddress.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExternalAddressesResponse {
    return {
      externalAddresses: globalThis.Array.isArray(object?.externalAddresses)
        ? object.externalAddresses.map((e: any) => ExternalAddress.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListExternalAddressesResponse): unknown {
    const obj: any = {};
    if (message.externalAddresses?.length) {
      obj.externalAddresses = message.externalAddresses.map((e) => ExternalAddress.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListExternalAddressesResponse>): ListExternalAddressesResponse {
    return ListExternalAddressesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListExternalAddressesResponse>): ListExternalAddressesResponse {
    const message = createBaseListExternalAddressesResponse();
    message.externalAddresses = object.externalAddresses?.map((e) => ExternalAddress.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseFetchNetworkPolicyExternalAddressesRequest(): FetchNetworkPolicyExternalAddressesRequest {
  return { networkPolicy: "", pageSize: 0, pageToken: "" };
}

export const FetchNetworkPolicyExternalAddressesRequest: MessageFns<FetchNetworkPolicyExternalAddressesRequest> = {
  encode(message: FetchNetworkPolicyExternalAddressesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkPolicy !== "") {
      writer.uint32(10).string(message.networkPolicy);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchNetworkPolicyExternalAddressesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchNetworkPolicyExternalAddressesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networkPolicy = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchNetworkPolicyExternalAddressesRequest {
    return {
      networkPolicy: isSet(object.networkPolicy) ? globalThis.String(object.networkPolicy) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: FetchNetworkPolicyExternalAddressesRequest): unknown {
    const obj: any = {};
    if (message.networkPolicy !== "") {
      obj.networkPolicy = message.networkPolicy;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchNetworkPolicyExternalAddressesRequest>): FetchNetworkPolicyExternalAddressesRequest {
    return FetchNetworkPolicyExternalAddressesRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FetchNetworkPolicyExternalAddressesRequest>,
  ): FetchNetworkPolicyExternalAddressesRequest {
    const message = createBaseFetchNetworkPolicyExternalAddressesRequest();
    message.networkPolicy = object.networkPolicy ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseFetchNetworkPolicyExternalAddressesResponse(): FetchNetworkPolicyExternalAddressesResponse {
  return { externalAddresses: [], nextPageToken: "" };
}

export const FetchNetworkPolicyExternalAddressesResponse: MessageFns<FetchNetworkPolicyExternalAddressesResponse> = {
  encode(
    message: FetchNetworkPolicyExternalAddressesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.externalAddresses) {
      ExternalAddress.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchNetworkPolicyExternalAddressesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchNetworkPolicyExternalAddressesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalAddresses.push(ExternalAddress.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchNetworkPolicyExternalAddressesResponse {
    return {
      externalAddresses: globalThis.Array.isArray(object?.externalAddresses)
        ? object.externalAddresses.map((e: any) => ExternalAddress.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: FetchNetworkPolicyExternalAddressesResponse): unknown {
    const obj: any = {};
    if (message.externalAddresses?.length) {
      obj.externalAddresses = message.externalAddresses.map((e) => ExternalAddress.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchNetworkPolicyExternalAddressesResponse>): FetchNetworkPolicyExternalAddressesResponse {
    return FetchNetworkPolicyExternalAddressesResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<FetchNetworkPolicyExternalAddressesResponse>,
  ): FetchNetworkPolicyExternalAddressesResponse {
    const message = createBaseFetchNetworkPolicyExternalAddressesResponse();
    message.externalAddresses = object.externalAddresses?.map((e) => ExternalAddress.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetExternalAddressRequest(): GetExternalAddressRequest {
  return { name: "" };
}

export const GetExternalAddressRequest: MessageFns<GetExternalAddressRequest> = {
  encode(message: GetExternalAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetExternalAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExternalAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExternalAddressRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetExternalAddressRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetExternalAddressRequest>): GetExternalAddressRequest {
    return GetExternalAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetExternalAddressRequest>): GetExternalAddressRequest {
    const message = createBaseGetExternalAddressRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateExternalAddressRequest(): CreateExternalAddressRequest {
  return { parent: "", externalAddress: undefined, externalAddressId: "", requestId: "" };
}

export const CreateExternalAddressRequest: MessageFns<CreateExternalAddressRequest> = {
  encode(message: CreateExternalAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.externalAddress !== undefined) {
      ExternalAddress.encode(message.externalAddress, writer.uint32(18).fork()).join();
    }
    if (message.externalAddressId !== "") {
      writer.uint32(26).string(message.externalAddressId);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateExternalAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExternalAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.externalAddress = ExternalAddress.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalAddressId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateExternalAddressRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      externalAddress: isSet(object.externalAddress) ? ExternalAddress.fromJSON(object.externalAddress) : undefined,
      externalAddressId: isSet(object.externalAddressId) ? globalThis.String(object.externalAddressId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateExternalAddressRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.externalAddress !== undefined) {
      obj.externalAddress = ExternalAddress.toJSON(message.externalAddress);
    }
    if (message.externalAddressId !== "") {
      obj.externalAddressId = message.externalAddressId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateExternalAddressRequest>): CreateExternalAddressRequest {
    return CreateExternalAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateExternalAddressRequest>): CreateExternalAddressRequest {
    const message = createBaseCreateExternalAddressRequest();
    message.parent = object.parent ?? "";
    message.externalAddress = (object.externalAddress !== undefined && object.externalAddress !== null)
      ? ExternalAddress.fromPartial(object.externalAddress)
      : undefined;
    message.externalAddressId = object.externalAddressId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateExternalAddressRequest(): UpdateExternalAddressRequest {
  return { updateMask: undefined, externalAddress: undefined, requestId: "" };
}

export const UpdateExternalAddressRequest: MessageFns<UpdateExternalAddressRequest> = {
  encode(message: UpdateExternalAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.externalAddress !== undefined) {
      ExternalAddress.encode(message.externalAddress, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateExternalAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateExternalAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.externalAddress = ExternalAddress.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateExternalAddressRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      externalAddress: isSet(object.externalAddress) ? ExternalAddress.fromJSON(object.externalAddress) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateExternalAddressRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.externalAddress !== undefined) {
      obj.externalAddress = ExternalAddress.toJSON(message.externalAddress);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateExternalAddressRequest>): UpdateExternalAddressRequest {
    return UpdateExternalAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateExternalAddressRequest>): UpdateExternalAddressRequest {
    const message = createBaseUpdateExternalAddressRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.externalAddress = (object.externalAddress !== undefined && object.externalAddress !== null)
      ? ExternalAddress.fromPartial(object.externalAddress)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteExternalAddressRequest(): DeleteExternalAddressRequest {
  return { name: "", requestId: "" };
}

export const DeleteExternalAddressRequest: MessageFns<DeleteExternalAddressRequest> = {
  encode(message: DeleteExternalAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteExternalAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteExternalAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteExternalAddressRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteExternalAddressRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteExternalAddressRequest>): DeleteExternalAddressRequest {
    return DeleteExternalAddressRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteExternalAddressRequest>): DeleteExternalAddressRequest {
    const message = createBaseDeleteExternalAddressRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListSubnetsRequest(): ListSubnetsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListSubnetsRequest: MessageFns<ListSubnetsRequest> = {
  encode(message: ListSubnetsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubnetsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubnetsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubnetsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSubnetsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubnetsRequest>): ListSubnetsRequest {
    return ListSubnetsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubnetsRequest>): ListSubnetsRequest {
    const message = createBaseListSubnetsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSubnetsResponse(): ListSubnetsResponse {
  return { subnets: [], nextPageToken: "", unreachable: [] };
}

export const ListSubnetsResponse: MessageFns<ListSubnetsResponse> = {
  encode(message: ListSubnetsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.subnets) {
      Subnet.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSubnetsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSubnetsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subnets.push(Subnet.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSubnetsResponse {
    return {
      subnets: globalThis.Array.isArray(object?.subnets) ? object.subnets.map((e: any) => Subnet.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListSubnetsResponse): unknown {
    const obj: any = {};
    if (message.subnets?.length) {
      obj.subnets = message.subnets.map((e) => Subnet.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSubnetsResponse>): ListSubnetsResponse {
    return ListSubnetsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSubnetsResponse>): ListSubnetsResponse {
    const message = createBaseListSubnetsResponse();
    message.subnets = object.subnets?.map((e) => Subnet.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetSubnetRequest(): GetSubnetRequest {
  return { name: "" };
}

export const GetSubnetRequest: MessageFns<GetSubnetRequest> = {
  encode(message: GetSubnetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubnetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubnetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubnetRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSubnetRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSubnetRequest>): GetSubnetRequest {
    return GetSubnetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSubnetRequest>): GetSubnetRequest {
    const message = createBaseGetSubnetRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateSubnetRequest(): UpdateSubnetRequest {
  return { updateMask: undefined, subnet: undefined };
}

export const UpdateSubnetRequest: MessageFns<UpdateSubnetRequest> = {
  encode(message: UpdateSubnetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.subnet !== undefined) {
      Subnet.encode(message.subnet, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubnetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubnetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnet = Subnet.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubnetRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      subnet: isSet(object.subnet) ? Subnet.fromJSON(object.subnet) : undefined,
    };
  },

  toJSON(message: UpdateSubnetRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.subnet !== undefined) {
      obj.subnet = Subnet.toJSON(message.subnet);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSubnetRequest>): UpdateSubnetRequest {
    return UpdateSubnetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSubnetRequest>): UpdateSubnetRequest {
    const message = createBaseUpdateSubnetRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.subnet = (object.subnet !== undefined && object.subnet !== null)
      ? Subnet.fromPartial(object.subnet)
      : undefined;
    return message;
  },
};

function createBaseListExternalAccessRulesRequest(): ListExternalAccessRulesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListExternalAccessRulesRequest: MessageFns<ListExternalAccessRulesRequest> = {
  encode(message: ListExternalAccessRulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExternalAccessRulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExternalAccessRulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExternalAccessRulesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListExternalAccessRulesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListExternalAccessRulesRequest>): ListExternalAccessRulesRequest {
    return ListExternalAccessRulesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListExternalAccessRulesRequest>): ListExternalAccessRulesRequest {
    const message = createBaseListExternalAccessRulesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListExternalAccessRulesResponse(): ListExternalAccessRulesResponse {
  return { externalAccessRules: [], nextPageToken: "", unreachable: [] };
}

export const ListExternalAccessRulesResponse: MessageFns<ListExternalAccessRulesResponse> = {
  encode(message: ListExternalAccessRulesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.externalAccessRules) {
      ExternalAccessRule.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListExternalAccessRulesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListExternalAccessRulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalAccessRules.push(ExternalAccessRule.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListExternalAccessRulesResponse {
    return {
      externalAccessRules: globalThis.Array.isArray(object?.externalAccessRules)
        ? object.externalAccessRules.map((e: any) => ExternalAccessRule.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListExternalAccessRulesResponse): unknown {
    const obj: any = {};
    if (message.externalAccessRules?.length) {
      obj.externalAccessRules = message.externalAccessRules.map((e) => ExternalAccessRule.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListExternalAccessRulesResponse>): ListExternalAccessRulesResponse {
    return ListExternalAccessRulesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListExternalAccessRulesResponse>): ListExternalAccessRulesResponse {
    const message = createBaseListExternalAccessRulesResponse();
    message.externalAccessRules = object.externalAccessRules?.map((e) => ExternalAccessRule.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetExternalAccessRuleRequest(): GetExternalAccessRuleRequest {
  return { name: "" };
}

export const GetExternalAccessRuleRequest: MessageFns<GetExternalAccessRuleRequest> = {
  encode(message: GetExternalAccessRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetExternalAccessRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetExternalAccessRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetExternalAccessRuleRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetExternalAccessRuleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetExternalAccessRuleRequest>): GetExternalAccessRuleRequest {
    return GetExternalAccessRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetExternalAccessRuleRequest>): GetExternalAccessRuleRequest {
    const message = createBaseGetExternalAccessRuleRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateExternalAccessRuleRequest(): CreateExternalAccessRuleRequest {
  return { parent: "", externalAccessRule: undefined, externalAccessRuleId: "", requestId: "" };
}

export const CreateExternalAccessRuleRequest: MessageFns<CreateExternalAccessRuleRequest> = {
  encode(message: CreateExternalAccessRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.externalAccessRule !== undefined) {
      ExternalAccessRule.encode(message.externalAccessRule, writer.uint32(18).fork()).join();
    }
    if (message.externalAccessRuleId !== "") {
      writer.uint32(26).string(message.externalAccessRuleId);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateExternalAccessRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateExternalAccessRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.externalAccessRule = ExternalAccessRule.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalAccessRuleId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateExternalAccessRuleRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      externalAccessRule: isSet(object.externalAccessRule)
        ? ExternalAccessRule.fromJSON(object.externalAccessRule)
        : undefined,
      externalAccessRuleId: isSet(object.externalAccessRuleId) ? globalThis.String(object.externalAccessRuleId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateExternalAccessRuleRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.externalAccessRule !== undefined) {
      obj.externalAccessRule = ExternalAccessRule.toJSON(message.externalAccessRule);
    }
    if (message.externalAccessRuleId !== "") {
      obj.externalAccessRuleId = message.externalAccessRuleId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateExternalAccessRuleRequest>): CreateExternalAccessRuleRequest {
    return CreateExternalAccessRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateExternalAccessRuleRequest>): CreateExternalAccessRuleRequest {
    const message = createBaseCreateExternalAccessRuleRequest();
    message.parent = object.parent ?? "";
    message.externalAccessRule = (object.externalAccessRule !== undefined && object.externalAccessRule !== null)
      ? ExternalAccessRule.fromPartial(object.externalAccessRule)
      : undefined;
    message.externalAccessRuleId = object.externalAccessRuleId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateExternalAccessRuleRequest(): UpdateExternalAccessRuleRequest {
  return { updateMask: undefined, externalAccessRule: undefined, requestId: "" };
}

export const UpdateExternalAccessRuleRequest: MessageFns<UpdateExternalAccessRuleRequest> = {
  encode(message: UpdateExternalAccessRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.externalAccessRule !== undefined) {
      ExternalAccessRule.encode(message.externalAccessRule, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateExternalAccessRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateExternalAccessRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.externalAccessRule = ExternalAccessRule.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateExternalAccessRuleRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      externalAccessRule: isSet(object.externalAccessRule)
        ? ExternalAccessRule.fromJSON(object.externalAccessRule)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateExternalAccessRuleRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.externalAccessRule !== undefined) {
      obj.externalAccessRule = ExternalAccessRule.toJSON(message.externalAccessRule);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateExternalAccessRuleRequest>): UpdateExternalAccessRuleRequest {
    return UpdateExternalAccessRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateExternalAccessRuleRequest>): UpdateExternalAccessRuleRequest {
    const message = createBaseUpdateExternalAccessRuleRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.externalAccessRule = (object.externalAccessRule !== undefined && object.externalAccessRule !== null)
      ? ExternalAccessRule.fromPartial(object.externalAccessRule)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteExternalAccessRuleRequest(): DeleteExternalAccessRuleRequest {
  return { name: "", requestId: "" };
}

export const DeleteExternalAccessRuleRequest: MessageFns<DeleteExternalAccessRuleRequest> = {
  encode(message: DeleteExternalAccessRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteExternalAccessRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteExternalAccessRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteExternalAccessRuleRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteExternalAccessRuleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteExternalAccessRuleRequest>): DeleteExternalAccessRuleRequest {
    return DeleteExternalAccessRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteExternalAccessRuleRequest>): DeleteExternalAccessRuleRequest {
    const message = createBaseDeleteExternalAccessRuleRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListLoggingServersRequest(): ListLoggingServersRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListLoggingServersRequest: MessageFns<ListLoggingServersRequest> = {
  encode(message: ListLoggingServersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLoggingServersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLoggingServersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLoggingServersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListLoggingServersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListLoggingServersRequest>): ListLoggingServersRequest {
    return ListLoggingServersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLoggingServersRequest>): ListLoggingServersRequest {
    const message = createBaseListLoggingServersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListLoggingServersResponse(): ListLoggingServersResponse {
  return { loggingServers: [], nextPageToken: "", unreachable: [] };
}

export const ListLoggingServersResponse: MessageFns<ListLoggingServersResponse> = {
  encode(message: ListLoggingServersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.loggingServers) {
      LoggingServer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLoggingServersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLoggingServersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.loggingServers.push(LoggingServer.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLoggingServersResponse {
    return {
      loggingServers: globalThis.Array.isArray(object?.loggingServers)
        ? object.loggingServers.map((e: any) => LoggingServer.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListLoggingServersResponse): unknown {
    const obj: any = {};
    if (message.loggingServers?.length) {
      obj.loggingServers = message.loggingServers.map((e) => LoggingServer.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListLoggingServersResponse>): ListLoggingServersResponse {
    return ListLoggingServersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLoggingServersResponse>): ListLoggingServersResponse {
    const message = createBaseListLoggingServersResponse();
    message.loggingServers = object.loggingServers?.map((e) => LoggingServer.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetLoggingServerRequest(): GetLoggingServerRequest {
  return { name: "" };
}

export const GetLoggingServerRequest: MessageFns<GetLoggingServerRequest> = {
  encode(message: GetLoggingServerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLoggingServerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLoggingServerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLoggingServerRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetLoggingServerRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLoggingServerRequest>): GetLoggingServerRequest {
    return GetLoggingServerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLoggingServerRequest>): GetLoggingServerRequest {
    const message = createBaseGetLoggingServerRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateLoggingServerRequest(): CreateLoggingServerRequest {
  return { parent: "", loggingServer: undefined, loggingServerId: "", requestId: "" };
}

export const CreateLoggingServerRequest: MessageFns<CreateLoggingServerRequest> = {
  encode(message: CreateLoggingServerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.loggingServer !== undefined) {
      LoggingServer.encode(message.loggingServer, writer.uint32(18).fork()).join();
    }
    if (message.loggingServerId !== "") {
      writer.uint32(26).string(message.loggingServerId);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateLoggingServerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateLoggingServerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.loggingServer = LoggingServer.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.loggingServerId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateLoggingServerRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      loggingServer: isSet(object.loggingServer) ? LoggingServer.fromJSON(object.loggingServer) : undefined,
      loggingServerId: isSet(object.loggingServerId) ? globalThis.String(object.loggingServerId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateLoggingServerRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.loggingServer !== undefined) {
      obj.loggingServer = LoggingServer.toJSON(message.loggingServer);
    }
    if (message.loggingServerId !== "") {
      obj.loggingServerId = message.loggingServerId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateLoggingServerRequest>): CreateLoggingServerRequest {
    return CreateLoggingServerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateLoggingServerRequest>): CreateLoggingServerRequest {
    const message = createBaseCreateLoggingServerRequest();
    message.parent = object.parent ?? "";
    message.loggingServer = (object.loggingServer !== undefined && object.loggingServer !== null)
      ? LoggingServer.fromPartial(object.loggingServer)
      : undefined;
    message.loggingServerId = object.loggingServerId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateLoggingServerRequest(): UpdateLoggingServerRequest {
  return { updateMask: undefined, loggingServer: undefined, requestId: "" };
}

export const UpdateLoggingServerRequest: MessageFns<UpdateLoggingServerRequest> = {
  encode(message: UpdateLoggingServerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.loggingServer !== undefined) {
      LoggingServer.encode(message.loggingServer, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateLoggingServerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLoggingServerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.loggingServer = LoggingServer.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateLoggingServerRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      loggingServer: isSet(object.loggingServer) ? LoggingServer.fromJSON(object.loggingServer) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateLoggingServerRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.loggingServer !== undefined) {
      obj.loggingServer = LoggingServer.toJSON(message.loggingServer);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateLoggingServerRequest>): UpdateLoggingServerRequest {
    return UpdateLoggingServerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateLoggingServerRequest>): UpdateLoggingServerRequest {
    const message = createBaseUpdateLoggingServerRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.loggingServer = (object.loggingServer !== undefined && object.loggingServer !== null)
      ? LoggingServer.fromPartial(object.loggingServer)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteLoggingServerRequest(): DeleteLoggingServerRequest {
  return { name: "", requestId: "" };
}

export const DeleteLoggingServerRequest: MessageFns<DeleteLoggingServerRequest> = {
  encode(message: DeleteLoggingServerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteLoggingServerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteLoggingServerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteLoggingServerRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteLoggingServerRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteLoggingServerRequest>): DeleteLoggingServerRequest {
    return DeleteLoggingServerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteLoggingServerRequest>): DeleteLoggingServerRequest {
    const message = createBaseDeleteLoggingServerRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseListNodeTypesRequest(): ListNodeTypesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListNodeTypesRequest: MessageFns<ListNodeTypesRequest> = {
  encode(message: ListNodeTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodeTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodeTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodeTypesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListNodeTypesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodeTypesRequest>): ListNodeTypesRequest {
    return ListNodeTypesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodeTypesRequest>): ListNodeTypesRequest {
    const message = createBaseListNodeTypesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListNodeTypesResponse(): ListNodeTypesResponse {
  return { nodeTypes: [], nextPageToken: "", unreachable: [] };
}

export const ListNodeTypesResponse: MessageFns<ListNodeTypesResponse> = {
  encode(message: ListNodeTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodeTypes) {
      NodeType.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodeTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodeTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeTypes.push(NodeType.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodeTypesResponse {
    return {
      nodeTypes: globalThis.Array.isArray(object?.nodeTypes)
        ? object.nodeTypes.map((e: any) => NodeType.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListNodeTypesResponse): unknown {
    const obj: any = {};
    if (message.nodeTypes?.length) {
      obj.nodeTypes = message.nodeTypes.map((e) => NodeType.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodeTypesResponse>): ListNodeTypesResponse {
    return ListNodeTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodeTypesResponse>): ListNodeTypesResponse {
    const message = createBaseListNodeTypesResponse();
    message.nodeTypes = object.nodeTypes?.map((e) => NodeType.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetNodeTypeRequest(): GetNodeTypeRequest {
  return { name: "" };
}

export const GetNodeTypeRequest: MessageFns<GetNodeTypeRequest> = {
  encode(message: GetNodeTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeTypeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNodeTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNodeTypeRequest>): GetNodeTypeRequest {
    return GetNodeTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNodeTypeRequest>): GetNodeTypeRequest {
    const message = createBaseGetNodeTypeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseShowNsxCredentialsRequest(): ShowNsxCredentialsRequest {
  return { privateCloud: "" };
}

export const ShowNsxCredentialsRequest: MessageFns<ShowNsxCredentialsRequest> = {
  encode(message: ShowNsxCredentialsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateCloud !== "") {
      writer.uint32(10).string(message.privateCloud);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShowNsxCredentialsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShowNsxCredentialsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateCloud = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShowNsxCredentialsRequest {
    return { privateCloud: isSet(object.privateCloud) ? globalThis.String(object.privateCloud) : "" };
  },

  toJSON(message: ShowNsxCredentialsRequest): unknown {
    const obj: any = {};
    if (message.privateCloud !== "") {
      obj.privateCloud = message.privateCloud;
    }
    return obj;
  },

  create(base?: DeepPartial<ShowNsxCredentialsRequest>): ShowNsxCredentialsRequest {
    return ShowNsxCredentialsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShowNsxCredentialsRequest>): ShowNsxCredentialsRequest {
    const message = createBaseShowNsxCredentialsRequest();
    message.privateCloud = object.privateCloud ?? "";
    return message;
  },
};

function createBaseShowVcenterCredentialsRequest(): ShowVcenterCredentialsRequest {
  return { privateCloud: "", username: "" };
}

export const ShowVcenterCredentialsRequest: MessageFns<ShowVcenterCredentialsRequest> = {
  encode(message: ShowVcenterCredentialsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateCloud !== "") {
      writer.uint32(10).string(message.privateCloud);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShowVcenterCredentialsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShowVcenterCredentialsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateCloud = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShowVcenterCredentialsRequest {
    return {
      privateCloud: isSet(object.privateCloud) ? globalThis.String(object.privateCloud) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: ShowVcenterCredentialsRequest): unknown {
    const obj: any = {};
    if (message.privateCloud !== "") {
      obj.privateCloud = message.privateCloud;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create(base?: DeepPartial<ShowVcenterCredentialsRequest>): ShowVcenterCredentialsRequest {
    return ShowVcenterCredentialsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShowVcenterCredentialsRequest>): ShowVcenterCredentialsRequest {
    const message = createBaseShowVcenterCredentialsRequest();
    message.privateCloud = object.privateCloud ?? "";
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseResetNsxCredentialsRequest(): ResetNsxCredentialsRequest {
  return { privateCloud: "", requestId: "" };
}

export const ResetNsxCredentialsRequest: MessageFns<ResetNsxCredentialsRequest> = {
  encode(message: ResetNsxCredentialsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateCloud !== "") {
      writer.uint32(10).string(message.privateCloud);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetNsxCredentialsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetNsxCredentialsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateCloud = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetNsxCredentialsRequest {
    return {
      privateCloud: isSet(object.privateCloud) ? globalThis.String(object.privateCloud) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: ResetNsxCredentialsRequest): unknown {
    const obj: any = {};
    if (message.privateCloud !== "") {
      obj.privateCloud = message.privateCloud;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<ResetNsxCredentialsRequest>): ResetNsxCredentialsRequest {
    return ResetNsxCredentialsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResetNsxCredentialsRequest>): ResetNsxCredentialsRequest {
    const message = createBaseResetNsxCredentialsRequest();
    message.privateCloud = object.privateCloud ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseResetVcenterCredentialsRequest(): ResetVcenterCredentialsRequest {
  return { privateCloud: "", requestId: "", username: "" };
}

export const ResetVcenterCredentialsRequest: MessageFns<ResetVcenterCredentialsRequest> = {
  encode(message: ResetVcenterCredentialsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateCloud !== "") {
      writer.uint32(10).string(message.privateCloud);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.username !== "") {
      writer.uint32(26).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetVcenterCredentialsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetVcenterCredentialsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateCloud = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.username = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetVcenterCredentialsRequest {
    return {
      privateCloud: isSet(object.privateCloud) ? globalThis.String(object.privateCloud) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
    };
  },

  toJSON(message: ResetVcenterCredentialsRequest): unknown {
    const obj: any = {};
    if (message.privateCloud !== "") {
      obj.privateCloud = message.privateCloud;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create(base?: DeepPartial<ResetVcenterCredentialsRequest>): ResetVcenterCredentialsRequest {
    return ResetVcenterCredentialsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResetVcenterCredentialsRequest>): ResetVcenterCredentialsRequest {
    const message = createBaseResetVcenterCredentialsRequest();
    message.privateCloud = object.privateCloud ?? "";
    message.requestId = object.requestId ?? "";
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseListHcxActivationKeysResponse(): ListHcxActivationKeysResponse {
  return { hcxActivationKeys: [], nextPageToken: "", unreachable: [] };
}

export const ListHcxActivationKeysResponse: MessageFns<ListHcxActivationKeysResponse> = {
  encode(message: ListHcxActivationKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.hcxActivationKeys) {
      HcxActivationKey.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHcxActivationKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHcxActivationKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hcxActivationKeys.push(HcxActivationKey.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHcxActivationKeysResponse {
    return {
      hcxActivationKeys: globalThis.Array.isArray(object?.hcxActivationKeys)
        ? object.hcxActivationKeys.map((e: any) => HcxActivationKey.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListHcxActivationKeysResponse): unknown {
    const obj: any = {};
    if (message.hcxActivationKeys?.length) {
      obj.hcxActivationKeys = message.hcxActivationKeys.map((e) => HcxActivationKey.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListHcxActivationKeysResponse>): ListHcxActivationKeysResponse {
    return ListHcxActivationKeysResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListHcxActivationKeysResponse>): ListHcxActivationKeysResponse {
    const message = createBaseListHcxActivationKeysResponse();
    message.hcxActivationKeys = object.hcxActivationKeys?.map((e) => HcxActivationKey.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseListHcxActivationKeysRequest(): ListHcxActivationKeysRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListHcxActivationKeysRequest: MessageFns<ListHcxActivationKeysRequest> = {
  encode(message: ListHcxActivationKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHcxActivationKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHcxActivationKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHcxActivationKeysRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListHcxActivationKeysRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListHcxActivationKeysRequest>): ListHcxActivationKeysRequest {
    return ListHcxActivationKeysRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListHcxActivationKeysRequest>): ListHcxActivationKeysRequest {
    const message = createBaseListHcxActivationKeysRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseGetHcxActivationKeyRequest(): GetHcxActivationKeyRequest {
  return { name: "" };
}

export const GetHcxActivationKeyRequest: MessageFns<GetHcxActivationKeyRequest> = {
  encode(message: GetHcxActivationKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHcxActivationKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHcxActivationKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHcxActivationKeyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetHcxActivationKeyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetHcxActivationKeyRequest>): GetHcxActivationKeyRequest {
    return GetHcxActivationKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHcxActivationKeyRequest>): GetHcxActivationKeyRequest {
    const message = createBaseGetHcxActivationKeyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateHcxActivationKeyRequest(): CreateHcxActivationKeyRequest {
  return { parent: "", hcxActivationKey: undefined, hcxActivationKeyId: "", requestId: "" };
}

export const CreateHcxActivationKeyRequest: MessageFns<CreateHcxActivationKeyRequest> = {
  encode(message: CreateHcxActivationKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.hcxActivationKey !== undefined) {
      HcxActivationKey.encode(message.hcxActivationKey, writer.uint32(18).fork()).join();
    }
    if (message.hcxActivationKeyId !== "") {
      writer.uint32(26).string(message.hcxActivationKeyId);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateHcxActivationKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateHcxActivationKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hcxActivationKey = HcxActivationKey.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hcxActivationKeyId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateHcxActivationKeyRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      hcxActivationKey: isSet(object.hcxActivationKey) ? HcxActivationKey.fromJSON(object.hcxActivationKey) : undefined,
      hcxActivationKeyId: isSet(object.hcxActivationKeyId) ? globalThis.String(object.hcxActivationKeyId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateHcxActivationKeyRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.hcxActivationKey !== undefined) {
      obj.hcxActivationKey = HcxActivationKey.toJSON(message.hcxActivationKey);
    }
    if (message.hcxActivationKeyId !== "") {
      obj.hcxActivationKeyId = message.hcxActivationKeyId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateHcxActivationKeyRequest>): CreateHcxActivationKeyRequest {
    return CreateHcxActivationKeyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateHcxActivationKeyRequest>): CreateHcxActivationKeyRequest {
    const message = createBaseCreateHcxActivationKeyRequest();
    message.parent = object.parent ?? "";
    message.hcxActivationKey = (object.hcxActivationKey !== undefined && object.hcxActivationKey !== null)
      ? HcxActivationKey.fromPartial(object.hcxActivationKey)
      : undefined;
    message.hcxActivationKeyId = object.hcxActivationKeyId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseGetDnsForwardingRequest(): GetDnsForwardingRequest {
  return { name: "" };
}

export const GetDnsForwardingRequest: MessageFns<GetDnsForwardingRequest> = {
  encode(message: GetDnsForwardingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDnsForwardingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDnsForwardingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDnsForwardingRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDnsForwardingRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDnsForwardingRequest>): GetDnsForwardingRequest {
    return GetDnsForwardingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDnsForwardingRequest>): GetDnsForwardingRequest {
    const message = createBaseGetDnsForwardingRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateDnsForwardingRequest(): UpdateDnsForwardingRequest {
  return { dnsForwarding: undefined, updateMask: undefined, requestId: "" };
}

export const UpdateDnsForwardingRequest: MessageFns<UpdateDnsForwardingRequest> = {
  encode(message: UpdateDnsForwardingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dnsForwarding !== undefined) {
      DnsForwarding.encode(message.dnsForwarding, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDnsForwardingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDnsForwardingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dnsForwarding = DnsForwarding.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDnsForwardingRequest {
    return {
      dnsForwarding: isSet(object.dnsForwarding) ? DnsForwarding.fromJSON(object.dnsForwarding) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateDnsForwardingRequest): unknown {
    const obj: any = {};
    if (message.dnsForwarding !== undefined) {
      obj.dnsForwarding = DnsForwarding.toJSON(message.dnsForwarding);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDnsForwardingRequest>): UpdateDnsForwardingRequest {
    return UpdateDnsForwardingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDnsForwardingRequest>): UpdateDnsForwardingRequest {
    const message = createBaseUpdateDnsForwardingRequest();
    message.dnsForwarding = (object.dnsForwarding !== undefined && object.dnsForwarding !== null)
      ? DnsForwarding.fromPartial(object.dnsForwarding)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCreateNetworkPeeringRequest(): CreateNetworkPeeringRequest {
  return { parent: "", networkPeeringId: "", networkPeering: undefined, requestId: "" };
}

export const CreateNetworkPeeringRequest: MessageFns<CreateNetworkPeeringRequest> = {
  encode(message: CreateNetworkPeeringRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.networkPeeringId !== "") {
      writer.uint32(18).string(message.networkPeeringId);
    }
    if (message.networkPeering !== undefined) {
      NetworkPeering.encode(message.networkPeering, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNetworkPeeringRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNetworkPeeringRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.networkPeeringId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.networkPeering = NetworkPeering.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNetworkPeeringRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      networkPeeringId: isSet(object.networkPeeringId) ? globalThis.String(object.networkPeeringId) : "",
      networkPeering: isSet(object.networkPeering) ? NetworkPeering.fromJSON(object.networkPeering) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateNetworkPeeringRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.networkPeeringId !== "") {
      obj.networkPeeringId = message.networkPeeringId;
    }
    if (message.networkPeering !== undefined) {
      obj.networkPeering = NetworkPeering.toJSON(message.networkPeering);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNetworkPeeringRequest>): CreateNetworkPeeringRequest {
    return CreateNetworkPeeringRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNetworkPeeringRequest>): CreateNetworkPeeringRequest {
    const message = createBaseCreateNetworkPeeringRequest();
    message.parent = object.parent ?? "";
    message.networkPeeringId = object.networkPeeringId ?? "";
    message.networkPeering = (object.networkPeering !== undefined && object.networkPeering !== null)
      ? NetworkPeering.fromPartial(object.networkPeering)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteNetworkPeeringRequest(): DeleteNetworkPeeringRequest {
  return { name: "", requestId: "" };
}

export const DeleteNetworkPeeringRequest: MessageFns<DeleteNetworkPeeringRequest> = {
  encode(message: DeleteNetworkPeeringRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNetworkPeeringRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNetworkPeeringRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNetworkPeeringRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteNetworkPeeringRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteNetworkPeeringRequest>): DeleteNetworkPeeringRequest {
    return DeleteNetworkPeeringRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteNetworkPeeringRequest>): DeleteNetworkPeeringRequest {
    const message = createBaseDeleteNetworkPeeringRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseGetNetworkPeeringRequest(): GetNetworkPeeringRequest {
  return { name: "" };
}

export const GetNetworkPeeringRequest: MessageFns<GetNetworkPeeringRequest> = {
  encode(message: GetNetworkPeeringRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkPeeringRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkPeeringRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkPeeringRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNetworkPeeringRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNetworkPeeringRequest>): GetNetworkPeeringRequest {
    return GetNetworkPeeringRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNetworkPeeringRequest>): GetNetworkPeeringRequest {
    const message = createBaseGetNetworkPeeringRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListNetworkPeeringsRequest(): ListNetworkPeeringsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListNetworkPeeringsRequest: MessageFns<ListNetworkPeeringsRequest> = {
  encode(message: ListNetworkPeeringsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNetworkPeeringsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNetworkPeeringsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNetworkPeeringsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListNetworkPeeringsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNetworkPeeringsRequest>): ListNetworkPeeringsRequest {
    return ListNetworkPeeringsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNetworkPeeringsRequest>): ListNetworkPeeringsRequest {
    const message = createBaseListNetworkPeeringsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseUpdateNetworkPeeringRequest(): UpdateNetworkPeeringRequest {
  return { networkPeering: undefined, updateMask: undefined, requestId: "" };
}

export const UpdateNetworkPeeringRequest: MessageFns<UpdateNetworkPeeringRequest> = {
  encode(message: UpdateNetworkPeeringRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkPeering !== undefined) {
      NetworkPeering.encode(message.networkPeering, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNetworkPeeringRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNetworkPeeringRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networkPeering = NetworkPeering.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNetworkPeeringRequest {
    return {
      networkPeering: isSet(object.networkPeering) ? NetworkPeering.fromJSON(object.networkPeering) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateNetworkPeeringRequest): unknown {
    const obj: any = {};
    if (message.networkPeering !== undefined) {
      obj.networkPeering = NetworkPeering.toJSON(message.networkPeering);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateNetworkPeeringRequest>): UpdateNetworkPeeringRequest {
    return UpdateNetworkPeeringRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateNetworkPeeringRequest>): UpdateNetworkPeeringRequest {
    const message = createBaseUpdateNetworkPeeringRequest();
    message.networkPeering = (object.networkPeering !== undefined && object.networkPeering !== null)
      ? NetworkPeering.fromPartial(object.networkPeering)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListNetworkPeeringsResponse(): ListNetworkPeeringsResponse {
  return { networkPeerings: [], nextPageToken: "", unreachable: [] };
}

export const ListNetworkPeeringsResponse: MessageFns<ListNetworkPeeringsResponse> = {
  encode(message: ListNetworkPeeringsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.networkPeerings) {
      NetworkPeering.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNetworkPeeringsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNetworkPeeringsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networkPeerings.push(NetworkPeering.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNetworkPeeringsResponse {
    return {
      networkPeerings: globalThis.Array.isArray(object?.networkPeerings)
        ? object.networkPeerings.map((e: any) => NetworkPeering.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListNetworkPeeringsResponse): unknown {
    const obj: any = {};
    if (message.networkPeerings?.length) {
      obj.networkPeerings = message.networkPeerings.map((e) => NetworkPeering.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNetworkPeeringsResponse>): ListNetworkPeeringsResponse {
    return ListNetworkPeeringsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNetworkPeeringsResponse>): ListNetworkPeeringsResponse {
    const message = createBaseListNetworkPeeringsResponse();
    message.networkPeerings = object.networkPeerings?.map((e) => NetworkPeering.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseListPeeringRoutesRequest(): ListPeeringRoutesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListPeeringRoutesRequest: MessageFns<ListPeeringRoutesRequest> = {
  encode(message: ListPeeringRoutesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(50).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPeeringRoutesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPeeringRoutesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPeeringRoutesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListPeeringRoutesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPeeringRoutesRequest>): ListPeeringRoutesRequest {
    return ListPeeringRoutesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPeeringRoutesRequest>): ListPeeringRoutesRequest {
    const message = createBaseListPeeringRoutesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListPeeringRoutesResponse(): ListPeeringRoutesResponse {
  return { peeringRoutes: [], nextPageToken: "" };
}

export const ListPeeringRoutesResponse: MessageFns<ListPeeringRoutesResponse> = {
  encode(message: ListPeeringRoutesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.peeringRoutes) {
      PeeringRoute.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPeeringRoutesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPeeringRoutesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.peeringRoutes.push(PeeringRoute.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPeeringRoutesResponse {
    return {
      peeringRoutes: globalThis.Array.isArray(object?.peeringRoutes)
        ? object.peeringRoutes.map((e: any) => PeeringRoute.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPeeringRoutesResponse): unknown {
    const obj: any = {};
    if (message.peeringRoutes?.length) {
      obj.peeringRoutes = message.peeringRoutes.map((e) => PeeringRoute.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPeeringRoutesResponse>): ListPeeringRoutesResponse {
    return ListPeeringRoutesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPeeringRoutesResponse>): ListPeeringRoutesResponse {
    const message = createBaseListPeeringRoutesResponse();
    message.peeringRoutes = object.peeringRoutes?.map((e) => PeeringRoute.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListNetworkPoliciesRequest(): ListNetworkPoliciesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListNetworkPoliciesRequest: MessageFns<ListNetworkPoliciesRequest> = {
  encode(message: ListNetworkPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNetworkPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNetworkPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNetworkPoliciesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListNetworkPoliciesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNetworkPoliciesRequest>): ListNetworkPoliciesRequest {
    return ListNetworkPoliciesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNetworkPoliciesRequest>): ListNetworkPoliciesRequest {
    const message = createBaseListNetworkPoliciesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListNetworkPoliciesResponse(): ListNetworkPoliciesResponse {
  return { networkPolicies: [], nextPageToken: "", unreachable: [] };
}

export const ListNetworkPoliciesResponse: MessageFns<ListNetworkPoliciesResponse> = {
  encode(message: ListNetworkPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.networkPolicies) {
      NetworkPolicy.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNetworkPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNetworkPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networkPolicies.push(NetworkPolicy.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNetworkPoliciesResponse {
    return {
      networkPolicies: globalThis.Array.isArray(object?.networkPolicies)
        ? object.networkPolicies.map((e: any) => NetworkPolicy.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListNetworkPoliciesResponse): unknown {
    const obj: any = {};
    if (message.networkPolicies?.length) {
      obj.networkPolicies = message.networkPolicies.map((e) => NetworkPolicy.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNetworkPoliciesResponse>): ListNetworkPoliciesResponse {
    return ListNetworkPoliciesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNetworkPoliciesResponse>): ListNetworkPoliciesResponse {
    const message = createBaseListNetworkPoliciesResponse();
    message.networkPolicies = object.networkPolicies?.map((e) => NetworkPolicy.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetNetworkPolicyRequest(): GetNetworkPolicyRequest {
  return { name: "" };
}

export const GetNetworkPolicyRequest: MessageFns<GetNetworkPolicyRequest> = {
  encode(message: GetNetworkPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkPolicyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNetworkPolicyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNetworkPolicyRequest>): GetNetworkPolicyRequest {
    return GetNetworkPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNetworkPolicyRequest>): GetNetworkPolicyRequest {
    const message = createBaseGetNetworkPolicyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateNetworkPolicyRequest(): UpdateNetworkPolicyRequest {
  return { networkPolicy: undefined, updateMask: undefined, requestId: "" };
}

export const UpdateNetworkPolicyRequest: MessageFns<UpdateNetworkPolicyRequest> = {
  encode(message: UpdateNetworkPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkPolicy !== undefined) {
      NetworkPolicy.encode(message.networkPolicy, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNetworkPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNetworkPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networkPolicy = NetworkPolicy.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNetworkPolicyRequest {
    return {
      networkPolicy: isSet(object.networkPolicy) ? NetworkPolicy.fromJSON(object.networkPolicy) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateNetworkPolicyRequest): unknown {
    const obj: any = {};
    if (message.networkPolicy !== undefined) {
      obj.networkPolicy = NetworkPolicy.toJSON(message.networkPolicy);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateNetworkPolicyRequest>): UpdateNetworkPolicyRequest {
    return UpdateNetworkPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateNetworkPolicyRequest>): UpdateNetworkPolicyRequest {
    const message = createBaseUpdateNetworkPolicyRequest();
    message.networkPolicy = (object.networkPolicy !== undefined && object.networkPolicy !== null)
      ? NetworkPolicy.fromPartial(object.networkPolicy)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCreateNetworkPolicyRequest(): CreateNetworkPolicyRequest {
  return { parent: "", networkPolicyId: "", networkPolicy: undefined, requestId: "" };
}

export const CreateNetworkPolicyRequest: MessageFns<CreateNetworkPolicyRequest> = {
  encode(message: CreateNetworkPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.networkPolicyId !== "") {
      writer.uint32(18).string(message.networkPolicyId);
    }
    if (message.networkPolicy !== undefined) {
      NetworkPolicy.encode(message.networkPolicy, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNetworkPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNetworkPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.networkPolicyId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.networkPolicy = NetworkPolicy.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNetworkPolicyRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      networkPolicyId: isSet(object.networkPolicyId) ? globalThis.String(object.networkPolicyId) : "",
      networkPolicy: isSet(object.networkPolicy) ? NetworkPolicy.fromJSON(object.networkPolicy) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateNetworkPolicyRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.networkPolicyId !== "") {
      obj.networkPolicyId = message.networkPolicyId;
    }
    if (message.networkPolicy !== undefined) {
      obj.networkPolicy = NetworkPolicy.toJSON(message.networkPolicy);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNetworkPolicyRequest>): CreateNetworkPolicyRequest {
    return CreateNetworkPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNetworkPolicyRequest>): CreateNetworkPolicyRequest {
    const message = createBaseCreateNetworkPolicyRequest();
    message.parent = object.parent ?? "";
    message.networkPolicyId = object.networkPolicyId ?? "";
    message.networkPolicy = (object.networkPolicy !== undefined && object.networkPolicy !== null)
      ? NetworkPolicy.fromPartial(object.networkPolicy)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteNetworkPolicyRequest(): DeleteNetworkPolicyRequest {
  return { name: "", requestId: "" };
}

export const DeleteNetworkPolicyRequest: MessageFns<DeleteNetworkPolicyRequest> = {
  encode(message: DeleteNetworkPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNetworkPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNetworkPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNetworkPolicyRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteNetworkPolicyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteNetworkPolicyRequest>): DeleteNetworkPolicyRequest {
    return DeleteNetworkPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteNetworkPolicyRequest>): DeleteNetworkPolicyRequest {
    const message = createBaseDeleteNetworkPolicyRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListManagementDnsZoneBindingsRequest(): ListManagementDnsZoneBindingsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListManagementDnsZoneBindingsRequest: MessageFns<ListManagementDnsZoneBindingsRequest> = {
  encode(message: ListManagementDnsZoneBindingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListManagementDnsZoneBindingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListManagementDnsZoneBindingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListManagementDnsZoneBindingsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListManagementDnsZoneBindingsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListManagementDnsZoneBindingsRequest>): ListManagementDnsZoneBindingsRequest {
    return ListManagementDnsZoneBindingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListManagementDnsZoneBindingsRequest>): ListManagementDnsZoneBindingsRequest {
    const message = createBaseListManagementDnsZoneBindingsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListManagementDnsZoneBindingsResponse(): ListManagementDnsZoneBindingsResponse {
  return { managementDnsZoneBindings: [], nextPageToken: "", unreachable: [] };
}

export const ListManagementDnsZoneBindingsResponse: MessageFns<ListManagementDnsZoneBindingsResponse> = {
  encode(message: ListManagementDnsZoneBindingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.managementDnsZoneBindings) {
      ManagementDnsZoneBinding.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListManagementDnsZoneBindingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListManagementDnsZoneBindingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.managementDnsZoneBindings.push(ManagementDnsZoneBinding.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListManagementDnsZoneBindingsResponse {
    return {
      managementDnsZoneBindings: globalThis.Array.isArray(object?.managementDnsZoneBindings)
        ? object.managementDnsZoneBindings.map((e: any) => ManagementDnsZoneBinding.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListManagementDnsZoneBindingsResponse): unknown {
    const obj: any = {};
    if (message.managementDnsZoneBindings?.length) {
      obj.managementDnsZoneBindings = message.managementDnsZoneBindings.map((e) => ManagementDnsZoneBinding.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListManagementDnsZoneBindingsResponse>): ListManagementDnsZoneBindingsResponse {
    return ListManagementDnsZoneBindingsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListManagementDnsZoneBindingsResponse>): ListManagementDnsZoneBindingsResponse {
    const message = createBaseListManagementDnsZoneBindingsResponse();
    message.managementDnsZoneBindings =
      object.managementDnsZoneBindings?.map((e) => ManagementDnsZoneBinding.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetManagementDnsZoneBindingRequest(): GetManagementDnsZoneBindingRequest {
  return { name: "" };
}

export const GetManagementDnsZoneBindingRequest: MessageFns<GetManagementDnsZoneBindingRequest> = {
  encode(message: GetManagementDnsZoneBindingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetManagementDnsZoneBindingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetManagementDnsZoneBindingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetManagementDnsZoneBindingRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetManagementDnsZoneBindingRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetManagementDnsZoneBindingRequest>): GetManagementDnsZoneBindingRequest {
    return GetManagementDnsZoneBindingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetManagementDnsZoneBindingRequest>): GetManagementDnsZoneBindingRequest {
    const message = createBaseGetManagementDnsZoneBindingRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateManagementDnsZoneBindingRequest(): CreateManagementDnsZoneBindingRequest {
  return { parent: "", managementDnsZoneBinding: undefined, managementDnsZoneBindingId: "", requestId: "" };
}

export const CreateManagementDnsZoneBindingRequest: MessageFns<CreateManagementDnsZoneBindingRequest> = {
  encode(message: CreateManagementDnsZoneBindingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.managementDnsZoneBinding !== undefined) {
      ManagementDnsZoneBinding.encode(message.managementDnsZoneBinding, writer.uint32(18).fork()).join();
    }
    if (message.managementDnsZoneBindingId !== "") {
      writer.uint32(26).string(message.managementDnsZoneBindingId);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateManagementDnsZoneBindingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateManagementDnsZoneBindingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.managementDnsZoneBinding = ManagementDnsZoneBinding.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.managementDnsZoneBindingId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateManagementDnsZoneBindingRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      managementDnsZoneBinding: isSet(object.managementDnsZoneBinding)
        ? ManagementDnsZoneBinding.fromJSON(object.managementDnsZoneBinding)
        : undefined,
      managementDnsZoneBindingId: isSet(object.managementDnsZoneBindingId)
        ? globalThis.String(object.managementDnsZoneBindingId)
        : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateManagementDnsZoneBindingRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.managementDnsZoneBinding !== undefined) {
      obj.managementDnsZoneBinding = ManagementDnsZoneBinding.toJSON(message.managementDnsZoneBinding);
    }
    if (message.managementDnsZoneBindingId !== "") {
      obj.managementDnsZoneBindingId = message.managementDnsZoneBindingId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateManagementDnsZoneBindingRequest>): CreateManagementDnsZoneBindingRequest {
    return CreateManagementDnsZoneBindingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateManagementDnsZoneBindingRequest>): CreateManagementDnsZoneBindingRequest {
    const message = createBaseCreateManagementDnsZoneBindingRequest();
    message.parent = object.parent ?? "";
    message.managementDnsZoneBinding =
      (object.managementDnsZoneBinding !== undefined && object.managementDnsZoneBinding !== null)
        ? ManagementDnsZoneBinding.fromPartial(object.managementDnsZoneBinding)
        : undefined;
    message.managementDnsZoneBindingId = object.managementDnsZoneBindingId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateManagementDnsZoneBindingRequest(): UpdateManagementDnsZoneBindingRequest {
  return { updateMask: undefined, managementDnsZoneBinding: undefined, requestId: "" };
}

export const UpdateManagementDnsZoneBindingRequest: MessageFns<UpdateManagementDnsZoneBindingRequest> = {
  encode(message: UpdateManagementDnsZoneBindingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.managementDnsZoneBinding !== undefined) {
      ManagementDnsZoneBinding.encode(message.managementDnsZoneBinding, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateManagementDnsZoneBindingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateManagementDnsZoneBindingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.managementDnsZoneBinding = ManagementDnsZoneBinding.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateManagementDnsZoneBindingRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      managementDnsZoneBinding: isSet(object.managementDnsZoneBinding)
        ? ManagementDnsZoneBinding.fromJSON(object.managementDnsZoneBinding)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateManagementDnsZoneBindingRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.managementDnsZoneBinding !== undefined) {
      obj.managementDnsZoneBinding = ManagementDnsZoneBinding.toJSON(message.managementDnsZoneBinding);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateManagementDnsZoneBindingRequest>): UpdateManagementDnsZoneBindingRequest {
    return UpdateManagementDnsZoneBindingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateManagementDnsZoneBindingRequest>): UpdateManagementDnsZoneBindingRequest {
    const message = createBaseUpdateManagementDnsZoneBindingRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.managementDnsZoneBinding =
      (object.managementDnsZoneBinding !== undefined && object.managementDnsZoneBinding !== null)
        ? ManagementDnsZoneBinding.fromPartial(object.managementDnsZoneBinding)
        : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteManagementDnsZoneBindingRequest(): DeleteManagementDnsZoneBindingRequest {
  return { name: "", requestId: "" };
}

export const DeleteManagementDnsZoneBindingRequest: MessageFns<DeleteManagementDnsZoneBindingRequest> = {
  encode(message: DeleteManagementDnsZoneBindingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteManagementDnsZoneBindingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteManagementDnsZoneBindingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteManagementDnsZoneBindingRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteManagementDnsZoneBindingRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteManagementDnsZoneBindingRequest>): DeleteManagementDnsZoneBindingRequest {
    return DeleteManagementDnsZoneBindingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteManagementDnsZoneBindingRequest>): DeleteManagementDnsZoneBindingRequest {
    const message = createBaseDeleteManagementDnsZoneBindingRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseRepairManagementDnsZoneBindingRequest(): RepairManagementDnsZoneBindingRequest {
  return { name: "", requestId: "" };
}

export const RepairManagementDnsZoneBindingRequest: MessageFns<RepairManagementDnsZoneBindingRequest> = {
  encode(message: RepairManagementDnsZoneBindingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepairManagementDnsZoneBindingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepairManagementDnsZoneBindingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepairManagementDnsZoneBindingRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: RepairManagementDnsZoneBindingRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<RepairManagementDnsZoneBindingRequest>): RepairManagementDnsZoneBindingRequest {
    return RepairManagementDnsZoneBindingRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepairManagementDnsZoneBindingRequest>): RepairManagementDnsZoneBindingRequest {
    const message = createBaseRepairManagementDnsZoneBindingRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCreateVmwareEngineNetworkRequest(): CreateVmwareEngineNetworkRequest {
  return { parent: "", vmwareEngineNetworkId: "", vmwareEngineNetwork: undefined, requestId: "" };
}

export const CreateVmwareEngineNetworkRequest: MessageFns<CreateVmwareEngineNetworkRequest> = {
  encode(message: CreateVmwareEngineNetworkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.vmwareEngineNetworkId !== "") {
      writer.uint32(18).string(message.vmwareEngineNetworkId);
    }
    if (message.vmwareEngineNetwork !== undefined) {
      VmwareEngineNetwork.encode(message.vmwareEngineNetwork, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateVmwareEngineNetworkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateVmwareEngineNetworkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vmwareEngineNetworkId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vmwareEngineNetwork = VmwareEngineNetwork.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateVmwareEngineNetworkRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      vmwareEngineNetworkId: isSet(object.vmwareEngineNetworkId) ? globalThis.String(object.vmwareEngineNetworkId) : "",
      vmwareEngineNetwork: isSet(object.vmwareEngineNetwork)
        ? VmwareEngineNetwork.fromJSON(object.vmwareEngineNetwork)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateVmwareEngineNetworkRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.vmwareEngineNetworkId !== "") {
      obj.vmwareEngineNetworkId = message.vmwareEngineNetworkId;
    }
    if (message.vmwareEngineNetwork !== undefined) {
      obj.vmwareEngineNetwork = VmwareEngineNetwork.toJSON(message.vmwareEngineNetwork);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateVmwareEngineNetworkRequest>): CreateVmwareEngineNetworkRequest {
    return CreateVmwareEngineNetworkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateVmwareEngineNetworkRequest>): CreateVmwareEngineNetworkRequest {
    const message = createBaseCreateVmwareEngineNetworkRequest();
    message.parent = object.parent ?? "";
    message.vmwareEngineNetworkId = object.vmwareEngineNetworkId ?? "";
    message.vmwareEngineNetwork = (object.vmwareEngineNetwork !== undefined && object.vmwareEngineNetwork !== null)
      ? VmwareEngineNetwork.fromPartial(object.vmwareEngineNetwork)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseUpdateVmwareEngineNetworkRequest(): UpdateVmwareEngineNetworkRequest {
  return { vmwareEngineNetwork: undefined, updateMask: undefined, requestId: "" };
}

export const UpdateVmwareEngineNetworkRequest: MessageFns<UpdateVmwareEngineNetworkRequest> = {
  encode(message: UpdateVmwareEngineNetworkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vmwareEngineNetwork !== undefined) {
      VmwareEngineNetwork.encode(message.vmwareEngineNetwork, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVmwareEngineNetworkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVmwareEngineNetworkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vmwareEngineNetwork = VmwareEngineNetwork.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateVmwareEngineNetworkRequest {
    return {
      vmwareEngineNetwork: isSet(object.vmwareEngineNetwork)
        ? VmwareEngineNetwork.fromJSON(object.vmwareEngineNetwork)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateVmwareEngineNetworkRequest): unknown {
    const obj: any = {};
    if (message.vmwareEngineNetwork !== undefined) {
      obj.vmwareEngineNetwork = VmwareEngineNetwork.toJSON(message.vmwareEngineNetwork);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateVmwareEngineNetworkRequest>): UpdateVmwareEngineNetworkRequest {
    return UpdateVmwareEngineNetworkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateVmwareEngineNetworkRequest>): UpdateVmwareEngineNetworkRequest {
    const message = createBaseUpdateVmwareEngineNetworkRequest();
    message.vmwareEngineNetwork = (object.vmwareEngineNetwork !== undefined && object.vmwareEngineNetwork !== null)
      ? VmwareEngineNetwork.fromPartial(object.vmwareEngineNetwork)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteVmwareEngineNetworkRequest(): DeleteVmwareEngineNetworkRequest {
  return { name: "", requestId: "", etag: "" };
}

export const DeleteVmwareEngineNetworkRequest: MessageFns<DeleteVmwareEngineNetworkRequest> = {
  encode(message: DeleteVmwareEngineNetworkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.etag !== "") {
      writer.uint32(26).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteVmwareEngineNetworkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteVmwareEngineNetworkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteVmwareEngineNetworkRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteVmwareEngineNetworkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteVmwareEngineNetworkRequest>): DeleteVmwareEngineNetworkRequest {
    return DeleteVmwareEngineNetworkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteVmwareEngineNetworkRequest>): DeleteVmwareEngineNetworkRequest {
    const message = createBaseDeleteVmwareEngineNetworkRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseGetVmwareEngineNetworkRequest(): GetVmwareEngineNetworkRequest {
  return { name: "" };
}

export const GetVmwareEngineNetworkRequest: MessageFns<GetVmwareEngineNetworkRequest> = {
  encode(message: GetVmwareEngineNetworkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVmwareEngineNetworkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVmwareEngineNetworkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVmwareEngineNetworkRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetVmwareEngineNetworkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetVmwareEngineNetworkRequest>): GetVmwareEngineNetworkRequest {
    return GetVmwareEngineNetworkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVmwareEngineNetworkRequest>): GetVmwareEngineNetworkRequest {
    const message = createBaseGetVmwareEngineNetworkRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListVmwareEngineNetworksRequest(): ListVmwareEngineNetworksRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListVmwareEngineNetworksRequest: MessageFns<ListVmwareEngineNetworksRequest> = {
  encode(message: ListVmwareEngineNetworksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVmwareEngineNetworksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVmwareEngineNetworksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVmwareEngineNetworksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListVmwareEngineNetworksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVmwareEngineNetworksRequest>): ListVmwareEngineNetworksRequest {
    return ListVmwareEngineNetworksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVmwareEngineNetworksRequest>): ListVmwareEngineNetworksRequest {
    const message = createBaseListVmwareEngineNetworksRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListVmwareEngineNetworksResponse(): ListVmwareEngineNetworksResponse {
  return { vmwareEngineNetworks: [], nextPageToken: "", unreachable: [] };
}

export const ListVmwareEngineNetworksResponse: MessageFns<ListVmwareEngineNetworksResponse> = {
  encode(message: ListVmwareEngineNetworksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.vmwareEngineNetworks) {
      VmwareEngineNetwork.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVmwareEngineNetworksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVmwareEngineNetworksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vmwareEngineNetworks.push(VmwareEngineNetwork.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVmwareEngineNetworksResponse {
    return {
      vmwareEngineNetworks: globalThis.Array.isArray(object?.vmwareEngineNetworks)
        ? object.vmwareEngineNetworks.map((e: any) => VmwareEngineNetwork.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListVmwareEngineNetworksResponse): unknown {
    const obj: any = {};
    if (message.vmwareEngineNetworks?.length) {
      obj.vmwareEngineNetworks = message.vmwareEngineNetworks.map((e) => VmwareEngineNetwork.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVmwareEngineNetworksResponse>): ListVmwareEngineNetworksResponse {
    return ListVmwareEngineNetworksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVmwareEngineNetworksResponse>): ListVmwareEngineNetworksResponse {
    const message = createBaseListVmwareEngineNetworksResponse();
    message.vmwareEngineNetworks = object.vmwareEngineNetworks?.map((e) => VmwareEngineNetwork.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreatePrivateConnectionRequest(): CreatePrivateConnectionRequest {
  return { parent: "", privateConnectionId: "", privateConnection: undefined, requestId: "" };
}

export const CreatePrivateConnectionRequest: MessageFns<CreatePrivateConnectionRequest> = {
  encode(message: CreatePrivateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.privateConnectionId !== "") {
      writer.uint32(18).string(message.privateConnectionId);
    }
    if (message.privateConnection !== undefined) {
      PrivateConnection.encode(message.privateConnection, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePrivateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePrivateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.privateConnectionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.privateConnection = PrivateConnection.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePrivateConnectionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      privateConnectionId: isSet(object.privateConnectionId) ? globalThis.String(object.privateConnectionId) : "",
      privateConnection: isSet(object.privateConnection)
        ? PrivateConnection.fromJSON(object.privateConnection)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreatePrivateConnectionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.privateConnectionId !== "") {
      obj.privateConnectionId = message.privateConnectionId;
    }
    if (message.privateConnection !== undefined) {
      obj.privateConnection = PrivateConnection.toJSON(message.privateConnection);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreatePrivateConnectionRequest>): CreatePrivateConnectionRequest {
    return CreatePrivateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreatePrivateConnectionRequest>): CreatePrivateConnectionRequest {
    const message = createBaseCreatePrivateConnectionRequest();
    message.parent = object.parent ?? "";
    message.privateConnectionId = object.privateConnectionId ?? "";
    message.privateConnection = (object.privateConnection !== undefined && object.privateConnection !== null)
      ? PrivateConnection.fromPartial(object.privateConnection)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseGetPrivateConnectionRequest(): GetPrivateConnectionRequest {
  return { name: "" };
}

export const GetPrivateConnectionRequest: MessageFns<GetPrivateConnectionRequest> = {
  encode(message: GetPrivateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPrivateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPrivateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPrivateConnectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetPrivateConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPrivateConnectionRequest>): GetPrivateConnectionRequest {
    return GetPrivateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPrivateConnectionRequest>): GetPrivateConnectionRequest {
    const message = createBaseGetPrivateConnectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListPrivateConnectionsRequest(): ListPrivateConnectionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListPrivateConnectionsRequest: MessageFns<ListPrivateConnectionsRequest> = {
  encode(message: ListPrivateConnectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPrivateConnectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPrivateConnectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPrivateConnectionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListPrivateConnectionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPrivateConnectionsRequest>): ListPrivateConnectionsRequest {
    return ListPrivateConnectionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPrivateConnectionsRequest>): ListPrivateConnectionsRequest {
    const message = createBaseListPrivateConnectionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListPrivateConnectionsResponse(): ListPrivateConnectionsResponse {
  return { privateConnections: [], nextPageToken: "", unreachable: [] };
}

export const ListPrivateConnectionsResponse: MessageFns<ListPrivateConnectionsResponse> = {
  encode(message: ListPrivateConnectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.privateConnections) {
      PrivateConnection.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPrivateConnectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPrivateConnectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateConnections.push(PrivateConnection.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPrivateConnectionsResponse {
    return {
      privateConnections: globalThis.Array.isArray(object?.privateConnections)
        ? object.privateConnections.map((e: any) => PrivateConnection.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListPrivateConnectionsResponse): unknown {
    const obj: any = {};
    if (message.privateConnections?.length) {
      obj.privateConnections = message.privateConnections.map((e) => PrivateConnection.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPrivateConnectionsResponse>): ListPrivateConnectionsResponse {
    return ListPrivateConnectionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPrivateConnectionsResponse>): ListPrivateConnectionsResponse {
    const message = createBaseListPrivateConnectionsResponse();
    message.privateConnections = object.privateConnections?.map((e) => PrivateConnection.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdatePrivateConnectionRequest(): UpdatePrivateConnectionRequest {
  return { privateConnection: undefined, updateMask: undefined, requestId: "" };
}

export const UpdatePrivateConnectionRequest: MessageFns<UpdatePrivateConnectionRequest> = {
  encode(message: UpdatePrivateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privateConnection !== undefined) {
      PrivateConnection.encode(message.privateConnection, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePrivateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePrivateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.privateConnection = PrivateConnection.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePrivateConnectionRequest {
    return {
      privateConnection: isSet(object.privateConnection)
        ? PrivateConnection.fromJSON(object.privateConnection)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdatePrivateConnectionRequest): unknown {
    const obj: any = {};
    if (message.privateConnection !== undefined) {
      obj.privateConnection = PrivateConnection.toJSON(message.privateConnection);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePrivateConnectionRequest>): UpdatePrivateConnectionRequest {
    return UpdatePrivateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePrivateConnectionRequest>): UpdatePrivateConnectionRequest {
    const message = createBaseUpdatePrivateConnectionRequest();
    message.privateConnection = (object.privateConnection !== undefined && object.privateConnection !== null)
      ? PrivateConnection.fromPartial(object.privateConnection)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeletePrivateConnectionRequest(): DeletePrivateConnectionRequest {
  return { name: "", requestId: "" };
}

export const DeletePrivateConnectionRequest: MessageFns<DeletePrivateConnectionRequest> = {
  encode(message: DeletePrivateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePrivateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePrivateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePrivateConnectionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeletePrivateConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeletePrivateConnectionRequest>): DeletePrivateConnectionRequest {
    return DeletePrivateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeletePrivateConnectionRequest>): DeletePrivateConnectionRequest {
    const message = createBaseDeletePrivateConnectionRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListPrivateConnectionPeeringRoutesRequest(): ListPrivateConnectionPeeringRoutesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListPrivateConnectionPeeringRoutesRequest: MessageFns<ListPrivateConnectionPeeringRoutesRequest> = {
  encode(message: ListPrivateConnectionPeeringRoutesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPrivateConnectionPeeringRoutesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPrivateConnectionPeeringRoutesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPrivateConnectionPeeringRoutesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListPrivateConnectionPeeringRoutesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPrivateConnectionPeeringRoutesRequest>): ListPrivateConnectionPeeringRoutesRequest {
    return ListPrivateConnectionPeeringRoutesRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListPrivateConnectionPeeringRoutesRequest>,
  ): ListPrivateConnectionPeeringRoutesRequest {
    const message = createBaseListPrivateConnectionPeeringRoutesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListPrivateConnectionPeeringRoutesResponse(): ListPrivateConnectionPeeringRoutesResponse {
  return { peeringRoutes: [], nextPageToken: "" };
}

export const ListPrivateConnectionPeeringRoutesResponse: MessageFns<ListPrivateConnectionPeeringRoutesResponse> = {
  encode(message: ListPrivateConnectionPeeringRoutesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.peeringRoutes) {
      PeeringRoute.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPrivateConnectionPeeringRoutesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPrivateConnectionPeeringRoutesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.peeringRoutes.push(PeeringRoute.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPrivateConnectionPeeringRoutesResponse {
    return {
      peeringRoutes: globalThis.Array.isArray(object?.peeringRoutes)
        ? object.peeringRoutes.map((e: any) => PeeringRoute.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPrivateConnectionPeeringRoutesResponse): unknown {
    const obj: any = {};
    if (message.peeringRoutes?.length) {
      obj.peeringRoutes = message.peeringRoutes.map((e) => PeeringRoute.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPrivateConnectionPeeringRoutesResponse>): ListPrivateConnectionPeeringRoutesResponse {
    return ListPrivateConnectionPeeringRoutesResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ListPrivateConnectionPeeringRoutesResponse>,
  ): ListPrivateConnectionPeeringRoutesResponse {
    const message = createBaseListPrivateConnectionPeeringRoutesResponse();
    message.peeringRoutes = object.peeringRoutes?.map((e) => PeeringRoute.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGrantDnsBindPermissionRequest(): GrantDnsBindPermissionRequest {
  return { name: "", principal: undefined, requestId: "" };
}

export const GrantDnsBindPermissionRequest: MessageFns<GrantDnsBindPermissionRequest> = {
  encode(message: GrantDnsBindPermissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.principal !== undefined) {
      Principal.encode(message.principal, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GrantDnsBindPermissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGrantDnsBindPermissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.principal = Principal.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GrantDnsBindPermissionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      principal: isSet(object.principal) ? Principal.fromJSON(object.principal) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: GrantDnsBindPermissionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.principal !== undefined) {
      obj.principal = Principal.toJSON(message.principal);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<GrantDnsBindPermissionRequest>): GrantDnsBindPermissionRequest {
    return GrantDnsBindPermissionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GrantDnsBindPermissionRequest>): GrantDnsBindPermissionRequest {
    const message = createBaseGrantDnsBindPermissionRequest();
    message.name = object.name ?? "";
    message.principal = (object.principal !== undefined && object.principal !== null)
      ? Principal.fromPartial(object.principal)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseRevokeDnsBindPermissionRequest(): RevokeDnsBindPermissionRequest {
  return { name: "", principal: undefined, requestId: "" };
}

export const RevokeDnsBindPermissionRequest: MessageFns<RevokeDnsBindPermissionRequest> = {
  encode(message: RevokeDnsBindPermissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.principal !== undefined) {
      Principal.encode(message.principal, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevokeDnsBindPermissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevokeDnsBindPermissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.principal = Principal.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevokeDnsBindPermissionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      principal: isSet(object.principal) ? Principal.fromJSON(object.principal) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: RevokeDnsBindPermissionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.principal !== undefined) {
      obj.principal = Principal.toJSON(message.principal);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<RevokeDnsBindPermissionRequest>): RevokeDnsBindPermissionRequest {
    return RevokeDnsBindPermissionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RevokeDnsBindPermissionRequest>): RevokeDnsBindPermissionRequest {
    const message = createBaseRevokeDnsBindPermissionRequest();
    message.name = object.name ?? "";
    message.principal = (object.principal !== undefined && object.principal !== null)
      ? Principal.fromPartial(object.principal)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseGetDnsBindPermissionRequest(): GetDnsBindPermissionRequest {
  return { name: "" };
}

export const GetDnsBindPermissionRequest: MessageFns<GetDnsBindPermissionRequest> = {
  encode(message: GetDnsBindPermissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDnsBindPermissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDnsBindPermissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDnsBindPermissionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDnsBindPermissionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDnsBindPermissionRequest>): GetDnsBindPermissionRequest {
    return GetDnsBindPermissionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDnsBindPermissionRequest>): GetDnsBindPermissionRequest {
    const message = createBaseGetDnsBindPermissionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

/** VMwareEngine manages VMware's private clusters in the Cloud. */
export type VmwareEngineDefinition = typeof VmwareEngineDefinition;
export const VmwareEngineDefinition = {
  name: "VmwareEngine",
  fullName: "google.cloud.vmwareengine.v1.VmwareEngine",
  methods: {
    /** Lists `PrivateCloud` resources in a given project and location. */
    listPrivateClouds: {
      name: "ListPrivateClouds",
      requestType: ListPrivateCloudsRequest,
      requestStream: false,
      responseType: ListPrivateCloudsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              51,
              18,
              49,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves a `PrivateCloud` resource by its resource name. */
    getPrivateCloud: {
      name: "GetPrivateCloud",
      requestType: GetPrivateCloudRequest,
      requestStream: false,
      responseType: PrivateCloud,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              51,
              18,
              49,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new `PrivateCloud` resource in a given project and location.
     * Private clouds of type `STANDARD` and
     * `TIME_LIMITED` are zonal resources, `STRETCHED` private clouds are
     * regional.
     * Creating a private cloud also creates a [management
     * cluster](https://cloud.google.com/vmware-engine/docs/concepts-vmware-components)
     * for that private cloud.
     */
    createPrivateCloud: {
      name: "CreatePrivateCloud",
      requestType: CreatePrivateCloudRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              80,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              37,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              108,
              111,
              117,
              100,
              44,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              108,
              111,
              117,
              100,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              13,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              108,
              111,
              117,
              100,
              34,
              49,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Modifies a `PrivateCloud` resource. Only the following fields can be
     * updated: `description`.
     * Only fields specified in `updateMask` are applied.
     *
     * During operation processing, the resource is temporarily in the `ACTIVE`
     * state before the operation fully completes. For that period of time, you
     * can't update the resource. Use the operation status to determine when the
     * processing fully completes.
     */
    updatePrivateCloud: {
      name: "UpdatePrivateCloud",
      requestType: UpdatePrivateCloudRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              80,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              25,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              108,
              111,
              117,
              100,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              80,
              58,
              13,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              108,
              111,
              117,
              100,
              50,
              63,
              47,
              118,
              49,
              47,
              123,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              108,
              111,
              117,
              100,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Schedules a `PrivateCloud` resource for deletion.
     *
     * A `PrivateCloud` resource scheduled for deletion has `PrivateCloud.state`
     * set to `DELETED` and `expireTime` set to the time when deletion is final
     * and can no longer be reversed. The delete operation is marked as done
     * as soon as the `PrivateCloud` is successfully scheduled for deletion
     * (this also applies when `delayHours` is set to zero), and the operation is
     * not kept in pending state until `PrivateCloud` is purged.
     * `PrivateCloud` can be restored using `UndeletePrivateCloud` method before
     * the `expireTime` elapses. When `expireTime` is reached, deletion is final
     * and all private cloud resources are irreversibly removed and billing stops.
     * During the final removal process, `PrivateCloud.state` is set to `PURGING`.
     * `PrivateCloud` can be polled using standard `GET` method for the whole
     * period of deletion and purging. It will not be returned only
     * when it is completely purged.
     */
    deletePrivateCloud: {
      name: "DeletePrivateCloud",
      requestType: DeletePrivateCloudRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              80,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              51,
              42,
              49,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Restores a private cloud that was previously scheduled for deletion by
     * `DeletePrivateCloud`. A `PrivateCloud` resource scheduled for deletion has
     * `PrivateCloud.state` set to `DELETED` and `PrivateCloud.expireTime` set to
     * the time when deletion can no longer be reversed.
     */
    undeletePrivateCloud: {
      name: "UndeletePrivateCloud",
      requestType: UndeletePrivateCloudRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              80,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              58,
              117,
              110,
              100,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Lists `Cluster` resources in a given private cloud. */
    listClusters: {
      name: "ListClusters",
      requestType: ListClustersRequest,
      requestStream: false,
      responseType: ListClustersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              62,
              18,
              60,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves a `Cluster` resource by its resource name. */
    getCluster: {
      name: "GetCluster",
      requestType: GetClusterRequest,
      requestStream: false,
      responseType: Cluster,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              62,
              18,
              60,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new cluster in a given private cloud.
     * Creating a new cluster provides additional nodes for
     * use in the parent private cloud and requires sufficient [node
     * quota](https://cloud.google.com/vmware-engine/quotas).
     */
    createCluster: {
      name: "CreateCluster",
      requestType: CreateClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              7,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              25,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              44,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              7,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              34,
              60,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Modifies a `Cluster` resource. Only fields specified in `updateMask` are
     * applied.
     *
     * During operation processing, the resource is temporarily in the `ACTIVE`
     * state before the operation fully completes. For that period of time, you
     * can't update the resource. Use the operation status to determine when the
     * processing fully completes.
     */
    updateCluster: {
      name: "UpdateCluster",
      requestType: UpdateClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              7,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([19, 99, 108, 117, 115, 116, 101, 114, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              79,
              58,
              7,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              50,
              68,
              47,
              118,
              49,
              47,
              123,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a `Cluster` resource. To avoid unintended data loss, migrate or
     * gracefully shut down any workloads running on the cluster before deletion.
     * You cannot delete the management cluster of a private cloud using this
     * method.
     */
    deleteCluster: {
      name: "DeleteCluster",
      requestType: DeleteClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              62,
              42,
              60,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists nodes in a given cluster. */
    listNodes: {
      name: "ListNodes",
      requestType: ListNodesRequest,
      requestStream: false,
      responseType: ListNodesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              70,
              18,
              68,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single node. */
    getNode: {
      name: "GetNode",
      requestType: GetNodeRequest,
      requestStream: false,
      responseType: Node,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              70,
              18,
              68,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists external IP addresses assigned to VMware workload VMs in a given
     * private cloud.
     */
    listExternalAddresses: {
      name: "ListExternalAddresses",
      requestType: ListExternalAddressesRequest,
      requestStream: false,
      responseType: ListExternalAddressesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              71,
              18,
              69,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              47,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              100,
              100,
              114,
              101,
              115,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists external IP addresses assigned to VMware workload VMs within the
     * scope of the given network policy.
     */
    fetchNetworkPolicyExternalAddresses: {
      name: "FetchNetworkPolicyExternalAddresses",
      requestType: FetchNetworkPolicyExternalAddressesRequest,
      requestStream: false,
      responseType: FetchNetworkPolicyExternalAddressesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([14, 110, 101, 116, 119, 111, 114, 107, 95, 112, 111, 108, 105, 99, 121])],
          578365826: [
            Buffer.from([
              86,
              18,
              84,
              47,
              118,
              49,
              47,
              123,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
              58,
              102,
              101,
              116,
              99,
              104,
              69,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              100,
              100,
              114,
              101,
              115,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single external IP address. */
    getExternalAddress: {
      name: "GetExternalAddress",
      requestType: GetExternalAddressRequest,
      requestStream: false,
      responseType: ExternalAddress,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              71,
              18,
              69,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              100,
              100,
              114,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new `ExternalAddress` resource in a given private cloud. The
     * network policy that corresponds to the private cloud must have the external
     * IP address network service enabled (`NetworkPolicy.external_ip`).
     */
    createExternalAddress: {
      name: "CreateExternalAddress",
      requestType: CreateExternalAddressRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              36,
              10,
              15,
              69,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              100,
              100,
              114,
              101,
              115,
              115,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              43,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              100,
              100,
              114,
              101,
              115,
              115,
              44,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              100,
              100,
              114,
              101,
              115,
              115,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              89,
              58,
              16,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              100,
              100,
              114,
              101,
              115,
              115,
              34,
              69,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              47,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              100,
              100,
              114,
              101,
              115,
              115,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the parameters of a single external IP address.
     * Only fields specified in `update_mask` are applied.
     *
     * During operation processing, the resource is temporarily in the `ACTIVE`
     * state before the operation fully completes. For that period of time, you
     * can't update the resource. Use the operation status to determine when the
     * processing fully completes.
     */
    updateExternalAddress: {
      name: "UpdateExternalAddress",
      requestType: UpdateExternalAddressRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              36,
              10,
              15,
              69,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              100,
              100,
              114,
              101,
              115,
              115,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              28,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              100,
              100,
              114,
              101,
              115,
              115,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              106,
              58,
              16,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              100,
              100,
              114,
              101,
              115,
              115,
              50,
              86,
              47,
              118,
              49,
              47,
              123,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              100,
              100,
              114,
              101,
              115,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              100,
              100,
              114,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a single external IP address. When you delete an external IP
     * address, connectivity between the external IP address and the corresponding
     * internal IP address is lost.
     */
    deleteExternalAddress: {
      name: "DeleteExternalAddress",
      requestType: DeleteExternalAddressRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              71,
              42,
              69,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              100,
              100,
              114,
              101,
              115,
              115,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists subnets in a given private cloud. */
    listSubnets: {
      name: "ListSubnets",
      requestType: ListSubnetsRequest,
      requestStream: false,
      responseType: ListSubnetsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              47,
              115,
              117,
              98,
              110,
              101,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single subnet. */
    getSubnet: {
      name: "GetSubnet",
      requestType: GetSubnetRequest,
      requestStream: false,
      responseType: Subnet,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              61,
              18,
              59,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              115,
              117,
              98,
              110,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the parameters of a single subnet. Only fields specified in
     * `update_mask` are applied.
     *
     * *Note*: This API is synchronous and always returns a successful
     * `google.longrunning.Operation` (LRO). The returned LRO will only have
     * `done` and `response` fields.
     */
    updateSubnet: {
      name: "UpdateSubnet",
      requestType: UpdateSubnetRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              27,
              10,
              6,
              83,
              117,
              98,
              110,
              101,
              116,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([18, 115, 117, 98, 110, 101, 116, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107]),
          ],
          578365826: [
            Buffer.from([
              76,
              58,
              6,
              115,
              117,
              98,
              110,
              101,
              116,
              50,
              66,
              47,
              118,
              49,
              47,
              123,
              115,
              117,
              98,
              110,
              101,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              115,
              117,
              98,
              110,
              101,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists `ExternalAccessRule` resources in the specified network policy. */
    listExternalAccessRules: {
      name: "ListExternalAccessRules",
      requestType: ListExternalAccessRulesRequest,
      requestStream: false,
      responseType: ListExternalAccessRulesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              75,
              18,
              73,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
              47,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              99,
              99,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single external access rule. */
    getExternalAccessRule: {
      name: "GetExternalAccessRule",
      requestType: GetExternalAccessRuleRequest,
      requestStream: false,
      responseType: ExternalAccessRule,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              75,
              18,
              73,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              47,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              99,
              99,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new external access rule in a given network policy. */
    createExternalAccessRule: {
      name: "CreateExternalAccessRule",
      requestType: CreateExternalAccessRuleRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              39,
              10,
              18,
              69,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              99,
              99,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              51,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              99,
              99,
              101,
              115,
              115,
              95,
              114,
              117,
              108,
              101,
              44,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              99,
              99,
              101,
              115,
              115,
              95,
              114,
              117,
              108,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              97,
              58,
              20,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              99,
              99,
              101,
              115,
              115,
              95,
              114,
              117,
              108,
              101,
              34,
              73,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
              47,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              99,
              99,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the parameters of a single external access rule.
     * Only fields specified in `update_mask` are applied.
     */
    updateExternalAccessRule: {
      name: "UpdateExternalAccessRule",
      requestType: UpdateExternalAccessRuleRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              39,
              10,
              18,
              69,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              99,
              99,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              32,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              99,
              99,
              101,
              115,
              115,
              95,
              114,
              117,
              108,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              118,
              58,
              20,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              99,
              99,
              101,
              115,
              115,
              95,
              114,
              117,
              108,
              101,
              50,
              94,
              47,
              118,
              49,
              47,
              123,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              95,
              97,
              99,
              99,
              101,
              115,
              115,
              95,
              114,
              117,
              108,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              47,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              99,
              99,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single external access rule. */
    deleteExternalAccessRule: {
      name: "DeleteExternalAccessRule",
      requestType: DeleteExternalAccessRuleRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              75,
              42,
              73,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              47,
              101,
              120,
              116,
              101,
              114,
              110,
              97,
              108,
              65,
              99,
              99,
              101,
              115,
              115,
              82,
              117,
              108,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists logging servers configured for a given private
     * cloud.
     */
    listLoggingServers: {
      name: "ListLoggingServers",
      requestType: ListLoggingServersRequest,
      requestStream: false,
      responseType: ListLoggingServersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              68,
              18,
              66,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              47,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              83,
              101,
              114,
              118,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a logging server. */
    getLoggingServer: {
      name: "GetLoggingServer",
      requestType: GetLoggingServerRequest,
      requestStream: false,
      responseType: LoggingServer,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              68,
              18,
              66,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              83,
              101,
              114,
              118,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Create a new logging server for a given private cloud. */
    createLoggingServer: {
      name: "CreateLoggingServer",
      requestType: CreateLoggingServerRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              13,
              76,
              111,
              103,
              103,
              105,
              110,
              103,
              83,
              101,
              114,
              118,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              39,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              95,
              115,
              101,
              114,
              118,
              101,
              114,
              44,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              95,
              115,
              101,
              114,
              118,
              101,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              84,
              58,
              14,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              95,
              115,
              101,
              114,
              118,
              101,
              114,
              34,
              66,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              47,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              83,
              101,
              114,
              118,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the parameters of a single logging server.
     * Only fields specified in `update_mask` are applied.
     */
    updateLoggingServer: {
      name: "UpdateLoggingServer",
      requestType: UpdateLoggingServerRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              13,
              76,
              111,
              103,
              103,
              105,
              110,
              103,
              83,
              101,
              114,
              118,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              26,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              95,
              115,
              101,
              114,
              118,
              101,
              114,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              99,
              58,
              14,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              95,
              115,
              101,
              114,
              118,
              101,
              114,
              50,
              81,
              47,
              118,
              49,
              47,
              123,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              95,
              115,
              101,
              114,
              118,
              101,
              114,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              83,
              101,
              114,
              118,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a single logging server. */
    deleteLoggingServer: {
      name: "DeleteLoggingServer",
      requestType: DeleteLoggingServerRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              68,
              42,
              66,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              108,
              111,
              103,
              103,
              105,
              110,
              103,
              83,
              101,
              114,
              118,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists node types */
    listNodeTypes: {
      name: "ListNodeTypes",
      requestType: ListNodeTypesRequest,
      requestStream: false,
      responseType: ListNodeTypesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single `NodeType`. */
    getNodeType: {
      name: "GetNodeType",
      requestType: GetNodeTypeRequest,
      requestStream: false,
      responseType: NodeType,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets details of credentials for NSX appliance. */
    showNsxCredentials: {
      name: "ShowNsxCredentials",
      requestType: ShowNsxCredentialsRequest,
      requestStream: false,
      responseType: Credentials,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([13, 112, 114, 105, 118, 97, 116, 101, 95, 99, 108, 111, 117, 100])],
          578365826: [
            Buffer.from([
              79,
              18,
              77,
              47,
              118,
              49,
              47,
              123,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              108,
              111,
              117,
              100,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              58,
              115,
              104,
              111,
              119,
              78,
              115,
              120,
              67,
              114,
              101,
              100,
              101,
              110,
              116,
              105,
              97,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of credentials for Vcenter appliance. */
    showVcenterCredentials: {
      name: "ShowVcenterCredentials",
      requestType: ShowVcenterCredentialsRequest,
      requestStream: false,
      responseType: Credentials,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([13, 112, 114, 105, 118, 97, 116, 101, 95, 99, 108, 111, 117, 100])],
          578365826: [
            Buffer.from([
              83,
              18,
              81,
              47,
              118,
              49,
              47,
              123,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              108,
              111,
              117,
              100,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              58,
              115,
              104,
              111,
              119,
              86,
              99,
              101,
              110,
              116,
              101,
              114,
              67,
              114,
              101,
              100,
              101,
              110,
              116,
              105,
              97,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Resets credentials of the NSX appliance. */
    resetNsxCredentials: {
      name: "ResetNsxCredentials",
      requestType: ResetNsxCredentialsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              80,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([13, 112, 114, 105, 118, 97, 116, 101, 95, 99, 108, 111, 117, 100])],
          578365826: [
            Buffer.from([
              83,
              58,
              1,
              42,
              34,
              78,
              47,
              118,
              49,
              47,
              123,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              108,
              111,
              117,
              100,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              101,
              116,
              78,
              115,
              120,
              67,
              114,
              101,
              100,
              101,
              110,
              116,
              105,
              97,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Resets credentials of the Vcenter appliance. */
    resetVcenterCredentials: {
      name: "ResetVcenterCredentials",
      requestType: ResetVcenterCredentialsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              80,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([13, 112, 114, 105, 118, 97, 116, 101, 95, 99, 108, 111, 117, 100])],
          578365826: [
            Buffer.from([
              87,
              58,
              1,
              42,
              34,
              82,
              47,
              118,
              49,
              47,
              123,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              108,
              111,
              117,
              100,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              101,
              116,
              86,
              99,
              101,
              110,
              116,
              101,
              114,
              67,
              114,
              101,
              100,
              101,
              110,
              116,
              105,
              97,
              108,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of the `DnsForwarding` config. */
    getDnsForwarding: {
      name: "GetDnsForwarding",
      requestType: GetDnsForwardingRequest,
      requestStream: false,
      responseType: DnsForwarding,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              65,
              18,
              63,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              100,
              110,
              115,
              70,
              111,
              114,
              119,
              97,
              114,
              100,
              105,
              110,
              103,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the parameters of the `DnsForwarding` config, like associated
     * domains. Only fields specified in `update_mask` are applied.
     */
    updateDnsForwarding: {
      name: "UpdateDnsForwarding",
      requestType: UpdateDnsForwardingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              13,
              68,
              110,
              115,
              70,
              111,
              114,
              119,
              97,
              114,
              100,
              105,
              110,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              26,
              100,
              110,
              115,
              95,
              102,
              111,
              114,
              119,
              97,
              114,
              100,
              105,
              110,
              103,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              96,
              58,
              14,
              100,
              110,
              115,
              95,
              102,
              111,
              114,
              119,
              97,
              114,
              100,
              105,
              110,
              103,
              50,
              78,
              47,
              118,
              49,
              47,
              123,
              100,
              110,
              115,
              95,
              102,
              111,
              114,
              119,
              97,
              114,
              100,
              105,
              110,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              100,
              110,
              115,
              70,
              111,
              114,
              119,
              97,
              114,
              100,
              105,
              110,
              103,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves a `NetworkPeering` resource by its resource name. The resource
     * contains details of the network peering, such as peered
     * networks, import and export custom route configurations, and peering state.
     * NetworkPeering is a global resource and location can only be global.
     */
    getNetworkPeering: {
      name: "GetNetworkPeering",
      requestType: GetNetworkPeeringRequest,
      requestStream: false,
      responseType: NetworkPeering,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              101,
              101,
              114,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists `NetworkPeering` resources in a given project. NetworkPeering is a
     * global resource and location can only be global.
     */
    listNetworkPeerings: {
      name: "ListNetworkPeerings",
      requestType: ListNetworkPeeringsRequest,
      requestStream: false,
      responseType: ListNetworkPeeringsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              101,
              101,
              114,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new network peering between the peer network and VMware Engine
     * network provided in a `NetworkPeering` resource. NetworkPeering is a
     * global resource and location can only be global.
     */
    createNetworkPeering: {
      name: "CreateNetworkPeering",
      requestType: CreateNetworkPeeringRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              35,
              10,
              14,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              101,
              101,
              114,
              105,
              110,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              41,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              101,
              101,
              114,
              105,
              110,
              103,
              44,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              101,
              101,
              114,
              105,
              110,
              103,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              70,
              58,
              15,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              101,
              101,
              114,
              105,
              110,
              103,
              34,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              101,
              101,
              114,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a `NetworkPeering` resource. When a network peering is deleted for
     * a VMware Engine network, the peer network becomes inaccessible to that
     * VMware Engine network. NetworkPeering is a global resource and location can
     * only be global.
     */
    deleteNetworkPeering: {
      name: "DeleteNetworkPeering",
      requestType: DeleteNetworkPeeringRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              42,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              101,
              101,
              114,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Modifies a `NetworkPeering` resource. Only the `description` field can be
     * updated. Only fields specified in `updateMask` are applied. NetworkPeering
     * is a global resource and location can only be global.
     */
    updateNetworkPeering: {
      name: "UpdateNetworkPeering",
      requestType: UpdateNetworkPeeringRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              35,
              10,
              14,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              101,
              101,
              114,
              105,
              110,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              27,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              101,
              101,
              114,
              105,
              110,
              103,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              86,
              58,
              15,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              101,
              101,
              114,
              105,
              110,
              103,
              50,
              67,
              47,
              118,
              49,
              47,
              123,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              101,
              101,
              114,
              105,
              110,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              101,
              101,
              114,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the network peering routes exchanged over a peering connection.
     * NetworkPeering is a global resource and location can only be global.
     */
    listPeeringRoutes: {
      name: "ListPeeringRoutes",
      requestType: ListPeeringRoutesRequest,
      requestStream: false,
      responseType: ListPeeringRoutesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              69,
              18,
              67,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              101,
              101,
              114,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
              47,
              112,
              101,
              101,
              114,
              105,
              110,
              103,
              82,
              111,
              117,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Creates a new HCX activation key in a given private cloud. */
    createHcxActivationKey: {
      name: "CreateHcxActivationKey",
      requestType: CreateHcxActivationKeyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              37,
              10,
              16,
              72,
              99,
              120,
              65,
              99,
              116,
              105,
              118,
              97,
              116,
              105,
              111,
              110,
              75,
              101,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              47,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              104,
              99,
              120,
              95,
              97,
              99,
              116,
              105,
              118,
              97,
              116,
              105,
              111,
              110,
              95,
              107,
              101,
              121,
              44,
              104,
              99,
              120,
              95,
              97,
              99,
              116,
              105,
              118,
              97,
              116,
              105,
              111,
              110,
              95,
              107,
              101,
              121,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              91,
              58,
              18,
              104,
              99,
              120,
              95,
              97,
              99,
              116,
              105,
              118,
              97,
              116,
              105,
              111,
              110,
              95,
              107,
              101,
              121,
              34,
              69,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              47,
              104,
              99,
              120,
              65,
              99,
              116,
              105,
              118,
              97,
              116,
              105,
              111,
              110,
              75,
              101,
              121,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists `HcxActivationKey` resources in a given private cloud. */
    listHcxActivationKeys: {
      name: "ListHcxActivationKeys",
      requestType: ListHcxActivationKeysRequest,
      requestStream: false,
      responseType: ListHcxActivationKeysResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              71,
              18,
              69,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              47,
              104,
              99,
              120,
              65,
              99,
              116,
              105,
              118,
              97,
              116,
              105,
              111,
              110,
              75,
              101,
              121,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves a `HcxActivationKey` resource by its resource name. */
    getHcxActivationKey: {
      name: "GetHcxActivationKey",
      requestType: GetHcxActivationKeyRequest,
      requestStream: false,
      responseType: HcxActivationKey,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              71,
              18,
              69,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              104,
              99,
              120,
              65,
              99,
              116,
              105,
              118,
              97,
              116,
              105,
              111,
              110,
              75,
              101,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Retrieves a `NetworkPolicy` resource by its resource name. */
    getNetworkPolicy: {
      name: "GetNetworkPolicy",
      requestType: GetNetworkPolicyRequest,
      requestStream: false,
      responseType: NetworkPolicy,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists `NetworkPolicy` resources in a specified project and location. */
    listNetworkPolicies: {
      name: "ListNetworkPolicies",
      requestType: ListNetworkPoliciesRequest,
      requestStream: false,
      responseType: ListNetworkPoliciesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new network policy in a given VMware Engine network of a
     * project and location (region). A new network policy cannot be created if
     * another network policy already exists in the same scope.
     */
    createNetworkPolicy: {
      name: "CreateNetworkPolicy",
      requestType: CreateNetworkPolicyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              13,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              39,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              44,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              14,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              34,
              51,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Modifies a `NetworkPolicy` resource. Only the following fields can be
     * updated: `internet_access`, `external_ip`, `edge_services_cidr`.
     * Only fields specified in `updateMask` are applied. When updating a network
     * policy, the external IP network service can only be disabled if there are
     * no external IP addresses present in the scope of the policy. Also, a
     * `NetworkService` cannot be updated when `NetworkService.state` is set
     * to `RECONCILING`.
     *
     * During operation processing, the resource is temporarily in the `ACTIVE`
     * state before the operation fully completes. For that period of time, you
     * can't update the resource. Use the operation status to determine when the
     * processing fully completes.
     */
    updateNetworkPolicy: {
      name: "UpdateNetworkPolicy",
      requestType: UpdateNetworkPolicyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              34,
              10,
              13,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              26,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              84,
              58,
              14,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              50,
              66,
              47,
              118,
              49,
              47,
              123,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              112,
              111,
              108,
              105,
              99,
              121,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a `NetworkPolicy` resource. A network policy cannot be deleted
     * when `NetworkService.state` is set to `RECONCILING` for either its external
     * IP or internet access service.
     */
    deleteNetworkPolicy: {
      name: "DeleteNetworkPolicy",
      requestType: DeleteNetworkPolicyRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              42,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              80,
              111,
              108,
              105,
              99,
              105,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Consumer VPCs bound to Management DNS Zone of a given private cloud. */
    listManagementDnsZoneBindings: {
      name: "ListManagementDnsZoneBindings",
      requestType: ListManagementDnsZoneBindingsRequest,
      requestStream: false,
      responseType: ListManagementDnsZoneBindingsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              79,
              18,
              77,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              47,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              68,
              110,
              115,
              90,
              111,
              110,
              101,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves a 'ManagementDnsZoneBinding' resource by its resource name. */
    getManagementDnsZoneBinding: {
      name: "GetManagementDnsZoneBinding",
      requestType: GetManagementDnsZoneBindingRequest,
      requestStream: false,
      responseType: ManagementDnsZoneBinding,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              79,
              18,
              77,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              68,
              110,
              115,
              90,
              111,
              110,
              101,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new `ManagementDnsZoneBinding` resource in a private cloud.
     * This RPC creates the DNS binding and the resource that represents the
     * DNS binding of the consumer VPC network to the management DNS zone. A
     * management DNS zone is the Cloud DNS cross-project binding zone that
     * VMware Engine creates for each private cloud. It contains FQDNs and
     * corresponding IP addresses for the private cloud's ESXi hosts and
     * management VM appliances like vCenter and NSX Manager.
     */
    createManagementDnsZoneBinding: {
      name: "CreateManagementDnsZoneBinding",
      requestType: CreateManagementDnsZoneBindingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              45,
              10,
              24,
              77,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              68,
              110,
              115,
              90,
              111,
              110,
              101,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              65,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              95,
              100,
              110,
              115,
              95,
              122,
              111,
              110,
              101,
              95,
              98,
              105,
              110,
              100,
              105,
              110,
              103,
              44,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              95,
              100,
              110,
              115,
              95,
              122,
              111,
              110,
              101,
              95,
              98,
              105,
              110,
              100,
              105,
              110,
              103,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              108,
              58,
              27,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              95,
              100,
              110,
              115,
              95,
              122,
              111,
              110,
              101,
              95,
              98,
              105,
              110,
              100,
              105,
              110,
              103,
              34,
              77,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              125,
              47,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              68,
              110,
              115,
              90,
              111,
              110,
              101,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a `ManagementDnsZoneBinding` resource.
     * Only fields specified in `update_mask` are applied.
     */
    updateManagementDnsZoneBinding: {
      name: "UpdateManagementDnsZoneBinding",
      requestType: UpdateManagementDnsZoneBindingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              45,
              10,
              24,
              77,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              68,
              110,
              115,
              90,
              111,
              110,
              101,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              39,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              95,
              100,
              110,
              115,
              95,
              122,
              111,
              110,
              101,
              95,
              98,
              105,
              110,
              100,
              105,
              110,
              103,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              136,
              1,
              58,
              27,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              95,
              100,
              110,
              115,
              95,
              122,
              111,
              110,
              101,
              95,
              98,
              105,
              110,
              100,
              105,
              110,
              103,
              50,
              105,
              47,
              118,
              49,
              47,
              123,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              95,
              100,
              110,
              115,
              95,
              122,
              111,
              110,
              101,
              95,
              98,
              105,
              110,
              100,
              105,
              110,
              103,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              68,
              110,
              115,
              90,
              111,
              110,
              101,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a `ManagementDnsZoneBinding` resource. When a management DNS zone
     * binding is deleted, the corresponding consumer VPC network is no longer
     * bound to the management DNS zone.
     */
    deleteManagementDnsZoneBinding: {
      name: "DeleteManagementDnsZoneBinding",
      requestType: DeleteManagementDnsZoneBindingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              79,
              42,
              77,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              68,
              110,
              115,
              90,
              111,
              110,
              101,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retries to create a `ManagementDnsZoneBinding` resource that is
     * in failed state.
     */
    repairManagementDnsZoneBinding: {
      name: "RepairManagementDnsZoneBinding",
      requestType: RepairManagementDnsZoneBindingRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              45,
              10,
              24,
              77,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              68,
              110,
              115,
              90,
              111,
              110,
              101,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              89,
              58,
              1,
              42,
              34,
              84,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              108,
              111,
              117,
              100,
              115,
              47,
              42,
              47,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              68,
              110,
              115,
              90,
              111,
              110,
              101,
              66,
              105,
              110,
              100,
              105,
              110,
              103,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              112,
              97,
              105,
              114,
            ]),
          ],
        },
      },
    },
    /** Creates a new VMware Engine network that can be used by a private cloud. */
    createVmwareEngineNetwork: {
      name: "CreateVmwareEngineNetwork",
      requestType: CreateVmwareEngineNetworkRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              40,
              10,
              19,
              86,
              109,
              119,
              97,
              114,
              101,
              69,
              110,
              103,
              105,
              110,
              101,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              53,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              118,
              109,
              119,
              97,
              114,
              101,
              95,
              101,
              110,
              103,
              105,
              110,
              101,
              95,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              44,
              118,
              109,
              119,
              97,
              114,
              101,
              95,
              101,
              110,
              103,
              105,
              110,
              101,
              95,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              81,
              58,
              21,
              118,
              109,
              119,
              97,
              114,
              101,
              95,
              101,
              110,
              103,
              105,
              110,
              101,
              95,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              34,
              56,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              118,
              109,
              119,
              97,
              114,
              101,
              69,
              110,
              103,
              105,
              110,
              101,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Modifies a VMware Engine network resource. Only the following fields can be
     * updated: `description`. Only fields specified in `updateMask` are
     * applied.
     */
    updateVmwareEngineNetwork: {
      name: "UpdateVmwareEngineNetwork",
      requestType: UpdateVmwareEngineNetworkRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              40,
              10,
              19,
              86,
              109,
              119,
              97,
              114,
              101,
              69,
              110,
              103,
              105,
              110,
              101,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              33,
              118,
              109,
              119,
              97,
              114,
              101,
              95,
              101,
              110,
              103,
              105,
              110,
              101,
              95,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              103,
              58,
              21,
              118,
              109,
              119,
              97,
              114,
              101,
              95,
              101,
              110,
              103,
              105,
              110,
              101,
              95,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              50,
              78,
              47,
              118,
              49,
              47,
              123,
              118,
              109,
              119,
              97,
              114,
              101,
              95,
              101,
              110,
              103,
              105,
              110,
              101,
              95,
              110,
              101,
              116,
              119,
              111,
              114,
              107,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              118,
              109,
              119,
              97,
              114,
              101,
              69,
              110,
              103,
              105,
              110,
              101,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a `VmwareEngineNetwork` resource. You can only delete a VMware
     * Engine network after all resources that refer to it are deleted. For
     * example, a private cloud, a network peering, and a network policy can all
     * refer to the same VMware Engine network.
     */
    deleteVmwareEngineNetwork: {
      name: "DeleteVmwareEngineNetwork",
      requestType: DeleteVmwareEngineNetworkRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              58,
              42,
              56,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              118,
              109,
              119,
              97,
              114,
              101,
              69,
              110,
              103,
              105,
              110,
              101,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves a `VmwareEngineNetwork` resource by its resource name. The
     * resource contains details of the VMware Engine network, such as its VMware
     * Engine network type, peered networks in a service project, and state
     * (for example, `CREATING`, `ACTIVE`, `DELETING`).
     */
    getVmwareEngineNetwork: {
      name: "GetVmwareEngineNetwork",
      requestType: GetVmwareEngineNetworkRequest,
      requestStream: false,
      responseType: VmwareEngineNetwork,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              58,
              18,
              56,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              118,
              109,
              119,
              97,
              114,
              101,
              69,
              110,
              103,
              105,
              110,
              101,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists `VmwareEngineNetwork` resources in a given project and location. */
    listVmwareEngineNetworks: {
      name: "ListVmwareEngineNetworks",
      requestType: ListVmwareEngineNetworksRequest,
      requestStream: false,
      responseType: ListVmwareEngineNetworksResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              58,
              18,
              56,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              118,
              109,
              119,
              97,
              114,
              101,
              69,
              110,
              103,
              105,
              110,
              101,
              78,
              101,
              116,
              119,
              111,
              114,
              107,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Creates a new private connection that can be used for accessing private
     * Clouds.
     */
    createPrivateConnection: {
      name: "CreatePrivateConnection",
      requestType: CreatePrivateConnectionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              17,
              80,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              47,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              44,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              76,
              58,
              18,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              34,
              54,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves a `PrivateConnection` resource by its resource name. The resource
     * contains details of the private connection, such as connected
     * network, routing mode and state.
     */
    getPrivateConnection: {
      name: "GetPrivateConnection",
      requestType: GetPrivateConnectionRequest,
      requestStream: false,
      responseType: PrivateConnection,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists `PrivateConnection` resources in a given project and location. */
    listPrivateConnections: {
      name: "ListPrivateConnections",
      requestType: ListPrivateConnectionsRequest,
      requestStream: false,
      responseType: ListPrivateConnectionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Modifies a `PrivateConnection` resource. Only `description` and
     * `routing_mode` fields can be updated. Only fields specified in `updateMask`
     * are applied.
     */
    updatePrivateConnection: {
      name: "UpdatePrivateConnection",
      requestType: UpdatePrivateConnectionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              17,
              80,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              30,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              95,
              58,
              18,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              50,
              73,
              47,
              118,
              49,
              47,
              123,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              95,
              99,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a `PrivateConnection` resource. When a private connection is
     * deleted for a VMware Engine network, the connected network becomes
     * inaccessible to that VMware Engine network.
     */
    deletePrivateConnection: {
      name: "DeletePrivateConnection",
      requestType: DeletePrivateConnectionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              42,
              54,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists the private connection routes exchanged over a peering connection. */
    listPrivateConnectionPeeringRoutes: {
      name: "ListPrivateConnectionPeeringRoutes",
      requestType: ListPrivateConnectionPeeringRoutesRequest,
      requestStream: false,
      responseType: ListPrivateConnectionPeeringRoutesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              72,
              18,
              70,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              114,
              105,
              118,
              97,
              116,
              101,
              67,
              111,
              110,
              110,
              101,
              99,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              101,
              101,
              114,
              105,
              110,
              103,
              82,
              111,
              117,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Grants the bind permission to the customer provided principal(user /
     * service account) to bind their DNS zone with the intranet VPC associated
     * with the project. DnsBindPermission is a global resource and location can
     * only be global.
     */
    grantDnsBindPermission: {
      name: "GrantDnsBindPermission",
      requestType: GrantDnsBindPermissionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              17,
              68,
              110,
              115,
              66,
              105,
              110,
              100,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([14, 110, 97, 109, 101, 44, 112, 114, 105, 110, 99, 105, 112, 97, 108])],
          578365826: [
            Buffer.from([
              62,
              58,
              1,
              42,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              110,
              115,
              66,
              105,
              110,
              100,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              125,
              58,
              103,
              114,
              97,
              110,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Gets all the principals having bind permission on the intranet VPC
     * associated with the consumer project granted by the Grant API.
     * DnsBindPermission is a global resource and location can only be global.
     */
    getDnsBindPermission: {
      name: "GetDnsBindPermission",
      requestType: GetDnsBindPermissionRequest,
      requestStream: false,
      responseType: DnsBindPermission,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              110,
              115,
              66,
              105,
              110,
              100,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Revokes the bind permission from the customer provided principal(user /
     * service account) on the intranet VPC associated with the consumer project.
     * DnsBindPermission is a global resource and location can only be global.
     */
    revokeDnsBindPermission: {
      name: "RevokeDnsBindPermission",
      requestType: RevokeDnsBindPermissionRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              38,
              10,
              17,
              68,
              110,
              115,
              66,
              105,
              110,
              100,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([14, 110, 97, 109, 101, 44, 112, 114, 105, 110, 99, 105, 112, 97, 108])],
          578365826: [
            Buffer.from([
              63,
              58,
              1,
              42,
              34,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              100,
              110,
              115,
              66,
              105,
              110,
              100,
              80,
              101,
              114,
              109,
              105,
              115,
              115,
              105,
              111,
              110,
              125,
              58,
              114,
              101,
              118,
              111,
              107,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface VmwareEngineServiceImplementation<CallContextExt = {}> {
  /** Lists `PrivateCloud` resources in a given project and location. */
  listPrivateClouds(
    request: ListPrivateCloudsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPrivateCloudsResponse>>;
  /** Retrieves a `PrivateCloud` resource by its resource name. */
  getPrivateCloud(
    request: GetPrivateCloudRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PrivateCloud>>;
  /**
   * Creates a new `PrivateCloud` resource in a given project and location.
   * Private clouds of type `STANDARD` and
   * `TIME_LIMITED` are zonal resources, `STRETCHED` private clouds are
   * regional.
   * Creating a private cloud also creates a [management
   * cluster](https://cloud.google.com/vmware-engine/docs/concepts-vmware-components)
   * for that private cloud.
   */
  createPrivateCloud(
    request: CreatePrivateCloudRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Modifies a `PrivateCloud` resource. Only the following fields can be
   * updated: `description`.
   * Only fields specified in `updateMask` are applied.
   *
   * During operation processing, the resource is temporarily in the `ACTIVE`
   * state before the operation fully completes. For that period of time, you
   * can't update the resource. Use the operation status to determine when the
   * processing fully completes.
   */
  updatePrivateCloud(
    request: UpdatePrivateCloudRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Schedules a `PrivateCloud` resource for deletion.
   *
   * A `PrivateCloud` resource scheduled for deletion has `PrivateCloud.state`
   * set to `DELETED` and `expireTime` set to the time when deletion is final
   * and can no longer be reversed. The delete operation is marked as done
   * as soon as the `PrivateCloud` is successfully scheduled for deletion
   * (this also applies when `delayHours` is set to zero), and the operation is
   * not kept in pending state until `PrivateCloud` is purged.
   * `PrivateCloud` can be restored using `UndeletePrivateCloud` method before
   * the `expireTime` elapses. When `expireTime` is reached, deletion is final
   * and all private cloud resources are irreversibly removed and billing stops.
   * During the final removal process, `PrivateCloud.state` is set to `PURGING`.
   * `PrivateCloud` can be polled using standard `GET` method for the whole
   * period of deletion and purging. It will not be returned only
   * when it is completely purged.
   */
  deletePrivateCloud(
    request: DeletePrivateCloudRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Restores a private cloud that was previously scheduled for deletion by
   * `DeletePrivateCloud`. A `PrivateCloud` resource scheduled for deletion has
   * `PrivateCloud.state` set to `DELETED` and `PrivateCloud.expireTime` set to
   * the time when deletion can no longer be reversed.
   */
  undeletePrivateCloud(
    request: UndeletePrivateCloudRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists `Cluster` resources in a given private cloud. */
  listClusters(
    request: ListClustersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListClustersResponse>>;
  /** Retrieves a `Cluster` resource by its resource name. */
  getCluster(request: GetClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Cluster>>;
  /**
   * Creates a new cluster in a given private cloud.
   * Creating a new cluster provides additional nodes for
   * use in the parent private cloud and requires sufficient [node
   * quota](https://cloud.google.com/vmware-engine/quotas).
   */
  createCluster(request: CreateClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Modifies a `Cluster` resource. Only fields specified in `updateMask` are
   * applied.
   *
   * During operation processing, the resource is temporarily in the `ACTIVE`
   * state before the operation fully completes. For that period of time, you
   * can't update the resource. Use the operation status to determine when the
   * processing fully completes.
   */
  updateCluster(request: UpdateClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Deletes a `Cluster` resource. To avoid unintended data loss, migrate or
   * gracefully shut down any workloads running on the cluster before deletion.
   * You cannot delete the management cluster of a private cloud using this
   * method.
   */
  deleteCluster(request: DeleteClusterRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Lists nodes in a given cluster. */
  listNodes(request: ListNodesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListNodesResponse>>;
  /** Gets details of a single node. */
  getNode(request: GetNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Node>>;
  /**
   * Lists external IP addresses assigned to VMware workload VMs in a given
   * private cloud.
   */
  listExternalAddresses(
    request: ListExternalAddressesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListExternalAddressesResponse>>;
  /**
   * Lists external IP addresses assigned to VMware workload VMs within the
   * scope of the given network policy.
   */
  fetchNetworkPolicyExternalAddresses(
    request: FetchNetworkPolicyExternalAddressesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FetchNetworkPolicyExternalAddressesResponse>>;
  /** Gets details of a single external IP address. */
  getExternalAddress(
    request: GetExternalAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExternalAddress>>;
  /**
   * Creates a new `ExternalAddress` resource in a given private cloud. The
   * network policy that corresponds to the private cloud must have the external
   * IP address network service enabled (`NetworkPolicy.external_ip`).
   */
  createExternalAddress(
    request: CreateExternalAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates the parameters of a single external IP address.
   * Only fields specified in `update_mask` are applied.
   *
   * During operation processing, the resource is temporarily in the `ACTIVE`
   * state before the operation fully completes. For that period of time, you
   * can't update the resource. Use the operation status to determine when the
   * processing fully completes.
   */
  updateExternalAddress(
    request: UpdateExternalAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes a single external IP address. When you delete an external IP
   * address, connectivity between the external IP address and the corresponding
   * internal IP address is lost.
   */
  deleteExternalAddress(
    request: DeleteExternalAddressRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists subnets in a given private cloud. */
  listSubnets(
    request: ListSubnetsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSubnetsResponse>>;
  /** Gets details of a single subnet. */
  getSubnet(request: GetSubnetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Subnet>>;
  /**
   * Updates the parameters of a single subnet. Only fields specified in
   * `update_mask` are applied.
   *
   * *Note*: This API is synchronous and always returns a successful
   * `google.longrunning.Operation` (LRO). The returned LRO will only have
   * `done` and `response` fields.
   */
  updateSubnet(request: UpdateSubnetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Lists `ExternalAccessRule` resources in the specified network policy. */
  listExternalAccessRules(
    request: ListExternalAccessRulesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListExternalAccessRulesResponse>>;
  /** Gets details of a single external access rule. */
  getExternalAccessRule(
    request: GetExternalAccessRuleRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ExternalAccessRule>>;
  /** Creates a new external access rule in a given network policy. */
  createExternalAccessRule(
    request: CreateExternalAccessRuleRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates the parameters of a single external access rule.
   * Only fields specified in `update_mask` are applied.
   */
  updateExternalAccessRule(
    request: UpdateExternalAccessRuleRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single external access rule. */
  deleteExternalAccessRule(
    request: DeleteExternalAccessRuleRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Lists logging servers configured for a given private
   * cloud.
   */
  listLoggingServers(
    request: ListLoggingServersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListLoggingServersResponse>>;
  /** Gets details of a logging server. */
  getLoggingServer(
    request: GetLoggingServerRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<LoggingServer>>;
  /** Create a new logging server for a given private cloud. */
  createLoggingServer(
    request: CreateLoggingServerRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates the parameters of a single logging server.
   * Only fields specified in `update_mask` are applied.
   */
  updateLoggingServer(
    request: UpdateLoggingServerRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single logging server. */
  deleteLoggingServer(
    request: DeleteLoggingServerRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists node types */
  listNodeTypes(
    request: ListNodeTypesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNodeTypesResponse>>;
  /** Gets details of a single `NodeType`. */
  getNodeType(request: GetNodeTypeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<NodeType>>;
  /** Gets details of credentials for NSX appliance. */
  showNsxCredentials(
    request: ShowNsxCredentialsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Credentials>>;
  /** Gets details of credentials for Vcenter appliance. */
  showVcenterCredentials(
    request: ShowVcenterCredentialsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Credentials>>;
  /** Resets credentials of the NSX appliance. */
  resetNsxCredentials(
    request: ResetNsxCredentialsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Resets credentials of the Vcenter appliance. */
  resetVcenterCredentials(
    request: ResetVcenterCredentialsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Gets details of the `DnsForwarding` config. */
  getDnsForwarding(
    request: GetDnsForwardingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DnsForwarding>>;
  /**
   * Updates the parameters of the `DnsForwarding` config, like associated
   * domains. Only fields specified in `update_mask` are applied.
   */
  updateDnsForwarding(
    request: UpdateDnsForwardingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Retrieves a `NetworkPeering` resource by its resource name. The resource
   * contains details of the network peering, such as peered
   * networks, import and export custom route configurations, and peering state.
   * NetworkPeering is a global resource and location can only be global.
   */
  getNetworkPeering(
    request: GetNetworkPeeringRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<NetworkPeering>>;
  /**
   * Lists `NetworkPeering` resources in a given project. NetworkPeering is a
   * global resource and location can only be global.
   */
  listNetworkPeerings(
    request: ListNetworkPeeringsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNetworkPeeringsResponse>>;
  /**
   * Creates a new network peering between the peer network and VMware Engine
   * network provided in a `NetworkPeering` resource. NetworkPeering is a
   * global resource and location can only be global.
   */
  createNetworkPeering(
    request: CreateNetworkPeeringRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes a `NetworkPeering` resource. When a network peering is deleted for
   * a VMware Engine network, the peer network becomes inaccessible to that
   * VMware Engine network. NetworkPeering is a global resource and location can
   * only be global.
   */
  deleteNetworkPeering(
    request: DeleteNetworkPeeringRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Modifies a `NetworkPeering` resource. Only the `description` field can be
   * updated. Only fields specified in `updateMask` are applied. NetworkPeering
   * is a global resource and location can only be global.
   */
  updateNetworkPeering(
    request: UpdateNetworkPeeringRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Lists the network peering routes exchanged over a peering connection.
   * NetworkPeering is a global resource and location can only be global.
   */
  listPeeringRoutes(
    request: ListPeeringRoutesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPeeringRoutesResponse>>;
  /** Creates a new HCX activation key in a given private cloud. */
  createHcxActivationKey(
    request: CreateHcxActivationKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists `HcxActivationKey` resources in a given private cloud. */
  listHcxActivationKeys(
    request: ListHcxActivationKeysRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListHcxActivationKeysResponse>>;
  /** Retrieves a `HcxActivationKey` resource by its resource name. */
  getHcxActivationKey(
    request: GetHcxActivationKeyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<HcxActivationKey>>;
  /** Retrieves a `NetworkPolicy` resource by its resource name. */
  getNetworkPolicy(
    request: GetNetworkPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<NetworkPolicy>>;
  /** Lists `NetworkPolicy` resources in a specified project and location. */
  listNetworkPolicies(
    request: ListNetworkPoliciesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNetworkPoliciesResponse>>;
  /**
   * Creates a new network policy in a given VMware Engine network of a
   * project and location (region). A new network policy cannot be created if
   * another network policy already exists in the same scope.
   */
  createNetworkPolicy(
    request: CreateNetworkPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Modifies a `NetworkPolicy` resource. Only the following fields can be
   * updated: `internet_access`, `external_ip`, `edge_services_cidr`.
   * Only fields specified in `updateMask` are applied. When updating a network
   * policy, the external IP network service can only be disabled if there are
   * no external IP addresses present in the scope of the policy. Also, a
   * `NetworkService` cannot be updated when `NetworkService.state` is set
   * to `RECONCILING`.
   *
   * During operation processing, the resource is temporarily in the `ACTIVE`
   * state before the operation fully completes. For that period of time, you
   * can't update the resource. Use the operation status to determine when the
   * processing fully completes.
   */
  updateNetworkPolicy(
    request: UpdateNetworkPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes a `NetworkPolicy` resource. A network policy cannot be deleted
   * when `NetworkService.state` is set to `RECONCILING` for either its external
   * IP or internet access service.
   */
  deleteNetworkPolicy(
    request: DeleteNetworkPolicyRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists Consumer VPCs bound to Management DNS Zone of a given private cloud. */
  listManagementDnsZoneBindings(
    request: ListManagementDnsZoneBindingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListManagementDnsZoneBindingsResponse>>;
  /** Retrieves a 'ManagementDnsZoneBinding' resource by its resource name. */
  getManagementDnsZoneBinding(
    request: GetManagementDnsZoneBindingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ManagementDnsZoneBinding>>;
  /**
   * Creates a new `ManagementDnsZoneBinding` resource in a private cloud.
   * This RPC creates the DNS binding and the resource that represents the
   * DNS binding of the consumer VPC network to the management DNS zone. A
   * management DNS zone is the Cloud DNS cross-project binding zone that
   * VMware Engine creates for each private cloud. It contains FQDNs and
   * corresponding IP addresses for the private cloud's ESXi hosts and
   * management VM appliances like vCenter and NSX Manager.
   */
  createManagementDnsZoneBinding(
    request: CreateManagementDnsZoneBindingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates a `ManagementDnsZoneBinding` resource.
   * Only fields specified in `update_mask` are applied.
   */
  updateManagementDnsZoneBinding(
    request: UpdateManagementDnsZoneBindingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes a `ManagementDnsZoneBinding` resource. When a management DNS zone
   * binding is deleted, the corresponding consumer VPC network is no longer
   * bound to the management DNS zone.
   */
  deleteManagementDnsZoneBinding(
    request: DeleteManagementDnsZoneBindingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Retries to create a `ManagementDnsZoneBinding` resource that is
   * in failed state.
   */
  repairManagementDnsZoneBinding(
    request: RepairManagementDnsZoneBindingRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Creates a new VMware Engine network that can be used by a private cloud. */
  createVmwareEngineNetwork(
    request: CreateVmwareEngineNetworkRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Modifies a VMware Engine network resource. Only the following fields can be
   * updated: `description`. Only fields specified in `updateMask` are
   * applied.
   */
  updateVmwareEngineNetwork(
    request: UpdateVmwareEngineNetworkRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes a `VmwareEngineNetwork` resource. You can only delete a VMware
   * Engine network after all resources that refer to it are deleted. For
   * example, a private cloud, a network peering, and a network policy can all
   * refer to the same VMware Engine network.
   */
  deleteVmwareEngineNetwork(
    request: DeleteVmwareEngineNetworkRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Retrieves a `VmwareEngineNetwork` resource by its resource name. The
   * resource contains details of the VMware Engine network, such as its VMware
   * Engine network type, peered networks in a service project, and state
   * (for example, `CREATING`, `ACTIVE`, `DELETING`).
   */
  getVmwareEngineNetwork(
    request: GetVmwareEngineNetworkRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<VmwareEngineNetwork>>;
  /** Lists `VmwareEngineNetwork` resources in a given project and location. */
  listVmwareEngineNetworks(
    request: ListVmwareEngineNetworksRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListVmwareEngineNetworksResponse>>;
  /**
   * Creates a new private connection that can be used for accessing private
   * Clouds.
   */
  createPrivateConnection(
    request: CreatePrivateConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Retrieves a `PrivateConnection` resource by its resource name. The resource
   * contains details of the private connection, such as connected
   * network, routing mode and state.
   */
  getPrivateConnection(
    request: GetPrivateConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PrivateConnection>>;
  /** Lists `PrivateConnection` resources in a given project and location. */
  listPrivateConnections(
    request: ListPrivateConnectionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPrivateConnectionsResponse>>;
  /**
   * Modifies a `PrivateConnection` resource. Only `description` and
   * `routing_mode` fields can be updated. Only fields specified in `updateMask`
   * are applied.
   */
  updatePrivateConnection(
    request: UpdatePrivateConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes a `PrivateConnection` resource. When a private connection is
   * deleted for a VMware Engine network, the connected network becomes
   * inaccessible to that VMware Engine network.
   */
  deletePrivateConnection(
    request: DeletePrivateConnectionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists the private connection routes exchanged over a peering connection. */
  listPrivateConnectionPeeringRoutes(
    request: ListPrivateConnectionPeeringRoutesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPrivateConnectionPeeringRoutesResponse>>;
  /**
   * Grants the bind permission to the customer provided principal(user /
   * service account) to bind their DNS zone with the intranet VPC associated
   * with the project. DnsBindPermission is a global resource and location can
   * only be global.
   */
  grantDnsBindPermission(
    request: GrantDnsBindPermissionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Gets all the principals having bind permission on the intranet VPC
   * associated with the consumer project granted by the Grant API.
   * DnsBindPermission is a global resource and location can only be global.
   */
  getDnsBindPermission(
    request: GetDnsBindPermissionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DnsBindPermission>>;
  /**
   * Revokes the bind permission from the customer provided principal(user /
   * service account) on the intranet VPC associated with the consumer project.
   * DnsBindPermission is a global resource and location can only be global.
   */
  revokeDnsBindPermission(
    request: RevokeDnsBindPermissionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface VmwareEngineClient<CallOptionsExt = {}> {
  /** Lists `PrivateCloud` resources in a given project and location. */
  listPrivateClouds(
    request: DeepPartial<ListPrivateCloudsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPrivateCloudsResponse>;
  /** Retrieves a `PrivateCloud` resource by its resource name. */
  getPrivateCloud(
    request: DeepPartial<GetPrivateCloudRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PrivateCloud>;
  /**
   * Creates a new `PrivateCloud` resource in a given project and location.
   * Private clouds of type `STANDARD` and
   * `TIME_LIMITED` are zonal resources, `STRETCHED` private clouds are
   * regional.
   * Creating a private cloud also creates a [management
   * cluster](https://cloud.google.com/vmware-engine/docs/concepts-vmware-components)
   * for that private cloud.
   */
  createPrivateCloud(
    request: DeepPartial<CreatePrivateCloudRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Modifies a `PrivateCloud` resource. Only the following fields can be
   * updated: `description`.
   * Only fields specified in `updateMask` are applied.
   *
   * During operation processing, the resource is temporarily in the `ACTIVE`
   * state before the operation fully completes. For that period of time, you
   * can't update the resource. Use the operation status to determine when the
   * processing fully completes.
   */
  updatePrivateCloud(
    request: DeepPartial<UpdatePrivateCloudRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Schedules a `PrivateCloud` resource for deletion.
   *
   * A `PrivateCloud` resource scheduled for deletion has `PrivateCloud.state`
   * set to `DELETED` and `expireTime` set to the time when deletion is final
   * and can no longer be reversed. The delete operation is marked as done
   * as soon as the `PrivateCloud` is successfully scheduled for deletion
   * (this also applies when `delayHours` is set to zero), and the operation is
   * not kept in pending state until `PrivateCloud` is purged.
   * `PrivateCloud` can be restored using `UndeletePrivateCloud` method before
   * the `expireTime` elapses. When `expireTime` is reached, deletion is final
   * and all private cloud resources are irreversibly removed and billing stops.
   * During the final removal process, `PrivateCloud.state` is set to `PURGING`.
   * `PrivateCloud` can be polled using standard `GET` method for the whole
   * period of deletion and purging. It will not be returned only
   * when it is completely purged.
   */
  deletePrivateCloud(
    request: DeepPartial<DeletePrivateCloudRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Restores a private cloud that was previously scheduled for deletion by
   * `DeletePrivateCloud`. A `PrivateCloud` resource scheduled for deletion has
   * `PrivateCloud.state` set to `DELETED` and `PrivateCloud.expireTime` set to
   * the time when deletion can no longer be reversed.
   */
  undeletePrivateCloud(
    request: DeepPartial<UndeletePrivateCloudRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists `Cluster` resources in a given private cloud. */
  listClusters(
    request: DeepPartial<ListClustersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListClustersResponse>;
  /** Retrieves a `Cluster` resource by its resource name. */
  getCluster(request: DeepPartial<GetClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Cluster>;
  /**
   * Creates a new cluster in a given private cloud.
   * Creating a new cluster provides additional nodes for
   * use in the parent private cloud and requires sufficient [node
   * quota](https://cloud.google.com/vmware-engine/quotas).
   */
  createCluster(request: DeepPartial<CreateClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Modifies a `Cluster` resource. Only fields specified in `updateMask` are
   * applied.
   *
   * During operation processing, the resource is temporarily in the `ACTIVE`
   * state before the operation fully completes. For that period of time, you
   * can't update the resource. Use the operation status to determine when the
   * processing fully completes.
   */
  updateCluster(request: DeepPartial<UpdateClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Deletes a `Cluster` resource. To avoid unintended data loss, migrate or
   * gracefully shut down any workloads running on the cluster before deletion.
   * You cannot delete the management cluster of a private cloud using this
   * method.
   */
  deleteCluster(request: DeepPartial<DeleteClusterRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Lists nodes in a given cluster. */
  listNodes(request: DeepPartial<ListNodesRequest>, options?: CallOptions & CallOptionsExt): Promise<ListNodesResponse>;
  /** Gets details of a single node. */
  getNode(request: DeepPartial<GetNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Node>;
  /**
   * Lists external IP addresses assigned to VMware workload VMs in a given
   * private cloud.
   */
  listExternalAddresses(
    request: DeepPartial<ListExternalAddressesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListExternalAddressesResponse>;
  /**
   * Lists external IP addresses assigned to VMware workload VMs within the
   * scope of the given network policy.
   */
  fetchNetworkPolicyExternalAddresses(
    request: DeepPartial<FetchNetworkPolicyExternalAddressesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FetchNetworkPolicyExternalAddressesResponse>;
  /** Gets details of a single external IP address. */
  getExternalAddress(
    request: DeepPartial<GetExternalAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExternalAddress>;
  /**
   * Creates a new `ExternalAddress` resource in a given private cloud. The
   * network policy that corresponds to the private cloud must have the external
   * IP address network service enabled (`NetworkPolicy.external_ip`).
   */
  createExternalAddress(
    request: DeepPartial<CreateExternalAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates the parameters of a single external IP address.
   * Only fields specified in `update_mask` are applied.
   *
   * During operation processing, the resource is temporarily in the `ACTIVE`
   * state before the operation fully completes. For that period of time, you
   * can't update the resource. Use the operation status to determine when the
   * processing fully completes.
   */
  updateExternalAddress(
    request: DeepPartial<UpdateExternalAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes a single external IP address. When you delete an external IP
   * address, connectivity between the external IP address and the corresponding
   * internal IP address is lost.
   */
  deleteExternalAddress(
    request: DeepPartial<DeleteExternalAddressRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists subnets in a given private cloud. */
  listSubnets(
    request: DeepPartial<ListSubnetsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSubnetsResponse>;
  /** Gets details of a single subnet. */
  getSubnet(request: DeepPartial<GetSubnetRequest>, options?: CallOptions & CallOptionsExt): Promise<Subnet>;
  /**
   * Updates the parameters of a single subnet. Only fields specified in
   * `update_mask` are applied.
   *
   * *Note*: This API is synchronous and always returns a successful
   * `google.longrunning.Operation` (LRO). The returned LRO will only have
   * `done` and `response` fields.
   */
  updateSubnet(request: DeepPartial<UpdateSubnetRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Lists `ExternalAccessRule` resources in the specified network policy. */
  listExternalAccessRules(
    request: DeepPartial<ListExternalAccessRulesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListExternalAccessRulesResponse>;
  /** Gets details of a single external access rule. */
  getExternalAccessRule(
    request: DeepPartial<GetExternalAccessRuleRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ExternalAccessRule>;
  /** Creates a new external access rule in a given network policy. */
  createExternalAccessRule(
    request: DeepPartial<CreateExternalAccessRuleRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates the parameters of a single external access rule.
   * Only fields specified in `update_mask` are applied.
   */
  updateExternalAccessRule(
    request: DeepPartial<UpdateExternalAccessRuleRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single external access rule. */
  deleteExternalAccessRule(
    request: DeepPartial<DeleteExternalAccessRuleRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Lists logging servers configured for a given private
   * cloud.
   */
  listLoggingServers(
    request: DeepPartial<ListLoggingServersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListLoggingServersResponse>;
  /** Gets details of a logging server. */
  getLoggingServer(
    request: DeepPartial<GetLoggingServerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<LoggingServer>;
  /** Create a new logging server for a given private cloud. */
  createLoggingServer(
    request: DeepPartial<CreateLoggingServerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates the parameters of a single logging server.
   * Only fields specified in `update_mask` are applied.
   */
  updateLoggingServer(
    request: DeepPartial<UpdateLoggingServerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single logging server. */
  deleteLoggingServer(
    request: DeepPartial<DeleteLoggingServerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists node types */
  listNodeTypes(
    request: DeepPartial<ListNodeTypesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNodeTypesResponse>;
  /** Gets details of a single `NodeType`. */
  getNodeType(request: DeepPartial<GetNodeTypeRequest>, options?: CallOptions & CallOptionsExt): Promise<NodeType>;
  /** Gets details of credentials for NSX appliance. */
  showNsxCredentials(
    request: DeepPartial<ShowNsxCredentialsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Credentials>;
  /** Gets details of credentials for Vcenter appliance. */
  showVcenterCredentials(
    request: DeepPartial<ShowVcenterCredentialsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Credentials>;
  /** Resets credentials of the NSX appliance. */
  resetNsxCredentials(
    request: DeepPartial<ResetNsxCredentialsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Resets credentials of the Vcenter appliance. */
  resetVcenterCredentials(
    request: DeepPartial<ResetVcenterCredentialsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Gets details of the `DnsForwarding` config. */
  getDnsForwarding(
    request: DeepPartial<GetDnsForwardingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DnsForwarding>;
  /**
   * Updates the parameters of the `DnsForwarding` config, like associated
   * domains. Only fields specified in `update_mask` are applied.
   */
  updateDnsForwarding(
    request: DeepPartial<UpdateDnsForwardingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Retrieves a `NetworkPeering` resource by its resource name. The resource
   * contains details of the network peering, such as peered
   * networks, import and export custom route configurations, and peering state.
   * NetworkPeering is a global resource and location can only be global.
   */
  getNetworkPeering(
    request: DeepPartial<GetNetworkPeeringRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<NetworkPeering>;
  /**
   * Lists `NetworkPeering` resources in a given project. NetworkPeering is a
   * global resource and location can only be global.
   */
  listNetworkPeerings(
    request: DeepPartial<ListNetworkPeeringsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNetworkPeeringsResponse>;
  /**
   * Creates a new network peering between the peer network and VMware Engine
   * network provided in a `NetworkPeering` resource. NetworkPeering is a
   * global resource and location can only be global.
   */
  createNetworkPeering(
    request: DeepPartial<CreateNetworkPeeringRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes a `NetworkPeering` resource. When a network peering is deleted for
   * a VMware Engine network, the peer network becomes inaccessible to that
   * VMware Engine network. NetworkPeering is a global resource and location can
   * only be global.
   */
  deleteNetworkPeering(
    request: DeepPartial<DeleteNetworkPeeringRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Modifies a `NetworkPeering` resource. Only the `description` field can be
   * updated. Only fields specified in `updateMask` are applied. NetworkPeering
   * is a global resource and location can only be global.
   */
  updateNetworkPeering(
    request: DeepPartial<UpdateNetworkPeeringRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Lists the network peering routes exchanged over a peering connection.
   * NetworkPeering is a global resource and location can only be global.
   */
  listPeeringRoutes(
    request: DeepPartial<ListPeeringRoutesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPeeringRoutesResponse>;
  /** Creates a new HCX activation key in a given private cloud. */
  createHcxActivationKey(
    request: DeepPartial<CreateHcxActivationKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists `HcxActivationKey` resources in a given private cloud. */
  listHcxActivationKeys(
    request: DeepPartial<ListHcxActivationKeysRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListHcxActivationKeysResponse>;
  /** Retrieves a `HcxActivationKey` resource by its resource name. */
  getHcxActivationKey(
    request: DeepPartial<GetHcxActivationKeyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<HcxActivationKey>;
  /** Retrieves a `NetworkPolicy` resource by its resource name. */
  getNetworkPolicy(
    request: DeepPartial<GetNetworkPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<NetworkPolicy>;
  /** Lists `NetworkPolicy` resources in a specified project and location. */
  listNetworkPolicies(
    request: DeepPartial<ListNetworkPoliciesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNetworkPoliciesResponse>;
  /**
   * Creates a new network policy in a given VMware Engine network of a
   * project and location (region). A new network policy cannot be created if
   * another network policy already exists in the same scope.
   */
  createNetworkPolicy(
    request: DeepPartial<CreateNetworkPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Modifies a `NetworkPolicy` resource. Only the following fields can be
   * updated: `internet_access`, `external_ip`, `edge_services_cidr`.
   * Only fields specified in `updateMask` are applied. When updating a network
   * policy, the external IP network service can only be disabled if there are
   * no external IP addresses present in the scope of the policy. Also, a
   * `NetworkService` cannot be updated when `NetworkService.state` is set
   * to `RECONCILING`.
   *
   * During operation processing, the resource is temporarily in the `ACTIVE`
   * state before the operation fully completes. For that period of time, you
   * can't update the resource. Use the operation status to determine when the
   * processing fully completes.
   */
  updateNetworkPolicy(
    request: DeepPartial<UpdateNetworkPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes a `NetworkPolicy` resource. A network policy cannot be deleted
   * when `NetworkService.state` is set to `RECONCILING` for either its external
   * IP or internet access service.
   */
  deleteNetworkPolicy(
    request: DeepPartial<DeleteNetworkPolicyRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists Consumer VPCs bound to Management DNS Zone of a given private cloud. */
  listManagementDnsZoneBindings(
    request: DeepPartial<ListManagementDnsZoneBindingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListManagementDnsZoneBindingsResponse>;
  /** Retrieves a 'ManagementDnsZoneBinding' resource by its resource name. */
  getManagementDnsZoneBinding(
    request: DeepPartial<GetManagementDnsZoneBindingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ManagementDnsZoneBinding>;
  /**
   * Creates a new `ManagementDnsZoneBinding` resource in a private cloud.
   * This RPC creates the DNS binding and the resource that represents the
   * DNS binding of the consumer VPC network to the management DNS zone. A
   * management DNS zone is the Cloud DNS cross-project binding zone that
   * VMware Engine creates for each private cloud. It contains FQDNs and
   * corresponding IP addresses for the private cloud's ESXi hosts and
   * management VM appliances like vCenter and NSX Manager.
   */
  createManagementDnsZoneBinding(
    request: DeepPartial<CreateManagementDnsZoneBindingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates a `ManagementDnsZoneBinding` resource.
   * Only fields specified in `update_mask` are applied.
   */
  updateManagementDnsZoneBinding(
    request: DeepPartial<UpdateManagementDnsZoneBindingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes a `ManagementDnsZoneBinding` resource. When a management DNS zone
   * binding is deleted, the corresponding consumer VPC network is no longer
   * bound to the management DNS zone.
   */
  deleteManagementDnsZoneBinding(
    request: DeepPartial<DeleteManagementDnsZoneBindingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Retries to create a `ManagementDnsZoneBinding` resource that is
   * in failed state.
   */
  repairManagementDnsZoneBinding(
    request: DeepPartial<RepairManagementDnsZoneBindingRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Creates a new VMware Engine network that can be used by a private cloud. */
  createVmwareEngineNetwork(
    request: DeepPartial<CreateVmwareEngineNetworkRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Modifies a VMware Engine network resource. Only the following fields can be
   * updated: `description`. Only fields specified in `updateMask` are
   * applied.
   */
  updateVmwareEngineNetwork(
    request: DeepPartial<UpdateVmwareEngineNetworkRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes a `VmwareEngineNetwork` resource. You can only delete a VMware
   * Engine network after all resources that refer to it are deleted. For
   * example, a private cloud, a network peering, and a network policy can all
   * refer to the same VMware Engine network.
   */
  deleteVmwareEngineNetwork(
    request: DeepPartial<DeleteVmwareEngineNetworkRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Retrieves a `VmwareEngineNetwork` resource by its resource name. The
   * resource contains details of the VMware Engine network, such as its VMware
   * Engine network type, peered networks in a service project, and state
   * (for example, `CREATING`, `ACTIVE`, `DELETING`).
   */
  getVmwareEngineNetwork(
    request: DeepPartial<GetVmwareEngineNetworkRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<VmwareEngineNetwork>;
  /** Lists `VmwareEngineNetwork` resources in a given project and location. */
  listVmwareEngineNetworks(
    request: DeepPartial<ListVmwareEngineNetworksRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListVmwareEngineNetworksResponse>;
  /**
   * Creates a new private connection that can be used for accessing private
   * Clouds.
   */
  createPrivateConnection(
    request: DeepPartial<CreatePrivateConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Retrieves a `PrivateConnection` resource by its resource name. The resource
   * contains details of the private connection, such as connected
   * network, routing mode and state.
   */
  getPrivateConnection(
    request: DeepPartial<GetPrivateConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PrivateConnection>;
  /** Lists `PrivateConnection` resources in a given project and location. */
  listPrivateConnections(
    request: DeepPartial<ListPrivateConnectionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPrivateConnectionsResponse>;
  /**
   * Modifies a `PrivateConnection` resource. Only `description` and
   * `routing_mode` fields can be updated. Only fields specified in `updateMask`
   * are applied.
   */
  updatePrivateConnection(
    request: DeepPartial<UpdatePrivateConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes a `PrivateConnection` resource. When a private connection is
   * deleted for a VMware Engine network, the connected network becomes
   * inaccessible to that VMware Engine network.
   */
  deletePrivateConnection(
    request: DeepPartial<DeletePrivateConnectionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists the private connection routes exchanged over a peering connection. */
  listPrivateConnectionPeeringRoutes(
    request: DeepPartial<ListPrivateConnectionPeeringRoutesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPrivateConnectionPeeringRoutesResponse>;
  /**
   * Grants the bind permission to the customer provided principal(user /
   * service account) to bind their DNS zone with the intranet VPC associated
   * with the project. DnsBindPermission is a global resource and location can
   * only be global.
   */
  grantDnsBindPermission(
    request: DeepPartial<GrantDnsBindPermissionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Gets all the principals having bind permission on the intranet VPC
   * associated with the consumer project granted by the Grant API.
   * DnsBindPermission is a global resource and location can only be global.
   */
  getDnsBindPermission(
    request: DeepPartial<GetDnsBindPermissionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DnsBindPermission>;
  /**
   * Revokes the bind permission from the customer provided principal(user /
   * service account) on the intranet VPC associated with the consumer project.
   * DnsBindPermission is a global resource and location can only be global.
   */
  revokeDnsBindPermission(
    request: DeepPartial<RevokeDnsBindPermissionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
