// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/scheduler/v1/job.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { AppEngineHttpTarget, HttpTarget, PubsubTarget } from "./target.js";

export const protobufPackage = "google.cloud.scheduler.v1";

/**
 * Configuration for a job.
 * The maximum allowed size for a job is 1MB.
 */
export interface Job {
  /**
   * Optionally caller-specified in
   * [CreateJob][google.cloud.scheduler.v1.CloudScheduler.CreateJob], after
   * which it becomes output only.
   *
   * The job name. For example:
   * `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
   *
   * * `PROJECT_ID` can contain letters ([A-Za-z]), numbers ([0-9]),
   *    hyphens (-), colons (:), or periods (.).
   *    For more information, see
   *    [Identifying
   *    projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
   * * `LOCATION_ID` is the canonical ID for the job's location.
   *    The list of available locations can be obtained by calling
   *    [ListLocations][google.cloud.location.Locations.ListLocations].
   *    For more information, see https://cloud.google.com/about/locations/.
   * * `JOB_ID` can contain only letters ([A-Za-z]), numbers ([0-9]),
   *    hyphens (-), or underscores (_). The maximum length is 500 characters.
   */
  name: string;
  /**
   * Optionally caller-specified in
   * [CreateJob][google.cloud.scheduler.v1.CloudScheduler.CreateJob] or
   * [UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob].
   *
   * A human-readable description for the job. This string must not contain
   * more than 500 characters.
   */
  description: string;
  /** Pub/Sub target. */
  pubsubTarget?:
    | PubsubTarget
    | undefined;
  /** App Engine HTTP target. */
  appEngineHttpTarget?:
    | AppEngineHttpTarget
    | undefined;
  /** HTTP target. */
  httpTarget?:
    | HttpTarget
    | undefined;
  /**
   * Required, except when used with
   * [UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob].
   *
   * Describes the schedule on which the job will be executed.
   *
   * The schedule can be either of the following types:
   *
   * * [Crontab](https://en.wikipedia.org/wiki/Cron#Overview)
   * * English-like
   * [schedule](https://cloud.google.com/scheduler/docs/configuring/cron-job-schedules)
   *
   * As a general rule, execution `n + 1` of a job will not begin
   * until execution `n` has finished. Cloud Scheduler will never
   * allow two simultaneously outstanding executions. For example,
   * this implies that if the `n+1`th execution is scheduled to run at
   * 16:00 but the `n`th execution takes until 16:15, the `n+1`th
   * execution will not start until `16:15`.
   * A scheduled start time will be delayed if the previous
   * execution has not ended when its scheduled time occurs.
   *
   * If [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count] > 0 and
   * a job attempt fails, the job will be tried a total of
   * [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count] times,
   * with exponential backoff, until the next scheduled start time.
   */
  schedule: string;
  /**
   * Specifies the time zone to be used in interpreting
   * [schedule][google.cloud.scheduler.v1.Job.schedule]. The value of this field
   * must be a time zone name from the [tz
   * database](http://en.wikipedia.org/wiki/Tz_database).
   *
   * Note that some time zones include a provision for
   * daylight savings time. The rules for daylight saving time are
   * determined by the chosen tz. For UTC use the string "utc". If a
   * time zone is not specified, the default will be in UTC (also known
   * as GMT).
   */
  timeZone: string;
  /** Output only. The creation time of the job. */
  userUpdateTime:
    | Date
    | undefined;
  /** Output only. State of the job. */
  state: Job_State;
  /** Output only. The response from the target for the last attempted execution. */
  status:
    | Status
    | undefined;
  /**
   * Output only. The next time the job is scheduled. Note that this may be a
   * retry of a previously failed attempt or the next execution time
   * according to the schedule.
   */
  scheduleTime:
    | Date
    | undefined;
  /** Output only. The time the last job attempt started. */
  lastAttemptTime:
    | Date
    | undefined;
  /** Settings that determine the retry behavior. */
  retryConfig:
    | RetryConfig
    | undefined;
  /**
   * The deadline for job attempts. If the request handler does not respond by
   * this deadline then the request is cancelled and the attempt is marked as a
   * `DEADLINE_EXCEEDED` failure. The failed attempt can be viewed in
   * execution logs. Cloud Scheduler will retry the job according
   * to the [RetryConfig][google.cloud.scheduler.v1.RetryConfig].
   *
   * The default and the allowed values depend on the type of target:
   *
   * * For [HTTP targets][google.cloud.scheduler.v1.Job.http_target], the
   * default is 3 minutes. The deadline must be in the interval [15 seconds, 30
   * minutes].
   *
   * * For [App Engine HTTP
   * targets][google.cloud.scheduler.v1.Job.app_engine_http_target], 0 indicates
   * that the request has the default deadline. The default deadline depends on
   * the scaling type of the service: 10 minutes for standard apps with
   * automatic scaling, 24 hours for standard apps with manual and basic
   * scaling, and 60 minutes for flex apps. If the request deadline is set, it
   * must be in the interval [15 seconds, 24 hours 15 seconds].
   *
   * * For [Pub/Sub targets][google.cloud.scheduler.v1.Job.pubsub_target], this
   * field is ignored.
   */
  attemptDeadline: Duration | undefined;
}

/** State of the job. */
export enum Job_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** ENABLED - The job is executing normally. */
  ENABLED = 1,
  /**
   * PAUSED - The job is paused by the user. It will not execute. A user can
   * intentionally pause the job using
   * [PauseJobRequest][google.cloud.scheduler.v1.PauseJobRequest].
   */
  PAUSED = 2,
  /**
   * DISABLED - The job is disabled by the system due to error. The user
   * cannot directly set a job to be disabled.
   */
  DISABLED = 3,
  /**
   * UPDATE_FAILED - The job state resulting from a failed
   * [CloudScheduler.UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob]
   * operation. To recover a job from this state, retry
   * [CloudScheduler.UpdateJob][google.cloud.scheduler.v1.CloudScheduler.UpdateJob]
   * until a successful response is received.
   */
  UPDATE_FAILED = 4,
  UNRECOGNIZED = -1,
}

export function job_StateFromJSON(object: any): Job_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Job_State.STATE_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return Job_State.ENABLED;
    case 2:
    case "PAUSED":
      return Job_State.PAUSED;
    case 3:
    case "DISABLED":
      return Job_State.DISABLED;
    case 4:
    case "UPDATE_FAILED":
      return Job_State.UPDATE_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Job_State.UNRECOGNIZED;
  }
}

export function job_StateToJSON(object: Job_State): string {
  switch (object) {
    case Job_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Job_State.ENABLED:
      return "ENABLED";
    case Job_State.PAUSED:
      return "PAUSED";
    case Job_State.DISABLED:
      return "DISABLED";
    case Job_State.UPDATE_FAILED:
      return "UPDATE_FAILED";
    case Job_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Settings that determine the retry behavior.
 *
 * By default, if a job does not complete successfully (meaning that
 * an acknowledgement is not received from the handler, then it will be retried
 * with exponential backoff according to the settings in
 * [RetryConfig][google.cloud.scheduler.v1.RetryConfig].
 */
export interface RetryConfig {
  /**
   * The number of attempts that the system will make to run a job using the
   * exponential backoff procedure described by
   * [max_doublings][google.cloud.scheduler.v1.RetryConfig.max_doublings].
   *
   * The default value of retry_count is zero.
   *
   * If retry_count is zero, a job attempt will *not* be retried if
   * it fails. Instead the Cloud Scheduler system will wait for the
   * next scheduled execution time.
   *
   * If retry_count is set to a non-zero number then Cloud Scheduler
   * will retry failed attempts, using exponential backoff,
   * retry_count times, or until the next scheduled execution time,
   * whichever comes first.
   *
   * Values greater than 5 and negative values are not allowed.
   */
  retryCount: number;
  /**
   * The time limit for retrying a failed job, measured from time when an
   * execution was first attempted. If specified with
   * [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count], the job
   * will be retried until both limits are reached.
   *
   * The default value for max_retry_duration is zero, which means retry
   * duration is unlimited.
   */
  maxRetryDuration:
    | Duration
    | undefined;
  /**
   * The minimum amount of time to wait before retrying a job after
   * it fails.
   *
   * The default value of this field is 5 seconds.
   */
  minBackoffDuration:
    | Duration
    | undefined;
  /**
   * The maximum amount of time to wait before retrying a job after
   * it fails.
   *
   * The default value of this field is 1 hour.
   */
  maxBackoffDuration:
    | Duration
    | undefined;
  /**
   * The time between retries will double `max_doublings` times.
   *
   * A job's retry interval starts at
   * [min_backoff_duration][google.cloud.scheduler.v1.RetryConfig.min_backoff_duration],
   * then doubles `max_doublings` times, then increases linearly, and finally
   * retries at intervals of
   * [max_backoff_duration][google.cloud.scheduler.v1.RetryConfig.max_backoff_duration]
   * up to [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count]
   * times.
   *
   * For example, if
   * [min_backoff_duration][google.cloud.scheduler.v1.RetryConfig.min_backoff_duration]
   * is 10s,
   * [max_backoff_duration][google.cloud.scheduler.v1.RetryConfig.max_backoff_duration]
   * is 300s, and `max_doublings` is 3, then the a job will first be retried in
   * 10s. The retry interval will double three times, and then increase linearly
   * by 2^3 * 10s.  Finally, the job will retry at intervals of
   * [max_backoff_duration][google.cloud.scheduler.v1.RetryConfig.max_backoff_duration]
   * until the job has been attempted
   * [retry_count][google.cloud.scheduler.v1.RetryConfig.retry_count] times.
   * Thus, the requests will retry at 10s, 20s, 40s, 80s, 160s, 240s, 300s,
   * 300s, ....
   *
   * The default value of this field is 5.
   */
  maxDoublings: number;
}

function createBaseJob(): Job {
  return {
    name: "",
    description: "",
    pubsubTarget: undefined,
    appEngineHttpTarget: undefined,
    httpTarget: undefined,
    schedule: "",
    timeZone: "",
    userUpdateTime: undefined,
    state: 0,
    status: undefined,
    scheduleTime: undefined,
    lastAttemptTime: undefined,
    retryConfig: undefined,
    attemptDeadline: undefined,
  };
}

export const Job: MessageFns<Job> = {
  encode(message: Job, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.pubsubTarget !== undefined) {
      PubsubTarget.encode(message.pubsubTarget, writer.uint32(34).fork()).join();
    }
    if (message.appEngineHttpTarget !== undefined) {
      AppEngineHttpTarget.encode(message.appEngineHttpTarget, writer.uint32(42).fork()).join();
    }
    if (message.httpTarget !== undefined) {
      HttpTarget.encode(message.httpTarget, writer.uint32(50).fork()).join();
    }
    if (message.schedule !== "") {
      writer.uint32(162).string(message.schedule);
    }
    if (message.timeZone !== "") {
      writer.uint32(170).string(message.timeZone);
    }
    if (message.userUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.userUpdateTime), writer.uint32(74).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (message.status !== undefined) {
      Status.encode(message.status, writer.uint32(90).fork()).join();
    }
    if (message.scheduleTime !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduleTime), writer.uint32(138).fork()).join();
    }
    if (message.lastAttemptTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastAttemptTime), writer.uint32(146).fork()).join();
    }
    if (message.retryConfig !== undefined) {
      RetryConfig.encode(message.retryConfig, writer.uint32(154).fork()).join();
    }
    if (message.attemptDeadline !== undefined) {
      Duration.encode(message.attemptDeadline, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pubsubTarget = PubsubTarget.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.appEngineHttpTarget = AppEngineHttpTarget.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.httpTarget = HttpTarget.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.schedule = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.timeZone = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.userUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.status = Status.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.scheduleTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.lastAttemptTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.retryConfig = RetryConfig.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.attemptDeadline = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      pubsubTarget: isSet(object.pubsubTarget) ? PubsubTarget.fromJSON(object.pubsubTarget) : undefined,
      appEngineHttpTarget: isSet(object.appEngineHttpTarget)
        ? AppEngineHttpTarget.fromJSON(object.appEngineHttpTarget)
        : undefined,
      httpTarget: isSet(object.httpTarget) ? HttpTarget.fromJSON(object.httpTarget) : undefined,
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : "",
      timeZone: isSet(object.timeZone) ? globalThis.String(object.timeZone) : "",
      userUpdateTime: isSet(object.userUpdateTime) ? fromJsonTimestamp(object.userUpdateTime) : undefined,
      state: isSet(object.state) ? job_StateFromJSON(object.state) : 0,
      status: isSet(object.status) ? Status.fromJSON(object.status) : undefined,
      scheduleTime: isSet(object.scheduleTime) ? fromJsonTimestamp(object.scheduleTime) : undefined,
      lastAttemptTime: isSet(object.lastAttemptTime) ? fromJsonTimestamp(object.lastAttemptTime) : undefined,
      retryConfig: isSet(object.retryConfig) ? RetryConfig.fromJSON(object.retryConfig) : undefined,
      attemptDeadline: isSet(object.attemptDeadline) ? Duration.fromJSON(object.attemptDeadline) : undefined,
    };
  },

  toJSON(message: Job): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.pubsubTarget !== undefined) {
      obj.pubsubTarget = PubsubTarget.toJSON(message.pubsubTarget);
    }
    if (message.appEngineHttpTarget !== undefined) {
      obj.appEngineHttpTarget = AppEngineHttpTarget.toJSON(message.appEngineHttpTarget);
    }
    if (message.httpTarget !== undefined) {
      obj.httpTarget = HttpTarget.toJSON(message.httpTarget);
    }
    if (message.schedule !== "") {
      obj.schedule = message.schedule;
    }
    if (message.timeZone !== "") {
      obj.timeZone = message.timeZone;
    }
    if (message.userUpdateTime !== undefined) {
      obj.userUpdateTime = message.userUpdateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = job_StateToJSON(message.state);
    }
    if (message.status !== undefined) {
      obj.status = Status.toJSON(message.status);
    }
    if (message.scheduleTime !== undefined) {
      obj.scheduleTime = message.scheduleTime.toISOString();
    }
    if (message.lastAttemptTime !== undefined) {
      obj.lastAttemptTime = message.lastAttemptTime.toISOString();
    }
    if (message.retryConfig !== undefined) {
      obj.retryConfig = RetryConfig.toJSON(message.retryConfig);
    }
    if (message.attemptDeadline !== undefined) {
      obj.attemptDeadline = Duration.toJSON(message.attemptDeadline);
    }
    return obj;
  },

  create(base?: DeepPartial<Job>): Job {
    return Job.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Job>): Job {
    const message = createBaseJob();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.pubsubTarget = (object.pubsubTarget !== undefined && object.pubsubTarget !== null)
      ? PubsubTarget.fromPartial(object.pubsubTarget)
      : undefined;
    message.appEngineHttpTarget = (object.appEngineHttpTarget !== undefined && object.appEngineHttpTarget !== null)
      ? AppEngineHttpTarget.fromPartial(object.appEngineHttpTarget)
      : undefined;
    message.httpTarget = (object.httpTarget !== undefined && object.httpTarget !== null)
      ? HttpTarget.fromPartial(object.httpTarget)
      : undefined;
    message.schedule = object.schedule ?? "";
    message.timeZone = object.timeZone ?? "";
    message.userUpdateTime = object.userUpdateTime ?? undefined;
    message.state = object.state ?? 0;
    message.status = (object.status !== undefined && object.status !== null)
      ? Status.fromPartial(object.status)
      : undefined;
    message.scheduleTime = object.scheduleTime ?? undefined;
    message.lastAttemptTime = object.lastAttemptTime ?? undefined;
    message.retryConfig = (object.retryConfig !== undefined && object.retryConfig !== null)
      ? RetryConfig.fromPartial(object.retryConfig)
      : undefined;
    message.attemptDeadline = (object.attemptDeadline !== undefined && object.attemptDeadline !== null)
      ? Duration.fromPartial(object.attemptDeadline)
      : undefined;
    return message;
  },
};

function createBaseRetryConfig(): RetryConfig {
  return {
    retryCount: 0,
    maxRetryDuration: undefined,
    minBackoffDuration: undefined,
    maxBackoffDuration: undefined,
    maxDoublings: 0,
  };
}

export const RetryConfig: MessageFns<RetryConfig> = {
  encode(message: RetryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retryCount !== 0) {
      writer.uint32(8).int32(message.retryCount);
    }
    if (message.maxRetryDuration !== undefined) {
      Duration.encode(message.maxRetryDuration, writer.uint32(18).fork()).join();
    }
    if (message.minBackoffDuration !== undefined) {
      Duration.encode(message.minBackoffDuration, writer.uint32(26).fork()).join();
    }
    if (message.maxBackoffDuration !== undefined) {
      Duration.encode(message.maxBackoffDuration, writer.uint32(34).fork()).join();
    }
    if (message.maxDoublings !== 0) {
      writer.uint32(40).int32(message.maxDoublings);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxRetryDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.minBackoffDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maxBackoffDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maxDoublings = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryConfig {
    return {
      retryCount: isSet(object.retryCount) ? globalThis.Number(object.retryCount) : 0,
      maxRetryDuration: isSet(object.maxRetryDuration) ? Duration.fromJSON(object.maxRetryDuration) : undefined,
      minBackoffDuration: isSet(object.minBackoffDuration) ? Duration.fromJSON(object.minBackoffDuration) : undefined,
      maxBackoffDuration: isSet(object.maxBackoffDuration) ? Duration.fromJSON(object.maxBackoffDuration) : undefined,
      maxDoublings: isSet(object.maxDoublings) ? globalThis.Number(object.maxDoublings) : 0,
    };
  },

  toJSON(message: RetryConfig): unknown {
    const obj: any = {};
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.maxRetryDuration !== undefined) {
      obj.maxRetryDuration = Duration.toJSON(message.maxRetryDuration);
    }
    if (message.minBackoffDuration !== undefined) {
      obj.minBackoffDuration = Duration.toJSON(message.minBackoffDuration);
    }
    if (message.maxBackoffDuration !== undefined) {
      obj.maxBackoffDuration = Duration.toJSON(message.maxBackoffDuration);
    }
    if (message.maxDoublings !== 0) {
      obj.maxDoublings = Math.round(message.maxDoublings);
    }
    return obj;
  },

  create(base?: DeepPartial<RetryConfig>): RetryConfig {
    return RetryConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetryConfig>): RetryConfig {
    const message = createBaseRetryConfig();
    message.retryCount = object.retryCount ?? 0;
    message.maxRetryDuration = (object.maxRetryDuration !== undefined && object.maxRetryDuration !== null)
      ? Duration.fromPartial(object.maxRetryDuration)
      : undefined;
    message.minBackoffDuration = (object.minBackoffDuration !== undefined && object.minBackoffDuration !== null)
      ? Duration.fromPartial(object.minBackoffDuration)
      : undefined;
    message.maxBackoffDuration = (object.maxBackoffDuration !== undefined && object.maxBackoffDuration !== null)
      ? Duration.fromPartial(object.maxBackoffDuration)
      : undefined;
    message.maxDoublings = object.maxDoublings ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
