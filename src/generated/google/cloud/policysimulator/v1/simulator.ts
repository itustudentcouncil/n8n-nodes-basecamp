// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/policysimulator/v1/simulator.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Policy } from "../../../iam/v1/policy.js";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { DateMessage } from "../../../type/date.js";
import { AccessState, accessStateFromJSON, accessStateToJSON, AccessTuple, ExplainedPolicy } from "./explanations.js";

export const protobufPackage = "google.cloud.policysimulator.v1";

/** A resource describing a `Replay`, or simulation. */
export interface Replay {
  /**
   * Output only. The resource name of the `Replay`, which has the following
   * format:
   *
   * `{projects|folders|organizations}/{resource-id}/locations/global/replays/{replay-id}`,
   * where `{resource-id}` is the ID of the project, folder, or organization
   * that owns the Replay.
   *
   * Example:
   * `projects/my-example-project/locations/global/replays/506a5f7f-38ce-4d7d-8e03-479ce1833c36`
   */
  name: string;
  /** Output only. The current state of the `Replay`. */
  state: Replay_State;
  /** Required. The configuration used for the `Replay`. */
  config:
    | ReplayConfig
    | undefined;
  /** Output only. Summary statistics about the replayed log entries. */
  resultsSummary: Replay_ResultsSummary | undefined;
}

/** The current state of the [Replay][google.cloud.policysimulator.v1.Replay]. */
export enum Replay_State {
  /** STATE_UNSPECIFIED - Default value. This value is unused. */
  STATE_UNSPECIFIED = 0,
  /** PENDING - The `Replay` has not started yet. */
  PENDING = 1,
  /** RUNNING - The `Replay` is currently running. */
  RUNNING = 2,
  /** SUCCEEDED - The `Replay` has successfully completed. */
  SUCCEEDED = 3,
  /** FAILED - The `Replay` has finished with an error. */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function replay_StateFromJSON(object: any): Replay_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Replay_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Replay_State.PENDING;
    case 2:
    case "RUNNING":
      return Replay_State.RUNNING;
    case 3:
    case "SUCCEEDED":
      return Replay_State.SUCCEEDED;
    case 4:
    case "FAILED":
      return Replay_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Replay_State.UNRECOGNIZED;
  }
}

export function replay_StateToJSON(object: Replay_State): string {
  switch (object) {
    case Replay_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Replay_State.PENDING:
      return "PENDING";
    case Replay_State.RUNNING:
      return "RUNNING";
    case Replay_State.SUCCEEDED:
      return "SUCCEEDED";
    case Replay_State.FAILED:
      return "FAILED";
    case Replay_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Summary statistics about the replayed log entries. */
export interface Replay_ResultsSummary {
  /** The total number of log entries replayed. */
  logCount: number;
  /**
   * The number of replayed log entries with no difference between
   * baseline and simulated policies.
   */
  unchangedCount: number;
  /**
   * The number of replayed log entries with a difference between baseline and
   * simulated policies.
   */
  differenceCount: number;
  /** The number of log entries that could not be replayed. */
  errorCount: number;
  /** The date of the oldest log entry replayed. */
  oldestDate:
    | DateMessage
    | undefined;
  /** The date of the newest log entry replayed. */
  newestDate: DateMessage | undefined;
}

/** The result of replaying a single access tuple against a simulated state. */
export interface ReplayResult {
  /**
   * The difference between the principal's access under the current
   * (baseline) policies and the principal's access under the proposed
   * (simulated) policies.
   *
   * This field is only included for access tuples that were successfully
   * replayed and had different results under the current policies and the
   * proposed policies.
   */
  diff?:
    | ReplayDiff
    | undefined;
  /**
   * The error that caused the access tuple replay to fail.
   *
   * This field is only included for access tuples that were not replayed
   * successfully.
   */
  error?:
    | Status
    | undefined;
  /**
   * The resource name of the `ReplayResult`, in the following format:
   *
   * `{projects|folders|organizations}/{resource-id}/locations/global/replays/{replay-id}/results/{replay-result-id}`,
   * where `{resource-id}` is the ID of the project, folder, or organization
   * that owns the [Replay][google.cloud.policysimulator.v1.Replay].
   *
   * Example:
   * `projects/my-example-project/locations/global/replays/506a5f7f-38ce-4d7d-8e03-479ce1833c36/results/1234`
   */
  name: string;
  /**
   * The [Replay][google.cloud.policysimulator.v1.Replay] that the access tuple
   * was included in.
   */
  parent: string;
  /**
   * The access tuple that was replayed. This field includes information about
   * the principal, resource, and permission that were involved in the access
   * attempt.
   */
  accessTuple:
    | AccessTuple
    | undefined;
  /** The latest date this access tuple was seen in the logs. */
  lastSeenDate: DateMessage | undefined;
}

/**
 * Request message for
 * [Simulator.CreateReplay][google.cloud.policysimulator.v1.Simulator.CreateReplay].
 */
export interface CreateReplayRequest {
  /**
   * Required. The parent resource where this
   * [Replay][google.cloud.policysimulator.v1.Replay] will be created. This
   * resource must be a project, folder, or organization with a location.
   *
   * Example: `projects/my-example-project/locations/global`
   */
  parent: string;
  /**
   * Required. The [Replay][google.cloud.policysimulator.v1.Replay] to create.
   * Set `Replay.ReplayConfig` to configure the replay.
   */
  replay: Replay | undefined;
}

/** Metadata about a Replay operation. */
export interface ReplayOperationMetadata {
  /** Time when the request was received. */
  startTime: Date | undefined;
}

/**
 * Request message for
 * [Simulator.GetReplay][google.cloud.policysimulator.v1.Simulator.GetReplay].
 */
export interface GetReplayRequest {
  /**
   * Required. The name of the [Replay][google.cloud.policysimulator.v1.Replay]
   * to retrieve, in the following format:
   *
   * `{projects|folders|organizations}/{resource-id}/locations/global/replays/{replay-id}`,
   * where `{resource-id}` is the ID of the project, folder, or organization
   * that owns the `Replay`.
   *
   * Example:
   * `projects/my-example-project/locations/global/replays/506a5f7f-38ce-4d7d-8e03-479ce1833c36`
   */
  name: string;
}

/**
 * Request message for
 * [Simulator.ListReplayResults][google.cloud.policysimulator.v1.Simulator.ListReplayResults].
 */
export interface ListReplayResultsRequest {
  /**
   * Required. The [Replay][google.cloud.policysimulator.v1.Replay] whose
   * results are listed, in the following format:
   *
   * `{projects|folders|organizations}/{resource-id}/locations/global/replays/{replay-id}`
   *
   * Example:
   * `projects/my-project/locations/global/replays/506a5f7f-38ce-4d7d-8e03-479ce1833c36`
   */
  parent: string;
  /**
   * The maximum number of
   * [ReplayResult][google.cloud.policysimulator.v1.ReplayResult] objects to
   * return. Defaults to 5000.
   *
   * The maximum value is 5000; values above 5000 are rounded down to 5000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous
   * [Simulator.ListReplayResults][google.cloud.policysimulator.v1.Simulator.ListReplayResults]
   * call. Provide this token to retrieve the next page of results.
   *
   * When paginating, all other parameters provided to
   * [Simulator.ListReplayResults[] must match the call that provided the page
   * token.
   */
  pageToken: string;
}

/**
 * Response message for
 * [Simulator.ListReplayResults][google.cloud.policysimulator.v1.Simulator.ListReplayResults].
 */
export interface ListReplayResultsResponse {
  /** The results of running a [Replay][google.cloud.policysimulator.v1.Replay]. */
  replayResults: ReplayResult[];
  /**
   * A token that you can use to retrieve the next page of
   * [ReplayResult][google.cloud.policysimulator.v1.ReplayResult] objects. If
   * this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/**
 * The configuration used for a
 * [Replay][google.cloud.policysimulator.v1.Replay].
 */
export interface ReplayConfig {
  /**
   * A mapping of the resources that you want to simulate policies for and the
   * policies that you want to simulate.
   *
   * Keys are the full resource names for the resources. For example,
   * `//cloudresourcemanager.googleapis.com/projects/my-project`.
   * For examples of full resource names for Google Cloud services, see
   * https://cloud.google.com/iam/help/troubleshooter/full-resource-names.
   *
   * Values are [Policy][google.iam.v1.Policy] objects representing the policies
   * that you want to simulate.
   *
   * Replays automatically take into account any IAM policies inherited through
   * the resource hierarchy, and any policies set on descendant resources. You
   * do not need to include these policies in the policy overlay.
   */
  policyOverlay: { [key: string]: Policy };
  /**
   * The logs to use as input for the
   * [Replay][google.cloud.policysimulator.v1.Replay].
   */
  logSource: ReplayConfig_LogSource;
}

/**
 * The source of the logs to use for a
 * [Replay][google.cloud.policysimulator.v1.Replay].
 */
export enum ReplayConfig_LogSource {
  /**
   * LOG_SOURCE_UNSPECIFIED - An unspecified log source.
   * If the log source is unspecified, the
   * [Replay][google.cloud.policysimulator.v1.Replay] defaults to using
   * `RECENT_ACCESSES`.
   */
  LOG_SOURCE_UNSPECIFIED = 0,
  /**
   * RECENT_ACCESSES - All access logs from the last 90 days. These logs may not include logs
   * from the most recent 7 days.
   */
  RECENT_ACCESSES = 1,
  UNRECOGNIZED = -1,
}

export function replayConfig_LogSourceFromJSON(object: any): ReplayConfig_LogSource {
  switch (object) {
    case 0:
    case "LOG_SOURCE_UNSPECIFIED":
      return ReplayConfig_LogSource.LOG_SOURCE_UNSPECIFIED;
    case 1:
    case "RECENT_ACCESSES":
      return ReplayConfig_LogSource.RECENT_ACCESSES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReplayConfig_LogSource.UNRECOGNIZED;
  }
}

export function replayConfig_LogSourceToJSON(object: ReplayConfig_LogSource): string {
  switch (object) {
    case ReplayConfig_LogSource.LOG_SOURCE_UNSPECIFIED:
      return "LOG_SOURCE_UNSPECIFIED";
    case ReplayConfig_LogSource.RECENT_ACCESSES:
      return "RECENT_ACCESSES";
    case ReplayConfig_LogSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ReplayConfig_PolicyOverlayEntry {
  key: string;
  value: Policy | undefined;
}

/**
 * The difference between the results of evaluating an access tuple under
 * the current (baseline) policies and under the proposed (simulated) policies.
 * This difference explains how a principal's access could change if the
 * proposed policies were applied.
 */
export interface ReplayDiff {
  /**
   * A summary and comparison of the principal's access under the current
   * (baseline) policies and the proposed (simulated) policies for a single
   * access tuple.
   *
   * The evaluation of the principal's access is reported in the
   * [AccessState][google.cloud.policysimulator.v1.AccessState] field.
   */
  accessDiff: AccessStateDiff | undefined;
}

/**
 * A summary and comparison of the principal's access under the current
 * (baseline) policies and the proposed (simulated) policies for a single
 * access tuple.
 */
export interface AccessStateDiff {
  /**
   * The results of evaluating the access tuple under the current (baseline)
   * policies.
   *
   * If the [AccessState][google.cloud.policysimulator.v1.AccessState] couldn't
   * be fully evaluated, this field explains why.
   */
  baseline:
    | ExplainedAccess
    | undefined;
  /**
   * The results of evaluating the access tuple under the proposed (simulated)
   * policies.
   *
   * If the AccessState couldn't be fully evaluated, this field explains why.
   */
  simulated:
    | ExplainedAccess
    | undefined;
  /**
   * How the principal's access, specified in the AccessState field, changed
   * between the current (baseline) policies and proposed (simulated) policies.
   */
  accessChange: AccessStateDiff_AccessChangeType;
}

/**
 * How the principal's access, specified in the AccessState field, changed
 * between the current (baseline) policies and proposed (simulated) policies.
 */
export enum AccessStateDiff_AccessChangeType {
  /** ACCESS_CHANGE_TYPE_UNSPECIFIED - Default value. This value is unused. */
  ACCESS_CHANGE_TYPE_UNSPECIFIED = 0,
  /**
   * NO_CHANGE - The principal's access did not change.
   * This includes the case where both baseline and simulated are UNKNOWN,
   * but the unknown information is equivalent.
   */
  NO_CHANGE = 1,
  /**
   * UNKNOWN_CHANGE - The principal's access under both the current policies and the proposed
   * policies is `UNKNOWN`, but the unknown information differs between them.
   */
  UNKNOWN_CHANGE = 2,
  /**
   * ACCESS_REVOKED - The principal had access under the current policies (`GRANTED`), but will
   * no longer have access after the proposed changes (`NOT_GRANTED`).
   */
  ACCESS_REVOKED = 3,
  /**
   * ACCESS_GAINED - The principal did not have access under the current policies
   * (`NOT_GRANTED`), but will have access after the proposed changes
   * (`GRANTED`).
   */
  ACCESS_GAINED = 4,
  /**
   * ACCESS_MAYBE_REVOKED - This result can occur for the following reasons:
   *
   * * The principal had access under the current policies (`GRANTED`), but
   *   their access after the proposed changes is `UNKNOWN`.
   *
   * * The principal's access under the current policies is `UNKNOWN`, but
   * they
   *   will not have access after the proposed changes (`NOT_GRANTED`).
   */
  ACCESS_MAYBE_REVOKED = 5,
  /**
   * ACCESS_MAYBE_GAINED - This result can occur for the following reasons:
   *
   * * The principal did not have access under the current policies
   *   (`NOT_GRANTED`), but their access after the proposed changes is
   *   `UNKNOWN`.
   *
   * * The principal's access under the current policies is `UNKNOWN`, but
   * they will have access after the proposed changes (`GRANTED`).
   */
  ACCESS_MAYBE_GAINED = 6,
  UNRECOGNIZED = -1,
}

export function accessStateDiff_AccessChangeTypeFromJSON(object: any): AccessStateDiff_AccessChangeType {
  switch (object) {
    case 0:
    case "ACCESS_CHANGE_TYPE_UNSPECIFIED":
      return AccessStateDiff_AccessChangeType.ACCESS_CHANGE_TYPE_UNSPECIFIED;
    case 1:
    case "NO_CHANGE":
      return AccessStateDiff_AccessChangeType.NO_CHANGE;
    case 2:
    case "UNKNOWN_CHANGE":
      return AccessStateDiff_AccessChangeType.UNKNOWN_CHANGE;
    case 3:
    case "ACCESS_REVOKED":
      return AccessStateDiff_AccessChangeType.ACCESS_REVOKED;
    case 4:
    case "ACCESS_GAINED":
      return AccessStateDiff_AccessChangeType.ACCESS_GAINED;
    case 5:
    case "ACCESS_MAYBE_REVOKED":
      return AccessStateDiff_AccessChangeType.ACCESS_MAYBE_REVOKED;
    case 6:
    case "ACCESS_MAYBE_GAINED":
      return AccessStateDiff_AccessChangeType.ACCESS_MAYBE_GAINED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessStateDiff_AccessChangeType.UNRECOGNIZED;
  }
}

export function accessStateDiff_AccessChangeTypeToJSON(object: AccessStateDiff_AccessChangeType): string {
  switch (object) {
    case AccessStateDiff_AccessChangeType.ACCESS_CHANGE_TYPE_UNSPECIFIED:
      return "ACCESS_CHANGE_TYPE_UNSPECIFIED";
    case AccessStateDiff_AccessChangeType.NO_CHANGE:
      return "NO_CHANGE";
    case AccessStateDiff_AccessChangeType.UNKNOWN_CHANGE:
      return "UNKNOWN_CHANGE";
    case AccessStateDiff_AccessChangeType.ACCESS_REVOKED:
      return "ACCESS_REVOKED";
    case AccessStateDiff_AccessChangeType.ACCESS_GAINED:
      return "ACCESS_GAINED";
    case AccessStateDiff_AccessChangeType.ACCESS_MAYBE_REVOKED:
      return "ACCESS_MAYBE_REVOKED";
    case AccessStateDiff_AccessChangeType.ACCESS_MAYBE_GAINED:
      return "ACCESS_MAYBE_GAINED";
    case AccessStateDiff_AccessChangeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Details about how a set of policies, listed in
 * [ExplainedPolicy][google.cloud.policysimulator.v1.ExplainedPolicy], resulted
 * in a certain [AccessState][google.cloud.policysimulator.v1.AccessState] when
 * replaying an access tuple.
 */
export interface ExplainedAccess {
  /**
   * Whether the principal in the access tuple has permission to access the
   * resource in the access tuple under the given policies.
   */
  accessState: AccessState;
  /**
   * If the [AccessState][google.cloud.policysimulator.v1.AccessState] is
   * `UNKNOWN`, this field contains the policies that led to that result.
   *
   * If the `AccessState` is `GRANTED` or `NOT_GRANTED`, this field is
   * omitted.
   */
  policies: ExplainedPolicy[];
  /**
   * If the [AccessState][google.cloud.policysimulator.v1.AccessState] is
   * `UNKNOWN`, this field contains a list of errors explaining why the result
   * is `UNKNOWN`.
   *
   * If the `AccessState` is `GRANTED` or `NOT_GRANTED`, this field is
   * omitted.
   */
  errors: Status[];
}

function createBaseReplay(): Replay {
  return { name: "", state: 0, config: undefined, resultsSummary: undefined };
}

export const Replay: MessageFns<Replay> = {
  encode(message: Replay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.config !== undefined) {
      ReplayConfig.encode(message.config, writer.uint32(26).fork()).join();
    }
    if (message.resultsSummary !== undefined) {
      Replay_ResultsSummary.encode(message.resultsSummary, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Replay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.config = ReplayConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.resultsSummary = Replay_ResultsSummary.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Replay {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? replay_StateFromJSON(object.state) : 0,
      config: isSet(object.config) ? ReplayConfig.fromJSON(object.config) : undefined,
      resultsSummary: isSet(object.resultsSummary) ? Replay_ResultsSummary.fromJSON(object.resultsSummary) : undefined,
    };
  },

  toJSON(message: Replay): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = replay_StateToJSON(message.state);
    }
    if (message.config !== undefined) {
      obj.config = ReplayConfig.toJSON(message.config);
    }
    if (message.resultsSummary !== undefined) {
      obj.resultsSummary = Replay_ResultsSummary.toJSON(message.resultsSummary);
    }
    return obj;
  },

  create(base?: DeepPartial<Replay>): Replay {
    return Replay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Replay>): Replay {
    const message = createBaseReplay();
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.config = (object.config !== undefined && object.config !== null)
      ? ReplayConfig.fromPartial(object.config)
      : undefined;
    message.resultsSummary = (object.resultsSummary !== undefined && object.resultsSummary !== null)
      ? Replay_ResultsSummary.fromPartial(object.resultsSummary)
      : undefined;
    return message;
  },
};

function createBaseReplay_ResultsSummary(): Replay_ResultsSummary {
  return {
    logCount: 0,
    unchangedCount: 0,
    differenceCount: 0,
    errorCount: 0,
    oldestDate: undefined,
    newestDate: undefined,
  };
}

export const Replay_ResultsSummary: MessageFns<Replay_ResultsSummary> = {
  encode(message: Replay_ResultsSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.logCount !== 0) {
      writer.uint32(8).int32(message.logCount);
    }
    if (message.unchangedCount !== 0) {
      writer.uint32(16).int32(message.unchangedCount);
    }
    if (message.differenceCount !== 0) {
      writer.uint32(24).int32(message.differenceCount);
    }
    if (message.errorCount !== 0) {
      writer.uint32(32).int32(message.errorCount);
    }
    if (message.oldestDate !== undefined) {
      DateMessage.encode(message.oldestDate, writer.uint32(42).fork()).join();
    }
    if (message.newestDate !== undefined) {
      DateMessage.encode(message.newestDate, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Replay_ResultsSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplay_ResultsSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.logCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.unchangedCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.differenceCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.errorCount = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.oldestDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.newestDate = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Replay_ResultsSummary {
    return {
      logCount: isSet(object.logCount) ? globalThis.Number(object.logCount) : 0,
      unchangedCount: isSet(object.unchangedCount) ? globalThis.Number(object.unchangedCount) : 0,
      differenceCount: isSet(object.differenceCount) ? globalThis.Number(object.differenceCount) : 0,
      errorCount: isSet(object.errorCount) ? globalThis.Number(object.errorCount) : 0,
      oldestDate: isSet(object.oldestDate) ? DateMessage.fromJSON(object.oldestDate) : undefined,
      newestDate: isSet(object.newestDate) ? DateMessage.fromJSON(object.newestDate) : undefined,
    };
  },

  toJSON(message: Replay_ResultsSummary): unknown {
    const obj: any = {};
    if (message.logCount !== 0) {
      obj.logCount = Math.round(message.logCount);
    }
    if (message.unchangedCount !== 0) {
      obj.unchangedCount = Math.round(message.unchangedCount);
    }
    if (message.differenceCount !== 0) {
      obj.differenceCount = Math.round(message.differenceCount);
    }
    if (message.errorCount !== 0) {
      obj.errorCount = Math.round(message.errorCount);
    }
    if (message.oldestDate !== undefined) {
      obj.oldestDate = DateMessage.toJSON(message.oldestDate);
    }
    if (message.newestDate !== undefined) {
      obj.newestDate = DateMessage.toJSON(message.newestDate);
    }
    return obj;
  },

  create(base?: DeepPartial<Replay_ResultsSummary>): Replay_ResultsSummary {
    return Replay_ResultsSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Replay_ResultsSummary>): Replay_ResultsSummary {
    const message = createBaseReplay_ResultsSummary();
    message.logCount = object.logCount ?? 0;
    message.unchangedCount = object.unchangedCount ?? 0;
    message.differenceCount = object.differenceCount ?? 0;
    message.errorCount = object.errorCount ?? 0;
    message.oldestDate = (object.oldestDate !== undefined && object.oldestDate !== null)
      ? DateMessage.fromPartial(object.oldestDate)
      : undefined;
    message.newestDate = (object.newestDate !== undefined && object.newestDate !== null)
      ? DateMessage.fromPartial(object.newestDate)
      : undefined;
    return message;
  },
};

function createBaseReplayResult(): ReplayResult {
  return { diff: undefined, error: undefined, name: "", parent: "", accessTuple: undefined, lastSeenDate: undefined };
}

export const ReplayResult: MessageFns<ReplayResult> = {
  encode(message: ReplayResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.diff !== undefined) {
      ReplayDiff.encode(message.diff, writer.uint32(42).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(50).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    if (message.accessTuple !== undefined) {
      AccessTuple.encode(message.accessTuple, writer.uint32(26).fork()).join();
    }
    if (message.lastSeenDate !== undefined) {
      DateMessage.encode(message.lastSeenDate, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplayResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.diff = ReplayDiff.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accessTuple = AccessTuple.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastSeenDate = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayResult {
    return {
      diff: isSet(object.diff) ? ReplayDiff.fromJSON(object.diff) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      accessTuple: isSet(object.accessTuple) ? AccessTuple.fromJSON(object.accessTuple) : undefined,
      lastSeenDate: isSet(object.lastSeenDate) ? DateMessage.fromJSON(object.lastSeenDate) : undefined,
    };
  },

  toJSON(message: ReplayResult): unknown {
    const obj: any = {};
    if (message.diff !== undefined) {
      obj.diff = ReplayDiff.toJSON(message.diff);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.accessTuple !== undefined) {
      obj.accessTuple = AccessTuple.toJSON(message.accessTuple);
    }
    if (message.lastSeenDate !== undefined) {
      obj.lastSeenDate = DateMessage.toJSON(message.lastSeenDate);
    }
    return obj;
  },

  create(base?: DeepPartial<ReplayResult>): ReplayResult {
    return ReplayResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplayResult>): ReplayResult {
    const message = createBaseReplayResult();
    message.diff = (object.diff !== undefined && object.diff !== null)
      ? ReplayDiff.fromPartial(object.diff)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.name = object.name ?? "";
    message.parent = object.parent ?? "";
    message.accessTuple = (object.accessTuple !== undefined && object.accessTuple !== null)
      ? AccessTuple.fromPartial(object.accessTuple)
      : undefined;
    message.lastSeenDate = (object.lastSeenDate !== undefined && object.lastSeenDate !== null)
      ? DateMessage.fromPartial(object.lastSeenDate)
      : undefined;
    return message;
  },
};

function createBaseCreateReplayRequest(): CreateReplayRequest {
  return { parent: "", replay: undefined };
}

export const CreateReplayRequest: MessageFns<CreateReplayRequest> = {
  encode(message: CreateReplayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.replay !== undefined) {
      Replay.encode(message.replay, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReplayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReplayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.replay = Replay.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReplayRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      replay: isSet(object.replay) ? Replay.fromJSON(object.replay) : undefined,
    };
  },

  toJSON(message: CreateReplayRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.replay !== undefined) {
      obj.replay = Replay.toJSON(message.replay);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateReplayRequest>): CreateReplayRequest {
    return CreateReplayRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateReplayRequest>): CreateReplayRequest {
    const message = createBaseCreateReplayRequest();
    message.parent = object.parent ?? "";
    message.replay = (object.replay !== undefined && object.replay !== null)
      ? Replay.fromPartial(object.replay)
      : undefined;
    return message;
  },
};

function createBaseReplayOperationMetadata(): ReplayOperationMetadata {
  return { startTime: undefined };
}

export const ReplayOperationMetadata: MessageFns<ReplayOperationMetadata> = {
  encode(message: ReplayOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplayOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayOperationMetadata {
    return { startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined };
  },

  toJSON(message: ReplayOperationMetadata): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReplayOperationMetadata>): ReplayOperationMetadata {
    return ReplayOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplayOperationMetadata>): ReplayOperationMetadata {
    const message = createBaseReplayOperationMetadata();
    message.startTime = object.startTime ?? undefined;
    return message;
  },
};

function createBaseGetReplayRequest(): GetReplayRequest {
  return { name: "" };
}

export const GetReplayRequest: MessageFns<GetReplayRequest> = {
  encode(message: GetReplayRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReplayRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReplayRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReplayRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetReplayRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReplayRequest>): GetReplayRequest {
    return GetReplayRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReplayRequest>): GetReplayRequest {
    const message = createBaseGetReplayRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListReplayResultsRequest(): ListReplayResultsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListReplayResultsRequest: MessageFns<ListReplayResultsRequest> = {
  encode(message: ListReplayResultsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReplayResultsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReplayResultsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReplayResultsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListReplayResultsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReplayResultsRequest>): ListReplayResultsRequest {
    return ListReplayResultsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReplayResultsRequest>): ListReplayResultsRequest {
    const message = createBaseListReplayResultsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListReplayResultsResponse(): ListReplayResultsResponse {
  return { replayResults: [], nextPageToken: "" };
}

export const ListReplayResultsResponse: MessageFns<ListReplayResultsResponse> = {
  encode(message: ListReplayResultsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.replayResults) {
      ReplayResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReplayResultsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReplayResultsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.replayResults.push(ReplayResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReplayResultsResponse {
    return {
      replayResults: globalThis.Array.isArray(object?.replayResults)
        ? object.replayResults.map((e: any) => ReplayResult.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListReplayResultsResponse): unknown {
    const obj: any = {};
    if (message.replayResults?.length) {
      obj.replayResults = message.replayResults.map((e) => ReplayResult.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReplayResultsResponse>): ListReplayResultsResponse {
    return ListReplayResultsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReplayResultsResponse>): ListReplayResultsResponse {
    const message = createBaseListReplayResultsResponse();
    message.replayResults = object.replayResults?.map((e) => ReplayResult.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseReplayConfig(): ReplayConfig {
  return { policyOverlay: {}, logSource: 0 };
}

export const ReplayConfig: MessageFns<ReplayConfig> = {
  encode(message: ReplayConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.policyOverlay).forEach(([key, value]) => {
      ReplayConfig_PolicyOverlayEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.logSource !== 0) {
      writer.uint32(16).int32(message.logSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplayConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = ReplayConfig_PolicyOverlayEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.policyOverlay[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.logSource = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayConfig {
    return {
      policyOverlay: isObject(object.policyOverlay)
        ? Object.entries(object.policyOverlay).reduce<{ [key: string]: Policy }>((acc, [key, value]) => {
          acc[key] = Policy.fromJSON(value);
          return acc;
        }, {})
        : {},
      logSource: isSet(object.logSource) ? replayConfig_LogSourceFromJSON(object.logSource) : 0,
    };
  },

  toJSON(message: ReplayConfig): unknown {
    const obj: any = {};
    if (message.policyOverlay) {
      const entries = Object.entries(message.policyOverlay);
      if (entries.length > 0) {
        obj.policyOverlay = {};
        entries.forEach(([k, v]) => {
          obj.policyOverlay[k] = Policy.toJSON(v);
        });
      }
    }
    if (message.logSource !== 0) {
      obj.logSource = replayConfig_LogSourceToJSON(message.logSource);
    }
    return obj;
  },

  create(base?: DeepPartial<ReplayConfig>): ReplayConfig {
    return ReplayConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplayConfig>): ReplayConfig {
    const message = createBaseReplayConfig();
    message.policyOverlay = Object.entries(object.policyOverlay ?? {}).reduce<{ [key: string]: Policy }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Policy.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.logSource = object.logSource ?? 0;
    return message;
  },
};

function createBaseReplayConfig_PolicyOverlayEntry(): ReplayConfig_PolicyOverlayEntry {
  return { key: "", value: undefined };
}

export const ReplayConfig_PolicyOverlayEntry: MessageFns<ReplayConfig_PolicyOverlayEntry> = {
  encode(message: ReplayConfig_PolicyOverlayEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Policy.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplayConfig_PolicyOverlayEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayConfig_PolicyOverlayEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Policy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayConfig_PolicyOverlayEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Policy.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ReplayConfig_PolicyOverlayEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Policy.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ReplayConfig_PolicyOverlayEntry>): ReplayConfig_PolicyOverlayEntry {
    return ReplayConfig_PolicyOverlayEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplayConfig_PolicyOverlayEntry>): ReplayConfig_PolicyOverlayEntry {
    const message = createBaseReplayConfig_PolicyOverlayEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Policy.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseReplayDiff(): ReplayDiff {
  return { accessDiff: undefined };
}

export const ReplayDiff: MessageFns<ReplayDiff> = {
  encode(message: ReplayDiff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessDiff !== undefined) {
      AccessStateDiff.encode(message.accessDiff, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplayDiff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplayDiff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accessDiff = AccessStateDiff.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplayDiff {
    return { accessDiff: isSet(object.accessDiff) ? AccessStateDiff.fromJSON(object.accessDiff) : undefined };
  },

  toJSON(message: ReplayDiff): unknown {
    const obj: any = {};
    if (message.accessDiff !== undefined) {
      obj.accessDiff = AccessStateDiff.toJSON(message.accessDiff);
    }
    return obj;
  },

  create(base?: DeepPartial<ReplayDiff>): ReplayDiff {
    return ReplayDiff.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplayDiff>): ReplayDiff {
    const message = createBaseReplayDiff();
    message.accessDiff = (object.accessDiff !== undefined && object.accessDiff !== null)
      ? AccessStateDiff.fromPartial(object.accessDiff)
      : undefined;
    return message;
  },
};

function createBaseAccessStateDiff(): AccessStateDiff {
  return { baseline: undefined, simulated: undefined, accessChange: 0 };
}

export const AccessStateDiff: MessageFns<AccessStateDiff> = {
  encode(message: AccessStateDiff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseline !== undefined) {
      ExplainedAccess.encode(message.baseline, writer.uint32(10).fork()).join();
    }
    if (message.simulated !== undefined) {
      ExplainedAccess.encode(message.simulated, writer.uint32(18).fork()).join();
    }
    if (message.accessChange !== 0) {
      writer.uint32(24).int32(message.accessChange);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessStateDiff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessStateDiff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseline = ExplainedAccess.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.simulated = ExplainedAccess.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.accessChange = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessStateDiff {
    return {
      baseline: isSet(object.baseline) ? ExplainedAccess.fromJSON(object.baseline) : undefined,
      simulated: isSet(object.simulated) ? ExplainedAccess.fromJSON(object.simulated) : undefined,
      accessChange: isSet(object.accessChange) ? accessStateDiff_AccessChangeTypeFromJSON(object.accessChange) : 0,
    };
  },

  toJSON(message: AccessStateDiff): unknown {
    const obj: any = {};
    if (message.baseline !== undefined) {
      obj.baseline = ExplainedAccess.toJSON(message.baseline);
    }
    if (message.simulated !== undefined) {
      obj.simulated = ExplainedAccess.toJSON(message.simulated);
    }
    if (message.accessChange !== 0) {
      obj.accessChange = accessStateDiff_AccessChangeTypeToJSON(message.accessChange);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessStateDiff>): AccessStateDiff {
    return AccessStateDiff.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessStateDiff>): AccessStateDiff {
    const message = createBaseAccessStateDiff();
    message.baseline = (object.baseline !== undefined && object.baseline !== null)
      ? ExplainedAccess.fromPartial(object.baseline)
      : undefined;
    message.simulated = (object.simulated !== undefined && object.simulated !== null)
      ? ExplainedAccess.fromPartial(object.simulated)
      : undefined;
    message.accessChange = object.accessChange ?? 0;
    return message;
  },
};

function createBaseExplainedAccess(): ExplainedAccess {
  return { accessState: 0, policies: [], errors: [] };
}

export const ExplainedAccess: MessageFns<ExplainedAccess> = {
  encode(message: ExplainedAccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessState !== 0) {
      writer.uint32(8).int32(message.accessState);
    }
    for (const v of message.policies) {
      ExplainedPolicy.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.errors) {
      Status.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExplainedAccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExplainedAccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.accessState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.policies.push(ExplainedPolicy.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.errors.push(Status.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExplainedAccess {
    return {
      accessState: isSet(object.accessState) ? accessStateFromJSON(object.accessState) : 0,
      policies: globalThis.Array.isArray(object?.policies)
        ? object.policies.map((e: any) => ExplainedPolicy.fromJSON(e))
        : [],
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => Status.fromJSON(e)) : [],
    };
  },

  toJSON(message: ExplainedAccess): unknown {
    const obj: any = {};
    if (message.accessState !== 0) {
      obj.accessState = accessStateToJSON(message.accessState);
    }
    if (message.policies?.length) {
      obj.policies = message.policies.map((e) => ExplainedPolicy.toJSON(e));
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => Status.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExplainedAccess>): ExplainedAccess {
    return ExplainedAccess.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExplainedAccess>): ExplainedAccess {
    const message = createBaseExplainedAccess();
    message.accessState = object.accessState ?? 0;
    message.policies = object.policies?.map((e) => ExplainedPolicy.fromPartial(e)) || [];
    message.errors = object.errors?.map((e) => Status.fromPartial(e)) || [];
    return message;
  },
};

/**
 * Policy Simulator API service.
 *
 * Policy Simulator is a collection of endpoints for creating, running, and
 * viewing a [Replay][google.cloud.policysimulator.v1.Replay]. A
 * [Replay][google.cloud.policysimulator.v1.Replay] is a type of simulation that
 * lets you see how your principals' access to resources might change if you
 * changed your IAM policy.
 *
 * During a [Replay][google.cloud.policysimulator.v1.Replay], Policy Simulator
 * re-evaluates, or replays, past access attempts under both the current policy
 * and  your proposed policy, and compares those results to determine how your
 * principals' access might change under the proposed policy.
 */
export type SimulatorDefinition = typeof SimulatorDefinition;
export const SimulatorDefinition = {
  name: "Simulator",
  fullName: "google.cloud.policysimulator.v1.Simulator",
  methods: {
    /**
     * Gets the specified [Replay][google.cloud.policysimulator.v1.Replay]. Each
     * `Replay` is available for at least 7 days.
     */
    getReplay: {
      name: "GetReplay",
      requestType: GetReplayRequest,
      requestStream: false,
      responseType: Replay,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              143,
              1,
              90,
              44,
              18,
              42,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              108,
              97,
              121,
              115,
              47,
              42,
              125,
              90,
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              108,
              97,
              121,
              115,
              47,
              42,
              125,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              108,
              97,
              121,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates and starts a [Replay][google.cloud.policysimulator.v1.Replay] using
     * the given [ReplayConfig][google.cloud.policysimulator.v1.ReplayConfig].
     */
    createReplay: {
      name: "CreateReplay",
      requestType: CreateReplayRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              6,
              82,
              101,
              112,
              108,
              97,
              121,
              18,
              23,
              82,
              101,
              112,
              108,
              97,
              121,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([13, 112, 97, 114, 101, 110, 116, 44, 114, 101, 112, 108, 97, 121])],
          578365826: [
            Buffer.from([
              167,
              1,
              58,
              6,
              114,
              101,
              112,
              108,
              97,
              121,
              90,
              52,
              58,
              6,
              114,
              101,
              112,
              108,
              97,
              121,
              34,
              42,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              108,
              97,
              121,
              115,
              90,
              58,
              58,
              6,
              114,
              101,
              112,
              108,
              97,
              121,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              108,
              97,
              121,
              115,
              34,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              108,
              97,
              121,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the results of running a
     * [Replay][google.cloud.policysimulator.v1.Replay].
     */
    listReplayResults: {
      name: "ListReplayResults",
      requestType: ListReplayResultsRequest,
      requestStream: false,
      responseType: ListReplayResultsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              173,
              1,
              90,
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              108,
              97,
              121,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              115,
              117,
              108,
              116,
              115,
              90,
              60,
              18,
              58,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              108,
              97,
              121,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              115,
              117,
              108,
              116,
              115,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              108,
              97,
              121,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              115,
              117,
              108,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface SimulatorServiceImplementation<CallContextExt = {}> {
  /**
   * Gets the specified [Replay][google.cloud.policysimulator.v1.Replay]. Each
   * `Replay` is available for at least 7 days.
   */
  getReplay(request: GetReplayRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Replay>>;
  /**
   * Creates and starts a [Replay][google.cloud.policysimulator.v1.Replay] using
   * the given [ReplayConfig][google.cloud.policysimulator.v1.ReplayConfig].
   */
  createReplay(request: CreateReplayRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Lists the results of running a
   * [Replay][google.cloud.policysimulator.v1.Replay].
   */
  listReplayResults(
    request: ListReplayResultsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReplayResultsResponse>>;
}

export interface SimulatorClient<CallOptionsExt = {}> {
  /**
   * Gets the specified [Replay][google.cloud.policysimulator.v1.Replay]. Each
   * `Replay` is available for at least 7 days.
   */
  getReplay(request: DeepPartial<GetReplayRequest>, options?: CallOptions & CallOptionsExt): Promise<Replay>;
  /**
   * Creates and starts a [Replay][google.cloud.policysimulator.v1.Replay] using
   * the given [ReplayConfig][google.cloud.policysimulator.v1.ReplayConfig].
   */
  createReplay(request: DeepPartial<CreateReplayRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Lists the results of running a
   * [Replay][google.cloud.policysimulator.v1.Replay].
   */
  listReplayResults(
    request: DeepPartial<ListReplayResultsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReplayResultsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
