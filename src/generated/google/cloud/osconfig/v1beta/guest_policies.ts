// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/osconfig/v1beta/guest_policies.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.osconfig.v1beta";

/** The desired state that the OS Config agent maintains on the VM instance. */
export enum DesiredState {
  /** DESIRED_STATE_UNSPECIFIED - The default is to ensure the package is installed. */
  DESIRED_STATE_UNSPECIFIED = 0,
  /** INSTALLED - The agent ensures that the package is installed. */
  INSTALLED = 1,
  /**
   * UPDATED - The agent ensures that the package is installed and
   * periodically checks for and install any updates.
   */
  UPDATED = 2,
  /**
   * REMOVED - The agent ensures that the package is not installed and uninstall it
   * if detected.
   */
  REMOVED = 3,
  UNRECOGNIZED = -1,
}

export function desiredStateFromJSON(object: any): DesiredState {
  switch (object) {
    case 0:
    case "DESIRED_STATE_UNSPECIFIED":
      return DesiredState.DESIRED_STATE_UNSPECIFIED;
    case 1:
    case "INSTALLED":
      return DesiredState.INSTALLED;
    case 2:
    case "UPDATED":
      return DesiredState.UPDATED;
    case 3:
    case "REMOVED":
      return DesiredState.REMOVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DesiredState.UNRECOGNIZED;
  }
}

export function desiredStateToJSON(object: DesiredState): string {
  switch (object) {
    case DesiredState.DESIRED_STATE_UNSPECIFIED:
      return "DESIRED_STATE_UNSPECIFIED";
    case DesiredState.INSTALLED:
      return "INSTALLED";
    case DesiredState.UPDATED:
      return "UPDATED";
    case DesiredState.REMOVED:
      return "REMOVED";
    case DesiredState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An OS Config resource representing a guest configuration policy. These
 * policies represent the desired state for VM instance guest environments
 * including packages to install or remove, package repository configurations,
 * and software to install.
 */
export interface GuestPolicy {
  /**
   * Required. Unique name of the resource in this project using one of the following
   * forms:
   * `projects/{project_number}/guestPolicies/{guest_policy_id}`.
   */
  name: string;
  /**
   * Description of the guest policy. Length of the description is limited
   * to 1024 characters.
   */
  description: string;
  /** Output only. Time this guest policy was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last time this guest policy was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Required. Specifies the VM instances that are assigned to this policy. This allows
   * you to target sets or groups of VM instances by different parameters such
   * as labels, names, OS, or zones.
   *
   * If left empty, all VM instances underneath this policy are targeted.
   *
   * At the same level in the resource hierarchy (that is within a project), the
   * service prevents the creation of multiple policies that conflict with
   * each other. For more information, see how the service [handles assignment
   * conflicts](/compute/docs/os-config-management/create-guest-policy#handle-conflicts).
   */
  assignment:
    | Assignment
    | undefined;
  /** The software packages to be managed by this policy. */
  packages: Package[];
  /**
   * A list of package repositories to configure on the VM instance. This is
   * done before any other configs are applied so they can use these repos.
   * Package repositories are only configured if the corresponding package
   * manager(s) are available.
   */
  packageRepositories: PackageRepository[];
  /** A list of Recipes to install on the VM instance. */
  recipes: SoftwareRecipe[];
  /**
   * The etag for this guest policy.
   * If this is provided on update, it must match the server's etag.
   */
  etag: string;
}

/**
 * An assignment represents the group or groups of VM instances that the policy
 * applies to.
 *
 * If an assignment is empty, it applies to all VM instances. Otherwise, the
 * targeted VM instances must meet all the criteria specified. So if both
 * labels and zones are specified, the policy applies to VM instances with those
 * labels and in those zones.
 */
export interface Assignment {
  /**
   * Targets instances matching at least one of these label sets. This allows
   * an assignment to target disparate groups, for example "env=prod or
   * env=staging".
   */
  groupLabels: Assignment_GroupLabel[];
  /**
   * Targets instances in any of these zones. Leave empty to target instances
   * in any zone.
   *
   * Zonal targeting is uncommon and is supported to facilitate the management
   * of changes by zone.
   */
  zones: string[];
  /**
   * Targets any of the instances specified. Instances are specified by their
   * URI in the form `zones/[ZONE]/instances/[INSTANCE_NAME]`.
   *
   * Instance targeting is uncommon and is supported to facilitate the
   * management of changes by the instance or to target specific VM instances
   * for development and testing.
   *
   * Only supported for project-level policies and must reference instances
   * within this project.
   */
  instances: string[];
  /**
   * Targets VM instances whose name starts with one of these prefixes.
   *
   * Like labels, this is another way to group VM instances when targeting
   * configs, for example prefix="prod-".
   *
   * Only supported for project-level policies.
   */
  instanceNamePrefixes: string[];
  /**
   * Targets VM instances matching at least one of the following OS types.
   *
   * VM instances must match all supplied criteria for a given OsType to be
   * included.
   */
  osTypes: Assignment_OsType[];
}

/**
 * Represents a group of VM intances that can be identified as having all
 * these labels, for example "env=prod and app=web".
 */
export interface Assignment_GroupLabel {
  /**
   * Google Compute Engine instance labels that must be present for an
   * instance to be included in this assignment group.
   */
  labels: { [key: string]: string };
}

export interface Assignment_GroupLabel_LabelsEntry {
  key: string;
  value: string;
}

/** Defines the criteria for selecting VM Instances by OS type. */
export interface Assignment_OsType {
  /**
   * Targets VM instances with OS Inventory enabled and having the following
   * OS short name, for example "debian" or "windows".
   */
  osShortName: string;
  /**
   * Targets VM instances with OS Inventory enabled and having the following
   * following OS version.
   */
  osVersion: string;
  /**
   * Targets VM instances with OS Inventory enabled and having the following
   * OS architecture.
   */
  osArchitecture: string;
}

/**
 * Package is a reference to the software package to be installed or removed.
 * The agent on the VM instance uses the system package manager to apply the
 * config.
 *
 * These are the commands that the agent uses to install or remove
 * packages.
 *
 * Apt
 * install: `apt-get update && apt-get -y install package1 package2 package3`
 * remove: `apt-get -y remove package1 package2 package3`
 *
 * Yum
 * install: `yum -y install package1 package2 package3`
 * remove: `yum -y remove package1 package2 package3`
 *
 * Zypper
 * install: `zypper install package1 package2 package3`
 * remove: `zypper rm package1 package2`
 *
 * Googet
 * install: `googet -noconfirm install package1 package2 package3`
 * remove: `googet -noconfirm remove package1 package2 package3`
 */
export interface Package {
  /**
   * Required. The name of the package. A package is uniquely identified for conflict
   * validation by checking the package name and the manager(s) that the
   * package targets.
   */
  name: string;
  /**
   * The desired_state the agent should maintain for this package. The
   * default is to ensure the package is installed.
   */
  desiredState: DesiredState;
  /**
   * Type of package manager that can be used to install this package.
   * If a system does not have the package manager, the package is not
   * installed or removed no error message is returned. By default,
   * or if you specify `ANY`,
   * the agent attempts to install and remove this package using the default
   * package manager. This is useful when creating a policy that applies to
   * different types of systems.
   *
   * The default behavior is ANY.
   */
  manager: Package_Manager;
}

/** Types of package managers that may be used to manage this package. */
export enum Package_Manager {
  /** MANAGER_UNSPECIFIED - The default behavior is ANY. */
  MANAGER_UNSPECIFIED = 0,
  /** ANY - Apply this package config using the default system package manager. */
  ANY = 1,
  /** APT - Apply this package config only if Apt is available on the system. */
  APT = 2,
  /** YUM - Apply this package config only if Yum is available on the system. */
  YUM = 3,
  /** ZYPPER - Apply this package config only if Zypper is available on the system. */
  ZYPPER = 4,
  /** GOO - Apply this package config only if GooGet is available on the system. */
  GOO = 5,
  UNRECOGNIZED = -1,
}

export function package_ManagerFromJSON(object: any): Package_Manager {
  switch (object) {
    case 0:
    case "MANAGER_UNSPECIFIED":
      return Package_Manager.MANAGER_UNSPECIFIED;
    case 1:
    case "ANY":
      return Package_Manager.ANY;
    case 2:
    case "APT":
      return Package_Manager.APT;
    case 3:
    case "YUM":
      return Package_Manager.YUM;
    case 4:
    case "ZYPPER":
      return Package_Manager.ZYPPER;
    case 5:
    case "GOO":
      return Package_Manager.GOO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Package_Manager.UNRECOGNIZED;
  }
}

export function package_ManagerToJSON(object: Package_Manager): string {
  switch (object) {
    case Package_Manager.MANAGER_UNSPECIFIED:
      return "MANAGER_UNSPECIFIED";
    case Package_Manager.ANY:
      return "ANY";
    case Package_Manager.APT:
      return "APT";
    case Package_Manager.YUM:
      return "YUM";
    case Package_Manager.ZYPPER:
      return "ZYPPER";
    case Package_Manager.GOO:
      return "GOO";
    case Package_Manager.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents a single Apt package repository. This repository is added to
 * a repo file that is stored at
 * `/etc/apt/sources.list.d/google_osconfig.list`.
 */
export interface AptRepository {
  /** Type of archive files in this repository. The default behavior is DEB. */
  archiveType: AptRepository_ArchiveType;
  /** Required. URI for this repository. */
  uri: string;
  /** Required. Distribution of this repository. */
  distribution: string;
  /** Required. List of components for this repository. Must contain at least one item. */
  components: string[];
  /**
   * URI of the key file for this repository. The agent maintains
   * a keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg` containing
   * all the keys in any applied guest policy.
   */
  gpgKey: string;
}

/** Type of archive. */
export enum AptRepository_ArchiveType {
  /** ARCHIVE_TYPE_UNSPECIFIED - Unspecified. */
  ARCHIVE_TYPE_UNSPECIFIED = 0,
  /** DEB - DEB indicates that the archive contains binary files. */
  DEB = 1,
  /** DEB_SRC - DEB_SRC indicates that the archive contains source files. */
  DEB_SRC = 2,
  UNRECOGNIZED = -1,
}

export function aptRepository_ArchiveTypeFromJSON(object: any): AptRepository_ArchiveType {
  switch (object) {
    case 0:
    case "ARCHIVE_TYPE_UNSPECIFIED":
      return AptRepository_ArchiveType.ARCHIVE_TYPE_UNSPECIFIED;
    case 1:
    case "DEB":
      return AptRepository_ArchiveType.DEB;
    case 2:
    case "DEB_SRC":
      return AptRepository_ArchiveType.DEB_SRC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AptRepository_ArchiveType.UNRECOGNIZED;
  }
}

export function aptRepository_ArchiveTypeToJSON(object: AptRepository_ArchiveType): string {
  switch (object) {
    case AptRepository_ArchiveType.ARCHIVE_TYPE_UNSPECIFIED:
      return "ARCHIVE_TYPE_UNSPECIFIED";
    case AptRepository_ArchiveType.DEB:
      return "DEB";
    case AptRepository_ArchiveType.DEB_SRC:
      return "DEB_SRC";
    case AptRepository_ArchiveType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents a single Yum package repository. This repository is added to a
 * repo file that is stored at `/etc/yum.repos.d/google_osconfig.repo`.
 */
export interface YumRepository {
  /**
   * Required. A one word, unique name for this repository. This is
   * the `repo id` in the Yum config file and also the `display_name` if
   * `display_name` is omitted. This id is also used as the unique identifier
   * when checking for guest policy conflicts.
   */
  id: string;
  /** The display name of the repository. */
  displayName: string;
  /** Required. The location of the repository directory. */
  baseUrl: string;
  /** URIs of GPG keys. */
  gpgKeys: string[];
}

/**
 * Represents a single Zypper package repository. This repository is added to a
 * repo file that is stored at `/etc/zypp/repos.d/google_osconfig.repo`.
 */
export interface ZypperRepository {
  /**
   * Required. A one word, unique name for this repository. This is
   * the `repo id` in the zypper config file and also the `display_name` if
   * `display_name` is omitted. This id is also used as the unique identifier
   * when checking for guest policy conflicts.
   */
  id: string;
  /** The display name of the repository. */
  displayName: string;
  /** Required. The location of the repository directory. */
  baseUrl: string;
  /** URIs of GPG keys. */
  gpgKeys: string[];
}

/**
 * Represents a Goo package repository. These is added to a repo file
 * that is stored at C:/ProgramData/GooGet/repos/google_osconfig.repo.
 */
export interface GooRepository {
  /** Required. The name of the repository. */
  name: string;
  /** Required. The url of the repository. */
  url: string;
}

/** A package repository. */
export interface PackageRepository {
  /** An Apt Repository. */
  apt?:
    | AptRepository
    | undefined;
  /** A Yum Repository. */
  yum?:
    | YumRepository
    | undefined;
  /** A Zypper Repository. */
  zypper?:
    | ZypperRepository
    | undefined;
  /** A Goo Repository. */
  goo?: GooRepository | undefined;
}

/**
 * A software recipe is a set of instructions for installing and configuring a
 * piece of software. It consists of a set of artifacts that are
 * downloaded, and a set of steps that install, configure, and/or update the
 * software.
 *
 * Recipes support installing and updating software from artifacts in the
 * following formats:
 * Zip archive, Tar archive, Windows MSI, Debian package, and RPM package.
 *
 * Additionally, recipes support executing a script (either defined in a file or
 * directly in this api) in bash, sh, cmd, and powershell.
 *
 * Updating a software recipe
 *
 * If a recipe is assigned to an instance and there is a recipe with the same
 * name but a lower version already installed and the assigned state
 * of the recipe is `UPDATED`, then the recipe is updated to
 * the new version.
 *
 * Script Working Directories
 *
 * Each script or execution step is run in its own temporary directory which
 * is deleted after completing the step.
 */
export interface SoftwareRecipe {
  /**
   * Required. Unique identifier for the recipe. Only one recipe with a given name is
   * installed on an instance.
   *
   * Names are also used to identify resources which helps to determine whether
   * guest policies have conflicts. This means that requests to create multiple
   * recipes with the same name and version are rejected since they
   * could potentially have conflicting assignments.
   */
  name: string;
  /**
   * The version of this software recipe. Version can be up to 4 period
   * separated numbers (e.g. 12.34.56.78).
   */
  version: string;
  /** Resources available to be used in the steps in the recipe. */
  artifacts: SoftwareRecipe_Artifact[];
  /**
   * Actions to be taken for installing this recipe. On failure it stops
   * executing steps and does not attempt another installation. Any steps taken
   * (including partially completed steps) are not rolled back.
   */
  installSteps: SoftwareRecipe_Step[];
  /**
   * Actions to be taken for updating this recipe. On failure it stops
   * executing steps and  does not attempt another update for this recipe. Any
   * steps taken (including partially completed steps) are not rolled back.
   */
  updateSteps: SoftwareRecipe_Step[];
  /**
   * Default is INSTALLED. The desired state the agent should maintain for this
   * recipe.
   *
   * INSTALLED: The software recipe is installed on the instance but
   *            won't be updated to new versions.
   * UPDATED: The software recipe is installed on the instance. The recipe is
   *          updated to a higher version, if a higher version of the recipe is
   *          assigned to this instance.
   * REMOVE: Remove is unsupported for software recipes and attempts to
   *         create or update a recipe to the REMOVE state is rejected.
   */
  desiredState: DesiredState;
}

/** Specifies a resource to be used in the recipe. */
export interface SoftwareRecipe_Artifact {
  /**
   * Required. Id of the artifact, which the installation and update steps of this
   * recipe can reference. Artifacts in a recipe cannot have the same id.
   */
  id: string;
  /** A generic remote artifact. */
  remote?:
    | SoftwareRecipe_Artifact_Remote
    | undefined;
  /** A Google Cloud Storage artifact. */
  gcs?:
    | SoftwareRecipe_Artifact_Gcs
    | undefined;
  /**
   * Defaults to false. When false, recipes are subject to validations
   * based on the artifact type:
   *
   * Remote: A checksum must be specified, and only protocols with
   * transport-layer security are permitted.
   * GCS:    An object generation number must be specified.
   */
  allowInsecure: boolean;
}

/** Specifies an artifact available via some URI. */
export interface SoftwareRecipe_Artifact_Remote {
  /**
   * URI from which to fetch the object. It should contain both the protocol
   * and path following the format {protocol}://{location}.
   */
  uri: string;
  /**
   * Must be provided if `allow_insecure` is `false`.
   * SHA256 checksum in hex format, to compare to the checksum of the
   * artifact. If the checksum is not empty and it doesn't match the
   * artifact then the recipe installation fails before running any of the
   * steps.
   */
  checksum: string;
}

/** Specifies an artifact available as a Google Cloud Storage object. */
export interface SoftwareRecipe_Artifact_Gcs {
  /**
   * Bucket of the Google Cloud Storage object.
   * Given an example URL:
   * `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
   * this value would be `my-bucket`.
   */
  bucket: string;
  /**
   * Name of the Google Cloud Storage object.
   * As specified [here]
   * (https://cloud.google.com/storage/docs/naming#objectnames)
   * Given an example URL:
   * `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
   * this value would be `foo/bar`.
   */
  object: string;
  /**
   * Must be provided if allow_insecure is false.
   * Generation number of the Google Cloud Storage object.
   * `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
   * this value would be `1234567`.
   */
  generation: Long;
}

/** An action that can be taken as part of installing or updating a recipe. */
export interface SoftwareRecipe_Step {
  /** Copies a file onto the instance. */
  fileCopy?:
    | SoftwareRecipe_Step_CopyFile
    | undefined;
  /** Extracts an archive into the specified directory. */
  archiveExtraction?:
    | SoftwareRecipe_Step_ExtractArchive
    | undefined;
  /** Installs an MSI file. */
  msiInstallation?:
    | SoftwareRecipe_Step_InstallMsi
    | undefined;
  /** Installs a deb file via dpkg. */
  dpkgInstallation?:
    | SoftwareRecipe_Step_InstallDpkg
    | undefined;
  /** Installs an rpm file via the rpm utility. */
  rpmInstallation?:
    | SoftwareRecipe_Step_InstallRpm
    | undefined;
  /** Executes an artifact or local file. */
  fileExec?:
    | SoftwareRecipe_Step_ExecFile
    | undefined;
  /** Runs commands in a shell. */
  scriptRun?: SoftwareRecipe_Step_RunScript | undefined;
}

/** Copies the artifact to the specified path on the instance. */
export interface SoftwareRecipe_Step_CopyFile {
  /** Required. The id of the relevant artifact in the recipe. */
  artifactId: string;
  /** Required. The absolute path on the instance to put the file. */
  destination: string;
  /**
   * Whether to allow this step to overwrite existing files. If this is
   * false and the file already exists the file is not overwritten
   * and the step is considered a success. Defaults to false.
   */
  overwrite: boolean;
  /**
   * Consists of three octal digits which represent, in
   * order, the permissions of the owner, group, and other users for the
   * file (similarly to the numeric mode used in the linux chmod utility).
   * Each digit represents a three bit number with the 4 bit
   * corresponding to the read permissions, the 2 bit corresponds to the
   * write bit, and the one bit corresponds to the execute permission.
   * Default behavior is 755.
   *
   * Below are some examples of permissions and their associated values:
   * read, write, and execute: 7
   * read and execute: 5
   * read and write: 6
   * read only: 4
   */
  permissions: string;
}

/** Extracts an archive of the type specified in the specified directory. */
export interface SoftwareRecipe_Step_ExtractArchive {
  /** Required. The id of the relevant artifact in the recipe. */
  artifactId: string;
  /**
   * Directory to extract archive to.
   * Defaults to `/` on Linux or `C:\` on Windows.
   */
  destination: string;
  /** Required. The type of the archive to extract. */
  type: SoftwareRecipe_Step_ExtractArchive_ArchiveType;
}

/** Specifying the type of archive. */
export enum SoftwareRecipe_Step_ExtractArchive_ArchiveType {
  /** ARCHIVE_TYPE_UNSPECIFIED - Indicates that the archive type isn't specified. */
  ARCHIVE_TYPE_UNSPECIFIED = 0,
  /** TAR - Indicates that the archive is a tar archive with no encryption. */
  TAR = 1,
  /** TAR_GZIP - Indicates that the archive is a tar archive with gzip encryption. */
  TAR_GZIP = 2,
  /** TAR_BZIP - Indicates that the archive is a tar archive with bzip encryption. */
  TAR_BZIP = 3,
  /** TAR_LZMA - Indicates that the archive is a tar archive with lzma encryption. */
  TAR_LZMA = 4,
  /** TAR_XZ - Indicates that the archive is a tar archive with xz encryption. */
  TAR_XZ = 5,
  /** ZIP - Indicates that the archive is a zip archive. */
  ZIP = 11,
  UNRECOGNIZED = -1,
}

export function softwareRecipe_Step_ExtractArchive_ArchiveTypeFromJSON(
  object: any,
): SoftwareRecipe_Step_ExtractArchive_ArchiveType {
  switch (object) {
    case 0:
    case "ARCHIVE_TYPE_UNSPECIFIED":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.ARCHIVE_TYPE_UNSPECIFIED;
    case 1:
    case "TAR":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR;
    case 2:
    case "TAR_GZIP":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_GZIP;
    case 3:
    case "TAR_BZIP":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_BZIP;
    case 4:
    case "TAR_LZMA":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_LZMA;
    case 5:
    case "TAR_XZ":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_XZ;
    case 11:
    case "ZIP":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.ZIP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.UNRECOGNIZED;
  }
}

export function softwareRecipe_Step_ExtractArchive_ArchiveTypeToJSON(
  object: SoftwareRecipe_Step_ExtractArchive_ArchiveType,
): string {
  switch (object) {
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.ARCHIVE_TYPE_UNSPECIFIED:
      return "ARCHIVE_TYPE_UNSPECIFIED";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR:
      return "TAR";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_GZIP:
      return "TAR_GZIP";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_BZIP:
      return "TAR_BZIP";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_LZMA:
      return "TAR_LZMA";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_XZ:
      return "TAR_XZ";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.ZIP:
      return "ZIP";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Installs an MSI file. */
export interface SoftwareRecipe_Step_InstallMsi {
  /** Required. The id of the relevant artifact in the recipe. */
  artifactId: string;
  /**
   * The flags to use when installing the MSI
   * defaults to ["/i"] (i.e. the install flag).
   */
  flags: string[];
  /**
   * Return codes that indicate that the software installed or updated
   * successfully. Behaviour defaults to [0]
   */
  allowedExitCodes: number[];
}

/** Installs a deb via dpkg. */
export interface SoftwareRecipe_Step_InstallDpkg {
  /** Required. The id of the relevant artifact in the recipe. */
  artifactId: string;
}

/** Installs an rpm file via the rpm utility. */
export interface SoftwareRecipe_Step_InstallRpm {
  /** Required. The id of the relevant artifact in the recipe. */
  artifactId: string;
}

/** Executes an artifact or local file. */
export interface SoftwareRecipe_Step_ExecFile {
  /** The id of the relevant artifact in the recipe. */
  artifactId?:
    | string
    | undefined;
  /** The absolute path of the file on the local filesystem. */
  localPath?:
    | string
    | undefined;
  /** Arguments to be passed to the provided executable. */
  args: string[];
  /**
   * Defaults to [0]. A list of possible return values that the program
   * can return to indicate a success.
   */
  allowedExitCodes: number[];
}

/** Runs a script through an interpreter. */
export interface SoftwareRecipe_Step_RunScript {
  /** Required. The shell script to be executed. */
  script: string;
  /**
   * Return codes that indicate that the software installed or updated
   * successfully. Behaviour defaults to [0]
   */
  allowedExitCodes: number[];
  /**
   * The script interpreter to use to run the script. If no interpreter is
   * specified the script is executed directly, which likely
   * only succeed for scripts with
   * [shebang lines](https://en.wikipedia.org/wiki/Shebang_\(Unix\)).
   */
  interpreter: SoftwareRecipe_Step_RunScript_Interpreter;
}

/** The interpreter used to execute a script. */
export enum SoftwareRecipe_Step_RunScript_Interpreter {
  /** INTERPRETER_UNSPECIFIED - Default value for ScriptType. */
  INTERPRETER_UNSPECIFIED = 0,
  /**
   * SHELL - Indicates that the script is run with `/bin/sh` on Linux and `cmd`
   * on windows.
   */
  SHELL = 1,
  /** POWERSHELL - Indicates that the script is run with powershell. */
  POWERSHELL = 3,
  UNRECOGNIZED = -1,
}

export function softwareRecipe_Step_RunScript_InterpreterFromJSON(
  object: any,
): SoftwareRecipe_Step_RunScript_Interpreter {
  switch (object) {
    case 0:
    case "INTERPRETER_UNSPECIFIED":
      return SoftwareRecipe_Step_RunScript_Interpreter.INTERPRETER_UNSPECIFIED;
    case 1:
    case "SHELL":
      return SoftwareRecipe_Step_RunScript_Interpreter.SHELL;
    case 3:
    case "POWERSHELL":
      return SoftwareRecipe_Step_RunScript_Interpreter.POWERSHELL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SoftwareRecipe_Step_RunScript_Interpreter.UNRECOGNIZED;
  }
}

export function softwareRecipe_Step_RunScript_InterpreterToJSON(
  object: SoftwareRecipe_Step_RunScript_Interpreter,
): string {
  switch (object) {
    case SoftwareRecipe_Step_RunScript_Interpreter.INTERPRETER_UNSPECIFIED:
      return "INTERPRETER_UNSPECIFIED";
    case SoftwareRecipe_Step_RunScript_Interpreter.SHELL:
      return "SHELL";
    case SoftwareRecipe_Step_RunScript_Interpreter.POWERSHELL:
      return "POWERSHELL";
    case SoftwareRecipe_Step_RunScript_Interpreter.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A request message for creating a guest policy. */
export interface CreateGuestPolicyRequest {
  /**
   * Required. The resource name of the parent using one of the following forms:
   * `projects/{project_number}`.
   */
  parent: string;
  /**
   * Required. The logical name of the guest policy in the project
   * with the following restrictions:
   *
   * * Must contain only lowercase letters, numbers, and hyphens.
   * * Must start with a letter.
   * * Must be between 1-63 characters.
   * * Must end with a number or a letter.
   * * Must be unique within the project.
   */
  guestPolicyId: string;
  /** Required. The GuestPolicy to create. */
  guestPolicy: GuestPolicy | undefined;
}

/** A request message for retrieving a guest policy. */
export interface GetGuestPolicyRequest {
  /**
   * Required. The resource name of the guest policy using one of the following forms:
   * `projects/{project_number}/guestPolicies/{guest_policy_id}`.
   */
  name: string;
}

/** A request message for listing guest policies. */
export interface ListGuestPoliciesRequest {
  /**
   * Required. The resource name of the parent using one of the following forms:
   * `projects/{project_number}`.
   */
  parent: string;
  /** The maximum number of guest policies to return. */
  pageSize: number;
  /**
   * A pagination token returned from a previous call to `ListGuestPolicies`
   * that indicates where this listing should continue from.
   */
  pageToken: string;
}

/** A response message for listing guest policies. */
export interface ListGuestPoliciesResponse {
  /** The list of GuestPolicies. */
  guestPolicies: GuestPolicy[];
  /**
   * A pagination token that can be used to get the next page
   * of guest policies.
   */
  nextPageToken: string;
}

/** A request message for updating a guest policy. */
export interface UpdateGuestPolicyRequest {
  /** Required. The updated GuestPolicy. */
  guestPolicy:
    | GuestPolicy
    | undefined;
  /**
   * Field mask that controls which fields of the guest policy should be
   * updated.
   */
  updateMask: string[] | undefined;
}

/** A request message for deleting a guest policy. */
export interface DeleteGuestPolicyRequest {
  /**
   * Required. The resource name of the guest policy  using one of the following forms:
   * `projects/{project_number}/guestPolicies/{guest_policy_id}`.
   */
  name: string;
}

/**
 * A request message for getting the effective guest policy assigned to the
 * instance.
 */
export interface LookupEffectiveGuestPolicyRequest {
  /** Required. The VM instance whose policies are being looked up. */
  instance: string;
  /**
   * Short name of the OS running on the instance. The OS Config agent only
   * provides this field for targeting if OS Inventory is enabled for that
   * instance.
   */
  osShortName: string;
  /**
   * Version of the OS running on the instance. The OS Config agent only
   * provides this field for targeting if OS Inventory is enabled for that
   * VM instance.
   */
  osVersion: string;
  /**
   * Architecture of OS running on the instance. The OS Config agent only
   * provides this field for targeting if OS Inventory is enabled for that
   * instance.
   */
  osArchitecture: string;
}

/** The effective guest policy that applies to a VM instance. */
export interface EffectiveGuestPolicy {
  /** List of package configurations assigned to the VM instance. */
  packages: EffectiveGuestPolicy_SourcedPackage[];
  /** List of package repository configurations assigned to the VM instance. */
  packageRepositories: EffectiveGuestPolicy_SourcedPackageRepository[];
  /** List of recipes assigned to the VM instance. */
  softwareRecipes: EffectiveGuestPolicy_SourcedSoftwareRecipe[];
}

/** A guest policy package including its source. */
export interface EffectiveGuestPolicy_SourcedPackage {
  /** Name of the guest policy providing this config. */
  source: string;
  /** A software package to configure on the VM instance. */
  package: Package | undefined;
}

/** A guest policy package repository including its source. */
export interface EffectiveGuestPolicy_SourcedPackageRepository {
  /** Name of the guest policy providing this config. */
  source: string;
  /** A software package repository to configure on the VM instance. */
  packageRepository: PackageRepository | undefined;
}

/** A guest policy recipe including its source. */
export interface EffectiveGuestPolicy_SourcedSoftwareRecipe {
  /** Name of the guest policy providing this config. */
  source: string;
  /** A software recipe to configure on the VM instance. */
  softwareRecipe: SoftwareRecipe | undefined;
}

function createBaseGuestPolicy(): GuestPolicy {
  return {
    name: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    assignment: undefined,
    packages: [],
    packageRepositories: [],
    recipes: [],
    etag: "",
  };
}

export const GuestPolicy: MessageFns<GuestPolicy> = {
  encode(message: GuestPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.assignment !== undefined) {
      Assignment.encode(message.assignment, writer.uint32(50).fork()).join();
    }
    for (const v of message.packages) {
      Package.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.packageRepositories) {
      PackageRepository.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.recipes) {
      SoftwareRecipe.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(82).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.assignment = Assignment.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.packages.push(Package.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.packageRepositories.push(PackageRepository.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.recipes.push(SoftwareRecipe.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestPolicy {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      assignment: isSet(object.assignment) ? Assignment.fromJSON(object.assignment) : undefined,
      packages: globalThis.Array.isArray(object?.packages) ? object.packages.map((e: any) => Package.fromJSON(e)) : [],
      packageRepositories: globalThis.Array.isArray(object?.packageRepositories)
        ? object.packageRepositories.map((e: any) => PackageRepository.fromJSON(e))
        : [],
      recipes: globalThis.Array.isArray(object?.recipes)
        ? object.recipes.map((e: any) => SoftwareRecipe.fromJSON(e))
        : [],
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: GuestPolicy): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.assignment !== undefined) {
      obj.assignment = Assignment.toJSON(message.assignment);
    }
    if (message.packages?.length) {
      obj.packages = message.packages.map((e) => Package.toJSON(e));
    }
    if (message.packageRepositories?.length) {
      obj.packageRepositories = message.packageRepositories.map((e) => PackageRepository.toJSON(e));
    }
    if (message.recipes?.length) {
      obj.recipes = message.recipes.map((e) => SoftwareRecipe.toJSON(e));
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<GuestPolicy>): GuestPolicy {
    return GuestPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestPolicy>): GuestPolicy {
    const message = createBaseGuestPolicy();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.assignment = (object.assignment !== undefined && object.assignment !== null)
      ? Assignment.fromPartial(object.assignment)
      : undefined;
    message.packages = object.packages?.map((e) => Package.fromPartial(e)) || [];
    message.packageRepositories = object.packageRepositories?.map((e) => PackageRepository.fromPartial(e)) || [];
    message.recipes = object.recipes?.map((e) => SoftwareRecipe.fromPartial(e)) || [];
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseAssignment(): Assignment {
  return { groupLabels: [], zones: [], instances: [], instanceNamePrefixes: [], osTypes: [] };
}

export const Assignment: MessageFns<Assignment> = {
  encode(message: Assignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.groupLabels) {
      Assignment_GroupLabel.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.zones) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.instances) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.instanceNamePrefixes) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.osTypes) {
      Assignment_OsType.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Assignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groupLabels.push(Assignment_GroupLabel.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zones.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instances.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instanceNamePrefixes.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.osTypes.push(Assignment_OsType.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Assignment {
    return {
      groupLabels: globalThis.Array.isArray(object?.groupLabels)
        ? object.groupLabels.map((e: any) => Assignment_GroupLabel.fromJSON(e))
        : [],
      zones: globalThis.Array.isArray(object?.zones) ? object.zones.map((e: any) => globalThis.String(e)) : [],
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => globalThis.String(e))
        : [],
      instanceNamePrefixes: globalThis.Array.isArray(object?.instanceNamePrefixes)
        ? object.instanceNamePrefixes.map((e: any) => globalThis.String(e))
        : [],
      osTypes: globalThis.Array.isArray(object?.osTypes)
        ? object.osTypes.map((e: any) => Assignment_OsType.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Assignment): unknown {
    const obj: any = {};
    if (message.groupLabels?.length) {
      obj.groupLabels = message.groupLabels.map((e) => Assignment_GroupLabel.toJSON(e));
    }
    if (message.zones?.length) {
      obj.zones = message.zones;
    }
    if (message.instances?.length) {
      obj.instances = message.instances;
    }
    if (message.instanceNamePrefixes?.length) {
      obj.instanceNamePrefixes = message.instanceNamePrefixes;
    }
    if (message.osTypes?.length) {
      obj.osTypes = message.osTypes.map((e) => Assignment_OsType.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Assignment>): Assignment {
    return Assignment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Assignment>): Assignment {
    const message = createBaseAssignment();
    message.groupLabels = object.groupLabels?.map((e) => Assignment_GroupLabel.fromPartial(e)) || [];
    message.zones = object.zones?.map((e) => e) || [];
    message.instances = object.instances?.map((e) => e) || [];
    message.instanceNamePrefixes = object.instanceNamePrefixes?.map((e) => e) || [];
    message.osTypes = object.osTypes?.map((e) => Assignment_OsType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAssignment_GroupLabel(): Assignment_GroupLabel {
  return { labels: {} };
}

export const Assignment_GroupLabel: MessageFns<Assignment_GroupLabel> = {
  encode(message: Assignment_GroupLabel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.labels).forEach(([key, value]) => {
      Assignment_GroupLabel_LabelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Assignment_GroupLabel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignment_GroupLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Assignment_GroupLabel_LabelsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.labels[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Assignment_GroupLabel {
    return {
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Assignment_GroupLabel): unknown {
    const obj: any = {};
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Assignment_GroupLabel>): Assignment_GroupLabel {
    return Assignment_GroupLabel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Assignment_GroupLabel>): Assignment_GroupLabel {
    const message = createBaseAssignment_GroupLabel();
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAssignment_GroupLabel_LabelsEntry(): Assignment_GroupLabel_LabelsEntry {
  return { key: "", value: "" };
}

export const Assignment_GroupLabel_LabelsEntry: MessageFns<Assignment_GroupLabel_LabelsEntry> = {
  encode(message: Assignment_GroupLabel_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Assignment_GroupLabel_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignment_GroupLabel_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Assignment_GroupLabel_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Assignment_GroupLabel_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Assignment_GroupLabel_LabelsEntry>): Assignment_GroupLabel_LabelsEntry {
    return Assignment_GroupLabel_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Assignment_GroupLabel_LabelsEntry>): Assignment_GroupLabel_LabelsEntry {
    const message = createBaseAssignment_GroupLabel_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAssignment_OsType(): Assignment_OsType {
  return { osShortName: "", osVersion: "", osArchitecture: "" };
}

export const Assignment_OsType: MessageFns<Assignment_OsType> = {
  encode(message: Assignment_OsType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.osShortName !== "") {
      writer.uint32(10).string(message.osShortName);
    }
    if (message.osVersion !== "") {
      writer.uint32(18).string(message.osVersion);
    }
    if (message.osArchitecture !== "") {
      writer.uint32(26).string(message.osArchitecture);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Assignment_OsType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignment_OsType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.osShortName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.osVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.osArchitecture = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Assignment_OsType {
    return {
      osShortName: isSet(object.osShortName) ? globalThis.String(object.osShortName) : "",
      osVersion: isSet(object.osVersion) ? globalThis.String(object.osVersion) : "",
      osArchitecture: isSet(object.osArchitecture) ? globalThis.String(object.osArchitecture) : "",
    };
  },

  toJSON(message: Assignment_OsType): unknown {
    const obj: any = {};
    if (message.osShortName !== "") {
      obj.osShortName = message.osShortName;
    }
    if (message.osVersion !== "") {
      obj.osVersion = message.osVersion;
    }
    if (message.osArchitecture !== "") {
      obj.osArchitecture = message.osArchitecture;
    }
    return obj;
  },

  create(base?: DeepPartial<Assignment_OsType>): Assignment_OsType {
    return Assignment_OsType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Assignment_OsType>): Assignment_OsType {
    const message = createBaseAssignment_OsType();
    message.osShortName = object.osShortName ?? "";
    message.osVersion = object.osVersion ?? "";
    message.osArchitecture = object.osArchitecture ?? "";
    return message;
  },
};

function createBasePackage(): Package {
  return { name: "", desiredState: 0, manager: 0 };
}

export const Package: MessageFns<Package> = {
  encode(message: Package, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.desiredState !== 0) {
      writer.uint32(16).int32(message.desiredState);
    }
    if (message.manager !== 0) {
      writer.uint32(24).int32(message.manager);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Package {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.desiredState = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.manager = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Package {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desiredState: isSet(object.desiredState) ? desiredStateFromJSON(object.desiredState) : 0,
      manager: isSet(object.manager) ? package_ManagerFromJSON(object.manager) : 0,
    };
  },

  toJSON(message: Package): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desiredState !== 0) {
      obj.desiredState = desiredStateToJSON(message.desiredState);
    }
    if (message.manager !== 0) {
      obj.manager = package_ManagerToJSON(message.manager);
    }
    return obj;
  },

  create(base?: DeepPartial<Package>): Package {
    return Package.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Package>): Package {
    const message = createBasePackage();
    message.name = object.name ?? "";
    message.desiredState = object.desiredState ?? 0;
    message.manager = object.manager ?? 0;
    return message;
  },
};

function createBaseAptRepository(): AptRepository {
  return { archiveType: 0, uri: "", distribution: "", components: [], gpgKey: "" };
}

export const AptRepository: MessageFns<AptRepository> = {
  encode(message: AptRepository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.archiveType !== 0) {
      writer.uint32(8).int32(message.archiveType);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.distribution !== "") {
      writer.uint32(26).string(message.distribution);
    }
    for (const v of message.components) {
      writer.uint32(34).string(v!);
    }
    if (message.gpgKey !== "") {
      writer.uint32(42).string(message.gpgKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AptRepository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAptRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.archiveType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.distribution = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.components.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gpgKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AptRepository {
    return {
      archiveType: isSet(object.archiveType) ? aptRepository_ArchiveTypeFromJSON(object.archiveType) : 0,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      distribution: isSet(object.distribution) ? globalThis.String(object.distribution) : "",
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => globalThis.String(e))
        : [],
      gpgKey: isSet(object.gpgKey) ? globalThis.String(object.gpgKey) : "",
    };
  },

  toJSON(message: AptRepository): unknown {
    const obj: any = {};
    if (message.archiveType !== 0) {
      obj.archiveType = aptRepository_ArchiveTypeToJSON(message.archiveType);
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.distribution !== "") {
      obj.distribution = message.distribution;
    }
    if (message.components?.length) {
      obj.components = message.components;
    }
    if (message.gpgKey !== "") {
      obj.gpgKey = message.gpgKey;
    }
    return obj;
  },

  create(base?: DeepPartial<AptRepository>): AptRepository {
    return AptRepository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AptRepository>): AptRepository {
    const message = createBaseAptRepository();
    message.archiveType = object.archiveType ?? 0;
    message.uri = object.uri ?? "";
    message.distribution = object.distribution ?? "";
    message.components = object.components?.map((e) => e) || [];
    message.gpgKey = object.gpgKey ?? "";
    return message;
  },
};

function createBaseYumRepository(): YumRepository {
  return { id: "", displayName: "", baseUrl: "", gpgKeys: [] };
}

export const YumRepository: MessageFns<YumRepository> = {
  encode(message: YumRepository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.baseUrl !== "") {
      writer.uint32(26).string(message.baseUrl);
    }
    for (const v of message.gpgKeys) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YumRepository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYumRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gpgKeys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YumRepository {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      gpgKeys: globalThis.Array.isArray(object?.gpgKeys) ? object.gpgKeys.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: YumRepository): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.gpgKeys?.length) {
      obj.gpgKeys = message.gpgKeys;
    }
    return obj;
  },

  create(base?: DeepPartial<YumRepository>): YumRepository {
    return YumRepository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<YumRepository>): YumRepository {
    const message = createBaseYumRepository();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.baseUrl = object.baseUrl ?? "";
    message.gpgKeys = object.gpgKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseZypperRepository(): ZypperRepository {
  return { id: "", displayName: "", baseUrl: "", gpgKeys: [] };
}

export const ZypperRepository: MessageFns<ZypperRepository> = {
  encode(message: ZypperRepository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.baseUrl !== "") {
      writer.uint32(26).string(message.baseUrl);
    }
    for (const v of message.gpgKeys) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZypperRepository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZypperRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gpgKeys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZypperRepository {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      gpgKeys: globalThis.Array.isArray(object?.gpgKeys) ? object.gpgKeys.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ZypperRepository): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.gpgKeys?.length) {
      obj.gpgKeys = message.gpgKeys;
    }
    return obj;
  },

  create(base?: DeepPartial<ZypperRepository>): ZypperRepository {
    return ZypperRepository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ZypperRepository>): ZypperRepository {
    const message = createBaseZypperRepository();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.baseUrl = object.baseUrl ?? "";
    message.gpgKeys = object.gpgKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseGooRepository(): GooRepository {
  return { name: "", url: "" };
}

export const GooRepository: MessageFns<GooRepository> = {
  encode(message: GooRepository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GooRepository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGooRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GooRepository {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: GooRepository): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<GooRepository>): GooRepository {
    return GooRepository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GooRepository>): GooRepository {
    const message = createBaseGooRepository();
    message.name = object.name ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBasePackageRepository(): PackageRepository {
  return { apt: undefined, yum: undefined, zypper: undefined, goo: undefined };
}

export const PackageRepository: MessageFns<PackageRepository> = {
  encode(message: PackageRepository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apt !== undefined) {
      AptRepository.encode(message.apt, writer.uint32(10).fork()).join();
    }
    if (message.yum !== undefined) {
      YumRepository.encode(message.yum, writer.uint32(18).fork()).join();
    }
    if (message.zypper !== undefined) {
      ZypperRepository.encode(message.zypper, writer.uint32(26).fork()).join();
    }
    if (message.goo !== undefined) {
      GooRepository.encode(message.goo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PackageRepository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePackageRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.apt = AptRepository.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.yum = YumRepository.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.zypper = ZypperRepository.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.goo = GooRepository.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PackageRepository {
    return {
      apt: isSet(object.apt) ? AptRepository.fromJSON(object.apt) : undefined,
      yum: isSet(object.yum) ? YumRepository.fromJSON(object.yum) : undefined,
      zypper: isSet(object.zypper) ? ZypperRepository.fromJSON(object.zypper) : undefined,
      goo: isSet(object.goo) ? GooRepository.fromJSON(object.goo) : undefined,
    };
  },

  toJSON(message: PackageRepository): unknown {
    const obj: any = {};
    if (message.apt !== undefined) {
      obj.apt = AptRepository.toJSON(message.apt);
    }
    if (message.yum !== undefined) {
      obj.yum = YumRepository.toJSON(message.yum);
    }
    if (message.zypper !== undefined) {
      obj.zypper = ZypperRepository.toJSON(message.zypper);
    }
    if (message.goo !== undefined) {
      obj.goo = GooRepository.toJSON(message.goo);
    }
    return obj;
  },

  create(base?: DeepPartial<PackageRepository>): PackageRepository {
    return PackageRepository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PackageRepository>): PackageRepository {
    const message = createBasePackageRepository();
    message.apt = (object.apt !== undefined && object.apt !== null) ? AptRepository.fromPartial(object.apt) : undefined;
    message.yum = (object.yum !== undefined && object.yum !== null) ? YumRepository.fromPartial(object.yum) : undefined;
    message.zypper = (object.zypper !== undefined && object.zypper !== null)
      ? ZypperRepository.fromPartial(object.zypper)
      : undefined;
    message.goo = (object.goo !== undefined && object.goo !== null) ? GooRepository.fromPartial(object.goo) : undefined;
    return message;
  },
};

function createBaseSoftwareRecipe(): SoftwareRecipe {
  return { name: "", version: "", artifacts: [], installSteps: [], updateSteps: [], desiredState: 0 };
}

export const SoftwareRecipe: MessageFns<SoftwareRecipe> = {
  encode(message: SoftwareRecipe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    for (const v of message.artifacts) {
      SoftwareRecipe_Artifact.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.installSteps) {
      SoftwareRecipe_Step.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.updateSteps) {
      SoftwareRecipe_Step.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.desiredState !== 0) {
      writer.uint32(48).int32(message.desiredState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.artifacts.push(SoftwareRecipe_Artifact.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.installSteps.push(SoftwareRecipe_Step.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateSteps.push(SoftwareRecipe_Step.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.desiredState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => SoftwareRecipe_Artifact.fromJSON(e))
        : [],
      installSteps: globalThis.Array.isArray(object?.installSteps)
        ? object.installSteps.map((e: any) => SoftwareRecipe_Step.fromJSON(e))
        : [],
      updateSteps: globalThis.Array.isArray(object?.updateSteps)
        ? object.updateSteps.map((e: any) => SoftwareRecipe_Step.fromJSON(e))
        : [],
      desiredState: isSet(object.desiredState) ? desiredStateFromJSON(object.desiredState) : 0,
    };
  },

  toJSON(message: SoftwareRecipe): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => SoftwareRecipe_Artifact.toJSON(e));
    }
    if (message.installSteps?.length) {
      obj.installSteps = message.installSteps.map((e) => SoftwareRecipe_Step.toJSON(e));
    }
    if (message.updateSteps?.length) {
      obj.updateSteps = message.updateSteps.map((e) => SoftwareRecipe_Step.toJSON(e));
    }
    if (message.desiredState !== 0) {
      obj.desiredState = desiredStateToJSON(message.desiredState);
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe>): SoftwareRecipe {
    return SoftwareRecipe.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe>): SoftwareRecipe {
    const message = createBaseSoftwareRecipe();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.artifacts = object.artifacts?.map((e) => SoftwareRecipe_Artifact.fromPartial(e)) || [];
    message.installSteps = object.installSteps?.map((e) => SoftwareRecipe_Step.fromPartial(e)) || [];
    message.updateSteps = object.updateSteps?.map((e) => SoftwareRecipe_Step.fromPartial(e)) || [];
    message.desiredState = object.desiredState ?? 0;
    return message;
  },
};

function createBaseSoftwareRecipe_Artifact(): SoftwareRecipe_Artifact {
  return { id: "", remote: undefined, gcs: undefined, allowInsecure: false };
}

export const SoftwareRecipe_Artifact: MessageFns<SoftwareRecipe_Artifact> = {
  encode(message: SoftwareRecipe_Artifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.remote !== undefined) {
      SoftwareRecipe_Artifact_Remote.encode(message.remote, writer.uint32(18).fork()).join();
    }
    if (message.gcs !== undefined) {
      SoftwareRecipe_Artifact_Gcs.encode(message.gcs, writer.uint32(26).fork()).join();
    }
    if (message.allowInsecure !== false) {
      writer.uint32(32).bool(message.allowInsecure);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Artifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Artifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.remote = SoftwareRecipe_Artifact_Remote.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gcs = SoftwareRecipe_Artifact_Gcs.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowInsecure = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Artifact {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      remote: isSet(object.remote) ? SoftwareRecipe_Artifact_Remote.fromJSON(object.remote) : undefined,
      gcs: isSet(object.gcs) ? SoftwareRecipe_Artifact_Gcs.fromJSON(object.gcs) : undefined,
      allowInsecure: isSet(object.allowInsecure) ? globalThis.Boolean(object.allowInsecure) : false,
    };
  },

  toJSON(message: SoftwareRecipe_Artifact): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.remote !== undefined) {
      obj.remote = SoftwareRecipe_Artifact_Remote.toJSON(message.remote);
    }
    if (message.gcs !== undefined) {
      obj.gcs = SoftwareRecipe_Artifact_Gcs.toJSON(message.gcs);
    }
    if (message.allowInsecure !== false) {
      obj.allowInsecure = message.allowInsecure;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Artifact>): SoftwareRecipe_Artifact {
    return SoftwareRecipe_Artifact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Artifact>): SoftwareRecipe_Artifact {
    const message = createBaseSoftwareRecipe_Artifact();
    message.id = object.id ?? "";
    message.remote = (object.remote !== undefined && object.remote !== null)
      ? SoftwareRecipe_Artifact_Remote.fromPartial(object.remote)
      : undefined;
    message.gcs = (object.gcs !== undefined && object.gcs !== null)
      ? SoftwareRecipe_Artifact_Gcs.fromPartial(object.gcs)
      : undefined;
    message.allowInsecure = object.allowInsecure ?? false;
    return message;
  },
};

function createBaseSoftwareRecipe_Artifact_Remote(): SoftwareRecipe_Artifact_Remote {
  return { uri: "", checksum: "" };
}

export const SoftwareRecipe_Artifact_Remote: MessageFns<SoftwareRecipe_Artifact_Remote> = {
  encode(message: SoftwareRecipe_Artifact_Remote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.checksum !== "") {
      writer.uint32(18).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Artifact_Remote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Artifact_Remote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.checksum = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Artifact_Remote {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: SoftwareRecipe_Artifact_Remote): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Artifact_Remote>): SoftwareRecipe_Artifact_Remote {
    return SoftwareRecipe_Artifact_Remote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Artifact_Remote>): SoftwareRecipe_Artifact_Remote {
    const message = createBaseSoftwareRecipe_Artifact_Remote();
    message.uri = object.uri ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseSoftwareRecipe_Artifact_Gcs(): SoftwareRecipe_Artifact_Gcs {
  return { bucket: "", object: "", generation: Long.ZERO };
}

export const SoftwareRecipe_Artifact_Gcs: MessageFns<SoftwareRecipe_Artifact_Gcs> = {
  encode(message: SoftwareRecipe_Artifact_Gcs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.object !== "") {
      writer.uint32(18).string(message.object);
    }
    if (!message.generation.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.generation.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Artifact_Gcs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Artifact_Gcs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.object = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.generation = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Artifact_Gcs {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      object: isSet(object.object) ? globalThis.String(object.object) : "",
      generation: isSet(object.generation) ? Long.fromValue(object.generation) : Long.ZERO,
    };
  },

  toJSON(message: SoftwareRecipe_Artifact_Gcs): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.object !== "") {
      obj.object = message.object;
    }
    if (!message.generation.equals(Long.ZERO)) {
      obj.generation = (message.generation || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Artifact_Gcs>): SoftwareRecipe_Artifact_Gcs {
    return SoftwareRecipe_Artifact_Gcs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Artifact_Gcs>): SoftwareRecipe_Artifact_Gcs {
    const message = createBaseSoftwareRecipe_Artifact_Gcs();
    message.bucket = object.bucket ?? "";
    message.object = object.object ?? "";
    message.generation = (object.generation !== undefined && object.generation !== null)
      ? Long.fromValue(object.generation)
      : Long.ZERO;
    return message;
  },
};

function createBaseSoftwareRecipe_Step(): SoftwareRecipe_Step {
  return {
    fileCopy: undefined,
    archiveExtraction: undefined,
    msiInstallation: undefined,
    dpkgInstallation: undefined,
    rpmInstallation: undefined,
    fileExec: undefined,
    scriptRun: undefined,
  };
}

export const SoftwareRecipe_Step: MessageFns<SoftwareRecipe_Step> = {
  encode(message: SoftwareRecipe_Step, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileCopy !== undefined) {
      SoftwareRecipe_Step_CopyFile.encode(message.fileCopy, writer.uint32(10).fork()).join();
    }
    if (message.archiveExtraction !== undefined) {
      SoftwareRecipe_Step_ExtractArchive.encode(message.archiveExtraction, writer.uint32(18).fork()).join();
    }
    if (message.msiInstallation !== undefined) {
      SoftwareRecipe_Step_InstallMsi.encode(message.msiInstallation, writer.uint32(26).fork()).join();
    }
    if (message.dpkgInstallation !== undefined) {
      SoftwareRecipe_Step_InstallDpkg.encode(message.dpkgInstallation, writer.uint32(34).fork()).join();
    }
    if (message.rpmInstallation !== undefined) {
      SoftwareRecipe_Step_InstallRpm.encode(message.rpmInstallation, writer.uint32(42).fork()).join();
    }
    if (message.fileExec !== undefined) {
      SoftwareRecipe_Step_ExecFile.encode(message.fileExec, writer.uint32(50).fork()).join();
    }
    if (message.scriptRun !== undefined) {
      SoftwareRecipe_Step_RunScript.encode(message.scriptRun, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileCopy = SoftwareRecipe_Step_CopyFile.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.archiveExtraction = SoftwareRecipe_Step_ExtractArchive.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.msiInstallation = SoftwareRecipe_Step_InstallMsi.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dpkgInstallation = SoftwareRecipe_Step_InstallDpkg.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rpmInstallation = SoftwareRecipe_Step_InstallRpm.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fileExec = SoftwareRecipe_Step_ExecFile.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.scriptRun = SoftwareRecipe_Step_RunScript.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step {
    return {
      fileCopy: isSet(object.fileCopy) ? SoftwareRecipe_Step_CopyFile.fromJSON(object.fileCopy) : undefined,
      archiveExtraction: isSet(object.archiveExtraction)
        ? SoftwareRecipe_Step_ExtractArchive.fromJSON(object.archiveExtraction)
        : undefined,
      msiInstallation: isSet(object.msiInstallation)
        ? SoftwareRecipe_Step_InstallMsi.fromJSON(object.msiInstallation)
        : undefined,
      dpkgInstallation: isSet(object.dpkgInstallation)
        ? SoftwareRecipe_Step_InstallDpkg.fromJSON(object.dpkgInstallation)
        : undefined,
      rpmInstallation: isSet(object.rpmInstallation)
        ? SoftwareRecipe_Step_InstallRpm.fromJSON(object.rpmInstallation)
        : undefined,
      fileExec: isSet(object.fileExec) ? SoftwareRecipe_Step_ExecFile.fromJSON(object.fileExec) : undefined,
      scriptRun: isSet(object.scriptRun) ? SoftwareRecipe_Step_RunScript.fromJSON(object.scriptRun) : undefined,
    };
  },

  toJSON(message: SoftwareRecipe_Step): unknown {
    const obj: any = {};
    if (message.fileCopy !== undefined) {
      obj.fileCopy = SoftwareRecipe_Step_CopyFile.toJSON(message.fileCopy);
    }
    if (message.archiveExtraction !== undefined) {
      obj.archiveExtraction = SoftwareRecipe_Step_ExtractArchive.toJSON(message.archiveExtraction);
    }
    if (message.msiInstallation !== undefined) {
      obj.msiInstallation = SoftwareRecipe_Step_InstallMsi.toJSON(message.msiInstallation);
    }
    if (message.dpkgInstallation !== undefined) {
      obj.dpkgInstallation = SoftwareRecipe_Step_InstallDpkg.toJSON(message.dpkgInstallation);
    }
    if (message.rpmInstallation !== undefined) {
      obj.rpmInstallation = SoftwareRecipe_Step_InstallRpm.toJSON(message.rpmInstallation);
    }
    if (message.fileExec !== undefined) {
      obj.fileExec = SoftwareRecipe_Step_ExecFile.toJSON(message.fileExec);
    }
    if (message.scriptRun !== undefined) {
      obj.scriptRun = SoftwareRecipe_Step_RunScript.toJSON(message.scriptRun);
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step>): SoftwareRecipe_Step {
    return SoftwareRecipe_Step.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step>): SoftwareRecipe_Step {
    const message = createBaseSoftwareRecipe_Step();
    message.fileCopy = (object.fileCopy !== undefined && object.fileCopy !== null)
      ? SoftwareRecipe_Step_CopyFile.fromPartial(object.fileCopy)
      : undefined;
    message.archiveExtraction = (object.archiveExtraction !== undefined && object.archiveExtraction !== null)
      ? SoftwareRecipe_Step_ExtractArchive.fromPartial(object.archiveExtraction)
      : undefined;
    message.msiInstallation = (object.msiInstallation !== undefined && object.msiInstallation !== null)
      ? SoftwareRecipe_Step_InstallMsi.fromPartial(object.msiInstallation)
      : undefined;
    message.dpkgInstallation = (object.dpkgInstallation !== undefined && object.dpkgInstallation !== null)
      ? SoftwareRecipe_Step_InstallDpkg.fromPartial(object.dpkgInstallation)
      : undefined;
    message.rpmInstallation = (object.rpmInstallation !== undefined && object.rpmInstallation !== null)
      ? SoftwareRecipe_Step_InstallRpm.fromPartial(object.rpmInstallation)
      : undefined;
    message.fileExec = (object.fileExec !== undefined && object.fileExec !== null)
      ? SoftwareRecipe_Step_ExecFile.fromPartial(object.fileExec)
      : undefined;
    message.scriptRun = (object.scriptRun !== undefined && object.scriptRun !== null)
      ? SoftwareRecipe_Step_RunScript.fromPartial(object.scriptRun)
      : undefined;
    return message;
  },
};

function createBaseSoftwareRecipe_Step_CopyFile(): SoftwareRecipe_Step_CopyFile {
  return { artifactId: "", destination: "", overwrite: false, permissions: "" };
}

export const SoftwareRecipe_Step_CopyFile: MessageFns<SoftwareRecipe_Step_CopyFile> = {
  encode(message: SoftwareRecipe_Step_CopyFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    if (message.destination !== "") {
      writer.uint32(18).string(message.destination);
    }
    if (message.overwrite !== false) {
      writer.uint32(24).bool(message.overwrite);
    }
    if (message.permissions !== "") {
      writer.uint32(34).string(message.permissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_CopyFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_CopyFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.overwrite = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.permissions = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_CopyFile {
    return {
      artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : "",
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      overwrite: isSet(object.overwrite) ? globalThis.Boolean(object.overwrite) : false,
      permissions: isSet(object.permissions) ? globalThis.String(object.permissions) : "",
    };
  },

  toJSON(message: SoftwareRecipe_Step_CopyFile): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.overwrite !== false) {
      obj.overwrite = message.overwrite;
    }
    if (message.permissions !== "") {
      obj.permissions = message.permissions;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_CopyFile>): SoftwareRecipe_Step_CopyFile {
    return SoftwareRecipe_Step_CopyFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_CopyFile>): SoftwareRecipe_Step_CopyFile {
    const message = createBaseSoftwareRecipe_Step_CopyFile();
    message.artifactId = object.artifactId ?? "";
    message.destination = object.destination ?? "";
    message.overwrite = object.overwrite ?? false;
    message.permissions = object.permissions ?? "";
    return message;
  },
};

function createBaseSoftwareRecipe_Step_ExtractArchive(): SoftwareRecipe_Step_ExtractArchive {
  return { artifactId: "", destination: "", type: 0 };
}

export const SoftwareRecipe_Step_ExtractArchive: MessageFns<SoftwareRecipe_Step_ExtractArchive> = {
  encode(message: SoftwareRecipe_Step_ExtractArchive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    if (message.destination !== "") {
      writer.uint32(18).string(message.destination);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_ExtractArchive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_ExtractArchive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_ExtractArchive {
    return {
      artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : "",
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      type: isSet(object.type) ? softwareRecipe_Step_ExtractArchive_ArchiveTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: SoftwareRecipe_Step_ExtractArchive): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.type !== 0) {
      obj.type = softwareRecipe_Step_ExtractArchive_ArchiveTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_ExtractArchive>): SoftwareRecipe_Step_ExtractArchive {
    return SoftwareRecipe_Step_ExtractArchive.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_ExtractArchive>): SoftwareRecipe_Step_ExtractArchive {
    const message = createBaseSoftwareRecipe_Step_ExtractArchive();
    message.artifactId = object.artifactId ?? "";
    message.destination = object.destination ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseSoftwareRecipe_Step_InstallMsi(): SoftwareRecipe_Step_InstallMsi {
  return { artifactId: "", flags: [], allowedExitCodes: [] };
}

export const SoftwareRecipe_Step_InstallMsi: MessageFns<SoftwareRecipe_Step_InstallMsi> = {
  encode(message: SoftwareRecipe_Step_InstallMsi, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    for (const v of message.flags) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(26).fork();
    for (const v of message.allowedExitCodes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_InstallMsi {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_InstallMsi();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.flags.push(reader.string());
          continue;
        case 3:
          if (tag === 24) {
            message.allowedExitCodes.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedExitCodes.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_InstallMsi {
    return {
      artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : "",
      flags: globalThis.Array.isArray(object?.flags) ? object.flags.map((e: any) => globalThis.String(e)) : [],
      allowedExitCodes: globalThis.Array.isArray(object?.allowedExitCodes)
        ? object.allowedExitCodes.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: SoftwareRecipe_Step_InstallMsi): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    if (message.flags?.length) {
      obj.flags = message.flags;
    }
    if (message.allowedExitCodes?.length) {
      obj.allowedExitCodes = message.allowedExitCodes.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_InstallMsi>): SoftwareRecipe_Step_InstallMsi {
    return SoftwareRecipe_Step_InstallMsi.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_InstallMsi>): SoftwareRecipe_Step_InstallMsi {
    const message = createBaseSoftwareRecipe_Step_InstallMsi();
    message.artifactId = object.artifactId ?? "";
    message.flags = object.flags?.map((e) => e) || [];
    message.allowedExitCodes = object.allowedExitCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSoftwareRecipe_Step_InstallDpkg(): SoftwareRecipe_Step_InstallDpkg {
  return { artifactId: "" };
}

export const SoftwareRecipe_Step_InstallDpkg: MessageFns<SoftwareRecipe_Step_InstallDpkg> = {
  encode(message: SoftwareRecipe_Step_InstallDpkg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_InstallDpkg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_InstallDpkg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_InstallDpkg {
    return { artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : "" };
  },

  toJSON(message: SoftwareRecipe_Step_InstallDpkg): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_InstallDpkg>): SoftwareRecipe_Step_InstallDpkg {
    return SoftwareRecipe_Step_InstallDpkg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_InstallDpkg>): SoftwareRecipe_Step_InstallDpkg {
    const message = createBaseSoftwareRecipe_Step_InstallDpkg();
    message.artifactId = object.artifactId ?? "";
    return message;
  },
};

function createBaseSoftwareRecipe_Step_InstallRpm(): SoftwareRecipe_Step_InstallRpm {
  return { artifactId: "" };
}

export const SoftwareRecipe_Step_InstallRpm: MessageFns<SoftwareRecipe_Step_InstallRpm> = {
  encode(message: SoftwareRecipe_Step_InstallRpm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_InstallRpm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_InstallRpm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_InstallRpm {
    return { artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : "" };
  },

  toJSON(message: SoftwareRecipe_Step_InstallRpm): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_InstallRpm>): SoftwareRecipe_Step_InstallRpm {
    return SoftwareRecipe_Step_InstallRpm.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_InstallRpm>): SoftwareRecipe_Step_InstallRpm {
    const message = createBaseSoftwareRecipe_Step_InstallRpm();
    message.artifactId = object.artifactId ?? "";
    return message;
  },
};

function createBaseSoftwareRecipe_Step_ExecFile(): SoftwareRecipe_Step_ExecFile {
  return { artifactId: undefined, localPath: undefined, args: [], allowedExitCodes: [] };
}

export const SoftwareRecipe_Step_ExecFile: MessageFns<SoftwareRecipe_Step_ExecFile> = {
  encode(message: SoftwareRecipe_Step_ExecFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== undefined) {
      writer.uint32(10).string(message.artifactId);
    }
    if (message.localPath !== undefined) {
      writer.uint32(18).string(message.localPath);
    }
    for (const v of message.args) {
      writer.uint32(26).string(v!);
    }
    writer.uint32(34).fork();
    for (const v of message.allowedExitCodes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_ExecFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_ExecFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.localPath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.args.push(reader.string());
          continue;
        case 4:
          if (tag === 32) {
            message.allowedExitCodes.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedExitCodes.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_ExecFile {
    return {
      artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : undefined,
      localPath: isSet(object.localPath) ? globalThis.String(object.localPath) : undefined,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      allowedExitCodes: globalThis.Array.isArray(object?.allowedExitCodes)
        ? object.allowedExitCodes.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: SoftwareRecipe_Step_ExecFile): unknown {
    const obj: any = {};
    if (message.artifactId !== undefined) {
      obj.artifactId = message.artifactId;
    }
    if (message.localPath !== undefined) {
      obj.localPath = message.localPath;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.allowedExitCodes?.length) {
      obj.allowedExitCodes = message.allowedExitCodes.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_ExecFile>): SoftwareRecipe_Step_ExecFile {
    return SoftwareRecipe_Step_ExecFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_ExecFile>): SoftwareRecipe_Step_ExecFile {
    const message = createBaseSoftwareRecipe_Step_ExecFile();
    message.artifactId = object.artifactId ?? undefined;
    message.localPath = object.localPath ?? undefined;
    message.args = object.args?.map((e) => e) || [];
    message.allowedExitCodes = object.allowedExitCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSoftwareRecipe_Step_RunScript(): SoftwareRecipe_Step_RunScript {
  return { script: "", allowedExitCodes: [], interpreter: 0 };
}

export const SoftwareRecipe_Step_RunScript: MessageFns<SoftwareRecipe_Step_RunScript> = {
  encode(message: SoftwareRecipe_Step_RunScript, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.script !== "") {
      writer.uint32(10).string(message.script);
    }
    writer.uint32(18).fork();
    for (const v of message.allowedExitCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message.interpreter !== 0) {
      writer.uint32(24).int32(message.interpreter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_RunScript {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_RunScript();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.script = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.allowedExitCodes.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedExitCodes.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.interpreter = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_RunScript {
    return {
      script: isSet(object.script) ? globalThis.String(object.script) : "",
      allowedExitCodes: globalThis.Array.isArray(object?.allowedExitCodes)
        ? object.allowedExitCodes.map((e: any) => globalThis.Number(e))
        : [],
      interpreter: isSet(object.interpreter)
        ? softwareRecipe_Step_RunScript_InterpreterFromJSON(object.interpreter)
        : 0,
    };
  },

  toJSON(message: SoftwareRecipe_Step_RunScript): unknown {
    const obj: any = {};
    if (message.script !== "") {
      obj.script = message.script;
    }
    if (message.allowedExitCodes?.length) {
      obj.allowedExitCodes = message.allowedExitCodes.map((e) => Math.round(e));
    }
    if (message.interpreter !== 0) {
      obj.interpreter = softwareRecipe_Step_RunScript_InterpreterToJSON(message.interpreter);
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_RunScript>): SoftwareRecipe_Step_RunScript {
    return SoftwareRecipe_Step_RunScript.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_RunScript>): SoftwareRecipe_Step_RunScript {
    const message = createBaseSoftwareRecipe_Step_RunScript();
    message.script = object.script ?? "";
    message.allowedExitCodes = object.allowedExitCodes?.map((e) => e) || [];
    message.interpreter = object.interpreter ?? 0;
    return message;
  },
};

function createBaseCreateGuestPolicyRequest(): CreateGuestPolicyRequest {
  return { parent: "", guestPolicyId: "", guestPolicy: undefined };
}

export const CreateGuestPolicyRequest: MessageFns<CreateGuestPolicyRequest> = {
  encode(message: CreateGuestPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.guestPolicyId !== "") {
      writer.uint32(18).string(message.guestPolicyId);
    }
    if (message.guestPolicy !== undefined) {
      GuestPolicy.encode(message.guestPolicy, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateGuestPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateGuestPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.guestPolicyId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.guestPolicy = GuestPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateGuestPolicyRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      guestPolicyId: isSet(object.guestPolicyId) ? globalThis.String(object.guestPolicyId) : "",
      guestPolicy: isSet(object.guestPolicy) ? GuestPolicy.fromJSON(object.guestPolicy) : undefined,
    };
  },

  toJSON(message: CreateGuestPolicyRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.guestPolicyId !== "") {
      obj.guestPolicyId = message.guestPolicyId;
    }
    if (message.guestPolicy !== undefined) {
      obj.guestPolicy = GuestPolicy.toJSON(message.guestPolicy);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateGuestPolicyRequest>): CreateGuestPolicyRequest {
    return CreateGuestPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateGuestPolicyRequest>): CreateGuestPolicyRequest {
    const message = createBaseCreateGuestPolicyRequest();
    message.parent = object.parent ?? "";
    message.guestPolicyId = object.guestPolicyId ?? "";
    message.guestPolicy = (object.guestPolicy !== undefined && object.guestPolicy !== null)
      ? GuestPolicy.fromPartial(object.guestPolicy)
      : undefined;
    return message;
  },
};

function createBaseGetGuestPolicyRequest(): GetGuestPolicyRequest {
  return { name: "" };
}

export const GetGuestPolicyRequest: MessageFns<GetGuestPolicyRequest> = {
  encode(message: GetGuestPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGuestPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGuestPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGuestPolicyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetGuestPolicyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetGuestPolicyRequest>): GetGuestPolicyRequest {
    return GetGuestPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetGuestPolicyRequest>): GetGuestPolicyRequest {
    const message = createBaseGetGuestPolicyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListGuestPoliciesRequest(): ListGuestPoliciesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListGuestPoliciesRequest: MessageFns<ListGuestPoliciesRequest> = {
  encode(message: ListGuestPoliciesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGuestPoliciesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGuestPoliciesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGuestPoliciesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListGuestPoliciesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGuestPoliciesRequest>): ListGuestPoliciesRequest {
    return ListGuestPoliciesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGuestPoliciesRequest>): ListGuestPoliciesRequest {
    const message = createBaseListGuestPoliciesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListGuestPoliciesResponse(): ListGuestPoliciesResponse {
  return { guestPolicies: [], nextPageToken: "" };
}

export const ListGuestPoliciesResponse: MessageFns<ListGuestPoliciesResponse> = {
  encode(message: ListGuestPoliciesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.guestPolicies) {
      GuestPolicy.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListGuestPoliciesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListGuestPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.guestPolicies.push(GuestPolicy.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListGuestPoliciesResponse {
    return {
      guestPolicies: globalThis.Array.isArray(object?.guestPolicies)
        ? object.guestPolicies.map((e: any) => GuestPolicy.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListGuestPoliciesResponse): unknown {
    const obj: any = {};
    if (message.guestPolicies?.length) {
      obj.guestPolicies = message.guestPolicies.map((e) => GuestPolicy.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListGuestPoliciesResponse>): ListGuestPoliciesResponse {
    return ListGuestPoliciesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListGuestPoliciesResponse>): ListGuestPoliciesResponse {
    const message = createBaseListGuestPoliciesResponse();
    message.guestPolicies = object.guestPolicies?.map((e) => GuestPolicy.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateGuestPolicyRequest(): UpdateGuestPolicyRequest {
  return { guestPolicy: undefined, updateMask: undefined };
}

export const UpdateGuestPolicyRequest: MessageFns<UpdateGuestPolicyRequest> = {
  encode(message: UpdateGuestPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guestPolicy !== undefined) {
      GuestPolicy.encode(message.guestPolicy, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateGuestPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateGuestPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.guestPolicy = GuestPolicy.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateGuestPolicyRequest {
    return {
      guestPolicy: isSet(object.guestPolicy) ? GuestPolicy.fromJSON(object.guestPolicy) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateGuestPolicyRequest): unknown {
    const obj: any = {};
    if (message.guestPolicy !== undefined) {
      obj.guestPolicy = GuestPolicy.toJSON(message.guestPolicy);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateGuestPolicyRequest>): UpdateGuestPolicyRequest {
    return UpdateGuestPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateGuestPolicyRequest>): UpdateGuestPolicyRequest {
    const message = createBaseUpdateGuestPolicyRequest();
    message.guestPolicy = (object.guestPolicy !== undefined && object.guestPolicy !== null)
      ? GuestPolicy.fromPartial(object.guestPolicy)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteGuestPolicyRequest(): DeleteGuestPolicyRequest {
  return { name: "" };
}

export const DeleteGuestPolicyRequest: MessageFns<DeleteGuestPolicyRequest> = {
  encode(message: DeleteGuestPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteGuestPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteGuestPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteGuestPolicyRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteGuestPolicyRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteGuestPolicyRequest>): DeleteGuestPolicyRequest {
    return DeleteGuestPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteGuestPolicyRequest>): DeleteGuestPolicyRequest {
    const message = createBaseDeleteGuestPolicyRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseLookupEffectiveGuestPolicyRequest(): LookupEffectiveGuestPolicyRequest {
  return { instance: "", osShortName: "", osVersion: "", osArchitecture: "" };
}

export const LookupEffectiveGuestPolicyRequest: MessageFns<LookupEffectiveGuestPolicyRequest> = {
  encode(message: LookupEffectiveGuestPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== "") {
      writer.uint32(10).string(message.instance);
    }
    if (message.osShortName !== "") {
      writer.uint32(18).string(message.osShortName);
    }
    if (message.osVersion !== "") {
      writer.uint32(26).string(message.osVersion);
    }
    if (message.osArchitecture !== "") {
      writer.uint32(34).string(message.osArchitecture);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupEffectiveGuestPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupEffectiveGuestPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.osShortName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.osVersion = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.osArchitecture = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupEffectiveGuestPolicyRequest {
    return {
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      osShortName: isSet(object.osShortName) ? globalThis.String(object.osShortName) : "",
      osVersion: isSet(object.osVersion) ? globalThis.String(object.osVersion) : "",
      osArchitecture: isSet(object.osArchitecture) ? globalThis.String(object.osArchitecture) : "",
    };
  },

  toJSON(message: LookupEffectiveGuestPolicyRequest): unknown {
    const obj: any = {};
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.osShortName !== "") {
      obj.osShortName = message.osShortName;
    }
    if (message.osVersion !== "") {
      obj.osVersion = message.osVersion;
    }
    if (message.osArchitecture !== "") {
      obj.osArchitecture = message.osArchitecture;
    }
    return obj;
  },

  create(base?: DeepPartial<LookupEffectiveGuestPolicyRequest>): LookupEffectiveGuestPolicyRequest {
    return LookupEffectiveGuestPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LookupEffectiveGuestPolicyRequest>): LookupEffectiveGuestPolicyRequest {
    const message = createBaseLookupEffectiveGuestPolicyRequest();
    message.instance = object.instance ?? "";
    message.osShortName = object.osShortName ?? "";
    message.osVersion = object.osVersion ?? "";
    message.osArchitecture = object.osArchitecture ?? "";
    return message;
  },
};

function createBaseEffectiveGuestPolicy(): EffectiveGuestPolicy {
  return { packages: [], packageRepositories: [], softwareRecipes: [] };
}

export const EffectiveGuestPolicy: MessageFns<EffectiveGuestPolicy> = {
  encode(message: EffectiveGuestPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.packages) {
      EffectiveGuestPolicy_SourcedPackage.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.packageRepositories) {
      EffectiveGuestPolicy_SourcedPackageRepository.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.softwareRecipes) {
      EffectiveGuestPolicy_SourcedSoftwareRecipe.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectiveGuestPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectiveGuestPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.packages.push(EffectiveGuestPolicy_SourcedPackage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.packageRepositories.push(
            EffectiveGuestPolicy_SourcedPackageRepository.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.softwareRecipes.push(EffectiveGuestPolicy_SourcedSoftwareRecipe.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectiveGuestPolicy {
    return {
      packages: globalThis.Array.isArray(object?.packages)
        ? object.packages.map((e: any) => EffectiveGuestPolicy_SourcedPackage.fromJSON(e))
        : [],
      packageRepositories: globalThis.Array.isArray(object?.packageRepositories)
        ? object.packageRepositories.map((e: any) => EffectiveGuestPolicy_SourcedPackageRepository.fromJSON(e))
        : [],
      softwareRecipes: globalThis.Array.isArray(object?.softwareRecipes)
        ? object.softwareRecipes.map((e: any) => EffectiveGuestPolicy_SourcedSoftwareRecipe.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EffectiveGuestPolicy): unknown {
    const obj: any = {};
    if (message.packages?.length) {
      obj.packages = message.packages.map((e) => EffectiveGuestPolicy_SourcedPackage.toJSON(e));
    }
    if (message.packageRepositories?.length) {
      obj.packageRepositories = message.packageRepositories.map((e) =>
        EffectiveGuestPolicy_SourcedPackageRepository.toJSON(e)
      );
    }
    if (message.softwareRecipes?.length) {
      obj.softwareRecipes = message.softwareRecipes.map((e) => EffectiveGuestPolicy_SourcedSoftwareRecipe.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EffectiveGuestPolicy>): EffectiveGuestPolicy {
    return EffectiveGuestPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EffectiveGuestPolicy>): EffectiveGuestPolicy {
    const message = createBaseEffectiveGuestPolicy();
    message.packages = object.packages?.map((e) => EffectiveGuestPolicy_SourcedPackage.fromPartial(e)) || [];
    message.packageRepositories =
      object.packageRepositories?.map((e) => EffectiveGuestPolicy_SourcedPackageRepository.fromPartial(e)) || [];
    message.softwareRecipes =
      object.softwareRecipes?.map((e) => EffectiveGuestPolicy_SourcedSoftwareRecipe.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEffectiveGuestPolicy_SourcedPackage(): EffectiveGuestPolicy_SourcedPackage {
  return { source: "", package: undefined };
}

export const EffectiveGuestPolicy_SourcedPackage: MessageFns<EffectiveGuestPolicy_SourcedPackage> = {
  encode(message: EffectiveGuestPolicy_SourcedPackage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.package !== undefined) {
      Package.encode(message.package, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectiveGuestPolicy_SourcedPackage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectiveGuestPolicy_SourcedPackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.package = Package.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectiveGuestPolicy_SourcedPackage {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      package: isSet(object.package) ? Package.fromJSON(object.package) : undefined,
    };
  },

  toJSON(message: EffectiveGuestPolicy_SourcedPackage): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.package !== undefined) {
      obj.package = Package.toJSON(message.package);
    }
    return obj;
  },

  create(base?: DeepPartial<EffectiveGuestPolicy_SourcedPackage>): EffectiveGuestPolicy_SourcedPackage {
    return EffectiveGuestPolicy_SourcedPackage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EffectiveGuestPolicy_SourcedPackage>): EffectiveGuestPolicy_SourcedPackage {
    const message = createBaseEffectiveGuestPolicy_SourcedPackage();
    message.source = object.source ?? "";
    message.package = (object.package !== undefined && object.package !== null)
      ? Package.fromPartial(object.package)
      : undefined;
    return message;
  },
};

function createBaseEffectiveGuestPolicy_SourcedPackageRepository(): EffectiveGuestPolicy_SourcedPackageRepository {
  return { source: "", packageRepository: undefined };
}

export const EffectiveGuestPolicy_SourcedPackageRepository: MessageFns<EffectiveGuestPolicy_SourcedPackageRepository> =
  {
    encode(
      message: EffectiveGuestPolicy_SourcedPackageRepository,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.source !== "") {
        writer.uint32(10).string(message.source);
      }
      if (message.packageRepository !== undefined) {
        PackageRepository.encode(message.packageRepository, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EffectiveGuestPolicy_SourcedPackageRepository {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEffectiveGuestPolicy_SourcedPackageRepository();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.source = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.packageRepository = PackageRepository.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EffectiveGuestPolicy_SourcedPackageRepository {
      return {
        source: isSet(object.source) ? globalThis.String(object.source) : "",
        packageRepository: isSet(object.packageRepository)
          ? PackageRepository.fromJSON(object.packageRepository)
          : undefined,
      };
    },

    toJSON(message: EffectiveGuestPolicy_SourcedPackageRepository): unknown {
      const obj: any = {};
      if (message.source !== "") {
        obj.source = message.source;
      }
      if (message.packageRepository !== undefined) {
        obj.packageRepository = PackageRepository.toJSON(message.packageRepository);
      }
      return obj;
    },

    create(
      base?: DeepPartial<EffectiveGuestPolicy_SourcedPackageRepository>,
    ): EffectiveGuestPolicy_SourcedPackageRepository {
      return EffectiveGuestPolicy_SourcedPackageRepository.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<EffectiveGuestPolicy_SourcedPackageRepository>,
    ): EffectiveGuestPolicy_SourcedPackageRepository {
      const message = createBaseEffectiveGuestPolicy_SourcedPackageRepository();
      message.source = object.source ?? "";
      message.packageRepository = (object.packageRepository !== undefined && object.packageRepository !== null)
        ? PackageRepository.fromPartial(object.packageRepository)
        : undefined;
      return message;
    },
  };

function createBaseEffectiveGuestPolicy_SourcedSoftwareRecipe(): EffectiveGuestPolicy_SourcedSoftwareRecipe {
  return { source: "", softwareRecipe: undefined };
}

export const EffectiveGuestPolicy_SourcedSoftwareRecipe: MessageFns<EffectiveGuestPolicy_SourcedSoftwareRecipe> = {
  encode(message: EffectiveGuestPolicy_SourcedSoftwareRecipe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.softwareRecipe !== undefined) {
      SoftwareRecipe.encode(message.softwareRecipe, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectiveGuestPolicy_SourcedSoftwareRecipe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectiveGuestPolicy_SourcedSoftwareRecipe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.softwareRecipe = SoftwareRecipe.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectiveGuestPolicy_SourcedSoftwareRecipe {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      softwareRecipe: isSet(object.softwareRecipe) ? SoftwareRecipe.fromJSON(object.softwareRecipe) : undefined,
    };
  },

  toJSON(message: EffectiveGuestPolicy_SourcedSoftwareRecipe): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.softwareRecipe !== undefined) {
      obj.softwareRecipe = SoftwareRecipe.toJSON(message.softwareRecipe);
    }
    return obj;
  },

  create(base?: DeepPartial<EffectiveGuestPolicy_SourcedSoftwareRecipe>): EffectiveGuestPolicy_SourcedSoftwareRecipe {
    return EffectiveGuestPolicy_SourcedSoftwareRecipe.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<EffectiveGuestPolicy_SourcedSoftwareRecipe>,
  ): EffectiveGuestPolicy_SourcedSoftwareRecipe {
    const message = createBaseEffectiveGuestPolicy_SourcedSoftwareRecipe();
    message.source = object.source ?? "";
    message.softwareRecipe = (object.softwareRecipe !== undefined && object.softwareRecipe !== null)
      ? SoftwareRecipe.fromPartial(object.softwareRecipe)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
