// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/osconfig/v1beta/patch_deployments.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { TimeZone } from "../../../type/datetime.js";
import { DayOfWeek, dayOfWeekFromJSON, dayOfWeekToJSON } from "../../../type/dayofweek.js";
import { TimeOfDay } from "../../../type/timeofday.js";
import { PatchConfig, PatchInstanceFilter, PatchRollout } from "./patch_jobs.js";

export const protobufPackage = "google.cloud.osconfig.v1beta";

/**
 * Patch deployments are configurations that individual patch jobs use to
 * complete a patch. These configurations include instance filter, package
 * repository settings, and a schedule. For more information about creating and
 * managing patch deployments, see [Scheduling patch
 * jobs](https://cloud.google.com/compute/docs/os-patch-management/schedule-patch-jobs).
 */
export interface PatchDeployment {
  /**
   * Unique name for the patch deployment resource in a project. The patch
   * deployment name is in the form:
   * `projects/{project_id}/patchDeployments/{patch_deployment_id}`.
   * This field is ignored when you create a new patch deployment.
   */
  name: string;
  /**
   * Optional. Description of the patch deployment. Length of the description is limited
   * to 1024 characters.
   */
  description: string;
  /** Required. VM instances to patch. */
  instanceFilter:
    | PatchInstanceFilter
    | undefined;
  /** Optional. Patch configuration that is applied. */
  patchConfig:
    | PatchConfig
    | undefined;
  /** Optional. Duration of the patch. After the duration ends, the patch times out. */
  duration:
    | Duration
    | undefined;
  /** Required. Schedule a one-time execution. */
  oneTimeSchedule?:
    | OneTimeSchedule
    | undefined;
  /** Required. Schedule recurring executions. */
  recurringSchedule?:
    | RecurringSchedule
    | undefined;
  /**
   * Output only. Time the patch deployment was created. Timestamp is in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. Time the patch deployment was last updated. Timestamp is in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. The last time a patch job was started by this deployment.
   * Timestamp is in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text
   * format.
   */
  lastExecuteTime:
    | Date
    | undefined;
  /** Optional. Rollout strategy of the patch job. */
  rollout:
    | PatchRollout
    | undefined;
  /** Output only. Current state of the patch deployment. */
  state: PatchDeployment_State;
}

/** Represents state of patch peployment. */
export enum PatchDeployment_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - Active value means that patch deployment generates Patch Jobs. */
  ACTIVE = 1,
  /**
   * PAUSED - Paused value means that patch deployment does not generate
   * Patch jobs. Requires user action to move in and out from this state.
   */
  PAUSED = 2,
  UNRECOGNIZED = -1,
}

export function patchDeployment_StateFromJSON(object: any): PatchDeployment_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return PatchDeployment_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return PatchDeployment_State.ACTIVE;
    case 2:
    case "PAUSED":
      return PatchDeployment_State.PAUSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PatchDeployment_State.UNRECOGNIZED;
  }
}

export function patchDeployment_StateToJSON(object: PatchDeployment_State): string {
  switch (object) {
    case PatchDeployment_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case PatchDeployment_State.ACTIVE:
      return "ACTIVE";
    case PatchDeployment_State.PAUSED:
      return "PAUSED";
    case PatchDeployment_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Sets the time for a one time patch deployment. Timestamp is in
 * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
 */
export interface OneTimeSchedule {
  /** Required. The desired patch job execution time. */
  executeTime: Date | undefined;
}

/** Sets the time for recurring patch deployments. */
export interface RecurringSchedule {
  /**
   * Required. Defines the time zone that `time_of_day` is relative to.
   * The rules for daylight saving time are determined by the chosen time zone.
   */
  timeZone:
    | TimeZone
    | undefined;
  /**
   * Optional. The time that the recurring schedule becomes effective.
   * Defaults to `create_time` of the patch deployment.
   */
  startTime:
    | Date
    | undefined;
  /**
   * Optional. The end time at which a recurring patch deployment schedule is no longer
   * active.
   */
  endTime:
    | Date
    | undefined;
  /** Required. Time of the day to run a recurring deployment. */
  timeOfDay:
    | TimeOfDay
    | undefined;
  /** Required. The frequency unit of this recurring schedule. */
  frequency: RecurringSchedule_Frequency;
  /** Required. Schedule with weekly executions. */
  weekly?:
    | WeeklySchedule
    | undefined;
  /** Required. Schedule with monthly executions. */
  monthly?:
    | MonthlySchedule
    | undefined;
  /** Output only. The time the last patch job ran successfully. */
  lastExecuteTime:
    | Date
    | undefined;
  /** Output only. The time the next patch job is scheduled to run. */
  nextExecuteTime: Date | undefined;
}

/** Specifies the frequency of the recurring patch deployments. */
export enum RecurringSchedule_Frequency {
  /** FREQUENCY_UNSPECIFIED - Invalid. A frequency must be specified. */
  FREQUENCY_UNSPECIFIED = 0,
  /**
   * WEEKLY - Indicates that the frequency of recurrence should be expressed in terms
   * of weeks.
   */
  WEEKLY = 1,
  /**
   * MONTHLY - Indicates that the frequency of recurrence should be expressed in terms
   * of months.
   */
  MONTHLY = 2,
  /**
   * DAILY - Indicates that the frequency of recurrence should be expressed in terms
   * of days.
   */
  DAILY = 3,
  UNRECOGNIZED = -1,
}

export function recurringSchedule_FrequencyFromJSON(object: any): RecurringSchedule_Frequency {
  switch (object) {
    case 0:
    case "FREQUENCY_UNSPECIFIED":
      return RecurringSchedule_Frequency.FREQUENCY_UNSPECIFIED;
    case 1:
    case "WEEKLY":
      return RecurringSchedule_Frequency.WEEKLY;
    case 2:
    case "MONTHLY":
      return RecurringSchedule_Frequency.MONTHLY;
    case 3:
    case "DAILY":
      return RecurringSchedule_Frequency.DAILY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecurringSchedule_Frequency.UNRECOGNIZED;
  }
}

export function recurringSchedule_FrequencyToJSON(object: RecurringSchedule_Frequency): string {
  switch (object) {
    case RecurringSchedule_Frequency.FREQUENCY_UNSPECIFIED:
      return "FREQUENCY_UNSPECIFIED";
    case RecurringSchedule_Frequency.WEEKLY:
      return "WEEKLY";
    case RecurringSchedule_Frequency.MONTHLY:
      return "MONTHLY";
    case RecurringSchedule_Frequency.DAILY:
      return "DAILY";
    case RecurringSchedule_Frequency.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a weekly schedule. */
export interface WeeklySchedule {
  /** Required. Day of the week. */
  dayOfWeek: DayOfWeek;
}

/**
 * Represents a monthly schedule. An example of a valid monthly schedule is
 * "on the third Tuesday of the month" or "on the 15th of the month".
 */
export interface MonthlySchedule {
  /** Required. Week day in a month. */
  weekDayOfMonth?:
    | WeekDayOfMonth
    | undefined;
  /**
   * Required. One day of the month. 1-31 indicates the 1st to the 31st day. -1
   * indicates the last day of the month.
   * Months without the target day will be skipped. For example, a schedule to
   * run "every month on the 31st" will not run in February, April, June, etc.
   */
  monthDay?: number | undefined;
}

/** Represents one week day in a month. An example is "the 4th Sunday". */
export interface WeekDayOfMonth {
  /**
   * Required. Week number in a month. 1-4 indicates the 1st to 4th week of the month. -1
   * indicates the last week of the month.
   */
  weekOrdinal: number;
  /** Required. A day of the week. */
  dayOfWeek: DayOfWeek;
  /**
   * Optional. Represents the number of days before or after the given week day of month
   * that the patch deployment is scheduled for. For example if `week_ordinal`
   * and `day_of_week` values point to the second day of the month and this
   * `day_offset` value is set to `3`, the patch deployment takes place three
   * days after the second Tuesday of the month. If this value is negative, for
   * example -5, the patches  are deployed five days before before the second
   * Tuesday of the month. Allowed values are in range `[-30, 30]`.
   */
  dayOffset: number;
}

/** A request message for creating a patch deployment. */
export interface CreatePatchDeploymentRequest {
  /** Required. The project to apply this patch deployment to in the form `projects/*`. */
  parent: string;
  /**
   * Required. A name for the patch deployment in the project. When creating a name
   * the following rules apply:
   * * Must contain only lowercase letters, numbers, and hyphens.
   * * Must start with a letter.
   * * Must be between 1-63 characters.
   * * Must end with a number or a letter.
   * * Must be unique within the project.
   */
  patchDeploymentId: string;
  /** Required. The patch deployment to create. */
  patchDeployment: PatchDeployment | undefined;
}

/** A request message for retrieving a patch deployment. */
export interface GetPatchDeploymentRequest {
  /**
   * Required. The resource name of the patch deployment in the form
   * `projects/* /patchDeployments/*`.
   */
  name: string;
}

/** A request message for listing patch deployments. */
export interface ListPatchDeploymentsRequest {
  /** Required. The resource name of the parent in the form `projects/*`. */
  parent: string;
  /** Optional. The maximum number of patch deployments to return. Default is 100. */
  pageSize: number;
  /**
   * Optional. A pagination token returned from a previous call to ListPatchDeployments
   * that indicates where this listing should continue from.
   */
  pageToken: string;
}

/** A response message for listing patch deployments. */
export interface ListPatchDeploymentsResponse {
  /** The list of patch deployments. */
  patchDeployments: PatchDeployment[];
  /**
   * A pagination token that can be used to get the next page of patch
   * deployments.
   */
  nextPageToken: string;
}

/** A request message for deleting a patch deployment. */
export interface DeletePatchDeploymentRequest {
  /**
   * Required. The resource name of the patch deployment in the form
   * `projects/* /patchDeployments/*`.
   */
  name: string;
}

/** A request message for updating a patch deployment. */
export interface UpdatePatchDeploymentRequest {
  /** Required. The patch deployment to Update. */
  patchDeployment:
    | PatchDeployment
    | undefined;
  /**
   * Optional. Field mask that controls which fields of the patch deployment should be
   * updated.
   */
  updateMask: string[] | undefined;
}

/** A request message for pausing a patch deployment. */
export interface PausePatchDeploymentRequest {
  /**
   * Required. The resource name of the patch deployment in the form
   * `projects/* /patchDeployments/*`.
   */
  name: string;
}

/** A request message for resuming a patch deployment. */
export interface ResumePatchDeploymentRequest {
  /**
   * Required. The resource name of the patch deployment in the form
   * `projects/* /patchDeployments/*`.
   */
  name: string;
}

function createBasePatchDeployment(): PatchDeployment {
  return {
    name: "",
    description: "",
    instanceFilter: undefined,
    patchConfig: undefined,
    duration: undefined,
    oneTimeSchedule: undefined,
    recurringSchedule: undefined,
    createTime: undefined,
    updateTime: undefined,
    lastExecuteTime: undefined,
    rollout: undefined,
    state: 0,
  };
}

export const PatchDeployment: MessageFns<PatchDeployment> = {
  encode(message: PatchDeployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.instanceFilter !== undefined) {
      PatchInstanceFilter.encode(message.instanceFilter, writer.uint32(26).fork()).join();
    }
    if (message.patchConfig !== undefined) {
      PatchConfig.encode(message.patchConfig, writer.uint32(34).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(42).fork()).join();
    }
    if (message.oneTimeSchedule !== undefined) {
      OneTimeSchedule.encode(message.oneTimeSchedule, writer.uint32(50).fork()).join();
    }
    if (message.recurringSchedule !== undefined) {
      RecurringSchedule.encode(message.recurringSchedule, writer.uint32(58).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    if (message.lastExecuteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastExecuteTime), writer.uint32(82).fork()).join();
    }
    if (message.rollout !== undefined) {
      PatchRollout.encode(message.rollout, writer.uint32(90).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(96).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchDeployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instanceFilter = PatchInstanceFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.patchConfig = PatchConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.oneTimeSchedule = OneTimeSchedule.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.recurringSchedule = RecurringSchedule.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.lastExecuteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.rollout = PatchRollout.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchDeployment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      instanceFilter: isSet(object.instanceFilter) ? PatchInstanceFilter.fromJSON(object.instanceFilter) : undefined,
      patchConfig: isSet(object.patchConfig) ? PatchConfig.fromJSON(object.patchConfig) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      oneTimeSchedule: isSet(object.oneTimeSchedule) ? OneTimeSchedule.fromJSON(object.oneTimeSchedule) : undefined,
      recurringSchedule: isSet(object.recurringSchedule)
        ? RecurringSchedule.fromJSON(object.recurringSchedule)
        : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      lastExecuteTime: isSet(object.lastExecuteTime) ? fromJsonTimestamp(object.lastExecuteTime) : undefined,
      rollout: isSet(object.rollout) ? PatchRollout.fromJSON(object.rollout) : undefined,
      state: isSet(object.state) ? patchDeployment_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: PatchDeployment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.instanceFilter !== undefined) {
      obj.instanceFilter = PatchInstanceFilter.toJSON(message.instanceFilter);
    }
    if (message.patchConfig !== undefined) {
      obj.patchConfig = PatchConfig.toJSON(message.patchConfig);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.oneTimeSchedule !== undefined) {
      obj.oneTimeSchedule = OneTimeSchedule.toJSON(message.oneTimeSchedule);
    }
    if (message.recurringSchedule !== undefined) {
      obj.recurringSchedule = RecurringSchedule.toJSON(message.recurringSchedule);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.lastExecuteTime !== undefined) {
      obj.lastExecuteTime = message.lastExecuteTime.toISOString();
    }
    if (message.rollout !== undefined) {
      obj.rollout = PatchRollout.toJSON(message.rollout);
    }
    if (message.state !== 0) {
      obj.state = patchDeployment_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<PatchDeployment>): PatchDeployment {
    return PatchDeployment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PatchDeployment>): PatchDeployment {
    const message = createBasePatchDeployment();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.instanceFilter = (object.instanceFilter !== undefined && object.instanceFilter !== null)
      ? PatchInstanceFilter.fromPartial(object.instanceFilter)
      : undefined;
    message.patchConfig = (object.patchConfig !== undefined && object.patchConfig !== null)
      ? PatchConfig.fromPartial(object.patchConfig)
      : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.oneTimeSchedule = (object.oneTimeSchedule !== undefined && object.oneTimeSchedule !== null)
      ? OneTimeSchedule.fromPartial(object.oneTimeSchedule)
      : undefined;
    message.recurringSchedule = (object.recurringSchedule !== undefined && object.recurringSchedule !== null)
      ? RecurringSchedule.fromPartial(object.recurringSchedule)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.lastExecuteTime = object.lastExecuteTime ?? undefined;
    message.rollout = (object.rollout !== undefined && object.rollout !== null)
      ? PatchRollout.fromPartial(object.rollout)
      : undefined;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseOneTimeSchedule(): OneTimeSchedule {
  return { executeTime: undefined };
}

export const OneTimeSchedule: MessageFns<OneTimeSchedule> = {
  encode(message: OneTimeSchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.executeTime), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OneTimeSchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOneTimeSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.executeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OneTimeSchedule {
    return { executeTime: isSet(object.executeTime) ? fromJsonTimestamp(object.executeTime) : undefined };
  },

  toJSON(message: OneTimeSchedule): unknown {
    const obj: any = {};
    if (message.executeTime !== undefined) {
      obj.executeTime = message.executeTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<OneTimeSchedule>): OneTimeSchedule {
    return OneTimeSchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OneTimeSchedule>): OneTimeSchedule {
    const message = createBaseOneTimeSchedule();
    message.executeTime = object.executeTime ?? undefined;
    return message;
  },
};

function createBaseRecurringSchedule(): RecurringSchedule {
  return {
    timeZone: undefined,
    startTime: undefined,
    endTime: undefined,
    timeOfDay: undefined,
    frequency: 0,
    weekly: undefined,
    monthly: undefined,
    lastExecuteTime: undefined,
    nextExecuteTime: undefined,
  };
}

export const RecurringSchedule: MessageFns<RecurringSchedule> = {
  encode(message: RecurringSchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeZone !== undefined) {
      TimeZone.encode(message.timeZone, writer.uint32(10).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    if (message.timeOfDay !== undefined) {
      TimeOfDay.encode(message.timeOfDay, writer.uint32(34).fork()).join();
    }
    if (message.frequency !== 0) {
      writer.uint32(40).int32(message.frequency);
    }
    if (message.weekly !== undefined) {
      WeeklySchedule.encode(message.weekly, writer.uint32(50).fork()).join();
    }
    if (message.monthly !== undefined) {
      MonthlySchedule.encode(message.monthly, writer.uint32(58).fork()).join();
    }
    if (message.lastExecuteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastExecuteTime), writer.uint32(74).fork()).join();
    }
    if (message.nextExecuteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.nextExecuteTime), writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecurringSchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecurringSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.timeZone = TimeZone.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.timeOfDay = TimeOfDay.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.frequency = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.weekly = WeeklySchedule.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.monthly = MonthlySchedule.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.lastExecuteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.nextExecuteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecurringSchedule {
    return {
      timeZone: isSet(object.timeZone) ? TimeZone.fromJSON(object.timeZone) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      timeOfDay: isSet(object.timeOfDay) ? TimeOfDay.fromJSON(object.timeOfDay) : undefined,
      frequency: isSet(object.frequency) ? recurringSchedule_FrequencyFromJSON(object.frequency) : 0,
      weekly: isSet(object.weekly) ? WeeklySchedule.fromJSON(object.weekly) : undefined,
      monthly: isSet(object.monthly) ? MonthlySchedule.fromJSON(object.monthly) : undefined,
      lastExecuteTime: isSet(object.lastExecuteTime) ? fromJsonTimestamp(object.lastExecuteTime) : undefined,
      nextExecuteTime: isSet(object.nextExecuteTime) ? fromJsonTimestamp(object.nextExecuteTime) : undefined,
    };
  },

  toJSON(message: RecurringSchedule): unknown {
    const obj: any = {};
    if (message.timeZone !== undefined) {
      obj.timeZone = TimeZone.toJSON(message.timeZone);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.timeOfDay !== undefined) {
      obj.timeOfDay = TimeOfDay.toJSON(message.timeOfDay);
    }
    if (message.frequency !== 0) {
      obj.frequency = recurringSchedule_FrequencyToJSON(message.frequency);
    }
    if (message.weekly !== undefined) {
      obj.weekly = WeeklySchedule.toJSON(message.weekly);
    }
    if (message.monthly !== undefined) {
      obj.monthly = MonthlySchedule.toJSON(message.monthly);
    }
    if (message.lastExecuteTime !== undefined) {
      obj.lastExecuteTime = message.lastExecuteTime.toISOString();
    }
    if (message.nextExecuteTime !== undefined) {
      obj.nextExecuteTime = message.nextExecuteTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<RecurringSchedule>): RecurringSchedule {
    return RecurringSchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RecurringSchedule>): RecurringSchedule {
    const message = createBaseRecurringSchedule();
    message.timeZone = (object.timeZone !== undefined && object.timeZone !== null)
      ? TimeZone.fromPartial(object.timeZone)
      : undefined;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.timeOfDay = (object.timeOfDay !== undefined && object.timeOfDay !== null)
      ? TimeOfDay.fromPartial(object.timeOfDay)
      : undefined;
    message.frequency = object.frequency ?? 0;
    message.weekly = (object.weekly !== undefined && object.weekly !== null)
      ? WeeklySchedule.fromPartial(object.weekly)
      : undefined;
    message.monthly = (object.monthly !== undefined && object.monthly !== null)
      ? MonthlySchedule.fromPartial(object.monthly)
      : undefined;
    message.lastExecuteTime = object.lastExecuteTime ?? undefined;
    message.nextExecuteTime = object.nextExecuteTime ?? undefined;
    return message;
  },
};

function createBaseWeeklySchedule(): WeeklySchedule {
  return { dayOfWeek: 0 };
}

export const WeeklySchedule: MessageFns<WeeklySchedule> = {
  encode(message: WeeklySchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dayOfWeek !== 0) {
      writer.uint32(8).int32(message.dayOfWeek);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeeklySchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeeklySchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.dayOfWeek = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeeklySchedule {
    return { dayOfWeek: isSet(object.dayOfWeek) ? dayOfWeekFromJSON(object.dayOfWeek) : 0 };
  },

  toJSON(message: WeeklySchedule): unknown {
    const obj: any = {};
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = dayOfWeekToJSON(message.dayOfWeek);
    }
    return obj;
  },

  create(base?: DeepPartial<WeeklySchedule>): WeeklySchedule {
    return WeeklySchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WeeklySchedule>): WeeklySchedule {
    const message = createBaseWeeklySchedule();
    message.dayOfWeek = object.dayOfWeek ?? 0;
    return message;
  },
};

function createBaseMonthlySchedule(): MonthlySchedule {
  return { weekDayOfMonth: undefined, monthDay: undefined };
}

export const MonthlySchedule: MessageFns<MonthlySchedule> = {
  encode(message: MonthlySchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.weekDayOfMonth !== undefined) {
      WeekDayOfMonth.encode(message.weekDayOfMonth, writer.uint32(10).fork()).join();
    }
    if (message.monthDay !== undefined) {
      writer.uint32(16).int32(message.monthDay);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MonthlySchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMonthlySchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.weekDayOfMonth = WeekDayOfMonth.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.monthDay = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MonthlySchedule {
    return {
      weekDayOfMonth: isSet(object.weekDayOfMonth) ? WeekDayOfMonth.fromJSON(object.weekDayOfMonth) : undefined,
      monthDay: isSet(object.monthDay) ? globalThis.Number(object.monthDay) : undefined,
    };
  },

  toJSON(message: MonthlySchedule): unknown {
    const obj: any = {};
    if (message.weekDayOfMonth !== undefined) {
      obj.weekDayOfMonth = WeekDayOfMonth.toJSON(message.weekDayOfMonth);
    }
    if (message.monthDay !== undefined) {
      obj.monthDay = Math.round(message.monthDay);
    }
    return obj;
  },

  create(base?: DeepPartial<MonthlySchedule>): MonthlySchedule {
    return MonthlySchedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MonthlySchedule>): MonthlySchedule {
    const message = createBaseMonthlySchedule();
    message.weekDayOfMonth = (object.weekDayOfMonth !== undefined && object.weekDayOfMonth !== null)
      ? WeekDayOfMonth.fromPartial(object.weekDayOfMonth)
      : undefined;
    message.monthDay = object.monthDay ?? undefined;
    return message;
  },
};

function createBaseWeekDayOfMonth(): WeekDayOfMonth {
  return { weekOrdinal: 0, dayOfWeek: 0, dayOffset: 0 };
}

export const WeekDayOfMonth: MessageFns<WeekDayOfMonth> = {
  encode(message: WeekDayOfMonth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.weekOrdinal !== 0) {
      writer.uint32(8).int32(message.weekOrdinal);
    }
    if (message.dayOfWeek !== 0) {
      writer.uint32(16).int32(message.dayOfWeek);
    }
    if (message.dayOffset !== 0) {
      writer.uint32(24).int32(message.dayOffset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeekDayOfMonth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeekDayOfMonth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.weekOrdinal = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dayOfWeek = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dayOffset = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeekDayOfMonth {
    return {
      weekOrdinal: isSet(object.weekOrdinal) ? globalThis.Number(object.weekOrdinal) : 0,
      dayOfWeek: isSet(object.dayOfWeek) ? dayOfWeekFromJSON(object.dayOfWeek) : 0,
      dayOffset: isSet(object.dayOffset) ? globalThis.Number(object.dayOffset) : 0,
    };
  },

  toJSON(message: WeekDayOfMonth): unknown {
    const obj: any = {};
    if (message.weekOrdinal !== 0) {
      obj.weekOrdinal = Math.round(message.weekOrdinal);
    }
    if (message.dayOfWeek !== 0) {
      obj.dayOfWeek = dayOfWeekToJSON(message.dayOfWeek);
    }
    if (message.dayOffset !== 0) {
      obj.dayOffset = Math.round(message.dayOffset);
    }
    return obj;
  },

  create(base?: DeepPartial<WeekDayOfMonth>): WeekDayOfMonth {
    return WeekDayOfMonth.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WeekDayOfMonth>): WeekDayOfMonth {
    const message = createBaseWeekDayOfMonth();
    message.weekOrdinal = object.weekOrdinal ?? 0;
    message.dayOfWeek = object.dayOfWeek ?? 0;
    message.dayOffset = object.dayOffset ?? 0;
    return message;
  },
};

function createBaseCreatePatchDeploymentRequest(): CreatePatchDeploymentRequest {
  return { parent: "", patchDeploymentId: "", patchDeployment: undefined };
}

export const CreatePatchDeploymentRequest: MessageFns<CreatePatchDeploymentRequest> = {
  encode(message: CreatePatchDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.patchDeploymentId !== "") {
      writer.uint32(18).string(message.patchDeploymentId);
    }
    if (message.patchDeployment !== undefined) {
      PatchDeployment.encode(message.patchDeployment, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePatchDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePatchDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.patchDeploymentId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.patchDeployment = PatchDeployment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePatchDeploymentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      patchDeploymentId: isSet(object.patchDeploymentId) ? globalThis.String(object.patchDeploymentId) : "",
      patchDeployment: isSet(object.patchDeployment) ? PatchDeployment.fromJSON(object.patchDeployment) : undefined,
    };
  },

  toJSON(message: CreatePatchDeploymentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.patchDeploymentId !== "") {
      obj.patchDeploymentId = message.patchDeploymentId;
    }
    if (message.patchDeployment !== undefined) {
      obj.patchDeployment = PatchDeployment.toJSON(message.patchDeployment);
    }
    return obj;
  },

  create(base?: DeepPartial<CreatePatchDeploymentRequest>): CreatePatchDeploymentRequest {
    return CreatePatchDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreatePatchDeploymentRequest>): CreatePatchDeploymentRequest {
    const message = createBaseCreatePatchDeploymentRequest();
    message.parent = object.parent ?? "";
    message.patchDeploymentId = object.patchDeploymentId ?? "";
    message.patchDeployment = (object.patchDeployment !== undefined && object.patchDeployment !== null)
      ? PatchDeployment.fromPartial(object.patchDeployment)
      : undefined;
    return message;
  },
};

function createBaseGetPatchDeploymentRequest(): GetPatchDeploymentRequest {
  return { name: "" };
}

export const GetPatchDeploymentRequest: MessageFns<GetPatchDeploymentRequest> = {
  encode(message: GetPatchDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPatchDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPatchDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPatchDeploymentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetPatchDeploymentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPatchDeploymentRequest>): GetPatchDeploymentRequest {
    return GetPatchDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPatchDeploymentRequest>): GetPatchDeploymentRequest {
    const message = createBaseGetPatchDeploymentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListPatchDeploymentsRequest(): ListPatchDeploymentsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListPatchDeploymentsRequest: MessageFns<ListPatchDeploymentsRequest> = {
  encode(message: ListPatchDeploymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPatchDeploymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPatchDeploymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPatchDeploymentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListPatchDeploymentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPatchDeploymentsRequest>): ListPatchDeploymentsRequest {
    return ListPatchDeploymentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPatchDeploymentsRequest>): ListPatchDeploymentsRequest {
    const message = createBaseListPatchDeploymentsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListPatchDeploymentsResponse(): ListPatchDeploymentsResponse {
  return { patchDeployments: [], nextPageToken: "" };
}

export const ListPatchDeploymentsResponse: MessageFns<ListPatchDeploymentsResponse> = {
  encode(message: ListPatchDeploymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.patchDeployments) {
      PatchDeployment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPatchDeploymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPatchDeploymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.patchDeployments.push(PatchDeployment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPatchDeploymentsResponse {
    return {
      patchDeployments: globalThis.Array.isArray(object?.patchDeployments)
        ? object.patchDeployments.map((e: any) => PatchDeployment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPatchDeploymentsResponse): unknown {
    const obj: any = {};
    if (message.patchDeployments?.length) {
      obj.patchDeployments = message.patchDeployments.map((e) => PatchDeployment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPatchDeploymentsResponse>): ListPatchDeploymentsResponse {
    return ListPatchDeploymentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPatchDeploymentsResponse>): ListPatchDeploymentsResponse {
    const message = createBaseListPatchDeploymentsResponse();
    message.patchDeployments = object.patchDeployments?.map((e) => PatchDeployment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeletePatchDeploymentRequest(): DeletePatchDeploymentRequest {
  return { name: "" };
}

export const DeletePatchDeploymentRequest: MessageFns<DeletePatchDeploymentRequest> = {
  encode(message: DeletePatchDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePatchDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePatchDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePatchDeploymentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeletePatchDeploymentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeletePatchDeploymentRequest>): DeletePatchDeploymentRequest {
    return DeletePatchDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeletePatchDeploymentRequest>): DeletePatchDeploymentRequest {
    const message = createBaseDeletePatchDeploymentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdatePatchDeploymentRequest(): UpdatePatchDeploymentRequest {
  return { patchDeployment: undefined, updateMask: undefined };
}

export const UpdatePatchDeploymentRequest: MessageFns<UpdatePatchDeploymentRequest> = {
  encode(message: UpdatePatchDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.patchDeployment !== undefined) {
      PatchDeployment.encode(message.patchDeployment, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePatchDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePatchDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.patchDeployment = PatchDeployment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePatchDeploymentRequest {
    return {
      patchDeployment: isSet(object.patchDeployment) ? PatchDeployment.fromJSON(object.patchDeployment) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdatePatchDeploymentRequest): unknown {
    const obj: any = {};
    if (message.patchDeployment !== undefined) {
      obj.patchDeployment = PatchDeployment.toJSON(message.patchDeployment);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdatePatchDeploymentRequest>): UpdatePatchDeploymentRequest {
    return UpdatePatchDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdatePatchDeploymentRequest>): UpdatePatchDeploymentRequest {
    const message = createBaseUpdatePatchDeploymentRequest();
    message.patchDeployment = (object.patchDeployment !== undefined && object.patchDeployment !== null)
      ? PatchDeployment.fromPartial(object.patchDeployment)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBasePausePatchDeploymentRequest(): PausePatchDeploymentRequest {
  return { name: "" };
}

export const PausePatchDeploymentRequest: MessageFns<PausePatchDeploymentRequest> = {
  encode(message: PausePatchDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PausePatchDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePausePatchDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PausePatchDeploymentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: PausePatchDeploymentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<PausePatchDeploymentRequest>): PausePatchDeploymentRequest {
    return PausePatchDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PausePatchDeploymentRequest>): PausePatchDeploymentRequest {
    const message = createBasePausePatchDeploymentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseResumePatchDeploymentRequest(): ResumePatchDeploymentRequest {
  return { name: "" };
}

export const ResumePatchDeploymentRequest: MessageFns<ResumePatchDeploymentRequest> = {
  encode(message: ResumePatchDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResumePatchDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumePatchDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResumePatchDeploymentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ResumePatchDeploymentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ResumePatchDeploymentRequest>): ResumePatchDeploymentRequest {
    return ResumePatchDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResumePatchDeploymentRequest>): ResumePatchDeploymentRequest {
    const message = createBaseResumePatchDeploymentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
