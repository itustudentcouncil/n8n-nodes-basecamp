// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/osconfig/v1/patch_jobs.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { FixedOrPercent } from "./osconfig_common.js";

export const protobufPackage = "google.cloud.osconfig.v1";

/**
 * A request message to initiate patching across Compute Engine
 * instances.
 */
export interface ExecutePatchJobRequest {
  /** Required. The project in which to run this patch in the form `projects/*` */
  parent: string;
  /**
   * Description of the patch job. Length of the description is limited
   * to 1024 characters.
   */
  description: string;
  /**
   * Required. Instances to patch, either explicitly or filtered by some
   * criteria such as zone or labels.
   */
  instanceFilter:
    | PatchInstanceFilter
    | undefined;
  /**
   * Patch configuration being applied. If omitted, instances are
   * patched using the default configurations.
   */
  patchConfig:
    | PatchConfig
    | undefined;
  /**
   * Duration of the patch job. After the duration ends, the patch job
   * times out.
   */
  duration:
    | Duration
    | undefined;
  /**
   * If this patch is a dry-run only, instances are contacted but
   * will do nothing.
   */
  dryRun: boolean;
  /** Display name for this patch job. This does not have to be unique. */
  displayName: string;
  /** Rollout strategy of the patch job. */
  rollout: PatchRollout | undefined;
}

/** Request to get an active or completed patch job. */
export interface GetPatchJobRequest {
  /** Required. Name of the patch in the form `projects/* /patchJobs/*` */
  name: string;
}

/** Request to list details for all instances that are part of a patch job. */
export interface ListPatchJobInstanceDetailsRequest {
  /**
   * Required. The parent for the instances are in the form of
   * `projects/* /patchJobs/*`.
   */
  parent: string;
  /** The maximum number of instance details records to return.  Default is 100. */
  pageSize: number;
  /**
   * A pagination token returned from a previous call
   * that indicates where this listing should continue from.
   */
  pageToken: string;
  /**
   * A filter expression that filters results listed in the response. This
   * field supports filtering results by instance zone, name, state, or
   * `failure_reason`.
   */
  filter: string;
}

/** A response message for listing the instances details for a patch job. */
export interface ListPatchJobInstanceDetailsResponse {
  /** A list of instance status. */
  patchJobInstanceDetails: PatchJobInstanceDetails[];
  /** A pagination token that can be used to get the next page of results. */
  nextPageToken: string;
}

/**
 * Patch details for a VM instance. For more information about reviewing VM
 * instance details, see
 * [Listing all VM instance details for a specific patch
 * job](https://cloud.google.com/compute/docs/os-patch-management/manage-patch-jobs#list-instance-details).
 */
export interface PatchJobInstanceDetails {
  /** The instance name in the form `projects/* /zones/* /instances/*` */
  name: string;
  /**
   * The unique identifier for the instance. This identifier is
   * defined by the server.
   */
  instanceSystemId: string;
  /** Current state of instance patch. */
  state: Instance_PatchState;
  /** If the patch fails, this field provides the reason. */
  failureReason: string;
  /** The number of times the agent that the agent attempts to apply the patch. */
  attemptCount: Long;
}

/** A request message for listing patch jobs. */
export interface ListPatchJobsRequest {
  /** Required. In the form of `projects/*` */
  parent: string;
  /** The maximum number of instance status to return. */
  pageSize: number;
  /**
   * A pagination token returned from a previous call
   * that indicates where this listing should continue from.
   */
  pageToken: string;
  /**
   * If provided, this field specifies the criteria that must be met by patch
   * jobs to be included in the response.
   * Currently, filtering is only available on the patch_deployment field.
   */
  filter: string;
}

/** A response message for listing patch jobs. */
export interface ListPatchJobsResponse {
  /** The list of patch jobs. */
  patchJobs: PatchJob[];
  /** A pagination token that can be used to get the next page of results. */
  nextPageToken: string;
}

/**
 * A high level representation of a patch job that is either in progress
 * or has completed.
 *
 * Instance details are not included in the job. To paginate through instance
 * details, use ListPatchJobInstanceDetails.
 *
 * For more information about patch jobs, see
 * [Creating patch
 * jobs](https://cloud.google.com/compute/docs/os-patch-management/create-patch-job).
 */
export interface PatchJob {
  /**
   * Unique identifier for this patch job in the form
   * `projects/* /patchJobs/*`
   */
  name: string;
  /** Display name for this patch job. This is not a unique identifier. */
  displayName: string;
  /**
   * Description of the patch job. Length of the description is limited
   * to 1024 characters.
   */
  description: string;
  /** Time this patch job was created. */
  createTime:
    | Date
    | undefined;
  /** Last time this patch job was updated. */
  updateTime:
    | Date
    | undefined;
  /** The current state of the PatchJob. */
  state: PatchJob_State;
  /** Instances to patch. */
  instanceFilter:
    | PatchInstanceFilter
    | undefined;
  /** Patch configuration being applied. */
  patchConfig:
    | PatchConfig
    | undefined;
  /**
   * Duration of the patch job. After the duration ends, the
   * patch job times out.
   */
  duration:
    | Duration
    | undefined;
  /** Summary of instance details. */
  instanceDetailsSummary:
    | PatchJob_InstanceDetailsSummary
    | undefined;
  /**
   * If this patch job is a dry run, the agent reports that it has
   * finished without running any updates on the VM instance.
   */
  dryRun: boolean;
  /**
   * If this patch job failed, this message provides information about the
   * failure.
   */
  errorMessage: string;
  /**
   * Reflects the overall progress of the patch job in the range of
   * 0.0 being no progress to 100.0 being complete.
   */
  percentComplete: number;
  /** Output only. Name of the patch deployment that created this patch job. */
  patchDeployment: string;
  /** Rollout strategy being applied. */
  rollout: PatchRollout | undefined;
}

/**
 * Enumeration of the various states a patch job passes through as it
 * executes.
 */
export enum PatchJob_State {
  /** STATE_UNSPECIFIED - State must be specified. */
  STATE_UNSPECIFIED = 0,
  /** STARTED - The patch job was successfully initiated. */
  STARTED = 1,
  /** INSTANCE_LOOKUP - The patch job is looking up instances to run the patch on. */
  INSTANCE_LOOKUP = 2,
  /** PATCHING - Instances are being patched. */
  PATCHING = 3,
  /** SUCCEEDED - Patch job completed successfully. */
  SUCCEEDED = 4,
  /** COMPLETED_WITH_ERRORS - Patch job completed but there were errors. */
  COMPLETED_WITH_ERRORS = 5,
  /** CANCELED - The patch job was canceled. */
  CANCELED = 6,
  /** TIMED_OUT - The patch job timed out. */
  TIMED_OUT = 7,
  UNRECOGNIZED = -1,
}

export function patchJob_StateFromJSON(object: any): PatchJob_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return PatchJob_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTED":
      return PatchJob_State.STARTED;
    case 2:
    case "INSTANCE_LOOKUP":
      return PatchJob_State.INSTANCE_LOOKUP;
    case 3:
    case "PATCHING":
      return PatchJob_State.PATCHING;
    case 4:
    case "SUCCEEDED":
      return PatchJob_State.SUCCEEDED;
    case 5:
    case "COMPLETED_WITH_ERRORS":
      return PatchJob_State.COMPLETED_WITH_ERRORS;
    case 6:
    case "CANCELED":
      return PatchJob_State.CANCELED;
    case 7:
    case "TIMED_OUT":
      return PatchJob_State.TIMED_OUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PatchJob_State.UNRECOGNIZED;
  }
}

export function patchJob_StateToJSON(object: PatchJob_State): string {
  switch (object) {
    case PatchJob_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case PatchJob_State.STARTED:
      return "STARTED";
    case PatchJob_State.INSTANCE_LOOKUP:
      return "INSTANCE_LOOKUP";
    case PatchJob_State.PATCHING:
      return "PATCHING";
    case PatchJob_State.SUCCEEDED:
      return "SUCCEEDED";
    case PatchJob_State.COMPLETED_WITH_ERRORS:
      return "COMPLETED_WITH_ERRORS";
    case PatchJob_State.CANCELED:
      return "CANCELED";
    case PatchJob_State.TIMED_OUT:
      return "TIMED_OUT";
    case PatchJob_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A summary of the current patch state across all instances that this patch
 * job affects. Contains counts of instances in different states. These states
 * map to `InstancePatchState`. List patch job instance details to see the
 * specific states of each instance.
 */
export interface PatchJob_InstanceDetailsSummary {
  /** Number of instances pending patch job. */
  pendingInstanceCount: Long;
  /** Number of instances that are inactive. */
  inactiveInstanceCount: Long;
  /** Number of instances notified about patch job. */
  notifiedInstanceCount: Long;
  /** Number of instances that have started. */
  startedInstanceCount: Long;
  /** Number of instances that are downloading patches. */
  downloadingPatchesInstanceCount: Long;
  /** Number of instances that are applying patches. */
  applyingPatchesInstanceCount: Long;
  /** Number of instances rebooting. */
  rebootingInstanceCount: Long;
  /** Number of instances that have completed successfully. */
  succeededInstanceCount: Long;
  /** Number of instances that require reboot. */
  succeededRebootRequiredInstanceCount: Long;
  /** Number of instances that failed. */
  failedInstanceCount: Long;
  /** Number of instances that have acked and will start shortly. */
  ackedInstanceCount: Long;
  /** Number of instances that exceeded the time out while applying the patch. */
  timedOutInstanceCount: Long;
  /** Number of instances that are running the pre-patch step. */
  prePatchStepInstanceCount: Long;
  /** Number of instances that are running the post-patch step. */
  postPatchStepInstanceCount: Long;
  /**
   * Number of instances that do not appear to be running the agent. Check to
   * ensure that the agent is installed, running, and able to communicate with
   * the service.
   */
  noAgentDetectedInstanceCount: Long;
}

/**
 * Patch configuration specifications. Contains details on how to apply the
 * patch(es) to a VM instance.
 */
export interface PatchConfig {
  /** Post-patch reboot settings. */
  rebootConfig: PatchConfig_RebootConfig;
  /**
   * Apt update settings. Use this setting to override the default `apt` patch
   * rules.
   */
  apt:
    | AptSettings
    | undefined;
  /**
   * Yum update settings. Use this setting to override the default `yum` patch
   * rules.
   */
  yum:
    | YumSettings
    | undefined;
  /**
   * Goo update settings. Use this setting to override the default `goo` patch
   * rules.
   */
  goo:
    | GooSettings
    | undefined;
  /**
   * Zypper update settings. Use this setting to override the default `zypper`
   * patch rules.
   */
  zypper:
    | ZypperSettings
    | undefined;
  /** Windows update settings. Use this override the default windows patch rules. */
  windowsUpdate:
    | WindowsUpdateSettings
    | undefined;
  /** The `ExecStep` to run before the patch update. */
  preStep:
    | ExecStep
    | undefined;
  /** The `ExecStep` to run after the patch update. */
  postStep:
    | ExecStep
    | undefined;
  /** Allows the patch job to run on Managed instance groups (MIGs). */
  migInstancesAllowed: boolean;
}

/** Post-patch reboot settings. */
export enum PatchConfig_RebootConfig {
  /** REBOOT_CONFIG_UNSPECIFIED - The default behavior is DEFAULT. */
  REBOOT_CONFIG_UNSPECIFIED = 0,
  /**
   * DEFAULT - The agent decides if a reboot is necessary by checking signals such as
   * registry keys on Windows or `/var/run/reboot-required` on APT based
   * systems. On RPM based systems, a set of core system package install times
   * are compared with system boot time.
   */
  DEFAULT = 1,
  /** ALWAYS - Always reboot the machine after the update completes. */
  ALWAYS = 2,
  /** NEVER - Never reboot the machine after the update completes. */
  NEVER = 3,
  UNRECOGNIZED = -1,
}

export function patchConfig_RebootConfigFromJSON(object: any): PatchConfig_RebootConfig {
  switch (object) {
    case 0:
    case "REBOOT_CONFIG_UNSPECIFIED":
      return PatchConfig_RebootConfig.REBOOT_CONFIG_UNSPECIFIED;
    case 1:
    case "DEFAULT":
      return PatchConfig_RebootConfig.DEFAULT;
    case 2:
    case "ALWAYS":
      return PatchConfig_RebootConfig.ALWAYS;
    case 3:
    case "NEVER":
      return PatchConfig_RebootConfig.NEVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PatchConfig_RebootConfig.UNRECOGNIZED;
  }
}

export function patchConfig_RebootConfigToJSON(object: PatchConfig_RebootConfig): string {
  switch (object) {
    case PatchConfig_RebootConfig.REBOOT_CONFIG_UNSPECIFIED:
      return "REBOOT_CONFIG_UNSPECIFIED";
    case PatchConfig_RebootConfig.DEFAULT:
      return "DEFAULT";
    case PatchConfig_RebootConfig.ALWAYS:
      return "ALWAYS";
    case PatchConfig_RebootConfig.NEVER:
      return "NEVER";
    case PatchConfig_RebootConfig.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Namespace for instance state enums. */
export interface Instance {
}

/** Patch state of an instance. */
export enum Instance_PatchState {
  /** PATCH_STATE_UNSPECIFIED - Unspecified. */
  PATCH_STATE_UNSPECIFIED = 0,
  /** PENDING - The instance is not yet notified. */
  PENDING = 1,
  /** INACTIVE - Instance is inactive and cannot be patched. */
  INACTIVE = 2,
  /** NOTIFIED - The instance is notified that it should be patched. */
  NOTIFIED = 3,
  /** STARTED - The instance has started the patching process. */
  STARTED = 4,
  /** DOWNLOADING_PATCHES - The instance is downloading patches. */
  DOWNLOADING_PATCHES = 5,
  /** APPLYING_PATCHES - The instance is applying patches. */
  APPLYING_PATCHES = 6,
  /** REBOOTING - The instance is rebooting. */
  REBOOTING = 7,
  /** SUCCEEDED - The instance has completed applying patches. */
  SUCCEEDED = 8,
  /** SUCCEEDED_REBOOT_REQUIRED - The instance has completed applying patches but a reboot is required. */
  SUCCEEDED_REBOOT_REQUIRED = 9,
  /** FAILED - The instance has failed to apply the patch. */
  FAILED = 10,
  /** ACKED - The instance acked the notification and will start shortly. */
  ACKED = 11,
  /** TIMED_OUT - The instance exceeded the time out while applying the patch. */
  TIMED_OUT = 12,
  /** RUNNING_PRE_PATCH_STEP - The instance is running the pre-patch step. */
  RUNNING_PRE_PATCH_STEP = 13,
  /** RUNNING_POST_PATCH_STEP - The instance is running the post-patch step. */
  RUNNING_POST_PATCH_STEP = 14,
  /**
   * NO_AGENT_DETECTED - The service could not detect the presence of the agent. Check to ensure
   * that the agent is installed, running, and able to communicate with the
   * service.
   */
  NO_AGENT_DETECTED = 15,
  UNRECOGNIZED = -1,
}

export function instance_PatchStateFromJSON(object: any): Instance_PatchState {
  switch (object) {
    case 0:
    case "PATCH_STATE_UNSPECIFIED":
      return Instance_PatchState.PATCH_STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Instance_PatchState.PENDING;
    case 2:
    case "INACTIVE":
      return Instance_PatchState.INACTIVE;
    case 3:
    case "NOTIFIED":
      return Instance_PatchState.NOTIFIED;
    case 4:
    case "STARTED":
      return Instance_PatchState.STARTED;
    case 5:
    case "DOWNLOADING_PATCHES":
      return Instance_PatchState.DOWNLOADING_PATCHES;
    case 6:
    case "APPLYING_PATCHES":
      return Instance_PatchState.APPLYING_PATCHES;
    case 7:
    case "REBOOTING":
      return Instance_PatchState.REBOOTING;
    case 8:
    case "SUCCEEDED":
      return Instance_PatchState.SUCCEEDED;
    case 9:
    case "SUCCEEDED_REBOOT_REQUIRED":
      return Instance_PatchState.SUCCEEDED_REBOOT_REQUIRED;
    case 10:
    case "FAILED":
      return Instance_PatchState.FAILED;
    case 11:
    case "ACKED":
      return Instance_PatchState.ACKED;
    case 12:
    case "TIMED_OUT":
      return Instance_PatchState.TIMED_OUT;
    case 13:
    case "RUNNING_PRE_PATCH_STEP":
      return Instance_PatchState.RUNNING_PRE_PATCH_STEP;
    case 14:
    case "RUNNING_POST_PATCH_STEP":
      return Instance_PatchState.RUNNING_POST_PATCH_STEP;
    case 15:
    case "NO_AGENT_DETECTED":
      return Instance_PatchState.NO_AGENT_DETECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_PatchState.UNRECOGNIZED;
  }
}

export function instance_PatchStateToJSON(object: Instance_PatchState): string {
  switch (object) {
    case Instance_PatchState.PATCH_STATE_UNSPECIFIED:
      return "PATCH_STATE_UNSPECIFIED";
    case Instance_PatchState.PENDING:
      return "PENDING";
    case Instance_PatchState.INACTIVE:
      return "INACTIVE";
    case Instance_PatchState.NOTIFIED:
      return "NOTIFIED";
    case Instance_PatchState.STARTED:
      return "STARTED";
    case Instance_PatchState.DOWNLOADING_PATCHES:
      return "DOWNLOADING_PATCHES";
    case Instance_PatchState.APPLYING_PATCHES:
      return "APPLYING_PATCHES";
    case Instance_PatchState.REBOOTING:
      return "REBOOTING";
    case Instance_PatchState.SUCCEEDED:
      return "SUCCEEDED";
    case Instance_PatchState.SUCCEEDED_REBOOT_REQUIRED:
      return "SUCCEEDED_REBOOT_REQUIRED";
    case Instance_PatchState.FAILED:
      return "FAILED";
    case Instance_PatchState.ACKED:
      return "ACKED";
    case Instance_PatchState.TIMED_OUT:
      return "TIMED_OUT";
    case Instance_PatchState.RUNNING_PRE_PATCH_STEP:
      return "RUNNING_PRE_PATCH_STEP";
    case Instance_PatchState.RUNNING_POST_PATCH_STEP:
      return "RUNNING_POST_PATCH_STEP";
    case Instance_PatchState.NO_AGENT_DETECTED:
      return "NO_AGENT_DETECTED";
    case Instance_PatchState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message for canceling a patch job. */
export interface CancelPatchJobRequest {
  /** Required. Name of the patch in the form `projects/* /patchJobs/*` */
  name: string;
}

/**
 * Apt patching is completed by executing `apt-get update && apt-get
 * upgrade`. Additional options can be set to control how this is executed.
 */
export interface AptSettings {
  /**
   * By changing the type to DIST, the patching is performed
   * using `apt-get dist-upgrade` instead.
   */
  type: AptSettings_Type;
  /** List of packages to exclude from update. These packages will be excluded */
  excludes: string[];
  /**
   * An exclusive list of packages to be updated. These are the only packages
   * that will be updated. If these packages are not installed, they will be
   * ignored. This field cannot be specified with any other patch configuration
   * fields.
   */
  exclusivePackages: string[];
}

/** Apt patch type. */
export enum AptSettings_Type {
  /** TYPE_UNSPECIFIED - By default, upgrade will be performed. */
  TYPE_UNSPECIFIED = 0,
  /** DIST - Runs `apt-get dist-upgrade`. */
  DIST = 1,
  /** UPGRADE - Runs `apt-get upgrade`. */
  UPGRADE = 2,
  UNRECOGNIZED = -1,
}

export function aptSettings_TypeFromJSON(object: any): AptSettings_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return AptSettings_Type.TYPE_UNSPECIFIED;
    case 1:
    case "DIST":
      return AptSettings_Type.DIST;
    case 2:
    case "UPGRADE":
      return AptSettings_Type.UPGRADE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AptSettings_Type.UNRECOGNIZED;
  }
}

export function aptSettings_TypeToJSON(object: AptSettings_Type): string {
  switch (object) {
    case AptSettings_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case AptSettings_Type.DIST:
      return "DIST";
    case AptSettings_Type.UPGRADE:
      return "UPGRADE";
    case AptSettings_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Yum patching is performed by executing `yum update`. Additional options
 * can be set to control how this is executed.
 *
 * Note that not all settings are supported on all platforms.
 */
export interface YumSettings {
  /**
   * Adds the `--security` flag to `yum update`. Not supported on
   * all platforms.
   */
  security: boolean;
  /** Will cause patch to run `yum update-minimal` instead. */
  minimal: boolean;
  /**
   * List of packages to exclude from update. These packages are excluded by
   * using the yum `--exclude` flag.
   */
  excludes: string[];
  /**
   * An exclusive list of packages to be updated. These are the only packages
   * that will be updated. If these packages are not installed, they will be
   * ignored. This field must not be specified with any other patch
   * configuration fields.
   */
  exclusivePackages: string[];
}

/** Googet patching is performed by running `googet update`. */
export interface GooSettings {
}

/**
 * Zypper patching is performed by running `zypper patch`.
 * See also https://en.opensuse.org/SDB:Zypper_manual.
 */
export interface ZypperSettings {
  /** Adds the `--with-optional` flag to `zypper patch`. */
  withOptional: boolean;
  /** Adds the `--with-update` flag, to `zypper patch`. */
  withUpdate: boolean;
  /**
   * Install only patches with these categories.
   * Common categories include security, recommended, and feature.
   */
  categories: string[];
  /**
   * Install only patches with these severities.
   * Common severities include critical, important, moderate, and low.
   */
  severities: string[];
  /** List of patches to exclude from update. */
  excludes: string[];
  /**
   * An exclusive list of patches to be updated. These are the only patches
   * that will be installed using 'zypper patch patch:<patch_name>' command.
   * This field must not be used with any other patch configuration fields.
   */
  exclusivePatches: string[];
}

/** Windows patching is performed using the Windows Update Agent. */
export interface WindowsUpdateSettings {
  /**
   * Only apply updates of these windows update classifications. If empty, all
   * updates are applied.
   */
  classifications: WindowsUpdateSettings_Classification[];
  /** List of KBs to exclude from update. */
  excludes: string[];
  /**
   * An exclusive list of kbs to be updated. These are the only patches
   * that will be updated. This field must not be used with other
   * patch configurations.
   */
  exclusivePatches: string[];
}

/**
 * Microsoft Windows update classifications as defined in
 * [1]
 * https://support.microsoft.com/en-us/help/824684/description-of-the-standard-terminology-that-is-used-to-describe-micro
 */
export enum WindowsUpdateSettings_Classification {
  /** CLASSIFICATION_UNSPECIFIED - Invalid. If classifications are included, they must be specified. */
  CLASSIFICATION_UNSPECIFIED = 0,
  /**
   * CRITICAL - "A widely released fix for a specific problem that addresses a critical,
   * non-security-related bug." [1]
   */
  CRITICAL = 1,
  /**
   * SECURITY - "A widely released fix for a product-specific, security-related
   * vulnerability. Security vulnerabilities are rated by their severity. The
   * severity rating is indicated in the Microsoft security bulletin as
   * critical, important, moderate, or low." [1]
   */
  SECURITY = 2,
  /**
   * DEFINITION - "A widely released and frequent software update that contains additions
   * to a product's definition database. Definition databases are often used
   * to detect objects that have specific attributes, such as malicious code,
   * phishing websites, or junk mail." [1]
   */
  DEFINITION = 3,
  /** DRIVER - "Software that controls the input and output of a device." [1] */
  DRIVER = 4,
  /**
   * FEATURE_PACK - "New product functionality that is first distributed outside the context
   * of a product release and that is typically included in the next full
   * product release." [1]
   */
  FEATURE_PACK = 5,
  /**
   * SERVICE_PACK - "A tested, cumulative set of all hotfixes, security updates, critical
   * updates, and updates. Additionally, service packs may contain additional
   * fixes for problems that are found internally since the release of the
   * product. Service packs my also contain a limited number of
   * customer-requested design changes or features." [1]
   */
  SERVICE_PACK = 6,
  /** TOOL - "A utility or feature that helps complete a task or set of tasks." [1] */
  TOOL = 7,
  /**
   * UPDATE_ROLLUP - "A tested, cumulative set of hotfixes, security updates, critical
   * updates, and updates that are packaged together for easy deployment. A
   * rollup generally targets a specific area, such as security, or a
   * component of a product, such as Internet Information Services (IIS)." [1]
   */
  UPDATE_ROLLUP = 8,
  /**
   * UPDATE - "A widely released fix for a specific problem. An update addresses a
   * noncritical, non-security-related bug." [1]
   */
  UPDATE = 9,
  UNRECOGNIZED = -1,
}

export function windowsUpdateSettings_ClassificationFromJSON(object: any): WindowsUpdateSettings_Classification {
  switch (object) {
    case 0:
    case "CLASSIFICATION_UNSPECIFIED":
      return WindowsUpdateSettings_Classification.CLASSIFICATION_UNSPECIFIED;
    case 1:
    case "CRITICAL":
      return WindowsUpdateSettings_Classification.CRITICAL;
    case 2:
    case "SECURITY":
      return WindowsUpdateSettings_Classification.SECURITY;
    case 3:
    case "DEFINITION":
      return WindowsUpdateSettings_Classification.DEFINITION;
    case 4:
    case "DRIVER":
      return WindowsUpdateSettings_Classification.DRIVER;
    case 5:
    case "FEATURE_PACK":
      return WindowsUpdateSettings_Classification.FEATURE_PACK;
    case 6:
    case "SERVICE_PACK":
      return WindowsUpdateSettings_Classification.SERVICE_PACK;
    case 7:
    case "TOOL":
      return WindowsUpdateSettings_Classification.TOOL;
    case 8:
    case "UPDATE_ROLLUP":
      return WindowsUpdateSettings_Classification.UPDATE_ROLLUP;
    case 9:
    case "UPDATE":
      return WindowsUpdateSettings_Classification.UPDATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WindowsUpdateSettings_Classification.UNRECOGNIZED;
  }
}

export function windowsUpdateSettings_ClassificationToJSON(object: WindowsUpdateSettings_Classification): string {
  switch (object) {
    case WindowsUpdateSettings_Classification.CLASSIFICATION_UNSPECIFIED:
      return "CLASSIFICATION_UNSPECIFIED";
    case WindowsUpdateSettings_Classification.CRITICAL:
      return "CRITICAL";
    case WindowsUpdateSettings_Classification.SECURITY:
      return "SECURITY";
    case WindowsUpdateSettings_Classification.DEFINITION:
      return "DEFINITION";
    case WindowsUpdateSettings_Classification.DRIVER:
      return "DRIVER";
    case WindowsUpdateSettings_Classification.FEATURE_PACK:
      return "FEATURE_PACK";
    case WindowsUpdateSettings_Classification.SERVICE_PACK:
      return "SERVICE_PACK";
    case WindowsUpdateSettings_Classification.TOOL:
      return "TOOL";
    case WindowsUpdateSettings_Classification.UPDATE_ROLLUP:
      return "UPDATE_ROLLUP";
    case WindowsUpdateSettings_Classification.UPDATE:
      return "UPDATE";
    case WindowsUpdateSettings_Classification.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A step that runs an executable for a PatchJob. */
export interface ExecStep {
  /** The ExecStepConfig for all Linux VMs targeted by the PatchJob. */
  linuxExecStepConfig:
    | ExecStepConfig
    | undefined;
  /** The ExecStepConfig for all Windows VMs targeted by the PatchJob. */
  windowsExecStepConfig: ExecStepConfig | undefined;
}

/** Common configurations for an ExecStep. */
export interface ExecStepConfig {
  /** An absolute path to the executable on the VM. */
  localPath?:
    | string
    | undefined;
  /** A Cloud Storage object containing the executable. */
  gcsObject?:
    | GcsObject
    | undefined;
  /**
   * Defaults to [0]. A list of possible return values that the
   * execution can return to indicate a success.
   */
  allowedSuccessCodes: number[];
  /**
   * The script interpreter to use to run the script. If no interpreter is
   * specified the script will be executed directly, which will likely
   * only succeed for scripts with [shebang lines]
   * (https://en.wikipedia.org/wiki/Shebang_\(Unix\)).
   */
  interpreter: ExecStepConfig_Interpreter;
}

/** The interpreter used to execute the a file. */
export enum ExecStepConfig_Interpreter {
  /**
   * INTERPRETER_UNSPECIFIED - Invalid for a Windows ExecStepConfig. For a Linux ExecStepConfig, the
   * interpreter will be parsed from the shebang line of the script if
   * unspecified.
   */
  INTERPRETER_UNSPECIFIED = 0,
  /**
   * SHELL - Indicates that the script is run with `/bin/sh` on Linux and `cmd`
   * on Windows.
   */
  SHELL = 1,
  /**
   * POWERSHELL - Indicates that the file is run with PowerShell flags
   * `-NonInteractive`, `-NoProfile`, and `-ExecutionPolicy Bypass`.
   */
  POWERSHELL = 2,
  UNRECOGNIZED = -1,
}

export function execStepConfig_InterpreterFromJSON(object: any): ExecStepConfig_Interpreter {
  switch (object) {
    case 0:
    case "INTERPRETER_UNSPECIFIED":
      return ExecStepConfig_Interpreter.INTERPRETER_UNSPECIFIED;
    case 1:
    case "SHELL":
      return ExecStepConfig_Interpreter.SHELL;
    case 2:
    case "POWERSHELL":
      return ExecStepConfig_Interpreter.POWERSHELL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecStepConfig_Interpreter.UNRECOGNIZED;
  }
}

export function execStepConfig_InterpreterToJSON(object: ExecStepConfig_Interpreter): string {
  switch (object) {
    case ExecStepConfig_Interpreter.INTERPRETER_UNSPECIFIED:
      return "INTERPRETER_UNSPECIFIED";
    case ExecStepConfig_Interpreter.SHELL:
      return "SHELL";
    case ExecStepConfig_Interpreter.POWERSHELL:
      return "POWERSHELL";
    case ExecStepConfig_Interpreter.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Cloud Storage object representation. */
export interface GcsObject {
  /** Required. Bucket of the Cloud Storage object. */
  bucket: string;
  /** Required. Name of the Cloud Storage object. */
  object: string;
  /**
   * Required. Generation number of the Cloud Storage object. This is used to
   * ensure that the ExecStep specified by this PatchJob does not change.
   */
  generationNumber: Long;
}

/**
 * A filter to target VM instances for patching. The targeted
 * VMs must meet all criteria specified. So if both labels and zones are
 * specified, the patch job targets only VMs with those labels and in those
 * zones.
 */
export interface PatchInstanceFilter {
  /**
   * Target all VM instances in the project. If true, no other criteria is
   * permitted.
   */
  all: boolean;
  /**
   * Targets VM instances matching ANY of these GroupLabels. This allows
   * targeting of disparate groups of VM instances.
   */
  groupLabels: PatchInstanceFilter_GroupLabel[];
  /**
   * Targets VM instances in ANY of these zones. Leave empty to target VM
   * instances in any zone.
   */
  zones: string[];
  /**
   * Targets any of the VM instances specified. Instances are specified by their
   * URI in the form `zones/[ZONE]/instances/[INSTANCE_NAME]`,
   * `projects/[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`, or
   * `https://www.googleapis.com/compute/v1/projects/[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`
   */
  instances: string[];
  /**
   * Targets VMs whose name starts with one of these prefixes. Similar to
   * labels, this is another way to group VMs when targeting configs, for
   * example prefix="prod-".
   */
  instanceNamePrefixes: string[];
}

/**
 * Targets a group of VM instances by using their [assigned
 * labels](https://cloud.google.com/compute/docs/labeling-resources). Labels
 * are key-value pairs. A `GroupLabel` is a combination of labels
 * that is used to target VMs for a patch job.
 *
 * For example, a patch job can target VMs that have the following
 * `GroupLabel`: `{"env":"test", "app":"web"}`. This means that the patch job
 * is applied to VMs that have both the labels `env=test` and `app=web`.
 */
export interface PatchInstanceFilter_GroupLabel {
  /**
   * Compute Engine instance labels that must be present for a VM
   * instance to be targeted by this filter.
   */
  labels: { [key: string]: string };
}

export interface PatchInstanceFilter_GroupLabel_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Patch rollout configuration specifications. Contains details on the
 * concurrency control when applying patch(es) to all targeted VMs.
 */
export interface PatchRollout {
  /** Mode of the patch rollout. */
  mode: PatchRollout_Mode;
  /**
   * The maximum number (or percentage) of VMs per zone to disrupt at any given
   * moment. The number of VMs calculated from multiplying the percentage by the
   * total number of VMs in a zone is rounded up.
   *
   * During patching, a VM is considered disrupted from the time the agent is
   * notified to begin until patching has completed. This disruption time
   * includes the time to complete reboot and any post-patch steps.
   *
   * A VM contributes to the disruption budget if its patching operation fails
   * either when applying the patches, running pre or post patch steps, or if it
   * fails to respond with a success notification before timing out. VMs that
   * are not running or do not have an active agent do not count toward this
   * disruption budget.
   *
   * For zone-by-zone rollouts, if the disruption budget in a zone is exceeded,
   * the patch job stops, because continuing to the next zone requires
   * completion of the patch process in the previous zone.
   *
   * For example, if the disruption budget has a fixed value of `10`, and 8 VMs
   * fail to patch in the current zone, the patch job continues to patch 2 VMs
   * at a time until the zone is completed. When that zone is completed
   * successfully, patching begins with 10 VMs at a time in the next zone. If 10
   * VMs in the next zone fail to patch, the patch job stops.
   */
  disruptionBudget: FixedOrPercent | undefined;
}

/** Type of the rollout. */
export enum PatchRollout_Mode {
  /** MODE_UNSPECIFIED - Mode must be specified. */
  MODE_UNSPECIFIED = 0,
  /**
   * ZONE_BY_ZONE - Patches are applied one zone at a time. The patch job begins in the
   * region with the lowest number of targeted VMs. Within the region,
   * patching begins in the zone with the lowest number of targeted VMs. If
   * multiple regions (or zones within a region) have the same number of
   * targeted VMs, a tie-breaker is achieved by sorting the regions or zones
   * in alphabetical order.
   */
  ZONE_BY_ZONE = 1,
  /** CONCURRENT_ZONES - Patches are applied to VMs in all zones at the same time. */
  CONCURRENT_ZONES = 2,
  UNRECOGNIZED = -1,
}

export function patchRollout_ModeFromJSON(object: any): PatchRollout_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return PatchRollout_Mode.MODE_UNSPECIFIED;
    case 1:
    case "ZONE_BY_ZONE":
      return PatchRollout_Mode.ZONE_BY_ZONE;
    case 2:
    case "CONCURRENT_ZONES":
      return PatchRollout_Mode.CONCURRENT_ZONES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PatchRollout_Mode.UNRECOGNIZED;
  }
}

export function patchRollout_ModeToJSON(object: PatchRollout_Mode): string {
  switch (object) {
    case PatchRollout_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case PatchRollout_Mode.ZONE_BY_ZONE:
      return "ZONE_BY_ZONE";
    case PatchRollout_Mode.CONCURRENT_ZONES:
      return "CONCURRENT_ZONES";
    case PatchRollout_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseExecutePatchJobRequest(): ExecutePatchJobRequest {
  return {
    parent: "",
    description: "",
    instanceFilter: undefined,
    patchConfig: undefined,
    duration: undefined,
    dryRun: false,
    displayName: "",
    rollout: undefined,
  };
}

export const ExecutePatchJobRequest: MessageFns<ExecutePatchJobRequest> = {
  encode(message: ExecutePatchJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.instanceFilter !== undefined) {
      PatchInstanceFilter.encode(message.instanceFilter, writer.uint32(58).fork()).join();
    }
    if (message.patchConfig !== undefined) {
      PatchConfig.encode(message.patchConfig, writer.uint32(34).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(42).fork()).join();
    }
    if (message.dryRun !== false) {
      writer.uint32(48).bool(message.dryRun);
    }
    if (message.displayName !== "") {
      writer.uint32(66).string(message.displayName);
    }
    if (message.rollout !== undefined) {
      PatchRollout.encode(message.rollout, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutePatchJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutePatchJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.instanceFilter = PatchInstanceFilter.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.patchConfig = PatchConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.rollout = PatchRollout.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutePatchJobRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      instanceFilter: isSet(object.instanceFilter) ? PatchInstanceFilter.fromJSON(object.instanceFilter) : undefined,
      patchConfig: isSet(object.patchConfig) ? PatchConfig.fromJSON(object.patchConfig) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      dryRun: isSet(object.dryRun) ? globalThis.Boolean(object.dryRun) : false,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      rollout: isSet(object.rollout) ? PatchRollout.fromJSON(object.rollout) : undefined,
    };
  },

  toJSON(message: ExecutePatchJobRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.instanceFilter !== undefined) {
      obj.instanceFilter = PatchInstanceFilter.toJSON(message.instanceFilter);
    }
    if (message.patchConfig !== undefined) {
      obj.patchConfig = PatchConfig.toJSON(message.patchConfig);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.rollout !== undefined) {
      obj.rollout = PatchRollout.toJSON(message.rollout);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutePatchJobRequest>): ExecutePatchJobRequest {
    return ExecutePatchJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutePatchJobRequest>): ExecutePatchJobRequest {
    const message = createBaseExecutePatchJobRequest();
    message.parent = object.parent ?? "";
    message.description = object.description ?? "";
    message.instanceFilter = (object.instanceFilter !== undefined && object.instanceFilter !== null)
      ? PatchInstanceFilter.fromPartial(object.instanceFilter)
      : undefined;
    message.patchConfig = (object.patchConfig !== undefined && object.patchConfig !== null)
      ? PatchConfig.fromPartial(object.patchConfig)
      : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.dryRun = object.dryRun ?? false;
    message.displayName = object.displayName ?? "";
    message.rollout = (object.rollout !== undefined && object.rollout !== null)
      ? PatchRollout.fromPartial(object.rollout)
      : undefined;
    return message;
  },
};

function createBaseGetPatchJobRequest(): GetPatchJobRequest {
  return { name: "" };
}

export const GetPatchJobRequest: MessageFns<GetPatchJobRequest> = {
  encode(message: GetPatchJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPatchJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPatchJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPatchJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetPatchJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPatchJobRequest>): GetPatchJobRequest {
    return GetPatchJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPatchJobRequest>): GetPatchJobRequest {
    const message = createBaseGetPatchJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListPatchJobInstanceDetailsRequest(): ListPatchJobInstanceDetailsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListPatchJobInstanceDetailsRequest: MessageFns<ListPatchJobInstanceDetailsRequest> = {
  encode(message: ListPatchJobInstanceDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPatchJobInstanceDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPatchJobInstanceDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPatchJobInstanceDetailsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListPatchJobInstanceDetailsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPatchJobInstanceDetailsRequest>): ListPatchJobInstanceDetailsRequest {
    return ListPatchJobInstanceDetailsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPatchJobInstanceDetailsRequest>): ListPatchJobInstanceDetailsRequest {
    const message = createBaseListPatchJobInstanceDetailsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListPatchJobInstanceDetailsResponse(): ListPatchJobInstanceDetailsResponse {
  return { patchJobInstanceDetails: [], nextPageToken: "" };
}

export const ListPatchJobInstanceDetailsResponse: MessageFns<ListPatchJobInstanceDetailsResponse> = {
  encode(message: ListPatchJobInstanceDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.patchJobInstanceDetails) {
      PatchJobInstanceDetails.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPatchJobInstanceDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPatchJobInstanceDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.patchJobInstanceDetails.push(PatchJobInstanceDetails.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPatchJobInstanceDetailsResponse {
    return {
      patchJobInstanceDetails: globalThis.Array.isArray(object?.patchJobInstanceDetails)
        ? object.patchJobInstanceDetails.map((e: any) => PatchJobInstanceDetails.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPatchJobInstanceDetailsResponse): unknown {
    const obj: any = {};
    if (message.patchJobInstanceDetails?.length) {
      obj.patchJobInstanceDetails = message.patchJobInstanceDetails.map((e) => PatchJobInstanceDetails.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPatchJobInstanceDetailsResponse>): ListPatchJobInstanceDetailsResponse {
    return ListPatchJobInstanceDetailsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPatchJobInstanceDetailsResponse>): ListPatchJobInstanceDetailsResponse {
    const message = createBaseListPatchJobInstanceDetailsResponse();
    message.patchJobInstanceDetails =
      object.patchJobInstanceDetails?.map((e) => PatchJobInstanceDetails.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBasePatchJobInstanceDetails(): PatchJobInstanceDetails {
  return { name: "", instanceSystemId: "", state: 0, failureReason: "", attemptCount: Long.ZERO };
}

export const PatchJobInstanceDetails: MessageFns<PatchJobInstanceDetails> = {
  encode(message: PatchJobInstanceDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.instanceSystemId !== "") {
      writer.uint32(18).string(message.instanceSystemId);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.failureReason !== "") {
      writer.uint32(34).string(message.failureReason);
    }
    if (!message.attemptCount.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.attemptCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchJobInstanceDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchJobInstanceDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceSystemId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.failureReason = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.attemptCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchJobInstanceDetails {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      instanceSystemId: isSet(object.instanceSystemId) ? globalThis.String(object.instanceSystemId) : "",
      state: isSet(object.state) ? instance_PatchStateFromJSON(object.state) : 0,
      failureReason: isSet(object.failureReason) ? globalThis.String(object.failureReason) : "",
      attemptCount: isSet(object.attemptCount) ? Long.fromValue(object.attemptCount) : Long.ZERO,
    };
  },

  toJSON(message: PatchJobInstanceDetails): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.instanceSystemId !== "") {
      obj.instanceSystemId = message.instanceSystemId;
    }
    if (message.state !== 0) {
      obj.state = instance_PatchStateToJSON(message.state);
    }
    if (message.failureReason !== "") {
      obj.failureReason = message.failureReason;
    }
    if (!message.attemptCount.equals(Long.ZERO)) {
      obj.attemptCount = (message.attemptCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<PatchJobInstanceDetails>): PatchJobInstanceDetails {
    return PatchJobInstanceDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PatchJobInstanceDetails>): PatchJobInstanceDetails {
    const message = createBasePatchJobInstanceDetails();
    message.name = object.name ?? "";
    message.instanceSystemId = object.instanceSystemId ?? "";
    message.state = object.state ?? 0;
    message.failureReason = object.failureReason ?? "";
    message.attemptCount = (object.attemptCount !== undefined && object.attemptCount !== null)
      ? Long.fromValue(object.attemptCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseListPatchJobsRequest(): ListPatchJobsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListPatchJobsRequest: MessageFns<ListPatchJobsRequest> = {
  encode(message: ListPatchJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPatchJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPatchJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPatchJobsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListPatchJobsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPatchJobsRequest>): ListPatchJobsRequest {
    return ListPatchJobsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPatchJobsRequest>): ListPatchJobsRequest {
    const message = createBaseListPatchJobsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListPatchJobsResponse(): ListPatchJobsResponse {
  return { patchJobs: [], nextPageToken: "" };
}

export const ListPatchJobsResponse: MessageFns<ListPatchJobsResponse> = {
  encode(message: ListPatchJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.patchJobs) {
      PatchJob.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPatchJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPatchJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.patchJobs.push(PatchJob.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPatchJobsResponse {
    return {
      patchJobs: globalThis.Array.isArray(object?.patchJobs)
        ? object.patchJobs.map((e: any) => PatchJob.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPatchJobsResponse): unknown {
    const obj: any = {};
    if (message.patchJobs?.length) {
      obj.patchJobs = message.patchJobs.map((e) => PatchJob.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPatchJobsResponse>): ListPatchJobsResponse {
    return ListPatchJobsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPatchJobsResponse>): ListPatchJobsResponse {
    const message = createBaseListPatchJobsResponse();
    message.patchJobs = object.patchJobs?.map((e) => PatchJob.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBasePatchJob(): PatchJob {
  return {
    name: "",
    displayName: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    state: 0,
    instanceFilter: undefined,
    patchConfig: undefined,
    duration: undefined,
    instanceDetailsSummary: undefined,
    dryRun: false,
    errorMessage: "",
    percentComplete: 0,
    patchDeployment: "",
    rollout: undefined,
  };
}

export const PatchJob: MessageFns<PatchJob> = {
  encode(message: PatchJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(114).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.instanceFilter !== undefined) {
      PatchInstanceFilter.encode(message.instanceFilter, writer.uint32(106).fork()).join();
    }
    if (message.patchConfig !== undefined) {
      PatchConfig.encode(message.patchConfig, writer.uint32(58).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(66).fork()).join();
    }
    if (message.instanceDetailsSummary !== undefined) {
      PatchJob_InstanceDetailsSummary.encode(message.instanceDetailsSummary, writer.uint32(74).fork()).join();
    }
    if (message.dryRun !== false) {
      writer.uint32(80).bool(message.dryRun);
    }
    if (message.errorMessage !== "") {
      writer.uint32(90).string(message.errorMessage);
    }
    if (message.percentComplete !== 0) {
      writer.uint32(97).double(message.percentComplete);
    }
    if (message.patchDeployment !== "") {
      writer.uint32(122).string(message.patchDeployment);
    }
    if (message.rollout !== undefined) {
      PatchRollout.encode(message.rollout, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.instanceFilter = PatchInstanceFilter.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.patchConfig = PatchConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.instanceDetailsSummary = PatchJob_InstanceDetailsSummary.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 12:
          if (tag !== 97) {
            break;
          }

          message.percentComplete = reader.double();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.patchDeployment = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.rollout = PatchRollout.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchJob {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? patchJob_StateFromJSON(object.state) : 0,
      instanceFilter: isSet(object.instanceFilter) ? PatchInstanceFilter.fromJSON(object.instanceFilter) : undefined,
      patchConfig: isSet(object.patchConfig) ? PatchConfig.fromJSON(object.patchConfig) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      instanceDetailsSummary: isSet(object.instanceDetailsSummary)
        ? PatchJob_InstanceDetailsSummary.fromJSON(object.instanceDetailsSummary)
        : undefined,
      dryRun: isSet(object.dryRun) ? globalThis.Boolean(object.dryRun) : false,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      percentComplete: isSet(object.percentComplete) ? globalThis.Number(object.percentComplete) : 0,
      patchDeployment: isSet(object.patchDeployment) ? globalThis.String(object.patchDeployment) : "",
      rollout: isSet(object.rollout) ? PatchRollout.fromJSON(object.rollout) : undefined,
    };
  },

  toJSON(message: PatchJob): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = patchJob_StateToJSON(message.state);
    }
    if (message.instanceFilter !== undefined) {
      obj.instanceFilter = PatchInstanceFilter.toJSON(message.instanceFilter);
    }
    if (message.patchConfig !== undefined) {
      obj.patchConfig = PatchConfig.toJSON(message.patchConfig);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.instanceDetailsSummary !== undefined) {
      obj.instanceDetailsSummary = PatchJob_InstanceDetailsSummary.toJSON(message.instanceDetailsSummary);
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.percentComplete !== 0) {
      obj.percentComplete = message.percentComplete;
    }
    if (message.patchDeployment !== "") {
      obj.patchDeployment = message.patchDeployment;
    }
    if (message.rollout !== undefined) {
      obj.rollout = PatchRollout.toJSON(message.rollout);
    }
    return obj;
  },

  create(base?: DeepPartial<PatchJob>): PatchJob {
    return PatchJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PatchJob>): PatchJob {
    const message = createBasePatchJob();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    message.instanceFilter = (object.instanceFilter !== undefined && object.instanceFilter !== null)
      ? PatchInstanceFilter.fromPartial(object.instanceFilter)
      : undefined;
    message.patchConfig = (object.patchConfig !== undefined && object.patchConfig !== null)
      ? PatchConfig.fromPartial(object.patchConfig)
      : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.instanceDetailsSummary =
      (object.instanceDetailsSummary !== undefined && object.instanceDetailsSummary !== null)
        ? PatchJob_InstanceDetailsSummary.fromPartial(object.instanceDetailsSummary)
        : undefined;
    message.dryRun = object.dryRun ?? false;
    message.errorMessage = object.errorMessage ?? "";
    message.percentComplete = object.percentComplete ?? 0;
    message.patchDeployment = object.patchDeployment ?? "";
    message.rollout = (object.rollout !== undefined && object.rollout !== null)
      ? PatchRollout.fromPartial(object.rollout)
      : undefined;
    return message;
  },
};

function createBasePatchJob_InstanceDetailsSummary(): PatchJob_InstanceDetailsSummary {
  return {
    pendingInstanceCount: Long.ZERO,
    inactiveInstanceCount: Long.ZERO,
    notifiedInstanceCount: Long.ZERO,
    startedInstanceCount: Long.ZERO,
    downloadingPatchesInstanceCount: Long.ZERO,
    applyingPatchesInstanceCount: Long.ZERO,
    rebootingInstanceCount: Long.ZERO,
    succeededInstanceCount: Long.ZERO,
    succeededRebootRequiredInstanceCount: Long.ZERO,
    failedInstanceCount: Long.ZERO,
    ackedInstanceCount: Long.ZERO,
    timedOutInstanceCount: Long.ZERO,
    prePatchStepInstanceCount: Long.ZERO,
    postPatchStepInstanceCount: Long.ZERO,
    noAgentDetectedInstanceCount: Long.ZERO,
  };
}

export const PatchJob_InstanceDetailsSummary: MessageFns<PatchJob_InstanceDetailsSummary> = {
  encode(message: PatchJob_InstanceDetailsSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.pendingInstanceCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.pendingInstanceCount.toString());
    }
    if (!message.inactiveInstanceCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.inactiveInstanceCount.toString());
    }
    if (!message.notifiedInstanceCount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.notifiedInstanceCount.toString());
    }
    if (!message.startedInstanceCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.startedInstanceCount.toString());
    }
    if (!message.downloadingPatchesInstanceCount.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.downloadingPatchesInstanceCount.toString());
    }
    if (!message.applyingPatchesInstanceCount.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.applyingPatchesInstanceCount.toString());
    }
    if (!message.rebootingInstanceCount.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.rebootingInstanceCount.toString());
    }
    if (!message.succeededInstanceCount.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.succeededInstanceCount.toString());
    }
    if (!message.succeededRebootRequiredInstanceCount.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.succeededRebootRequiredInstanceCount.toString());
    }
    if (!message.failedInstanceCount.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.failedInstanceCount.toString());
    }
    if (!message.ackedInstanceCount.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.ackedInstanceCount.toString());
    }
    if (!message.timedOutInstanceCount.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.timedOutInstanceCount.toString());
    }
    if (!message.prePatchStepInstanceCount.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.prePatchStepInstanceCount.toString());
    }
    if (!message.postPatchStepInstanceCount.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.postPatchStepInstanceCount.toString());
    }
    if (!message.noAgentDetectedInstanceCount.equals(Long.ZERO)) {
      writer.uint32(120).int64(message.noAgentDetectedInstanceCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchJob_InstanceDetailsSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchJob_InstanceDetailsSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pendingInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inactiveInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.notifiedInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.startedInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.downloadingPatchesInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.applyingPatchesInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.rebootingInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.succeededInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.succeededRebootRequiredInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.failedInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.ackedInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.timedOutInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.prePatchStepInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.postPatchStepInstanceCount = Long.fromString(reader.int64().toString());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.noAgentDetectedInstanceCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchJob_InstanceDetailsSummary {
    return {
      pendingInstanceCount: isSet(object.pendingInstanceCount)
        ? Long.fromValue(object.pendingInstanceCount)
        : Long.ZERO,
      inactiveInstanceCount: isSet(object.inactiveInstanceCount)
        ? Long.fromValue(object.inactiveInstanceCount)
        : Long.ZERO,
      notifiedInstanceCount: isSet(object.notifiedInstanceCount)
        ? Long.fromValue(object.notifiedInstanceCount)
        : Long.ZERO,
      startedInstanceCount: isSet(object.startedInstanceCount)
        ? Long.fromValue(object.startedInstanceCount)
        : Long.ZERO,
      downloadingPatchesInstanceCount: isSet(object.downloadingPatchesInstanceCount)
        ? Long.fromValue(object.downloadingPatchesInstanceCount)
        : Long.ZERO,
      applyingPatchesInstanceCount: isSet(object.applyingPatchesInstanceCount)
        ? Long.fromValue(object.applyingPatchesInstanceCount)
        : Long.ZERO,
      rebootingInstanceCount: isSet(object.rebootingInstanceCount)
        ? Long.fromValue(object.rebootingInstanceCount)
        : Long.ZERO,
      succeededInstanceCount: isSet(object.succeededInstanceCount)
        ? Long.fromValue(object.succeededInstanceCount)
        : Long.ZERO,
      succeededRebootRequiredInstanceCount: isSet(object.succeededRebootRequiredInstanceCount)
        ? Long.fromValue(object.succeededRebootRequiredInstanceCount)
        : Long.ZERO,
      failedInstanceCount: isSet(object.failedInstanceCount) ? Long.fromValue(object.failedInstanceCount) : Long.ZERO,
      ackedInstanceCount: isSet(object.ackedInstanceCount) ? Long.fromValue(object.ackedInstanceCount) : Long.ZERO,
      timedOutInstanceCount: isSet(object.timedOutInstanceCount)
        ? Long.fromValue(object.timedOutInstanceCount)
        : Long.ZERO,
      prePatchStepInstanceCount: isSet(object.prePatchStepInstanceCount)
        ? Long.fromValue(object.prePatchStepInstanceCount)
        : Long.ZERO,
      postPatchStepInstanceCount: isSet(object.postPatchStepInstanceCount)
        ? Long.fromValue(object.postPatchStepInstanceCount)
        : Long.ZERO,
      noAgentDetectedInstanceCount: isSet(object.noAgentDetectedInstanceCount)
        ? Long.fromValue(object.noAgentDetectedInstanceCount)
        : Long.ZERO,
    };
  },

  toJSON(message: PatchJob_InstanceDetailsSummary): unknown {
    const obj: any = {};
    if (!message.pendingInstanceCount.equals(Long.ZERO)) {
      obj.pendingInstanceCount = (message.pendingInstanceCount || Long.ZERO).toString();
    }
    if (!message.inactiveInstanceCount.equals(Long.ZERO)) {
      obj.inactiveInstanceCount = (message.inactiveInstanceCount || Long.ZERO).toString();
    }
    if (!message.notifiedInstanceCount.equals(Long.ZERO)) {
      obj.notifiedInstanceCount = (message.notifiedInstanceCount || Long.ZERO).toString();
    }
    if (!message.startedInstanceCount.equals(Long.ZERO)) {
      obj.startedInstanceCount = (message.startedInstanceCount || Long.ZERO).toString();
    }
    if (!message.downloadingPatchesInstanceCount.equals(Long.ZERO)) {
      obj.downloadingPatchesInstanceCount = (message.downloadingPatchesInstanceCount || Long.ZERO).toString();
    }
    if (!message.applyingPatchesInstanceCount.equals(Long.ZERO)) {
      obj.applyingPatchesInstanceCount = (message.applyingPatchesInstanceCount || Long.ZERO).toString();
    }
    if (!message.rebootingInstanceCount.equals(Long.ZERO)) {
      obj.rebootingInstanceCount = (message.rebootingInstanceCount || Long.ZERO).toString();
    }
    if (!message.succeededInstanceCount.equals(Long.ZERO)) {
      obj.succeededInstanceCount = (message.succeededInstanceCount || Long.ZERO).toString();
    }
    if (!message.succeededRebootRequiredInstanceCount.equals(Long.ZERO)) {
      obj.succeededRebootRequiredInstanceCount = (message.succeededRebootRequiredInstanceCount || Long.ZERO).toString();
    }
    if (!message.failedInstanceCount.equals(Long.ZERO)) {
      obj.failedInstanceCount = (message.failedInstanceCount || Long.ZERO).toString();
    }
    if (!message.ackedInstanceCount.equals(Long.ZERO)) {
      obj.ackedInstanceCount = (message.ackedInstanceCount || Long.ZERO).toString();
    }
    if (!message.timedOutInstanceCount.equals(Long.ZERO)) {
      obj.timedOutInstanceCount = (message.timedOutInstanceCount || Long.ZERO).toString();
    }
    if (!message.prePatchStepInstanceCount.equals(Long.ZERO)) {
      obj.prePatchStepInstanceCount = (message.prePatchStepInstanceCount || Long.ZERO).toString();
    }
    if (!message.postPatchStepInstanceCount.equals(Long.ZERO)) {
      obj.postPatchStepInstanceCount = (message.postPatchStepInstanceCount || Long.ZERO).toString();
    }
    if (!message.noAgentDetectedInstanceCount.equals(Long.ZERO)) {
      obj.noAgentDetectedInstanceCount = (message.noAgentDetectedInstanceCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<PatchJob_InstanceDetailsSummary>): PatchJob_InstanceDetailsSummary {
    return PatchJob_InstanceDetailsSummary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PatchJob_InstanceDetailsSummary>): PatchJob_InstanceDetailsSummary {
    const message = createBasePatchJob_InstanceDetailsSummary();
    message.pendingInstanceCount = (object.pendingInstanceCount !== undefined && object.pendingInstanceCount !== null)
      ? Long.fromValue(object.pendingInstanceCount)
      : Long.ZERO;
    message.inactiveInstanceCount =
      (object.inactiveInstanceCount !== undefined && object.inactiveInstanceCount !== null)
        ? Long.fromValue(object.inactiveInstanceCount)
        : Long.ZERO;
    message.notifiedInstanceCount =
      (object.notifiedInstanceCount !== undefined && object.notifiedInstanceCount !== null)
        ? Long.fromValue(object.notifiedInstanceCount)
        : Long.ZERO;
    message.startedInstanceCount = (object.startedInstanceCount !== undefined && object.startedInstanceCount !== null)
      ? Long.fromValue(object.startedInstanceCount)
      : Long.ZERO;
    message.downloadingPatchesInstanceCount =
      (object.downloadingPatchesInstanceCount !== undefined && object.downloadingPatchesInstanceCount !== null)
        ? Long.fromValue(object.downloadingPatchesInstanceCount)
        : Long.ZERO;
    message.applyingPatchesInstanceCount =
      (object.applyingPatchesInstanceCount !== undefined && object.applyingPatchesInstanceCount !== null)
        ? Long.fromValue(object.applyingPatchesInstanceCount)
        : Long.ZERO;
    message.rebootingInstanceCount =
      (object.rebootingInstanceCount !== undefined && object.rebootingInstanceCount !== null)
        ? Long.fromValue(object.rebootingInstanceCount)
        : Long.ZERO;
    message.succeededInstanceCount =
      (object.succeededInstanceCount !== undefined && object.succeededInstanceCount !== null)
        ? Long.fromValue(object.succeededInstanceCount)
        : Long.ZERO;
    message.succeededRebootRequiredInstanceCount =
      (object.succeededRebootRequiredInstanceCount !== undefined &&
          object.succeededRebootRequiredInstanceCount !== null)
        ? Long.fromValue(object.succeededRebootRequiredInstanceCount)
        : Long.ZERO;
    message.failedInstanceCount = (object.failedInstanceCount !== undefined && object.failedInstanceCount !== null)
      ? Long.fromValue(object.failedInstanceCount)
      : Long.ZERO;
    message.ackedInstanceCount = (object.ackedInstanceCount !== undefined && object.ackedInstanceCount !== null)
      ? Long.fromValue(object.ackedInstanceCount)
      : Long.ZERO;
    message.timedOutInstanceCount =
      (object.timedOutInstanceCount !== undefined && object.timedOutInstanceCount !== null)
        ? Long.fromValue(object.timedOutInstanceCount)
        : Long.ZERO;
    message.prePatchStepInstanceCount =
      (object.prePatchStepInstanceCount !== undefined && object.prePatchStepInstanceCount !== null)
        ? Long.fromValue(object.prePatchStepInstanceCount)
        : Long.ZERO;
    message.postPatchStepInstanceCount =
      (object.postPatchStepInstanceCount !== undefined && object.postPatchStepInstanceCount !== null)
        ? Long.fromValue(object.postPatchStepInstanceCount)
        : Long.ZERO;
    message.noAgentDetectedInstanceCount =
      (object.noAgentDetectedInstanceCount !== undefined && object.noAgentDetectedInstanceCount !== null)
        ? Long.fromValue(object.noAgentDetectedInstanceCount)
        : Long.ZERO;
    return message;
  },
};

function createBasePatchConfig(): PatchConfig {
  return {
    rebootConfig: 0,
    apt: undefined,
    yum: undefined,
    goo: undefined,
    zypper: undefined,
    windowsUpdate: undefined,
    preStep: undefined,
    postStep: undefined,
    migInstancesAllowed: false,
  };
}

export const PatchConfig: MessageFns<PatchConfig> = {
  encode(message: PatchConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rebootConfig !== 0) {
      writer.uint32(8).int32(message.rebootConfig);
    }
    if (message.apt !== undefined) {
      AptSettings.encode(message.apt, writer.uint32(26).fork()).join();
    }
    if (message.yum !== undefined) {
      YumSettings.encode(message.yum, writer.uint32(34).fork()).join();
    }
    if (message.goo !== undefined) {
      GooSettings.encode(message.goo, writer.uint32(42).fork()).join();
    }
    if (message.zypper !== undefined) {
      ZypperSettings.encode(message.zypper, writer.uint32(50).fork()).join();
    }
    if (message.windowsUpdate !== undefined) {
      WindowsUpdateSettings.encode(message.windowsUpdate, writer.uint32(58).fork()).join();
    }
    if (message.preStep !== undefined) {
      ExecStep.encode(message.preStep, writer.uint32(66).fork()).join();
    }
    if (message.postStep !== undefined) {
      ExecStep.encode(message.postStep, writer.uint32(74).fork()).join();
    }
    if (message.migInstancesAllowed !== false) {
      writer.uint32(80).bool(message.migInstancesAllowed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rebootConfig = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.apt = AptSettings.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.yum = YumSettings.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.goo = GooSettings.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.zypper = ZypperSettings.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.windowsUpdate = WindowsUpdateSettings.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.preStep = ExecStep.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.postStep = ExecStep.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.migInstancesAllowed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchConfig {
    return {
      rebootConfig: isSet(object.rebootConfig) ? patchConfig_RebootConfigFromJSON(object.rebootConfig) : 0,
      apt: isSet(object.apt) ? AptSettings.fromJSON(object.apt) : undefined,
      yum: isSet(object.yum) ? YumSettings.fromJSON(object.yum) : undefined,
      goo: isSet(object.goo) ? GooSettings.fromJSON(object.goo) : undefined,
      zypper: isSet(object.zypper) ? ZypperSettings.fromJSON(object.zypper) : undefined,
      windowsUpdate: isSet(object.windowsUpdate) ? WindowsUpdateSettings.fromJSON(object.windowsUpdate) : undefined,
      preStep: isSet(object.preStep) ? ExecStep.fromJSON(object.preStep) : undefined,
      postStep: isSet(object.postStep) ? ExecStep.fromJSON(object.postStep) : undefined,
      migInstancesAllowed: isSet(object.migInstancesAllowed) ? globalThis.Boolean(object.migInstancesAllowed) : false,
    };
  },

  toJSON(message: PatchConfig): unknown {
    const obj: any = {};
    if (message.rebootConfig !== 0) {
      obj.rebootConfig = patchConfig_RebootConfigToJSON(message.rebootConfig);
    }
    if (message.apt !== undefined) {
      obj.apt = AptSettings.toJSON(message.apt);
    }
    if (message.yum !== undefined) {
      obj.yum = YumSettings.toJSON(message.yum);
    }
    if (message.goo !== undefined) {
      obj.goo = GooSettings.toJSON(message.goo);
    }
    if (message.zypper !== undefined) {
      obj.zypper = ZypperSettings.toJSON(message.zypper);
    }
    if (message.windowsUpdate !== undefined) {
      obj.windowsUpdate = WindowsUpdateSettings.toJSON(message.windowsUpdate);
    }
    if (message.preStep !== undefined) {
      obj.preStep = ExecStep.toJSON(message.preStep);
    }
    if (message.postStep !== undefined) {
      obj.postStep = ExecStep.toJSON(message.postStep);
    }
    if (message.migInstancesAllowed !== false) {
      obj.migInstancesAllowed = message.migInstancesAllowed;
    }
    return obj;
  },

  create(base?: DeepPartial<PatchConfig>): PatchConfig {
    return PatchConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PatchConfig>): PatchConfig {
    const message = createBasePatchConfig();
    message.rebootConfig = object.rebootConfig ?? 0;
    message.apt = (object.apt !== undefined && object.apt !== null) ? AptSettings.fromPartial(object.apt) : undefined;
    message.yum = (object.yum !== undefined && object.yum !== null) ? YumSettings.fromPartial(object.yum) : undefined;
    message.goo = (object.goo !== undefined && object.goo !== null) ? GooSettings.fromPartial(object.goo) : undefined;
    message.zypper = (object.zypper !== undefined && object.zypper !== null)
      ? ZypperSettings.fromPartial(object.zypper)
      : undefined;
    message.windowsUpdate = (object.windowsUpdate !== undefined && object.windowsUpdate !== null)
      ? WindowsUpdateSettings.fromPartial(object.windowsUpdate)
      : undefined;
    message.preStep = (object.preStep !== undefined && object.preStep !== null)
      ? ExecStep.fromPartial(object.preStep)
      : undefined;
    message.postStep = (object.postStep !== undefined && object.postStep !== null)
      ? ExecStep.fromPartial(object.postStep)
      : undefined;
    message.migInstancesAllowed = object.migInstancesAllowed ?? false;
    return message;
  },
};

function createBaseInstance(): Instance {
  return {};
}

export const Instance: MessageFns<Instance> = {
  encode(_: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Instance {
    return {};
  },

  toJSON(_: Instance): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Instance>): Instance {
    return Instance.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Instance>): Instance {
    const message = createBaseInstance();
    return message;
  },
};

function createBaseCancelPatchJobRequest(): CancelPatchJobRequest {
  return { name: "" };
}

export const CancelPatchJobRequest: MessageFns<CancelPatchJobRequest> = {
  encode(message: CancelPatchJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelPatchJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelPatchJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelPatchJobRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CancelPatchJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<CancelPatchJobRequest>): CancelPatchJobRequest {
    return CancelPatchJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelPatchJobRequest>): CancelPatchJobRequest {
    const message = createBaseCancelPatchJobRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseAptSettings(): AptSettings {
  return { type: 0, excludes: [], exclusivePackages: [] };
}

export const AptSettings: MessageFns<AptSettings> = {
  encode(message: AptSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.excludes) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.exclusivePackages) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AptSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAptSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.excludes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.exclusivePackages.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AptSettings {
    return {
      type: isSet(object.type) ? aptSettings_TypeFromJSON(object.type) : 0,
      excludes: globalThis.Array.isArray(object?.excludes) ? object.excludes.map((e: any) => globalThis.String(e)) : [],
      exclusivePackages: globalThis.Array.isArray(object?.exclusivePackages)
        ? object.exclusivePackages.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AptSettings): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = aptSettings_TypeToJSON(message.type);
    }
    if (message.excludes?.length) {
      obj.excludes = message.excludes;
    }
    if (message.exclusivePackages?.length) {
      obj.exclusivePackages = message.exclusivePackages;
    }
    return obj;
  },

  create(base?: DeepPartial<AptSettings>): AptSettings {
    return AptSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AptSettings>): AptSettings {
    const message = createBaseAptSettings();
    message.type = object.type ?? 0;
    message.excludes = object.excludes?.map((e) => e) || [];
    message.exclusivePackages = object.exclusivePackages?.map((e) => e) || [];
    return message;
  },
};

function createBaseYumSettings(): YumSettings {
  return { security: false, minimal: false, excludes: [], exclusivePackages: [] };
}

export const YumSettings: MessageFns<YumSettings> = {
  encode(message: YumSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.security !== false) {
      writer.uint32(8).bool(message.security);
    }
    if (message.minimal !== false) {
      writer.uint32(16).bool(message.minimal);
    }
    for (const v of message.excludes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.exclusivePackages) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YumSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYumSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.security = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minimal = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.excludes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.exclusivePackages.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YumSettings {
    return {
      security: isSet(object.security) ? globalThis.Boolean(object.security) : false,
      minimal: isSet(object.minimal) ? globalThis.Boolean(object.minimal) : false,
      excludes: globalThis.Array.isArray(object?.excludes) ? object.excludes.map((e: any) => globalThis.String(e)) : [],
      exclusivePackages: globalThis.Array.isArray(object?.exclusivePackages)
        ? object.exclusivePackages.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: YumSettings): unknown {
    const obj: any = {};
    if (message.security !== false) {
      obj.security = message.security;
    }
    if (message.minimal !== false) {
      obj.minimal = message.minimal;
    }
    if (message.excludes?.length) {
      obj.excludes = message.excludes;
    }
    if (message.exclusivePackages?.length) {
      obj.exclusivePackages = message.exclusivePackages;
    }
    return obj;
  },

  create(base?: DeepPartial<YumSettings>): YumSettings {
    return YumSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<YumSettings>): YumSettings {
    const message = createBaseYumSettings();
    message.security = object.security ?? false;
    message.minimal = object.minimal ?? false;
    message.excludes = object.excludes?.map((e) => e) || [];
    message.exclusivePackages = object.exclusivePackages?.map((e) => e) || [];
    return message;
  },
};

function createBaseGooSettings(): GooSettings {
  return {};
}

export const GooSettings: MessageFns<GooSettings> = {
  encode(_: GooSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GooSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGooSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GooSettings {
    return {};
  },

  toJSON(_: GooSettings): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GooSettings>): GooSettings {
    return GooSettings.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GooSettings>): GooSettings {
    const message = createBaseGooSettings();
    return message;
  },
};

function createBaseZypperSettings(): ZypperSettings {
  return { withOptional: false, withUpdate: false, categories: [], severities: [], excludes: [], exclusivePatches: [] };
}

export const ZypperSettings: MessageFns<ZypperSettings> = {
  encode(message: ZypperSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.withOptional !== false) {
      writer.uint32(8).bool(message.withOptional);
    }
    if (message.withUpdate !== false) {
      writer.uint32(16).bool(message.withUpdate);
    }
    for (const v of message.categories) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.severities) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.excludes) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.exclusivePatches) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZypperSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZypperSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.withOptional = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.withUpdate = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.severities.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.excludes.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.exclusivePatches.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZypperSettings {
    return {
      withOptional: isSet(object.withOptional) ? globalThis.Boolean(object.withOptional) : false,
      withUpdate: isSet(object.withUpdate) ? globalThis.Boolean(object.withUpdate) : false,
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      severities: globalThis.Array.isArray(object?.severities)
        ? object.severities.map((e: any) => globalThis.String(e))
        : [],
      excludes: globalThis.Array.isArray(object?.excludes) ? object.excludes.map((e: any) => globalThis.String(e)) : [],
      exclusivePatches: globalThis.Array.isArray(object?.exclusivePatches)
        ? object.exclusivePatches.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ZypperSettings): unknown {
    const obj: any = {};
    if (message.withOptional !== false) {
      obj.withOptional = message.withOptional;
    }
    if (message.withUpdate !== false) {
      obj.withUpdate = message.withUpdate;
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.severities?.length) {
      obj.severities = message.severities;
    }
    if (message.excludes?.length) {
      obj.excludes = message.excludes;
    }
    if (message.exclusivePatches?.length) {
      obj.exclusivePatches = message.exclusivePatches;
    }
    return obj;
  },

  create(base?: DeepPartial<ZypperSettings>): ZypperSettings {
    return ZypperSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ZypperSettings>): ZypperSettings {
    const message = createBaseZypperSettings();
    message.withOptional = object.withOptional ?? false;
    message.withUpdate = object.withUpdate ?? false;
    message.categories = object.categories?.map((e) => e) || [];
    message.severities = object.severities?.map((e) => e) || [];
    message.excludes = object.excludes?.map((e) => e) || [];
    message.exclusivePatches = object.exclusivePatches?.map((e) => e) || [];
    return message;
  },
};

function createBaseWindowsUpdateSettings(): WindowsUpdateSettings {
  return { classifications: [], excludes: [], exclusivePatches: [] };
}

export const WindowsUpdateSettings: MessageFns<WindowsUpdateSettings> = {
  encode(message: WindowsUpdateSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.classifications) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.excludes) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.exclusivePatches) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WindowsUpdateSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWindowsUpdateSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.classifications.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.classifications.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.excludes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.exclusivePatches.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WindowsUpdateSettings {
    return {
      classifications: globalThis.Array.isArray(object?.classifications)
        ? object.classifications.map((e: any) => windowsUpdateSettings_ClassificationFromJSON(e))
        : [],
      excludes: globalThis.Array.isArray(object?.excludes) ? object.excludes.map((e: any) => globalThis.String(e)) : [],
      exclusivePatches: globalThis.Array.isArray(object?.exclusivePatches)
        ? object.exclusivePatches.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: WindowsUpdateSettings): unknown {
    const obj: any = {};
    if (message.classifications?.length) {
      obj.classifications = message.classifications.map((e) => windowsUpdateSettings_ClassificationToJSON(e));
    }
    if (message.excludes?.length) {
      obj.excludes = message.excludes;
    }
    if (message.exclusivePatches?.length) {
      obj.exclusivePatches = message.exclusivePatches;
    }
    return obj;
  },

  create(base?: DeepPartial<WindowsUpdateSettings>): WindowsUpdateSettings {
    return WindowsUpdateSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WindowsUpdateSettings>): WindowsUpdateSettings {
    const message = createBaseWindowsUpdateSettings();
    message.classifications = object.classifications?.map((e) => e) || [];
    message.excludes = object.excludes?.map((e) => e) || [];
    message.exclusivePatches = object.exclusivePatches?.map((e) => e) || [];
    return message;
  },
};

function createBaseExecStep(): ExecStep {
  return { linuxExecStepConfig: undefined, windowsExecStepConfig: undefined };
}

export const ExecStep: MessageFns<ExecStep> = {
  encode(message: ExecStep, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.linuxExecStepConfig !== undefined) {
      ExecStepConfig.encode(message.linuxExecStepConfig, writer.uint32(10).fork()).join();
    }
    if (message.windowsExecStepConfig !== undefined) {
      ExecStepConfig.encode(message.windowsExecStepConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecStep {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.linuxExecStepConfig = ExecStepConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.windowsExecStepConfig = ExecStepConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecStep {
    return {
      linuxExecStepConfig: isSet(object.linuxExecStepConfig)
        ? ExecStepConfig.fromJSON(object.linuxExecStepConfig)
        : undefined,
      windowsExecStepConfig: isSet(object.windowsExecStepConfig)
        ? ExecStepConfig.fromJSON(object.windowsExecStepConfig)
        : undefined,
    };
  },

  toJSON(message: ExecStep): unknown {
    const obj: any = {};
    if (message.linuxExecStepConfig !== undefined) {
      obj.linuxExecStepConfig = ExecStepConfig.toJSON(message.linuxExecStepConfig);
    }
    if (message.windowsExecStepConfig !== undefined) {
      obj.windowsExecStepConfig = ExecStepConfig.toJSON(message.windowsExecStepConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecStep>): ExecStep {
    return ExecStep.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecStep>): ExecStep {
    const message = createBaseExecStep();
    message.linuxExecStepConfig = (object.linuxExecStepConfig !== undefined && object.linuxExecStepConfig !== null)
      ? ExecStepConfig.fromPartial(object.linuxExecStepConfig)
      : undefined;
    message.windowsExecStepConfig =
      (object.windowsExecStepConfig !== undefined && object.windowsExecStepConfig !== null)
        ? ExecStepConfig.fromPartial(object.windowsExecStepConfig)
        : undefined;
    return message;
  },
};

function createBaseExecStepConfig(): ExecStepConfig {
  return { localPath: undefined, gcsObject: undefined, allowedSuccessCodes: [], interpreter: 0 };
}

export const ExecStepConfig: MessageFns<ExecStepConfig> = {
  encode(message: ExecStepConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.localPath !== undefined) {
      writer.uint32(10).string(message.localPath);
    }
    if (message.gcsObject !== undefined) {
      GcsObject.encode(message.gcsObject, writer.uint32(18).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v of message.allowedSuccessCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message.interpreter !== 0) {
      writer.uint32(32).int32(message.interpreter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecStepConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecStepConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.localPath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gcsObject = GcsObject.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag === 24) {
            message.allowedSuccessCodes.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedSuccessCodes.push(reader.int32());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.interpreter = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecStepConfig {
    return {
      localPath: isSet(object.localPath) ? globalThis.String(object.localPath) : undefined,
      gcsObject: isSet(object.gcsObject) ? GcsObject.fromJSON(object.gcsObject) : undefined,
      allowedSuccessCodes: globalThis.Array.isArray(object?.allowedSuccessCodes)
        ? object.allowedSuccessCodes.map((e: any) => globalThis.Number(e))
        : [],
      interpreter: isSet(object.interpreter) ? execStepConfig_InterpreterFromJSON(object.interpreter) : 0,
    };
  },

  toJSON(message: ExecStepConfig): unknown {
    const obj: any = {};
    if (message.localPath !== undefined) {
      obj.localPath = message.localPath;
    }
    if (message.gcsObject !== undefined) {
      obj.gcsObject = GcsObject.toJSON(message.gcsObject);
    }
    if (message.allowedSuccessCodes?.length) {
      obj.allowedSuccessCodes = message.allowedSuccessCodes.map((e) => Math.round(e));
    }
    if (message.interpreter !== 0) {
      obj.interpreter = execStepConfig_InterpreterToJSON(message.interpreter);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecStepConfig>): ExecStepConfig {
    return ExecStepConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecStepConfig>): ExecStepConfig {
    const message = createBaseExecStepConfig();
    message.localPath = object.localPath ?? undefined;
    message.gcsObject = (object.gcsObject !== undefined && object.gcsObject !== null)
      ? GcsObject.fromPartial(object.gcsObject)
      : undefined;
    message.allowedSuccessCodes = object.allowedSuccessCodes?.map((e) => e) || [];
    message.interpreter = object.interpreter ?? 0;
    return message;
  },
};

function createBaseGcsObject(): GcsObject {
  return { bucket: "", object: "", generationNumber: Long.ZERO };
}

export const GcsObject: MessageFns<GcsObject> = {
  encode(message: GcsObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.object !== "") {
      writer.uint32(18).string(message.object);
    }
    if (!message.generationNumber.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.generationNumber.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.object = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.generationNumber = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsObject {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      object: isSet(object.object) ? globalThis.String(object.object) : "",
      generationNumber: isSet(object.generationNumber) ? Long.fromValue(object.generationNumber) : Long.ZERO,
    };
  },

  toJSON(message: GcsObject): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.object !== "") {
      obj.object = message.object;
    }
    if (!message.generationNumber.equals(Long.ZERO)) {
      obj.generationNumber = (message.generationNumber || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GcsObject>): GcsObject {
    return GcsObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsObject>): GcsObject {
    const message = createBaseGcsObject();
    message.bucket = object.bucket ?? "";
    message.object = object.object ?? "";
    message.generationNumber = (object.generationNumber !== undefined && object.generationNumber !== null)
      ? Long.fromValue(object.generationNumber)
      : Long.ZERO;
    return message;
  },
};

function createBasePatchInstanceFilter(): PatchInstanceFilter {
  return { all: false, groupLabels: [], zones: [], instances: [], instanceNamePrefixes: [] };
}

export const PatchInstanceFilter: MessageFns<PatchInstanceFilter> = {
  encode(message: PatchInstanceFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.all !== false) {
      writer.uint32(8).bool(message.all);
    }
    for (const v of message.groupLabels) {
      PatchInstanceFilter_GroupLabel.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.zones) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.instances) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.instanceNamePrefixes) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchInstanceFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchInstanceFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.all = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupLabels.push(PatchInstanceFilter_GroupLabel.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.zones.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.instances.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.instanceNamePrefixes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchInstanceFilter {
    return {
      all: isSet(object.all) ? globalThis.Boolean(object.all) : false,
      groupLabels: globalThis.Array.isArray(object?.groupLabels)
        ? object.groupLabels.map((e: any) => PatchInstanceFilter_GroupLabel.fromJSON(e))
        : [],
      zones: globalThis.Array.isArray(object?.zones) ? object.zones.map((e: any) => globalThis.String(e)) : [],
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => globalThis.String(e))
        : [],
      instanceNamePrefixes: globalThis.Array.isArray(object?.instanceNamePrefixes)
        ? object.instanceNamePrefixes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PatchInstanceFilter): unknown {
    const obj: any = {};
    if (message.all !== false) {
      obj.all = message.all;
    }
    if (message.groupLabels?.length) {
      obj.groupLabels = message.groupLabels.map((e) => PatchInstanceFilter_GroupLabel.toJSON(e));
    }
    if (message.zones?.length) {
      obj.zones = message.zones;
    }
    if (message.instances?.length) {
      obj.instances = message.instances;
    }
    if (message.instanceNamePrefixes?.length) {
      obj.instanceNamePrefixes = message.instanceNamePrefixes;
    }
    return obj;
  },

  create(base?: DeepPartial<PatchInstanceFilter>): PatchInstanceFilter {
    return PatchInstanceFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PatchInstanceFilter>): PatchInstanceFilter {
    const message = createBasePatchInstanceFilter();
    message.all = object.all ?? false;
    message.groupLabels = object.groupLabels?.map((e) => PatchInstanceFilter_GroupLabel.fromPartial(e)) || [];
    message.zones = object.zones?.map((e) => e) || [];
    message.instances = object.instances?.map((e) => e) || [];
    message.instanceNamePrefixes = object.instanceNamePrefixes?.map((e) => e) || [];
    return message;
  },
};

function createBasePatchInstanceFilter_GroupLabel(): PatchInstanceFilter_GroupLabel {
  return { labels: {} };
}

export const PatchInstanceFilter_GroupLabel: MessageFns<PatchInstanceFilter_GroupLabel> = {
  encode(message: PatchInstanceFilter_GroupLabel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.labels).forEach(([key, value]) => {
      PatchInstanceFilter_GroupLabel_LabelsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchInstanceFilter_GroupLabel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchInstanceFilter_GroupLabel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = PatchInstanceFilter_GroupLabel_LabelsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.labels[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchInstanceFilter_GroupLabel {
    return {
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PatchInstanceFilter_GroupLabel): unknown {
    const obj: any = {};
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<PatchInstanceFilter_GroupLabel>): PatchInstanceFilter_GroupLabel {
    return PatchInstanceFilter_GroupLabel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PatchInstanceFilter_GroupLabel>): PatchInstanceFilter_GroupLabel {
    const message = createBasePatchInstanceFilter_GroupLabel();
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBasePatchInstanceFilter_GroupLabel_LabelsEntry(): PatchInstanceFilter_GroupLabel_LabelsEntry {
  return { key: "", value: "" };
}

export const PatchInstanceFilter_GroupLabel_LabelsEntry: MessageFns<PatchInstanceFilter_GroupLabel_LabelsEntry> = {
  encode(message: PatchInstanceFilter_GroupLabel_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchInstanceFilter_GroupLabel_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchInstanceFilter_GroupLabel_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchInstanceFilter_GroupLabel_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PatchInstanceFilter_GroupLabel_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PatchInstanceFilter_GroupLabel_LabelsEntry>): PatchInstanceFilter_GroupLabel_LabelsEntry {
    return PatchInstanceFilter_GroupLabel_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PatchInstanceFilter_GroupLabel_LabelsEntry>,
  ): PatchInstanceFilter_GroupLabel_LabelsEntry {
    const message = createBasePatchInstanceFilter_GroupLabel_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePatchRollout(): PatchRollout {
  return { mode: 0, disruptionBudget: undefined };
}

export const PatchRollout: MessageFns<PatchRollout> = {
  encode(message: PatchRollout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    if (message.disruptionBudget !== undefined) {
      FixedOrPercent.encode(message.disruptionBudget, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchRollout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchRollout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.disruptionBudget = FixedOrPercent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchRollout {
    return {
      mode: isSet(object.mode) ? patchRollout_ModeFromJSON(object.mode) : 0,
      disruptionBudget: isSet(object.disruptionBudget) ? FixedOrPercent.fromJSON(object.disruptionBudget) : undefined,
    };
  },

  toJSON(message: PatchRollout): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = patchRollout_ModeToJSON(message.mode);
    }
    if (message.disruptionBudget !== undefined) {
      obj.disruptionBudget = FixedOrPercent.toJSON(message.disruptionBudget);
    }
    return obj;
  },

  create(base?: DeepPartial<PatchRollout>): PatchRollout {
    return PatchRollout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PatchRollout>): PatchRollout {
    const message = createBasePatchRollout();
    message.mode = object.mode ?? 0;
    message.disruptionBudget = (object.disruptionBudget !== undefined && object.disruptionBudget !== null)
      ? FixedOrPercent.fromPartial(object.disruptionBudget)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
