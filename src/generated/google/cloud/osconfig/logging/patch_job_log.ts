// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/osconfig/logging/patch_job_log.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.osconfig.logging";

export interface PatchJobCompletedLog {
  /**
   * The patch job name. For example:
   * projects/PROJECT_ID/patchJobs/PATCH_JOB_ID
   */
  patchJob: string;
  /** The current state of the PatchJob. */
  state: PatchJobCompletedLog_State;
  /** Summary of instance details. */
  instanceDetailsSummary:
    | PatchJobCompletedLog_InstanceDetailsSummary
    | undefined;
  /**
   * If this patch job is a dry run, the agent will report that it has
   * finished without running any updates on the VM.
   */
  dryRun: boolean;
  /**
   * If this patch job failed, this message will provide information about the
   * failure.
   */
  errorMessage: string;
  /** Time this PatchJob was created. */
  createTime:
    | Date
    | undefined;
  /** Last time this PatchJob was updated. */
  updateTime: Date | undefined;
}

/**
 * Enumeration of the various states a patch job passes through as it
 * executes.
 */
export enum PatchJobCompletedLog_State {
  /** STATE_UNSPECIFIED - State must be specified. */
  STATE_UNSPECIFIED = 0,
  /** STARTED - The patch job was successfully initiated. */
  STARTED = 1,
  /** INSTANCE_LOOKUP - The patch job is looking up instances to run the patch on. */
  INSTANCE_LOOKUP = 2,
  /** PATCHING - Instances are being patched. */
  PATCHING = 3,
  /** SUCCEEDED - Patch job completed successfully. */
  SUCCEEDED = 4,
  /** COMPLETED_WITH_ERRORS - Patch job completed but there were errors. */
  COMPLETED_WITH_ERRORS = 5,
  /** CANCELED - The patch job was canceled. */
  CANCELED = 6,
  /** TIMED_OUT - The patch job has timed out. */
  TIMED_OUT = 7,
  UNRECOGNIZED = -1,
}

export function patchJobCompletedLog_StateFromJSON(object: any): PatchJobCompletedLog_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return PatchJobCompletedLog_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTED":
      return PatchJobCompletedLog_State.STARTED;
    case 2:
    case "INSTANCE_LOOKUP":
      return PatchJobCompletedLog_State.INSTANCE_LOOKUP;
    case 3:
    case "PATCHING":
      return PatchJobCompletedLog_State.PATCHING;
    case 4:
    case "SUCCEEDED":
      return PatchJobCompletedLog_State.SUCCEEDED;
    case 5:
    case "COMPLETED_WITH_ERRORS":
      return PatchJobCompletedLog_State.COMPLETED_WITH_ERRORS;
    case 6:
    case "CANCELED":
      return PatchJobCompletedLog_State.CANCELED;
    case 7:
    case "TIMED_OUT":
      return PatchJobCompletedLog_State.TIMED_OUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PatchJobCompletedLog_State.UNRECOGNIZED;
  }
}

export function patchJobCompletedLog_StateToJSON(object: PatchJobCompletedLog_State): string {
  switch (object) {
    case PatchJobCompletedLog_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case PatchJobCompletedLog_State.STARTED:
      return "STARTED";
    case PatchJobCompletedLog_State.INSTANCE_LOOKUP:
      return "INSTANCE_LOOKUP";
    case PatchJobCompletedLog_State.PATCHING:
      return "PATCHING";
    case PatchJobCompletedLog_State.SUCCEEDED:
      return "SUCCEEDED";
    case PatchJobCompletedLog_State.COMPLETED_WITH_ERRORS:
      return "COMPLETED_WITH_ERRORS";
    case PatchJobCompletedLog_State.CANCELED:
      return "CANCELED";
    case PatchJobCompletedLog_State.TIMED_OUT:
      return "TIMED_OUT";
    case PatchJobCompletedLog_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A summary of the current patch state across all instances this patch job
 * affects. Contains counts of instances in different states. These states map
 * to InstancePatchState. List patch job instance details to see the specific
 * states of each instance.
 */
export interface PatchJobCompletedLog_InstanceDetailsSummary {
  /** Number of instances pending patch job. */
  instancesPending: Long;
  /** Number of instances that are inactive. */
  instancesInactive: Long;
  /** Number of instances notified about patch job. */
  instancesNotified: Long;
  /** Number of instances that have started. */
  instancesStarted: Long;
  /** Number of instances that are downloading patches. */
  instancesDownloadingPatches: Long;
  /** Number of instances that are applying patches. */
  instancesApplyingPatches: Long;
  /** Number of instances rebooting. */
  instancesRebooting: Long;
  /** Number of instances that have completed successfully. */
  instancesSucceeded: Long;
  /** Number of instances that require reboot. */
  instancesSucceededRebootRequired: Long;
  /** Number of instances that failed. */
  instancesFailed: Long;
  /** Number of instances that have acked and will start shortly. */
  instancesAcked: Long;
  /** Number of instances that exceeded the time out while applying the patch. */
  instancesTimedOut: Long;
  /** Number of instances that are running the pre-patch step. */
  instancesRunningPrePatchStep: Long;
  /** Number of instances that are running the post-patch step. */
  instancesRunningPostPatchStep: Long;
}

function createBasePatchJobCompletedLog(): PatchJobCompletedLog {
  return {
    patchJob: "",
    state: 0,
    instanceDetailsSummary: undefined,
    dryRun: false,
    errorMessage: "",
    createTime: undefined,
    updateTime: undefined,
  };
}

export const PatchJobCompletedLog: MessageFns<PatchJobCompletedLog> = {
  encode(message: PatchJobCompletedLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.patchJob !== "") {
      writer.uint32(10).string(message.patchJob);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.instanceDetailsSummary !== undefined) {
      PatchJobCompletedLog_InstanceDetailsSummary.encode(message.instanceDetailsSummary, writer.uint32(26).fork())
        .join();
    }
    if (message.dryRun !== false) {
      writer.uint32(32).bool(message.dryRun);
    }
    if (message.errorMessage !== "") {
      writer.uint32(42).string(message.errorMessage);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchJobCompletedLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchJobCompletedLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.patchJob = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instanceDetailsSummary = PatchJobCompletedLog_InstanceDetailsSummary.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchJobCompletedLog {
    return {
      patchJob: isSet(object.patchJob) ? globalThis.String(object.patchJob) : "",
      state: isSet(object.state) ? patchJobCompletedLog_StateFromJSON(object.state) : 0,
      instanceDetailsSummary: isSet(object.instanceDetailsSummary)
        ? PatchJobCompletedLog_InstanceDetailsSummary.fromJSON(object.instanceDetailsSummary)
        : undefined,
      dryRun: isSet(object.dryRun) ? globalThis.Boolean(object.dryRun) : false,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: PatchJobCompletedLog): unknown {
    const obj: any = {};
    if (message.patchJob !== "") {
      obj.patchJob = message.patchJob;
    }
    if (message.state !== 0) {
      obj.state = patchJobCompletedLog_StateToJSON(message.state);
    }
    if (message.instanceDetailsSummary !== undefined) {
      obj.instanceDetailsSummary = PatchJobCompletedLog_InstanceDetailsSummary.toJSON(message.instanceDetailsSummary);
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<PatchJobCompletedLog>): PatchJobCompletedLog {
    return PatchJobCompletedLog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PatchJobCompletedLog>): PatchJobCompletedLog {
    const message = createBasePatchJobCompletedLog();
    message.patchJob = object.patchJob ?? "";
    message.state = object.state ?? 0;
    message.instanceDetailsSummary =
      (object.instanceDetailsSummary !== undefined && object.instanceDetailsSummary !== null)
        ? PatchJobCompletedLog_InstanceDetailsSummary.fromPartial(object.instanceDetailsSummary)
        : undefined;
    message.dryRun = object.dryRun ?? false;
    message.errorMessage = object.errorMessage ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBasePatchJobCompletedLog_InstanceDetailsSummary(): PatchJobCompletedLog_InstanceDetailsSummary {
  return {
    instancesPending: Long.ZERO,
    instancesInactive: Long.ZERO,
    instancesNotified: Long.ZERO,
    instancesStarted: Long.ZERO,
    instancesDownloadingPatches: Long.ZERO,
    instancesApplyingPatches: Long.ZERO,
    instancesRebooting: Long.ZERO,
    instancesSucceeded: Long.ZERO,
    instancesSucceededRebootRequired: Long.ZERO,
    instancesFailed: Long.ZERO,
    instancesAcked: Long.ZERO,
    instancesTimedOut: Long.ZERO,
    instancesRunningPrePatchStep: Long.ZERO,
    instancesRunningPostPatchStep: Long.ZERO,
  };
}

export const PatchJobCompletedLog_InstanceDetailsSummary: MessageFns<PatchJobCompletedLog_InstanceDetailsSummary> = {
  encode(
    message: PatchJobCompletedLog_InstanceDetailsSummary,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (!message.instancesPending.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.instancesPending.toString());
    }
    if (!message.instancesInactive.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.instancesInactive.toString());
    }
    if (!message.instancesNotified.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.instancesNotified.toString());
    }
    if (!message.instancesStarted.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.instancesStarted.toString());
    }
    if (!message.instancesDownloadingPatches.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.instancesDownloadingPatches.toString());
    }
    if (!message.instancesApplyingPatches.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.instancesApplyingPatches.toString());
    }
    if (!message.instancesRebooting.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.instancesRebooting.toString());
    }
    if (!message.instancesSucceeded.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.instancesSucceeded.toString());
    }
    if (!message.instancesSucceededRebootRequired.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.instancesSucceededRebootRequired.toString());
    }
    if (!message.instancesFailed.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.instancesFailed.toString());
    }
    if (!message.instancesAcked.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.instancesAcked.toString());
    }
    if (!message.instancesTimedOut.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.instancesTimedOut.toString());
    }
    if (!message.instancesRunningPrePatchStep.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.instancesRunningPrePatchStep.toString());
    }
    if (!message.instancesRunningPostPatchStep.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.instancesRunningPostPatchStep.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PatchJobCompletedLog_InstanceDetailsSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatchJobCompletedLog_InstanceDetailsSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.instancesPending = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.instancesInactive = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.instancesNotified = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.instancesStarted = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.instancesDownloadingPatches = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.instancesApplyingPatches = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.instancesRebooting = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.instancesSucceeded = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.instancesSucceededRebootRequired = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.instancesFailed = Long.fromString(reader.int64().toString());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.instancesAcked = Long.fromString(reader.int64().toString());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.instancesTimedOut = Long.fromString(reader.int64().toString());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.instancesRunningPrePatchStep = Long.fromString(reader.int64().toString());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.instancesRunningPostPatchStep = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PatchJobCompletedLog_InstanceDetailsSummary {
    return {
      instancesPending: isSet(object.instancesPending) ? Long.fromValue(object.instancesPending) : Long.ZERO,
      instancesInactive: isSet(object.instancesInactive) ? Long.fromValue(object.instancesInactive) : Long.ZERO,
      instancesNotified: isSet(object.instancesNotified) ? Long.fromValue(object.instancesNotified) : Long.ZERO,
      instancesStarted: isSet(object.instancesStarted) ? Long.fromValue(object.instancesStarted) : Long.ZERO,
      instancesDownloadingPatches: isSet(object.instancesDownloadingPatches)
        ? Long.fromValue(object.instancesDownloadingPatches)
        : Long.ZERO,
      instancesApplyingPatches: isSet(object.instancesApplyingPatches)
        ? Long.fromValue(object.instancesApplyingPatches)
        : Long.ZERO,
      instancesRebooting: isSet(object.instancesRebooting) ? Long.fromValue(object.instancesRebooting) : Long.ZERO,
      instancesSucceeded: isSet(object.instancesSucceeded) ? Long.fromValue(object.instancesSucceeded) : Long.ZERO,
      instancesSucceededRebootRequired: isSet(object.instancesSucceededRebootRequired)
        ? Long.fromValue(object.instancesSucceededRebootRequired)
        : Long.ZERO,
      instancesFailed: isSet(object.instancesFailed) ? Long.fromValue(object.instancesFailed) : Long.ZERO,
      instancesAcked: isSet(object.instancesAcked) ? Long.fromValue(object.instancesAcked) : Long.ZERO,
      instancesTimedOut: isSet(object.instancesTimedOut) ? Long.fromValue(object.instancesTimedOut) : Long.ZERO,
      instancesRunningPrePatchStep: isSet(object.instancesRunningPrePatchStep)
        ? Long.fromValue(object.instancesRunningPrePatchStep)
        : Long.ZERO,
      instancesRunningPostPatchStep: isSet(object.instancesRunningPostPatchStep)
        ? Long.fromValue(object.instancesRunningPostPatchStep)
        : Long.ZERO,
    };
  },

  toJSON(message: PatchJobCompletedLog_InstanceDetailsSummary): unknown {
    const obj: any = {};
    if (!message.instancesPending.equals(Long.ZERO)) {
      obj.instancesPending = (message.instancesPending || Long.ZERO).toString();
    }
    if (!message.instancesInactive.equals(Long.ZERO)) {
      obj.instancesInactive = (message.instancesInactive || Long.ZERO).toString();
    }
    if (!message.instancesNotified.equals(Long.ZERO)) {
      obj.instancesNotified = (message.instancesNotified || Long.ZERO).toString();
    }
    if (!message.instancesStarted.equals(Long.ZERO)) {
      obj.instancesStarted = (message.instancesStarted || Long.ZERO).toString();
    }
    if (!message.instancesDownloadingPatches.equals(Long.ZERO)) {
      obj.instancesDownloadingPatches = (message.instancesDownloadingPatches || Long.ZERO).toString();
    }
    if (!message.instancesApplyingPatches.equals(Long.ZERO)) {
      obj.instancesApplyingPatches = (message.instancesApplyingPatches || Long.ZERO).toString();
    }
    if (!message.instancesRebooting.equals(Long.ZERO)) {
      obj.instancesRebooting = (message.instancesRebooting || Long.ZERO).toString();
    }
    if (!message.instancesSucceeded.equals(Long.ZERO)) {
      obj.instancesSucceeded = (message.instancesSucceeded || Long.ZERO).toString();
    }
    if (!message.instancesSucceededRebootRequired.equals(Long.ZERO)) {
      obj.instancesSucceededRebootRequired = (message.instancesSucceededRebootRequired || Long.ZERO).toString();
    }
    if (!message.instancesFailed.equals(Long.ZERO)) {
      obj.instancesFailed = (message.instancesFailed || Long.ZERO).toString();
    }
    if (!message.instancesAcked.equals(Long.ZERO)) {
      obj.instancesAcked = (message.instancesAcked || Long.ZERO).toString();
    }
    if (!message.instancesTimedOut.equals(Long.ZERO)) {
      obj.instancesTimedOut = (message.instancesTimedOut || Long.ZERO).toString();
    }
    if (!message.instancesRunningPrePatchStep.equals(Long.ZERO)) {
      obj.instancesRunningPrePatchStep = (message.instancesRunningPrePatchStep || Long.ZERO).toString();
    }
    if (!message.instancesRunningPostPatchStep.equals(Long.ZERO)) {
      obj.instancesRunningPostPatchStep = (message.instancesRunningPostPatchStep || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<PatchJobCompletedLog_InstanceDetailsSummary>): PatchJobCompletedLog_InstanceDetailsSummary {
    return PatchJobCompletedLog_InstanceDetailsSummary.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<PatchJobCompletedLog_InstanceDetailsSummary>,
  ): PatchJobCompletedLog_InstanceDetailsSummary {
    const message = createBasePatchJobCompletedLog_InstanceDetailsSummary();
    message.instancesPending = (object.instancesPending !== undefined && object.instancesPending !== null)
      ? Long.fromValue(object.instancesPending)
      : Long.ZERO;
    message.instancesInactive = (object.instancesInactive !== undefined && object.instancesInactive !== null)
      ? Long.fromValue(object.instancesInactive)
      : Long.ZERO;
    message.instancesNotified = (object.instancesNotified !== undefined && object.instancesNotified !== null)
      ? Long.fromValue(object.instancesNotified)
      : Long.ZERO;
    message.instancesStarted = (object.instancesStarted !== undefined && object.instancesStarted !== null)
      ? Long.fromValue(object.instancesStarted)
      : Long.ZERO;
    message.instancesDownloadingPatches =
      (object.instancesDownloadingPatches !== undefined && object.instancesDownloadingPatches !== null)
        ? Long.fromValue(object.instancesDownloadingPatches)
        : Long.ZERO;
    message.instancesApplyingPatches =
      (object.instancesApplyingPatches !== undefined && object.instancesApplyingPatches !== null)
        ? Long.fromValue(object.instancesApplyingPatches)
        : Long.ZERO;
    message.instancesRebooting = (object.instancesRebooting !== undefined && object.instancesRebooting !== null)
      ? Long.fromValue(object.instancesRebooting)
      : Long.ZERO;
    message.instancesSucceeded = (object.instancesSucceeded !== undefined && object.instancesSucceeded !== null)
      ? Long.fromValue(object.instancesSucceeded)
      : Long.ZERO;
    message.instancesSucceededRebootRequired =
      (object.instancesSucceededRebootRequired !== undefined && object.instancesSucceededRebootRequired !== null)
        ? Long.fromValue(object.instancesSucceededRebootRequired)
        : Long.ZERO;
    message.instancesFailed = (object.instancesFailed !== undefined && object.instancesFailed !== null)
      ? Long.fromValue(object.instancesFailed)
      : Long.ZERO;
    message.instancesAcked = (object.instancesAcked !== undefined && object.instancesAcked !== null)
      ? Long.fromValue(object.instancesAcked)
      : Long.ZERO;
    message.instancesTimedOut = (object.instancesTimedOut !== undefined && object.instancesTimedOut !== null)
      ? Long.fromValue(object.instancesTimedOut)
      : Long.ZERO;
    message.instancesRunningPrePatchStep =
      (object.instancesRunningPrePatchStep !== undefined && object.instancesRunningPrePatchStep !== null)
        ? Long.fromValue(object.instancesRunningPrePatchStep)
        : Long.ZERO;
    message.instancesRunningPostPatchStep =
      (object.instancesRunningPostPatchStep !== undefined && object.instancesRunningPostPatchStep !== null)
        ? Long.fromValue(object.instancesRunningPostPatchStep)
        : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
