// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/osconfig/agentendpoint/v1beta/guest_policies.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.osconfig.agentendpoint.v1beta";

/** The desired state that the OS Config agent will maintain on the VM. */
export enum DesiredState {
  /** DESIRED_STATE_UNSPECIFIED - The default is to ensure the package is installed. */
  DESIRED_STATE_UNSPECIFIED = 0,
  /** INSTALLED - The agent ensures that the package is installed. */
  INSTALLED = 1,
  /**
   * UPDATED - The agent ensures that the package is installed and
   * periodically checks for and install any updates.
   */
  UPDATED = 2,
  /**
   * REMOVED - The agent ensures that the package is not installed and uninstall it
   * if detected.
   */
  REMOVED = 3,
  UNRECOGNIZED = -1,
}

export function desiredStateFromJSON(object: any): DesiredState {
  switch (object) {
    case 0:
    case "DESIRED_STATE_UNSPECIFIED":
      return DesiredState.DESIRED_STATE_UNSPECIFIED;
    case 1:
    case "INSTALLED":
      return DesiredState.INSTALLED;
    case 2:
    case "UPDATED":
      return DesiredState.UPDATED;
    case 3:
    case "REMOVED":
      return DesiredState.REMOVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DesiredState.UNRECOGNIZED;
  }
}

export function desiredStateToJSON(object: DesiredState): string {
  switch (object) {
    case DesiredState.DESIRED_STATE_UNSPECIFIED:
      return "DESIRED_STATE_UNSPECIFIED";
    case DesiredState.INSTALLED:
      return "INSTALLED";
    case DesiredState.UPDATED:
      return "UPDATED";
    case DesiredState.REMOVED:
      return "REMOVED";
    case DesiredState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Package is a reference to the software package to be installed or removed.
 * The agent on the VM instance uses the system package manager to apply the
 * config.
 *
 * These are the commands that the agent uses to install or remove
 * packages.
 *
 * Apt
 * install: `apt-get update && apt-get -y install package1 package2 package3`
 * remove: `apt-get -y remove package1 package2 package3`
 *
 * Yum
 * install: `yum -y install package1 package2 package3`
 * remove: `yum -y remove package1 package2 package3`
 *
 * Zypper
 * install: `zypper install package1 package2 package3`
 * remove: `zypper rm package1 package2`
 *
 * Googet
 * install: `googet -noconfirm install package1 package2 package3`
 * remove: `googet -noconfirm remove package1 package2 package3`
 */
export interface Package {
  /**
   * The name of the package. A package is uniquely identified for conflict
   * validation by checking the package name and the manager(s) that the
   * package targets.
   */
  name: string;
  /**
   * The desired_state the agent should maintain for this package. The
   * default is to ensure the package is installed.
   */
  desiredState: DesiredState;
  /**
   * Type of package manager that can be used to install this package.
   * If a system does not have the package manager, the package is not
   * installed or removed no error message is returned. By default,
   * or if you specify `ANY`,
   * the agent attempts to install and remove this package using the default
   * package manager. This is useful when creating a policy that applies to
   * different types of systems.
   *
   * The default behavior is ANY.
   */
  manager: Package_Manager;
}

/** Types of package managers that may be used to manage this package. */
export enum Package_Manager {
  /** MANAGER_UNSPECIFIED - The default behavior is ANY. */
  MANAGER_UNSPECIFIED = 0,
  /** ANY - Apply this package config using the default system package manager. */
  ANY = 1,
  /** APT - Apply this package config only if Apt is available on the system. */
  APT = 2,
  /** YUM - Apply this package config only if Yum is available on the system. */
  YUM = 3,
  /** ZYPPER - Apply this package config only if Zypper is available on the system. */
  ZYPPER = 4,
  /** GOO - Apply this package config only if GooGet is available on the system. */
  GOO = 5,
  UNRECOGNIZED = -1,
}

export function package_ManagerFromJSON(object: any): Package_Manager {
  switch (object) {
    case 0:
    case "MANAGER_UNSPECIFIED":
      return Package_Manager.MANAGER_UNSPECIFIED;
    case 1:
    case "ANY":
      return Package_Manager.ANY;
    case 2:
    case "APT":
      return Package_Manager.APT;
    case 3:
    case "YUM":
      return Package_Manager.YUM;
    case 4:
    case "ZYPPER":
      return Package_Manager.ZYPPER;
    case 5:
    case "GOO":
      return Package_Manager.GOO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Package_Manager.UNRECOGNIZED;
  }
}

export function package_ManagerToJSON(object: Package_Manager): string {
  switch (object) {
    case Package_Manager.MANAGER_UNSPECIFIED:
      return "MANAGER_UNSPECIFIED";
    case Package_Manager.ANY:
      return "ANY";
    case Package_Manager.APT:
      return "APT";
    case Package_Manager.YUM:
      return "YUM";
    case Package_Manager.ZYPPER:
      return "ZYPPER";
    case Package_Manager.GOO:
      return "GOO";
    case Package_Manager.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents a single Apt package repository. This repository is added to
 * a repo file that is stored at
 * `/etc/apt/sources.list.d/google_osconfig.list`.
 */
export interface AptRepository {
  /** Type of archive files in this repository. The default behavior is DEB. */
  archiveType: AptRepository_ArchiveType;
  /** URI for this repository. */
  uri: string;
  /** Distribution of this repository. */
  distribution: string;
  /** List of components for this repository. Must contain at least one item. */
  components: string[];
  /**
   * URI of the key file for this repository. The agent maintains
   * a keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg` containing
   * all the keys in any applied guest policy.
   */
  gpgKey: string;
}

/** Type of archive. */
export enum AptRepository_ArchiveType {
  /** ARCHIVE_TYPE_UNSPECIFIED - Unspecified. */
  ARCHIVE_TYPE_UNSPECIFIED = 0,
  /** DEB - DEB indicates that the archive contains binary files. */
  DEB = 1,
  /** DEB_SRC - DEB_SRC indicates that the archive contains source files. */
  DEB_SRC = 2,
  UNRECOGNIZED = -1,
}

export function aptRepository_ArchiveTypeFromJSON(object: any): AptRepository_ArchiveType {
  switch (object) {
    case 0:
    case "ARCHIVE_TYPE_UNSPECIFIED":
      return AptRepository_ArchiveType.ARCHIVE_TYPE_UNSPECIFIED;
    case 1:
    case "DEB":
      return AptRepository_ArchiveType.DEB;
    case 2:
    case "DEB_SRC":
      return AptRepository_ArchiveType.DEB_SRC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AptRepository_ArchiveType.UNRECOGNIZED;
  }
}

export function aptRepository_ArchiveTypeToJSON(object: AptRepository_ArchiveType): string {
  switch (object) {
    case AptRepository_ArchiveType.ARCHIVE_TYPE_UNSPECIFIED:
      return "ARCHIVE_TYPE_UNSPECIFIED";
    case AptRepository_ArchiveType.DEB:
      return "DEB";
    case AptRepository_ArchiveType.DEB_SRC:
      return "DEB_SRC";
    case AptRepository_ArchiveType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents a single Yum package repository. This repository is added to a
 * repo file that is stored at `/etc/yum.repos.d/google_osconfig.repo`.
 */
export interface YumRepository {
  /**
   * A one word, unique name for this repository. This is
   * the `repo id` in the Yum config file and also the `display_name` if
   * `display_name` is omitted. This id is also used as the unique identifier
   * when checking for guest policy conflicts.
   */
  id: string;
  /** The display name of the repository. */
  displayName: string;
  /** The location of the repository directory. */
  baseUrl: string;
  /** URIs of GPG keys. */
  gpgKeys: string[];
}

/**
 * Represents a single Zypper package repository. This repository is added to a
 * repo file that is stored at `/etc/zypp/repos.d/google_osconfig.repo`.
 */
export interface ZypperRepository {
  /**
   * A one word, unique name for this repository. This is
   * the `repo id` in the zypper config file and also the `display_name` if
   * `display_name` is omitted. This id is also used as the unique identifier
   * when checking for guest policy conflicts.
   */
  id: string;
  /** The display name of the repository. */
  displayName: string;
  /** The location of the repository directory. */
  baseUrl: string;
  /** URIs of GPG keys. */
  gpgKeys: string[];
}

/**
 * Represents a Goo package repository. These is added to a repo file
 * that is stored at C:/ProgramData/GooGet/repos/google_osconfig.repo.
 */
export interface GooRepository {
  /** The name of the repository. */
  name: string;
  /** The url of the repository. */
  url: string;
}

/** A package repository. */
export interface PackageRepository {
  /** An Apt Repository. */
  apt?:
    | AptRepository
    | undefined;
  /** A Yum Repository. */
  yum?:
    | YumRepository
    | undefined;
  /** A Zypper Repository. */
  zypper?:
    | ZypperRepository
    | undefined;
  /** A Goo Repository. */
  goo?: GooRepository | undefined;
}

/**
 * A software recipe is a set of instructions for installing and configuring a
 * piece of software. It consists of a set of artifacts that are
 * downloaded, and a set of steps that install, configure, and/or update the
 * software.
 *
 * Recipes support installing and updating software from artifacts in the
 * following formats:
 * Zip archive, Tar archive, Windows MSI, Debian package, and RPM package.
 *
 * Additionally, recipes support executing a script (either defined in a file or
 * directly in this api) in bash, sh, cmd, and powershell.
 *
 * Updating a software recipe
 *
 * If a recipe is assigned to an instance and there is a recipe with the same
 * name but a lower version already installed and the assigned state
 * of the recipe is `INSTALLED_KEEP_UPDATED`, then the recipe is updated to
 * the new version.
 *
 * Script Working Directories
 *
 * Each script or execution step is run in its own temporary directory which
 * is deleted after completing the step.
 */
export interface SoftwareRecipe {
  /**
   * Unique identifier for the recipe. Only one recipe with a given name is
   * installed on an instance.
   *
   * Names are also used to identify resources which helps to determine whether
   * guest policies have conflicts. This means that requests to create multiple
   * recipes with the same name and version are rejected since they
   * could potentially have conflicting assignments.
   */
  name: string;
  /**
   * The version of this software recipe. Version can be up to 4 period
   * separated numbers (e.g. 12.34.56.78).
   */
  version: string;
  /** Resources available to be used in the steps in the recipe. */
  artifacts: SoftwareRecipe_Artifact[];
  /**
   * Actions to be taken for installing this recipe. On failure it stops
   * executing steps and does not attempt another installation. Any steps taken
   * (including partially completed steps) are not rolled back.  Install steps
   * must be specified and are used on first installation.
   */
  installSteps: SoftwareRecipe_Step[];
  /**
   * Actions to be taken for updating this recipe. On failure it stops
   * executing steps and  does not attempt another update for this recipe. Any
   * steps taken (including partially completed steps) are not rolled back.
   * Upgrade steps are not mandatory and are only used when upgrading.
   */
  updateSteps: SoftwareRecipe_Step[];
  /**
   * Default is INSTALLED. The desired state the agent should maintain for this
   * recipe.
   *
   * INSTALLED: The software recipe is installed on the instance but won't be
   *                         updated to new versions.
   * UPDATED: The software recipe is installed on the instance. The recipe is
   *                         updated to a higher version, if a higher version of
   *                         the recipe is assigned to this instance.
   * REMOVE: Remove is unsupported for software recipes and attempts to
   *         create or update a recipe to the REMOVE state is rejected.
   */
  desiredState: DesiredState;
}

/** Specifies a resource to be used in the recipe. */
export interface SoftwareRecipe_Artifact {
  /**
   * Id of the artifact, which the installation and update steps of this
   * recipe can reference. Artifacts in a recipe cannot have the same id.
   */
  id: string;
  /** A generic remote artifact. */
  remote?:
    | SoftwareRecipe_Artifact_Remote
    | undefined;
  /** A Cloud Storage artifact. */
  gcs?:
    | SoftwareRecipe_Artifact_Gcs
    | undefined;
  /**
   * Defaults to false. When false, recipes are subject to validations
   * based on the artifact type:
   *
   * Remote: A checksum must be specified, and only protocols with
   *         transport-layer security are permitted.
   * GCS:    An object generation number must be specified.
   */
  allowInsecure: boolean;
}

/** Specifies an artifact available via some URI. */
export interface SoftwareRecipe_Artifact_Remote {
  /**
   * URI from which to fetch the object. It should contain both the protocol
   * and path following the format {protocol}://{location}.
   */
  uri: string;
  /**
   * Must be provided if `allow_insecure` is `false`.
   * SHA256 checksum in hex format, to compare to the checksum of the
   * artifact. If the checksum is not empty and it doesn't match the
   * artifact then the recipe installation fails before running any of the
   * steps.
   */
  checksum: string;
}

/** Specifies an artifact available as a Cloud Storage object. */
export interface SoftwareRecipe_Artifact_Gcs {
  /**
   * Bucket of the Cloud Storage object.
   * Given an example URL:
   * `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
   * this value would be `my-bucket`.
   */
  bucket: string;
  /**
   * Name of the Cloud Storage object.
   * As specified [here]
   * (https://cloud.google.com/storage/docs/naming#objectnames)
   * Given an example URL:
   * `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
   * this value would be `foo/bar`.
   */
  object: string;
  /**
   * Must be provided if allow_insecure is false.
   * Generation number of the Cloud Storage object.
   * `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
   * this value would be `1234567`.
   */
  generation: Long;
}

/** An action that can be taken as part of installing or updating a recipe. */
export interface SoftwareRecipe_Step {
  /** Copies a file onto the instance. */
  fileCopy?:
    | SoftwareRecipe_Step_CopyFile
    | undefined;
  /** Extracts an archive into the specified directory. */
  archiveExtraction?:
    | SoftwareRecipe_Step_ExtractArchive
    | undefined;
  /** Installs an MSI file. */
  msiInstallation?:
    | SoftwareRecipe_Step_InstallMsi
    | undefined;
  /** Installs a deb file via dpkg. */
  dpkgInstallation?:
    | SoftwareRecipe_Step_InstallDpkg
    | undefined;
  /** Installs an rpm file via the rpm utility. */
  rpmInstallation?:
    | SoftwareRecipe_Step_InstallRpm
    | undefined;
  /** Executes an artifact or local file. */
  fileExec?:
    | SoftwareRecipe_Step_ExecFile
    | undefined;
  /** Runs commands in a shell. */
  scriptRun?: SoftwareRecipe_Step_RunScript | undefined;
}

/** Copies the artifact to the specified path on the instance. */
export interface SoftwareRecipe_Step_CopyFile {
  /** The id of the relevant artifact in the recipe. */
  artifactId: string;
  /** The absolute path on the instance to put the file. */
  destination: string;
  /**
   * Whether to allow this step to overwrite existing files. If this is
   * false and the file already exists the file is not overwritten
   * and the step is considered a success. Defaults to false.
   */
  overwrite: boolean;
  /**
   * Consists of three octal digits which represent, in
   * order, the permissions of the owner, group, and other users for the
   * file (similarly to the numeric mode used in the linux chmod utility).
   * Each digit represents a three bit number with the 4 bit
   * corresponding to the read permissions, the 2 bit corresponds to the
   * write bit, and the one bit corresponds to the execute permission.
   * Default behavior is 755.
   *
   * Below are some examples of permissions and their associated values:
   * read, write, and execute: 7
   * read and execute: 5
   * read and write: 6
   * read only: 4
   */
  permissions: string;
}

/** Extracts an archive of the type specified in the specified directory. */
export interface SoftwareRecipe_Step_ExtractArchive {
  /** The id of the relevant artifact in the recipe. */
  artifactId: string;
  /**
   * Directory to extract archive to.
   * Defaults to `/` on Linux or `C:\` on Windows.
   */
  destination: string;
  /** The type of the archive to extract. */
  type: SoftwareRecipe_Step_ExtractArchive_ArchiveType;
}

/** Specifying the type of archive. */
export enum SoftwareRecipe_Step_ExtractArchive_ArchiveType {
  /** ARCHIVE_TYPE_UNSPECIFIED - Indicates that the archive type isn't specified. */
  ARCHIVE_TYPE_UNSPECIFIED = 0,
  /** TAR - Indicates that the archive is a tar archive with no encryption. */
  TAR = 1,
  /** TAR_GZIP - Indicates that the archive is a tar archive with gzip encryption. */
  TAR_GZIP = 2,
  /** TAR_BZIP - Indicates that the archive is a tar archive with bzip encryption. */
  TAR_BZIP = 3,
  /** TAR_LZMA - Indicates that the archive is a tar archive with lzma encryption. */
  TAR_LZMA = 4,
  /** TAR_XZ - Indicates that the archive is a tar archive with xz encryption. */
  TAR_XZ = 5,
  /** ZIP - Indicates that the archive is a zip archive. */
  ZIP = 11,
  UNRECOGNIZED = -1,
}

export function softwareRecipe_Step_ExtractArchive_ArchiveTypeFromJSON(
  object: any,
): SoftwareRecipe_Step_ExtractArchive_ArchiveType {
  switch (object) {
    case 0:
    case "ARCHIVE_TYPE_UNSPECIFIED":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.ARCHIVE_TYPE_UNSPECIFIED;
    case 1:
    case "TAR":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR;
    case 2:
    case "TAR_GZIP":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_GZIP;
    case 3:
    case "TAR_BZIP":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_BZIP;
    case 4:
    case "TAR_LZMA":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_LZMA;
    case 5:
    case "TAR_XZ":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_XZ;
    case 11:
    case "ZIP":
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.ZIP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SoftwareRecipe_Step_ExtractArchive_ArchiveType.UNRECOGNIZED;
  }
}

export function softwareRecipe_Step_ExtractArchive_ArchiveTypeToJSON(
  object: SoftwareRecipe_Step_ExtractArchive_ArchiveType,
): string {
  switch (object) {
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.ARCHIVE_TYPE_UNSPECIFIED:
      return "ARCHIVE_TYPE_UNSPECIFIED";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR:
      return "TAR";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_GZIP:
      return "TAR_GZIP";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_BZIP:
      return "TAR_BZIP";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_LZMA:
      return "TAR_LZMA";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.TAR_XZ:
      return "TAR_XZ";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.ZIP:
      return "ZIP";
    case SoftwareRecipe_Step_ExtractArchive_ArchiveType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Installs an MSI file. */
export interface SoftwareRecipe_Step_InstallMsi {
  /** The id of the relevant artifact in the recipe. */
  artifactId: string;
  /**
   * The flags to use when installing the MSI
   * defaults to ["/i"] (i.e. the install flag).
   */
  flags: string[];
  /**
   * Return codes that indicate that the software installed or updated
   * successfully. Behaviour defaults to [0]
   */
  allowedExitCodes: number[];
}

/** Installs a deb via dpkg. */
export interface SoftwareRecipe_Step_InstallDpkg {
  /** The id of the relevant artifact in the recipe. */
  artifactId: string;
}

/** Installs an rpm file via the rpm utility. */
export interface SoftwareRecipe_Step_InstallRpm {
  /** The id of the relevant artifact in the recipe. */
  artifactId: string;
}

/** Executes an artifact or local file. */
export interface SoftwareRecipe_Step_ExecFile {
  /** The id of the relevant artifact in the recipe. */
  artifactId?:
    | string
    | undefined;
  /** The absolute path of the file on the local filesystem. */
  localPath?:
    | string
    | undefined;
  /** Arguments to be passed to the provided executable. */
  args: string[];
  /**
   * Defaults to [0]. A list of possible return values that the program
   * can return to indicate a success.
   */
  allowedExitCodes: number[];
}

/** Runs a script through an interpreter. */
export interface SoftwareRecipe_Step_RunScript {
  /** The shell script to be executed. */
  script: string;
  /**
   * Return codes that indicate that the software installed or updated
   * successfully. Behaviour defaults to [0]
   */
  allowedExitCodes: number[];
  /**
   * The script interpreter to use to run the script. If no interpreter is
   * specified the script is executed directly, which likely
   * only succeed for scripts with
   * [shebang lines](https://en.wikipedia.org/wiki/Shebang_(Unix)).
   */
  interpreter: SoftwareRecipe_Step_RunScript_Interpreter;
}

/** The interpreter used to execute a script. */
export enum SoftwareRecipe_Step_RunScript_Interpreter {
  /** INTERPRETER_UNSPECIFIED - Default value for ScriptType. */
  INTERPRETER_UNSPECIFIED = 0,
  /**
   * SHELL - Indicates that the script is run with `/bin/sh` on Linux and `cmd`
   * on windows.
   */
  SHELL = 1,
  /** POWERSHELL - Indicates that the script is run with powershell. */
  POWERSHELL = 3,
  UNRECOGNIZED = -1,
}

export function softwareRecipe_Step_RunScript_InterpreterFromJSON(
  object: any,
): SoftwareRecipe_Step_RunScript_Interpreter {
  switch (object) {
    case 0:
    case "INTERPRETER_UNSPECIFIED":
      return SoftwareRecipe_Step_RunScript_Interpreter.INTERPRETER_UNSPECIFIED;
    case 1:
    case "SHELL":
      return SoftwareRecipe_Step_RunScript_Interpreter.SHELL;
    case 3:
    case "POWERSHELL":
      return SoftwareRecipe_Step_RunScript_Interpreter.POWERSHELL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SoftwareRecipe_Step_RunScript_Interpreter.UNRECOGNIZED;
  }
}

export function softwareRecipe_Step_RunScript_InterpreterToJSON(
  object: SoftwareRecipe_Step_RunScript_Interpreter,
): string {
  switch (object) {
    case SoftwareRecipe_Step_RunScript_Interpreter.INTERPRETER_UNSPECIFIED:
      return "INTERPRETER_UNSPECIFIED";
    case SoftwareRecipe_Step_RunScript_Interpreter.SHELL:
      return "SHELL";
    case SoftwareRecipe_Step_RunScript_Interpreter.POWERSHELL:
      return "POWERSHELL";
    case SoftwareRecipe_Step_RunScript_Interpreter.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A request message for getting effective policy assigned to the instance. */
export interface LookupEffectiveGuestPolicyRequest {
  /**
   * Required. This is the GCE instance identity token described in
   * https://cloud.google.com/compute/docs/instances/verifying-instance-identity
   * where the audience is 'osconfig.googleapis.com' and the format is 'full'.
   */
  instanceIdToken: string;
  /**
   * Short name of the OS running on the instance. The OS Config agent only
   * provideS this field for targeting if OS Inventory is enabled for that
   * instance.
   */
  osShortName: string;
  /**
   * Version of the OS running on the instance. The OS Config agent only
   * provide this field for targeting if OS Inventory is enabled for that
   * VM instance.
   */
  osVersion: string;
  /**
   * Architecture of OS running on the instance. The OS Config agent only
   * provide this field for targeting if OS Inventory is enabled for that
   * instance.
   */
  osArchitecture: string;
}

/** The effective guest policy assigned to the instance. */
export interface EffectiveGuestPolicy {
  /** List of package configurations assigned to the VM instance. */
  packages: EffectiveGuestPolicy_SourcedPackage[];
  /** List of package repository configurations assigned to the VM instance. */
  packageRepositories: EffectiveGuestPolicy_SourcedPackageRepository[];
  /** List of recipes assigned to the VM instance. */
  softwareRecipes: EffectiveGuestPolicy_SourcedSoftwareRecipe[];
}

/** A guest policy package including its source. */
export interface EffectiveGuestPolicy_SourcedPackage {
  /** Name of the guest policy providing this config. */
  source: string;
  /** A software package to configure on the VM instance. */
  package: Package | undefined;
}

/** A guest policy package repository including its source. */
export interface EffectiveGuestPolicy_SourcedPackageRepository {
  /** Name of the guest policy providing this config. */
  source: string;
  /** A software package repository to configure on the VM instance. */
  packageRepository: PackageRepository | undefined;
}

/** A guest policy recipe including its source. */
export interface EffectiveGuestPolicy_SourcedSoftwareRecipe {
  /** Name of the guest policy providing this config. */
  source: string;
  /** A software recipe to configure on the VM instance. */
  softwareRecipe: SoftwareRecipe | undefined;
}

function createBasePackage(): Package {
  return { name: "", desiredState: 0, manager: 0 };
}

export const Package: MessageFns<Package> = {
  encode(message: Package, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.desiredState !== 0) {
      writer.uint32(16).int32(message.desiredState);
    }
    if (message.manager !== 0) {
      writer.uint32(24).int32(message.manager);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Package {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.desiredState = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.manager = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Package {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      desiredState: isSet(object.desiredState) ? desiredStateFromJSON(object.desiredState) : 0,
      manager: isSet(object.manager) ? package_ManagerFromJSON(object.manager) : 0,
    };
  },

  toJSON(message: Package): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.desiredState !== 0) {
      obj.desiredState = desiredStateToJSON(message.desiredState);
    }
    if (message.manager !== 0) {
      obj.manager = package_ManagerToJSON(message.manager);
    }
    return obj;
  },

  create(base?: DeepPartial<Package>): Package {
    return Package.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Package>): Package {
    const message = createBasePackage();
    message.name = object.name ?? "";
    message.desiredState = object.desiredState ?? 0;
    message.manager = object.manager ?? 0;
    return message;
  },
};

function createBaseAptRepository(): AptRepository {
  return { archiveType: 0, uri: "", distribution: "", components: [], gpgKey: "" };
}

export const AptRepository: MessageFns<AptRepository> = {
  encode(message: AptRepository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.archiveType !== 0) {
      writer.uint32(8).int32(message.archiveType);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.distribution !== "") {
      writer.uint32(26).string(message.distribution);
    }
    for (const v of message.components) {
      writer.uint32(34).string(v!);
    }
    if (message.gpgKey !== "") {
      writer.uint32(42).string(message.gpgKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AptRepository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAptRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.archiveType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.distribution = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.components.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gpgKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AptRepository {
    return {
      archiveType: isSet(object.archiveType) ? aptRepository_ArchiveTypeFromJSON(object.archiveType) : 0,
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      distribution: isSet(object.distribution) ? globalThis.String(object.distribution) : "",
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => globalThis.String(e))
        : [],
      gpgKey: isSet(object.gpgKey) ? globalThis.String(object.gpgKey) : "",
    };
  },

  toJSON(message: AptRepository): unknown {
    const obj: any = {};
    if (message.archiveType !== 0) {
      obj.archiveType = aptRepository_ArchiveTypeToJSON(message.archiveType);
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.distribution !== "") {
      obj.distribution = message.distribution;
    }
    if (message.components?.length) {
      obj.components = message.components;
    }
    if (message.gpgKey !== "") {
      obj.gpgKey = message.gpgKey;
    }
    return obj;
  },

  create(base?: DeepPartial<AptRepository>): AptRepository {
    return AptRepository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AptRepository>): AptRepository {
    const message = createBaseAptRepository();
    message.archiveType = object.archiveType ?? 0;
    message.uri = object.uri ?? "";
    message.distribution = object.distribution ?? "";
    message.components = object.components?.map((e) => e) || [];
    message.gpgKey = object.gpgKey ?? "";
    return message;
  },
};

function createBaseYumRepository(): YumRepository {
  return { id: "", displayName: "", baseUrl: "", gpgKeys: [] };
}

export const YumRepository: MessageFns<YumRepository> = {
  encode(message: YumRepository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.baseUrl !== "") {
      writer.uint32(26).string(message.baseUrl);
    }
    for (const v of message.gpgKeys) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YumRepository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYumRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gpgKeys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): YumRepository {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      gpgKeys: globalThis.Array.isArray(object?.gpgKeys) ? object.gpgKeys.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: YumRepository): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.gpgKeys?.length) {
      obj.gpgKeys = message.gpgKeys;
    }
    return obj;
  },

  create(base?: DeepPartial<YumRepository>): YumRepository {
    return YumRepository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<YumRepository>): YumRepository {
    const message = createBaseYumRepository();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.baseUrl = object.baseUrl ?? "";
    message.gpgKeys = object.gpgKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseZypperRepository(): ZypperRepository {
  return { id: "", displayName: "", baseUrl: "", gpgKeys: [] };
}

export const ZypperRepository: MessageFns<ZypperRepository> = {
  encode(message: ZypperRepository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.baseUrl !== "") {
      writer.uint32(26).string(message.baseUrl);
    }
    for (const v of message.gpgKeys) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZypperRepository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZypperRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gpgKeys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZypperRepository {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : "",
      gpgKeys: globalThis.Array.isArray(object?.gpgKeys) ? object.gpgKeys.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ZypperRepository): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.baseUrl !== "") {
      obj.baseUrl = message.baseUrl;
    }
    if (message.gpgKeys?.length) {
      obj.gpgKeys = message.gpgKeys;
    }
    return obj;
  },

  create(base?: DeepPartial<ZypperRepository>): ZypperRepository {
    return ZypperRepository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ZypperRepository>): ZypperRepository {
    const message = createBaseZypperRepository();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.baseUrl = object.baseUrl ?? "";
    message.gpgKeys = object.gpgKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseGooRepository(): GooRepository {
  return { name: "", url: "" };
}

export const GooRepository: MessageFns<GooRepository> = {
  encode(message: GooRepository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GooRepository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGooRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GooRepository {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: GooRepository): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create(base?: DeepPartial<GooRepository>): GooRepository {
    return GooRepository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GooRepository>): GooRepository {
    const message = createBaseGooRepository();
    message.name = object.name ?? "";
    message.url = object.url ?? "";
    return message;
  },
};

function createBasePackageRepository(): PackageRepository {
  return { apt: undefined, yum: undefined, zypper: undefined, goo: undefined };
}

export const PackageRepository: MessageFns<PackageRepository> = {
  encode(message: PackageRepository, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.apt !== undefined) {
      AptRepository.encode(message.apt, writer.uint32(10).fork()).join();
    }
    if (message.yum !== undefined) {
      YumRepository.encode(message.yum, writer.uint32(18).fork()).join();
    }
    if (message.zypper !== undefined) {
      ZypperRepository.encode(message.zypper, writer.uint32(26).fork()).join();
    }
    if (message.goo !== undefined) {
      GooRepository.encode(message.goo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PackageRepository {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePackageRepository();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.apt = AptRepository.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.yum = YumRepository.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.zypper = ZypperRepository.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.goo = GooRepository.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PackageRepository {
    return {
      apt: isSet(object.apt) ? AptRepository.fromJSON(object.apt) : undefined,
      yum: isSet(object.yum) ? YumRepository.fromJSON(object.yum) : undefined,
      zypper: isSet(object.zypper) ? ZypperRepository.fromJSON(object.zypper) : undefined,
      goo: isSet(object.goo) ? GooRepository.fromJSON(object.goo) : undefined,
    };
  },

  toJSON(message: PackageRepository): unknown {
    const obj: any = {};
    if (message.apt !== undefined) {
      obj.apt = AptRepository.toJSON(message.apt);
    }
    if (message.yum !== undefined) {
      obj.yum = YumRepository.toJSON(message.yum);
    }
    if (message.zypper !== undefined) {
      obj.zypper = ZypperRepository.toJSON(message.zypper);
    }
    if (message.goo !== undefined) {
      obj.goo = GooRepository.toJSON(message.goo);
    }
    return obj;
  },

  create(base?: DeepPartial<PackageRepository>): PackageRepository {
    return PackageRepository.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PackageRepository>): PackageRepository {
    const message = createBasePackageRepository();
    message.apt = (object.apt !== undefined && object.apt !== null) ? AptRepository.fromPartial(object.apt) : undefined;
    message.yum = (object.yum !== undefined && object.yum !== null) ? YumRepository.fromPartial(object.yum) : undefined;
    message.zypper = (object.zypper !== undefined && object.zypper !== null)
      ? ZypperRepository.fromPartial(object.zypper)
      : undefined;
    message.goo = (object.goo !== undefined && object.goo !== null) ? GooRepository.fromPartial(object.goo) : undefined;
    return message;
  },
};

function createBaseSoftwareRecipe(): SoftwareRecipe {
  return { name: "", version: "", artifacts: [], installSteps: [], updateSteps: [], desiredState: 0 };
}

export const SoftwareRecipe: MessageFns<SoftwareRecipe> = {
  encode(message: SoftwareRecipe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    for (const v of message.artifacts) {
      SoftwareRecipe_Artifact.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.installSteps) {
      SoftwareRecipe_Step.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.updateSteps) {
      SoftwareRecipe_Step.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.desiredState !== 0) {
      writer.uint32(48).int32(message.desiredState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.artifacts.push(SoftwareRecipe_Artifact.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.installSteps.push(SoftwareRecipe_Step.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateSteps.push(SoftwareRecipe_Step.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.desiredState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      artifacts: globalThis.Array.isArray(object?.artifacts)
        ? object.artifacts.map((e: any) => SoftwareRecipe_Artifact.fromJSON(e))
        : [],
      installSteps: globalThis.Array.isArray(object?.installSteps)
        ? object.installSteps.map((e: any) => SoftwareRecipe_Step.fromJSON(e))
        : [],
      updateSteps: globalThis.Array.isArray(object?.updateSteps)
        ? object.updateSteps.map((e: any) => SoftwareRecipe_Step.fromJSON(e))
        : [],
      desiredState: isSet(object.desiredState) ? desiredStateFromJSON(object.desiredState) : 0,
    };
  },

  toJSON(message: SoftwareRecipe): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.artifacts?.length) {
      obj.artifacts = message.artifacts.map((e) => SoftwareRecipe_Artifact.toJSON(e));
    }
    if (message.installSteps?.length) {
      obj.installSteps = message.installSteps.map((e) => SoftwareRecipe_Step.toJSON(e));
    }
    if (message.updateSteps?.length) {
      obj.updateSteps = message.updateSteps.map((e) => SoftwareRecipe_Step.toJSON(e));
    }
    if (message.desiredState !== 0) {
      obj.desiredState = desiredStateToJSON(message.desiredState);
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe>): SoftwareRecipe {
    return SoftwareRecipe.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe>): SoftwareRecipe {
    const message = createBaseSoftwareRecipe();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.artifacts = object.artifacts?.map((e) => SoftwareRecipe_Artifact.fromPartial(e)) || [];
    message.installSteps = object.installSteps?.map((e) => SoftwareRecipe_Step.fromPartial(e)) || [];
    message.updateSteps = object.updateSteps?.map((e) => SoftwareRecipe_Step.fromPartial(e)) || [];
    message.desiredState = object.desiredState ?? 0;
    return message;
  },
};

function createBaseSoftwareRecipe_Artifact(): SoftwareRecipe_Artifact {
  return { id: "", remote: undefined, gcs: undefined, allowInsecure: false };
}

export const SoftwareRecipe_Artifact: MessageFns<SoftwareRecipe_Artifact> = {
  encode(message: SoftwareRecipe_Artifact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.remote !== undefined) {
      SoftwareRecipe_Artifact_Remote.encode(message.remote, writer.uint32(18).fork()).join();
    }
    if (message.gcs !== undefined) {
      SoftwareRecipe_Artifact_Gcs.encode(message.gcs, writer.uint32(26).fork()).join();
    }
    if (message.allowInsecure !== false) {
      writer.uint32(32).bool(message.allowInsecure);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Artifact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Artifact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.remote = SoftwareRecipe_Artifact_Remote.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gcs = SoftwareRecipe_Artifact_Gcs.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowInsecure = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Artifact {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      remote: isSet(object.remote) ? SoftwareRecipe_Artifact_Remote.fromJSON(object.remote) : undefined,
      gcs: isSet(object.gcs) ? SoftwareRecipe_Artifact_Gcs.fromJSON(object.gcs) : undefined,
      allowInsecure: isSet(object.allowInsecure) ? globalThis.Boolean(object.allowInsecure) : false,
    };
  },

  toJSON(message: SoftwareRecipe_Artifact): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.remote !== undefined) {
      obj.remote = SoftwareRecipe_Artifact_Remote.toJSON(message.remote);
    }
    if (message.gcs !== undefined) {
      obj.gcs = SoftwareRecipe_Artifact_Gcs.toJSON(message.gcs);
    }
    if (message.allowInsecure !== false) {
      obj.allowInsecure = message.allowInsecure;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Artifact>): SoftwareRecipe_Artifact {
    return SoftwareRecipe_Artifact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Artifact>): SoftwareRecipe_Artifact {
    const message = createBaseSoftwareRecipe_Artifact();
    message.id = object.id ?? "";
    message.remote = (object.remote !== undefined && object.remote !== null)
      ? SoftwareRecipe_Artifact_Remote.fromPartial(object.remote)
      : undefined;
    message.gcs = (object.gcs !== undefined && object.gcs !== null)
      ? SoftwareRecipe_Artifact_Gcs.fromPartial(object.gcs)
      : undefined;
    message.allowInsecure = object.allowInsecure ?? false;
    return message;
  },
};

function createBaseSoftwareRecipe_Artifact_Remote(): SoftwareRecipe_Artifact_Remote {
  return { uri: "", checksum: "" };
}

export const SoftwareRecipe_Artifact_Remote: MessageFns<SoftwareRecipe_Artifact_Remote> = {
  encode(message: SoftwareRecipe_Artifact_Remote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.checksum !== "") {
      writer.uint32(18).string(message.checksum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Artifact_Remote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Artifact_Remote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.checksum = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Artifact_Remote {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
    };
  },

  toJSON(message: SoftwareRecipe_Artifact_Remote): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Artifact_Remote>): SoftwareRecipe_Artifact_Remote {
    return SoftwareRecipe_Artifact_Remote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Artifact_Remote>): SoftwareRecipe_Artifact_Remote {
    const message = createBaseSoftwareRecipe_Artifact_Remote();
    message.uri = object.uri ?? "";
    message.checksum = object.checksum ?? "";
    return message;
  },
};

function createBaseSoftwareRecipe_Artifact_Gcs(): SoftwareRecipe_Artifact_Gcs {
  return { bucket: "", object: "", generation: Long.ZERO };
}

export const SoftwareRecipe_Artifact_Gcs: MessageFns<SoftwareRecipe_Artifact_Gcs> = {
  encode(message: SoftwareRecipe_Artifact_Gcs, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucket !== "") {
      writer.uint32(10).string(message.bucket);
    }
    if (message.object !== "") {
      writer.uint32(18).string(message.object);
    }
    if (!message.generation.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.generation.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Artifact_Gcs {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Artifact_Gcs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.bucket = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.object = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.generation = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Artifact_Gcs {
    return {
      bucket: isSet(object.bucket) ? globalThis.String(object.bucket) : "",
      object: isSet(object.object) ? globalThis.String(object.object) : "",
      generation: isSet(object.generation) ? Long.fromValue(object.generation) : Long.ZERO,
    };
  },

  toJSON(message: SoftwareRecipe_Artifact_Gcs): unknown {
    const obj: any = {};
    if (message.bucket !== "") {
      obj.bucket = message.bucket;
    }
    if (message.object !== "") {
      obj.object = message.object;
    }
    if (!message.generation.equals(Long.ZERO)) {
      obj.generation = (message.generation || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Artifact_Gcs>): SoftwareRecipe_Artifact_Gcs {
    return SoftwareRecipe_Artifact_Gcs.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Artifact_Gcs>): SoftwareRecipe_Artifact_Gcs {
    const message = createBaseSoftwareRecipe_Artifact_Gcs();
    message.bucket = object.bucket ?? "";
    message.object = object.object ?? "";
    message.generation = (object.generation !== undefined && object.generation !== null)
      ? Long.fromValue(object.generation)
      : Long.ZERO;
    return message;
  },
};

function createBaseSoftwareRecipe_Step(): SoftwareRecipe_Step {
  return {
    fileCopy: undefined,
    archiveExtraction: undefined,
    msiInstallation: undefined,
    dpkgInstallation: undefined,
    rpmInstallation: undefined,
    fileExec: undefined,
    scriptRun: undefined,
  };
}

export const SoftwareRecipe_Step: MessageFns<SoftwareRecipe_Step> = {
  encode(message: SoftwareRecipe_Step, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileCopy !== undefined) {
      SoftwareRecipe_Step_CopyFile.encode(message.fileCopy, writer.uint32(10).fork()).join();
    }
    if (message.archiveExtraction !== undefined) {
      SoftwareRecipe_Step_ExtractArchive.encode(message.archiveExtraction, writer.uint32(18).fork()).join();
    }
    if (message.msiInstallation !== undefined) {
      SoftwareRecipe_Step_InstallMsi.encode(message.msiInstallation, writer.uint32(26).fork()).join();
    }
    if (message.dpkgInstallation !== undefined) {
      SoftwareRecipe_Step_InstallDpkg.encode(message.dpkgInstallation, writer.uint32(34).fork()).join();
    }
    if (message.rpmInstallation !== undefined) {
      SoftwareRecipe_Step_InstallRpm.encode(message.rpmInstallation, writer.uint32(42).fork()).join();
    }
    if (message.fileExec !== undefined) {
      SoftwareRecipe_Step_ExecFile.encode(message.fileExec, writer.uint32(50).fork()).join();
    }
    if (message.scriptRun !== undefined) {
      SoftwareRecipe_Step_RunScript.encode(message.scriptRun, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fileCopy = SoftwareRecipe_Step_CopyFile.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.archiveExtraction = SoftwareRecipe_Step_ExtractArchive.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.msiInstallation = SoftwareRecipe_Step_InstallMsi.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dpkgInstallation = SoftwareRecipe_Step_InstallDpkg.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rpmInstallation = SoftwareRecipe_Step_InstallRpm.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fileExec = SoftwareRecipe_Step_ExecFile.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.scriptRun = SoftwareRecipe_Step_RunScript.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step {
    return {
      fileCopy: isSet(object.fileCopy) ? SoftwareRecipe_Step_CopyFile.fromJSON(object.fileCopy) : undefined,
      archiveExtraction: isSet(object.archiveExtraction)
        ? SoftwareRecipe_Step_ExtractArchive.fromJSON(object.archiveExtraction)
        : undefined,
      msiInstallation: isSet(object.msiInstallation)
        ? SoftwareRecipe_Step_InstallMsi.fromJSON(object.msiInstallation)
        : undefined,
      dpkgInstallation: isSet(object.dpkgInstallation)
        ? SoftwareRecipe_Step_InstallDpkg.fromJSON(object.dpkgInstallation)
        : undefined,
      rpmInstallation: isSet(object.rpmInstallation)
        ? SoftwareRecipe_Step_InstallRpm.fromJSON(object.rpmInstallation)
        : undefined,
      fileExec: isSet(object.fileExec) ? SoftwareRecipe_Step_ExecFile.fromJSON(object.fileExec) : undefined,
      scriptRun: isSet(object.scriptRun) ? SoftwareRecipe_Step_RunScript.fromJSON(object.scriptRun) : undefined,
    };
  },

  toJSON(message: SoftwareRecipe_Step): unknown {
    const obj: any = {};
    if (message.fileCopy !== undefined) {
      obj.fileCopy = SoftwareRecipe_Step_CopyFile.toJSON(message.fileCopy);
    }
    if (message.archiveExtraction !== undefined) {
      obj.archiveExtraction = SoftwareRecipe_Step_ExtractArchive.toJSON(message.archiveExtraction);
    }
    if (message.msiInstallation !== undefined) {
      obj.msiInstallation = SoftwareRecipe_Step_InstallMsi.toJSON(message.msiInstallation);
    }
    if (message.dpkgInstallation !== undefined) {
      obj.dpkgInstallation = SoftwareRecipe_Step_InstallDpkg.toJSON(message.dpkgInstallation);
    }
    if (message.rpmInstallation !== undefined) {
      obj.rpmInstallation = SoftwareRecipe_Step_InstallRpm.toJSON(message.rpmInstallation);
    }
    if (message.fileExec !== undefined) {
      obj.fileExec = SoftwareRecipe_Step_ExecFile.toJSON(message.fileExec);
    }
    if (message.scriptRun !== undefined) {
      obj.scriptRun = SoftwareRecipe_Step_RunScript.toJSON(message.scriptRun);
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step>): SoftwareRecipe_Step {
    return SoftwareRecipe_Step.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step>): SoftwareRecipe_Step {
    const message = createBaseSoftwareRecipe_Step();
    message.fileCopy = (object.fileCopy !== undefined && object.fileCopy !== null)
      ? SoftwareRecipe_Step_CopyFile.fromPartial(object.fileCopy)
      : undefined;
    message.archiveExtraction = (object.archiveExtraction !== undefined && object.archiveExtraction !== null)
      ? SoftwareRecipe_Step_ExtractArchive.fromPartial(object.archiveExtraction)
      : undefined;
    message.msiInstallation = (object.msiInstallation !== undefined && object.msiInstallation !== null)
      ? SoftwareRecipe_Step_InstallMsi.fromPartial(object.msiInstallation)
      : undefined;
    message.dpkgInstallation = (object.dpkgInstallation !== undefined && object.dpkgInstallation !== null)
      ? SoftwareRecipe_Step_InstallDpkg.fromPartial(object.dpkgInstallation)
      : undefined;
    message.rpmInstallation = (object.rpmInstallation !== undefined && object.rpmInstallation !== null)
      ? SoftwareRecipe_Step_InstallRpm.fromPartial(object.rpmInstallation)
      : undefined;
    message.fileExec = (object.fileExec !== undefined && object.fileExec !== null)
      ? SoftwareRecipe_Step_ExecFile.fromPartial(object.fileExec)
      : undefined;
    message.scriptRun = (object.scriptRun !== undefined && object.scriptRun !== null)
      ? SoftwareRecipe_Step_RunScript.fromPartial(object.scriptRun)
      : undefined;
    return message;
  },
};

function createBaseSoftwareRecipe_Step_CopyFile(): SoftwareRecipe_Step_CopyFile {
  return { artifactId: "", destination: "", overwrite: false, permissions: "" };
}

export const SoftwareRecipe_Step_CopyFile: MessageFns<SoftwareRecipe_Step_CopyFile> = {
  encode(message: SoftwareRecipe_Step_CopyFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    if (message.destination !== "") {
      writer.uint32(18).string(message.destination);
    }
    if (message.overwrite !== false) {
      writer.uint32(24).bool(message.overwrite);
    }
    if (message.permissions !== "") {
      writer.uint32(34).string(message.permissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_CopyFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_CopyFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.overwrite = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.permissions = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_CopyFile {
    return {
      artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : "",
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      overwrite: isSet(object.overwrite) ? globalThis.Boolean(object.overwrite) : false,
      permissions: isSet(object.permissions) ? globalThis.String(object.permissions) : "",
    };
  },

  toJSON(message: SoftwareRecipe_Step_CopyFile): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.overwrite !== false) {
      obj.overwrite = message.overwrite;
    }
    if (message.permissions !== "") {
      obj.permissions = message.permissions;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_CopyFile>): SoftwareRecipe_Step_CopyFile {
    return SoftwareRecipe_Step_CopyFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_CopyFile>): SoftwareRecipe_Step_CopyFile {
    const message = createBaseSoftwareRecipe_Step_CopyFile();
    message.artifactId = object.artifactId ?? "";
    message.destination = object.destination ?? "";
    message.overwrite = object.overwrite ?? false;
    message.permissions = object.permissions ?? "";
    return message;
  },
};

function createBaseSoftwareRecipe_Step_ExtractArchive(): SoftwareRecipe_Step_ExtractArchive {
  return { artifactId: "", destination: "", type: 0 };
}

export const SoftwareRecipe_Step_ExtractArchive: MessageFns<SoftwareRecipe_Step_ExtractArchive> = {
  encode(message: SoftwareRecipe_Step_ExtractArchive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    if (message.destination !== "") {
      writer.uint32(18).string(message.destination);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_ExtractArchive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_ExtractArchive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.destination = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_ExtractArchive {
    return {
      artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : "",
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      type: isSet(object.type) ? softwareRecipe_Step_ExtractArchive_ArchiveTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: SoftwareRecipe_Step_ExtractArchive): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.type !== 0) {
      obj.type = softwareRecipe_Step_ExtractArchive_ArchiveTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_ExtractArchive>): SoftwareRecipe_Step_ExtractArchive {
    return SoftwareRecipe_Step_ExtractArchive.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_ExtractArchive>): SoftwareRecipe_Step_ExtractArchive {
    const message = createBaseSoftwareRecipe_Step_ExtractArchive();
    message.artifactId = object.artifactId ?? "";
    message.destination = object.destination ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseSoftwareRecipe_Step_InstallMsi(): SoftwareRecipe_Step_InstallMsi {
  return { artifactId: "", flags: [], allowedExitCodes: [] };
}

export const SoftwareRecipe_Step_InstallMsi: MessageFns<SoftwareRecipe_Step_InstallMsi> = {
  encode(message: SoftwareRecipe_Step_InstallMsi, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    for (const v of message.flags) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(26).fork();
    for (const v of message.allowedExitCodes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_InstallMsi {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_InstallMsi();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.flags.push(reader.string());
          continue;
        case 3:
          if (tag === 24) {
            message.allowedExitCodes.push(reader.int32());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedExitCodes.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_InstallMsi {
    return {
      artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : "",
      flags: globalThis.Array.isArray(object?.flags) ? object.flags.map((e: any) => globalThis.String(e)) : [],
      allowedExitCodes: globalThis.Array.isArray(object?.allowedExitCodes)
        ? object.allowedExitCodes.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: SoftwareRecipe_Step_InstallMsi): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    if (message.flags?.length) {
      obj.flags = message.flags;
    }
    if (message.allowedExitCodes?.length) {
      obj.allowedExitCodes = message.allowedExitCodes.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_InstallMsi>): SoftwareRecipe_Step_InstallMsi {
    return SoftwareRecipe_Step_InstallMsi.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_InstallMsi>): SoftwareRecipe_Step_InstallMsi {
    const message = createBaseSoftwareRecipe_Step_InstallMsi();
    message.artifactId = object.artifactId ?? "";
    message.flags = object.flags?.map((e) => e) || [];
    message.allowedExitCodes = object.allowedExitCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSoftwareRecipe_Step_InstallDpkg(): SoftwareRecipe_Step_InstallDpkg {
  return { artifactId: "" };
}

export const SoftwareRecipe_Step_InstallDpkg: MessageFns<SoftwareRecipe_Step_InstallDpkg> = {
  encode(message: SoftwareRecipe_Step_InstallDpkg, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_InstallDpkg {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_InstallDpkg();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_InstallDpkg {
    return { artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : "" };
  },

  toJSON(message: SoftwareRecipe_Step_InstallDpkg): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_InstallDpkg>): SoftwareRecipe_Step_InstallDpkg {
    return SoftwareRecipe_Step_InstallDpkg.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_InstallDpkg>): SoftwareRecipe_Step_InstallDpkg {
    const message = createBaseSoftwareRecipe_Step_InstallDpkg();
    message.artifactId = object.artifactId ?? "";
    return message;
  },
};

function createBaseSoftwareRecipe_Step_InstallRpm(): SoftwareRecipe_Step_InstallRpm {
  return { artifactId: "" };
}

export const SoftwareRecipe_Step_InstallRpm: MessageFns<SoftwareRecipe_Step_InstallRpm> = {
  encode(message: SoftwareRecipe_Step_InstallRpm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== "") {
      writer.uint32(10).string(message.artifactId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_InstallRpm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_InstallRpm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_InstallRpm {
    return { artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : "" };
  },

  toJSON(message: SoftwareRecipe_Step_InstallRpm): unknown {
    const obj: any = {};
    if (message.artifactId !== "") {
      obj.artifactId = message.artifactId;
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_InstallRpm>): SoftwareRecipe_Step_InstallRpm {
    return SoftwareRecipe_Step_InstallRpm.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_InstallRpm>): SoftwareRecipe_Step_InstallRpm {
    const message = createBaseSoftwareRecipe_Step_InstallRpm();
    message.artifactId = object.artifactId ?? "";
    return message;
  },
};

function createBaseSoftwareRecipe_Step_ExecFile(): SoftwareRecipe_Step_ExecFile {
  return { artifactId: undefined, localPath: undefined, args: [], allowedExitCodes: [] };
}

export const SoftwareRecipe_Step_ExecFile: MessageFns<SoftwareRecipe_Step_ExecFile> = {
  encode(message: SoftwareRecipe_Step_ExecFile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.artifactId !== undefined) {
      writer.uint32(10).string(message.artifactId);
    }
    if (message.localPath !== undefined) {
      writer.uint32(18).string(message.localPath);
    }
    for (const v of message.args) {
      writer.uint32(26).string(v!);
    }
    writer.uint32(34).fork();
    for (const v of message.allowedExitCodes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_ExecFile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_ExecFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.artifactId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.localPath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.args.push(reader.string());
          continue;
        case 4:
          if (tag === 32) {
            message.allowedExitCodes.push(reader.int32());

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedExitCodes.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_ExecFile {
    return {
      artifactId: isSet(object.artifactId) ? globalThis.String(object.artifactId) : undefined,
      localPath: isSet(object.localPath) ? globalThis.String(object.localPath) : undefined,
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
      allowedExitCodes: globalThis.Array.isArray(object?.allowedExitCodes)
        ? object.allowedExitCodes.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: SoftwareRecipe_Step_ExecFile): unknown {
    const obj: any = {};
    if (message.artifactId !== undefined) {
      obj.artifactId = message.artifactId;
    }
    if (message.localPath !== undefined) {
      obj.localPath = message.localPath;
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    if (message.allowedExitCodes?.length) {
      obj.allowedExitCodes = message.allowedExitCodes.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_ExecFile>): SoftwareRecipe_Step_ExecFile {
    return SoftwareRecipe_Step_ExecFile.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_ExecFile>): SoftwareRecipe_Step_ExecFile {
    const message = createBaseSoftwareRecipe_Step_ExecFile();
    message.artifactId = object.artifactId ?? undefined;
    message.localPath = object.localPath ?? undefined;
    message.args = object.args?.map((e) => e) || [];
    message.allowedExitCodes = object.allowedExitCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSoftwareRecipe_Step_RunScript(): SoftwareRecipe_Step_RunScript {
  return { script: "", allowedExitCodes: [], interpreter: 0 };
}

export const SoftwareRecipe_Step_RunScript: MessageFns<SoftwareRecipe_Step_RunScript> = {
  encode(message: SoftwareRecipe_Step_RunScript, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.script !== "") {
      writer.uint32(10).string(message.script);
    }
    writer.uint32(18).fork();
    for (const v of message.allowedExitCodes) {
      writer.int32(v);
    }
    writer.join();
    if (message.interpreter !== 0) {
      writer.uint32(24).int32(message.interpreter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SoftwareRecipe_Step_RunScript {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSoftwareRecipe_Step_RunScript();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.script = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.allowedExitCodes.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedExitCodes.push(reader.int32());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.interpreter = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SoftwareRecipe_Step_RunScript {
    return {
      script: isSet(object.script) ? globalThis.String(object.script) : "",
      allowedExitCodes: globalThis.Array.isArray(object?.allowedExitCodes)
        ? object.allowedExitCodes.map((e: any) => globalThis.Number(e))
        : [],
      interpreter: isSet(object.interpreter)
        ? softwareRecipe_Step_RunScript_InterpreterFromJSON(object.interpreter)
        : 0,
    };
  },

  toJSON(message: SoftwareRecipe_Step_RunScript): unknown {
    const obj: any = {};
    if (message.script !== "") {
      obj.script = message.script;
    }
    if (message.allowedExitCodes?.length) {
      obj.allowedExitCodes = message.allowedExitCodes.map((e) => Math.round(e));
    }
    if (message.interpreter !== 0) {
      obj.interpreter = softwareRecipe_Step_RunScript_InterpreterToJSON(message.interpreter);
    }
    return obj;
  },

  create(base?: DeepPartial<SoftwareRecipe_Step_RunScript>): SoftwareRecipe_Step_RunScript {
    return SoftwareRecipe_Step_RunScript.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SoftwareRecipe_Step_RunScript>): SoftwareRecipe_Step_RunScript {
    const message = createBaseSoftwareRecipe_Step_RunScript();
    message.script = object.script ?? "";
    message.allowedExitCodes = object.allowedExitCodes?.map((e) => e) || [];
    message.interpreter = object.interpreter ?? 0;
    return message;
  },
};

function createBaseLookupEffectiveGuestPolicyRequest(): LookupEffectiveGuestPolicyRequest {
  return { instanceIdToken: "", osShortName: "", osVersion: "", osArchitecture: "" };
}

export const LookupEffectiveGuestPolicyRequest: MessageFns<LookupEffectiveGuestPolicyRequest> = {
  encode(message: LookupEffectiveGuestPolicyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instanceIdToken !== "") {
      writer.uint32(10).string(message.instanceIdToken);
    }
    if (message.osShortName !== "") {
      writer.uint32(18).string(message.osShortName);
    }
    if (message.osVersion !== "") {
      writer.uint32(26).string(message.osVersion);
    }
    if (message.osArchitecture !== "") {
      writer.uint32(34).string(message.osArchitecture);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupEffectiveGuestPolicyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupEffectiveGuestPolicyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instanceIdToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.osShortName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.osVersion = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.osArchitecture = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupEffectiveGuestPolicyRequest {
    return {
      instanceIdToken: isSet(object.instanceIdToken) ? globalThis.String(object.instanceIdToken) : "",
      osShortName: isSet(object.osShortName) ? globalThis.String(object.osShortName) : "",
      osVersion: isSet(object.osVersion) ? globalThis.String(object.osVersion) : "",
      osArchitecture: isSet(object.osArchitecture) ? globalThis.String(object.osArchitecture) : "",
    };
  },

  toJSON(message: LookupEffectiveGuestPolicyRequest): unknown {
    const obj: any = {};
    if (message.instanceIdToken !== "") {
      obj.instanceIdToken = message.instanceIdToken;
    }
    if (message.osShortName !== "") {
      obj.osShortName = message.osShortName;
    }
    if (message.osVersion !== "") {
      obj.osVersion = message.osVersion;
    }
    if (message.osArchitecture !== "") {
      obj.osArchitecture = message.osArchitecture;
    }
    return obj;
  },

  create(base?: DeepPartial<LookupEffectiveGuestPolicyRequest>): LookupEffectiveGuestPolicyRequest {
    return LookupEffectiveGuestPolicyRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LookupEffectiveGuestPolicyRequest>): LookupEffectiveGuestPolicyRequest {
    const message = createBaseLookupEffectiveGuestPolicyRequest();
    message.instanceIdToken = object.instanceIdToken ?? "";
    message.osShortName = object.osShortName ?? "";
    message.osVersion = object.osVersion ?? "";
    message.osArchitecture = object.osArchitecture ?? "";
    return message;
  },
};

function createBaseEffectiveGuestPolicy(): EffectiveGuestPolicy {
  return { packages: [], packageRepositories: [], softwareRecipes: [] };
}

export const EffectiveGuestPolicy: MessageFns<EffectiveGuestPolicy> = {
  encode(message: EffectiveGuestPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.packages) {
      EffectiveGuestPolicy_SourcedPackage.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.packageRepositories) {
      EffectiveGuestPolicy_SourcedPackageRepository.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.softwareRecipes) {
      EffectiveGuestPolicy_SourcedSoftwareRecipe.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectiveGuestPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectiveGuestPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.packages.push(EffectiveGuestPolicy_SourcedPackage.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.packageRepositories.push(
            EffectiveGuestPolicy_SourcedPackageRepository.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.softwareRecipes.push(EffectiveGuestPolicy_SourcedSoftwareRecipe.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectiveGuestPolicy {
    return {
      packages: globalThis.Array.isArray(object?.packages)
        ? object.packages.map((e: any) => EffectiveGuestPolicy_SourcedPackage.fromJSON(e))
        : [],
      packageRepositories: globalThis.Array.isArray(object?.packageRepositories)
        ? object.packageRepositories.map((e: any) => EffectiveGuestPolicy_SourcedPackageRepository.fromJSON(e))
        : [],
      softwareRecipes: globalThis.Array.isArray(object?.softwareRecipes)
        ? object.softwareRecipes.map((e: any) => EffectiveGuestPolicy_SourcedSoftwareRecipe.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EffectiveGuestPolicy): unknown {
    const obj: any = {};
    if (message.packages?.length) {
      obj.packages = message.packages.map((e) => EffectiveGuestPolicy_SourcedPackage.toJSON(e));
    }
    if (message.packageRepositories?.length) {
      obj.packageRepositories = message.packageRepositories.map((e) =>
        EffectiveGuestPolicy_SourcedPackageRepository.toJSON(e)
      );
    }
    if (message.softwareRecipes?.length) {
      obj.softwareRecipes = message.softwareRecipes.map((e) => EffectiveGuestPolicy_SourcedSoftwareRecipe.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EffectiveGuestPolicy>): EffectiveGuestPolicy {
    return EffectiveGuestPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EffectiveGuestPolicy>): EffectiveGuestPolicy {
    const message = createBaseEffectiveGuestPolicy();
    message.packages = object.packages?.map((e) => EffectiveGuestPolicy_SourcedPackage.fromPartial(e)) || [];
    message.packageRepositories =
      object.packageRepositories?.map((e) => EffectiveGuestPolicy_SourcedPackageRepository.fromPartial(e)) || [];
    message.softwareRecipes =
      object.softwareRecipes?.map((e) => EffectiveGuestPolicy_SourcedSoftwareRecipe.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEffectiveGuestPolicy_SourcedPackage(): EffectiveGuestPolicy_SourcedPackage {
  return { source: "", package: undefined };
}

export const EffectiveGuestPolicy_SourcedPackage: MessageFns<EffectiveGuestPolicy_SourcedPackage> = {
  encode(message: EffectiveGuestPolicy_SourcedPackage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.package !== undefined) {
      Package.encode(message.package, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectiveGuestPolicy_SourcedPackage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectiveGuestPolicy_SourcedPackage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.package = Package.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectiveGuestPolicy_SourcedPackage {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      package: isSet(object.package) ? Package.fromJSON(object.package) : undefined,
    };
  },

  toJSON(message: EffectiveGuestPolicy_SourcedPackage): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.package !== undefined) {
      obj.package = Package.toJSON(message.package);
    }
    return obj;
  },

  create(base?: DeepPartial<EffectiveGuestPolicy_SourcedPackage>): EffectiveGuestPolicy_SourcedPackage {
    return EffectiveGuestPolicy_SourcedPackage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EffectiveGuestPolicy_SourcedPackage>): EffectiveGuestPolicy_SourcedPackage {
    const message = createBaseEffectiveGuestPolicy_SourcedPackage();
    message.source = object.source ?? "";
    message.package = (object.package !== undefined && object.package !== null)
      ? Package.fromPartial(object.package)
      : undefined;
    return message;
  },
};

function createBaseEffectiveGuestPolicy_SourcedPackageRepository(): EffectiveGuestPolicy_SourcedPackageRepository {
  return { source: "", packageRepository: undefined };
}

export const EffectiveGuestPolicy_SourcedPackageRepository: MessageFns<EffectiveGuestPolicy_SourcedPackageRepository> =
  {
    encode(
      message: EffectiveGuestPolicy_SourcedPackageRepository,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.source !== "") {
        writer.uint32(10).string(message.source);
      }
      if (message.packageRepository !== undefined) {
        PackageRepository.encode(message.packageRepository, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EffectiveGuestPolicy_SourcedPackageRepository {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEffectiveGuestPolicy_SourcedPackageRepository();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.source = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.packageRepository = PackageRepository.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EffectiveGuestPolicy_SourcedPackageRepository {
      return {
        source: isSet(object.source) ? globalThis.String(object.source) : "",
        packageRepository: isSet(object.packageRepository)
          ? PackageRepository.fromJSON(object.packageRepository)
          : undefined,
      };
    },

    toJSON(message: EffectiveGuestPolicy_SourcedPackageRepository): unknown {
      const obj: any = {};
      if (message.source !== "") {
        obj.source = message.source;
      }
      if (message.packageRepository !== undefined) {
        obj.packageRepository = PackageRepository.toJSON(message.packageRepository);
      }
      return obj;
    },

    create(
      base?: DeepPartial<EffectiveGuestPolicy_SourcedPackageRepository>,
    ): EffectiveGuestPolicy_SourcedPackageRepository {
      return EffectiveGuestPolicy_SourcedPackageRepository.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<EffectiveGuestPolicy_SourcedPackageRepository>,
    ): EffectiveGuestPolicy_SourcedPackageRepository {
      const message = createBaseEffectiveGuestPolicy_SourcedPackageRepository();
      message.source = object.source ?? "";
      message.packageRepository = (object.packageRepository !== undefined && object.packageRepository !== null)
        ? PackageRepository.fromPartial(object.packageRepository)
        : undefined;
      return message;
    },
  };

function createBaseEffectiveGuestPolicy_SourcedSoftwareRecipe(): EffectiveGuestPolicy_SourcedSoftwareRecipe {
  return { source: "", softwareRecipe: undefined };
}

export const EffectiveGuestPolicy_SourcedSoftwareRecipe: MessageFns<EffectiveGuestPolicy_SourcedSoftwareRecipe> = {
  encode(message: EffectiveGuestPolicy_SourcedSoftwareRecipe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.softwareRecipe !== undefined) {
      SoftwareRecipe.encode(message.softwareRecipe, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectiveGuestPolicy_SourcedSoftwareRecipe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectiveGuestPolicy_SourcedSoftwareRecipe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.softwareRecipe = SoftwareRecipe.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectiveGuestPolicy_SourcedSoftwareRecipe {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      softwareRecipe: isSet(object.softwareRecipe) ? SoftwareRecipe.fromJSON(object.softwareRecipe) : undefined,
    };
  },

  toJSON(message: EffectiveGuestPolicy_SourcedSoftwareRecipe): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.softwareRecipe !== undefined) {
      obj.softwareRecipe = SoftwareRecipe.toJSON(message.softwareRecipe);
    }
    return obj;
  },

  create(base?: DeepPartial<EffectiveGuestPolicy_SourcedSoftwareRecipe>): EffectiveGuestPolicy_SourcedSoftwareRecipe {
    return EffectiveGuestPolicy_SourcedSoftwareRecipe.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<EffectiveGuestPolicy_SourcedSoftwareRecipe>,
  ): EffectiveGuestPolicy_SourcedSoftwareRecipe {
    const message = createBaseEffectiveGuestPolicy_SourcedSoftwareRecipe();
    message.source = object.source ?? "";
    message.softwareRecipe = (object.softwareRecipe !== undefined && object.softwareRecipe !== null)
      ? SoftwareRecipe.fromPartial(object.softwareRecipe)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
