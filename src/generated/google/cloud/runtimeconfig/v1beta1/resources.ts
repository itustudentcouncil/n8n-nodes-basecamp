// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/runtimeconfig/v1beta1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";

export const protobufPackage = "google.cloud.runtimeconfig.v1beta1";

/**
 * The `VariableState` describes the last known state of the variable and is
 * used during a `variables().watch` call to distinguish the state of the
 * variable.
 */
export enum VariableState {
  /** VARIABLE_STATE_UNSPECIFIED - Default variable state. */
  VARIABLE_STATE_UNSPECIFIED = 0,
  /** UPDATED - The variable was updated, while `variables().watch` was executing. */
  UPDATED = 1,
  /** DELETED - The variable was deleted, while `variables().watch` was executing. */
  DELETED = 2,
  UNRECOGNIZED = -1,
}

export function variableStateFromJSON(object: any): VariableState {
  switch (object) {
    case 0:
    case "VARIABLE_STATE_UNSPECIFIED":
      return VariableState.VARIABLE_STATE_UNSPECIFIED;
    case 1:
    case "UPDATED":
      return VariableState.UPDATED;
    case 2:
    case "DELETED":
      return VariableState.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VariableState.UNRECOGNIZED;
  }
}

export function variableStateToJSON(object: VariableState): string {
  switch (object) {
    case VariableState.VARIABLE_STATE_UNSPECIFIED:
      return "VARIABLE_STATE_UNSPECIFIED";
    case VariableState.UPDATED:
      return "UPDATED";
    case VariableState.DELETED:
      return "DELETED";
    case VariableState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A RuntimeConfig resource is the primary resource in the Cloud RuntimeConfig
 * service. A RuntimeConfig resource consists of metadata and a hierarchy of
 * variables.
 */
export interface RuntimeConfig {
  /**
   * The resource name of a runtime config. The name must have the format:
   *
   *     projects/[PROJECT_ID]/configs/[CONFIG_NAME]
   *
   * The `[PROJECT_ID]` must be a valid project ID, and `[CONFIG_NAME]` is an
   * arbitrary name that matches RFC 1035 segment specification. The length of
   * `[CONFIG_NAME]` must be less than 64 bytes.
   *
   * You pick the RuntimeConfig resource name, but the server will validate that
   * the name adheres to this format. After you create the resource, you cannot
   * change the resource's name.
   */
  name: string;
  /** An optional description of the RuntimeConfig object. */
  description: string;
}

/**
 * Describes a single variable within a RuntimeConfig resource.
 * The name denotes the hierarchical variable name. For example,
 * `ports/serving_port` is a valid variable name. The variable value is an
 * opaque string and only leaf variables can have values (that is, variables
 * that do not have any child variables).
 */
export interface Variable {
  /**
   * The name of the variable resource, in the format:
   *
   *     projects/[PROJECT_ID]/configs/[CONFIG_NAME]/variables/[VARIABLE_NAME]
   *
   * The `[PROJECT_ID]` must be a valid project ID, `[CONFIG_NAME]` must be a
   * valid RuntimeConfig reource and `[VARIABLE_NAME]` follows Unix file system
   * file path naming.
   *
   * The `[VARIABLE_NAME]` can contain ASCII letters, numbers, slashes and
   * dashes. Slashes are used as path element separators and are not part of the
   * `[VARIABLE_NAME]` itself, so `[VARIABLE_NAME]` must contain at least one
   * non-slash character. Multiple slashes are coalesced into single slash
   * character. Each path segment should follow RFC 1035 segment specification.
   * The length of a `[VARIABLE_NAME]` must be less than 256 bytes.
   *
   * Once you create a variable, you cannot change the variable name.
   */
  name: string;
  /**
   * The binary value of the variable. The length of the value must be less
   * than 4096 bytes. Empty values are also accepted. The value must be
   * base64 encoded. Only one of `value` or `text` can be set.
   */
  value?:
    | Buffer
    | undefined;
  /**
   * The string value of the variable. The length of the value must be less
   * than 4096 bytes. Empty values are also accepted. For example,
   * `text: "my text value"`. The string must be valid UTF-8.
   */
  text?:
    | string
    | undefined;
  /** [Output Only] The time of the last variable update. */
  updateTime:
    | Date
    | undefined;
  /**
   * [Ouput only] The current state of the variable. The variable state
   * indicates the outcome of the `variables().watch` call and is visible
   * through the `get` and `list` calls.
   */
  state: VariableState;
}

/** The condition that a Waiter resource is waiting for. */
export interface EndCondition {
  /** The cardinality of the `EndCondition`. */
  cardinality?: EndCondition_Cardinality | undefined;
}

/**
 * A Cardinality condition for the Waiter resource. A cardinality condition is
 * met when the number of variables under a specified path prefix reaches a
 * predefined number. For example, if you set a Cardinality condition where
 * the `path` is set to `/foo` and the number of paths is set to 2, the
 * following variables would meet the condition in a RuntimeConfig resource:
 *
 * + `/foo/variable1 = "value1"`
 * + `/foo/variable2 = "value2"`
 * + `/bar/variable3 = "value3"`
 *
 * It would not would not satisify the same condition with the `number` set to
 * 3, however, because there is only 2 paths that start with `/foo`.
 * Cardinality conditions are recursive; all subtrees under the specific
 * path prefix are counted.
 */
export interface EndCondition_Cardinality {
  /** The root of the variable subtree to monitor. For example, `/foo`. */
  path: string;
  /**
   * The number variables under the `path` that must exist to meet this
   * condition. Defaults to 1 if not specified.
   */
  number: number;
}

/**
 * A Waiter resource waits for some end condition within a RuntimeConfig
 * resource to be met before it returns. For example, assume you have a
 * distributed system where each node writes to a Variable resource indidicating
 * the node's readiness as part of the startup process.
 *
 * You then configure a Waiter resource with the success condition set to wait
 * until some number of nodes have checked in. Afterwards, your application
 * runs some arbitrary code after the condition has been met and the waiter
 * returns successfully.
 *
 * Once created, a Waiter resource is immutable.
 *
 * To learn more about using waiters, read the
 * [Creating a
 * Waiter](/deployment-manager/runtime-configurator/creating-a-waiter)
 * documentation.
 */
export interface Waiter {
  /**
   * The name of the Waiter resource, in the format:
   *
   *     projects/[PROJECT_ID]/configs/[CONFIG_NAME]/waiters/[WAITER_NAME]
   *
   * The `[PROJECT_ID]` must be a valid Google Cloud project ID,
   * the `[CONFIG_NAME]` must be a valid RuntimeConfig resource, the
   * `[WAITER_NAME]` must match RFC 1035 segment specification, and the length
   * of `[WAITER_NAME]` must be less than 64 bytes.
   *
   * After you create a Waiter resource, you cannot change the resource name.
   */
  name: string;
  /**
   * [Required] Specifies the timeout of the waiter in seconds, beginning from
   * the instant that `waiters().create` method is called. If this time elapses
   * before the success or failure conditions are met, the waiter fails and sets
   * the `error` code to `DEADLINE_EXCEEDED`.
   */
  timeout:
    | Duration
    | undefined;
  /**
   * [Optional] The failure condition of this waiter. If this condition is met,
   * `done` will be set to `true` and the `error` code will be set to `ABORTED`.
   * The failure condition takes precedence over the success condition. If both
   * conditions are met, a failure will be indicated. This value is optional; if
   * no failure condition is set, the only failure scenario will be a timeout.
   */
  failure:
    | EndCondition
    | undefined;
  /**
   * [Required] The success condition. If this condition is met, `done` will be
   * set to `true` and the `error` value will remain unset. The failure
   * condition takes precedence over the success condition. If both conditions
   * are met, a failure will be indicated.
   */
  success:
    | EndCondition
    | undefined;
  /**
   * [Output Only] The instant at which this Waiter resource was created. Adding
   * the value of `timeout` to this instant yields the timeout deadline for the
   * waiter.
   */
  createTime:
    | Date
    | undefined;
  /**
   * [Output Only] If the value is `false`, it means the waiter is still waiting
   * for one of its conditions to be met.
   *
   * If true, the waiter has finished. If the waiter finished due to a timeout
   * or failure, `error` will be set.
   */
  done: boolean;
  /**
   * [Output Only] If the waiter ended due to a failure or timeout, this value
   * will be set.
   */
  error: Status | undefined;
}

function createBaseRuntimeConfig(): RuntimeConfig {
  return { name: "", description: "" };
}

export const RuntimeConfig: MessageFns<RuntimeConfig> = {
  encode(message: RuntimeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: RuntimeConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeConfig>): RuntimeConfig {
    return RuntimeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeConfig>): RuntimeConfig {
    const message = createBaseRuntimeConfig();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseVariable(): Variable {
  return { name: "", value: undefined, text: undefined, updateTime: undefined, state: 0 };
}

export const Variable: MessageFns<Variable> = {
  encode(message: Variable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      writer.uint32(18).bytes(message.value);
    }
    if (message.text !== undefined) {
      writer.uint32(42).string(message.text);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variable {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : undefined,
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? variableStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Variable): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = variableStateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<Variable>): Variable {
    return Variable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Variable>): Variable {
    const message = createBaseVariable();
    message.name = object.name ?? "";
    message.value = object.value ?? undefined;
    message.text = object.text ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseEndCondition(): EndCondition {
  return { cardinality: undefined };
}

export const EndCondition: MessageFns<EndCondition> = {
  encode(message: EndCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardinality !== undefined) {
      EndCondition_Cardinality.encode(message.cardinality, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cardinality = EndCondition_Cardinality.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndCondition {
    return {
      cardinality: isSet(object.cardinality) ? EndCondition_Cardinality.fromJSON(object.cardinality) : undefined,
    };
  },

  toJSON(message: EndCondition): unknown {
    const obj: any = {};
    if (message.cardinality !== undefined) {
      obj.cardinality = EndCondition_Cardinality.toJSON(message.cardinality);
    }
    return obj;
  },

  create(base?: DeepPartial<EndCondition>): EndCondition {
    return EndCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EndCondition>): EndCondition {
    const message = createBaseEndCondition();
    message.cardinality = (object.cardinality !== undefined && object.cardinality !== null)
      ? EndCondition_Cardinality.fromPartial(object.cardinality)
      : undefined;
    return message;
  },
};

function createBaseEndCondition_Cardinality(): EndCondition_Cardinality {
  return { path: "", number: 0 };
}

export const EndCondition_Cardinality: MessageFns<EndCondition_Cardinality> = {
  encode(message: EndCondition_Cardinality, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.number !== 0) {
      writer.uint32(16).int32(message.number);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EndCondition_Cardinality {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEndCondition_Cardinality();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.number = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EndCondition_Cardinality {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      number: isSet(object.number) ? globalThis.Number(object.number) : 0,
    };
  },

  toJSON(message: EndCondition_Cardinality): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    return obj;
  },

  create(base?: DeepPartial<EndCondition_Cardinality>): EndCondition_Cardinality {
    return EndCondition_Cardinality.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EndCondition_Cardinality>): EndCondition_Cardinality {
    const message = createBaseEndCondition_Cardinality();
    message.path = object.path ?? "";
    message.number = object.number ?? 0;
    return message;
  },
};

function createBaseWaiter(): Waiter {
  return {
    name: "",
    timeout: undefined,
    failure: undefined,
    success: undefined,
    createTime: undefined,
    done: false,
    error: undefined,
  };
}

export const Waiter: MessageFns<Waiter> = {
  encode(message: Waiter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(18).fork()).join();
    }
    if (message.failure !== undefined) {
      EndCondition.encode(message.failure, writer.uint32(26).fork()).join();
    }
    if (message.success !== undefined) {
      EndCondition.encode(message.success, writer.uint32(34).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.done !== false) {
      writer.uint32(48).bool(message.done);
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Waiter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWaiter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.failure = EndCondition.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.success = EndCondition.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.done = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Waiter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      failure: isSet(object.failure) ? EndCondition.fromJSON(object.failure) : undefined,
      success: isSet(object.success) ? EndCondition.fromJSON(object.success) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      done: isSet(object.done) ? globalThis.Boolean(object.done) : false,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: Waiter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.failure !== undefined) {
      obj.failure = EndCondition.toJSON(message.failure);
    }
    if (message.success !== undefined) {
      obj.success = EndCondition.toJSON(message.success);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.done !== false) {
      obj.done = message.done;
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<Waiter>): Waiter {
    return Waiter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Waiter>): Waiter {
    const message = createBaseWaiter();
    message.name = object.name ?? "";
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.failure = (object.failure !== undefined && object.failure !== null)
      ? EndCondition.fromPartial(object.failure)
      : undefined;
    message.success = (object.success !== undefined && object.success !== null)
      ? EndCondition.fromPartial(object.success)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.done = object.done ?? false;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
