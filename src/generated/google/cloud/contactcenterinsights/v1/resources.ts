// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/contactcenterinsights/v1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.contactcenterinsights.v1";

/** The conversation resource. */
export interface Conversation {
  /** Call-specific metadata. */
  callMetadata?:
    | Conversation_CallMetadata
    | undefined;
  /**
   * The time at which this conversation should expire. After this time, the
   * conversation data and any associated analyses will be deleted.
   */
  expireTime?:
    | Date
    | undefined;
  /**
   * Input only. The TTL for this resource. If specified, then this TTL will
   * be used to calculate the expire time.
   */
  ttl?:
    | Duration
    | undefined;
  /**
   * Immutable. The resource name of the conversation.
   * Format:
   * projects/{project}/locations/{location}/conversations/{conversation}
   */
  name: string;
  /** The source of the audio and transcription for the conversation. */
  dataSource:
    | ConversationDataSource
    | undefined;
  /** Output only. The time at which the conversation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The most recent time at which the conversation was updated. */
  updateTime:
    | Date
    | undefined;
  /** The time at which the conversation started. */
  startTime:
    | Date
    | undefined;
  /** A user-specified language code for the conversation. */
  languageCode: string;
  /**
   * An opaque, user-specified string representing the human agent who handled
   * the conversation.
   */
  agentId: string;
  /**
   * A map for the user to specify any custom fields. A maximum of 20 labels per
   * conversation is allowed, with a maximum of 256 characters per entry.
   */
  labels: { [key: string]: string };
  /** Conversation metadata related to quality management. */
  qualityMetadata:
    | Conversation_QualityMetadata
    | undefined;
  /** Output only. The conversation transcript. */
  transcript:
    | Conversation_Transcript
    | undefined;
  /**
   * Immutable. The conversation medium, if unspecified will default to
   * PHONE_CALL.
   */
  medium: Conversation_Medium;
  /** Output only. The duration of the conversation. */
  duration:
    | Duration
    | undefined;
  /** Output only. The number of turns in the conversation. */
  turnCount: number;
  /** Output only. The conversation's latest analysis, if one exists. */
  latestAnalysis:
    | Analysis
    | undefined;
  /** Output only. Latest summary of the conversation. */
  latestSummary:
    | ConversationSummarizationSuggestionData
    | undefined;
  /**
   * Output only. The annotations that were generated during the customer and
   * agent interaction.
   */
  runtimeAnnotations: RuntimeAnnotation[];
  /**
   * Output only. All the matched Dialogflow intents in the call. The key
   * corresponds to a Dialogflow intent, format:
   * projects/{project}/agent/{agent}/intents/{intent}
   */
  dialogflowIntents: { [key: string]: DialogflowIntent };
  /** Obfuscated user ID which the customer sent to us. */
  obfuscatedUserId: string;
}

/** Possible media for the conversation. */
export enum Conversation_Medium {
  /** MEDIUM_UNSPECIFIED - Default value, if unspecified will default to PHONE_CALL. */
  MEDIUM_UNSPECIFIED = 0,
  /** PHONE_CALL - The format for conversations that took place over the phone. */
  PHONE_CALL = 1,
  /** CHAT - The format for conversations that took place over chat. */
  CHAT = 2,
  UNRECOGNIZED = -1,
}

export function conversation_MediumFromJSON(object: any): Conversation_Medium {
  switch (object) {
    case 0:
    case "MEDIUM_UNSPECIFIED":
      return Conversation_Medium.MEDIUM_UNSPECIFIED;
    case 1:
    case "PHONE_CALL":
      return Conversation_Medium.PHONE_CALL;
    case 2:
    case "CHAT":
      return Conversation_Medium.CHAT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Conversation_Medium.UNRECOGNIZED;
  }
}

export function conversation_MediumToJSON(object: Conversation_Medium): string {
  switch (object) {
    case Conversation_Medium.MEDIUM_UNSPECIFIED:
      return "MEDIUM_UNSPECIFIED";
    case Conversation_Medium.PHONE_CALL:
      return "PHONE_CALL";
    case Conversation_Medium.CHAT:
      return "CHAT";
    case Conversation_Medium.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Call-specific metadata. */
export interface Conversation_CallMetadata {
  /** The audio channel that contains the customer. */
  customerChannel: number;
  /** The audio channel that contains the agent. */
  agentChannel: number;
}

/** Conversation metadata related to quality management. */
export interface Conversation_QualityMetadata {
  /** An arbitrary integer value indicating the customer's satisfaction rating. */
  customerSatisfactionRating: number;
  /** The amount of time the customer waited to connect with an agent. */
  waitDuration:
    | Duration
    | undefined;
  /** An arbitrary string value specifying the menu path the customer took. */
  menuPath: string;
  /** Information about agents involved in the call. */
  agentInfo: Conversation_QualityMetadata_AgentInfo[];
}

/** Information about an agent involved in the conversation. */
export interface Conversation_QualityMetadata_AgentInfo {
  /** A user-specified string representing the agent. */
  agentId: string;
  /** The agent's name. */
  displayName: string;
  /** A user-specified string representing the agent's team. */
  team: string;
  /**
   * A user-provided string indicating the outcome of the agent's segment of
   * the call.
   */
  dispositionCode: string;
}

/** A message representing the transcript of a conversation. */
export interface Conversation_Transcript {
  /** A list of sequential transcript segments that comprise the conversation. */
  transcriptSegments: Conversation_Transcript_TranscriptSegment[];
}

/** A segment of a full transcript. */
export interface Conversation_Transcript_TranscriptSegment {
  /** The time that the message occurred, if provided. */
  messageTime:
    | Date
    | undefined;
  /** The text of this segment. */
  text: string;
  /**
   * A confidence estimate between 0.0 and 1.0 of the fidelity of this
   * segment. A default value of 0.0 indicates that the value is unset.
   */
  confidence: number;
  /** A list of the word-specific information for each word in the segment. */
  words: Conversation_Transcript_TranscriptSegment_WordInfo[];
  /**
   * The language code of this segment as a
   * [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
   * Example: "en-US".
   */
  languageCode: string;
  /**
   * For conversations derived from multi-channel audio, this is the channel
   * number corresponding to the audio from that channel. For
   * audioChannelCount = N, its output values can range from '1' to 'N'. A
   * channel tag of 0 indicates that the audio is mono.
   */
  channelTag: number;
  /** The participant of this segment. */
  segmentParticipant:
    | ConversationParticipant
    | undefined;
  /** CCAI metadata relating to the current transcript segment. */
  dialogflowSegmentMetadata:
    | Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata
    | undefined;
  /** The sentiment for this transcript segment. */
  sentiment: SentimentData | undefined;
}

/** Word-level info for words in a transcript. */
export interface Conversation_Transcript_TranscriptSegment_WordInfo {
  /**
   * Time offset of the start of this word relative to the beginning of
   * the total conversation.
   */
  startOffset:
    | Duration
    | undefined;
  /**
   * Time offset of the end of this word relative to the beginning of the
   * total conversation.
   */
  endOffset:
    | Duration
    | undefined;
  /** The word itself. Includes punctuation marks that surround the word. */
  word: string;
  /**
   * A confidence estimate between 0.0 and 1.0 of the fidelity of this
   * word. A default value of 0.0 indicates that the value is unset.
   */
  confidence: number;
}

/** Metadata from Dialogflow relating to the current transcript segment. */
export interface Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata {
  /**
   * Whether the transcript segment was covered under the configured smart
   * reply allowlist in Agent Assist.
   */
  smartReplyAllowlistCovered: boolean;
}

export interface Conversation_LabelsEntry {
  key: string;
  value: string;
}

export interface Conversation_DialogflowIntentsEntry {
  key: string;
  value: DialogflowIntent | undefined;
}

/** The analysis resource. */
export interface Analysis {
  /**
   * Immutable. The resource name of the analysis.
   * Format:
   * projects/{project}/locations/{location}/conversations/{conversation}/analyses/{analysis}
   */
  name: string;
  /** Output only. The time at which the analysis was requested. */
  requestTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which the analysis was created, which occurs when
   * the long-running operation completes.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The result of the analysis, which is populated when the
   * analysis finishes.
   */
  analysisResult:
    | AnalysisResult
    | undefined;
  /**
   * To select the annotators to run and the phrase matchers to use
   * (if any). If not specified, all annotators will be run.
   */
  annotatorSelector: AnnotatorSelector | undefined;
}

/** The conversation source, which is a combination of transcript and audio. */
export interface ConversationDataSource {
  /** A Cloud Storage location specification for the audio and transcript. */
  gcsSource?:
    | GcsSource
    | undefined;
  /** The source when the conversation comes from Dialogflow. */
  dialogflowSource?: DialogflowSource | undefined;
}

/** A Cloud Storage source of conversation data. */
export interface GcsSource {
  /**
   * Cloud Storage URI that points to a file that contains the conversation
   * audio.
   */
  audioUri: string;
  /**
   * Immutable. Cloud Storage URI that points to a file that contains the
   * conversation transcript.
   */
  transcriptUri: string;
}

/** A Dialogflow source of conversation data. */
export interface DialogflowSource {
  /**
   * Output only. The name of the Dialogflow conversation that this conversation
   * resource is derived from. Format:
   * projects/{project}/locations/{location}/conversations/{conversation}
   */
  dialogflowConversation: string;
  /**
   * Cloud Storage URI that points to a file that contains the conversation
   * audio.
   */
  audioUri: string;
}

/** The result of an analysis. */
export interface AnalysisResult {
  /** Call-specific metadata created by the analysis. */
  callAnalysisMetadata?:
    | AnalysisResult_CallAnalysisMetadata
    | undefined;
  /** The time at which the analysis ended. */
  endTime: Date | undefined;
}

/** Call-specific metadata created during analysis. */
export interface AnalysisResult_CallAnalysisMetadata {
  /** A list of call annotations that apply to this call. */
  annotations: CallAnnotation[];
  /** All the entities in the call. */
  entities: { [key: string]: Entity };
  /** Overall conversation-level sentiment for each channel of the call. */
  sentiments: ConversationLevelSentiment[];
  /** All the matched intents in the call. */
  intents: { [key: string]: Intent };
  /** All the matched phrase matchers in the call. */
  phraseMatchers: { [key: string]: PhraseMatchData };
  /** Overall conversation-level issue modeling result. */
  issueModelResult: IssueModelResult | undefined;
}

export interface AnalysisResult_CallAnalysisMetadata_EntitiesEntry {
  key: string;
  value: Entity | undefined;
}

export interface AnalysisResult_CallAnalysisMetadata_IntentsEntry {
  key: string;
  value: Intent | undefined;
}

export interface AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry {
  key: string;
  value: PhraseMatchData | undefined;
}

/** Issue Modeling result on a conversation. */
export interface IssueModelResult {
  /**
   * Issue model that generates the result.
   * Format: projects/{project}/locations/{location}/issueModels/{issue_model}
   */
  issueModel: string;
  /** All the matched issues. */
  issues: IssueAssignment[];
}

/** One channel of conversation-level sentiment data. */
export interface ConversationLevelSentiment {
  /** The channel of the audio that the data applies to. */
  channelTag: number;
  /** Data specifying sentiment. */
  sentimentData: SentimentData | undefined;
}

/** Information about the issue. */
export interface IssueAssignment {
  /** Resource name of the assigned issue. */
  issue: string;
  /**
   * Score indicating the likelihood of the issue assignment.
   * currently bounded on [0,1].
   */
  score: number;
  /**
   * Immutable. Display name of the assigned issue. This field is set at time of
   * analyis and immutable since then.
   */
  displayName: string;
}

/** A piece of metadata that applies to a window of a call. */
export interface CallAnnotation {
  /** Data specifying an interruption. */
  interruptionData?:
    | InterruptionData
    | undefined;
  /** Data specifying sentiment. */
  sentimentData?:
    | SentimentData
    | undefined;
  /** Data specifying silence. */
  silenceData?:
    | SilenceData
    | undefined;
  /** Data specifying a hold. */
  holdData?:
    | HoldData
    | undefined;
  /** Data specifying an entity mention. */
  entityMentionData?:
    | EntityMentionData
    | undefined;
  /** Data specifying an intent match. */
  intentMatchData?:
    | IntentMatchData
    | undefined;
  /** Data specifying a phrase match. */
  phraseMatchData?:
    | PhraseMatchData
    | undefined;
  /** Data specifying an issue match. */
  issueMatchData?:
    | IssueMatchData
    | undefined;
  /**
   * The channel of the audio where the annotation occurs. For single-channel
   * audio, this field is not populated.
   */
  channelTag: number;
  /** The boundary in the conversation where the annotation starts, inclusive. */
  annotationStartBoundary:
    | AnnotationBoundary
    | undefined;
  /** The boundary in the conversation where the annotation ends, inclusive. */
  annotationEndBoundary: AnnotationBoundary | undefined;
}

/** A point in a conversation that marks the start or the end of an annotation. */
export interface AnnotationBoundary {
  /**
   * The word index of this boundary with respect to the first word in the
   * transcript piece. This index starts at zero.
   */
  wordIndex?:
    | number
    | undefined;
  /**
   * The index in the sequence of transcribed pieces of the conversation where
   * the boundary is located. This index starts at zero.
   */
  transcriptIndex: number;
}

/**
 * The data for an entity annotation.
 * Represents a phrase in the conversation that is a known entity, such
 * as a person, an organization, or location.
 */
export interface Entity {
  /** The representative name for the entity. */
  displayName: string;
  /** The entity type. */
  type: Entity_Type;
  /**
   * Metadata associated with the entity.
   *
   * For most entity types, the metadata is a Wikipedia URL (`wikipedia_url`)
   * and Knowledge Graph MID (`mid`), if they are available. For the metadata
   * associated with other entity types, see the Type table below.
   */
  metadata: { [key: string]: string };
  /**
   * The salience score associated with the entity in the [0, 1.0] range.
   *
   * The salience score for an entity provides information about the
   * importance or centrality of that entity to the entire document text.
   * Scores closer to 0 are less salient, while scores closer to 1.0 are highly
   * salient.
   */
  salience: number;
  /** The aggregate sentiment expressed for this entity in the conversation. */
  sentiment: SentimentData | undefined;
}

/**
 * The type of the entity. For most entity types, the associated metadata is a
 * Wikipedia URL (`wikipedia_url`) and Knowledge Graph MID (`mid`). The table
 * below lists the associated fields for entities that have different
 * metadata.
 */
export enum Entity_Type {
  /** TYPE_UNSPECIFIED - Unspecified. */
  TYPE_UNSPECIFIED = 0,
  /** PERSON - Person. */
  PERSON = 1,
  /** LOCATION - Location. */
  LOCATION = 2,
  /** ORGANIZATION - Organization. */
  ORGANIZATION = 3,
  /** EVENT - Event. */
  EVENT = 4,
  /** WORK_OF_ART - Artwork. */
  WORK_OF_ART = 5,
  /** CONSUMER_GOOD - Consumer product. */
  CONSUMER_GOOD = 6,
  /** OTHER - Other types of entities. */
  OTHER = 7,
  /**
   * PHONE_NUMBER - Phone number.
   *
   * The metadata lists the phone number (formatted according to local
   * convention), plus whichever additional elements appear in the text:
   *
   * * `number` - The actual number, broken down into sections according to
   * local convention.
   * * `national_prefix` - Country code, if detected.
   * * `area_code` - Region or area code, if detected.
   * * `extension` - Phone extension (to be dialed after connection), if
   * detected.
   */
  PHONE_NUMBER = 9,
  /**
   * ADDRESS - Address.
   *
   * The metadata identifies the street number and locality plus whichever
   * additional elements appear in the text:
   *
   * * `street_number` - Street number.
   * * `locality` - City or town.
   * * `street_name` - Street/route name, if detected.
   * * `postal_code` - Postal code, if detected.
   * * `country` - Country, if detected.
   * * `broad_region` - Administrative area, such as the state, if detected.
   * * `narrow_region` - Smaller administrative area, such as county, if
   * detected.
   * * `sublocality` - Used in Asian addresses to demark a district within a
   * city, if detected.
   */
  ADDRESS = 10,
  /**
   * DATE - Date.
   *
   * The metadata identifies the components of the date:
   *
   * * `year` - Four digit year, if detected.
   * * `month` - Two digit month number, if detected.
   * * `day` - Two digit day number, if detected.
   */
  DATE = 11,
  /**
   * NUMBER - Number.
   *
   * The metadata is the number itself.
   */
  NUMBER = 12,
  /**
   * PRICE - Price.
   *
   * The metadata identifies the `value` and `currency`.
   */
  PRICE = 13,
  UNRECOGNIZED = -1,
}

export function entity_TypeFromJSON(object: any): Entity_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Entity_Type.TYPE_UNSPECIFIED;
    case 1:
    case "PERSON":
      return Entity_Type.PERSON;
    case 2:
    case "LOCATION":
      return Entity_Type.LOCATION;
    case 3:
    case "ORGANIZATION":
      return Entity_Type.ORGANIZATION;
    case 4:
    case "EVENT":
      return Entity_Type.EVENT;
    case 5:
    case "WORK_OF_ART":
      return Entity_Type.WORK_OF_ART;
    case 6:
    case "CONSUMER_GOOD":
      return Entity_Type.CONSUMER_GOOD;
    case 7:
    case "OTHER":
      return Entity_Type.OTHER;
    case 9:
    case "PHONE_NUMBER":
      return Entity_Type.PHONE_NUMBER;
    case 10:
    case "ADDRESS":
      return Entity_Type.ADDRESS;
    case 11:
    case "DATE":
      return Entity_Type.DATE;
    case 12:
    case "NUMBER":
      return Entity_Type.NUMBER;
    case 13:
    case "PRICE":
      return Entity_Type.PRICE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Entity_Type.UNRECOGNIZED;
  }
}

export function entity_TypeToJSON(object: Entity_Type): string {
  switch (object) {
    case Entity_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Entity_Type.PERSON:
      return "PERSON";
    case Entity_Type.LOCATION:
      return "LOCATION";
    case Entity_Type.ORGANIZATION:
      return "ORGANIZATION";
    case Entity_Type.EVENT:
      return "EVENT";
    case Entity_Type.WORK_OF_ART:
      return "WORK_OF_ART";
    case Entity_Type.CONSUMER_GOOD:
      return "CONSUMER_GOOD";
    case Entity_Type.OTHER:
      return "OTHER";
    case Entity_Type.PHONE_NUMBER:
      return "PHONE_NUMBER";
    case Entity_Type.ADDRESS:
      return "ADDRESS";
    case Entity_Type.DATE:
      return "DATE";
    case Entity_Type.NUMBER:
      return "NUMBER";
    case Entity_Type.PRICE:
      return "PRICE";
    case Entity_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Entity_MetadataEntry {
  key: string;
  value: string;
}

/**
 * The data for an intent.
 * Represents a detected intent in the conversation, for example MAKES_PROMISE.
 */
export interface Intent {
  /** The unique identifier of the intent. */
  id: string;
  /** The human-readable name of the intent. */
  displayName: string;
}

/**
 * The data for a matched phrase matcher.
 * Represents information identifying a phrase matcher for a given match.
 */
export interface PhraseMatchData {
  /** The unique identifier (the resource name) of the phrase matcher. */
  phraseMatcher: string;
  /** The human-readable name of the phrase matcher. */
  displayName: string;
}

/**
 * The data for a Dialogflow intent.
 * Represents a detected intent in the conversation, e.g. MAKES_PROMISE.
 */
export interface DialogflowIntent {
  /** The human-readable name of the intent. */
  displayName: string;
}

/** The data for an interruption annotation. */
export interface InterruptionData {
}

/** The data for a silence annotation. */
export interface SilenceData {
}

/** The data for a hold annotation. */
export interface HoldData {
}

/**
 * The data for an entity mention annotation.
 * This represents a mention of an `Entity` in the conversation.
 */
export interface EntityMentionData {
  /**
   * The key of this entity in conversation entities.
   * Can be used to retrieve the exact `Entity` this mention is attached to.
   */
  entityUniqueId: string;
  /** The type of the entity mention. */
  type: EntityMentionData_MentionType;
  /** Sentiment expressed for this mention of the entity. */
  sentiment: SentimentData | undefined;
}

/** The supported types of mentions. */
export enum EntityMentionData_MentionType {
  /** MENTION_TYPE_UNSPECIFIED - Unspecified. */
  MENTION_TYPE_UNSPECIFIED = 0,
  /** PROPER - Proper noun. */
  PROPER = 1,
  /** COMMON - Common noun (or noun compound). */
  COMMON = 2,
  UNRECOGNIZED = -1,
}

export function entityMentionData_MentionTypeFromJSON(object: any): EntityMentionData_MentionType {
  switch (object) {
    case 0:
    case "MENTION_TYPE_UNSPECIFIED":
      return EntityMentionData_MentionType.MENTION_TYPE_UNSPECIFIED;
    case 1:
    case "PROPER":
      return EntityMentionData_MentionType.PROPER;
    case 2:
    case "COMMON":
      return EntityMentionData_MentionType.COMMON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EntityMentionData_MentionType.UNRECOGNIZED;
  }
}

export function entityMentionData_MentionTypeToJSON(object: EntityMentionData_MentionType): string {
  switch (object) {
    case EntityMentionData_MentionType.MENTION_TYPE_UNSPECIFIED:
      return "MENTION_TYPE_UNSPECIFIED";
    case EntityMentionData_MentionType.PROPER:
      return "PROPER";
    case EntityMentionData_MentionType.COMMON:
      return "COMMON";
    case EntityMentionData_MentionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The data for an intent match.
 * Represents an intent match for a text segment in the conversation. A text
 * segment can be part of a sentence, a complete sentence, or an utterance
 * with multiple sentences.
 */
export interface IntentMatchData {
  /**
   * The id of the matched intent.
   * Can be used to retrieve the corresponding intent information.
   */
  intentUniqueId: string;
}

/** The data for a sentiment annotation. */
export interface SentimentData {
  /**
   * A non-negative number from 0 to infinity which represents the abolute
   * magnitude of sentiment regardless of score.
   */
  magnitude: number;
  /** The sentiment score between -1.0 (negative) and 1.0 (positive). */
  score: number;
}

/** The data for an issue match annotation. */
export interface IssueMatchData {
  /** Information about the issue's assignment. */
  issueAssignment: IssueAssignment | undefined;
}

/** The issue model resource. */
export interface IssueModel {
  /**
   * Immutable. The resource name of the issue model.
   * Format:
   * projects/{project}/locations/{location}/issueModels/{issue_model}
   */
  name: string;
  /** The representative name for the issue model. */
  displayName: string;
  /** Output only. The time at which this issue model was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The most recent time at which the issue model was updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. Number of issues in this issue model. */
  issueCount: Long;
  /** Output only. State of the model. */
  state: IssueModel_State;
  /** Configs for the input data that used to create the issue model. */
  inputDataConfig:
    | IssueModel_InputDataConfig
    | undefined;
  /**
   * Output only. Immutable. The issue model's label statistics on its training
   * data.
   */
  trainingStats:
    | IssueModelLabelStats
    | undefined;
  /** Type of the model. */
  modelType: IssueModel_ModelType;
  /** Language of the model. */
  languageCode: string;
}

/** State of the model. */
export enum IssueModel_State {
  /** STATE_UNSPECIFIED - Unspecified. */
  STATE_UNSPECIFIED = 0,
  /** UNDEPLOYED - Model is not deployed but is ready to deploy. */
  UNDEPLOYED = 1,
  /** DEPLOYING - Model is being deployed. */
  DEPLOYING = 2,
  /**
   * DEPLOYED - Model is deployed and is ready to be used. A model can only be used in
   * analysis if it's in this state.
   */
  DEPLOYED = 3,
  /** UNDEPLOYING - Model is being undeployed. */
  UNDEPLOYING = 4,
  /** DELETING - Model is being deleted. */
  DELETING = 5,
  UNRECOGNIZED = -1,
}

export function issueModel_StateFromJSON(object: any): IssueModel_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return IssueModel_State.STATE_UNSPECIFIED;
    case 1:
    case "UNDEPLOYED":
      return IssueModel_State.UNDEPLOYED;
    case 2:
    case "DEPLOYING":
      return IssueModel_State.DEPLOYING;
    case 3:
    case "DEPLOYED":
      return IssueModel_State.DEPLOYED;
    case 4:
    case "UNDEPLOYING":
      return IssueModel_State.UNDEPLOYING;
    case 5:
    case "DELETING":
      return IssueModel_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IssueModel_State.UNRECOGNIZED;
  }
}

export function issueModel_StateToJSON(object: IssueModel_State): string {
  switch (object) {
    case IssueModel_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case IssueModel_State.UNDEPLOYED:
      return "UNDEPLOYED";
    case IssueModel_State.DEPLOYING:
      return "DEPLOYING";
    case IssueModel_State.DEPLOYED:
      return "DEPLOYED";
    case IssueModel_State.UNDEPLOYING:
      return "UNDEPLOYING";
    case IssueModel_State.DELETING:
      return "DELETING";
    case IssueModel_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of the model. */
export enum IssueModel_ModelType {
  /** MODEL_TYPE_UNSPECIFIED - Unspecified model type. */
  MODEL_TYPE_UNSPECIFIED = 0,
  /** TYPE_V1 - Type V1. */
  TYPE_V1 = 1,
  /** TYPE_V2 - Type V2. */
  TYPE_V2 = 2,
  UNRECOGNIZED = -1,
}

export function issueModel_ModelTypeFromJSON(object: any): IssueModel_ModelType {
  switch (object) {
    case 0:
    case "MODEL_TYPE_UNSPECIFIED":
      return IssueModel_ModelType.MODEL_TYPE_UNSPECIFIED;
    case 1:
    case "TYPE_V1":
      return IssueModel_ModelType.TYPE_V1;
    case 2:
    case "TYPE_V2":
      return IssueModel_ModelType.TYPE_V2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IssueModel_ModelType.UNRECOGNIZED;
  }
}

export function issueModel_ModelTypeToJSON(object: IssueModel_ModelType): string {
  switch (object) {
    case IssueModel_ModelType.MODEL_TYPE_UNSPECIFIED:
      return "MODEL_TYPE_UNSPECIFIED";
    case IssueModel_ModelType.TYPE_V1:
      return "TYPE_V1";
    case IssueModel_ModelType.TYPE_V2:
      return "TYPE_V2";
    case IssueModel_ModelType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configs for the input data used to create the issue model. */
export interface IssueModel_InputDataConfig {
  /**
   * Medium of conversations used in training data. This field is being
   * deprecated. To specify the medium to be used in training a new issue
   * model, set the `medium` field on `filter`.
   *
   * @deprecated
   */
  medium: Conversation_Medium;
  /** Output only. Number of conversations used in training. Output only. */
  trainingConversationsCount: Long;
  /**
   * A filter to reduce the conversations used for training the model to a
   * specific subset.
   */
  filter: string;
}

/** The issue resource. */
export interface Issue {
  /**
   * Immutable. The resource name of the issue.
   * Format:
   * projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue}
   */
  name: string;
  /** The representative name for the issue. */
  displayName: string;
  /** Output only. The time at which this issue was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The most recent time that this issue was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Resource names of the sample representative utterances that
   * match to this issue.
   */
  sampleUtterances: string[];
}

/** Aggregated statistics about an issue model. */
export interface IssueModelLabelStats {
  /** Number of conversations the issue model has analyzed at this point in time. */
  analyzedConversationsCount: Long;
  /**
   * Number of analyzed conversations for which no issue was applicable at this
   * point in time.
   */
  unclassifiedConversationsCount: Long;
  /** Statistics on each issue. Key is the issue's resource name. */
  issueStats: { [key: string]: IssueModelLabelStats_IssueStats };
}

/** Aggregated statistics about an issue. */
export interface IssueModelLabelStats_IssueStats {
  /**
   * Issue resource.
   * Format:
   * projects/{project}/locations/{location}/issueModels/{issue_model}/issues/{issue}
   */
  issue: string;
  /** Number of conversations attached to the issue at this point in time. */
  labeledConversationsCount: Long;
  /** Display name of the issue. */
  displayName: string;
}

export interface IssueModelLabelStats_IssueStatsEntry {
  key: string;
  value: IssueModelLabelStats_IssueStats | undefined;
}

/** The phrase matcher resource. */
export interface PhraseMatcher {
  /**
   * The resource name of the phrase matcher.
   * Format:
   * projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher}
   */
  name: string;
  /**
   * Output only. Immutable. The revision ID of the phrase matcher.
   * A new revision is committed whenever the matcher is changed, except when it
   * is activated or deactivated. A server generated random ID will be used.
   * Example: locations/global/phraseMatchers/my-first-matcher@1234567
   */
  revisionId: string;
  /**
   * The customized version tag to use for the phrase matcher. If not specified,
   * it will default to `revision_id`.
   */
  versionTag: string;
  /**
   * Output only. The timestamp of when the revision was created. It is also the
   * create time when a new matcher is added.
   */
  revisionCreateTime:
    | Date
    | undefined;
  /** The human-readable name of the phrase matcher. */
  displayName: string;
  /** Required. The type of this phrase matcher. */
  type: PhraseMatcher_PhraseMatcherType;
  /** Applies the phrase matcher only when it is active. */
  active: boolean;
  /** A list of phase match rule groups that are included in this matcher. */
  phraseMatchRuleGroups: PhraseMatchRuleGroup[];
  /**
   * Output only. The most recent time at which the activation status was
   * updated.
   */
  activationUpdateTime:
    | Date
    | undefined;
  /**
   * The role whose utterances the phrase matcher should be matched
   * against. If the role is ROLE_UNSPECIFIED it will be matched against any
   * utterances in the transcript.
   */
  roleMatch: ConversationParticipant_Role;
  /** Output only. The most recent time at which the phrase matcher was updated. */
  updateTime: Date | undefined;
}

/**
 * Specifies how to combine each phrase match rule group to determine whether
 * there is a match.
 */
export enum PhraseMatcher_PhraseMatcherType {
  /** PHRASE_MATCHER_TYPE_UNSPECIFIED - Unspecified. */
  PHRASE_MATCHER_TYPE_UNSPECIFIED = 0,
  /** ALL_OF - Must meet all phrase match rule groups or there is no match. */
  ALL_OF = 1,
  /** ANY_OF - If any of the phrase match rule groups are met, there is a match. */
  ANY_OF = 2,
  UNRECOGNIZED = -1,
}

export function phraseMatcher_PhraseMatcherTypeFromJSON(object: any): PhraseMatcher_PhraseMatcherType {
  switch (object) {
    case 0:
    case "PHRASE_MATCHER_TYPE_UNSPECIFIED":
      return PhraseMatcher_PhraseMatcherType.PHRASE_MATCHER_TYPE_UNSPECIFIED;
    case 1:
    case "ALL_OF":
      return PhraseMatcher_PhraseMatcherType.ALL_OF;
    case 2:
    case "ANY_OF":
      return PhraseMatcher_PhraseMatcherType.ANY_OF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PhraseMatcher_PhraseMatcherType.UNRECOGNIZED;
  }
}

export function phraseMatcher_PhraseMatcherTypeToJSON(object: PhraseMatcher_PhraseMatcherType): string {
  switch (object) {
    case PhraseMatcher_PhraseMatcherType.PHRASE_MATCHER_TYPE_UNSPECIFIED:
      return "PHRASE_MATCHER_TYPE_UNSPECIFIED";
    case PhraseMatcher_PhraseMatcherType.ALL_OF:
      return "ALL_OF";
    case PhraseMatcher_PhraseMatcherType.ANY_OF:
      return "ANY_OF";
    case PhraseMatcher_PhraseMatcherType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A message representing a rule in the phrase matcher. */
export interface PhraseMatchRuleGroup {
  /** Required. The type of this phrase match rule group. */
  type: PhraseMatchRuleGroup_PhraseMatchRuleGroupType;
  /** A list of phrase match rules that are included in this group. */
  phraseMatchRules: PhraseMatchRule[];
}

/**
 * Specifies how to combine each phrase match rule for whether there is a
 * match.
 */
export enum PhraseMatchRuleGroup_PhraseMatchRuleGroupType {
  /** PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED - Unspecified. */
  PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED = 0,
  /** ALL_OF - Must meet all phrase match rules or there is no match. */
  ALL_OF = 1,
  /** ANY_OF - If any of the phrase match rules are met, there is a match. */
  ANY_OF = 2,
  UNRECOGNIZED = -1,
}

export function phraseMatchRuleGroup_PhraseMatchRuleGroupTypeFromJSON(
  object: any,
): PhraseMatchRuleGroup_PhraseMatchRuleGroupType {
  switch (object) {
    case 0:
    case "PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED":
      return PhraseMatchRuleGroup_PhraseMatchRuleGroupType.PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED;
    case 1:
    case "ALL_OF":
      return PhraseMatchRuleGroup_PhraseMatchRuleGroupType.ALL_OF;
    case 2:
    case "ANY_OF":
      return PhraseMatchRuleGroup_PhraseMatchRuleGroupType.ANY_OF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PhraseMatchRuleGroup_PhraseMatchRuleGroupType.UNRECOGNIZED;
  }
}

export function phraseMatchRuleGroup_PhraseMatchRuleGroupTypeToJSON(
  object: PhraseMatchRuleGroup_PhraseMatchRuleGroupType,
): string {
  switch (object) {
    case PhraseMatchRuleGroup_PhraseMatchRuleGroupType.PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED:
      return "PHRASE_MATCH_RULE_GROUP_TYPE_UNSPECIFIED";
    case PhraseMatchRuleGroup_PhraseMatchRuleGroupType.ALL_OF:
      return "ALL_OF";
    case PhraseMatchRuleGroup_PhraseMatchRuleGroupType.ANY_OF:
      return "ANY_OF";
    case PhraseMatchRuleGroup_PhraseMatchRuleGroupType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The data for a phrase match rule. */
export interface PhraseMatchRule {
  /** Required. The phrase to be matched. */
  query: string;
  /**
   * Specifies whether the phrase must be missing from the transcript segment or
   * present in the transcript segment.
   */
  negated: boolean;
  /**
   * Provides additional information about the rule that specifies how to apply
   * the rule.
   */
  config: PhraseMatchRuleConfig | undefined;
}

/** Configuration information of a phrase match rule. */
export interface PhraseMatchRuleConfig {
  /** The configuration for the exact match rule. */
  exactMatchConfig?: ExactMatchConfig | undefined;
}

/** Exact match configuration. */
export interface ExactMatchConfig {
  /** Whether to consider case sensitivity when performing an exact match. */
  caseSensitive: boolean;
}

/** The settings resource. */
export interface Settings {
  /**
   * Immutable. The resource name of the settings resource.
   * Format:
   * projects/{project}/locations/{location}/settings
   */
  name: string;
  /** Output only. The time at which the settings was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which the settings were last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * A language code to be applied to each transcript segment unless the segment
   * already specifies a language code. Language code defaults to "en-US" if it
   * is neither specified on the segment nor here.
   */
  languageCode: string;
  /**
   * The default TTL for newly-created conversations. If a conversation has a
   * specified expiration, that value will be used instead. Changing this
   * value will not change the expiration of existing conversations.
   * Conversations with no expire time persist until they are deleted.
   */
  conversationTtl:
    | Duration
    | undefined;
  /**
   * A map that maps a notification trigger to a Pub/Sub topic. Each time a
   * specified trigger occurs, Insights will notify the corresponding Pub/Sub
   * topic.
   *
   * Keys are notification triggers. Supported keys are:
   *
   * * "all-triggers": Notify each time any of the supported triggers occurs.
   * * "create-analysis": Notify each time an analysis is created.
   * * "create-conversation": Notify each time a conversation is created.
   * * "export-insights-data": Notify each time an export is complete.
   * * "update-conversation": Notify each time a conversation is updated via
   * UpdateConversation.
   *
   * Values are Pub/Sub topics. The format of each Pub/Sub topic is:
   * projects/{project}/topics/{topic}
   */
  pubsubNotificationSettings: { [key: string]: string };
  /** Default analysis settings. */
  analysisConfig:
    | Settings_AnalysisConfig
    | undefined;
  /**
   * Default DLP redaction resources to be applied while ingesting
   * conversations.
   */
  redactionConfig:
    | RedactionConfig
    | undefined;
  /**
   * Optional. Default Speech-to-Text resources to be used while ingesting audio
   * files. Optional, CCAI Insights will create a default if not provided.
   */
  speechConfig: SpeechConfig | undefined;
}

/** Default configuration when creating Analyses in Insights. */
export interface Settings_AnalysisConfig {
  /**
   * Percentage of conversations created using Dialogflow runtime integration
   * to analyze automatically, between [0, 100].
   */
  runtimeIntegrationAnalysisPercentage: number;
  /**
   * Percentage of conversations created using the UploadConversation endpoint
   * to analyze automatically, between [0, 100].
   */
  uploadConversationAnalysisPercentage: number;
  /**
   * To select the annotators to run and the phrase matchers to use
   * (if any). If not specified, all annotators will be run.
   */
  annotatorSelector: AnnotatorSelector | undefined;
}

export interface Settings_PubsubNotificationSettingsEntry {
  key: string;
  value: string;
}

/** DLP resources used for redaction while ingesting conversations. */
export interface RedactionConfig {
  /**
   * The fully-qualified DLP deidentify template resource name.
   * Format:
   * `projects/{project}/deidentifyTemplates/{template}`
   */
  deidentifyTemplate: string;
  /**
   * The fully-qualified DLP inspect template resource name.
   * Format:
   * `projects/{project}/locations/{location}/inspectTemplates/{template}`
   */
  inspectTemplate: string;
}

/** Speech-to-Text configuration. */
export interface SpeechConfig {
  /**
   * The fully-qualified Speech Recognizer resource name.
   * Format:
   * `projects/{project_id}/locations/{location}/recognizer/{recognizer}`
   */
  speechRecognizer: string;
}

/** An annotation that was generated during the customer and agent interaction. */
export interface RuntimeAnnotation {
  /** Agent Assist Article Suggestion data. */
  articleSuggestion?:
    | ArticleSuggestionData
    | undefined;
  /** Agent Assist FAQ answer data. */
  faqAnswer?:
    | FaqAnswerData
    | undefined;
  /** Agent Assist Smart Reply data. */
  smartReply?:
    | SmartReplyData
    | undefined;
  /** Agent Assist Smart Compose suggestion data. */
  smartComposeSuggestion?:
    | SmartComposeSuggestionData
    | undefined;
  /** Dialogflow interaction data. */
  dialogflowInteraction?:
    | DialogflowInteractionData
    | undefined;
  /** Conversation summarization suggestion data. */
  conversationSummarizationSuggestion?:
    | ConversationSummarizationSuggestionData
    | undefined;
  /**
   * The unique identifier of the annotation.
   * Format:
   * projects/{project}/locations/{location}/conversationDatasets/{dataset}/conversationDataItems/{data_item}/conversationAnnotations/{annotation}
   */
  annotationId: string;
  /** The time at which this annotation was created. */
  createTime:
    | Date
    | undefined;
  /** The boundary in the conversation where the annotation starts, inclusive. */
  startBoundary:
    | AnnotationBoundary
    | undefined;
  /** The boundary in the conversation where the annotation ends, inclusive. */
  endBoundary:
    | AnnotationBoundary
    | undefined;
  /** The feedback that the customer has about the answer in `data`. */
  answerFeedback: AnswerFeedback | undefined;
}

/**
 * The feedback that the customer has about a certain answer in the
 * conversation.
 */
export interface AnswerFeedback {
  /** The correctness level of an answer. */
  correctnessLevel: AnswerFeedback_CorrectnessLevel;
  /** Indicates whether an answer or item was clicked by the human agent. */
  clicked: boolean;
  /**
   * Indicates whether an answer or item was displayed to the human agent in the
   * agent desktop UI.
   */
  displayed: boolean;
}

/** The correctness level of an answer. */
export enum AnswerFeedback_CorrectnessLevel {
  /** CORRECTNESS_LEVEL_UNSPECIFIED - Correctness level unspecified. */
  CORRECTNESS_LEVEL_UNSPECIFIED = 0,
  /** NOT_CORRECT - Answer is totally wrong. */
  NOT_CORRECT = 1,
  /** PARTIALLY_CORRECT - Answer is partially correct. */
  PARTIALLY_CORRECT = 2,
  /** FULLY_CORRECT - Answer is fully correct. */
  FULLY_CORRECT = 3,
  UNRECOGNIZED = -1,
}

export function answerFeedback_CorrectnessLevelFromJSON(object: any): AnswerFeedback_CorrectnessLevel {
  switch (object) {
    case 0:
    case "CORRECTNESS_LEVEL_UNSPECIFIED":
      return AnswerFeedback_CorrectnessLevel.CORRECTNESS_LEVEL_UNSPECIFIED;
    case 1:
    case "NOT_CORRECT":
      return AnswerFeedback_CorrectnessLevel.NOT_CORRECT;
    case 2:
    case "PARTIALLY_CORRECT":
      return AnswerFeedback_CorrectnessLevel.PARTIALLY_CORRECT;
    case 3:
    case "FULLY_CORRECT":
      return AnswerFeedback_CorrectnessLevel.FULLY_CORRECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnswerFeedback_CorrectnessLevel.UNRECOGNIZED;
  }
}

export function answerFeedback_CorrectnessLevelToJSON(object: AnswerFeedback_CorrectnessLevel): string {
  switch (object) {
    case AnswerFeedback_CorrectnessLevel.CORRECTNESS_LEVEL_UNSPECIFIED:
      return "CORRECTNESS_LEVEL_UNSPECIFIED";
    case AnswerFeedback_CorrectnessLevel.NOT_CORRECT:
      return "NOT_CORRECT";
    case AnswerFeedback_CorrectnessLevel.PARTIALLY_CORRECT:
      return "PARTIALLY_CORRECT";
    case AnswerFeedback_CorrectnessLevel.FULLY_CORRECT:
      return "FULLY_CORRECT";
    case AnswerFeedback_CorrectnessLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Agent Assist Article Suggestion data. */
export interface ArticleSuggestionData {
  /** Article title. */
  title: string;
  /** Article URI. */
  uri: string;
  /**
   * The system's confidence score that this article is a good match for this
   * conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
   * certain).
   */
  confidenceScore: number;
  /**
   * Map that contains metadata about the Article Suggestion and the document
   * that it originates from.
   */
  metadata: { [key: string]: string };
  /**
   * The name of the answer record.
   * Format:
   * projects/{project}/locations/{location}/answerRecords/{answer_record}
   */
  queryRecord: string;
  /**
   * The knowledge document that this answer was extracted from.
   * Format:
   * projects/{project}/knowledgeBases/{knowledge_base}/documents/{document}
   */
  source: string;
}

export interface ArticleSuggestionData_MetadataEntry {
  key: string;
  value: string;
}

/** Agent Assist frequently-asked-question answer data. */
export interface FaqAnswerData {
  /** The piece of text from the `source` knowledge base document. */
  answer: string;
  /**
   * The system's confidence score that this answer is a good match for this
   * conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
   * certain).
   */
  confidenceScore: number;
  /** The corresponding FAQ question. */
  question: string;
  /**
   * Map that contains metadata about the FAQ answer and the document that
   * it originates from.
   */
  metadata: { [key: string]: string };
  /**
   * The name of the answer record.
   * Format:
   * projects/{project}/locations/{location}/answerRecords/{answer_record}
   */
  queryRecord: string;
  /**
   * The knowledge document that this answer was extracted from.
   * Format:
   * projects/{project}/knowledgeBases/{knowledge_base}/documents/{document}.
   */
  source: string;
}

export interface FaqAnswerData_MetadataEntry {
  key: string;
  value: string;
}

/** Agent Assist Smart Reply data. */
export interface SmartReplyData {
  /** The content of the reply. */
  reply: string;
  /**
   * The system's confidence score that this reply is a good match for this
   * conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
   * certain).
   */
  confidenceScore: number;
  /**
   * Map that contains metadata about the Smart Reply and the document from
   * which it originates.
   */
  metadata: { [key: string]: string };
  /**
   * The name of the answer record.
   * Format:
   * projects/{project}/locations/{location}/answerRecords/{answer_record}
   */
  queryRecord: string;
}

export interface SmartReplyData_MetadataEntry {
  key: string;
  value: string;
}

/** Agent Assist Smart Compose suggestion data. */
export interface SmartComposeSuggestionData {
  /** The content of the suggestion. */
  suggestion: string;
  /**
   * The system's confidence score that this suggestion is a good match for this
   * conversation, ranging from 0.0 (completely uncertain) to 1.0 (completely
   * certain).
   */
  confidenceScore: number;
  /**
   * Map that contains metadata about the Smart Compose suggestion and the
   * document from which it originates.
   */
  metadata: { [key: string]: string };
  /**
   * The name of the answer record.
   * Format:
   * projects/{project}/locations/{location}/answerRecords/{answer_record}
   */
  queryRecord: string;
}

export interface SmartComposeSuggestionData_MetadataEntry {
  key: string;
  value: string;
}

/** Dialogflow interaction data. */
export interface DialogflowInteractionData {
  /**
   * The Dialogflow intent resource path. Format:
   * projects/{project}/agent/{agent}/intents/{intent}
   */
  dialogflowIntentId: string;
  /**
   * The confidence of the match ranging from 0.0 (completely uncertain) to 1.0
   * (completely certain).
   */
  confidence: number;
}

/** Conversation summarization suggestion data. */
export interface ConversationSummarizationSuggestionData {
  /** The summarization content that is concatenated into one string. */
  text: string;
  /**
   * The summarization content that is divided into sections. The key is the
   * section's name and the value is the section's content. There is no
   * specific format for the key or value.
   */
  textSections: { [key: string]: string };
  /** The confidence score of the summarization. */
  confidence: number;
  /**
   * A map that contains metadata about the summarization and the document
   * from which it originates.
   */
  metadata: { [key: string]: string };
  /**
   * The name of the answer record.
   * Format:
   * projects/{project}/locations/{location}/answerRecords/{answer_record}
   */
  answerRecord: string;
  /**
   * The name of the model that generates this summary.
   * Format:
   * projects/{project}/locations/{location}/conversationModels/{conversation_model}
   */
  conversationModel: string;
}

export interface ConversationSummarizationSuggestionData_TextSectionsEntry {
  key: string;
  value: string;
}

export interface ConversationSummarizationSuggestionData_MetadataEntry {
  key: string;
  value: string;
}

/** The call participant speaking for a given utterance. */
export interface ConversationParticipant {
  /**
   * The name of the participant provided by Dialogflow. Format:
   * projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant}
   */
  dialogflowParticipantName?:
    | string
    | undefined;
  /** A user-specified ID representing the participant. */
  userId?:
    | string
    | undefined;
  /**
   * Deprecated. Use `dialogflow_participant_name` instead.
   * The name of the Dialogflow participant. Format:
   * projects/{project}/locations/{location}/conversations/{conversation}/participants/{participant}
   *
   * @deprecated
   */
  dialogflowParticipant: string;
  /** Obfuscated user ID from Dialogflow. */
  obfuscatedExternalUserId: string;
  /** The role of the participant. */
  role: ConversationParticipant_Role;
}

/** The role of the participant. */
export enum ConversationParticipant_Role {
  /** ROLE_UNSPECIFIED - Participant's role is not set. */
  ROLE_UNSPECIFIED = 0,
  /** HUMAN_AGENT - Participant is a human agent. */
  HUMAN_AGENT = 1,
  /** AUTOMATED_AGENT - Participant is an automated agent. */
  AUTOMATED_AGENT = 2,
  /** END_USER - Participant is an end user who conversed with the contact center. */
  END_USER = 3,
  /** ANY_AGENT - Participant is either a human or automated agent. */
  ANY_AGENT = 4,
  UNRECOGNIZED = -1,
}

export function conversationParticipant_RoleFromJSON(object: any): ConversationParticipant_Role {
  switch (object) {
    case 0:
    case "ROLE_UNSPECIFIED":
      return ConversationParticipant_Role.ROLE_UNSPECIFIED;
    case 1:
    case "HUMAN_AGENT":
      return ConversationParticipant_Role.HUMAN_AGENT;
    case 2:
    case "AUTOMATED_AGENT":
      return ConversationParticipant_Role.AUTOMATED_AGENT;
    case 3:
    case "END_USER":
      return ConversationParticipant_Role.END_USER;
    case 4:
    case "ANY_AGENT":
      return ConversationParticipant_Role.ANY_AGENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConversationParticipant_Role.UNRECOGNIZED;
  }
}

export function conversationParticipant_RoleToJSON(object: ConversationParticipant_Role): string {
  switch (object) {
    case ConversationParticipant_Role.ROLE_UNSPECIFIED:
      return "ROLE_UNSPECIFIED";
    case ConversationParticipant_Role.HUMAN_AGENT:
      return "HUMAN_AGENT";
    case ConversationParticipant_Role.AUTOMATED_AGENT:
      return "AUTOMATED_AGENT";
    case ConversationParticipant_Role.END_USER:
      return "END_USER";
    case ConversationParticipant_Role.ANY_AGENT:
      return "ANY_AGENT";
    case ConversationParticipant_Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The View resource. */
export interface View {
  /**
   * Immutable. The resource name of the view.
   * Format:
   * projects/{project}/locations/{location}/views/{view}
   */
  name: string;
  /** The human-readable display name of the view. */
  displayName: string;
  /** Output only. The time at which this view was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The most recent time at which the view was updated. */
  updateTime:
    | Date
    | undefined;
  /** String with specific view properties, must be non-empty. */
  value: string;
}

/** Selector of all available annotators and phrase matchers to run. */
export interface AnnotatorSelector {
  /** Whether to run the interruption annotator. */
  runInterruptionAnnotator: boolean;
  /** Whether to run the silence annotator. */
  runSilenceAnnotator: boolean;
  /** Whether to run the active phrase matcher annotator(s). */
  runPhraseMatcherAnnotator: boolean;
  /**
   * The list of phrase matchers to run. If not provided, all active phrase
   * matchers will be used. If inactive phrase matchers are provided, they will
   * not be used. Phrase matchers will be run only if
   * run_phrase_matcher_annotator is set to true. Format:
   * projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher}
   */
  phraseMatchers: string[];
  /** Whether to run the sentiment annotator. */
  runSentimentAnnotator: boolean;
  /** Whether to run the entity annotator. */
  runEntityAnnotator: boolean;
  /** Whether to run the intent annotator. */
  runIntentAnnotator: boolean;
  /**
   * Whether to run the issue model annotator. A model should have already been
   * deployed for this to take effect.
   */
  runIssueModelAnnotator: boolean;
  /**
   * The issue model to run. If not provided, the most recently deployed topic
   * model will be used. The provided issue model will only be used for
   * inference if the issue model is deployed and if run_issue_model_annotator
   * is set to true. If more than one issue model is provided, only the first
   * provided issue model will be used for inference.
   */
  issueModels: string[];
  /** Whether to run the summarization annotator. */
  runSummarizationAnnotator: boolean;
  /** Configuration for the summarization annotator. */
  summarizationConfig: AnnotatorSelector_SummarizationConfig | undefined;
}

/** Configuration for summarization. */
export interface AnnotatorSelector_SummarizationConfig {
  /**
   * Resource name of the Dialogflow conversation profile.
   * Format:
   * projects/{project}/locations/{location}/conversationProfiles/{conversation_profile}
   */
  conversationProfile?:
    | string
    | undefined;
  /** Default summarization model to be used. */
  summarizationModel?: AnnotatorSelector_SummarizationConfig_SummarizationModel | undefined;
}

/** Summarization model to use, if `conversation_profile` is not used. */
export enum AnnotatorSelector_SummarizationConfig_SummarizationModel {
  /** SUMMARIZATION_MODEL_UNSPECIFIED - Unspecified summarization model. */
  SUMMARIZATION_MODEL_UNSPECIFIED = 0,
  /** BASELINE_MODEL - The CCAI baseline model. */
  BASELINE_MODEL = 1,
  UNRECOGNIZED = -1,
}

export function annotatorSelector_SummarizationConfig_SummarizationModelFromJSON(
  object: any,
): AnnotatorSelector_SummarizationConfig_SummarizationModel {
  switch (object) {
    case 0:
    case "SUMMARIZATION_MODEL_UNSPECIFIED":
      return AnnotatorSelector_SummarizationConfig_SummarizationModel.SUMMARIZATION_MODEL_UNSPECIFIED;
    case 1:
    case "BASELINE_MODEL":
      return AnnotatorSelector_SummarizationConfig_SummarizationModel.BASELINE_MODEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnnotatorSelector_SummarizationConfig_SummarizationModel.UNRECOGNIZED;
  }
}

export function annotatorSelector_SummarizationConfig_SummarizationModelToJSON(
  object: AnnotatorSelector_SummarizationConfig_SummarizationModel,
): string {
  switch (object) {
    case AnnotatorSelector_SummarizationConfig_SummarizationModel.SUMMARIZATION_MODEL_UNSPECIFIED:
      return "SUMMARIZATION_MODEL_UNSPECIFIED";
    case AnnotatorSelector_SummarizationConfig_SummarizationModel.BASELINE_MODEL:
      return "BASELINE_MODEL";
    case AnnotatorSelector_SummarizationConfig_SummarizationModel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseConversation(): Conversation {
  return {
    callMetadata: undefined,
    expireTime: undefined,
    ttl: undefined,
    name: "",
    dataSource: undefined,
    createTime: undefined,
    updateTime: undefined,
    startTime: undefined,
    languageCode: "",
    agentId: "",
    labels: {},
    qualityMetadata: undefined,
    transcript: undefined,
    medium: 0,
    duration: undefined,
    turnCount: 0,
    latestAnalysis: undefined,
    latestSummary: undefined,
    runtimeAnnotations: [],
    dialogflowIntents: {},
    obfuscatedUserId: "",
  };
}

export const Conversation: MessageFns<Conversation> = {
  encode(message: Conversation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callMetadata !== undefined) {
      Conversation_CallMetadata.encode(message.callMetadata, writer.uint32(58).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(122).fork()).join();
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(130).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dataSource !== undefined) {
      ConversationDataSource.encode(message.dataSource, writer.uint32(18).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(138).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(114).string(message.languageCode);
    }
    if (message.agentId !== "") {
      writer.uint32(42).string(message.agentId);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Conversation_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.qualityMetadata !== undefined) {
      Conversation_QualityMetadata.encode(message.qualityMetadata, writer.uint32(194).fork()).join();
    }
    if (message.transcript !== undefined) {
      Conversation_Transcript.encode(message.transcript, writer.uint32(66).fork()).join();
    }
    if (message.medium !== 0) {
      writer.uint32(72).int32(message.medium);
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(82).fork()).join();
    }
    if (message.turnCount !== 0) {
      writer.uint32(88).int32(message.turnCount);
    }
    if (message.latestAnalysis !== undefined) {
      Analysis.encode(message.latestAnalysis, writer.uint32(98).fork()).join();
    }
    if (message.latestSummary !== undefined) {
      ConversationSummarizationSuggestionData.encode(message.latestSummary, writer.uint32(162).fork()).join();
    }
    for (const v of message.runtimeAnnotations) {
      RuntimeAnnotation.encode(v!, writer.uint32(106).fork()).join();
    }
    Object.entries(message.dialogflowIntents).forEach(([key, value]) => {
      Conversation_DialogflowIntentsEntry.encode({ key: key as any, value }, writer.uint32(146).fork()).join();
    });
    if (message.obfuscatedUserId !== "") {
      writer.uint32(170).string(message.obfuscatedUserId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.callMetadata = Conversation_CallMetadata.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataSource = ConversationDataSource.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = Conversation_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.qualityMetadata = Conversation_QualityMetadata.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.transcript = Conversation_Transcript.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.medium = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.turnCount = reader.int32();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.latestAnalysis = Analysis.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.latestSummary = ConversationSummarizationSuggestionData.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.runtimeAnnotations.push(RuntimeAnnotation.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          const entry18 = Conversation_DialogflowIntentsEntry.decode(reader, reader.uint32());
          if (entry18.value !== undefined) {
            message.dialogflowIntents[entry18.key] = entry18.value;
          }
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.obfuscatedUserId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation {
    return {
      callMetadata: isSet(object.callMetadata) ? Conversation_CallMetadata.fromJSON(object.callMetadata) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataSource: isSet(object.dataSource) ? ConversationDataSource.fromJSON(object.dataSource) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      qualityMetadata: isSet(object.qualityMetadata)
        ? Conversation_QualityMetadata.fromJSON(object.qualityMetadata)
        : undefined,
      transcript: isSet(object.transcript) ? Conversation_Transcript.fromJSON(object.transcript) : undefined,
      medium: isSet(object.medium) ? conversation_MediumFromJSON(object.medium) : 0,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      turnCount: isSet(object.turnCount) ? globalThis.Number(object.turnCount) : 0,
      latestAnalysis: isSet(object.latestAnalysis) ? Analysis.fromJSON(object.latestAnalysis) : undefined,
      latestSummary: isSet(object.latestSummary)
        ? ConversationSummarizationSuggestionData.fromJSON(object.latestSummary)
        : undefined,
      runtimeAnnotations: globalThis.Array.isArray(object?.runtimeAnnotations)
        ? object.runtimeAnnotations.map((e: any) => RuntimeAnnotation.fromJSON(e))
        : [],
      dialogflowIntents: isObject(object.dialogflowIntents)
        ? Object.entries(object.dialogflowIntents).reduce<{ [key: string]: DialogflowIntent }>((acc, [key, value]) => {
          acc[key] = DialogflowIntent.fromJSON(value);
          return acc;
        }, {})
        : {},
      obfuscatedUserId: isSet(object.obfuscatedUserId) ? globalThis.String(object.obfuscatedUserId) : "",
    };
  },

  toJSON(message: Conversation): unknown {
    const obj: any = {};
    if (message.callMetadata !== undefined) {
      obj.callMetadata = Conversation_CallMetadata.toJSON(message.callMetadata);
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataSource !== undefined) {
      obj.dataSource = ConversationDataSource.toJSON(message.dataSource);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.qualityMetadata !== undefined) {
      obj.qualityMetadata = Conversation_QualityMetadata.toJSON(message.qualityMetadata);
    }
    if (message.transcript !== undefined) {
      obj.transcript = Conversation_Transcript.toJSON(message.transcript);
    }
    if (message.medium !== 0) {
      obj.medium = conversation_MediumToJSON(message.medium);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.turnCount !== 0) {
      obj.turnCount = Math.round(message.turnCount);
    }
    if (message.latestAnalysis !== undefined) {
      obj.latestAnalysis = Analysis.toJSON(message.latestAnalysis);
    }
    if (message.latestSummary !== undefined) {
      obj.latestSummary = ConversationSummarizationSuggestionData.toJSON(message.latestSummary);
    }
    if (message.runtimeAnnotations?.length) {
      obj.runtimeAnnotations = message.runtimeAnnotations.map((e) => RuntimeAnnotation.toJSON(e));
    }
    if (message.dialogflowIntents) {
      const entries = Object.entries(message.dialogflowIntents);
      if (entries.length > 0) {
        obj.dialogflowIntents = {};
        entries.forEach(([k, v]) => {
          obj.dialogflowIntents[k] = DialogflowIntent.toJSON(v);
        });
      }
    }
    if (message.obfuscatedUserId !== "") {
      obj.obfuscatedUserId = message.obfuscatedUserId;
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation>): Conversation {
    return Conversation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation>): Conversation {
    const message = createBaseConversation();
    message.callMetadata = (object.callMetadata !== undefined && object.callMetadata !== null)
      ? Conversation_CallMetadata.fromPartial(object.callMetadata)
      : undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    message.name = object.name ?? "";
    message.dataSource = (object.dataSource !== undefined && object.dataSource !== null)
      ? ConversationDataSource.fromPartial(object.dataSource)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.startTime = object.startTime ?? undefined;
    message.languageCode = object.languageCode ?? "";
    message.agentId = object.agentId ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.qualityMetadata = (object.qualityMetadata !== undefined && object.qualityMetadata !== null)
      ? Conversation_QualityMetadata.fromPartial(object.qualityMetadata)
      : undefined;
    message.transcript = (object.transcript !== undefined && object.transcript !== null)
      ? Conversation_Transcript.fromPartial(object.transcript)
      : undefined;
    message.medium = object.medium ?? 0;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.turnCount = object.turnCount ?? 0;
    message.latestAnalysis = (object.latestAnalysis !== undefined && object.latestAnalysis !== null)
      ? Analysis.fromPartial(object.latestAnalysis)
      : undefined;
    message.latestSummary = (object.latestSummary !== undefined && object.latestSummary !== null)
      ? ConversationSummarizationSuggestionData.fromPartial(object.latestSummary)
      : undefined;
    message.runtimeAnnotations = object.runtimeAnnotations?.map((e) => RuntimeAnnotation.fromPartial(e)) || [];
    message.dialogflowIntents = Object.entries(object.dialogflowIntents ?? {}).reduce<
      { [key: string]: DialogflowIntent }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = DialogflowIntent.fromPartial(value);
      }
      return acc;
    }, {});
    message.obfuscatedUserId = object.obfuscatedUserId ?? "";
    return message;
  },
};

function createBaseConversation_CallMetadata(): Conversation_CallMetadata {
  return { customerChannel: 0, agentChannel: 0 };
}

export const Conversation_CallMetadata: MessageFns<Conversation_CallMetadata> = {
  encode(message: Conversation_CallMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerChannel !== 0) {
      writer.uint32(8).int32(message.customerChannel);
    }
    if (message.agentChannel !== 0) {
      writer.uint32(16).int32(message.agentChannel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_CallMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_CallMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.customerChannel = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.agentChannel = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_CallMetadata {
    return {
      customerChannel: isSet(object.customerChannel) ? globalThis.Number(object.customerChannel) : 0,
      agentChannel: isSet(object.agentChannel) ? globalThis.Number(object.agentChannel) : 0,
    };
  },

  toJSON(message: Conversation_CallMetadata): unknown {
    const obj: any = {};
    if (message.customerChannel !== 0) {
      obj.customerChannel = Math.round(message.customerChannel);
    }
    if (message.agentChannel !== 0) {
      obj.agentChannel = Math.round(message.agentChannel);
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_CallMetadata>): Conversation_CallMetadata {
    return Conversation_CallMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation_CallMetadata>): Conversation_CallMetadata {
    const message = createBaseConversation_CallMetadata();
    message.customerChannel = object.customerChannel ?? 0;
    message.agentChannel = object.agentChannel ?? 0;
    return message;
  },
};

function createBaseConversation_QualityMetadata(): Conversation_QualityMetadata {
  return { customerSatisfactionRating: 0, waitDuration: undefined, menuPath: "", agentInfo: [] };
}

export const Conversation_QualityMetadata: MessageFns<Conversation_QualityMetadata> = {
  encode(message: Conversation_QualityMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerSatisfactionRating !== 0) {
      writer.uint32(8).int32(message.customerSatisfactionRating);
    }
    if (message.waitDuration !== undefined) {
      Duration.encode(message.waitDuration, writer.uint32(18).fork()).join();
    }
    if (message.menuPath !== "") {
      writer.uint32(26).string(message.menuPath);
    }
    for (const v of message.agentInfo) {
      Conversation_QualityMetadata_AgentInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_QualityMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_QualityMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.customerSatisfactionRating = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.waitDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.menuPath = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.agentInfo.push(Conversation_QualityMetadata_AgentInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_QualityMetadata {
    return {
      customerSatisfactionRating: isSet(object.customerSatisfactionRating)
        ? globalThis.Number(object.customerSatisfactionRating)
        : 0,
      waitDuration: isSet(object.waitDuration) ? Duration.fromJSON(object.waitDuration) : undefined,
      menuPath: isSet(object.menuPath) ? globalThis.String(object.menuPath) : "",
      agentInfo: globalThis.Array.isArray(object?.agentInfo)
        ? object.agentInfo.map((e: any) => Conversation_QualityMetadata_AgentInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Conversation_QualityMetadata): unknown {
    const obj: any = {};
    if (message.customerSatisfactionRating !== 0) {
      obj.customerSatisfactionRating = Math.round(message.customerSatisfactionRating);
    }
    if (message.waitDuration !== undefined) {
      obj.waitDuration = Duration.toJSON(message.waitDuration);
    }
    if (message.menuPath !== "") {
      obj.menuPath = message.menuPath;
    }
    if (message.agentInfo?.length) {
      obj.agentInfo = message.agentInfo.map((e) => Conversation_QualityMetadata_AgentInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_QualityMetadata>): Conversation_QualityMetadata {
    return Conversation_QualityMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation_QualityMetadata>): Conversation_QualityMetadata {
    const message = createBaseConversation_QualityMetadata();
    message.customerSatisfactionRating = object.customerSatisfactionRating ?? 0;
    message.waitDuration = (object.waitDuration !== undefined && object.waitDuration !== null)
      ? Duration.fromPartial(object.waitDuration)
      : undefined;
    message.menuPath = object.menuPath ?? "";
    message.agentInfo = object.agentInfo?.map((e) => Conversation_QualityMetadata_AgentInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConversation_QualityMetadata_AgentInfo(): Conversation_QualityMetadata_AgentInfo {
  return { agentId: "", displayName: "", team: "", dispositionCode: "" };
}

export const Conversation_QualityMetadata_AgentInfo: MessageFns<Conversation_QualityMetadata_AgentInfo> = {
  encode(message: Conversation_QualityMetadata_AgentInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agentId !== "") {
      writer.uint32(10).string(message.agentId);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.team !== "") {
      writer.uint32(26).string(message.team);
    }
    if (message.dispositionCode !== "") {
      writer.uint32(34).string(message.dispositionCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_QualityMetadata_AgentInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_QualityMetadata_AgentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.agentId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.team = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.dispositionCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_QualityMetadata_AgentInfo {
    return {
      agentId: isSet(object.agentId) ? globalThis.String(object.agentId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      team: isSet(object.team) ? globalThis.String(object.team) : "",
      dispositionCode: isSet(object.dispositionCode) ? globalThis.String(object.dispositionCode) : "",
    };
  },

  toJSON(message: Conversation_QualityMetadata_AgentInfo): unknown {
    const obj: any = {};
    if (message.agentId !== "") {
      obj.agentId = message.agentId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.team !== "") {
      obj.team = message.team;
    }
    if (message.dispositionCode !== "") {
      obj.dispositionCode = message.dispositionCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_QualityMetadata_AgentInfo>): Conversation_QualityMetadata_AgentInfo {
    return Conversation_QualityMetadata_AgentInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation_QualityMetadata_AgentInfo>): Conversation_QualityMetadata_AgentInfo {
    const message = createBaseConversation_QualityMetadata_AgentInfo();
    message.agentId = object.agentId ?? "";
    message.displayName = object.displayName ?? "";
    message.team = object.team ?? "";
    message.dispositionCode = object.dispositionCode ?? "";
    return message;
  },
};

function createBaseConversation_Transcript(): Conversation_Transcript {
  return { transcriptSegments: [] };
}

export const Conversation_Transcript: MessageFns<Conversation_Transcript> = {
  encode(message: Conversation_Transcript, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.transcriptSegments) {
      Conversation_Transcript_TranscriptSegment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_Transcript {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_Transcript();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transcriptSegments.push(Conversation_Transcript_TranscriptSegment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_Transcript {
    return {
      transcriptSegments: globalThis.Array.isArray(object?.transcriptSegments)
        ? object.transcriptSegments.map((e: any) => Conversation_Transcript_TranscriptSegment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Conversation_Transcript): unknown {
    const obj: any = {};
    if (message.transcriptSegments?.length) {
      obj.transcriptSegments = message.transcriptSegments.map((e) =>
        Conversation_Transcript_TranscriptSegment.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_Transcript>): Conversation_Transcript {
    return Conversation_Transcript.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation_Transcript>): Conversation_Transcript {
    const message = createBaseConversation_Transcript();
    message.transcriptSegments =
      object.transcriptSegments?.map((e) => Conversation_Transcript_TranscriptSegment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConversation_Transcript_TranscriptSegment(): Conversation_Transcript_TranscriptSegment {
  return {
    messageTime: undefined,
    text: "",
    confidence: 0,
    words: [],
    languageCode: "",
    channelTag: 0,
    segmentParticipant: undefined,
    dialogflowSegmentMetadata: undefined,
    sentiment: undefined,
  };
}

export const Conversation_Transcript_TranscriptSegment: MessageFns<Conversation_Transcript_TranscriptSegment> = {
  encode(message: Conversation_Transcript_TranscriptSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageTime !== undefined) {
      Timestamp.encode(toTimestamp(message.messageTime), writer.uint32(50).fork()).join();
    }
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    for (const v of message.words) {
      Conversation_Transcript_TranscriptSegment_WordInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    if (message.channelTag !== 0) {
      writer.uint32(40).int32(message.channelTag);
    }
    if (message.segmentParticipant !== undefined) {
      ConversationParticipant.encode(message.segmentParticipant, writer.uint32(74).fork()).join();
    }
    if (message.dialogflowSegmentMetadata !== undefined) {
      Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata.encode(
        message.dialogflowSegmentMetadata,
        writer.uint32(82).fork(),
      ).join();
    }
    if (message.sentiment !== undefined) {
      SentimentData.encode(message.sentiment, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_Transcript_TranscriptSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_Transcript_TranscriptSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.messageTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.words.push(Conversation_Transcript_TranscriptSegment_WordInfo.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.channelTag = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.segmentParticipant = ConversationParticipant.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dialogflowSegmentMetadata = Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata
            .decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.sentiment = SentimentData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_Transcript_TranscriptSegment {
    return {
      messageTime: isSet(object.messageTime) ? fromJsonTimestamp(object.messageTime) : undefined,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      words: globalThis.Array.isArray(object?.words)
        ? object.words.map((e: any) => Conversation_Transcript_TranscriptSegment_WordInfo.fromJSON(e))
        : [],
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      channelTag: isSet(object.channelTag) ? globalThis.Number(object.channelTag) : 0,
      segmentParticipant: isSet(object.segmentParticipant)
        ? ConversationParticipant.fromJSON(object.segmentParticipant)
        : undefined,
      dialogflowSegmentMetadata: isSet(object.dialogflowSegmentMetadata)
        ? Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata.fromJSON(object.dialogflowSegmentMetadata)
        : undefined,
      sentiment: isSet(object.sentiment) ? SentimentData.fromJSON(object.sentiment) : undefined,
    };
  },

  toJSON(message: Conversation_Transcript_TranscriptSegment): unknown {
    const obj: any = {};
    if (message.messageTime !== undefined) {
      obj.messageTime = message.messageTime.toISOString();
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.words?.length) {
      obj.words = message.words.map((e) => Conversation_Transcript_TranscriptSegment_WordInfo.toJSON(e));
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.channelTag !== 0) {
      obj.channelTag = Math.round(message.channelTag);
    }
    if (message.segmentParticipant !== undefined) {
      obj.segmentParticipant = ConversationParticipant.toJSON(message.segmentParticipant);
    }
    if (message.dialogflowSegmentMetadata !== undefined) {
      obj.dialogflowSegmentMetadata = Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata.toJSON(
        message.dialogflowSegmentMetadata,
      );
    }
    if (message.sentiment !== undefined) {
      obj.sentiment = SentimentData.toJSON(message.sentiment);
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_Transcript_TranscriptSegment>): Conversation_Transcript_TranscriptSegment {
    return Conversation_Transcript_TranscriptSegment.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Conversation_Transcript_TranscriptSegment>,
  ): Conversation_Transcript_TranscriptSegment {
    const message = createBaseConversation_Transcript_TranscriptSegment();
    message.messageTime = object.messageTime ?? undefined;
    message.text = object.text ?? "";
    message.confidence = object.confidence ?? 0;
    message.words = object.words?.map((e) => Conversation_Transcript_TranscriptSegment_WordInfo.fromPartial(e)) || [];
    message.languageCode = object.languageCode ?? "";
    message.channelTag = object.channelTag ?? 0;
    message.segmentParticipant = (object.segmentParticipant !== undefined && object.segmentParticipant !== null)
      ? ConversationParticipant.fromPartial(object.segmentParticipant)
      : undefined;
    message.dialogflowSegmentMetadata =
      (object.dialogflowSegmentMetadata !== undefined && object.dialogflowSegmentMetadata !== null)
        ? Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata.fromPartial(
          object.dialogflowSegmentMetadata,
        )
        : undefined;
    message.sentiment = (object.sentiment !== undefined && object.sentiment !== null)
      ? SentimentData.fromPartial(object.sentiment)
      : undefined;
    return message;
  },
};

function createBaseConversation_Transcript_TranscriptSegment_WordInfo(): Conversation_Transcript_TranscriptSegment_WordInfo {
  return { startOffset: undefined, endOffset: undefined, word: "", confidence: 0 };
}

export const Conversation_Transcript_TranscriptSegment_WordInfo: MessageFns<
  Conversation_Transcript_TranscriptSegment_WordInfo
> = {
  encode(
    message: Conversation_Transcript_TranscriptSegment_WordInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.startOffset !== undefined) {
      Duration.encode(message.startOffset, writer.uint32(10).fork()).join();
    }
    if (message.endOffset !== undefined) {
      Duration.encode(message.endOffset, writer.uint32(18).fork()).join();
    }
    if (message.word !== "") {
      writer.uint32(26).string(message.word);
    }
    if (message.confidence !== 0) {
      writer.uint32(37).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_Transcript_TranscriptSegment_WordInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_Transcript_TranscriptSegment_WordInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startOffset = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endOffset = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.word = reader.string();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_Transcript_TranscriptSegment_WordInfo {
    return {
      startOffset: isSet(object.startOffset) ? Duration.fromJSON(object.startOffset) : undefined,
      endOffset: isSet(object.endOffset) ? Duration.fromJSON(object.endOffset) : undefined,
      word: isSet(object.word) ? globalThis.String(object.word) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: Conversation_Transcript_TranscriptSegment_WordInfo): unknown {
    const obj: any = {};
    if (message.startOffset !== undefined) {
      obj.startOffset = Duration.toJSON(message.startOffset);
    }
    if (message.endOffset !== undefined) {
      obj.endOffset = Duration.toJSON(message.endOffset);
    }
    if (message.word !== "") {
      obj.word = message.word;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Conversation_Transcript_TranscriptSegment_WordInfo>,
  ): Conversation_Transcript_TranscriptSegment_WordInfo {
    return Conversation_Transcript_TranscriptSegment_WordInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Conversation_Transcript_TranscriptSegment_WordInfo>,
  ): Conversation_Transcript_TranscriptSegment_WordInfo {
    const message = createBaseConversation_Transcript_TranscriptSegment_WordInfo();
    message.startOffset = (object.startOffset !== undefined && object.startOffset !== null)
      ? Duration.fromPartial(object.startOffset)
      : undefined;
    message.endOffset = (object.endOffset !== undefined && object.endOffset !== null)
      ? Duration.fromPartial(object.endOffset)
      : undefined;
    message.word = object.word ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseConversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata(): Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata {
  return { smartReplyAllowlistCovered: false };
}

export const Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata: MessageFns<
  Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata
> = {
  encode(
    message: Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.smartReplyAllowlistCovered !== false) {
      writer.uint32(8).bool(message.smartReplyAllowlistCovered);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.smartReplyAllowlistCovered = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata {
    return {
      smartReplyAllowlistCovered: isSet(object.smartReplyAllowlistCovered)
        ? globalThis.Boolean(object.smartReplyAllowlistCovered)
        : false,
    };
  },

  toJSON(message: Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata): unknown {
    const obj: any = {};
    if (message.smartReplyAllowlistCovered !== false) {
      obj.smartReplyAllowlistCovered = message.smartReplyAllowlistCovered;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata>,
  ): Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata {
    return Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata>,
  ): Conversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata {
    const message = createBaseConversation_Transcript_TranscriptSegment_DialogflowSegmentMetadata();
    message.smartReplyAllowlistCovered = object.smartReplyAllowlistCovered ?? false;
    return message;
  },
};

function createBaseConversation_LabelsEntry(): Conversation_LabelsEntry {
  return { key: "", value: "" };
}

export const Conversation_LabelsEntry: MessageFns<Conversation_LabelsEntry> = {
  encode(message: Conversation_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Conversation_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_LabelsEntry>): Conversation_LabelsEntry {
    return Conversation_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation_LabelsEntry>): Conversation_LabelsEntry {
    const message = createBaseConversation_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConversation_DialogflowIntentsEntry(): Conversation_DialogflowIntentsEntry {
  return { key: "", value: undefined };
}

export const Conversation_DialogflowIntentsEntry: MessageFns<Conversation_DialogflowIntentsEntry> = {
  encode(message: Conversation_DialogflowIntentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DialogflowIntent.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Conversation_DialogflowIntentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversation_DialogflowIntentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = DialogflowIntent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Conversation_DialogflowIntentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? DialogflowIntent.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Conversation_DialogflowIntentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = DialogflowIntent.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Conversation_DialogflowIntentsEntry>): Conversation_DialogflowIntentsEntry {
    return Conversation_DialogflowIntentsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Conversation_DialogflowIntentsEntry>): Conversation_DialogflowIntentsEntry {
    const message = createBaseConversation_DialogflowIntentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? DialogflowIntent.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAnalysis(): Analysis {
  return {
    name: "",
    requestTime: undefined,
    createTime: undefined,
    analysisResult: undefined,
    annotatorSelector: undefined,
  };
}

export const Analysis: MessageFns<Analysis> = {
  encode(message: Analysis, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestTime !== undefined) {
      Timestamp.encode(toTimestamp(message.requestTime), writer.uint32(18).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.analysisResult !== undefined) {
      AnalysisResult.encode(message.analysisResult, writer.uint32(58).fork()).join();
    }
    if (message.annotatorSelector !== undefined) {
      AnnotatorSelector.encode(message.annotatorSelector, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Analysis {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.analysisResult = AnalysisResult.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.annotatorSelector = AnnotatorSelector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Analysis {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestTime: isSet(object.requestTime) ? fromJsonTimestamp(object.requestTime) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      analysisResult: isSet(object.analysisResult) ? AnalysisResult.fromJSON(object.analysisResult) : undefined,
      annotatorSelector: isSet(object.annotatorSelector)
        ? AnnotatorSelector.fromJSON(object.annotatorSelector)
        : undefined,
    };
  },

  toJSON(message: Analysis): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestTime !== undefined) {
      obj.requestTime = message.requestTime.toISOString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.analysisResult !== undefined) {
      obj.analysisResult = AnalysisResult.toJSON(message.analysisResult);
    }
    if (message.annotatorSelector !== undefined) {
      obj.annotatorSelector = AnnotatorSelector.toJSON(message.annotatorSelector);
    }
    return obj;
  },

  create(base?: DeepPartial<Analysis>): Analysis {
    return Analysis.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Analysis>): Analysis {
    const message = createBaseAnalysis();
    message.name = object.name ?? "";
    message.requestTime = object.requestTime ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.analysisResult = (object.analysisResult !== undefined && object.analysisResult !== null)
      ? AnalysisResult.fromPartial(object.analysisResult)
      : undefined;
    message.annotatorSelector = (object.annotatorSelector !== undefined && object.annotatorSelector !== null)
      ? AnnotatorSelector.fromPartial(object.annotatorSelector)
      : undefined;
    return message;
  },
};

function createBaseConversationDataSource(): ConversationDataSource {
  return { gcsSource: undefined, dialogflowSource: undefined };
}

export const ConversationDataSource: MessageFns<ConversationDataSource> = {
  encode(message: ConversationDataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsSource !== undefined) {
      GcsSource.encode(message.gcsSource, writer.uint32(10).fork()).join();
    }
    if (message.dialogflowSource !== undefined) {
      DialogflowSource.encode(message.dialogflowSource, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationDataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsSource = GcsSource.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dialogflowSource = DialogflowSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationDataSource {
    return {
      gcsSource: isSet(object.gcsSource) ? GcsSource.fromJSON(object.gcsSource) : undefined,
      dialogflowSource: isSet(object.dialogflowSource) ? DialogflowSource.fromJSON(object.dialogflowSource) : undefined,
    };
  },

  toJSON(message: ConversationDataSource): unknown {
    const obj: any = {};
    if (message.gcsSource !== undefined) {
      obj.gcsSource = GcsSource.toJSON(message.gcsSource);
    }
    if (message.dialogflowSource !== undefined) {
      obj.dialogflowSource = DialogflowSource.toJSON(message.dialogflowSource);
    }
    return obj;
  },

  create(base?: DeepPartial<ConversationDataSource>): ConversationDataSource {
    return ConversationDataSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversationDataSource>): ConversationDataSource {
    const message = createBaseConversationDataSource();
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? GcsSource.fromPartial(object.gcsSource)
      : undefined;
    message.dialogflowSource = (object.dialogflowSource !== undefined && object.dialogflowSource !== null)
      ? DialogflowSource.fromPartial(object.dialogflowSource)
      : undefined;
    return message;
  },
};

function createBaseGcsSource(): GcsSource {
  return { audioUri: "", transcriptUri: "" };
}

export const GcsSource: MessageFns<GcsSource> = {
  encode(message: GcsSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.audioUri !== "") {
      writer.uint32(10).string(message.audioUri);
    }
    if (message.transcriptUri !== "") {
      writer.uint32(18).string(message.transcriptUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audioUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.transcriptUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsSource {
    return {
      audioUri: isSet(object.audioUri) ? globalThis.String(object.audioUri) : "",
      transcriptUri: isSet(object.transcriptUri) ? globalThis.String(object.transcriptUri) : "",
    };
  },

  toJSON(message: GcsSource): unknown {
    const obj: any = {};
    if (message.audioUri !== "") {
      obj.audioUri = message.audioUri;
    }
    if (message.transcriptUri !== "") {
      obj.transcriptUri = message.transcriptUri;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsSource>): GcsSource {
    return GcsSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsSource>): GcsSource {
    const message = createBaseGcsSource();
    message.audioUri = object.audioUri ?? "";
    message.transcriptUri = object.transcriptUri ?? "";
    return message;
  },
};

function createBaseDialogflowSource(): DialogflowSource {
  return { dialogflowConversation: "", audioUri: "" };
}

export const DialogflowSource: MessageFns<DialogflowSource> = {
  encode(message: DialogflowSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dialogflowConversation !== "") {
      writer.uint32(10).string(message.dialogflowConversation);
    }
    if (message.audioUri !== "") {
      writer.uint32(26).string(message.audioUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogflowSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogflowSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dialogflowConversation = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.audioUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogflowSource {
    return {
      dialogflowConversation: isSet(object.dialogflowConversation)
        ? globalThis.String(object.dialogflowConversation)
        : "",
      audioUri: isSet(object.audioUri) ? globalThis.String(object.audioUri) : "",
    };
  },

  toJSON(message: DialogflowSource): unknown {
    const obj: any = {};
    if (message.dialogflowConversation !== "") {
      obj.dialogflowConversation = message.dialogflowConversation;
    }
    if (message.audioUri !== "") {
      obj.audioUri = message.audioUri;
    }
    return obj;
  },

  create(base?: DeepPartial<DialogflowSource>): DialogflowSource {
    return DialogflowSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DialogflowSource>): DialogflowSource {
    const message = createBaseDialogflowSource();
    message.dialogflowConversation = object.dialogflowConversation ?? "";
    message.audioUri = object.audioUri ?? "";
    return message;
  },
};

function createBaseAnalysisResult(): AnalysisResult {
  return { callAnalysisMetadata: undefined, endTime: undefined };
}

export const AnalysisResult: MessageFns<AnalysisResult> = {
  encode(message: AnalysisResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callAnalysisMetadata !== undefined) {
      AnalysisResult_CallAnalysisMetadata.encode(message.callAnalysisMetadata, writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalysisResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysisResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.callAnalysisMetadata = AnalysisResult_CallAnalysisMetadata.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalysisResult {
    return {
      callAnalysisMetadata: isSet(object.callAnalysisMetadata)
        ? AnalysisResult_CallAnalysisMetadata.fromJSON(object.callAnalysisMetadata)
        : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: AnalysisResult): unknown {
    const obj: any = {};
    if (message.callAnalysisMetadata !== undefined) {
      obj.callAnalysisMetadata = AnalysisResult_CallAnalysisMetadata.toJSON(message.callAnalysisMetadata);
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AnalysisResult>): AnalysisResult {
    return AnalysisResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalysisResult>): AnalysisResult {
    const message = createBaseAnalysisResult();
    message.callAnalysisMetadata = (object.callAnalysisMetadata !== undefined && object.callAnalysisMetadata !== null)
      ? AnalysisResult_CallAnalysisMetadata.fromPartial(object.callAnalysisMetadata)
      : undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseAnalysisResult_CallAnalysisMetadata(): AnalysisResult_CallAnalysisMetadata {
  return {
    annotations: [],
    entities: {},
    sentiments: [],
    intents: {},
    phraseMatchers: {},
    issueModelResult: undefined,
  };
}

export const AnalysisResult_CallAnalysisMetadata: MessageFns<AnalysisResult_CallAnalysisMetadata> = {
  encode(message: AnalysisResult_CallAnalysisMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.annotations) {
      CallAnnotation.encode(v!, writer.uint32(18).fork()).join();
    }
    Object.entries(message.entities).forEach(([key, value]) => {
      AnalysisResult_CallAnalysisMetadata_EntitiesEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .join();
    });
    for (const v of message.sentiments) {
      ConversationLevelSentiment.encode(v!, writer.uint32(34).fork()).join();
    }
    Object.entries(message.intents).forEach(([key, value]) => {
      AnalysisResult_CallAnalysisMetadata_IntentsEntry.encode({ key: key as any, value }, writer.uint32(50).fork())
        .join();
    });
    Object.entries(message.phraseMatchers).forEach(([key, value]) => {
      AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry.encode(
        { key: key as any, value },
        writer.uint32(58).fork(),
      ).join();
    });
    if (message.issueModelResult !== undefined) {
      IssueModelResult.encode(message.issueModelResult, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalysisResult_CallAnalysisMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysisResult_CallAnalysisMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.annotations.push(CallAnnotation.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = AnalysisResult_CallAnalysisMetadata_EntitiesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.entities[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.sentiments.push(ConversationLevelSentiment.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = AnalysisResult_CallAnalysisMetadata_IntentsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.intents[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.phraseMatchers[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.issueModelResult = IssueModelResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalysisResult_CallAnalysisMetadata {
    return {
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => CallAnnotation.fromJSON(e))
        : [],
      entities: isObject(object.entities)
        ? Object.entries(object.entities).reduce<{ [key: string]: Entity }>((acc, [key, value]) => {
          acc[key] = Entity.fromJSON(value);
          return acc;
        }, {})
        : {},
      sentiments: globalThis.Array.isArray(object?.sentiments)
        ? object.sentiments.map((e: any) => ConversationLevelSentiment.fromJSON(e))
        : [],
      intents: isObject(object.intents)
        ? Object.entries(object.intents).reduce<{ [key: string]: Intent }>((acc, [key, value]) => {
          acc[key] = Intent.fromJSON(value);
          return acc;
        }, {})
        : {},
      phraseMatchers: isObject(object.phraseMatchers)
        ? Object.entries(object.phraseMatchers).reduce<{ [key: string]: PhraseMatchData }>((acc, [key, value]) => {
          acc[key] = PhraseMatchData.fromJSON(value);
          return acc;
        }, {})
        : {},
      issueModelResult: isSet(object.issueModelResult) ? IssueModelResult.fromJSON(object.issueModelResult) : undefined,
    };
  },

  toJSON(message: AnalysisResult_CallAnalysisMetadata): unknown {
    const obj: any = {};
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => CallAnnotation.toJSON(e));
    }
    if (message.entities) {
      const entries = Object.entries(message.entities);
      if (entries.length > 0) {
        obj.entities = {};
        entries.forEach(([k, v]) => {
          obj.entities[k] = Entity.toJSON(v);
        });
      }
    }
    if (message.sentiments?.length) {
      obj.sentiments = message.sentiments.map((e) => ConversationLevelSentiment.toJSON(e));
    }
    if (message.intents) {
      const entries = Object.entries(message.intents);
      if (entries.length > 0) {
        obj.intents = {};
        entries.forEach(([k, v]) => {
          obj.intents[k] = Intent.toJSON(v);
        });
      }
    }
    if (message.phraseMatchers) {
      const entries = Object.entries(message.phraseMatchers);
      if (entries.length > 0) {
        obj.phraseMatchers = {};
        entries.forEach(([k, v]) => {
          obj.phraseMatchers[k] = PhraseMatchData.toJSON(v);
        });
      }
    }
    if (message.issueModelResult !== undefined) {
      obj.issueModelResult = IssueModelResult.toJSON(message.issueModelResult);
    }
    return obj;
  },

  create(base?: DeepPartial<AnalysisResult_CallAnalysisMetadata>): AnalysisResult_CallAnalysisMetadata {
    return AnalysisResult_CallAnalysisMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnalysisResult_CallAnalysisMetadata>): AnalysisResult_CallAnalysisMetadata {
    const message = createBaseAnalysisResult_CallAnalysisMetadata();
    message.annotations = object.annotations?.map((e) => CallAnnotation.fromPartial(e)) || [];
    message.entities = Object.entries(object.entities ?? {}).reduce<{ [key: string]: Entity }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Entity.fromPartial(value);
      }
      return acc;
    }, {});
    message.sentiments = object.sentiments?.map((e) => ConversationLevelSentiment.fromPartial(e)) || [];
    message.intents = Object.entries(object.intents ?? {}).reduce<{ [key: string]: Intent }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Intent.fromPartial(value);
      }
      return acc;
    }, {});
    message.phraseMatchers = Object.entries(object.phraseMatchers ?? {}).reduce<{ [key: string]: PhraseMatchData }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = PhraseMatchData.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.issueModelResult = (object.issueModelResult !== undefined && object.issueModelResult !== null)
      ? IssueModelResult.fromPartial(object.issueModelResult)
      : undefined;
    return message;
  },
};

function createBaseAnalysisResult_CallAnalysisMetadata_EntitiesEntry(): AnalysisResult_CallAnalysisMetadata_EntitiesEntry {
  return { key: "", value: undefined };
}

export const AnalysisResult_CallAnalysisMetadata_EntitiesEntry: MessageFns<
  AnalysisResult_CallAnalysisMetadata_EntitiesEntry
> = {
  encode(
    message: AnalysisResult_CallAnalysisMetadata_EntitiesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Entity.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalysisResult_CallAnalysisMetadata_EntitiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysisResult_CallAnalysisMetadata_EntitiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Entity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalysisResult_CallAnalysisMetadata_EntitiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Entity.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AnalysisResult_CallAnalysisMetadata_EntitiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Entity.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AnalysisResult_CallAnalysisMetadata_EntitiesEntry>,
  ): AnalysisResult_CallAnalysisMetadata_EntitiesEntry {
    return AnalysisResult_CallAnalysisMetadata_EntitiesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AnalysisResult_CallAnalysisMetadata_EntitiesEntry>,
  ): AnalysisResult_CallAnalysisMetadata_EntitiesEntry {
    const message = createBaseAnalysisResult_CallAnalysisMetadata_EntitiesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Entity.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAnalysisResult_CallAnalysisMetadata_IntentsEntry(): AnalysisResult_CallAnalysisMetadata_IntentsEntry {
  return { key: "", value: undefined };
}

export const AnalysisResult_CallAnalysisMetadata_IntentsEntry: MessageFns<
  AnalysisResult_CallAnalysisMetadata_IntentsEntry
> = {
  encode(
    message: AnalysisResult_CallAnalysisMetadata_IntentsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Intent.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalysisResult_CallAnalysisMetadata_IntentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysisResult_CallAnalysisMetadata_IntentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Intent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalysisResult_CallAnalysisMetadata_IntentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Intent.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AnalysisResult_CallAnalysisMetadata_IntentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Intent.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AnalysisResult_CallAnalysisMetadata_IntentsEntry>,
  ): AnalysisResult_CallAnalysisMetadata_IntentsEntry {
    return AnalysisResult_CallAnalysisMetadata_IntentsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AnalysisResult_CallAnalysisMetadata_IntentsEntry>,
  ): AnalysisResult_CallAnalysisMetadata_IntentsEntry {
    const message = createBaseAnalysisResult_CallAnalysisMetadata_IntentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Intent.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry(): AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry {
  return { key: "", value: undefined };
}

export const AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry: MessageFns<
  AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry
> = {
  encode(
    message: AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      PhraseMatchData.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = PhraseMatchData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? PhraseMatchData.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = PhraseMatchData.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry>,
  ): AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry {
    return AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry>,
  ): AnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry {
    const message = createBaseAnalysisResult_CallAnalysisMetadata_PhraseMatchersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? PhraseMatchData.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseIssueModelResult(): IssueModelResult {
  return { issueModel: "", issues: [] };
}

export const IssueModelResult: MessageFns<IssueModelResult> = {
  encode(message: IssueModelResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issueModel !== "") {
      writer.uint32(10).string(message.issueModel);
    }
    for (const v of message.issues) {
      IssueAssignment.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IssueModelResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssueModelResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issueModel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.issues.push(IssueAssignment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssueModelResult {
    return {
      issueModel: isSet(object.issueModel) ? globalThis.String(object.issueModel) : "",
      issues: globalThis.Array.isArray(object?.issues)
        ? object.issues.map((e: any) => IssueAssignment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IssueModelResult): unknown {
    const obj: any = {};
    if (message.issueModel !== "") {
      obj.issueModel = message.issueModel;
    }
    if (message.issues?.length) {
      obj.issues = message.issues.map((e) => IssueAssignment.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IssueModelResult>): IssueModelResult {
    return IssueModelResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IssueModelResult>): IssueModelResult {
    const message = createBaseIssueModelResult();
    message.issueModel = object.issueModel ?? "";
    message.issues = object.issues?.map((e) => IssueAssignment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConversationLevelSentiment(): ConversationLevelSentiment {
  return { channelTag: 0, sentimentData: undefined };
}

export const ConversationLevelSentiment: MessageFns<ConversationLevelSentiment> = {
  encode(message: ConversationLevelSentiment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelTag !== 0) {
      writer.uint32(8).int32(message.channelTag);
    }
    if (message.sentimentData !== undefined) {
      SentimentData.encode(message.sentimentData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationLevelSentiment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationLevelSentiment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channelTag = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sentimentData = SentimentData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationLevelSentiment {
    return {
      channelTag: isSet(object.channelTag) ? globalThis.Number(object.channelTag) : 0,
      sentimentData: isSet(object.sentimentData) ? SentimentData.fromJSON(object.sentimentData) : undefined,
    };
  },

  toJSON(message: ConversationLevelSentiment): unknown {
    const obj: any = {};
    if (message.channelTag !== 0) {
      obj.channelTag = Math.round(message.channelTag);
    }
    if (message.sentimentData !== undefined) {
      obj.sentimentData = SentimentData.toJSON(message.sentimentData);
    }
    return obj;
  },

  create(base?: DeepPartial<ConversationLevelSentiment>): ConversationLevelSentiment {
    return ConversationLevelSentiment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversationLevelSentiment>): ConversationLevelSentiment {
    const message = createBaseConversationLevelSentiment();
    message.channelTag = object.channelTag ?? 0;
    message.sentimentData = (object.sentimentData !== undefined && object.sentimentData !== null)
      ? SentimentData.fromPartial(object.sentimentData)
      : undefined;
    return message;
  },
};

function createBaseIssueAssignment(): IssueAssignment {
  return { issue: "", score: 0, displayName: "" };
}

export const IssueAssignment: MessageFns<IssueAssignment> = {
  encode(message: IssueAssignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issue !== "") {
      writer.uint32(10).string(message.issue);
    }
    if (message.score !== 0) {
      writer.uint32(17).double(message.score);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IssueAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssueAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issue = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.score = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssueAssignment {
    return {
      issue: isSet(object.issue) ? globalThis.String(object.issue) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: IssueAssignment): unknown {
    const obj: any = {};
    if (message.issue !== "") {
      obj.issue = message.issue;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<IssueAssignment>): IssueAssignment {
    return IssueAssignment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IssueAssignment>): IssueAssignment {
    const message = createBaseIssueAssignment();
    message.issue = object.issue ?? "";
    message.score = object.score ?? 0;
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseCallAnnotation(): CallAnnotation {
  return {
    interruptionData: undefined,
    sentimentData: undefined,
    silenceData: undefined,
    holdData: undefined,
    entityMentionData: undefined,
    intentMatchData: undefined,
    phraseMatchData: undefined,
    issueMatchData: undefined,
    channelTag: 0,
    annotationStartBoundary: undefined,
    annotationEndBoundary: undefined,
  };
}

export const CallAnnotation: MessageFns<CallAnnotation> = {
  encode(message: CallAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.interruptionData !== undefined) {
      InterruptionData.encode(message.interruptionData, writer.uint32(82).fork()).join();
    }
    if (message.sentimentData !== undefined) {
      SentimentData.encode(message.sentimentData, writer.uint32(90).fork()).join();
    }
    if (message.silenceData !== undefined) {
      SilenceData.encode(message.silenceData, writer.uint32(98).fork()).join();
    }
    if (message.holdData !== undefined) {
      HoldData.encode(message.holdData, writer.uint32(106).fork()).join();
    }
    if (message.entityMentionData !== undefined) {
      EntityMentionData.encode(message.entityMentionData, writer.uint32(122).fork()).join();
    }
    if (message.intentMatchData !== undefined) {
      IntentMatchData.encode(message.intentMatchData, writer.uint32(130).fork()).join();
    }
    if (message.phraseMatchData !== undefined) {
      PhraseMatchData.encode(message.phraseMatchData, writer.uint32(138).fork()).join();
    }
    if (message.issueMatchData !== undefined) {
      IssueMatchData.encode(message.issueMatchData, writer.uint32(146).fork()).join();
    }
    if (message.channelTag !== 0) {
      writer.uint32(8).int32(message.channelTag);
    }
    if (message.annotationStartBoundary !== undefined) {
      AnnotationBoundary.encode(message.annotationStartBoundary, writer.uint32(34).fork()).join();
    }
    if (message.annotationEndBoundary !== undefined) {
      AnnotationBoundary.encode(message.annotationEndBoundary, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CallAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10:
          if (tag !== 82) {
            break;
          }

          message.interruptionData = InterruptionData.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.sentimentData = SentimentData.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.silenceData = SilenceData.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.holdData = HoldData.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.entityMentionData = EntityMentionData.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.intentMatchData = IntentMatchData.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.phraseMatchData = PhraseMatchData.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.issueMatchData = IssueMatchData.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.channelTag = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.annotationStartBoundary = AnnotationBoundary.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.annotationEndBoundary = AnnotationBoundary.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CallAnnotation {
    return {
      interruptionData: isSet(object.interruptionData) ? InterruptionData.fromJSON(object.interruptionData) : undefined,
      sentimentData: isSet(object.sentimentData) ? SentimentData.fromJSON(object.sentimentData) : undefined,
      silenceData: isSet(object.silenceData) ? SilenceData.fromJSON(object.silenceData) : undefined,
      holdData: isSet(object.holdData) ? HoldData.fromJSON(object.holdData) : undefined,
      entityMentionData: isSet(object.entityMentionData)
        ? EntityMentionData.fromJSON(object.entityMentionData)
        : undefined,
      intentMatchData: isSet(object.intentMatchData) ? IntentMatchData.fromJSON(object.intentMatchData) : undefined,
      phraseMatchData: isSet(object.phraseMatchData) ? PhraseMatchData.fromJSON(object.phraseMatchData) : undefined,
      issueMatchData: isSet(object.issueMatchData) ? IssueMatchData.fromJSON(object.issueMatchData) : undefined,
      channelTag: isSet(object.channelTag) ? globalThis.Number(object.channelTag) : 0,
      annotationStartBoundary: isSet(object.annotationStartBoundary)
        ? AnnotationBoundary.fromJSON(object.annotationStartBoundary)
        : undefined,
      annotationEndBoundary: isSet(object.annotationEndBoundary)
        ? AnnotationBoundary.fromJSON(object.annotationEndBoundary)
        : undefined,
    };
  },

  toJSON(message: CallAnnotation): unknown {
    const obj: any = {};
    if (message.interruptionData !== undefined) {
      obj.interruptionData = InterruptionData.toJSON(message.interruptionData);
    }
    if (message.sentimentData !== undefined) {
      obj.sentimentData = SentimentData.toJSON(message.sentimentData);
    }
    if (message.silenceData !== undefined) {
      obj.silenceData = SilenceData.toJSON(message.silenceData);
    }
    if (message.holdData !== undefined) {
      obj.holdData = HoldData.toJSON(message.holdData);
    }
    if (message.entityMentionData !== undefined) {
      obj.entityMentionData = EntityMentionData.toJSON(message.entityMentionData);
    }
    if (message.intentMatchData !== undefined) {
      obj.intentMatchData = IntentMatchData.toJSON(message.intentMatchData);
    }
    if (message.phraseMatchData !== undefined) {
      obj.phraseMatchData = PhraseMatchData.toJSON(message.phraseMatchData);
    }
    if (message.issueMatchData !== undefined) {
      obj.issueMatchData = IssueMatchData.toJSON(message.issueMatchData);
    }
    if (message.channelTag !== 0) {
      obj.channelTag = Math.round(message.channelTag);
    }
    if (message.annotationStartBoundary !== undefined) {
      obj.annotationStartBoundary = AnnotationBoundary.toJSON(message.annotationStartBoundary);
    }
    if (message.annotationEndBoundary !== undefined) {
      obj.annotationEndBoundary = AnnotationBoundary.toJSON(message.annotationEndBoundary);
    }
    return obj;
  },

  create(base?: DeepPartial<CallAnnotation>): CallAnnotation {
    return CallAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CallAnnotation>): CallAnnotation {
    const message = createBaseCallAnnotation();
    message.interruptionData = (object.interruptionData !== undefined && object.interruptionData !== null)
      ? InterruptionData.fromPartial(object.interruptionData)
      : undefined;
    message.sentimentData = (object.sentimentData !== undefined && object.sentimentData !== null)
      ? SentimentData.fromPartial(object.sentimentData)
      : undefined;
    message.silenceData = (object.silenceData !== undefined && object.silenceData !== null)
      ? SilenceData.fromPartial(object.silenceData)
      : undefined;
    message.holdData = (object.holdData !== undefined && object.holdData !== null)
      ? HoldData.fromPartial(object.holdData)
      : undefined;
    message.entityMentionData = (object.entityMentionData !== undefined && object.entityMentionData !== null)
      ? EntityMentionData.fromPartial(object.entityMentionData)
      : undefined;
    message.intentMatchData = (object.intentMatchData !== undefined && object.intentMatchData !== null)
      ? IntentMatchData.fromPartial(object.intentMatchData)
      : undefined;
    message.phraseMatchData = (object.phraseMatchData !== undefined && object.phraseMatchData !== null)
      ? PhraseMatchData.fromPartial(object.phraseMatchData)
      : undefined;
    message.issueMatchData = (object.issueMatchData !== undefined && object.issueMatchData !== null)
      ? IssueMatchData.fromPartial(object.issueMatchData)
      : undefined;
    message.channelTag = object.channelTag ?? 0;
    message.annotationStartBoundary =
      (object.annotationStartBoundary !== undefined && object.annotationStartBoundary !== null)
        ? AnnotationBoundary.fromPartial(object.annotationStartBoundary)
        : undefined;
    message.annotationEndBoundary =
      (object.annotationEndBoundary !== undefined && object.annotationEndBoundary !== null)
        ? AnnotationBoundary.fromPartial(object.annotationEndBoundary)
        : undefined;
    return message;
  },
};

function createBaseAnnotationBoundary(): AnnotationBoundary {
  return { wordIndex: undefined, transcriptIndex: 0 };
}

export const AnnotationBoundary: MessageFns<AnnotationBoundary> = {
  encode(message: AnnotationBoundary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wordIndex !== undefined) {
      writer.uint32(24).int32(message.wordIndex);
    }
    if (message.transcriptIndex !== 0) {
      writer.uint32(8).int32(message.transcriptIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotationBoundary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotationBoundary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.wordIndex = reader.int32();
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.transcriptIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotationBoundary {
    return {
      wordIndex: isSet(object.wordIndex) ? globalThis.Number(object.wordIndex) : undefined,
      transcriptIndex: isSet(object.transcriptIndex) ? globalThis.Number(object.transcriptIndex) : 0,
    };
  },

  toJSON(message: AnnotationBoundary): unknown {
    const obj: any = {};
    if (message.wordIndex !== undefined) {
      obj.wordIndex = Math.round(message.wordIndex);
    }
    if (message.transcriptIndex !== 0) {
      obj.transcriptIndex = Math.round(message.transcriptIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotationBoundary>): AnnotationBoundary {
    return AnnotationBoundary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotationBoundary>): AnnotationBoundary {
    const message = createBaseAnnotationBoundary();
    message.wordIndex = object.wordIndex ?? undefined;
    message.transcriptIndex = object.transcriptIndex ?? 0;
    return message;
  },
};

function createBaseEntity(): Entity {
  return { displayName: "", type: 0, metadata: {}, salience: 0, sentiment: undefined };
}

export const Entity: MessageFns<Entity> = {
  encode(message: Entity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Entity_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.salience !== 0) {
      writer.uint32(37).float(message.salience);
    }
    if (message.sentiment !== undefined) {
      SentimentData.encode(message.sentiment, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Entity_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.salience = reader.float();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sentiment = SentimentData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entity {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      type: isSet(object.type) ? entity_TypeFromJSON(object.type) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      salience: isSet(object.salience) ? globalThis.Number(object.salience) : 0,
      sentiment: isSet(object.sentiment) ? SentimentData.fromJSON(object.sentiment) : undefined,
    };
  },

  toJSON(message: Entity): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.type !== 0) {
      obj.type = entity_TypeToJSON(message.type);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.salience !== 0) {
      obj.salience = message.salience;
    }
    if (message.sentiment !== undefined) {
      obj.sentiment = SentimentData.toJSON(message.sentiment);
    }
    return obj;
  },

  create(base?: DeepPartial<Entity>): Entity {
    return Entity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entity>): Entity {
    const message = createBaseEntity();
    message.displayName = object.displayName ?? "";
    message.type = object.type ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.salience = object.salience ?? 0;
    message.sentiment = (object.sentiment !== undefined && object.sentiment !== null)
      ? SentimentData.fromPartial(object.sentiment)
      : undefined;
    return message;
  },
};

function createBaseEntity_MetadataEntry(): Entity_MetadataEntry {
  return { key: "", value: "" };
}

export const Entity_MetadataEntry: MessageFns<Entity_MetadataEntry> = {
  encode(message: Entity_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entity_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntity_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entity_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Entity_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Entity_MetadataEntry>): Entity_MetadataEntry {
    return Entity_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entity_MetadataEntry>): Entity_MetadataEntry {
    const message = createBaseEntity_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseIntent(): Intent {
  return { id: "", displayName: "" };
}

export const Intent: MessageFns<Intent> = {
  encode(message: Intent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Intent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Intent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: Intent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<Intent>): Intent {
    return Intent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Intent>): Intent {
    const message = createBaseIntent();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBasePhraseMatchData(): PhraseMatchData {
  return { phraseMatcher: "", displayName: "" };
}

export const PhraseMatchData: MessageFns<PhraseMatchData> = {
  encode(message: PhraseMatchData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.phraseMatcher !== "") {
      writer.uint32(10).string(message.phraseMatcher);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhraseMatchData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhraseMatchData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.phraseMatcher = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhraseMatchData {
    return {
      phraseMatcher: isSet(object.phraseMatcher) ? globalThis.String(object.phraseMatcher) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: PhraseMatchData): unknown {
    const obj: any = {};
    if (message.phraseMatcher !== "") {
      obj.phraseMatcher = message.phraseMatcher;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<PhraseMatchData>): PhraseMatchData {
    return PhraseMatchData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhraseMatchData>): PhraseMatchData {
    const message = createBasePhraseMatchData();
    message.phraseMatcher = object.phraseMatcher ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseDialogflowIntent(): DialogflowIntent {
  return { displayName: "" };
}

export const DialogflowIntent: MessageFns<DialogflowIntent> = {
  encode(message: DialogflowIntent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogflowIntent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogflowIntent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogflowIntent {
    return { displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "" };
  },

  toJSON(message: DialogflowIntent): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<DialogflowIntent>): DialogflowIntent {
    return DialogflowIntent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DialogflowIntent>): DialogflowIntent {
    const message = createBaseDialogflowIntent();
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseInterruptionData(): InterruptionData {
  return {};
}

export const InterruptionData: MessageFns<InterruptionData> = {
  encode(_: InterruptionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterruptionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterruptionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InterruptionData {
    return {};
  },

  toJSON(_: InterruptionData): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<InterruptionData>): InterruptionData {
    return InterruptionData.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<InterruptionData>): InterruptionData {
    const message = createBaseInterruptionData();
    return message;
  },
};

function createBaseSilenceData(): SilenceData {
  return {};
}

export const SilenceData: MessageFns<SilenceData> = {
  encode(_: SilenceData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SilenceData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSilenceData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SilenceData {
    return {};
  },

  toJSON(_: SilenceData): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SilenceData>): SilenceData {
    return SilenceData.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SilenceData>): SilenceData {
    const message = createBaseSilenceData();
    return message;
  },
};

function createBaseHoldData(): HoldData {
  return {};
}

export const HoldData: MessageFns<HoldData> = {
  encode(_: HoldData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HoldData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHoldData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HoldData {
    return {};
  },

  toJSON(_: HoldData): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<HoldData>): HoldData {
    return HoldData.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<HoldData>): HoldData {
    const message = createBaseHoldData();
    return message;
  },
};

function createBaseEntityMentionData(): EntityMentionData {
  return { entityUniqueId: "", type: 0, sentiment: undefined };
}

export const EntityMentionData: MessageFns<EntityMentionData> = {
  encode(message: EntityMentionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityUniqueId !== "") {
      writer.uint32(10).string(message.entityUniqueId);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.sentiment !== undefined) {
      SentimentData.encode(message.sentiment, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityMentionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityMentionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entityUniqueId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sentiment = SentimentData.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityMentionData {
    return {
      entityUniqueId: isSet(object.entityUniqueId) ? globalThis.String(object.entityUniqueId) : "",
      type: isSet(object.type) ? entityMentionData_MentionTypeFromJSON(object.type) : 0,
      sentiment: isSet(object.sentiment) ? SentimentData.fromJSON(object.sentiment) : undefined,
    };
  },

  toJSON(message: EntityMentionData): unknown {
    const obj: any = {};
    if (message.entityUniqueId !== "") {
      obj.entityUniqueId = message.entityUniqueId;
    }
    if (message.type !== 0) {
      obj.type = entityMentionData_MentionTypeToJSON(message.type);
    }
    if (message.sentiment !== undefined) {
      obj.sentiment = SentimentData.toJSON(message.sentiment);
    }
    return obj;
  },

  create(base?: DeepPartial<EntityMentionData>): EntityMentionData {
    return EntityMentionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityMentionData>): EntityMentionData {
    const message = createBaseEntityMentionData();
    message.entityUniqueId = object.entityUniqueId ?? "";
    message.type = object.type ?? 0;
    message.sentiment = (object.sentiment !== undefined && object.sentiment !== null)
      ? SentimentData.fromPartial(object.sentiment)
      : undefined;
    return message;
  },
};

function createBaseIntentMatchData(): IntentMatchData {
  return { intentUniqueId: "" };
}

export const IntentMatchData: MessageFns<IntentMatchData> = {
  encode(message: IntentMatchData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.intentUniqueId !== "") {
      writer.uint32(10).string(message.intentUniqueId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntentMatchData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntentMatchData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.intentUniqueId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntentMatchData {
    return { intentUniqueId: isSet(object.intentUniqueId) ? globalThis.String(object.intentUniqueId) : "" };
  },

  toJSON(message: IntentMatchData): unknown {
    const obj: any = {};
    if (message.intentUniqueId !== "") {
      obj.intentUniqueId = message.intentUniqueId;
    }
    return obj;
  },

  create(base?: DeepPartial<IntentMatchData>): IntentMatchData {
    return IntentMatchData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntentMatchData>): IntentMatchData {
    const message = createBaseIntentMatchData();
    message.intentUniqueId = object.intentUniqueId ?? "";
    return message;
  },
};

function createBaseSentimentData(): SentimentData {
  return { magnitude: 0, score: 0 };
}

export const SentimentData: MessageFns<SentimentData> = {
  encode(message: SentimentData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.magnitude !== 0) {
      writer.uint32(13).float(message.magnitude);
    }
    if (message.score !== 0) {
      writer.uint32(21).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SentimentData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSentimentData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.magnitude = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.score = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SentimentData {
    return {
      magnitude: isSet(object.magnitude) ? globalThis.Number(object.magnitude) : 0,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: SentimentData): unknown {
    const obj: any = {};
    if (message.magnitude !== 0) {
      obj.magnitude = message.magnitude;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<SentimentData>): SentimentData {
    return SentimentData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SentimentData>): SentimentData {
    const message = createBaseSentimentData();
    message.magnitude = object.magnitude ?? 0;
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseIssueMatchData(): IssueMatchData {
  return { issueAssignment: undefined };
}

export const IssueMatchData: MessageFns<IssueMatchData> = {
  encode(message: IssueMatchData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issueAssignment !== undefined) {
      IssueAssignment.encode(message.issueAssignment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IssueMatchData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssueMatchData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issueAssignment = IssueAssignment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssueMatchData {
    return {
      issueAssignment: isSet(object.issueAssignment) ? IssueAssignment.fromJSON(object.issueAssignment) : undefined,
    };
  },

  toJSON(message: IssueMatchData): unknown {
    const obj: any = {};
    if (message.issueAssignment !== undefined) {
      obj.issueAssignment = IssueAssignment.toJSON(message.issueAssignment);
    }
    return obj;
  },

  create(base?: DeepPartial<IssueMatchData>): IssueMatchData {
    return IssueMatchData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IssueMatchData>): IssueMatchData {
    const message = createBaseIssueMatchData();
    message.issueAssignment = (object.issueAssignment !== undefined && object.issueAssignment !== null)
      ? IssueAssignment.fromPartial(object.issueAssignment)
      : undefined;
    return message;
  },
};

function createBaseIssueModel(): IssueModel {
  return {
    name: "",
    displayName: "",
    createTime: undefined,
    updateTime: undefined,
    issueCount: Long.ZERO,
    state: 0,
    inputDataConfig: undefined,
    trainingStats: undefined,
    modelType: 0,
    languageCode: "",
  };
}

export const IssueModel: MessageFns<IssueModel> = {
  encode(message: IssueModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (!message.issueCount.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.issueCount.toString());
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.inputDataConfig !== undefined) {
      IssueModel_InputDataConfig.encode(message.inputDataConfig, writer.uint32(50).fork()).join();
    }
    if (message.trainingStats !== undefined) {
      IssueModelLabelStats.encode(message.trainingStats, writer.uint32(58).fork()).join();
    }
    if (message.modelType !== 0) {
      writer.uint32(72).int32(message.modelType);
    }
    if (message.languageCode !== "") {
      writer.uint32(82).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IssueModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssueModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.issueCount = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.inputDataConfig = IssueModel_InputDataConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.trainingStats = IssueModelLabelStats.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.modelType = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssueModel {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      issueCount: isSet(object.issueCount) ? Long.fromValue(object.issueCount) : Long.ZERO,
      state: isSet(object.state) ? issueModel_StateFromJSON(object.state) : 0,
      inputDataConfig: isSet(object.inputDataConfig)
        ? IssueModel_InputDataConfig.fromJSON(object.inputDataConfig)
        : undefined,
      trainingStats: isSet(object.trainingStats) ? IssueModelLabelStats.fromJSON(object.trainingStats) : undefined,
      modelType: isSet(object.modelType) ? issueModel_ModelTypeFromJSON(object.modelType) : 0,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: IssueModel): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (!message.issueCount.equals(Long.ZERO)) {
      obj.issueCount = (message.issueCount || Long.ZERO).toString();
    }
    if (message.state !== 0) {
      obj.state = issueModel_StateToJSON(message.state);
    }
    if (message.inputDataConfig !== undefined) {
      obj.inputDataConfig = IssueModel_InputDataConfig.toJSON(message.inputDataConfig);
    }
    if (message.trainingStats !== undefined) {
      obj.trainingStats = IssueModelLabelStats.toJSON(message.trainingStats);
    }
    if (message.modelType !== 0) {
      obj.modelType = issueModel_ModelTypeToJSON(message.modelType);
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<IssueModel>): IssueModel {
    return IssueModel.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IssueModel>): IssueModel {
    const message = createBaseIssueModel();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.issueCount = (object.issueCount !== undefined && object.issueCount !== null)
      ? Long.fromValue(object.issueCount)
      : Long.ZERO;
    message.state = object.state ?? 0;
    message.inputDataConfig = (object.inputDataConfig !== undefined && object.inputDataConfig !== null)
      ? IssueModel_InputDataConfig.fromPartial(object.inputDataConfig)
      : undefined;
    message.trainingStats = (object.trainingStats !== undefined && object.trainingStats !== null)
      ? IssueModelLabelStats.fromPartial(object.trainingStats)
      : undefined;
    message.modelType = object.modelType ?? 0;
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseIssueModel_InputDataConfig(): IssueModel_InputDataConfig {
  return { medium: 0, trainingConversationsCount: Long.ZERO, filter: "" };
}

export const IssueModel_InputDataConfig: MessageFns<IssueModel_InputDataConfig> = {
  encode(message: IssueModel_InputDataConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.medium !== 0) {
      writer.uint32(8).int32(message.medium);
    }
    if (!message.trainingConversationsCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.trainingConversationsCount.toString());
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IssueModel_InputDataConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssueModel_InputDataConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.medium = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.trainingConversationsCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssueModel_InputDataConfig {
    return {
      medium: isSet(object.medium) ? conversation_MediumFromJSON(object.medium) : 0,
      trainingConversationsCount: isSet(object.trainingConversationsCount)
        ? Long.fromValue(object.trainingConversationsCount)
        : Long.ZERO,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: IssueModel_InputDataConfig): unknown {
    const obj: any = {};
    if (message.medium !== 0) {
      obj.medium = conversation_MediumToJSON(message.medium);
    }
    if (!message.trainingConversationsCount.equals(Long.ZERO)) {
      obj.trainingConversationsCount = (message.trainingConversationsCount || Long.ZERO).toString();
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<IssueModel_InputDataConfig>): IssueModel_InputDataConfig {
    return IssueModel_InputDataConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IssueModel_InputDataConfig>): IssueModel_InputDataConfig {
    const message = createBaseIssueModel_InputDataConfig();
    message.medium = object.medium ?? 0;
    message.trainingConversationsCount =
      (object.trainingConversationsCount !== undefined && object.trainingConversationsCount !== null)
        ? Long.fromValue(object.trainingConversationsCount)
        : Long.ZERO;
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseIssue(): Issue {
  return { name: "", displayName: "", createTime: undefined, updateTime: undefined, sampleUtterances: [] };
}

export const Issue: MessageFns<Issue> = {
  encode(message: Issue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    for (const v of message.sampleUtterances) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Issue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sampleUtterances.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Issue {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      sampleUtterances: globalThis.Array.isArray(object?.sampleUtterances)
        ? object.sampleUtterances.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Issue): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.sampleUtterances?.length) {
      obj.sampleUtterances = message.sampleUtterances;
    }
    return obj;
  },

  create(base?: DeepPartial<Issue>): Issue {
    return Issue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Issue>): Issue {
    const message = createBaseIssue();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.sampleUtterances = object.sampleUtterances?.map((e) => e) || [];
    return message;
  },
};

function createBaseIssueModelLabelStats(): IssueModelLabelStats {
  return { analyzedConversationsCount: Long.ZERO, unclassifiedConversationsCount: Long.ZERO, issueStats: {} };
}

export const IssueModelLabelStats: MessageFns<IssueModelLabelStats> = {
  encode(message: IssueModelLabelStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.analyzedConversationsCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.analyzedConversationsCount.toString());
    }
    if (!message.unclassifiedConversationsCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.unclassifiedConversationsCount.toString());
    }
    Object.entries(message.issueStats).forEach(([key, value]) => {
      IssueModelLabelStats_IssueStatsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IssueModelLabelStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssueModelLabelStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.analyzedConversationsCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.unclassifiedConversationsCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = IssueModelLabelStats_IssueStatsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.issueStats[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssueModelLabelStats {
    return {
      analyzedConversationsCount: isSet(object.analyzedConversationsCount)
        ? Long.fromValue(object.analyzedConversationsCount)
        : Long.ZERO,
      unclassifiedConversationsCount: isSet(object.unclassifiedConversationsCount)
        ? Long.fromValue(object.unclassifiedConversationsCount)
        : Long.ZERO,
      issueStats: isObject(object.issueStats)
        ? Object.entries(object.issueStats).reduce<{ [key: string]: IssueModelLabelStats_IssueStats }>(
          (acc, [key, value]) => {
            acc[key] = IssueModelLabelStats_IssueStats.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: IssueModelLabelStats): unknown {
    const obj: any = {};
    if (!message.analyzedConversationsCount.equals(Long.ZERO)) {
      obj.analyzedConversationsCount = (message.analyzedConversationsCount || Long.ZERO).toString();
    }
    if (!message.unclassifiedConversationsCount.equals(Long.ZERO)) {
      obj.unclassifiedConversationsCount = (message.unclassifiedConversationsCount || Long.ZERO).toString();
    }
    if (message.issueStats) {
      const entries = Object.entries(message.issueStats);
      if (entries.length > 0) {
        obj.issueStats = {};
        entries.forEach(([k, v]) => {
          obj.issueStats[k] = IssueModelLabelStats_IssueStats.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<IssueModelLabelStats>): IssueModelLabelStats {
    return IssueModelLabelStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IssueModelLabelStats>): IssueModelLabelStats {
    const message = createBaseIssueModelLabelStats();
    message.analyzedConversationsCount =
      (object.analyzedConversationsCount !== undefined && object.analyzedConversationsCount !== null)
        ? Long.fromValue(object.analyzedConversationsCount)
        : Long.ZERO;
    message.unclassifiedConversationsCount =
      (object.unclassifiedConversationsCount !== undefined && object.unclassifiedConversationsCount !== null)
        ? Long.fromValue(object.unclassifiedConversationsCount)
        : Long.ZERO;
    message.issueStats = Object.entries(object.issueStats ?? {}).reduce<
      { [key: string]: IssueModelLabelStats_IssueStats }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = IssueModelLabelStats_IssueStats.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseIssueModelLabelStats_IssueStats(): IssueModelLabelStats_IssueStats {
  return { issue: "", labeledConversationsCount: Long.ZERO, displayName: "" };
}

export const IssueModelLabelStats_IssueStats: MessageFns<IssueModelLabelStats_IssueStats> = {
  encode(message: IssueModelLabelStats_IssueStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issue !== "") {
      writer.uint32(10).string(message.issue);
    }
    if (!message.labeledConversationsCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.labeledConversationsCount.toString());
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IssueModelLabelStats_IssueStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssueModelLabelStats_IssueStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issue = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.labeledConversationsCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssueModelLabelStats_IssueStats {
    return {
      issue: isSet(object.issue) ? globalThis.String(object.issue) : "",
      labeledConversationsCount: isSet(object.labeledConversationsCount)
        ? Long.fromValue(object.labeledConversationsCount)
        : Long.ZERO,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: IssueModelLabelStats_IssueStats): unknown {
    const obj: any = {};
    if (message.issue !== "") {
      obj.issue = message.issue;
    }
    if (!message.labeledConversationsCount.equals(Long.ZERO)) {
      obj.labeledConversationsCount = (message.labeledConversationsCount || Long.ZERO).toString();
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<IssueModelLabelStats_IssueStats>): IssueModelLabelStats_IssueStats {
    return IssueModelLabelStats_IssueStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IssueModelLabelStats_IssueStats>): IssueModelLabelStats_IssueStats {
    const message = createBaseIssueModelLabelStats_IssueStats();
    message.issue = object.issue ?? "";
    message.labeledConversationsCount =
      (object.labeledConversationsCount !== undefined && object.labeledConversationsCount !== null)
        ? Long.fromValue(object.labeledConversationsCount)
        : Long.ZERO;
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseIssueModelLabelStats_IssueStatsEntry(): IssueModelLabelStats_IssueStatsEntry {
  return { key: "", value: undefined };
}

export const IssueModelLabelStats_IssueStatsEntry: MessageFns<IssueModelLabelStats_IssueStatsEntry> = {
  encode(message: IssueModelLabelStats_IssueStatsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      IssueModelLabelStats_IssueStats.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IssueModelLabelStats_IssueStatsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssueModelLabelStats_IssueStatsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = IssueModelLabelStats_IssueStats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IssueModelLabelStats_IssueStatsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? IssueModelLabelStats_IssueStats.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: IssueModelLabelStats_IssueStatsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = IssueModelLabelStats_IssueStats.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<IssueModelLabelStats_IssueStatsEntry>): IssueModelLabelStats_IssueStatsEntry {
    return IssueModelLabelStats_IssueStatsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IssueModelLabelStats_IssueStatsEntry>): IssueModelLabelStats_IssueStatsEntry {
    const message = createBaseIssueModelLabelStats_IssueStatsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? IssueModelLabelStats_IssueStats.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePhraseMatcher(): PhraseMatcher {
  return {
    name: "",
    revisionId: "",
    versionTag: "",
    revisionCreateTime: undefined,
    displayName: "",
    type: 0,
    active: false,
    phraseMatchRuleGroups: [],
    activationUpdateTime: undefined,
    roleMatch: 0,
    updateTime: undefined,
  };
}

export const PhraseMatcher: MessageFns<PhraseMatcher> = {
  encode(message: PhraseMatcher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.revisionId !== "") {
      writer.uint32(18).string(message.revisionId);
    }
    if (message.versionTag !== "") {
      writer.uint32(26).string(message.versionTag);
    }
    if (message.revisionCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionCreateTime), writer.uint32(34).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.type !== 0) {
      writer.uint32(48).int32(message.type);
    }
    if (message.active !== false) {
      writer.uint32(56).bool(message.active);
    }
    for (const v of message.phraseMatchRuleGroups) {
      PhraseMatchRuleGroup.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.activationUpdateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.activationUpdateTime), writer.uint32(74).fork()).join();
    }
    if (message.roleMatch !== 0) {
      writer.uint32(80).int32(message.roleMatch);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhraseMatcher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhraseMatcher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.versionTag = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.revisionCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.active = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.phraseMatchRuleGroups.push(PhraseMatchRuleGroup.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.activationUpdateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.roleMatch = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhraseMatcher {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      versionTag: isSet(object.versionTag) ? globalThis.String(object.versionTag) : "",
      revisionCreateTime: isSet(object.revisionCreateTime) ? fromJsonTimestamp(object.revisionCreateTime) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      type: isSet(object.type) ? phraseMatcher_PhraseMatcherTypeFromJSON(object.type) : 0,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      phraseMatchRuleGroups: globalThis.Array.isArray(object?.phraseMatchRuleGroups)
        ? object.phraseMatchRuleGroups.map((e: any) => PhraseMatchRuleGroup.fromJSON(e))
        : [],
      activationUpdateTime: isSet(object.activationUpdateTime)
        ? fromJsonTimestamp(object.activationUpdateTime)
        : undefined,
      roleMatch: isSet(object.roleMatch) ? conversationParticipant_RoleFromJSON(object.roleMatch) : 0,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: PhraseMatcher): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.versionTag !== "") {
      obj.versionTag = message.versionTag;
    }
    if (message.revisionCreateTime !== undefined) {
      obj.revisionCreateTime = message.revisionCreateTime.toISOString();
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.type !== 0) {
      obj.type = phraseMatcher_PhraseMatcherTypeToJSON(message.type);
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.phraseMatchRuleGroups?.length) {
      obj.phraseMatchRuleGroups = message.phraseMatchRuleGroups.map((e) => PhraseMatchRuleGroup.toJSON(e));
    }
    if (message.activationUpdateTime !== undefined) {
      obj.activationUpdateTime = message.activationUpdateTime.toISOString();
    }
    if (message.roleMatch !== 0) {
      obj.roleMatch = conversationParticipant_RoleToJSON(message.roleMatch);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<PhraseMatcher>): PhraseMatcher {
    return PhraseMatcher.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhraseMatcher>): PhraseMatcher {
    const message = createBasePhraseMatcher();
    message.name = object.name ?? "";
    message.revisionId = object.revisionId ?? "";
    message.versionTag = object.versionTag ?? "";
    message.revisionCreateTime = object.revisionCreateTime ?? undefined;
    message.displayName = object.displayName ?? "";
    message.type = object.type ?? 0;
    message.active = object.active ?? false;
    message.phraseMatchRuleGroups = object.phraseMatchRuleGroups?.map((e) => PhraseMatchRuleGroup.fromPartial(e)) || [];
    message.activationUpdateTime = object.activationUpdateTime ?? undefined;
    message.roleMatch = object.roleMatch ?? 0;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBasePhraseMatchRuleGroup(): PhraseMatchRuleGroup {
  return { type: 0, phraseMatchRules: [] };
}

export const PhraseMatchRuleGroup: MessageFns<PhraseMatchRuleGroup> = {
  encode(message: PhraseMatchRuleGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.phraseMatchRules) {
      PhraseMatchRule.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhraseMatchRuleGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhraseMatchRuleGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.phraseMatchRules.push(PhraseMatchRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhraseMatchRuleGroup {
    return {
      type: isSet(object.type) ? phraseMatchRuleGroup_PhraseMatchRuleGroupTypeFromJSON(object.type) : 0,
      phraseMatchRules: globalThis.Array.isArray(object?.phraseMatchRules)
        ? object.phraseMatchRules.map((e: any) => PhraseMatchRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PhraseMatchRuleGroup): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = phraseMatchRuleGroup_PhraseMatchRuleGroupTypeToJSON(message.type);
    }
    if (message.phraseMatchRules?.length) {
      obj.phraseMatchRules = message.phraseMatchRules.map((e) => PhraseMatchRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PhraseMatchRuleGroup>): PhraseMatchRuleGroup {
    return PhraseMatchRuleGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhraseMatchRuleGroup>): PhraseMatchRuleGroup {
    const message = createBasePhraseMatchRuleGroup();
    message.type = object.type ?? 0;
    message.phraseMatchRules = object.phraseMatchRules?.map((e) => PhraseMatchRule.fromPartial(e)) || [];
    return message;
  },
};

function createBasePhraseMatchRule(): PhraseMatchRule {
  return { query: "", negated: false, config: undefined };
}

export const PhraseMatchRule: MessageFns<PhraseMatchRule> = {
  encode(message: PhraseMatchRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.negated !== false) {
      writer.uint32(16).bool(message.negated);
    }
    if (message.config !== undefined) {
      PhraseMatchRuleConfig.encode(message.config, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhraseMatchRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhraseMatchRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.negated = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.config = PhraseMatchRuleConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhraseMatchRule {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      negated: isSet(object.negated) ? globalThis.Boolean(object.negated) : false,
      config: isSet(object.config) ? PhraseMatchRuleConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: PhraseMatchRule): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.negated !== false) {
      obj.negated = message.negated;
    }
    if (message.config !== undefined) {
      obj.config = PhraseMatchRuleConfig.toJSON(message.config);
    }
    return obj;
  },

  create(base?: DeepPartial<PhraseMatchRule>): PhraseMatchRule {
    return PhraseMatchRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhraseMatchRule>): PhraseMatchRule {
    const message = createBasePhraseMatchRule();
    message.query = object.query ?? "";
    message.negated = object.negated ?? false;
    message.config = (object.config !== undefined && object.config !== null)
      ? PhraseMatchRuleConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBasePhraseMatchRuleConfig(): PhraseMatchRuleConfig {
  return { exactMatchConfig: undefined };
}

export const PhraseMatchRuleConfig: MessageFns<PhraseMatchRuleConfig> = {
  encode(message: PhraseMatchRuleConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exactMatchConfig !== undefined) {
      ExactMatchConfig.encode(message.exactMatchConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PhraseMatchRuleConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhraseMatchRuleConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.exactMatchConfig = ExactMatchConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhraseMatchRuleConfig {
    return {
      exactMatchConfig: isSet(object.exactMatchConfig) ? ExactMatchConfig.fromJSON(object.exactMatchConfig) : undefined,
    };
  },

  toJSON(message: PhraseMatchRuleConfig): unknown {
    const obj: any = {};
    if (message.exactMatchConfig !== undefined) {
      obj.exactMatchConfig = ExactMatchConfig.toJSON(message.exactMatchConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<PhraseMatchRuleConfig>): PhraseMatchRuleConfig {
    return PhraseMatchRuleConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhraseMatchRuleConfig>): PhraseMatchRuleConfig {
    const message = createBasePhraseMatchRuleConfig();
    message.exactMatchConfig = (object.exactMatchConfig !== undefined && object.exactMatchConfig !== null)
      ? ExactMatchConfig.fromPartial(object.exactMatchConfig)
      : undefined;
    return message;
  },
};

function createBaseExactMatchConfig(): ExactMatchConfig {
  return { caseSensitive: false };
}

export const ExactMatchConfig: MessageFns<ExactMatchConfig> = {
  encode(message: ExactMatchConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caseSensitive !== false) {
      writer.uint32(8).bool(message.caseSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExactMatchConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExactMatchConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.caseSensitive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExactMatchConfig {
    return { caseSensitive: isSet(object.caseSensitive) ? globalThis.Boolean(object.caseSensitive) : false };
  },

  toJSON(message: ExactMatchConfig): unknown {
    const obj: any = {};
    if (message.caseSensitive !== false) {
      obj.caseSensitive = message.caseSensitive;
    }
    return obj;
  },

  create(base?: DeepPartial<ExactMatchConfig>): ExactMatchConfig {
    return ExactMatchConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExactMatchConfig>): ExactMatchConfig {
    const message = createBaseExactMatchConfig();
    message.caseSensitive = object.caseSensitive ?? false;
    return message;
  },
};

function createBaseSettings(): Settings {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    languageCode: "",
    conversationTtl: undefined,
    pubsubNotificationSettings: {},
    analysisConfig: undefined,
    redactionConfig: undefined,
    speechConfig: undefined,
  };
}

export const Settings: MessageFns<Settings> = {
  encode(message: Settings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    if (message.conversationTtl !== undefined) {
      Duration.encode(message.conversationTtl, writer.uint32(42).fork()).join();
    }
    Object.entries(message.pubsubNotificationSettings).forEach(([key, value]) => {
      Settings_PubsubNotificationSettingsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.analysisConfig !== undefined) {
      Settings_AnalysisConfig.encode(message.analysisConfig, writer.uint32(58).fork()).join();
    }
    if (message.redactionConfig !== undefined) {
      RedactionConfig.encode(message.redactionConfig, writer.uint32(82).fork()).join();
    }
    if (message.speechConfig !== undefined) {
      SpeechConfig.encode(message.speechConfig, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.conversationTtl = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = Settings_PubsubNotificationSettingsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.pubsubNotificationSettings[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.analysisConfig = Settings_AnalysisConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.redactionConfig = RedactionConfig.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.speechConfig = SpeechConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      conversationTtl: isSet(object.conversationTtl) ? Duration.fromJSON(object.conversationTtl) : undefined,
      pubsubNotificationSettings: isObject(object.pubsubNotificationSettings)
        ? Object.entries(object.pubsubNotificationSettings).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      analysisConfig: isSet(object.analysisConfig)
        ? Settings_AnalysisConfig.fromJSON(object.analysisConfig)
        : undefined,
      redactionConfig: isSet(object.redactionConfig) ? RedactionConfig.fromJSON(object.redactionConfig) : undefined,
      speechConfig: isSet(object.speechConfig) ? SpeechConfig.fromJSON(object.speechConfig) : undefined,
    };
  },

  toJSON(message: Settings): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.conversationTtl !== undefined) {
      obj.conversationTtl = Duration.toJSON(message.conversationTtl);
    }
    if (message.pubsubNotificationSettings) {
      const entries = Object.entries(message.pubsubNotificationSettings);
      if (entries.length > 0) {
        obj.pubsubNotificationSettings = {};
        entries.forEach(([k, v]) => {
          obj.pubsubNotificationSettings[k] = v;
        });
      }
    }
    if (message.analysisConfig !== undefined) {
      obj.analysisConfig = Settings_AnalysisConfig.toJSON(message.analysisConfig);
    }
    if (message.redactionConfig !== undefined) {
      obj.redactionConfig = RedactionConfig.toJSON(message.redactionConfig);
    }
    if (message.speechConfig !== undefined) {
      obj.speechConfig = SpeechConfig.toJSON(message.speechConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Settings>): Settings {
    return Settings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings>): Settings {
    const message = createBaseSettings();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.languageCode = object.languageCode ?? "";
    message.conversationTtl = (object.conversationTtl !== undefined && object.conversationTtl !== null)
      ? Duration.fromPartial(object.conversationTtl)
      : undefined;
    message.pubsubNotificationSettings = Object.entries(object.pubsubNotificationSettings ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.analysisConfig = (object.analysisConfig !== undefined && object.analysisConfig !== null)
      ? Settings_AnalysisConfig.fromPartial(object.analysisConfig)
      : undefined;
    message.redactionConfig = (object.redactionConfig !== undefined && object.redactionConfig !== null)
      ? RedactionConfig.fromPartial(object.redactionConfig)
      : undefined;
    message.speechConfig = (object.speechConfig !== undefined && object.speechConfig !== null)
      ? SpeechConfig.fromPartial(object.speechConfig)
      : undefined;
    return message;
  },
};

function createBaseSettings_AnalysisConfig(): Settings_AnalysisConfig {
  return {
    runtimeIntegrationAnalysisPercentage: 0,
    uploadConversationAnalysisPercentage: 0,
    annotatorSelector: undefined,
  };
}

export const Settings_AnalysisConfig: MessageFns<Settings_AnalysisConfig> = {
  encode(message: Settings_AnalysisConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runtimeIntegrationAnalysisPercentage !== 0) {
      writer.uint32(9).double(message.runtimeIntegrationAnalysisPercentage);
    }
    if (message.uploadConversationAnalysisPercentage !== 0) {
      writer.uint32(49).double(message.uploadConversationAnalysisPercentage);
    }
    if (message.annotatorSelector !== undefined) {
      AnnotatorSelector.encode(message.annotatorSelector, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings_AnalysisConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings_AnalysisConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.runtimeIntegrationAnalysisPercentage = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.uploadConversationAnalysisPercentage = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.annotatorSelector = AnnotatorSelector.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings_AnalysisConfig {
    return {
      runtimeIntegrationAnalysisPercentage: isSet(object.runtimeIntegrationAnalysisPercentage)
        ? globalThis.Number(object.runtimeIntegrationAnalysisPercentage)
        : 0,
      uploadConversationAnalysisPercentage: isSet(object.uploadConversationAnalysisPercentage)
        ? globalThis.Number(object.uploadConversationAnalysisPercentage)
        : 0,
      annotatorSelector: isSet(object.annotatorSelector)
        ? AnnotatorSelector.fromJSON(object.annotatorSelector)
        : undefined,
    };
  },

  toJSON(message: Settings_AnalysisConfig): unknown {
    const obj: any = {};
    if (message.runtimeIntegrationAnalysisPercentage !== 0) {
      obj.runtimeIntegrationAnalysisPercentage = message.runtimeIntegrationAnalysisPercentage;
    }
    if (message.uploadConversationAnalysisPercentage !== 0) {
      obj.uploadConversationAnalysisPercentage = message.uploadConversationAnalysisPercentage;
    }
    if (message.annotatorSelector !== undefined) {
      obj.annotatorSelector = AnnotatorSelector.toJSON(message.annotatorSelector);
    }
    return obj;
  },

  create(base?: DeepPartial<Settings_AnalysisConfig>): Settings_AnalysisConfig {
    return Settings_AnalysisConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings_AnalysisConfig>): Settings_AnalysisConfig {
    const message = createBaseSettings_AnalysisConfig();
    message.runtimeIntegrationAnalysisPercentage = object.runtimeIntegrationAnalysisPercentage ?? 0;
    message.uploadConversationAnalysisPercentage = object.uploadConversationAnalysisPercentage ?? 0;
    message.annotatorSelector = (object.annotatorSelector !== undefined && object.annotatorSelector !== null)
      ? AnnotatorSelector.fromPartial(object.annotatorSelector)
      : undefined;
    return message;
  },
};

function createBaseSettings_PubsubNotificationSettingsEntry(): Settings_PubsubNotificationSettingsEntry {
  return { key: "", value: "" };
}

export const Settings_PubsubNotificationSettingsEntry: MessageFns<Settings_PubsubNotificationSettingsEntry> = {
  encode(message: Settings_PubsubNotificationSettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings_PubsubNotificationSettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings_PubsubNotificationSettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings_PubsubNotificationSettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Settings_PubsubNotificationSettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Settings_PubsubNotificationSettingsEntry>): Settings_PubsubNotificationSettingsEntry {
    return Settings_PubsubNotificationSettingsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Settings_PubsubNotificationSettingsEntry>): Settings_PubsubNotificationSettingsEntry {
    const message = createBaseSettings_PubsubNotificationSettingsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRedactionConfig(): RedactionConfig {
  return { deidentifyTemplate: "", inspectTemplate: "" };
}

export const RedactionConfig: MessageFns<RedactionConfig> = {
  encode(message: RedactionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deidentifyTemplate !== "") {
      writer.uint32(10).string(message.deidentifyTemplate);
    }
    if (message.inspectTemplate !== "") {
      writer.uint32(18).string(message.inspectTemplate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedactionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedactionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deidentifyTemplate = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inspectTemplate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedactionConfig {
    return {
      deidentifyTemplate: isSet(object.deidentifyTemplate) ? globalThis.String(object.deidentifyTemplate) : "",
      inspectTemplate: isSet(object.inspectTemplate) ? globalThis.String(object.inspectTemplate) : "",
    };
  },

  toJSON(message: RedactionConfig): unknown {
    const obj: any = {};
    if (message.deidentifyTemplate !== "") {
      obj.deidentifyTemplate = message.deidentifyTemplate;
    }
    if (message.inspectTemplate !== "") {
      obj.inspectTemplate = message.inspectTemplate;
    }
    return obj;
  },

  create(base?: DeepPartial<RedactionConfig>): RedactionConfig {
    return RedactionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RedactionConfig>): RedactionConfig {
    const message = createBaseRedactionConfig();
    message.deidentifyTemplate = object.deidentifyTemplate ?? "";
    message.inspectTemplate = object.inspectTemplate ?? "";
    return message;
  },
};

function createBaseSpeechConfig(): SpeechConfig {
  return { speechRecognizer: "" };
}

export const SpeechConfig: MessageFns<SpeechConfig> = {
  encode(message: SpeechConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.speechRecognizer !== "") {
      writer.uint32(10).string(message.speechRecognizer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeechConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeechConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.speechRecognizer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeechConfig {
    return { speechRecognizer: isSet(object.speechRecognizer) ? globalThis.String(object.speechRecognizer) : "" };
  },

  toJSON(message: SpeechConfig): unknown {
    const obj: any = {};
    if (message.speechRecognizer !== "") {
      obj.speechRecognizer = message.speechRecognizer;
    }
    return obj;
  },

  create(base?: DeepPartial<SpeechConfig>): SpeechConfig {
    return SpeechConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpeechConfig>): SpeechConfig {
    const message = createBaseSpeechConfig();
    message.speechRecognizer = object.speechRecognizer ?? "";
    return message;
  },
};

function createBaseRuntimeAnnotation(): RuntimeAnnotation {
  return {
    articleSuggestion: undefined,
    faqAnswer: undefined,
    smartReply: undefined,
    smartComposeSuggestion: undefined,
    dialogflowInteraction: undefined,
    conversationSummarizationSuggestion: undefined,
    annotationId: "",
    createTime: undefined,
    startBoundary: undefined,
    endBoundary: undefined,
    answerFeedback: undefined,
  };
}

export const RuntimeAnnotation: MessageFns<RuntimeAnnotation> = {
  encode(message: RuntimeAnnotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.articleSuggestion !== undefined) {
      ArticleSuggestionData.encode(message.articleSuggestion, writer.uint32(50).fork()).join();
    }
    if (message.faqAnswer !== undefined) {
      FaqAnswerData.encode(message.faqAnswer, writer.uint32(58).fork()).join();
    }
    if (message.smartReply !== undefined) {
      SmartReplyData.encode(message.smartReply, writer.uint32(66).fork()).join();
    }
    if (message.smartComposeSuggestion !== undefined) {
      SmartComposeSuggestionData.encode(message.smartComposeSuggestion, writer.uint32(74).fork()).join();
    }
    if (message.dialogflowInteraction !== undefined) {
      DialogflowInteractionData.encode(message.dialogflowInteraction, writer.uint32(82).fork()).join();
    }
    if (message.conversationSummarizationSuggestion !== undefined) {
      ConversationSummarizationSuggestionData.encode(
        message.conversationSummarizationSuggestion,
        writer.uint32(98).fork(),
      ).join();
    }
    if (message.annotationId !== "") {
      writer.uint32(10).string(message.annotationId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.startBoundary !== undefined) {
      AnnotationBoundary.encode(message.startBoundary, writer.uint32(26).fork()).join();
    }
    if (message.endBoundary !== undefined) {
      AnnotationBoundary.encode(message.endBoundary, writer.uint32(34).fork()).join();
    }
    if (message.answerFeedback !== undefined) {
      AnswerFeedback.encode(message.answerFeedback, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeAnnotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6:
          if (tag !== 50) {
            break;
          }

          message.articleSuggestion = ArticleSuggestionData.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.faqAnswer = FaqAnswerData.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.smartReply = SmartReplyData.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.smartComposeSuggestion = SmartComposeSuggestionData.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.dialogflowInteraction = DialogflowInteractionData.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.conversationSummarizationSuggestion = ConversationSummarizationSuggestionData.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.annotationId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startBoundary = AnnotationBoundary.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endBoundary = AnnotationBoundary.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.answerFeedback = AnswerFeedback.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeAnnotation {
    return {
      articleSuggestion: isSet(object.articleSuggestion)
        ? ArticleSuggestionData.fromJSON(object.articleSuggestion)
        : undefined,
      faqAnswer: isSet(object.faqAnswer) ? FaqAnswerData.fromJSON(object.faqAnswer) : undefined,
      smartReply: isSet(object.smartReply) ? SmartReplyData.fromJSON(object.smartReply) : undefined,
      smartComposeSuggestion: isSet(object.smartComposeSuggestion)
        ? SmartComposeSuggestionData.fromJSON(object.smartComposeSuggestion)
        : undefined,
      dialogflowInteraction: isSet(object.dialogflowInteraction)
        ? DialogflowInteractionData.fromJSON(object.dialogflowInteraction)
        : undefined,
      conversationSummarizationSuggestion: isSet(object.conversationSummarizationSuggestion)
        ? ConversationSummarizationSuggestionData.fromJSON(object.conversationSummarizationSuggestion)
        : undefined,
      annotationId: isSet(object.annotationId) ? globalThis.String(object.annotationId) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      startBoundary: isSet(object.startBoundary) ? AnnotationBoundary.fromJSON(object.startBoundary) : undefined,
      endBoundary: isSet(object.endBoundary) ? AnnotationBoundary.fromJSON(object.endBoundary) : undefined,
      answerFeedback: isSet(object.answerFeedback) ? AnswerFeedback.fromJSON(object.answerFeedback) : undefined,
    };
  },

  toJSON(message: RuntimeAnnotation): unknown {
    const obj: any = {};
    if (message.articleSuggestion !== undefined) {
      obj.articleSuggestion = ArticleSuggestionData.toJSON(message.articleSuggestion);
    }
    if (message.faqAnswer !== undefined) {
      obj.faqAnswer = FaqAnswerData.toJSON(message.faqAnswer);
    }
    if (message.smartReply !== undefined) {
      obj.smartReply = SmartReplyData.toJSON(message.smartReply);
    }
    if (message.smartComposeSuggestion !== undefined) {
      obj.smartComposeSuggestion = SmartComposeSuggestionData.toJSON(message.smartComposeSuggestion);
    }
    if (message.dialogflowInteraction !== undefined) {
      obj.dialogflowInteraction = DialogflowInteractionData.toJSON(message.dialogflowInteraction);
    }
    if (message.conversationSummarizationSuggestion !== undefined) {
      obj.conversationSummarizationSuggestion = ConversationSummarizationSuggestionData.toJSON(
        message.conversationSummarizationSuggestion,
      );
    }
    if (message.annotationId !== "") {
      obj.annotationId = message.annotationId;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.startBoundary !== undefined) {
      obj.startBoundary = AnnotationBoundary.toJSON(message.startBoundary);
    }
    if (message.endBoundary !== undefined) {
      obj.endBoundary = AnnotationBoundary.toJSON(message.endBoundary);
    }
    if (message.answerFeedback !== undefined) {
      obj.answerFeedback = AnswerFeedback.toJSON(message.answerFeedback);
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeAnnotation>): RuntimeAnnotation {
    return RuntimeAnnotation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeAnnotation>): RuntimeAnnotation {
    const message = createBaseRuntimeAnnotation();
    message.articleSuggestion = (object.articleSuggestion !== undefined && object.articleSuggestion !== null)
      ? ArticleSuggestionData.fromPartial(object.articleSuggestion)
      : undefined;
    message.faqAnswer = (object.faqAnswer !== undefined && object.faqAnswer !== null)
      ? FaqAnswerData.fromPartial(object.faqAnswer)
      : undefined;
    message.smartReply = (object.smartReply !== undefined && object.smartReply !== null)
      ? SmartReplyData.fromPartial(object.smartReply)
      : undefined;
    message.smartComposeSuggestion =
      (object.smartComposeSuggestion !== undefined && object.smartComposeSuggestion !== null)
        ? SmartComposeSuggestionData.fromPartial(object.smartComposeSuggestion)
        : undefined;
    message.dialogflowInteraction =
      (object.dialogflowInteraction !== undefined && object.dialogflowInteraction !== null)
        ? DialogflowInteractionData.fromPartial(object.dialogflowInteraction)
        : undefined;
    message.conversationSummarizationSuggestion =
      (object.conversationSummarizationSuggestion !== undefined && object.conversationSummarizationSuggestion !== null)
        ? ConversationSummarizationSuggestionData.fromPartial(object.conversationSummarizationSuggestion)
        : undefined;
    message.annotationId = object.annotationId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.startBoundary = (object.startBoundary !== undefined && object.startBoundary !== null)
      ? AnnotationBoundary.fromPartial(object.startBoundary)
      : undefined;
    message.endBoundary = (object.endBoundary !== undefined && object.endBoundary !== null)
      ? AnnotationBoundary.fromPartial(object.endBoundary)
      : undefined;
    message.answerFeedback = (object.answerFeedback !== undefined && object.answerFeedback !== null)
      ? AnswerFeedback.fromPartial(object.answerFeedback)
      : undefined;
    return message;
  },
};

function createBaseAnswerFeedback(): AnswerFeedback {
  return { correctnessLevel: 0, clicked: false, displayed: false };
}

export const AnswerFeedback: MessageFns<AnswerFeedback> = {
  encode(message: AnswerFeedback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.correctnessLevel !== 0) {
      writer.uint32(8).int32(message.correctnessLevel);
    }
    if (message.clicked !== false) {
      writer.uint32(16).bool(message.clicked);
    }
    if (message.displayed !== false) {
      writer.uint32(24).bool(message.displayed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnswerFeedback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnswerFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.correctnessLevel = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clicked = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.displayed = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnswerFeedback {
    return {
      correctnessLevel: isSet(object.correctnessLevel)
        ? answerFeedback_CorrectnessLevelFromJSON(object.correctnessLevel)
        : 0,
      clicked: isSet(object.clicked) ? globalThis.Boolean(object.clicked) : false,
      displayed: isSet(object.displayed) ? globalThis.Boolean(object.displayed) : false,
    };
  },

  toJSON(message: AnswerFeedback): unknown {
    const obj: any = {};
    if (message.correctnessLevel !== 0) {
      obj.correctnessLevel = answerFeedback_CorrectnessLevelToJSON(message.correctnessLevel);
    }
    if (message.clicked !== false) {
      obj.clicked = message.clicked;
    }
    if (message.displayed !== false) {
      obj.displayed = message.displayed;
    }
    return obj;
  },

  create(base?: DeepPartial<AnswerFeedback>): AnswerFeedback {
    return AnswerFeedback.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnswerFeedback>): AnswerFeedback {
    const message = createBaseAnswerFeedback();
    message.correctnessLevel = object.correctnessLevel ?? 0;
    message.clicked = object.clicked ?? false;
    message.displayed = object.displayed ?? false;
    return message;
  },
};

function createBaseArticleSuggestionData(): ArticleSuggestionData {
  return { title: "", uri: "", confidenceScore: 0, metadata: {}, queryRecord: "", source: "" };
}

export const ArticleSuggestionData: MessageFns<ArticleSuggestionData> = {
  encode(message: ArticleSuggestionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.uri !== "") {
      writer.uint32(18).string(message.uri);
    }
    if (message.confidenceScore !== 0) {
      writer.uint32(29).float(message.confidenceScore);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ArticleSuggestionData_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.queryRecord !== "") {
      writer.uint32(42).string(message.queryRecord);
    }
    if (message.source !== "") {
      writer.uint32(50).string(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArticleSuggestionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArticleSuggestionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.confidenceScore = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = ArticleSuggestionData_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.queryRecord = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.source = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArticleSuggestionData {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      confidenceScore: isSet(object.confidenceScore) ? globalThis.Number(object.confidenceScore) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      queryRecord: isSet(object.queryRecord) ? globalThis.String(object.queryRecord) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
    };
  },

  toJSON(message: ArticleSuggestionData): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.confidenceScore !== 0) {
      obj.confidenceScore = message.confidenceScore;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.queryRecord !== "") {
      obj.queryRecord = message.queryRecord;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    return obj;
  },

  create(base?: DeepPartial<ArticleSuggestionData>): ArticleSuggestionData {
    return ArticleSuggestionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ArticleSuggestionData>): ArticleSuggestionData {
    const message = createBaseArticleSuggestionData();
    message.title = object.title ?? "";
    message.uri = object.uri ?? "";
    message.confidenceScore = object.confidenceScore ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.queryRecord = object.queryRecord ?? "";
    message.source = object.source ?? "";
    return message;
  },
};

function createBaseArticleSuggestionData_MetadataEntry(): ArticleSuggestionData_MetadataEntry {
  return { key: "", value: "" };
}

export const ArticleSuggestionData_MetadataEntry: MessageFns<ArticleSuggestionData_MetadataEntry> = {
  encode(message: ArticleSuggestionData_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ArticleSuggestionData_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseArticleSuggestionData_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ArticleSuggestionData_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ArticleSuggestionData_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ArticleSuggestionData_MetadataEntry>): ArticleSuggestionData_MetadataEntry {
    return ArticleSuggestionData_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ArticleSuggestionData_MetadataEntry>): ArticleSuggestionData_MetadataEntry {
    const message = createBaseArticleSuggestionData_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFaqAnswerData(): FaqAnswerData {
  return { answer: "", confidenceScore: 0, question: "", metadata: {}, queryRecord: "", source: "" };
}

export const FaqAnswerData: MessageFns<FaqAnswerData> = {
  encode(message: FaqAnswerData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== "") {
      writer.uint32(10).string(message.answer);
    }
    if (message.confidenceScore !== 0) {
      writer.uint32(21).float(message.confidenceScore);
    }
    if (message.question !== "") {
      writer.uint32(26).string(message.question);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      FaqAnswerData_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.queryRecord !== "") {
      writer.uint32(42).string(message.queryRecord);
    }
    if (message.source !== "") {
      writer.uint32(50).string(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FaqAnswerData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFaqAnswerData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.answer = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidenceScore = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.question = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = FaqAnswerData_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.queryRecord = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.source = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FaqAnswerData {
    return {
      answer: isSet(object.answer) ? globalThis.String(object.answer) : "",
      confidenceScore: isSet(object.confidenceScore) ? globalThis.Number(object.confidenceScore) : 0,
      question: isSet(object.question) ? globalThis.String(object.question) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      queryRecord: isSet(object.queryRecord) ? globalThis.String(object.queryRecord) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
    };
  },

  toJSON(message: FaqAnswerData): unknown {
    const obj: any = {};
    if (message.answer !== "") {
      obj.answer = message.answer;
    }
    if (message.confidenceScore !== 0) {
      obj.confidenceScore = message.confidenceScore;
    }
    if (message.question !== "") {
      obj.question = message.question;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.queryRecord !== "") {
      obj.queryRecord = message.queryRecord;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    return obj;
  },

  create(base?: DeepPartial<FaqAnswerData>): FaqAnswerData {
    return FaqAnswerData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FaqAnswerData>): FaqAnswerData {
    const message = createBaseFaqAnswerData();
    message.answer = object.answer ?? "";
    message.confidenceScore = object.confidenceScore ?? 0;
    message.question = object.question ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.queryRecord = object.queryRecord ?? "";
    message.source = object.source ?? "";
    return message;
  },
};

function createBaseFaqAnswerData_MetadataEntry(): FaqAnswerData_MetadataEntry {
  return { key: "", value: "" };
}

export const FaqAnswerData_MetadataEntry: MessageFns<FaqAnswerData_MetadataEntry> = {
  encode(message: FaqAnswerData_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FaqAnswerData_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFaqAnswerData_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FaqAnswerData_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: FaqAnswerData_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<FaqAnswerData_MetadataEntry>): FaqAnswerData_MetadataEntry {
    return FaqAnswerData_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FaqAnswerData_MetadataEntry>): FaqAnswerData_MetadataEntry {
    const message = createBaseFaqAnswerData_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSmartReplyData(): SmartReplyData {
  return { reply: "", confidenceScore: 0, metadata: {}, queryRecord: "" };
}

export const SmartReplyData: MessageFns<SmartReplyData> = {
  encode(message: SmartReplyData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reply !== "") {
      writer.uint32(10).string(message.reply);
    }
    if (message.confidenceScore !== 0) {
      writer.uint32(17).double(message.confidenceScore);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SmartReplyData_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.queryRecord !== "") {
      writer.uint32(34).string(message.queryRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmartReplyData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartReplyData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reply = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.confidenceScore = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = SmartReplyData_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.queryRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmartReplyData {
    return {
      reply: isSet(object.reply) ? globalThis.String(object.reply) : "",
      confidenceScore: isSet(object.confidenceScore) ? globalThis.Number(object.confidenceScore) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      queryRecord: isSet(object.queryRecord) ? globalThis.String(object.queryRecord) : "",
    };
  },

  toJSON(message: SmartReplyData): unknown {
    const obj: any = {};
    if (message.reply !== "") {
      obj.reply = message.reply;
    }
    if (message.confidenceScore !== 0) {
      obj.confidenceScore = message.confidenceScore;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.queryRecord !== "") {
      obj.queryRecord = message.queryRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<SmartReplyData>): SmartReplyData {
    return SmartReplyData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SmartReplyData>): SmartReplyData {
    const message = createBaseSmartReplyData();
    message.reply = object.reply ?? "";
    message.confidenceScore = object.confidenceScore ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.queryRecord = object.queryRecord ?? "";
    return message;
  },
};

function createBaseSmartReplyData_MetadataEntry(): SmartReplyData_MetadataEntry {
  return { key: "", value: "" };
}

export const SmartReplyData_MetadataEntry: MessageFns<SmartReplyData_MetadataEntry> = {
  encode(message: SmartReplyData_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmartReplyData_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartReplyData_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmartReplyData_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SmartReplyData_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SmartReplyData_MetadataEntry>): SmartReplyData_MetadataEntry {
    return SmartReplyData_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SmartReplyData_MetadataEntry>): SmartReplyData_MetadataEntry {
    const message = createBaseSmartReplyData_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSmartComposeSuggestionData(): SmartComposeSuggestionData {
  return { suggestion: "", confidenceScore: 0, metadata: {}, queryRecord: "" };
}

export const SmartComposeSuggestionData: MessageFns<SmartComposeSuggestionData> = {
  encode(message: SmartComposeSuggestionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.suggestion !== "") {
      writer.uint32(10).string(message.suggestion);
    }
    if (message.confidenceScore !== 0) {
      writer.uint32(17).double(message.confidenceScore);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SmartComposeSuggestionData_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.queryRecord !== "") {
      writer.uint32(34).string(message.queryRecord);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmartComposeSuggestionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartComposeSuggestionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.suggestion = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.confidenceScore = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = SmartComposeSuggestionData_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.queryRecord = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmartComposeSuggestionData {
    return {
      suggestion: isSet(object.suggestion) ? globalThis.String(object.suggestion) : "",
      confidenceScore: isSet(object.confidenceScore) ? globalThis.Number(object.confidenceScore) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      queryRecord: isSet(object.queryRecord) ? globalThis.String(object.queryRecord) : "",
    };
  },

  toJSON(message: SmartComposeSuggestionData): unknown {
    const obj: any = {};
    if (message.suggestion !== "") {
      obj.suggestion = message.suggestion;
    }
    if (message.confidenceScore !== 0) {
      obj.confidenceScore = message.confidenceScore;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.queryRecord !== "") {
      obj.queryRecord = message.queryRecord;
    }
    return obj;
  },

  create(base?: DeepPartial<SmartComposeSuggestionData>): SmartComposeSuggestionData {
    return SmartComposeSuggestionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SmartComposeSuggestionData>): SmartComposeSuggestionData {
    const message = createBaseSmartComposeSuggestionData();
    message.suggestion = object.suggestion ?? "";
    message.confidenceScore = object.confidenceScore ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.queryRecord = object.queryRecord ?? "";
    return message;
  },
};

function createBaseSmartComposeSuggestionData_MetadataEntry(): SmartComposeSuggestionData_MetadataEntry {
  return { key: "", value: "" };
}

export const SmartComposeSuggestionData_MetadataEntry: MessageFns<SmartComposeSuggestionData_MetadataEntry> = {
  encode(message: SmartComposeSuggestionData_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmartComposeSuggestionData_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartComposeSuggestionData_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmartComposeSuggestionData_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SmartComposeSuggestionData_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SmartComposeSuggestionData_MetadataEntry>): SmartComposeSuggestionData_MetadataEntry {
    return SmartComposeSuggestionData_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SmartComposeSuggestionData_MetadataEntry>): SmartComposeSuggestionData_MetadataEntry {
    const message = createBaseSmartComposeSuggestionData_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDialogflowInteractionData(): DialogflowInteractionData {
  return { dialogflowIntentId: "", confidence: 0 };
}

export const DialogflowInteractionData: MessageFns<DialogflowInteractionData> = {
  encode(message: DialogflowInteractionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dialogflowIntentId !== "") {
      writer.uint32(10).string(message.dialogflowIntentId);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogflowInteractionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogflowInteractionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dialogflowIntentId = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogflowInteractionData {
    return {
      dialogflowIntentId: isSet(object.dialogflowIntentId) ? globalThis.String(object.dialogflowIntentId) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: DialogflowInteractionData): unknown {
    const obj: any = {};
    if (message.dialogflowIntentId !== "") {
      obj.dialogflowIntentId = message.dialogflowIntentId;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<DialogflowInteractionData>): DialogflowInteractionData {
    return DialogflowInteractionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DialogflowInteractionData>): DialogflowInteractionData {
    const message = createBaseDialogflowInteractionData();
    message.dialogflowIntentId = object.dialogflowIntentId ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseConversationSummarizationSuggestionData(): ConversationSummarizationSuggestionData {
  return { text: "", textSections: {}, confidence: 0, metadata: {}, answerRecord: "", conversationModel: "" };
}

export const ConversationSummarizationSuggestionData: MessageFns<ConversationSummarizationSuggestionData> = {
  encode(message: ConversationSummarizationSuggestionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    Object.entries(message.textSections).forEach(([key, value]) => {
      ConversationSummarizationSuggestionData_TextSectionsEntry.encode(
        { key: key as any, value },
        writer.uint32(42).fork(),
      ).join();
    });
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ConversationSummarizationSuggestionData_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork())
        .join();
    });
    if (message.answerRecord !== "") {
      writer.uint32(34).string(message.answerRecord);
    }
    if (message.conversationModel !== "") {
      writer.uint32(50).string(message.conversationModel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationSummarizationSuggestionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationSummarizationSuggestionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = ConversationSummarizationSuggestionData_TextSectionsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.textSections[entry5.key] = entry5.value;
          }
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ConversationSummarizationSuggestionData_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.answerRecord = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.conversationModel = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationSummarizationSuggestionData {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      textSections: isObject(object.textSections)
        ? Object.entries(object.textSections).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      answerRecord: isSet(object.answerRecord) ? globalThis.String(object.answerRecord) : "",
      conversationModel: isSet(object.conversationModel) ? globalThis.String(object.conversationModel) : "",
    };
  },

  toJSON(message: ConversationSummarizationSuggestionData): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.textSections) {
      const entries = Object.entries(message.textSections);
      if (entries.length > 0) {
        obj.textSections = {};
        entries.forEach(([k, v]) => {
          obj.textSections[k] = v;
        });
      }
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.answerRecord !== "") {
      obj.answerRecord = message.answerRecord;
    }
    if (message.conversationModel !== "") {
      obj.conversationModel = message.conversationModel;
    }
    return obj;
  },

  create(base?: DeepPartial<ConversationSummarizationSuggestionData>): ConversationSummarizationSuggestionData {
    return ConversationSummarizationSuggestionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversationSummarizationSuggestionData>): ConversationSummarizationSuggestionData {
    const message = createBaseConversationSummarizationSuggestionData();
    message.text = object.text ?? "";
    message.textSections = Object.entries(object.textSections ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.confidence = object.confidence ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.answerRecord = object.answerRecord ?? "";
    message.conversationModel = object.conversationModel ?? "";
    return message;
  },
};

function createBaseConversationSummarizationSuggestionData_TextSectionsEntry(): ConversationSummarizationSuggestionData_TextSectionsEntry {
  return { key: "", value: "" };
}

export const ConversationSummarizationSuggestionData_TextSectionsEntry: MessageFns<
  ConversationSummarizationSuggestionData_TextSectionsEntry
> = {
  encode(
    message: ConversationSummarizationSuggestionData_TextSectionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationSummarizationSuggestionData_TextSectionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationSummarizationSuggestionData_TextSectionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationSummarizationSuggestionData_TextSectionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConversationSummarizationSuggestionData_TextSectionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ConversationSummarizationSuggestionData_TextSectionsEntry>,
  ): ConversationSummarizationSuggestionData_TextSectionsEntry {
    return ConversationSummarizationSuggestionData_TextSectionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ConversationSummarizationSuggestionData_TextSectionsEntry>,
  ): ConversationSummarizationSuggestionData_TextSectionsEntry {
    const message = createBaseConversationSummarizationSuggestionData_TextSectionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConversationSummarizationSuggestionData_MetadataEntry(): ConversationSummarizationSuggestionData_MetadataEntry {
  return { key: "", value: "" };
}

export const ConversationSummarizationSuggestionData_MetadataEntry: MessageFns<
  ConversationSummarizationSuggestionData_MetadataEntry
> = {
  encode(
    message: ConversationSummarizationSuggestionData_MetadataEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationSummarizationSuggestionData_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationSummarizationSuggestionData_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationSummarizationSuggestionData_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConversationSummarizationSuggestionData_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ConversationSummarizationSuggestionData_MetadataEntry>,
  ): ConversationSummarizationSuggestionData_MetadataEntry {
    return ConversationSummarizationSuggestionData_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ConversationSummarizationSuggestionData_MetadataEntry>,
  ): ConversationSummarizationSuggestionData_MetadataEntry {
    const message = createBaseConversationSummarizationSuggestionData_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConversationParticipant(): ConversationParticipant {
  return {
    dialogflowParticipantName: undefined,
    userId: undefined,
    dialogflowParticipant: "",
    obfuscatedExternalUserId: "",
    role: 0,
  };
}

export const ConversationParticipant: MessageFns<ConversationParticipant> = {
  encode(message: ConversationParticipant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dialogflowParticipantName !== undefined) {
      writer.uint32(42).string(message.dialogflowParticipantName);
    }
    if (message.userId !== undefined) {
      writer.uint32(50).string(message.userId);
    }
    if (message.dialogflowParticipant !== "") {
      writer.uint32(10).string(message.dialogflowParticipant);
    }
    if (message.obfuscatedExternalUserId !== "") {
      writer.uint32(26).string(message.obfuscatedExternalUserId);
    }
    if (message.role !== 0) {
      writer.uint32(16).int32(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConversationParticipant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConversationParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dialogflowParticipantName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dialogflowParticipant = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.obfuscatedExternalUserId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConversationParticipant {
    return {
      dialogflowParticipantName: isSet(object.dialogflowParticipantName)
        ? globalThis.String(object.dialogflowParticipantName)
        : undefined,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : undefined,
      dialogflowParticipant: isSet(object.dialogflowParticipant) ? globalThis.String(object.dialogflowParticipant) : "",
      obfuscatedExternalUserId: isSet(object.obfuscatedExternalUserId)
        ? globalThis.String(object.obfuscatedExternalUserId)
        : "",
      role: isSet(object.role) ? conversationParticipant_RoleFromJSON(object.role) : 0,
    };
  },

  toJSON(message: ConversationParticipant): unknown {
    const obj: any = {};
    if (message.dialogflowParticipantName !== undefined) {
      obj.dialogflowParticipantName = message.dialogflowParticipantName;
    }
    if (message.userId !== undefined) {
      obj.userId = message.userId;
    }
    if (message.dialogflowParticipant !== "") {
      obj.dialogflowParticipant = message.dialogflowParticipant;
    }
    if (message.obfuscatedExternalUserId !== "") {
      obj.obfuscatedExternalUserId = message.obfuscatedExternalUserId;
    }
    if (message.role !== 0) {
      obj.role = conversationParticipant_RoleToJSON(message.role);
    }
    return obj;
  },

  create(base?: DeepPartial<ConversationParticipant>): ConversationParticipant {
    return ConversationParticipant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConversationParticipant>): ConversationParticipant {
    const message = createBaseConversationParticipant();
    message.dialogflowParticipantName = object.dialogflowParticipantName ?? undefined;
    message.userId = object.userId ?? undefined;
    message.dialogflowParticipant = object.dialogflowParticipant ?? "";
    message.obfuscatedExternalUserId = object.obfuscatedExternalUserId ?? "";
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseView(): View {
  return { name: "", displayName: "", createTime: undefined, updateTime: undefined, value: "" };
}

export const View: MessageFns<View> = {
  encode(message: View, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.value !== "") {
      writer.uint32(42).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): View {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): View {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: View): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<View>): View {
    return View.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<View>): View {
    const message = createBaseView();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAnnotatorSelector(): AnnotatorSelector {
  return {
    runInterruptionAnnotator: false,
    runSilenceAnnotator: false,
    runPhraseMatcherAnnotator: false,
    phraseMatchers: [],
    runSentimentAnnotator: false,
    runEntityAnnotator: false,
    runIntentAnnotator: false,
    runIssueModelAnnotator: false,
    issueModels: [],
    runSummarizationAnnotator: false,
    summarizationConfig: undefined,
  };
}

export const AnnotatorSelector: MessageFns<AnnotatorSelector> = {
  encode(message: AnnotatorSelector, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runInterruptionAnnotator !== false) {
      writer.uint32(8).bool(message.runInterruptionAnnotator);
    }
    if (message.runSilenceAnnotator !== false) {
      writer.uint32(16).bool(message.runSilenceAnnotator);
    }
    if (message.runPhraseMatcherAnnotator !== false) {
      writer.uint32(24).bool(message.runPhraseMatcherAnnotator);
    }
    for (const v of message.phraseMatchers) {
      writer.uint32(34).string(v!);
    }
    if (message.runSentimentAnnotator !== false) {
      writer.uint32(40).bool(message.runSentimentAnnotator);
    }
    if (message.runEntityAnnotator !== false) {
      writer.uint32(48).bool(message.runEntityAnnotator);
    }
    if (message.runIntentAnnotator !== false) {
      writer.uint32(56).bool(message.runIntentAnnotator);
    }
    if (message.runIssueModelAnnotator !== false) {
      writer.uint32(64).bool(message.runIssueModelAnnotator);
    }
    for (const v of message.issueModels) {
      writer.uint32(82).string(v!);
    }
    if (message.runSummarizationAnnotator !== false) {
      writer.uint32(72).bool(message.runSummarizationAnnotator);
    }
    if (message.summarizationConfig !== undefined) {
      AnnotatorSelector_SummarizationConfig.encode(message.summarizationConfig, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotatorSelector {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotatorSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.runInterruptionAnnotator = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.runSilenceAnnotator = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.runPhraseMatcherAnnotator = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phraseMatchers.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.runSentimentAnnotator = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.runEntityAnnotator = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.runIntentAnnotator = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.runIssueModelAnnotator = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.issueModels.push(reader.string());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.runSummarizationAnnotator = reader.bool();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.summarizationConfig = AnnotatorSelector_SummarizationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotatorSelector {
    return {
      runInterruptionAnnotator: isSet(object.runInterruptionAnnotator)
        ? globalThis.Boolean(object.runInterruptionAnnotator)
        : false,
      runSilenceAnnotator: isSet(object.runSilenceAnnotator) ? globalThis.Boolean(object.runSilenceAnnotator) : false,
      runPhraseMatcherAnnotator: isSet(object.runPhraseMatcherAnnotator)
        ? globalThis.Boolean(object.runPhraseMatcherAnnotator)
        : false,
      phraseMatchers: globalThis.Array.isArray(object?.phraseMatchers)
        ? object.phraseMatchers.map((e: any) => globalThis.String(e))
        : [],
      runSentimentAnnotator: isSet(object.runSentimentAnnotator)
        ? globalThis.Boolean(object.runSentimentAnnotator)
        : false,
      runEntityAnnotator: isSet(object.runEntityAnnotator) ? globalThis.Boolean(object.runEntityAnnotator) : false,
      runIntentAnnotator: isSet(object.runIntentAnnotator) ? globalThis.Boolean(object.runIntentAnnotator) : false,
      runIssueModelAnnotator: isSet(object.runIssueModelAnnotator)
        ? globalThis.Boolean(object.runIssueModelAnnotator)
        : false,
      issueModels: globalThis.Array.isArray(object?.issueModels)
        ? object.issueModels.map((e: any) => globalThis.String(e))
        : [],
      runSummarizationAnnotator: isSet(object.runSummarizationAnnotator)
        ? globalThis.Boolean(object.runSummarizationAnnotator)
        : false,
      summarizationConfig: isSet(object.summarizationConfig)
        ? AnnotatorSelector_SummarizationConfig.fromJSON(object.summarizationConfig)
        : undefined,
    };
  },

  toJSON(message: AnnotatorSelector): unknown {
    const obj: any = {};
    if (message.runInterruptionAnnotator !== false) {
      obj.runInterruptionAnnotator = message.runInterruptionAnnotator;
    }
    if (message.runSilenceAnnotator !== false) {
      obj.runSilenceAnnotator = message.runSilenceAnnotator;
    }
    if (message.runPhraseMatcherAnnotator !== false) {
      obj.runPhraseMatcherAnnotator = message.runPhraseMatcherAnnotator;
    }
    if (message.phraseMatchers?.length) {
      obj.phraseMatchers = message.phraseMatchers;
    }
    if (message.runSentimentAnnotator !== false) {
      obj.runSentimentAnnotator = message.runSentimentAnnotator;
    }
    if (message.runEntityAnnotator !== false) {
      obj.runEntityAnnotator = message.runEntityAnnotator;
    }
    if (message.runIntentAnnotator !== false) {
      obj.runIntentAnnotator = message.runIntentAnnotator;
    }
    if (message.runIssueModelAnnotator !== false) {
      obj.runIssueModelAnnotator = message.runIssueModelAnnotator;
    }
    if (message.issueModels?.length) {
      obj.issueModels = message.issueModels;
    }
    if (message.runSummarizationAnnotator !== false) {
      obj.runSummarizationAnnotator = message.runSummarizationAnnotator;
    }
    if (message.summarizationConfig !== undefined) {
      obj.summarizationConfig = AnnotatorSelector_SummarizationConfig.toJSON(message.summarizationConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotatorSelector>): AnnotatorSelector {
    return AnnotatorSelector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotatorSelector>): AnnotatorSelector {
    const message = createBaseAnnotatorSelector();
    message.runInterruptionAnnotator = object.runInterruptionAnnotator ?? false;
    message.runSilenceAnnotator = object.runSilenceAnnotator ?? false;
    message.runPhraseMatcherAnnotator = object.runPhraseMatcherAnnotator ?? false;
    message.phraseMatchers = object.phraseMatchers?.map((e) => e) || [];
    message.runSentimentAnnotator = object.runSentimentAnnotator ?? false;
    message.runEntityAnnotator = object.runEntityAnnotator ?? false;
    message.runIntentAnnotator = object.runIntentAnnotator ?? false;
    message.runIssueModelAnnotator = object.runIssueModelAnnotator ?? false;
    message.issueModels = object.issueModels?.map((e) => e) || [];
    message.runSummarizationAnnotator = object.runSummarizationAnnotator ?? false;
    message.summarizationConfig = (object.summarizationConfig !== undefined && object.summarizationConfig !== null)
      ? AnnotatorSelector_SummarizationConfig.fromPartial(object.summarizationConfig)
      : undefined;
    return message;
  },
};

function createBaseAnnotatorSelector_SummarizationConfig(): AnnotatorSelector_SummarizationConfig {
  return { conversationProfile: undefined, summarizationModel: undefined };
}

export const AnnotatorSelector_SummarizationConfig: MessageFns<AnnotatorSelector_SummarizationConfig> = {
  encode(message: AnnotatorSelector_SummarizationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.conversationProfile !== undefined) {
      writer.uint32(10).string(message.conversationProfile);
    }
    if (message.summarizationModel !== undefined) {
      writer.uint32(16).int32(message.summarizationModel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotatorSelector_SummarizationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotatorSelector_SummarizationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conversationProfile = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.summarizationModel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotatorSelector_SummarizationConfig {
    return {
      conversationProfile: isSet(object.conversationProfile)
        ? globalThis.String(object.conversationProfile)
        : undefined,
      summarizationModel: isSet(object.summarizationModel)
        ? annotatorSelector_SummarizationConfig_SummarizationModelFromJSON(object.summarizationModel)
        : undefined,
    };
  },

  toJSON(message: AnnotatorSelector_SummarizationConfig): unknown {
    const obj: any = {};
    if (message.conversationProfile !== undefined) {
      obj.conversationProfile = message.conversationProfile;
    }
    if (message.summarizationModel !== undefined) {
      obj.summarizationModel = annotatorSelector_SummarizationConfig_SummarizationModelToJSON(
        message.summarizationModel,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AnnotatorSelector_SummarizationConfig>): AnnotatorSelector_SummarizationConfig {
    return AnnotatorSelector_SummarizationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AnnotatorSelector_SummarizationConfig>): AnnotatorSelector_SummarizationConfig {
    const message = createBaseAnnotatorSelector_SummarizationConfig();
    message.conversationProfile = object.conversationProfile ?? undefined;
    message.summarizationModel = object.summarizationModel ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
