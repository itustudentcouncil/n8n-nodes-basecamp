// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/identitytoolkit/v2/mfa_info.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.identitytoolkit.v2";

/** The information required to auto-retrieve an SMS. */
export interface AutoRetrievalInfo {
  /**
   * The Android app's signature hash for Google Play Service's
   * SMS Retriever API.
   */
  appSignatureHash: string;
}

/** App Verification info for a StartMfa request. */
export interface StartMfaPhoneRequestInfo {
  /** Required for enrollment. Phone number to be enrolled as MFA. */
  phoneNumber: string;
  /** iOS only. Receipt of successful app token validation with APNS. */
  iosReceipt: string;
  /** iOS only. Secret delivered to iOS app via APNS. */
  iosSecret: string;
  /** Web only. Recaptcha solution. */
  recaptchaToken: string;
  /**
   * Android only. Used by Google Play Services to identify the app for
   * auto-retrieval.
   */
  autoRetrievalInfo:
    | AutoRetrievalInfo
    | undefined;
  /**
   * Android only. Used to assert application identity in place of a
   * recaptcha token. A SafetyNet Token can be generated via the
   * [SafetyNet Android Attestation
   * API](https://developer.android.com/training/safetynet/attestation.html),
   * with the Base64 encoding of the `phone_number` field as the nonce.
   */
  safetyNetToken: string;
}

/** Phone Verification info for a StartMfa response. */
export interface StartMfaPhoneResponseInfo {
  /** An opaque string that represents the enrollment session. */
  sessionInfo: string;
}

/** Phone Verification info for a FinalizeMfa request. */
export interface FinalizeMfaPhoneRequestInfo {
  /** An opaque string that represents the enrollment session. */
  sessionInfo: string;
  /** User-entered verification code. */
  code: string;
  /** Android only. Uses for "instant" phone number verification though GmsCore. */
  androidVerificationProof: string;
  /** Required if Android verification proof is presented. */
  phoneNumber: string;
}

/** Phone Verification info for a FinalizeMfa response. */
export interface FinalizeMfaPhoneResponseInfo {
  /** Android only. Long-lived replacement for valid code tied to android device. */
  androidVerificationProof: string;
  /** Android only. Expiration time of verification proof in seconds. */
  androidVerificationProofExpireTime:
    | Date
    | undefined;
  /** For Android verification proof. */
  phoneNumber: string;
}

function createBaseAutoRetrievalInfo(): AutoRetrievalInfo {
  return { appSignatureHash: "" };
}

export const AutoRetrievalInfo: MessageFns<AutoRetrievalInfo> = {
  encode(message: AutoRetrievalInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appSignatureHash !== "") {
      writer.uint32(10).string(message.appSignatureHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AutoRetrievalInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAutoRetrievalInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appSignatureHash = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AutoRetrievalInfo {
    return { appSignatureHash: isSet(object.appSignatureHash) ? globalThis.String(object.appSignatureHash) : "" };
  },

  toJSON(message: AutoRetrievalInfo): unknown {
    const obj: any = {};
    if (message.appSignatureHash !== "") {
      obj.appSignatureHash = message.appSignatureHash;
    }
    return obj;
  },

  create(base?: DeepPartial<AutoRetrievalInfo>): AutoRetrievalInfo {
    return AutoRetrievalInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AutoRetrievalInfo>): AutoRetrievalInfo {
    const message = createBaseAutoRetrievalInfo();
    message.appSignatureHash = object.appSignatureHash ?? "";
    return message;
  },
};

function createBaseStartMfaPhoneRequestInfo(): StartMfaPhoneRequestInfo {
  return {
    phoneNumber: "",
    iosReceipt: "",
    iosSecret: "",
    recaptchaToken: "",
    autoRetrievalInfo: undefined,
    safetyNetToken: "",
  };
}

export const StartMfaPhoneRequestInfo: MessageFns<StartMfaPhoneRequestInfo> = {
  encode(message: StartMfaPhoneRequestInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.phoneNumber !== "") {
      writer.uint32(10).string(message.phoneNumber);
    }
    if (message.iosReceipt !== "") {
      writer.uint32(18).string(message.iosReceipt);
    }
    if (message.iosSecret !== "") {
      writer.uint32(26).string(message.iosSecret);
    }
    if (message.recaptchaToken !== "") {
      writer.uint32(34).string(message.recaptchaToken);
    }
    if (message.autoRetrievalInfo !== undefined) {
      AutoRetrievalInfo.encode(message.autoRetrievalInfo, writer.uint32(42).fork()).join();
    }
    if (message.safetyNetToken !== "") {
      writer.uint32(50).string(message.safetyNetToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartMfaPhoneRequestInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartMfaPhoneRequestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.iosReceipt = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.iosSecret = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.recaptchaToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.autoRetrievalInfo = AutoRetrievalInfo.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.safetyNetToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartMfaPhoneRequestInfo {
    return {
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : "",
      iosReceipt: isSet(object.iosReceipt) ? globalThis.String(object.iosReceipt) : "",
      iosSecret: isSet(object.iosSecret) ? globalThis.String(object.iosSecret) : "",
      recaptchaToken: isSet(object.recaptchaToken) ? globalThis.String(object.recaptchaToken) : "",
      autoRetrievalInfo: isSet(object.autoRetrievalInfo)
        ? AutoRetrievalInfo.fromJSON(object.autoRetrievalInfo)
        : undefined,
      safetyNetToken: isSet(object.safetyNetToken) ? globalThis.String(object.safetyNetToken) : "",
    };
  },

  toJSON(message: StartMfaPhoneRequestInfo): unknown {
    const obj: any = {};
    if (message.phoneNumber !== "") {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.iosReceipt !== "") {
      obj.iosReceipt = message.iosReceipt;
    }
    if (message.iosSecret !== "") {
      obj.iosSecret = message.iosSecret;
    }
    if (message.recaptchaToken !== "") {
      obj.recaptchaToken = message.recaptchaToken;
    }
    if (message.autoRetrievalInfo !== undefined) {
      obj.autoRetrievalInfo = AutoRetrievalInfo.toJSON(message.autoRetrievalInfo);
    }
    if (message.safetyNetToken !== "") {
      obj.safetyNetToken = message.safetyNetToken;
    }
    return obj;
  },

  create(base?: DeepPartial<StartMfaPhoneRequestInfo>): StartMfaPhoneRequestInfo {
    return StartMfaPhoneRequestInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartMfaPhoneRequestInfo>): StartMfaPhoneRequestInfo {
    const message = createBaseStartMfaPhoneRequestInfo();
    message.phoneNumber = object.phoneNumber ?? "";
    message.iosReceipt = object.iosReceipt ?? "";
    message.iosSecret = object.iosSecret ?? "";
    message.recaptchaToken = object.recaptchaToken ?? "";
    message.autoRetrievalInfo = (object.autoRetrievalInfo !== undefined && object.autoRetrievalInfo !== null)
      ? AutoRetrievalInfo.fromPartial(object.autoRetrievalInfo)
      : undefined;
    message.safetyNetToken = object.safetyNetToken ?? "";
    return message;
  },
};

function createBaseStartMfaPhoneResponseInfo(): StartMfaPhoneResponseInfo {
  return { sessionInfo: "" };
}

export const StartMfaPhoneResponseInfo: MessageFns<StartMfaPhoneResponseInfo> = {
  encode(message: StartMfaPhoneResponseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionInfo !== "") {
      writer.uint32(10).string(message.sessionInfo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartMfaPhoneResponseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartMfaPhoneResponseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionInfo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartMfaPhoneResponseInfo {
    return { sessionInfo: isSet(object.sessionInfo) ? globalThis.String(object.sessionInfo) : "" };
  },

  toJSON(message: StartMfaPhoneResponseInfo): unknown {
    const obj: any = {};
    if (message.sessionInfo !== "") {
      obj.sessionInfo = message.sessionInfo;
    }
    return obj;
  },

  create(base?: DeepPartial<StartMfaPhoneResponseInfo>): StartMfaPhoneResponseInfo {
    return StartMfaPhoneResponseInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartMfaPhoneResponseInfo>): StartMfaPhoneResponseInfo {
    const message = createBaseStartMfaPhoneResponseInfo();
    message.sessionInfo = object.sessionInfo ?? "";
    return message;
  },
};

function createBaseFinalizeMfaPhoneRequestInfo(): FinalizeMfaPhoneRequestInfo {
  return { sessionInfo: "", code: "", androidVerificationProof: "", phoneNumber: "" };
}

export const FinalizeMfaPhoneRequestInfo: MessageFns<FinalizeMfaPhoneRequestInfo> = {
  encode(message: FinalizeMfaPhoneRequestInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionInfo !== "") {
      writer.uint32(10).string(message.sessionInfo);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.androidVerificationProof !== "") {
      writer.uint32(26).string(message.androidVerificationProof);
    }
    if (message.phoneNumber !== "") {
      writer.uint32(34).string(message.phoneNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeMfaPhoneRequestInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeMfaPhoneRequestInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sessionInfo = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.androidVerificationProof = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeMfaPhoneRequestInfo {
    return {
      sessionInfo: isSet(object.sessionInfo) ? globalThis.String(object.sessionInfo) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      androidVerificationProof: isSet(object.androidVerificationProof)
        ? globalThis.String(object.androidVerificationProof)
        : "",
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : "",
    };
  },

  toJSON(message: FinalizeMfaPhoneRequestInfo): unknown {
    const obj: any = {};
    if (message.sessionInfo !== "") {
      obj.sessionInfo = message.sessionInfo;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.androidVerificationProof !== "") {
      obj.androidVerificationProof = message.androidVerificationProof;
    }
    if (message.phoneNumber !== "") {
      obj.phoneNumber = message.phoneNumber;
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeMfaPhoneRequestInfo>): FinalizeMfaPhoneRequestInfo {
    return FinalizeMfaPhoneRequestInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeMfaPhoneRequestInfo>): FinalizeMfaPhoneRequestInfo {
    const message = createBaseFinalizeMfaPhoneRequestInfo();
    message.sessionInfo = object.sessionInfo ?? "";
    message.code = object.code ?? "";
    message.androidVerificationProof = object.androidVerificationProof ?? "";
    message.phoneNumber = object.phoneNumber ?? "";
    return message;
  },
};

function createBaseFinalizeMfaPhoneResponseInfo(): FinalizeMfaPhoneResponseInfo {
  return { androidVerificationProof: "", androidVerificationProofExpireTime: undefined, phoneNumber: "" };
}

export const FinalizeMfaPhoneResponseInfo: MessageFns<FinalizeMfaPhoneResponseInfo> = {
  encode(message: FinalizeMfaPhoneResponseInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.androidVerificationProof !== "") {
      writer.uint32(10).string(message.androidVerificationProof);
    }
    if (message.androidVerificationProofExpireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.androidVerificationProofExpireTime), writer.uint32(18).fork()).join();
    }
    if (message.phoneNumber !== "") {
      writer.uint32(26).string(message.phoneNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeMfaPhoneResponseInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeMfaPhoneResponseInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.androidVerificationProof = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.androidVerificationProofExpireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeMfaPhoneResponseInfo {
    return {
      androidVerificationProof: isSet(object.androidVerificationProof)
        ? globalThis.String(object.androidVerificationProof)
        : "",
      androidVerificationProofExpireTime: isSet(object.androidVerificationProofExpireTime)
        ? fromJsonTimestamp(object.androidVerificationProofExpireTime)
        : undefined,
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : "",
    };
  },

  toJSON(message: FinalizeMfaPhoneResponseInfo): unknown {
    const obj: any = {};
    if (message.androidVerificationProof !== "") {
      obj.androidVerificationProof = message.androidVerificationProof;
    }
    if (message.androidVerificationProofExpireTime !== undefined) {
      obj.androidVerificationProofExpireTime = message.androidVerificationProofExpireTime.toISOString();
    }
    if (message.phoneNumber !== "") {
      obj.phoneNumber = message.phoneNumber;
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeMfaPhoneResponseInfo>): FinalizeMfaPhoneResponseInfo {
    return FinalizeMfaPhoneResponseInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeMfaPhoneResponseInfo>): FinalizeMfaPhoneResponseInfo {
    const message = createBaseFinalizeMfaPhoneResponseInfo();
    message.androidVerificationProof = object.androidVerificationProof ?? "";
    message.androidVerificationProofExpireTime = object.androidVerificationProofExpireTime ?? undefined;
    message.phoneNumber = object.phoneNumber ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
