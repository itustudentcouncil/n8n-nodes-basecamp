// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/telcoautomation/v1/telcoautomation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.telcoautomation.v1";

/** BlueprintView defines the type of view of the blueprint. */
export enum BlueprintView {
  /** BLUEPRINT_VIEW_UNSPECIFIED - Unspecified enum value. */
  BLUEPRINT_VIEW_UNSPECIFIED = 0,
  /** BLUEPRINT_VIEW_BASIC - View which only contains metadata. */
  BLUEPRINT_VIEW_BASIC = 1,
  /** BLUEPRINT_VIEW_FULL - View which contains metadata and files it encapsulates. */
  BLUEPRINT_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function blueprintViewFromJSON(object: any): BlueprintView {
  switch (object) {
    case 0:
    case "BLUEPRINT_VIEW_UNSPECIFIED":
      return BlueprintView.BLUEPRINT_VIEW_UNSPECIFIED;
    case 1:
    case "BLUEPRINT_VIEW_BASIC":
      return BlueprintView.BLUEPRINT_VIEW_BASIC;
    case 2:
    case "BLUEPRINT_VIEW_FULL":
      return BlueprintView.BLUEPRINT_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BlueprintView.UNRECOGNIZED;
  }
}

export function blueprintViewToJSON(object: BlueprintView): string {
  switch (object) {
    case BlueprintView.BLUEPRINT_VIEW_UNSPECIFIED:
      return "BLUEPRINT_VIEW_UNSPECIFIED";
    case BlueprintView.BLUEPRINT_VIEW_BASIC:
      return "BLUEPRINT_VIEW_BASIC";
    case BlueprintView.BLUEPRINT_VIEW_FULL:
      return "BLUEPRINT_VIEW_FULL";
    case BlueprintView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** DeploymentView defines the type of view of the deployment. */
export enum DeploymentView {
  /** DEPLOYMENT_VIEW_UNSPECIFIED - Unspecified enum value. */
  DEPLOYMENT_VIEW_UNSPECIFIED = 0,
  /** DEPLOYMENT_VIEW_BASIC - View which only contains metadata. */
  DEPLOYMENT_VIEW_BASIC = 1,
  /** DEPLOYMENT_VIEW_FULL - View which contains metadata and files it encapsulates. */
  DEPLOYMENT_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function deploymentViewFromJSON(object: any): DeploymentView {
  switch (object) {
    case 0:
    case "DEPLOYMENT_VIEW_UNSPECIFIED":
      return DeploymentView.DEPLOYMENT_VIEW_UNSPECIFIED;
    case 1:
    case "DEPLOYMENT_VIEW_BASIC":
      return DeploymentView.DEPLOYMENT_VIEW_BASIC;
    case 2:
    case "DEPLOYMENT_VIEW_FULL":
      return DeploymentView.DEPLOYMENT_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeploymentView.UNRECOGNIZED;
  }
}

export function deploymentViewToJSON(object: DeploymentView): string {
  switch (object) {
    case DeploymentView.DEPLOYMENT_VIEW_UNSPECIFIED:
      return "DEPLOYMENT_VIEW_UNSPECIFIED";
    case DeploymentView.DEPLOYMENT_VIEW_BASIC:
      return "DEPLOYMENT_VIEW_BASIC";
    case DeploymentView.DEPLOYMENT_VIEW_FULL:
      return "DEPLOYMENT_VIEW_FULL";
    case DeploymentView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represent type of CR. */
export enum ResourceType {
  /** RESOURCE_TYPE_UNSPECIFIED - Unspecified resource type. */
  RESOURCE_TYPE_UNSPECIFIED = 0,
  /** NF_DEPLOY_RESOURCE - User specified NF Deploy CR. */
  NF_DEPLOY_RESOURCE = 1,
  /** DEPLOYMENT_RESOURCE - CRs that are part of a blueprint. */
  DEPLOYMENT_RESOURCE = 2,
  UNRECOGNIZED = -1,
}

export function resourceTypeFromJSON(object: any): ResourceType {
  switch (object) {
    case 0:
    case "RESOURCE_TYPE_UNSPECIFIED":
      return ResourceType.RESOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "NF_DEPLOY_RESOURCE":
      return ResourceType.NF_DEPLOY_RESOURCE;
    case 2:
    case "DEPLOYMENT_RESOURCE":
      return ResourceType.DEPLOYMENT_RESOURCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResourceType.UNRECOGNIZED;
  }
}

export function resourceTypeToJSON(object: ResourceType): string {
  switch (object) {
    case ResourceType.RESOURCE_TYPE_UNSPECIFIED:
      return "RESOURCE_TYPE_UNSPECIFIED";
    case ResourceType.NF_DEPLOY_RESOURCE:
      return "NF_DEPLOY_RESOURCE";
    case ResourceType.DEPLOYMENT_RESOURCE:
      return "DEPLOYMENT_RESOURCE";
    case ResourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Status of an entity (resource, deployment). */
export enum Status {
  /** STATUS_UNSPECIFIED - Unknown state. */
  STATUS_UNSPECIFIED = 0,
  /** STATUS_IN_PROGRESS - Under progress. */
  STATUS_IN_PROGRESS = 1,
  /** STATUS_ACTIVE - Running and ready to serve traffic. */
  STATUS_ACTIVE = 2,
  /** STATUS_FAILED - Failed or stalled. */
  STATUS_FAILED = 3,
  /** STATUS_DELETING - Delete in progress. */
  STATUS_DELETING = 4,
  /** STATUS_DELETED - Deleted deployment. */
  STATUS_DELETED = 5,
  /** STATUS_PEERING - NFDeploy specific status. Peering in progress. */
  STATUS_PEERING = 10,
  /**
   * STATUS_NOT_APPLICABLE - K8s objects such as NetworkAttachmentDefinition don't have a defined
   * status.
   */
  STATUS_NOT_APPLICABLE = 11,
  UNRECOGNIZED = -1,
}

export function statusFromJSON(object: any): Status {
  switch (object) {
    case 0:
    case "STATUS_UNSPECIFIED":
      return Status.STATUS_UNSPECIFIED;
    case 1:
    case "STATUS_IN_PROGRESS":
      return Status.STATUS_IN_PROGRESS;
    case 2:
    case "STATUS_ACTIVE":
      return Status.STATUS_ACTIVE;
    case 3:
    case "STATUS_FAILED":
      return Status.STATUS_FAILED;
    case 4:
    case "STATUS_DELETING":
      return Status.STATUS_DELETING;
    case 5:
    case "STATUS_DELETED":
      return Status.STATUS_DELETED;
    case 10:
    case "STATUS_PEERING":
      return Status.STATUS_PEERING;
    case 11:
    case "STATUS_NOT_APPLICABLE":
      return Status.STATUS_NOT_APPLICABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Status.UNRECOGNIZED;
  }
}

export function statusToJSON(object: Status): string {
  switch (object) {
    case Status.STATUS_UNSPECIFIED:
      return "STATUS_UNSPECIFIED";
    case Status.STATUS_IN_PROGRESS:
      return "STATUS_IN_PROGRESS";
    case Status.STATUS_ACTIVE:
      return "STATUS_ACTIVE";
    case Status.STATUS_FAILED:
      return "STATUS_FAILED";
    case Status.STATUS_DELETING:
      return "STATUS_DELETING";
    case Status.STATUS_DELETED:
      return "STATUS_DELETED";
    case Status.STATUS_PEERING:
      return "STATUS_PEERING";
    case Status.STATUS_NOT_APPLICABLE:
      return "STATUS_NOT_APPLICABLE";
    case Status.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * DeploymentLevel of a blueprint signifies where the blueprint will be
 * applied.
 */
export enum DeploymentLevel {
  /** DEPLOYMENT_LEVEL_UNSPECIFIED - Default unspecified deployment level. */
  DEPLOYMENT_LEVEL_UNSPECIFIED = 0,
  /**
   * HYDRATION - Blueprints at HYDRATION level cannot be used to create a Deployment
   * (A user cannot manually initate deployment of these blueprints on
   * orchestration or workload cluster).
   * These blueprints stay in a user's private catalog and are configured and
   * deployed by TNA automation.
   */
  HYDRATION = 1,
  /**
   * SINGLE_DEPLOYMENT - Blueprints at SINGLE_DEPLOYMENT level can be
   * a) Modified in private catalog.
   * b) Used to create a deployment on orchestration cluster by the user, once
   * approved.
   */
  SINGLE_DEPLOYMENT = 2,
  /**
   * MULTI_DEPLOYMENT - Blueprints at MULTI_DEPLOYMENT level can be
   * a) Modified in private catalog.
   * b) Used to create a deployment on orchestration cluster which will create
   * further hydrated deployments.
   */
  MULTI_DEPLOYMENT = 3,
  /**
   * WORKLOAD_CLUSTER_DEPLOYMENT - Blueprints at WORKLOAD_CLUSTER_DEPLOYMENT level can be
   * a) Modified in private catalog.
   * b) Used to create a deployment on workload cluster by the user, once
   * approved.
   */
  WORKLOAD_CLUSTER_DEPLOYMENT = 4,
  UNRECOGNIZED = -1,
}

export function deploymentLevelFromJSON(object: any): DeploymentLevel {
  switch (object) {
    case 0:
    case "DEPLOYMENT_LEVEL_UNSPECIFIED":
      return DeploymentLevel.DEPLOYMENT_LEVEL_UNSPECIFIED;
    case 1:
    case "HYDRATION":
      return DeploymentLevel.HYDRATION;
    case 2:
    case "SINGLE_DEPLOYMENT":
      return DeploymentLevel.SINGLE_DEPLOYMENT;
    case 3:
    case "MULTI_DEPLOYMENT":
      return DeploymentLevel.MULTI_DEPLOYMENT;
    case 4:
    case "WORKLOAD_CLUSTER_DEPLOYMENT":
      return DeploymentLevel.WORKLOAD_CLUSTER_DEPLOYMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DeploymentLevel.UNRECOGNIZED;
  }
}

export function deploymentLevelToJSON(object: DeploymentLevel): string {
  switch (object) {
    case DeploymentLevel.DEPLOYMENT_LEVEL_UNSPECIFIED:
      return "DEPLOYMENT_LEVEL_UNSPECIFIED";
    case DeploymentLevel.HYDRATION:
      return "HYDRATION";
    case DeploymentLevel.SINGLE_DEPLOYMENT:
      return "SINGLE_DEPLOYMENT";
    case DeploymentLevel.MULTI_DEPLOYMENT:
      return "MULTI_DEPLOYMENT";
    case DeploymentLevel.WORKLOAD_CLUSTER_DEPLOYMENT:
      return "WORKLOAD_CLUSTER_DEPLOYMENT";
    case DeploymentLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Orchestration cluster represents a GKE cluster with config controller and
 * TNA specific components installed on it.
 */
export interface OrchestrationCluster {
  /**
   * Name of the orchestration cluster. The name of orchestration cluster cannot
   * be more than 24 characters.
   */
  name: string;
  /** Management configuration of the underlying GKE cluster. */
  managementConfig:
    | ManagementConfig
    | undefined;
  /** Output only. [Output only] Create time stamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. [Output only] Update time stamp. */
  updateTime:
    | Date
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Output only. Provides the TNA version installed on the cluster. */
  tnaVersion: string;
  /** Output only. State of the Orchestration Cluster. */
  state: OrchestrationCluster_State;
}

/** Possible states that the Orchestration Cluster can be in. */
export enum OrchestrationCluster_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - OrchestrationCluster is being created. */
  CREATING = 1,
  /** ACTIVE - OrchestrationCluster has been created and is ready for use. */
  ACTIVE = 2,
  /** DELETING - OrchestrationCluster is being deleted. */
  DELETING = 3,
  /**
   * FAILED - OrchestrationCluster encountered an error and is in an indeterministic
   * state. User can still initiate a delete operation on this state.
   */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function orchestrationCluster_StateFromJSON(object: any): OrchestrationCluster_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return OrchestrationCluster_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return OrchestrationCluster_State.CREATING;
    case 2:
    case "ACTIVE":
      return OrchestrationCluster_State.ACTIVE;
    case 3:
    case "DELETING":
      return OrchestrationCluster_State.DELETING;
    case 4:
    case "FAILED":
      return OrchestrationCluster_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrchestrationCluster_State.UNRECOGNIZED;
  }
}

export function orchestrationCluster_StateToJSON(object: OrchestrationCluster_State): string {
  switch (object) {
    case OrchestrationCluster_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case OrchestrationCluster_State.CREATING:
      return "CREATING";
    case OrchestrationCluster_State.ACTIVE:
      return "ACTIVE";
    case OrchestrationCluster_State.DELETING:
      return "DELETING";
    case OrchestrationCluster_State.FAILED:
      return "FAILED";
    case OrchestrationCluster_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface OrchestrationCluster_LabelsEntry {
  key: string;
  value: string;
}

/**
 * EdgeSlm represents an SLM instance which manages the lifecycle of edge
 * components installed on Workload clusters managed by an Orchestration
 * Cluster.
 */
export interface EdgeSlm {
  /** Name of the EdgeSlm resource. */
  name: string;
  /**
   * Immutable. Reference to the orchestration cluster on which templates for
   * this resources will be applied. This should be of format
   * projects/{project}/locations/{location}/orchestrationClusters/{orchestration_cluster}.
   */
  orchestrationCluster: string;
  /** Output only. [Output only] Create time stamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. [Output only] Update time stamp. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. Labels as key value pairs. The key and value should contain
   * characters which are UTF-8 compliant and less than 50 characters.
   */
  labels: { [key: string]: string };
  /** Output only. Provides the active TNA version for this resource. */
  tnaVersion: string;
  /** Output only. State of the EdgeSlm resource. */
  state: EdgeSlm_State;
  /**
   * Optional. Type of workload cluster for which an EdgeSLM resource is
   * created.
   */
  workloadClusterType: EdgeSlm_WorkloadClusterType;
}

/** Possible states of the resource. */
export enum EdgeSlm_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - EdgeSlm is being created. */
  CREATING = 1,
  /** ACTIVE - EdgeSlm has been created and is ready for use. */
  ACTIVE = 2,
  /** DELETING - EdgeSlm is being deleted. */
  DELETING = 3,
  /**
   * FAILED - EdgeSlm encountered an error and is in an indeterministic
   * state. User can still initiate a delete operation on this state.
   */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function edgeSlm_StateFromJSON(object: any): EdgeSlm_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return EdgeSlm_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return EdgeSlm_State.CREATING;
    case 2:
    case "ACTIVE":
      return EdgeSlm_State.ACTIVE;
    case 3:
    case "DELETING":
      return EdgeSlm_State.DELETING;
    case 4:
    case "FAILED":
      return EdgeSlm_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EdgeSlm_State.UNRECOGNIZED;
  }
}

export function edgeSlm_StateToJSON(object: EdgeSlm_State): string {
  switch (object) {
    case EdgeSlm_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case EdgeSlm_State.CREATING:
      return "CREATING";
    case EdgeSlm_State.ACTIVE:
      return "ACTIVE";
    case EdgeSlm_State.DELETING:
      return "DELETING";
    case EdgeSlm_State.FAILED:
      return "FAILED";
    case EdgeSlm_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Workload clusters supported by TNA. New values will be added to the enum
 * list as TNA adds supports for new workload clusters in future.
 */
export enum EdgeSlm_WorkloadClusterType {
  /** WORKLOAD_CLUSTER_TYPE_UNSPECIFIED - Unspecified workload cluster. */
  WORKLOAD_CLUSTER_TYPE_UNSPECIFIED = 0,
  /** GDCE - Workload cluster is a GDCE cluster. */
  GDCE = 1,
  /** GKE - Workload cluster is a GKE cluster. */
  GKE = 2,
  UNRECOGNIZED = -1,
}

export function edgeSlm_WorkloadClusterTypeFromJSON(object: any): EdgeSlm_WorkloadClusterType {
  switch (object) {
    case 0:
    case "WORKLOAD_CLUSTER_TYPE_UNSPECIFIED":
      return EdgeSlm_WorkloadClusterType.WORKLOAD_CLUSTER_TYPE_UNSPECIFIED;
    case 1:
    case "GDCE":
      return EdgeSlm_WorkloadClusterType.GDCE;
    case 2:
    case "GKE":
      return EdgeSlm_WorkloadClusterType.GKE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EdgeSlm_WorkloadClusterType.UNRECOGNIZED;
  }
}

export function edgeSlm_WorkloadClusterTypeToJSON(object: EdgeSlm_WorkloadClusterType): string {
  switch (object) {
    case EdgeSlm_WorkloadClusterType.WORKLOAD_CLUSTER_TYPE_UNSPECIFIED:
      return "WORKLOAD_CLUSTER_TYPE_UNSPECIFIED";
    case EdgeSlm_WorkloadClusterType.GDCE:
      return "GDCE";
    case EdgeSlm_WorkloadClusterType.GKE:
      return "GKE";
    case EdgeSlm_WorkloadClusterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EdgeSlm_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A Blueprint contains a collection of kubernetes resources in the form of
 * YAML files. The file contents of a blueprint are collectively known as
 * package. A blueprint can be
 * a) imported from TNA's public catalog
 * b) modified as per a user's need
 * c) proposed and approved.
 * On approval, a revision of blueprint is created which can be used to
 * create a deployment on Orchestration or Workload Cluster.
 */
export interface Blueprint {
  /**
   * The name of the blueprint. If unspecified, the name will be autogenerated
   * from server side. Name of the blueprint must not contain `@` character.
   */
  name: string;
  /**
   * Output only. Immutable. The revision ID of the blueprint.
   * A new revision is committed whenever a blueprint is approved.
   */
  revisionId: string;
  /**
   * Required. Immutable. The public blueprint ID from which this blueprint was
   * created.
   */
  sourceBlueprint: string;
  /** Output only. The timestamp that the revision was created. */
  revisionCreateTime:
    | Date
    | undefined;
  /** Output only. Approval state of the blueprint (DRAFT, PROPOSED, APPROVED) */
  approvalState: Blueprint_ApprovalState;
  /** Optional. Human readable name of a Blueprint. */
  displayName: string;
  /** Output only. Name of the repository where the blueprint files are stored. */
  repository: string;
  /**
   * Optional. Files present in a blueprint.
   * When invoking UpdateBlueprint API, only the modified files should be
   * included in this. Files that are not included in the update of a blueprint
   * will not be changed.
   */
  files: File[];
  /**
   * Optional. Labels are key-value attributes that can be set on a blueprint
   * resource by the user.
   */
  labels: { [key: string]: string };
  /** Output only. Blueprint creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the blueprint was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Source provider is the author of a public blueprint, from
   * which this blueprint is created.
   */
  sourceProvider: string;
  /**
   * Output only. DeploymentLevel of a blueprint signifies where the blueprint
   * will be applied. e.g. [HYDRATION, SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT]
   */
  deploymentLevel: DeploymentLevel;
  /**
   * Output only. Indicates if the deployment created from this blueprint can be
   * rolled back.
   */
  rollbackSupport: boolean;
}

/**
 * Approval state indicates the state of a Blueprint in its approval
 * lifecycle.
 */
export enum Blueprint_ApprovalState {
  /** APPROVAL_STATE_UNSPECIFIED - Unspecified state. */
  APPROVAL_STATE_UNSPECIFIED = 0,
  /**
   * DRAFT - A blueprint starts in DRAFT state once it is created. All edits are made
   * to the blueprint in DRAFT state.
   */
  DRAFT = 1,
  /**
   * PROPOSED - When the edits are ready for review, blueprint can be proposed and moves
   * to PROPOSED state. Edits cannot be made to a blueprint in PROPOSED state.
   */
  PROPOSED = 2,
  /**
   * APPROVED - When a proposed blueprint is approved, it moves to APPROVED state. A new
   * revision is committed. The latest committed revision can be used to
   * create a deployment on Orchestration or Workload Cluster. Edits to an
   * APPROVED blueprint changes its state back to DRAFT. The last committed
   * revision of a blueprint represents its latest APPROVED state.
   */
  APPROVED = 3,
  UNRECOGNIZED = -1,
}

export function blueprint_ApprovalStateFromJSON(object: any): Blueprint_ApprovalState {
  switch (object) {
    case 0:
    case "APPROVAL_STATE_UNSPECIFIED":
      return Blueprint_ApprovalState.APPROVAL_STATE_UNSPECIFIED;
    case 1:
    case "DRAFT":
      return Blueprint_ApprovalState.DRAFT;
    case 2:
    case "PROPOSED":
      return Blueprint_ApprovalState.PROPOSED;
    case 3:
    case "APPROVED":
      return Blueprint_ApprovalState.APPROVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Blueprint_ApprovalState.UNRECOGNIZED;
  }
}

export function blueprint_ApprovalStateToJSON(object: Blueprint_ApprovalState): string {
  switch (object) {
    case Blueprint_ApprovalState.APPROVAL_STATE_UNSPECIFIED:
      return "APPROVAL_STATE_UNSPECIFIED";
    case Blueprint_ApprovalState.DRAFT:
      return "DRAFT";
    case Blueprint_ApprovalState.PROPOSED:
      return "PROPOSED";
    case Blueprint_ApprovalState.APPROVED:
      return "APPROVED";
    case Blueprint_ApprovalState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Blueprint_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A Blueprint contains a collection of kubernetes resources in the form of
 * YAML files. The file contents of a blueprint are collectively known as
 * package.
 * Public blueprint is a TNA provided blueprint that in present in TNA's public
 * catalog. A user can copy the public blueprint to their private catalog for
 * further modifications.
 */
export interface PublicBlueprint {
  /** Name of the public blueprint. */
  name: string;
  /** The display name of the public blueprint. */
  displayName: string;
  /** The description of the public blueprint. */
  description: string;
  /**
   * DeploymentLevel of a blueprint signifies where the blueprint will be
   * applied. e.g. [HYDRATION, SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT]
   */
  deploymentLevel: DeploymentLevel;
  /** Source provider is the author of a public blueprint. e.g. Google, vendors */
  sourceProvider: string;
  /**
   * Output only. Indicates if the deployment created from this blueprint can be
   * rolled back.
   */
  rollbackSupport: boolean;
}

/**
 * Deployment contains a collection of YAML files (This collection is also known
 * as package) that can to applied on an orchestration cluster (GKE cluster with
 * TNA addons) or a workload cluster.
 */
export interface Deployment {
  /** The name of the deployment. */
  name: string;
  /**
   * Output only. Immutable. The revision ID of the deployment.
   * A new revision is committed whenever a change in deployment is applied.
   */
  revisionId: string;
  /** Required. The blueprint revision from which this deployment was created. */
  sourceBlueprintRevision: string;
  /** Output only. The timestamp that the revision was created. */
  revisionCreateTime:
    | Date
    | undefined;
  /** Output only. State of the deployment (DRAFT, APPLIED, DELETING). */
  state: Deployment_State;
  /** Optional. Human readable name of a Deployment. */
  displayName: string;
  /**
   * Output only. Name of the repository where the deployment package files are
   * stored.
   */
  repository: string;
  /**
   * Optional. Files present in a deployment.
   * When invoking UpdateDeployment API, only the modified files should be
   * included in this. Files that are not included in the update of a deployment
   * will not be changed.
   */
  files: File[];
  /**
   * Optional. Labels are key-value attributes that can be set on a deployment
   * resource by the user.
   */
  labels: { [key: string]: string };
  /** Output only. Deployment creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the deployment was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Source provider is the author of a public blueprint, from
   * which this deployment is created.
   */
  sourceProvider: string;
  /**
   * Optional. Immutable. The WorkloadCluster on which to create the Deployment.
   * This field should only be passed when the deployment_level of the source
   * blueprint specifies deployments on workload clusters e.g.
   * WORKLOAD_CLUSTER_DEPLOYMENT.
   */
  workloadCluster: string;
  /**
   * Output only. Attributes to where the deployment can inflict changes. The
   * value can only be [SINGLE_DEPLOYMENT, MULTI_DEPLOYMENT].
   */
  deploymentLevel: DeploymentLevel;
  /**
   * Output only. Indicates if the deployment can be rolled back, exported from
   * public blueprint.
   */
  rollbackSupport: boolean;
}

/** State defines which state the current deployment is in. */
export enum Deployment_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /**
   * DRAFT - A deployment starts in DRAFT state. All edits are made in DRAFT state. A
   * deployment opened for editing after applying will be in draft state,
   * while its prevision revision will be its current applied version.
   */
  DRAFT = 1,
  /**
   * APPLIED - This state means that the contents (YAML files containing kubernetes
   * resources) of the deployment have been applied to an Orchestration or
   * Workload Cluster. A revision is created when a deployment is applied.
   * This revision will represent the latest view of what is applied on the
   * cluster until the deployment is modified and applied again, which will
   * create a new revision.
   */
  APPLIED = 2,
  /**
   * DELETING - A deployment in DELETING state has been marked for deletion. Its
   * deletion status can be queried using `ComputeDeploymentStatus` API. No
   * updates are allowed to a deployment in DELETING state.
   */
  DELETING = 3,
  UNRECOGNIZED = -1,
}

export function deployment_StateFromJSON(object: any): Deployment_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Deployment_State.STATE_UNSPECIFIED;
    case 1:
    case "DRAFT":
      return Deployment_State.DRAFT;
    case 2:
    case "APPLIED":
      return Deployment_State.APPLIED;
    case 3:
    case "DELETING":
      return Deployment_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Deployment_State.UNRECOGNIZED;
  }
}

export function deployment_StateToJSON(object: Deployment_State): string {
  switch (object) {
    case Deployment_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Deployment_State.DRAFT:
      return "DRAFT";
    case Deployment_State.APPLIED:
      return "APPLIED";
    case Deployment_State.DELETING:
      return "DELETING";
    case Deployment_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Deployment_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A collection of kubernetes yaml files which are deployed on a Workload
 * Cluster. Hydrated Deployments are created by TNA intent based automation.
 */
export interface HydratedDeployment {
  /** Output only. The name of the hydrated deployment. */
  name: string;
  /** Output only. State of the hydrated deployment (DRAFT, APPLIED). */
  state: HydratedDeployment_State;
  /**
   * Optional. File contents of a hydrated deployment.
   * When invoking UpdateHydratedBlueprint API, only the modified files should
   * be included in this. Files that are not included in the update of a
   * hydrated deployment will not be changed.
   */
  files: File[];
  /**
   * Output only. WorkloadCluster identifies which workload cluster will the
   * hydrated deployment will be deployed on.
   */
  workloadCluster: string;
}

/** State defines which state the current hydrated deployment is in. */
export enum HydratedDeployment_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /**
   * DRAFT - A hydrated deployment starts in DRAFT state. All edits are made in DRAFT
   * state.
   */
  DRAFT = 1,
  /**
   * APPLIED - When the edit is applied, the hydrated deployment moves to APPLIED
   * state. No changes can be made once a hydrated deployment is applied.
   */
  APPLIED = 2,
  UNRECOGNIZED = -1,
}

export function hydratedDeployment_StateFromJSON(object: any): HydratedDeployment_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return HydratedDeployment_State.STATE_UNSPECIFIED;
    case 1:
    case "DRAFT":
      return HydratedDeployment_State.DRAFT;
    case 2:
    case "APPLIED":
      return HydratedDeployment_State.APPLIED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HydratedDeployment_State.UNRECOGNIZED;
  }
}

export function hydratedDeployment_StateToJSON(object: HydratedDeployment_State): string {
  switch (object) {
    case HydratedDeployment_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case HydratedDeployment_State.DRAFT:
      return "DRAFT";
    case HydratedDeployment_State.APPLIED:
      return "APPLIED";
    case HydratedDeployment_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message for requesting list of OrchestrationClusters. */
export interface ListOrchestrationClustersRequest {
  /** Required. Parent value for ListOrchestrationClustersRequest */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results. */
  filter: string;
  /** Hint for how to order the results. */
  orderBy: string;
}

/** Message for response to listing OrchestrationClusters. */
export interface ListOrchestrationClustersResponse {
  /** The list of OrchestrationCluster */
  orchestrationClusters: OrchestrationCluster[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a OrchestrationCluster. */
export interface GetOrchestrationClusterRequest {
  /** Required. Name of the resource */
  name: string;
}

/** Message for creating a OrchestrationCluster. */
export interface CreateOrchestrationClusterRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. Id of the requesting object
   * If auto-generating Id server-side, remove this field and
   * orchestration_cluster_id from the method_signature of Create RPC
   */
  orchestrationClusterId: string;
  /** Required. The resource being created */
  orchestrationCluster:
    | OrchestrationCluster
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for deleting a OrchestrationCluster. */
export interface DeleteOrchestrationClusterRequest {
  /** Required. Name of the resource */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for requesting list of EdgeSlms */
export interface ListEdgeSlmsRequest {
  /** Required. Parent value for ListEdgeSlmsRequest */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results the server should return. */
  pageToken: string;
  /** Filtering results */
  filter: string;
  /** Hint for how to order the results */
  orderBy: string;
}

/** Message for response to listing EdgeSlms. */
export interface ListEdgeSlmsResponse {
  /** The list of EdgeSlm */
  edgeSlms: EdgeSlm[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for getting a EdgeSlm. */
export interface GetEdgeSlmRequest {
  /** Required. Name of the resource */
  name: string;
}

/** Message for creating a EdgeSlm. */
export interface CreateEdgeSlmRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. Id of the requesting object
   * If auto-generating Id server-side, remove this field and
   * edge_slm_id from the method_signature of Create RPC
   */
  edgeSlmId: string;
  /** Required. The resource being created */
  edgeSlm:
    | EdgeSlm
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for deleting a EdgeSlm. */
export interface DeleteEdgeSlmRequest {
  /** Required. Name of the resource */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request object for `CreateBlueprint`. */
export interface CreateBlueprintRequest {
  /**
   * Required. The name of parent resource.
   * Format should be -
   * "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
   */
  parent: string;
  /** Optional. The name of the blueprint. */
  blueprintId: string;
  /** Required. The `Blueprint` to create. */
  blueprint: Blueprint | undefined;
}

/** Request object for `UpdateBlueprint`. */
export interface UpdateBlueprintRequest {
  /** Required. The `blueprint` to update. */
  blueprint:
    | Blueprint
    | undefined;
  /**
   * Required. Update mask is used to specify the fields to be overwritten in
   * the `blueprint` resource by the update.
   */
  updateMask: string[] | undefined;
}

/** Request object for `GetBlueprint`. */
export interface GetBlueprintRequest {
  /**
   * Required. The name of the blueprint.
   * Case 1: If the name provided in the request is
   * {blueprint_id}@{revision_id}, then the revision with revision_id will be
   * returned. Case 2: If the name provided in the request is {blueprint}, then
   * the current state of the blueprint is returned.
   */
  name: string;
  /**
   * Optional. Defines the type of view of the blueprint.
   * When field is not present BLUEPRINT_VIEW_BASIC is considered as default.
   */
  view: BlueprintView;
}

/** Request object for `DeleteBlueprint`. */
export interface DeleteBlueprintRequest {
  /**
   * Required. The name of blueprint to delete.
   * Blueprint name should be in the format {blueprint_id}, if
   * {blueprint_id}@{revision_id} is passed then the API throws invalid
   * argument.
   */
  name: string;
}

/** Request object for `ListBlueprints`. */
export interface ListBlueprintsRequest {
  /**
   * Required. The name of parent orchestration cluster resource.
   * Format should be -
   * "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
   */
  parent: string;
  /**
   * Optional. Filtering only supports equality on blueprint state.
   * It should be in the form: "state = DRAFT". `OR` operator can be used to
   * get response for multiple states. e.g. "state = DRAFT OR state = PROPOSED".
   */
  filter: string;
  /** Optional. The maximum number of blueprints to return per page. */
  pageSize: number;
  /**
   * Optional. The page token, received from a previous ListBlueprints call.
   * It can be provided to retrieve the subsequent page.
   */
  pageToken: string;
}

/** Response object for `ListBlueprints`. */
export interface ListBlueprintsResponse {
  /** The list of requested blueprints. */
  blueprints: Blueprint[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request object for `ApproveBlueprint`. */
export interface ApproveBlueprintRequest {
  /**
   * Required. The name of the blueprint to approve. The blueprint must be in
   * Proposed state. A new revision is committed on approval.
   */
  name: string;
}

/** Request object for `ProposeBlueprint`. */
export interface ProposeBlueprintRequest {
  /** Required. The name of the blueprint being proposed. */
  name: string;
}

/** Request object for `RejectBlueprint`. */
export interface RejectBlueprintRequest {
  /** Required. The name of the blueprint being rejected. */
  name: string;
}

/** Request object for `ListBlueprintRevisions`. */
export interface ListBlueprintRevisionsRequest {
  /** Required. The name of the blueprint to list revisions for. */
  name: string;
  /** The maximum number of revisions to return per page. */
  pageSize: number;
  /**
   * The page token, received from a previous ListBlueprintRevisions call
   * It can be provided to retrieve the subsequent page.
   */
  pageToken: string;
}

/** Response object for `ListBlueprintRevisions`. */
export interface ListBlueprintRevisionsResponse {
  /** The revisions of the blueprint. */
  blueprints: Blueprint[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request object for `SearchBlueprintRevisions`. */
export interface SearchBlueprintRevisionsRequest {
  /**
   * Required. The name of parent orchestration cluster resource.
   * Format should be -
   * "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
   */
  parent: string;
  /**
   * Required. Supported queries:
   * 1. ""                       : Lists all revisions across all blueprints.
   * 2. "latest=true"            : Lists latest revisions across all blueprints.
   * 3. "name={name}"            : Lists all revisions of blueprint with name
   * {name}.
   * 4. "name={name} latest=true": Lists latest revision of blueprint with name
   * {name}
   */
  query: string;
  /**
   * Optional. The maximum number of blueprints revisions to return per page.
   * max page size = 100, default page size = 20.
   */
  pageSize: number;
  /**
   * Optional. The page token, received from a previous search call.
   * It can be provided to retrieve the subsequent page.
   */
  pageToken: string;
}

/** Response object for `SearchBlueprintRevisions`. */
export interface SearchBlueprintRevisionsResponse {
  /** The list of requested blueprint revisions. */
  blueprints: Blueprint[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request object for `DiscardBlueprintChanges`. */
export interface DiscardBlueprintChangesRequest {
  /** Required. The name of the blueprint of which changes are being discarded. */
  name: string;
}

/** Response object for `DiscardBlueprintChanges`. */
export interface DiscardBlueprintChangesResponse {
}

/** Request object for `ListPublicBlueprints`. */
export interface ListPublicBlueprintsRequest {
  /**
   * Required. Parent value of public blueprint.
   * Format should be -
   * "projects/{project_id}/locations/{location_name}".
   */
  parent: string;
  /**
   * Optional. Requested page size. Server may return fewer items than
   * requested. If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** Optional. A token identifying a page of results the server should return. */
  pageToken: string;
}

/** Response object for `ListPublicBlueprints`. */
export interface ListPublicBlueprintsResponse {
  /** The list of public blueprints to return. */
  publicBlueprints: PublicBlueprint[];
  /**
   * Output only. A token identifying a page of results the server should
   * return.
   */
  nextPageToken: string;
}

/** Request object for `GetPublicBlueprint`. */
export interface GetPublicBlueprintRequest {
  /** Required. The name of the public blueprint. */
  name: string;
}

/** Request object for `CreateDeployment`. */
export interface CreateDeploymentRequest {
  /**
   * Required. The name of parent resource.
   * Format should be -
   * "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
   */
  parent: string;
  /** Optional. The name of the deployment. */
  deploymentId: string;
  /** Required. The `Deployment` to create. */
  deployment: Deployment | undefined;
}

/** Request object for `UpdateDeployment`. */
export interface UpdateDeploymentRequest {
  /** Required. The `deployment` to update. */
  deployment:
    | Deployment
    | undefined;
  /**
   * Required. Update mask is used to specify the fields to be overwritten in
   * the `deployment` resource by the update.
   */
  updateMask: string[] | undefined;
}

/** Request object for `GetDeployment`. */
export interface GetDeploymentRequest {
  /**
   * Required. The name of the deployment.
   * Case 1: If the name provided in the request is
   * {deployment_id}@{revision_id}, then the revision with revision_id will be
   * returned.
   * Case 2: If the name provided in the request is {deployment}, then
   * the current state of the deployment is returned.
   */
  name: string;
  /**
   * Optional. Defines the type of view of the deployment.
   * When field is not present VIEW_BASIC is considered as default.
   */
  view: DeploymentView;
}

/** Request object for `RemoveDeployment`. */
export interface RemoveDeploymentRequest {
  /** Required. The name of deployment to initiate delete. */
  name: string;
}

/** Request object for `ListDeployments`. */
export interface ListDeploymentsRequest {
  /**
   * Required. The name of parent orchestration cluster resource.
   * Format should be -
   * "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
   */
  parent: string;
  /**
   * Optional. Filtering only supports equality on deployment state.
   * It should be in the form: "state = DRAFT". `OR` operator can be used to
   * get response for multiple states. e.g. "state = DRAFT OR state = APPLIED".
   */
  filter: string;
  /** Optional. The maximum number of deployments to return per page. */
  pageSize: number;
  /**
   * Optional. The page token, received from a previous ListDeployments call.
   * It can be provided to retrieve the subsequent page.
   */
  pageToken: string;
}

/** Response object for `ListDeployments`. */
export interface ListDeploymentsResponse {
  /** The list of requested deployments. */
  deployments: Deployment[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request for listing all revisions of a deployment. */
export interface ListDeploymentRevisionsRequest {
  /** Required. The name of the deployment to list revisions for. */
  name: string;
  /** Optional. The maximum number of revisions to return per page. */
  pageSize: number;
  /**
   * Optional. The page token, received from a previous ListDeploymentRevisions
   * call Provide this to retrieve the subsequent page.
   */
  pageToken: string;
}

/** List of deployment revisions for a given deployment. */
export interface ListDeploymentRevisionsResponse {
  /** The revisions of the deployment. */
  deployments: Deployment[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request object for `SearchDeploymentRevisions`. */
export interface SearchDeploymentRevisionsRequest {
  /**
   * Required. The name of parent orchestration cluster resource.
   * Format should be -
   * "projects/{project_id}/locations/{location_name}/orchestrationClusters/{orchestration_cluster}".
   */
  parent: string;
  /**
   * Required. Supported queries:
   * 1. ""                       : Lists all revisions across all deployments.
   * 2. "latest=true"            : Lists latest revisions across all
   * deployments.
   * 3. "name={name}"            : Lists all revisions of deployment with name
   * {name}.
   * 4. "name={name} latest=true": Lists latest revision of deployment with name
   * {name}
   */
  query: string;
  /**
   * Optional. The maximum number of deployment revisions to return per page.
   * max page size = 100, default page size = 20.
   */
  pageSize: number;
  /**
   * Optional. The page token, received from a previous search call.
   * It can be provided to retrieve the subsequent page.
   */
  pageToken: string;
}

/** Response object for `SearchDeploymentRevisions`. */
export interface SearchDeploymentRevisionsResponse {
  /** The list of requested deployment revisions. */
  deployments: Deployment[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request object for `DiscardDeploymentChanges`. */
export interface DiscardDeploymentChangesRequest {
  /** Required. The name of the deployment of which changes are being discarded. */
  name: string;
}

/** Response object for `DiscardDeploymentChanges`. */
export interface DiscardDeploymentChangesResponse {
}

/**
 * Request object for `ApplyDeployment`. The resources in given deployment
 * gets applied to Orchestration Cluster. A new revision is created when a
 * deployment is applied.
 */
export interface ApplyDeploymentRequest {
  /** Required. The name of the deployment to apply to orchestration cluster. */
  name: string;
}

/** Request object for `ComputeDeploymentStatus`. */
export interface ComputeDeploymentStatusRequest {
  /** Required. The name of the deployment without revisionID. */
  name: string;
}

/** Response object for `ComputeDeploymentStatus`. */
export interface ComputeDeploymentStatusResponse {
  /** The name of the deployment. */
  name: string;
  /** Output only. Aggregated status of a deployment. */
  aggregatedStatus: Status;
  /** Output only. Resource level status details in deployments. */
  resourceStatuses: ResourceStatus[];
}

/** Request object for `RollbackDeployment`. */
export interface RollbackDeploymentRequest {
  /** Required. Name of the deployment. */
  name: string;
  /** Required. The revision id of deployment to roll back to. */
  revisionId: string;
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have been cancelled successfully
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

/** Request object for `GetHydratedDeployment`. */
export interface GetHydratedDeploymentRequest {
  /** Required. Name of the hydrated deployment. */
  name: string;
}

/** Request object for `ListHydratedDeployments`. */
export interface ListHydratedDeploymentsRequest {
  /** Required. The deployment managing the hydrated deployments. */
  parent: string;
  /**
   * Optional. The maximum number of hydrated deployments to return. The service
   * may return fewer than this value. If unspecified, at most 50 hydrated
   * deployments will be returned. The maximum value is 1000. Values above 1000
   * will be set to 1000.
   */
  pageSize: number;
  /**
   * Optional. The page token, received from a previous ListHydratedDeployments
   * call. Provide this to retrieve the subsequent page.
   */
  pageToken: string;
}

/** Response object for `ListHydratedDeployments`. */
export interface ListHydratedDeploymentsResponse {
  /** The list of hydrated deployments. */
  hydratedDeployments: HydratedDeployment[];
  /**
   * A token that can be sent as `page_token` to retrieve the next page.
   * If this field is omitted, there are no subsequent pages.
   */
  nextPageToken: string;
}

/** Request object for `UpdateHydratedDeployment`. */
export interface UpdateHydratedDeploymentRequest {
  /** Required. The hydrated deployment to update. */
  hydratedDeployment:
    | HydratedDeployment
    | undefined;
  /**
   * Required. The list of fields to update. Update mask supports a special
   * value `*` which fully replaces (equivalent to PUT) the resource provided.
   */
  updateMask: string[] | undefined;
}

/** Request for applying a hydrated deployment. */
export interface ApplyHydratedDeploymentRequest {
  /** Required. The name of the hydrated deployment to apply. */
  name: string;
}

/** Configuration of the cluster management */
export interface ManagementConfig {
  /** Configuration of the standard (GKE) cluster management */
  standardManagementConfig?:
    | StandardManagementConfig
    | undefined;
  /**
   * Configuration of the full (Autopilot) cluster management. Full cluster
   * management is a preview feature.
   */
  fullManagementConfig?: FullManagementConfig | undefined;
}

/** Configuration of the standard (GKE) cluster management. */
export interface StandardManagementConfig {
  /**
   * Optional. Name of the VPC Network to put the GKE cluster and nodes in. The
   * VPC will be created if it doesn't exist.
   */
  network: string;
  /**
   * Optional. Specifies the subnet that the interface will be part of. Network
   * key must be specified and the subnet must be a subnetwork of the specified
   * network.
   */
  subnet: string;
  /**
   * Optional. The /28 network that the masters will use. It should be free
   * within the network.
   */
  masterIpv4CidrBlock: string;
  /**
   * Optional. The IP address range for the cluster pod IPs. Set to blank to
   * have a range chosen with the default size. Set to /netmask (e.g. /14) to
   * have a range chosen with a specific netmask. Set to a CIDR notation
   * (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
   * 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
   */
  clusterCidrBlock: string;
  /**
   * Optional. The IP address range for the cluster service IPs. Set to blank to
   * have a range chosen with the default size. Set to /netmask (e.g. /14) to
   * have a range chosen with a specific netmask. Set to a CIDR notation (e.g.
   * 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
   * 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
   */
  servicesCidrBlock: string;
  /**
   * Optional. The name of the existing secondary range in the cluster's
   * subnetwork to use for pod IP addresses. Alternatively, cluster_cidr_block
   * can be used to automatically create a GKE-managed one.
   */
  clusterNamedRange: string;
  /**
   * Optional. The name of the existing secondary range in the cluster's
   * subnetwork to use for service ClusterIPs. Alternatively,
   * services_cidr_block can be used to automatically create a GKE-managed one.
   */
  servicesNamedRange: string;
  /**
   * Optional. Master Authorized Network that supports multiple CIDR blocks.
   * Allows access to the k8s master from multiple blocks. It cannot be set at
   * the same time with the field man_block.
   */
  masterAuthorizedNetworksConfig: MasterAuthorizedNetworksConfig | undefined;
}

/** Configuration of the full (Autopilot) cluster management */
export interface FullManagementConfig {
  /**
   * Optional. Name of the VPC Network to put the GKE cluster and nodes in. The
   * VPC will be created if it doesn't exist.
   */
  network: string;
  /**
   * Optional. Specifies the subnet that the interface will be part of. Network
   * key must be specified and the subnet must be a subnetwork of the specified
   * network.
   */
  subnet: string;
  /** Optional. The /28 network that the masters will use. */
  masterIpv4CidrBlock: string;
  /**
   * Optional. The IP address range for the cluster pod IPs. Set to blank to
   * have a range chosen with the default size. Set to /netmask (e.g. /14) to
   * have a range chosen with a specific netmask. Set to a CIDR notation
   * (e.g. 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
   * 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
   */
  clusterCidrBlock: string;
  /**
   * Optional. The IP address range for the cluster service IPs. Set to blank to
   * have a range chosen with the default size. Set to /netmask (e.g. /14) to
   * have a range chosen with a specific netmask. Set to a CIDR notation (e.g.
   * 10.96.0.0/14) from the RFC-1918 private networks (e.g. 10.0.0.0/8,
   * 172.16.0.0/12, 192.168.0.0/16) to pick a specific range to use.
   */
  servicesCidrBlock: string;
  /**
   * Optional. The name of the existing secondary range in the cluster's
   * subnetwork to use for pod IP addresses. Alternatively, cluster_cidr_block
   * can be used to automatically create a GKE-managed one.
   */
  clusterNamedRange: string;
  /**
   * Optional. The name of the existing secondary range in the cluster's
   * subnetwork to use for service ClusterIPs. Alternatively,
   * services_cidr_block can be used to automatically create a GKE-managed one.
   */
  servicesNamedRange: string;
  /**
   * Optional. Master Authorized Network that supports multiple CIDR blocks.
   * Allows access to the k8s master from multiple blocks. It cannot be set at
   * the same time with the field man_block.
   */
  masterAuthorizedNetworksConfig: MasterAuthorizedNetworksConfig | undefined;
}

/** Configuration of the Master Authorized Network that support multiple CIDRs */
export interface MasterAuthorizedNetworksConfig {
  /**
   * Optional. cidr_blocks define up to 50 external networks that could access
   * Kubernetes master through HTTPS.
   */
  cidrBlocks: MasterAuthorizedNetworksConfig_CidrBlock[];
}

/** CidrBlock contains an optional name and one CIDR block. */
export interface MasterAuthorizedNetworksConfig_CidrBlock {
  /**
   * Optional. display_name is an optional field for users to identify CIDR
   * blocks.
   */
  displayName: string;
  /**
   * Optional. cidr_block must be specified in CIDR notation when using
   * master_authorized_networks_config. Currently, the user could still use
   * the deprecated man_block field, so this field is currently optional, but
   * will be required in the future.
   */
  cidrBlock: string;
}

/** File represents a yaml file present in a blueprint's package. */
export interface File {
  /**
   * Required. Path of the file in package.
   * e.g. `gdce/v1/cluster.yaml`
   */
  path: string;
  /** Optional. The contents of a file in string format. */
  content: string;
  /** Optional. Signifies whether a file is marked for deletion. */
  deleted: boolean;
  /**
   * Optional. Indicates whether changes are allowed to a file. If the field is
   * not set, the file cannot be edited.
   */
  editable: boolean;
}

/** Status of a deployment resource. */
export interface ResourceStatus {
  /** Name of the resource. */
  name: string;
  /** Namespace of the resource. */
  resourceNamespace: string;
  /** Group to which the resource belongs to. */
  group: string;
  /** Version of the resource. */
  version: string;
  /** Kind of the resource. */
  kind: string;
  /** Output only. Resource type. */
  resourceType: ResourceType;
  /** Output only. Status of the resource. */
  status: Status;
  /** Output only. Detailed status of NFDeploy. */
  nfDeployStatus: NFDeployStatus | undefined;
}

/** Deployment status of NFDeploy. */
export interface NFDeployStatus {
  /** Output only. Total number of NFs targeted by this deployment */
  targetedNfs: number;
  /**
   * Output only. Total number of NFs targeted by this deployment with a Ready
   * Condition set.
   */
  readyNfs: number;
  /** Output only. Per-Site Status. */
  sites: NFDeploySiteStatus[];
}

/** Per-Site Status. */
export interface NFDeploySiteStatus {
  /** Output only. Site id. */
  site: string;
  /** Output only. If true, the Site Deletion is in progress. */
  pendingDeletion: boolean;
  /** Output only. Hydration status. */
  hydration:
    | HydrationStatus
    | undefined;
  /** Output only. Workload status. */
  workload: WorkloadStatus | undefined;
}

/** Hydration status. */
export interface HydrationStatus {
  /** Output only. SiteVersion Hydration is targeting. */
  siteVersion:
    | SiteVersion
    | undefined;
  /** Output only. Status. */
  status: string;
}

/** SiteVersion Hydration is targeting. */
export interface SiteVersion {
  /** Output only. NF vendor. */
  nfVendor: string;
  /** Output only. NF vendor type. */
  nfType: string;
  /** Output only. NF version. */
  nfVersion: string;
}

/** Workload status. */
export interface WorkloadStatus {
  /** Output only. SiteVersion running in the workload cluster. */
  siteVersion:
    | SiteVersion
    | undefined;
  /** Output only. Status. */
  status: string;
}

function createBaseOrchestrationCluster(): OrchestrationCluster {
  return {
    name: "",
    managementConfig: undefined,
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    tnaVersion: "",
    state: 0,
  };
}

export const OrchestrationCluster: MessageFns<OrchestrationCluster> = {
  encode(message: OrchestrationCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.managementConfig !== undefined) {
      ManagementConfig.encode(message.managementConfig, writer.uint32(42).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      OrchestrationCluster_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.tnaVersion !== "") {
      writer.uint32(50).string(message.tnaVersion);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrchestrationCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrchestrationCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.managementConfig = ManagementConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = OrchestrationCluster_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tnaVersion = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrchestrationCluster {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      managementConfig: isSet(object.managementConfig) ? ManagementConfig.fromJSON(object.managementConfig) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      tnaVersion: isSet(object.tnaVersion) ? globalThis.String(object.tnaVersion) : "",
      state: isSet(object.state) ? orchestrationCluster_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: OrchestrationCluster): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.managementConfig !== undefined) {
      obj.managementConfig = ManagementConfig.toJSON(message.managementConfig);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.tnaVersion !== "") {
      obj.tnaVersion = message.tnaVersion;
    }
    if (message.state !== 0) {
      obj.state = orchestrationCluster_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<OrchestrationCluster>): OrchestrationCluster {
    return OrchestrationCluster.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrchestrationCluster>): OrchestrationCluster {
    const message = createBaseOrchestrationCluster();
    message.name = object.name ?? "";
    message.managementConfig = (object.managementConfig !== undefined && object.managementConfig !== null)
      ? ManagementConfig.fromPartial(object.managementConfig)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.tnaVersion = object.tnaVersion ?? "";
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseOrchestrationCluster_LabelsEntry(): OrchestrationCluster_LabelsEntry {
  return { key: "", value: "" };
}

export const OrchestrationCluster_LabelsEntry: MessageFns<OrchestrationCluster_LabelsEntry> = {
  encode(message: OrchestrationCluster_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrchestrationCluster_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrchestrationCluster_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrchestrationCluster_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: OrchestrationCluster_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<OrchestrationCluster_LabelsEntry>): OrchestrationCluster_LabelsEntry {
    return OrchestrationCluster_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrchestrationCluster_LabelsEntry>): OrchestrationCluster_LabelsEntry {
    const message = createBaseOrchestrationCluster_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEdgeSlm(): EdgeSlm {
  return {
    name: "",
    orchestrationCluster: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    tnaVersion: "",
    state: 0,
    workloadClusterType: 0,
  };
}

export const EdgeSlm: MessageFns<EdgeSlm> = {
  encode(message: EdgeSlm, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.orchestrationCluster !== "") {
      writer.uint32(42).string(message.orchestrationCluster);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      EdgeSlm_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.tnaVersion !== "") {
      writer.uint32(50).string(message.tnaVersion);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message.workloadClusterType !== 0) {
      writer.uint32(64).int32(message.workloadClusterType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EdgeSlm {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdgeSlm();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orchestrationCluster = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = EdgeSlm_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tnaVersion = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.workloadClusterType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EdgeSlm {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      orchestrationCluster: isSet(object.orchestrationCluster) ? globalThis.String(object.orchestrationCluster) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      tnaVersion: isSet(object.tnaVersion) ? globalThis.String(object.tnaVersion) : "",
      state: isSet(object.state) ? edgeSlm_StateFromJSON(object.state) : 0,
      workloadClusterType: isSet(object.workloadClusterType)
        ? edgeSlm_WorkloadClusterTypeFromJSON(object.workloadClusterType)
        : 0,
    };
  },

  toJSON(message: EdgeSlm): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.orchestrationCluster !== "") {
      obj.orchestrationCluster = message.orchestrationCluster;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.tnaVersion !== "") {
      obj.tnaVersion = message.tnaVersion;
    }
    if (message.state !== 0) {
      obj.state = edgeSlm_StateToJSON(message.state);
    }
    if (message.workloadClusterType !== 0) {
      obj.workloadClusterType = edgeSlm_WorkloadClusterTypeToJSON(message.workloadClusterType);
    }
    return obj;
  },

  create(base?: DeepPartial<EdgeSlm>): EdgeSlm {
    return EdgeSlm.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EdgeSlm>): EdgeSlm {
    const message = createBaseEdgeSlm();
    message.name = object.name ?? "";
    message.orchestrationCluster = object.orchestrationCluster ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.tnaVersion = object.tnaVersion ?? "";
    message.state = object.state ?? 0;
    message.workloadClusterType = object.workloadClusterType ?? 0;
    return message;
  },
};

function createBaseEdgeSlm_LabelsEntry(): EdgeSlm_LabelsEntry {
  return { key: "", value: "" };
}

export const EdgeSlm_LabelsEntry: MessageFns<EdgeSlm_LabelsEntry> = {
  encode(message: EdgeSlm_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EdgeSlm_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEdgeSlm_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EdgeSlm_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EdgeSlm_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EdgeSlm_LabelsEntry>): EdgeSlm_LabelsEntry {
    return EdgeSlm_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EdgeSlm_LabelsEntry>): EdgeSlm_LabelsEntry {
    const message = createBaseEdgeSlm_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBlueprint(): Blueprint {
  return {
    name: "",
    revisionId: "",
    sourceBlueprint: "",
    revisionCreateTime: undefined,
    approvalState: 0,
    displayName: "",
    repository: "",
    files: [],
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    sourceProvider: "",
    deploymentLevel: 0,
    rollbackSupport: false,
  };
}

export const Blueprint: MessageFns<Blueprint> = {
  encode(message: Blueprint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.revisionId !== "") {
      writer.uint32(18).string(message.revisionId);
    }
    if (message.sourceBlueprint !== "") {
      writer.uint32(26).string(message.sourceBlueprint);
    }
    if (message.revisionCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionCreateTime), writer.uint32(42).fork()).join();
    }
    if (message.approvalState !== 0) {
      writer.uint32(48).int32(message.approvalState);
    }
    if (message.displayName !== "") {
      writer.uint32(58).string(message.displayName);
    }
    if (message.repository !== "") {
      writer.uint32(66).string(message.repository);
    }
    for (const v of message.files) {
      File.encode(v!, writer.uint32(74).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Blueprint_LabelsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(90).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(98).fork()).join();
    }
    if (message.sourceProvider !== "") {
      writer.uint32(106).string(message.sourceProvider);
    }
    if (message.deploymentLevel !== 0) {
      writer.uint32(112).int32(message.deploymentLevel);
    }
    if (message.rollbackSupport !== false) {
      writer.uint32(120).bool(message.rollbackSupport);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Blueprint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlueprint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceBlueprint = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.revisionCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.approvalState = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.files.push(File.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Blueprint_LabelsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.labels[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.sourceProvider = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.deploymentLevel = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.rollbackSupport = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Blueprint {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      sourceBlueprint: isSet(object.sourceBlueprint) ? globalThis.String(object.sourceBlueprint) : "",
      revisionCreateTime: isSet(object.revisionCreateTime) ? fromJsonTimestamp(object.revisionCreateTime) : undefined,
      approvalState: isSet(object.approvalState) ? blueprint_ApprovalStateFromJSON(object.approvalState) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => File.fromJSON(e)) : [],
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      sourceProvider: isSet(object.sourceProvider) ? globalThis.String(object.sourceProvider) : "",
      deploymentLevel: isSet(object.deploymentLevel) ? deploymentLevelFromJSON(object.deploymentLevel) : 0,
      rollbackSupport: isSet(object.rollbackSupport) ? globalThis.Boolean(object.rollbackSupport) : false,
    };
  },

  toJSON(message: Blueprint): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.sourceBlueprint !== "") {
      obj.sourceBlueprint = message.sourceBlueprint;
    }
    if (message.revisionCreateTime !== undefined) {
      obj.revisionCreateTime = message.revisionCreateTime.toISOString();
    }
    if (message.approvalState !== 0) {
      obj.approvalState = blueprint_ApprovalStateToJSON(message.approvalState);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => File.toJSON(e));
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.sourceProvider !== "") {
      obj.sourceProvider = message.sourceProvider;
    }
    if (message.deploymentLevel !== 0) {
      obj.deploymentLevel = deploymentLevelToJSON(message.deploymentLevel);
    }
    if (message.rollbackSupport !== false) {
      obj.rollbackSupport = message.rollbackSupport;
    }
    return obj;
  },

  create(base?: DeepPartial<Blueprint>): Blueprint {
    return Blueprint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Blueprint>): Blueprint {
    const message = createBaseBlueprint();
    message.name = object.name ?? "";
    message.revisionId = object.revisionId ?? "";
    message.sourceBlueprint = object.sourceBlueprint ?? "";
    message.revisionCreateTime = object.revisionCreateTime ?? undefined;
    message.approvalState = object.approvalState ?? 0;
    message.displayName = object.displayName ?? "";
    message.repository = object.repository ?? "";
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.sourceProvider = object.sourceProvider ?? "";
    message.deploymentLevel = object.deploymentLevel ?? 0;
    message.rollbackSupport = object.rollbackSupport ?? false;
    return message;
  },
};

function createBaseBlueprint_LabelsEntry(): Blueprint_LabelsEntry {
  return { key: "", value: "" };
}

export const Blueprint_LabelsEntry: MessageFns<Blueprint_LabelsEntry> = {
  encode(message: Blueprint_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Blueprint_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlueprint_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Blueprint_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Blueprint_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Blueprint_LabelsEntry>): Blueprint_LabelsEntry {
    return Blueprint_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Blueprint_LabelsEntry>): Blueprint_LabelsEntry {
    const message = createBaseBlueprint_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePublicBlueprint(): PublicBlueprint {
  return { name: "", displayName: "", description: "", deploymentLevel: 0, sourceProvider: "", rollbackSupport: false };
}

export const PublicBlueprint: MessageFns<PublicBlueprint> = {
  encode(message: PublicBlueprint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.deploymentLevel !== 0) {
      writer.uint32(32).int32(message.deploymentLevel);
    }
    if (message.sourceProvider !== "") {
      writer.uint32(42).string(message.sourceProvider);
    }
    if (message.rollbackSupport !== false) {
      writer.uint32(120).bool(message.rollbackSupport);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicBlueprint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicBlueprint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.deploymentLevel = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sourceProvider = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.rollbackSupport = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicBlueprint {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      deploymentLevel: isSet(object.deploymentLevel) ? deploymentLevelFromJSON(object.deploymentLevel) : 0,
      sourceProvider: isSet(object.sourceProvider) ? globalThis.String(object.sourceProvider) : "",
      rollbackSupport: isSet(object.rollbackSupport) ? globalThis.Boolean(object.rollbackSupport) : false,
    };
  },

  toJSON(message: PublicBlueprint): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.deploymentLevel !== 0) {
      obj.deploymentLevel = deploymentLevelToJSON(message.deploymentLevel);
    }
    if (message.sourceProvider !== "") {
      obj.sourceProvider = message.sourceProvider;
    }
    if (message.rollbackSupport !== false) {
      obj.rollbackSupport = message.rollbackSupport;
    }
    return obj;
  },

  create(base?: DeepPartial<PublicBlueprint>): PublicBlueprint {
    return PublicBlueprint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublicBlueprint>): PublicBlueprint {
    const message = createBasePublicBlueprint();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.deploymentLevel = object.deploymentLevel ?? 0;
    message.sourceProvider = object.sourceProvider ?? "";
    message.rollbackSupport = object.rollbackSupport ?? false;
    return message;
  },
};

function createBaseDeployment(): Deployment {
  return {
    name: "",
    revisionId: "",
    sourceBlueprintRevision: "",
    revisionCreateTime: undefined,
    state: 0,
    displayName: "",
    repository: "",
    files: [],
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    sourceProvider: "",
    workloadCluster: "",
    deploymentLevel: 0,
    rollbackSupport: false,
  };
}

export const Deployment: MessageFns<Deployment> = {
  encode(message: Deployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.revisionId !== "") {
      writer.uint32(18).string(message.revisionId);
    }
    if (message.sourceBlueprintRevision !== "") {
      writer.uint32(26).string(message.sourceBlueprintRevision);
    }
    if (message.revisionCreateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revisionCreateTime), writer.uint32(34).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.displayName !== "") {
      writer.uint32(50).string(message.displayName);
    }
    if (message.repository !== "") {
      writer.uint32(58).string(message.repository);
    }
    for (const v of message.files) {
      File.encode(v!, writer.uint32(66).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Deployment_LabelsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(82).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(90).fork()).join();
    }
    if (message.sourceProvider !== "") {
      writer.uint32(98).string(message.sourceProvider);
    }
    if (message.workloadCluster !== "") {
      writer.uint32(106).string(message.workloadCluster);
    }
    if (message.deploymentLevel !== 0) {
      writer.uint32(112).int32(message.deploymentLevel);
    }
    if (message.rollbackSupport !== false) {
      writer.uint32(120).bool(message.rollbackSupport);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceBlueprintRevision = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.revisionCreateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.repository = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.files.push(File.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = Deployment_LabelsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.labels[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.sourceProvider = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.workloadCluster = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.deploymentLevel = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.rollbackSupport = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deployment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      sourceBlueprintRevision: isSet(object.sourceBlueprintRevision)
        ? globalThis.String(object.sourceBlueprintRevision)
        : "",
      revisionCreateTime: isSet(object.revisionCreateTime) ? fromJsonTimestamp(object.revisionCreateTime) : undefined,
      state: isSet(object.state) ? deployment_StateFromJSON(object.state) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => File.fromJSON(e)) : [],
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      sourceProvider: isSet(object.sourceProvider) ? globalThis.String(object.sourceProvider) : "",
      workloadCluster: isSet(object.workloadCluster) ? globalThis.String(object.workloadCluster) : "",
      deploymentLevel: isSet(object.deploymentLevel) ? deploymentLevelFromJSON(object.deploymentLevel) : 0,
      rollbackSupport: isSet(object.rollbackSupport) ? globalThis.Boolean(object.rollbackSupport) : false,
    };
  },

  toJSON(message: Deployment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.sourceBlueprintRevision !== "") {
      obj.sourceBlueprintRevision = message.sourceBlueprintRevision;
    }
    if (message.revisionCreateTime !== undefined) {
      obj.revisionCreateTime = message.revisionCreateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = deployment_StateToJSON(message.state);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => File.toJSON(e));
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.sourceProvider !== "") {
      obj.sourceProvider = message.sourceProvider;
    }
    if (message.workloadCluster !== "") {
      obj.workloadCluster = message.workloadCluster;
    }
    if (message.deploymentLevel !== 0) {
      obj.deploymentLevel = deploymentLevelToJSON(message.deploymentLevel);
    }
    if (message.rollbackSupport !== false) {
      obj.rollbackSupport = message.rollbackSupport;
    }
    return obj;
  },

  create(base?: DeepPartial<Deployment>): Deployment {
    return Deployment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Deployment>): Deployment {
    const message = createBaseDeployment();
    message.name = object.name ?? "";
    message.revisionId = object.revisionId ?? "";
    message.sourceBlueprintRevision = object.sourceBlueprintRevision ?? "";
    message.revisionCreateTime = object.revisionCreateTime ?? undefined;
    message.state = object.state ?? 0;
    message.displayName = object.displayName ?? "";
    message.repository = object.repository ?? "";
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.sourceProvider = object.sourceProvider ?? "";
    message.workloadCluster = object.workloadCluster ?? "";
    message.deploymentLevel = object.deploymentLevel ?? 0;
    message.rollbackSupport = object.rollbackSupport ?? false;
    return message;
  },
};

function createBaseDeployment_LabelsEntry(): Deployment_LabelsEntry {
  return { key: "", value: "" };
}

export const Deployment_LabelsEntry: MessageFns<Deployment_LabelsEntry> = {
  encode(message: Deployment_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deployment_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployment_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deployment_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Deployment_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Deployment_LabelsEntry>): Deployment_LabelsEntry {
    return Deployment_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Deployment_LabelsEntry>): Deployment_LabelsEntry {
    const message = createBaseDeployment_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHydratedDeployment(): HydratedDeployment {
  return { name: "", state: 0, files: [], workloadCluster: "" };
}

export const HydratedDeployment: MessageFns<HydratedDeployment> = {
  encode(message: HydratedDeployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    for (const v of message.files) {
      File.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.workloadCluster !== "") {
      writer.uint32(34).string(message.workloadCluster);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HydratedDeployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHydratedDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.files.push(File.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workloadCluster = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HydratedDeployment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? hydratedDeployment_StateFromJSON(object.state) : 0,
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => File.fromJSON(e)) : [],
      workloadCluster: isSet(object.workloadCluster) ? globalThis.String(object.workloadCluster) : "",
    };
  },

  toJSON(message: HydratedDeployment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = hydratedDeployment_StateToJSON(message.state);
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => File.toJSON(e));
    }
    if (message.workloadCluster !== "") {
      obj.workloadCluster = message.workloadCluster;
    }
    return obj;
  },

  create(base?: DeepPartial<HydratedDeployment>): HydratedDeployment {
    return HydratedDeployment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HydratedDeployment>): HydratedDeployment {
    const message = createBaseHydratedDeployment();
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    message.workloadCluster = object.workloadCluster ?? "";
    return message;
  },
};

function createBaseListOrchestrationClustersRequest(): ListOrchestrationClustersRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListOrchestrationClustersRequest: MessageFns<ListOrchestrationClustersRequest> = {
  encode(message: ListOrchestrationClustersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrchestrationClustersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrchestrationClustersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrchestrationClustersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListOrchestrationClustersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOrchestrationClustersRequest>): ListOrchestrationClustersRequest {
    return ListOrchestrationClustersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOrchestrationClustersRequest>): ListOrchestrationClustersRequest {
    const message = createBaseListOrchestrationClustersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListOrchestrationClustersResponse(): ListOrchestrationClustersResponse {
  return { orchestrationClusters: [], nextPageToken: "", unreachable: [] };
}

export const ListOrchestrationClustersResponse: MessageFns<ListOrchestrationClustersResponse> = {
  encode(message: ListOrchestrationClustersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orchestrationClusters) {
      OrchestrationCluster.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListOrchestrationClustersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrchestrationClustersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orchestrationClusters.push(OrchestrationCluster.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListOrchestrationClustersResponse {
    return {
      orchestrationClusters: globalThis.Array.isArray(object?.orchestrationClusters)
        ? object.orchestrationClusters.map((e: any) => OrchestrationCluster.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListOrchestrationClustersResponse): unknown {
    const obj: any = {};
    if (message.orchestrationClusters?.length) {
      obj.orchestrationClusters = message.orchestrationClusters.map((e) => OrchestrationCluster.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListOrchestrationClustersResponse>): ListOrchestrationClustersResponse {
    return ListOrchestrationClustersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListOrchestrationClustersResponse>): ListOrchestrationClustersResponse {
    const message = createBaseListOrchestrationClustersResponse();
    message.orchestrationClusters = object.orchestrationClusters?.map((e) => OrchestrationCluster.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetOrchestrationClusterRequest(): GetOrchestrationClusterRequest {
  return { name: "" };
}

export const GetOrchestrationClusterRequest: MessageFns<GetOrchestrationClusterRequest> = {
  encode(message: GetOrchestrationClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrchestrationClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrchestrationClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrchestrationClusterRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetOrchestrationClusterRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetOrchestrationClusterRequest>): GetOrchestrationClusterRequest {
    return GetOrchestrationClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrchestrationClusterRequest>): GetOrchestrationClusterRequest {
    const message = createBaseGetOrchestrationClusterRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateOrchestrationClusterRequest(): CreateOrchestrationClusterRequest {
  return { parent: "", orchestrationClusterId: "", orchestrationCluster: undefined, requestId: "" };
}

export const CreateOrchestrationClusterRequest: MessageFns<CreateOrchestrationClusterRequest> = {
  encode(message: CreateOrchestrationClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.orchestrationClusterId !== "") {
      writer.uint32(18).string(message.orchestrationClusterId);
    }
    if (message.orchestrationCluster !== undefined) {
      OrchestrationCluster.encode(message.orchestrationCluster, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateOrchestrationClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrchestrationClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orchestrationClusterId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.orchestrationCluster = OrchestrationCluster.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateOrchestrationClusterRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      orchestrationClusterId: isSet(object.orchestrationClusterId)
        ? globalThis.String(object.orchestrationClusterId)
        : "",
      orchestrationCluster: isSet(object.orchestrationCluster)
        ? OrchestrationCluster.fromJSON(object.orchestrationCluster)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateOrchestrationClusterRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.orchestrationClusterId !== "") {
      obj.orchestrationClusterId = message.orchestrationClusterId;
    }
    if (message.orchestrationCluster !== undefined) {
      obj.orchestrationCluster = OrchestrationCluster.toJSON(message.orchestrationCluster);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateOrchestrationClusterRequest>): CreateOrchestrationClusterRequest {
    return CreateOrchestrationClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateOrchestrationClusterRequest>): CreateOrchestrationClusterRequest {
    const message = createBaseCreateOrchestrationClusterRequest();
    message.parent = object.parent ?? "";
    message.orchestrationClusterId = object.orchestrationClusterId ?? "";
    message.orchestrationCluster = (object.orchestrationCluster !== undefined && object.orchestrationCluster !== null)
      ? OrchestrationCluster.fromPartial(object.orchestrationCluster)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteOrchestrationClusterRequest(): DeleteOrchestrationClusterRequest {
  return { name: "", requestId: "" };
}

export const DeleteOrchestrationClusterRequest: MessageFns<DeleteOrchestrationClusterRequest> = {
  encode(message: DeleteOrchestrationClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteOrchestrationClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteOrchestrationClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteOrchestrationClusterRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteOrchestrationClusterRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteOrchestrationClusterRequest>): DeleteOrchestrationClusterRequest {
    return DeleteOrchestrationClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteOrchestrationClusterRequest>): DeleteOrchestrationClusterRequest {
    const message = createBaseDeleteOrchestrationClusterRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListEdgeSlmsRequest(): ListEdgeSlmsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListEdgeSlmsRequest: MessageFns<ListEdgeSlmsRequest> = {
  encode(message: ListEdgeSlmsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEdgeSlmsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEdgeSlmsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEdgeSlmsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListEdgeSlmsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEdgeSlmsRequest>): ListEdgeSlmsRequest {
    return ListEdgeSlmsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEdgeSlmsRequest>): ListEdgeSlmsRequest {
    const message = createBaseListEdgeSlmsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListEdgeSlmsResponse(): ListEdgeSlmsResponse {
  return { edgeSlms: [], nextPageToken: "", unreachable: [] };
}

export const ListEdgeSlmsResponse: MessageFns<ListEdgeSlmsResponse> = {
  encode(message: ListEdgeSlmsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.edgeSlms) {
      EdgeSlm.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEdgeSlmsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEdgeSlmsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.edgeSlms.push(EdgeSlm.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEdgeSlmsResponse {
    return {
      edgeSlms: globalThis.Array.isArray(object?.edgeSlms) ? object.edgeSlms.map((e: any) => EdgeSlm.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListEdgeSlmsResponse): unknown {
    const obj: any = {};
    if (message.edgeSlms?.length) {
      obj.edgeSlms = message.edgeSlms.map((e) => EdgeSlm.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEdgeSlmsResponse>): ListEdgeSlmsResponse {
    return ListEdgeSlmsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEdgeSlmsResponse>): ListEdgeSlmsResponse {
    const message = createBaseListEdgeSlmsResponse();
    message.edgeSlms = object.edgeSlms?.map((e) => EdgeSlm.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetEdgeSlmRequest(): GetEdgeSlmRequest {
  return { name: "" };
}

export const GetEdgeSlmRequest: MessageFns<GetEdgeSlmRequest> = {
  encode(message: GetEdgeSlmRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEdgeSlmRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEdgeSlmRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEdgeSlmRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetEdgeSlmRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEdgeSlmRequest>): GetEdgeSlmRequest {
    return GetEdgeSlmRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEdgeSlmRequest>): GetEdgeSlmRequest {
    const message = createBaseGetEdgeSlmRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateEdgeSlmRequest(): CreateEdgeSlmRequest {
  return { parent: "", edgeSlmId: "", edgeSlm: undefined, requestId: "" };
}

export const CreateEdgeSlmRequest: MessageFns<CreateEdgeSlmRequest> = {
  encode(message: CreateEdgeSlmRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.edgeSlmId !== "") {
      writer.uint32(18).string(message.edgeSlmId);
    }
    if (message.edgeSlm !== undefined) {
      EdgeSlm.encode(message.edgeSlm, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEdgeSlmRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEdgeSlmRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.edgeSlmId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.edgeSlm = EdgeSlm.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEdgeSlmRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      edgeSlmId: isSet(object.edgeSlmId) ? globalThis.String(object.edgeSlmId) : "",
      edgeSlm: isSet(object.edgeSlm) ? EdgeSlm.fromJSON(object.edgeSlm) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateEdgeSlmRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.edgeSlmId !== "") {
      obj.edgeSlmId = message.edgeSlmId;
    }
    if (message.edgeSlm !== undefined) {
      obj.edgeSlm = EdgeSlm.toJSON(message.edgeSlm);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateEdgeSlmRequest>): CreateEdgeSlmRequest {
    return CreateEdgeSlmRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateEdgeSlmRequest>): CreateEdgeSlmRequest {
    const message = createBaseCreateEdgeSlmRequest();
    message.parent = object.parent ?? "";
    message.edgeSlmId = object.edgeSlmId ?? "";
    message.edgeSlm = (object.edgeSlm !== undefined && object.edgeSlm !== null)
      ? EdgeSlm.fromPartial(object.edgeSlm)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteEdgeSlmRequest(): DeleteEdgeSlmRequest {
  return { name: "", requestId: "" };
}

export const DeleteEdgeSlmRequest: MessageFns<DeleteEdgeSlmRequest> = {
  encode(message: DeleteEdgeSlmRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEdgeSlmRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEdgeSlmRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteEdgeSlmRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteEdgeSlmRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteEdgeSlmRequest>): DeleteEdgeSlmRequest {
    return DeleteEdgeSlmRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteEdgeSlmRequest>): DeleteEdgeSlmRequest {
    const message = createBaseDeleteEdgeSlmRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseCreateBlueprintRequest(): CreateBlueprintRequest {
  return { parent: "", blueprintId: "", blueprint: undefined };
}

export const CreateBlueprintRequest: MessageFns<CreateBlueprintRequest> = {
  encode(message: CreateBlueprintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.blueprint !== undefined) {
      Blueprint.encode(message.blueprint, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBlueprintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBlueprintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blueprint = Blueprint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBlueprintRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      blueprint: isSet(object.blueprint) ? Blueprint.fromJSON(object.blueprint) : undefined,
    };
  },

  toJSON(message: CreateBlueprintRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.blueprint !== undefined) {
      obj.blueprint = Blueprint.toJSON(message.blueprint);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBlueprintRequest>): CreateBlueprintRequest {
    return CreateBlueprintRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBlueprintRequest>): CreateBlueprintRequest {
    const message = createBaseCreateBlueprintRequest();
    message.parent = object.parent ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.blueprint = (object.blueprint !== undefined && object.blueprint !== null)
      ? Blueprint.fromPartial(object.blueprint)
      : undefined;
    return message;
  },
};

function createBaseUpdateBlueprintRequest(): UpdateBlueprintRequest {
  return { blueprint: undefined, updateMask: undefined };
}

export const UpdateBlueprintRequest: MessageFns<UpdateBlueprintRequest> = {
  encode(message: UpdateBlueprintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprint !== undefined) {
      Blueprint.encode(message.blueprint, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBlueprintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBlueprintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blueprint = Blueprint.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBlueprintRequest {
    return {
      blueprint: isSet(object.blueprint) ? Blueprint.fromJSON(object.blueprint) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateBlueprintRequest): unknown {
    const obj: any = {};
    if (message.blueprint !== undefined) {
      obj.blueprint = Blueprint.toJSON(message.blueprint);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateBlueprintRequest>): UpdateBlueprintRequest {
    return UpdateBlueprintRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateBlueprintRequest>): UpdateBlueprintRequest {
    const message = createBaseUpdateBlueprintRequest();
    message.blueprint = (object.blueprint !== undefined && object.blueprint !== null)
      ? Blueprint.fromPartial(object.blueprint)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetBlueprintRequest(): GetBlueprintRequest {
  return { name: "", view: 0 };
}

export const GetBlueprintRequest: MessageFns<GetBlueprintRequest> = {
  encode(message: GetBlueprintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBlueprintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBlueprintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBlueprintRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? blueprintViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetBlueprintRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = blueprintViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBlueprintRequest>): GetBlueprintRequest {
    return GetBlueprintRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBlueprintRequest>): GetBlueprintRequest {
    const message = createBaseGetBlueprintRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseDeleteBlueprintRequest(): DeleteBlueprintRequest {
  return { name: "" };
}

export const DeleteBlueprintRequest: MessageFns<DeleteBlueprintRequest> = {
  encode(message: DeleteBlueprintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteBlueprintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBlueprintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteBlueprintRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteBlueprintRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteBlueprintRequest>): DeleteBlueprintRequest {
    return DeleteBlueprintRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteBlueprintRequest>): DeleteBlueprintRequest {
    const message = createBaseDeleteBlueprintRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListBlueprintsRequest(): ListBlueprintsRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListBlueprintsRequest: MessageFns<ListBlueprintsRequest> = {
  encode(message: ListBlueprintsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBlueprintsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlueprintsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBlueprintsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListBlueprintsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBlueprintsRequest>): ListBlueprintsRequest {
    return ListBlueprintsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBlueprintsRequest>): ListBlueprintsRequest {
    const message = createBaseListBlueprintsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListBlueprintsResponse(): ListBlueprintsResponse {
  return { blueprints: [], nextPageToken: "" };
}

export const ListBlueprintsResponse: MessageFns<ListBlueprintsResponse> = {
  encode(message: ListBlueprintsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blueprints) {
      Blueprint.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBlueprintsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlueprintsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blueprints.push(Blueprint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBlueprintsResponse {
    return {
      blueprints: globalThis.Array.isArray(object?.blueprints)
        ? object.blueprints.map((e: any) => Blueprint.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListBlueprintsResponse): unknown {
    const obj: any = {};
    if (message.blueprints?.length) {
      obj.blueprints = message.blueprints.map((e) => Blueprint.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBlueprintsResponse>): ListBlueprintsResponse {
    return ListBlueprintsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBlueprintsResponse>): ListBlueprintsResponse {
    const message = createBaseListBlueprintsResponse();
    message.blueprints = object.blueprints?.map((e) => Blueprint.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseApproveBlueprintRequest(): ApproveBlueprintRequest {
  return { name: "" };
}

export const ApproveBlueprintRequest: MessageFns<ApproveBlueprintRequest> = {
  encode(message: ApproveBlueprintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApproveBlueprintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveBlueprintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveBlueprintRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ApproveBlueprintRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ApproveBlueprintRequest>): ApproveBlueprintRequest {
    return ApproveBlueprintRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApproveBlueprintRequest>): ApproveBlueprintRequest {
    const message = createBaseApproveBlueprintRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseProposeBlueprintRequest(): ProposeBlueprintRequest {
  return { name: "" };
}

export const ProposeBlueprintRequest: MessageFns<ProposeBlueprintRequest> = {
  encode(message: ProposeBlueprintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProposeBlueprintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProposeBlueprintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProposeBlueprintRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ProposeBlueprintRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ProposeBlueprintRequest>): ProposeBlueprintRequest {
    return ProposeBlueprintRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProposeBlueprintRequest>): ProposeBlueprintRequest {
    const message = createBaseProposeBlueprintRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRejectBlueprintRequest(): RejectBlueprintRequest {
  return { name: "" };
}

export const RejectBlueprintRequest: MessageFns<RejectBlueprintRequest> = {
  encode(message: RejectBlueprintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RejectBlueprintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRejectBlueprintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RejectBlueprintRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RejectBlueprintRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<RejectBlueprintRequest>): RejectBlueprintRequest {
    return RejectBlueprintRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RejectBlueprintRequest>): RejectBlueprintRequest {
    const message = createBaseRejectBlueprintRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListBlueprintRevisionsRequest(): ListBlueprintRevisionsRequest {
  return { name: "", pageSize: 0, pageToken: "" };
}

export const ListBlueprintRevisionsRequest: MessageFns<ListBlueprintRevisionsRequest> = {
  encode(message: ListBlueprintRevisionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBlueprintRevisionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlueprintRevisionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBlueprintRevisionsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListBlueprintRevisionsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBlueprintRevisionsRequest>): ListBlueprintRevisionsRequest {
    return ListBlueprintRevisionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBlueprintRevisionsRequest>): ListBlueprintRevisionsRequest {
    const message = createBaseListBlueprintRevisionsRequest();
    message.name = object.name ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListBlueprintRevisionsResponse(): ListBlueprintRevisionsResponse {
  return { blueprints: [], nextPageToken: "" };
}

export const ListBlueprintRevisionsResponse: MessageFns<ListBlueprintRevisionsResponse> = {
  encode(message: ListBlueprintRevisionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blueprints) {
      Blueprint.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBlueprintRevisionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBlueprintRevisionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blueprints.push(Blueprint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBlueprintRevisionsResponse {
    return {
      blueprints: globalThis.Array.isArray(object?.blueprints)
        ? object.blueprints.map((e: any) => Blueprint.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListBlueprintRevisionsResponse): unknown {
    const obj: any = {};
    if (message.blueprints?.length) {
      obj.blueprints = message.blueprints.map((e) => Blueprint.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBlueprintRevisionsResponse>): ListBlueprintRevisionsResponse {
    return ListBlueprintRevisionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBlueprintRevisionsResponse>): ListBlueprintRevisionsResponse {
    const message = createBaseListBlueprintRevisionsResponse();
    message.blueprints = object.blueprints?.map((e) => Blueprint.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSearchBlueprintRevisionsRequest(): SearchBlueprintRevisionsRequest {
  return { parent: "", query: "", pageSize: 0, pageToken: "" };
}

export const SearchBlueprintRevisionsRequest: MessageFns<SearchBlueprintRevisionsRequest> = {
  encode(message: SearchBlueprintRevisionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchBlueprintRevisionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchBlueprintRevisionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchBlueprintRevisionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: SearchBlueprintRevisionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchBlueprintRevisionsRequest>): SearchBlueprintRevisionsRequest {
    return SearchBlueprintRevisionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchBlueprintRevisionsRequest>): SearchBlueprintRevisionsRequest {
    const message = createBaseSearchBlueprintRevisionsRequest();
    message.parent = object.parent ?? "";
    message.query = object.query ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseSearchBlueprintRevisionsResponse(): SearchBlueprintRevisionsResponse {
  return { blueprints: [], nextPageToken: "" };
}

export const SearchBlueprintRevisionsResponse: MessageFns<SearchBlueprintRevisionsResponse> = {
  encode(message: SearchBlueprintRevisionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blueprints) {
      Blueprint.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchBlueprintRevisionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchBlueprintRevisionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blueprints.push(Blueprint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchBlueprintRevisionsResponse {
    return {
      blueprints: globalThis.Array.isArray(object?.blueprints)
        ? object.blueprints.map((e: any) => Blueprint.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchBlueprintRevisionsResponse): unknown {
    const obj: any = {};
    if (message.blueprints?.length) {
      obj.blueprints = message.blueprints.map((e) => Blueprint.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchBlueprintRevisionsResponse>): SearchBlueprintRevisionsResponse {
    return SearchBlueprintRevisionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchBlueprintRevisionsResponse>): SearchBlueprintRevisionsResponse {
    const message = createBaseSearchBlueprintRevisionsResponse();
    message.blueprints = object.blueprints?.map((e) => Blueprint.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDiscardBlueprintChangesRequest(): DiscardBlueprintChangesRequest {
  return { name: "" };
}

export const DiscardBlueprintChangesRequest: MessageFns<DiscardBlueprintChangesRequest> = {
  encode(message: DiscardBlueprintChangesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscardBlueprintChangesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscardBlueprintChangesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiscardBlueprintChangesRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DiscardBlueprintChangesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DiscardBlueprintChangesRequest>): DiscardBlueprintChangesRequest {
    return DiscardBlueprintChangesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiscardBlueprintChangesRequest>): DiscardBlueprintChangesRequest {
    const message = createBaseDiscardBlueprintChangesRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDiscardBlueprintChangesResponse(): DiscardBlueprintChangesResponse {
  return {};
}

export const DiscardBlueprintChangesResponse: MessageFns<DiscardBlueprintChangesResponse> = {
  encode(_: DiscardBlueprintChangesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscardBlueprintChangesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscardBlueprintChangesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DiscardBlueprintChangesResponse {
    return {};
  },

  toJSON(_: DiscardBlueprintChangesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DiscardBlueprintChangesResponse>): DiscardBlueprintChangesResponse {
    return DiscardBlueprintChangesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DiscardBlueprintChangesResponse>): DiscardBlueprintChangesResponse {
    const message = createBaseDiscardBlueprintChangesResponse();
    return message;
  },
};

function createBaseListPublicBlueprintsRequest(): ListPublicBlueprintsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListPublicBlueprintsRequest: MessageFns<ListPublicBlueprintsRequest> = {
  encode(message: ListPublicBlueprintsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPublicBlueprintsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPublicBlueprintsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPublicBlueprintsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListPublicBlueprintsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPublicBlueprintsRequest>): ListPublicBlueprintsRequest {
    return ListPublicBlueprintsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPublicBlueprintsRequest>): ListPublicBlueprintsRequest {
    const message = createBaseListPublicBlueprintsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListPublicBlueprintsResponse(): ListPublicBlueprintsResponse {
  return { publicBlueprints: [], nextPageToken: "" };
}

export const ListPublicBlueprintsResponse: MessageFns<ListPublicBlueprintsResponse> = {
  encode(message: ListPublicBlueprintsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.publicBlueprints) {
      PublicBlueprint.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPublicBlueprintsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPublicBlueprintsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.publicBlueprints.push(PublicBlueprint.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPublicBlueprintsResponse {
    return {
      publicBlueprints: globalThis.Array.isArray(object?.publicBlueprints)
        ? object.publicBlueprints.map((e: any) => PublicBlueprint.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListPublicBlueprintsResponse): unknown {
    const obj: any = {};
    if (message.publicBlueprints?.length) {
      obj.publicBlueprints = message.publicBlueprints.map((e) => PublicBlueprint.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListPublicBlueprintsResponse>): ListPublicBlueprintsResponse {
    return ListPublicBlueprintsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPublicBlueprintsResponse>): ListPublicBlueprintsResponse {
    const message = createBaseListPublicBlueprintsResponse();
    message.publicBlueprints = object.publicBlueprints?.map((e) => PublicBlueprint.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetPublicBlueprintRequest(): GetPublicBlueprintRequest {
  return { name: "" };
}

export const GetPublicBlueprintRequest: MessageFns<GetPublicBlueprintRequest> = {
  encode(message: GetPublicBlueprintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPublicBlueprintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPublicBlueprintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPublicBlueprintRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetPublicBlueprintRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetPublicBlueprintRequest>): GetPublicBlueprintRequest {
    return GetPublicBlueprintRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetPublicBlueprintRequest>): GetPublicBlueprintRequest {
    const message = createBaseGetPublicBlueprintRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateDeploymentRequest(): CreateDeploymentRequest {
  return { parent: "", deploymentId: "", deployment: undefined };
}

export const CreateDeploymentRequest: MessageFns<CreateDeploymentRequest> = {
  encode(message: CreateDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.deploymentId !== "") {
      writer.uint32(18).string(message.deploymentId);
    }
    if (message.deployment !== undefined) {
      Deployment.encode(message.deployment, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deployment = Deployment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDeploymentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : "",
      deployment: isSet(object.deployment) ? Deployment.fromJSON(object.deployment) : undefined,
    };
  },

  toJSON(message: CreateDeploymentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.deploymentId !== "") {
      obj.deploymentId = message.deploymentId;
    }
    if (message.deployment !== undefined) {
      obj.deployment = Deployment.toJSON(message.deployment);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateDeploymentRequest>): CreateDeploymentRequest {
    return CreateDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateDeploymentRequest>): CreateDeploymentRequest {
    const message = createBaseCreateDeploymentRequest();
    message.parent = object.parent ?? "";
    message.deploymentId = object.deploymentId ?? "";
    message.deployment = (object.deployment !== undefined && object.deployment !== null)
      ? Deployment.fromPartial(object.deployment)
      : undefined;
    return message;
  },
};

function createBaseUpdateDeploymentRequest(): UpdateDeploymentRequest {
  return { deployment: undefined, updateMask: undefined };
}

export const UpdateDeploymentRequest: MessageFns<UpdateDeploymentRequest> = {
  encode(message: UpdateDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deployment !== undefined) {
      Deployment.encode(message.deployment, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deployment = Deployment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDeploymentRequest {
    return {
      deployment: isSet(object.deployment) ? Deployment.fromJSON(object.deployment) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateDeploymentRequest): unknown {
    const obj: any = {};
    if (message.deployment !== undefined) {
      obj.deployment = Deployment.toJSON(message.deployment);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDeploymentRequest>): UpdateDeploymentRequest {
    return UpdateDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDeploymentRequest>): UpdateDeploymentRequest {
    const message = createBaseUpdateDeploymentRequest();
    message.deployment = (object.deployment !== undefined && object.deployment !== null)
      ? Deployment.fromPartial(object.deployment)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetDeploymentRequest(): GetDeploymentRequest {
  return { name: "", view: 0 };
}

export const GetDeploymentRequest: MessageFns<GetDeploymentRequest> = {
  encode(message: GetDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDeploymentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? deploymentViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetDeploymentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = deploymentViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetDeploymentRequest>): GetDeploymentRequest {
    return GetDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDeploymentRequest>): GetDeploymentRequest {
    const message = createBaseGetDeploymentRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseRemoveDeploymentRequest(): RemoveDeploymentRequest {
  return { name: "" };
}

export const RemoveDeploymentRequest: MessageFns<RemoveDeploymentRequest> = {
  encode(message: RemoveDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveDeploymentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RemoveDeploymentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveDeploymentRequest>): RemoveDeploymentRequest {
    return RemoveDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveDeploymentRequest>): RemoveDeploymentRequest {
    const message = createBaseRemoveDeploymentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListDeploymentsRequest(): ListDeploymentsRequest {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListDeploymentsRequest: MessageFns<ListDeploymentsRequest> = {
  encode(message: ListDeploymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeploymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeploymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeploymentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDeploymentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDeploymentsRequest>): ListDeploymentsRequest {
    return ListDeploymentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDeploymentsRequest>): ListDeploymentsRequest {
    const message = createBaseListDeploymentsRequest();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDeploymentsResponse(): ListDeploymentsResponse {
  return { deployments: [], nextPageToken: "" };
}

export const ListDeploymentsResponse: MessageFns<ListDeploymentsResponse> = {
  encode(message: ListDeploymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deployments) {
      Deployment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeploymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeploymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deployments.push(Deployment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeploymentsResponse {
    return {
      deployments: globalThis.Array.isArray(object?.deployments)
        ? object.deployments.map((e: any) => Deployment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDeploymentsResponse): unknown {
    const obj: any = {};
    if (message.deployments?.length) {
      obj.deployments = message.deployments.map((e) => Deployment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDeploymentsResponse>): ListDeploymentsResponse {
    return ListDeploymentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDeploymentsResponse>): ListDeploymentsResponse {
    const message = createBaseListDeploymentsResponse();
    message.deployments = object.deployments?.map((e) => Deployment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListDeploymentRevisionsRequest(): ListDeploymentRevisionsRequest {
  return { name: "", pageSize: 0, pageToken: "" };
}

export const ListDeploymentRevisionsRequest: MessageFns<ListDeploymentRevisionsRequest> = {
  encode(message: ListDeploymentRevisionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeploymentRevisionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeploymentRevisionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeploymentRevisionsRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListDeploymentRevisionsRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDeploymentRevisionsRequest>): ListDeploymentRevisionsRequest {
    return ListDeploymentRevisionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDeploymentRevisionsRequest>): ListDeploymentRevisionsRequest {
    const message = createBaseListDeploymentRevisionsRequest();
    message.name = object.name ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListDeploymentRevisionsResponse(): ListDeploymentRevisionsResponse {
  return { deployments: [], nextPageToken: "" };
}

export const ListDeploymentRevisionsResponse: MessageFns<ListDeploymentRevisionsResponse> = {
  encode(message: ListDeploymentRevisionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deployments) {
      Deployment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDeploymentRevisionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDeploymentRevisionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deployments.push(Deployment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDeploymentRevisionsResponse {
    return {
      deployments: globalThis.Array.isArray(object?.deployments)
        ? object.deployments.map((e: any) => Deployment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDeploymentRevisionsResponse): unknown {
    const obj: any = {};
    if (message.deployments?.length) {
      obj.deployments = message.deployments.map((e) => Deployment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDeploymentRevisionsResponse>): ListDeploymentRevisionsResponse {
    return ListDeploymentRevisionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDeploymentRevisionsResponse>): ListDeploymentRevisionsResponse {
    const message = createBaseListDeploymentRevisionsResponse();
    message.deployments = object.deployments?.map((e) => Deployment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSearchDeploymentRevisionsRequest(): SearchDeploymentRevisionsRequest {
  return { parent: "", query: "", pageSize: 0, pageToken: "" };
}

export const SearchDeploymentRevisionsRequest: MessageFns<SearchDeploymentRevisionsRequest> = {
  encode(message: SearchDeploymentRevisionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchDeploymentRevisionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchDeploymentRevisionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchDeploymentRevisionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: SearchDeploymentRevisionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchDeploymentRevisionsRequest>): SearchDeploymentRevisionsRequest {
    return SearchDeploymentRevisionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchDeploymentRevisionsRequest>): SearchDeploymentRevisionsRequest {
    const message = createBaseSearchDeploymentRevisionsRequest();
    message.parent = object.parent ?? "";
    message.query = object.query ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseSearchDeploymentRevisionsResponse(): SearchDeploymentRevisionsResponse {
  return { deployments: [], nextPageToken: "" };
}

export const SearchDeploymentRevisionsResponse: MessageFns<SearchDeploymentRevisionsResponse> = {
  encode(message: SearchDeploymentRevisionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.deployments) {
      Deployment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchDeploymentRevisionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchDeploymentRevisionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deployments.push(Deployment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchDeploymentRevisionsResponse {
    return {
      deployments: globalThis.Array.isArray(object?.deployments)
        ? object.deployments.map((e: any) => Deployment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchDeploymentRevisionsResponse): unknown {
    const obj: any = {};
    if (message.deployments?.length) {
      obj.deployments = message.deployments.map((e) => Deployment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchDeploymentRevisionsResponse>): SearchDeploymentRevisionsResponse {
    return SearchDeploymentRevisionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchDeploymentRevisionsResponse>): SearchDeploymentRevisionsResponse {
    const message = createBaseSearchDeploymentRevisionsResponse();
    message.deployments = object.deployments?.map((e) => Deployment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDiscardDeploymentChangesRequest(): DiscardDeploymentChangesRequest {
  return { name: "" };
}

export const DiscardDeploymentChangesRequest: MessageFns<DiscardDeploymentChangesRequest> = {
  encode(message: DiscardDeploymentChangesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscardDeploymentChangesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscardDeploymentChangesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiscardDeploymentChangesRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DiscardDeploymentChangesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DiscardDeploymentChangesRequest>): DiscardDeploymentChangesRequest {
    return DiscardDeploymentChangesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiscardDeploymentChangesRequest>): DiscardDeploymentChangesRequest {
    const message = createBaseDiscardDeploymentChangesRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDiscardDeploymentChangesResponse(): DiscardDeploymentChangesResponse {
  return {};
}

export const DiscardDeploymentChangesResponse: MessageFns<DiscardDeploymentChangesResponse> = {
  encode(_: DiscardDeploymentChangesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscardDeploymentChangesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscardDeploymentChangesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DiscardDeploymentChangesResponse {
    return {};
  },

  toJSON(_: DiscardDeploymentChangesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DiscardDeploymentChangesResponse>): DiscardDeploymentChangesResponse {
    return DiscardDeploymentChangesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DiscardDeploymentChangesResponse>): DiscardDeploymentChangesResponse {
    const message = createBaseDiscardDeploymentChangesResponse();
    return message;
  },
};

function createBaseApplyDeploymentRequest(): ApplyDeploymentRequest {
  return { name: "" };
}

export const ApplyDeploymentRequest: MessageFns<ApplyDeploymentRequest> = {
  encode(message: ApplyDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyDeploymentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ApplyDeploymentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ApplyDeploymentRequest>): ApplyDeploymentRequest {
    return ApplyDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplyDeploymentRequest>): ApplyDeploymentRequest {
    const message = createBaseApplyDeploymentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseComputeDeploymentStatusRequest(): ComputeDeploymentStatusRequest {
  return { name: "" };
}

export const ComputeDeploymentStatusRequest: MessageFns<ComputeDeploymentStatusRequest> = {
  encode(message: ComputeDeploymentStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeDeploymentStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeDeploymentStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeDeploymentStatusRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ComputeDeploymentStatusRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeDeploymentStatusRequest>): ComputeDeploymentStatusRequest {
    return ComputeDeploymentStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeDeploymentStatusRequest>): ComputeDeploymentStatusRequest {
    const message = createBaseComputeDeploymentStatusRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseComputeDeploymentStatusResponse(): ComputeDeploymentStatusResponse {
  return { name: "", aggregatedStatus: 0, resourceStatuses: [] };
}

export const ComputeDeploymentStatusResponse: MessageFns<ComputeDeploymentStatusResponse> = {
  encode(message: ComputeDeploymentStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.aggregatedStatus !== 0) {
      writer.uint32(16).int32(message.aggregatedStatus);
    }
    for (const v of message.resourceStatuses) {
      ResourceStatus.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeDeploymentStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeDeploymentStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.aggregatedStatus = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resourceStatuses.push(ResourceStatus.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeDeploymentStatusResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      aggregatedStatus: isSet(object.aggregatedStatus) ? statusFromJSON(object.aggregatedStatus) : 0,
      resourceStatuses: globalThis.Array.isArray(object?.resourceStatuses)
        ? object.resourceStatuses.map((e: any) => ResourceStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ComputeDeploymentStatusResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.aggregatedStatus !== 0) {
      obj.aggregatedStatus = statusToJSON(message.aggregatedStatus);
    }
    if (message.resourceStatuses?.length) {
      obj.resourceStatuses = message.resourceStatuses.map((e) => ResourceStatus.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeDeploymentStatusResponse>): ComputeDeploymentStatusResponse {
    return ComputeDeploymentStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeDeploymentStatusResponse>): ComputeDeploymentStatusResponse {
    const message = createBaseComputeDeploymentStatusResponse();
    message.name = object.name ?? "";
    message.aggregatedStatus = object.aggregatedStatus ?? 0;
    message.resourceStatuses = object.resourceStatuses?.map((e) => ResourceStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRollbackDeploymentRequest(): RollbackDeploymentRequest {
  return { name: "", revisionId: "" };
}

export const RollbackDeploymentRequest: MessageFns<RollbackDeploymentRequest> = {
  encode(message: RollbackDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.revisionId !== "") {
      writer.uint32(18).string(message.revisionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RollbackDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRollbackDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revisionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RollbackDeploymentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
    };
  },

  toJSON(message: RollbackDeploymentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    return obj;
  },

  create(base?: DeepPartial<RollbackDeploymentRequest>): RollbackDeploymentRequest {
    return RollbackDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RollbackDeploymentRequest>): RollbackDeploymentRequest {
    const message = createBaseRollbackDeploymentRequest();
    message.name = object.name ?? "";
    message.revisionId = object.revisionId ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseGetHydratedDeploymentRequest(): GetHydratedDeploymentRequest {
  return { name: "" };
}

export const GetHydratedDeploymentRequest: MessageFns<GetHydratedDeploymentRequest> = {
  encode(message: GetHydratedDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHydratedDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHydratedDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHydratedDeploymentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetHydratedDeploymentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetHydratedDeploymentRequest>): GetHydratedDeploymentRequest {
    return GetHydratedDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHydratedDeploymentRequest>): GetHydratedDeploymentRequest {
    const message = createBaseGetHydratedDeploymentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListHydratedDeploymentsRequest(): ListHydratedDeploymentsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListHydratedDeploymentsRequest: MessageFns<ListHydratedDeploymentsRequest> = {
  encode(message: ListHydratedDeploymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHydratedDeploymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHydratedDeploymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHydratedDeploymentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListHydratedDeploymentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListHydratedDeploymentsRequest>): ListHydratedDeploymentsRequest {
    return ListHydratedDeploymentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListHydratedDeploymentsRequest>): ListHydratedDeploymentsRequest {
    const message = createBaseListHydratedDeploymentsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListHydratedDeploymentsResponse(): ListHydratedDeploymentsResponse {
  return { hydratedDeployments: [], nextPageToken: "" };
}

export const ListHydratedDeploymentsResponse: MessageFns<ListHydratedDeploymentsResponse> = {
  encode(message: ListHydratedDeploymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.hydratedDeployments) {
      HydratedDeployment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHydratedDeploymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHydratedDeploymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hydratedDeployments.push(HydratedDeployment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHydratedDeploymentsResponse {
    return {
      hydratedDeployments: globalThis.Array.isArray(object?.hydratedDeployments)
        ? object.hydratedDeployments.map((e: any) => HydratedDeployment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListHydratedDeploymentsResponse): unknown {
    const obj: any = {};
    if (message.hydratedDeployments?.length) {
      obj.hydratedDeployments = message.hydratedDeployments.map((e) => HydratedDeployment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListHydratedDeploymentsResponse>): ListHydratedDeploymentsResponse {
    return ListHydratedDeploymentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListHydratedDeploymentsResponse>): ListHydratedDeploymentsResponse {
    const message = createBaseListHydratedDeploymentsResponse();
    message.hydratedDeployments = object.hydratedDeployments?.map((e) => HydratedDeployment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseUpdateHydratedDeploymentRequest(): UpdateHydratedDeploymentRequest {
  return { hydratedDeployment: undefined, updateMask: undefined };
}

export const UpdateHydratedDeploymentRequest: MessageFns<UpdateHydratedDeploymentRequest> = {
  encode(message: UpdateHydratedDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hydratedDeployment !== undefined) {
      HydratedDeployment.encode(message.hydratedDeployment, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateHydratedDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateHydratedDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hydratedDeployment = HydratedDeployment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateHydratedDeploymentRequest {
    return {
      hydratedDeployment: isSet(object.hydratedDeployment)
        ? HydratedDeployment.fromJSON(object.hydratedDeployment)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateHydratedDeploymentRequest): unknown {
    const obj: any = {};
    if (message.hydratedDeployment !== undefined) {
      obj.hydratedDeployment = HydratedDeployment.toJSON(message.hydratedDeployment);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateHydratedDeploymentRequest>): UpdateHydratedDeploymentRequest {
    return UpdateHydratedDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateHydratedDeploymentRequest>): UpdateHydratedDeploymentRequest {
    const message = createBaseUpdateHydratedDeploymentRequest();
    message.hydratedDeployment = (object.hydratedDeployment !== undefined && object.hydratedDeployment !== null)
      ? HydratedDeployment.fromPartial(object.hydratedDeployment)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseApplyHydratedDeploymentRequest(): ApplyHydratedDeploymentRequest {
  return { name: "" };
}

export const ApplyHydratedDeploymentRequest: MessageFns<ApplyHydratedDeploymentRequest> = {
  encode(message: ApplyHydratedDeploymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyHydratedDeploymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyHydratedDeploymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyHydratedDeploymentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ApplyHydratedDeploymentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ApplyHydratedDeploymentRequest>): ApplyHydratedDeploymentRequest {
    return ApplyHydratedDeploymentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApplyHydratedDeploymentRequest>): ApplyHydratedDeploymentRequest {
    const message = createBaseApplyHydratedDeploymentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseManagementConfig(): ManagementConfig {
  return { standardManagementConfig: undefined, fullManagementConfig: undefined };
}

export const ManagementConfig: MessageFns<ManagementConfig> = {
  encode(message: ManagementConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.standardManagementConfig !== undefined) {
      StandardManagementConfig.encode(message.standardManagementConfig, writer.uint32(10).fork()).join();
    }
    if (message.fullManagementConfig !== undefined) {
      FullManagementConfig.encode(message.fullManagementConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManagementConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManagementConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.standardManagementConfig = StandardManagementConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fullManagementConfig = FullManagementConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManagementConfig {
    return {
      standardManagementConfig: isSet(object.standardManagementConfig)
        ? StandardManagementConfig.fromJSON(object.standardManagementConfig)
        : undefined,
      fullManagementConfig: isSet(object.fullManagementConfig)
        ? FullManagementConfig.fromJSON(object.fullManagementConfig)
        : undefined,
    };
  },

  toJSON(message: ManagementConfig): unknown {
    const obj: any = {};
    if (message.standardManagementConfig !== undefined) {
      obj.standardManagementConfig = StandardManagementConfig.toJSON(message.standardManagementConfig);
    }
    if (message.fullManagementConfig !== undefined) {
      obj.fullManagementConfig = FullManagementConfig.toJSON(message.fullManagementConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ManagementConfig>): ManagementConfig {
    return ManagementConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManagementConfig>): ManagementConfig {
    const message = createBaseManagementConfig();
    message.standardManagementConfig =
      (object.standardManagementConfig !== undefined && object.standardManagementConfig !== null)
        ? StandardManagementConfig.fromPartial(object.standardManagementConfig)
        : undefined;
    message.fullManagementConfig = (object.fullManagementConfig !== undefined && object.fullManagementConfig !== null)
      ? FullManagementConfig.fromPartial(object.fullManagementConfig)
      : undefined;
    return message;
  },
};

function createBaseStandardManagementConfig(): StandardManagementConfig {
  return {
    network: "",
    subnet: "",
    masterIpv4CidrBlock: "",
    clusterCidrBlock: "",
    servicesCidrBlock: "",
    clusterNamedRange: "",
    servicesNamedRange: "",
    masterAuthorizedNetworksConfig: undefined,
  };
}

export const StandardManagementConfig: MessageFns<StandardManagementConfig> = {
  encode(message: StandardManagementConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.subnet !== "") {
      writer.uint32(18).string(message.subnet);
    }
    if (message.masterIpv4CidrBlock !== "") {
      writer.uint32(26).string(message.masterIpv4CidrBlock);
    }
    if (message.clusterCidrBlock !== "") {
      writer.uint32(34).string(message.clusterCidrBlock);
    }
    if (message.servicesCidrBlock !== "") {
      writer.uint32(42).string(message.servicesCidrBlock);
    }
    if (message.clusterNamedRange !== "") {
      writer.uint32(50).string(message.clusterNamedRange);
    }
    if (message.servicesNamedRange !== "") {
      writer.uint32(58).string(message.servicesNamedRange);
    }
    if (message.masterAuthorizedNetworksConfig !== undefined) {
      MasterAuthorizedNetworksConfig.encode(message.masterAuthorizedNetworksConfig, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StandardManagementConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStandardManagementConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnet = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.masterIpv4CidrBlock = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clusterCidrBlock = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.servicesCidrBlock = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clusterNamedRange = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.servicesNamedRange = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.masterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StandardManagementConfig {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnet: isSet(object.subnet) ? globalThis.String(object.subnet) : "",
      masterIpv4CidrBlock: isSet(object.masterIpv4CidrBlock) ? globalThis.String(object.masterIpv4CidrBlock) : "",
      clusterCidrBlock: isSet(object.clusterCidrBlock) ? globalThis.String(object.clusterCidrBlock) : "",
      servicesCidrBlock: isSet(object.servicesCidrBlock) ? globalThis.String(object.servicesCidrBlock) : "",
      clusterNamedRange: isSet(object.clusterNamedRange) ? globalThis.String(object.clusterNamedRange) : "",
      servicesNamedRange: isSet(object.servicesNamedRange) ? globalThis.String(object.servicesNamedRange) : "",
      masterAuthorizedNetworksConfig: isSet(object.masterAuthorizedNetworksConfig)
        ? MasterAuthorizedNetworksConfig.fromJSON(object.masterAuthorizedNetworksConfig)
        : undefined,
    };
  },

  toJSON(message: StandardManagementConfig): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnet !== "") {
      obj.subnet = message.subnet;
    }
    if (message.masterIpv4CidrBlock !== "") {
      obj.masterIpv4CidrBlock = message.masterIpv4CidrBlock;
    }
    if (message.clusterCidrBlock !== "") {
      obj.clusterCidrBlock = message.clusterCidrBlock;
    }
    if (message.servicesCidrBlock !== "") {
      obj.servicesCidrBlock = message.servicesCidrBlock;
    }
    if (message.clusterNamedRange !== "") {
      obj.clusterNamedRange = message.clusterNamedRange;
    }
    if (message.servicesNamedRange !== "") {
      obj.servicesNamedRange = message.servicesNamedRange;
    }
    if (message.masterAuthorizedNetworksConfig !== undefined) {
      obj.masterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.toJSON(
        message.masterAuthorizedNetworksConfig,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<StandardManagementConfig>): StandardManagementConfig {
    return StandardManagementConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StandardManagementConfig>): StandardManagementConfig {
    const message = createBaseStandardManagementConfig();
    message.network = object.network ?? "";
    message.subnet = object.subnet ?? "";
    message.masterIpv4CidrBlock = object.masterIpv4CidrBlock ?? "";
    message.clusterCidrBlock = object.clusterCidrBlock ?? "";
    message.servicesCidrBlock = object.servicesCidrBlock ?? "";
    message.clusterNamedRange = object.clusterNamedRange ?? "";
    message.servicesNamedRange = object.servicesNamedRange ?? "";
    message.masterAuthorizedNetworksConfig =
      (object.masterAuthorizedNetworksConfig !== undefined && object.masterAuthorizedNetworksConfig !== null)
        ? MasterAuthorizedNetworksConfig.fromPartial(object.masterAuthorizedNetworksConfig)
        : undefined;
    return message;
  },
};

function createBaseFullManagementConfig(): FullManagementConfig {
  return {
    network: "",
    subnet: "",
    masterIpv4CidrBlock: "",
    clusterCidrBlock: "",
    servicesCidrBlock: "",
    clusterNamedRange: "",
    servicesNamedRange: "",
    masterAuthorizedNetworksConfig: undefined,
  };
}

export const FullManagementConfig: MessageFns<FullManagementConfig> = {
  encode(message: FullManagementConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.subnet !== "") {
      writer.uint32(18).string(message.subnet);
    }
    if (message.masterIpv4CidrBlock !== "") {
      writer.uint32(26).string(message.masterIpv4CidrBlock);
    }
    if (message.clusterCidrBlock !== "") {
      writer.uint32(34).string(message.clusterCidrBlock);
    }
    if (message.servicesCidrBlock !== "") {
      writer.uint32(42).string(message.servicesCidrBlock);
    }
    if (message.clusterNamedRange !== "") {
      writer.uint32(50).string(message.clusterNamedRange);
    }
    if (message.servicesNamedRange !== "") {
      writer.uint32(58).string(message.servicesNamedRange);
    }
    if (message.masterAuthorizedNetworksConfig !== undefined) {
      MasterAuthorizedNetworksConfig.encode(message.masterAuthorizedNetworksConfig, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FullManagementConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFullManagementConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnet = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.masterIpv4CidrBlock = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clusterCidrBlock = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.servicesCidrBlock = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clusterNamedRange = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.servicesNamedRange = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.masterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FullManagementConfig {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnet: isSet(object.subnet) ? globalThis.String(object.subnet) : "",
      masterIpv4CidrBlock: isSet(object.masterIpv4CidrBlock) ? globalThis.String(object.masterIpv4CidrBlock) : "",
      clusterCidrBlock: isSet(object.clusterCidrBlock) ? globalThis.String(object.clusterCidrBlock) : "",
      servicesCidrBlock: isSet(object.servicesCidrBlock) ? globalThis.String(object.servicesCidrBlock) : "",
      clusterNamedRange: isSet(object.clusterNamedRange) ? globalThis.String(object.clusterNamedRange) : "",
      servicesNamedRange: isSet(object.servicesNamedRange) ? globalThis.String(object.servicesNamedRange) : "",
      masterAuthorizedNetworksConfig: isSet(object.masterAuthorizedNetworksConfig)
        ? MasterAuthorizedNetworksConfig.fromJSON(object.masterAuthorizedNetworksConfig)
        : undefined,
    };
  },

  toJSON(message: FullManagementConfig): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnet !== "") {
      obj.subnet = message.subnet;
    }
    if (message.masterIpv4CidrBlock !== "") {
      obj.masterIpv4CidrBlock = message.masterIpv4CidrBlock;
    }
    if (message.clusterCidrBlock !== "") {
      obj.clusterCidrBlock = message.clusterCidrBlock;
    }
    if (message.servicesCidrBlock !== "") {
      obj.servicesCidrBlock = message.servicesCidrBlock;
    }
    if (message.clusterNamedRange !== "") {
      obj.clusterNamedRange = message.clusterNamedRange;
    }
    if (message.servicesNamedRange !== "") {
      obj.servicesNamedRange = message.servicesNamedRange;
    }
    if (message.masterAuthorizedNetworksConfig !== undefined) {
      obj.masterAuthorizedNetworksConfig = MasterAuthorizedNetworksConfig.toJSON(
        message.masterAuthorizedNetworksConfig,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<FullManagementConfig>): FullManagementConfig {
    return FullManagementConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FullManagementConfig>): FullManagementConfig {
    const message = createBaseFullManagementConfig();
    message.network = object.network ?? "";
    message.subnet = object.subnet ?? "";
    message.masterIpv4CidrBlock = object.masterIpv4CidrBlock ?? "";
    message.clusterCidrBlock = object.clusterCidrBlock ?? "";
    message.servicesCidrBlock = object.servicesCidrBlock ?? "";
    message.clusterNamedRange = object.clusterNamedRange ?? "";
    message.servicesNamedRange = object.servicesNamedRange ?? "";
    message.masterAuthorizedNetworksConfig =
      (object.masterAuthorizedNetworksConfig !== undefined && object.masterAuthorizedNetworksConfig !== null)
        ? MasterAuthorizedNetworksConfig.fromPartial(object.masterAuthorizedNetworksConfig)
        : undefined;
    return message;
  },
};

function createBaseMasterAuthorizedNetworksConfig(): MasterAuthorizedNetworksConfig {
  return { cidrBlocks: [] };
}

export const MasterAuthorizedNetworksConfig: MessageFns<MasterAuthorizedNetworksConfig> = {
  encode(message: MasterAuthorizedNetworksConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cidrBlocks) {
      MasterAuthorizedNetworksConfig_CidrBlock.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MasterAuthorizedNetworksConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMasterAuthorizedNetworksConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cidrBlocks.push(MasterAuthorizedNetworksConfig_CidrBlock.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MasterAuthorizedNetworksConfig {
    return {
      cidrBlocks: globalThis.Array.isArray(object?.cidrBlocks)
        ? object.cidrBlocks.map((e: any) => MasterAuthorizedNetworksConfig_CidrBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MasterAuthorizedNetworksConfig): unknown {
    const obj: any = {};
    if (message.cidrBlocks?.length) {
      obj.cidrBlocks = message.cidrBlocks.map((e) => MasterAuthorizedNetworksConfig_CidrBlock.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MasterAuthorizedNetworksConfig>): MasterAuthorizedNetworksConfig {
    return MasterAuthorizedNetworksConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MasterAuthorizedNetworksConfig>): MasterAuthorizedNetworksConfig {
    const message = createBaseMasterAuthorizedNetworksConfig();
    message.cidrBlocks = object.cidrBlocks?.map((e) => MasterAuthorizedNetworksConfig_CidrBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMasterAuthorizedNetworksConfig_CidrBlock(): MasterAuthorizedNetworksConfig_CidrBlock {
  return { displayName: "", cidrBlock: "" };
}

export const MasterAuthorizedNetworksConfig_CidrBlock: MessageFns<MasterAuthorizedNetworksConfig_CidrBlock> = {
  encode(message: MasterAuthorizedNetworksConfig_CidrBlock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.cidrBlock !== "") {
      writer.uint32(18).string(message.cidrBlock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MasterAuthorizedNetworksConfig_CidrBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMasterAuthorizedNetworksConfig_CidrBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cidrBlock = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MasterAuthorizedNetworksConfig_CidrBlock {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      cidrBlock: isSet(object.cidrBlock) ? globalThis.String(object.cidrBlock) : "",
    };
  },

  toJSON(message: MasterAuthorizedNetworksConfig_CidrBlock): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.cidrBlock !== "") {
      obj.cidrBlock = message.cidrBlock;
    }
    return obj;
  },

  create(base?: DeepPartial<MasterAuthorizedNetworksConfig_CidrBlock>): MasterAuthorizedNetworksConfig_CidrBlock {
    return MasterAuthorizedNetworksConfig_CidrBlock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MasterAuthorizedNetworksConfig_CidrBlock>): MasterAuthorizedNetworksConfig_CidrBlock {
    const message = createBaseMasterAuthorizedNetworksConfig_CidrBlock();
    message.displayName = object.displayName ?? "";
    message.cidrBlock = object.cidrBlock ?? "";
    return message;
  },
};

function createBaseFile(): File {
  return { path: "", content: "", deleted: false, editable: false };
}

export const File: MessageFns<File> = {
  encode(message: File, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.deleted !== false) {
      writer.uint32(24).bool(message.deleted);
    }
    if (message.editable !== false) {
      writer.uint32(32).bool(message.editable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): File {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.deleted = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.editable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): File {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      deleted: isSet(object.deleted) ? globalThis.Boolean(object.deleted) : false,
      editable: isSet(object.editable) ? globalThis.Boolean(object.editable) : false,
    };
  },

  toJSON(message: File): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.deleted !== false) {
      obj.deleted = message.deleted;
    }
    if (message.editable !== false) {
      obj.editable = message.editable;
    }
    return obj;
  },

  create(base?: DeepPartial<File>): File {
    return File.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<File>): File {
    const message = createBaseFile();
    message.path = object.path ?? "";
    message.content = object.content ?? "";
    message.deleted = object.deleted ?? false;
    message.editable = object.editable ?? false;
    return message;
  },
};

function createBaseResourceStatus(): ResourceStatus {
  return {
    name: "",
    resourceNamespace: "",
    group: "",
    version: "",
    kind: "",
    resourceType: 0,
    status: 0,
    nfDeployStatus: undefined,
  };
}

export const ResourceStatus: MessageFns<ResourceStatus> = {
  encode(message: ResourceStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.resourceNamespace !== "") {
      writer.uint32(18).string(message.resourceNamespace);
    }
    if (message.group !== "") {
      writer.uint32(26).string(message.group);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    if (message.kind !== "") {
      writer.uint32(42).string(message.kind);
    }
    if (message.resourceType !== 0) {
      writer.uint32(48).int32(message.resourceType);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.nfDeployStatus !== undefined) {
      NFDeployStatus.encode(message.nfDeployStatus, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceNamespace = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.group = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.resourceType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.nfDeployStatus = NFDeployStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceStatus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      resourceNamespace: isSet(object.resourceNamespace) ? globalThis.String(object.resourceNamespace) : "",
      group: isSet(object.group) ? globalThis.String(object.group) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      resourceType: isSet(object.resourceType) ? resourceTypeFromJSON(object.resourceType) : 0,
      status: isSet(object.status) ? statusFromJSON(object.status) : 0,
      nfDeployStatus: isSet(object.nfDeployStatus) ? NFDeployStatus.fromJSON(object.nfDeployStatus) : undefined,
    };
  },

  toJSON(message: ResourceStatus): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.resourceNamespace !== "") {
      obj.resourceNamespace = message.resourceNamespace;
    }
    if (message.group !== "") {
      obj.group = message.group;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.resourceType !== 0) {
      obj.resourceType = resourceTypeToJSON(message.resourceType);
    }
    if (message.status !== 0) {
      obj.status = statusToJSON(message.status);
    }
    if (message.nfDeployStatus !== undefined) {
      obj.nfDeployStatus = NFDeployStatus.toJSON(message.nfDeployStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceStatus>): ResourceStatus {
    return ResourceStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceStatus>): ResourceStatus {
    const message = createBaseResourceStatus();
    message.name = object.name ?? "";
    message.resourceNamespace = object.resourceNamespace ?? "";
    message.group = object.group ?? "";
    message.version = object.version ?? "";
    message.kind = object.kind ?? "";
    message.resourceType = object.resourceType ?? 0;
    message.status = object.status ?? 0;
    message.nfDeployStatus = (object.nfDeployStatus !== undefined && object.nfDeployStatus !== null)
      ? NFDeployStatus.fromPartial(object.nfDeployStatus)
      : undefined;
    return message;
  },
};

function createBaseNFDeployStatus(): NFDeployStatus {
  return { targetedNfs: 0, readyNfs: 0, sites: [] };
}

export const NFDeployStatus: MessageFns<NFDeployStatus> = {
  encode(message: NFDeployStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetedNfs !== 0) {
      writer.uint32(8).int32(message.targetedNfs);
    }
    if (message.readyNfs !== 0) {
      writer.uint32(16).int32(message.readyNfs);
    }
    for (const v of message.sites) {
      NFDeploySiteStatus.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NFDeployStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNFDeployStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetedNfs = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.readyNfs = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sites.push(NFDeploySiteStatus.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NFDeployStatus {
    return {
      targetedNfs: isSet(object.targetedNfs) ? globalThis.Number(object.targetedNfs) : 0,
      readyNfs: isSet(object.readyNfs) ? globalThis.Number(object.readyNfs) : 0,
      sites: globalThis.Array.isArray(object?.sites)
        ? object.sites.map((e: any) => NFDeploySiteStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NFDeployStatus): unknown {
    const obj: any = {};
    if (message.targetedNfs !== 0) {
      obj.targetedNfs = Math.round(message.targetedNfs);
    }
    if (message.readyNfs !== 0) {
      obj.readyNfs = Math.round(message.readyNfs);
    }
    if (message.sites?.length) {
      obj.sites = message.sites.map((e) => NFDeploySiteStatus.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NFDeployStatus>): NFDeployStatus {
    return NFDeployStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NFDeployStatus>): NFDeployStatus {
    const message = createBaseNFDeployStatus();
    message.targetedNfs = object.targetedNfs ?? 0;
    message.readyNfs = object.readyNfs ?? 0;
    message.sites = object.sites?.map((e) => NFDeploySiteStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNFDeploySiteStatus(): NFDeploySiteStatus {
  return { site: "", pendingDeletion: false, hydration: undefined, workload: undefined };
}

export const NFDeploySiteStatus: MessageFns<NFDeploySiteStatus> = {
  encode(message: NFDeploySiteStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.site !== "") {
      writer.uint32(10).string(message.site);
    }
    if (message.pendingDeletion !== false) {
      writer.uint32(16).bool(message.pendingDeletion);
    }
    if (message.hydration !== undefined) {
      HydrationStatus.encode(message.hydration, writer.uint32(26).fork()).join();
    }
    if (message.workload !== undefined) {
      WorkloadStatus.encode(message.workload, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NFDeploySiteStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNFDeploySiteStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.site = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pendingDeletion = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.hydration = HydrationStatus.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workload = WorkloadStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NFDeploySiteStatus {
    return {
      site: isSet(object.site) ? globalThis.String(object.site) : "",
      pendingDeletion: isSet(object.pendingDeletion) ? globalThis.Boolean(object.pendingDeletion) : false,
      hydration: isSet(object.hydration) ? HydrationStatus.fromJSON(object.hydration) : undefined,
      workload: isSet(object.workload) ? WorkloadStatus.fromJSON(object.workload) : undefined,
    };
  },

  toJSON(message: NFDeploySiteStatus): unknown {
    const obj: any = {};
    if (message.site !== "") {
      obj.site = message.site;
    }
    if (message.pendingDeletion !== false) {
      obj.pendingDeletion = message.pendingDeletion;
    }
    if (message.hydration !== undefined) {
      obj.hydration = HydrationStatus.toJSON(message.hydration);
    }
    if (message.workload !== undefined) {
      obj.workload = WorkloadStatus.toJSON(message.workload);
    }
    return obj;
  },

  create(base?: DeepPartial<NFDeploySiteStatus>): NFDeploySiteStatus {
    return NFDeploySiteStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NFDeploySiteStatus>): NFDeploySiteStatus {
    const message = createBaseNFDeploySiteStatus();
    message.site = object.site ?? "";
    message.pendingDeletion = object.pendingDeletion ?? false;
    message.hydration = (object.hydration !== undefined && object.hydration !== null)
      ? HydrationStatus.fromPartial(object.hydration)
      : undefined;
    message.workload = (object.workload !== undefined && object.workload !== null)
      ? WorkloadStatus.fromPartial(object.workload)
      : undefined;
    return message;
  },
};

function createBaseHydrationStatus(): HydrationStatus {
  return { siteVersion: undefined, status: "" };
}

export const HydrationStatus: MessageFns<HydrationStatus> = {
  encode(message: HydrationStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.siteVersion !== undefined) {
      SiteVersion.encode(message.siteVersion, writer.uint32(10).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HydrationStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHydrationStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.siteVersion = SiteVersion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HydrationStatus {
    return {
      siteVersion: isSet(object.siteVersion) ? SiteVersion.fromJSON(object.siteVersion) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: HydrationStatus): unknown {
    const obj: any = {};
    if (message.siteVersion !== undefined) {
      obj.siteVersion = SiteVersion.toJSON(message.siteVersion);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create(base?: DeepPartial<HydrationStatus>): HydrationStatus {
    return HydrationStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HydrationStatus>): HydrationStatus {
    const message = createBaseHydrationStatus();
    message.siteVersion = (object.siteVersion !== undefined && object.siteVersion !== null)
      ? SiteVersion.fromPartial(object.siteVersion)
      : undefined;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseSiteVersion(): SiteVersion {
  return { nfVendor: "", nfType: "", nfVersion: "" };
}

export const SiteVersion: MessageFns<SiteVersion> = {
  encode(message: SiteVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nfVendor !== "") {
      writer.uint32(10).string(message.nfVendor);
    }
    if (message.nfType !== "") {
      writer.uint32(18).string(message.nfType);
    }
    if (message.nfVersion !== "") {
      writer.uint32(26).string(message.nfVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SiteVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSiteVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nfVendor = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nfType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nfVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SiteVersion {
    return {
      nfVendor: isSet(object.nfVendor) ? globalThis.String(object.nfVendor) : "",
      nfType: isSet(object.nfType) ? globalThis.String(object.nfType) : "",
      nfVersion: isSet(object.nfVersion) ? globalThis.String(object.nfVersion) : "",
    };
  },

  toJSON(message: SiteVersion): unknown {
    const obj: any = {};
    if (message.nfVendor !== "") {
      obj.nfVendor = message.nfVendor;
    }
    if (message.nfType !== "") {
      obj.nfType = message.nfType;
    }
    if (message.nfVersion !== "") {
      obj.nfVersion = message.nfVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<SiteVersion>): SiteVersion {
    return SiteVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SiteVersion>): SiteVersion {
    const message = createBaseSiteVersion();
    message.nfVendor = object.nfVendor ?? "";
    message.nfType = object.nfType ?? "";
    message.nfVersion = object.nfVersion ?? "";
    return message;
  },
};

function createBaseWorkloadStatus(): WorkloadStatus {
  return { siteVersion: undefined, status: "" };
}

export const WorkloadStatus: MessageFns<WorkloadStatus> = {
  encode(message: WorkloadStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.siteVersion !== undefined) {
      SiteVersion.encode(message.siteVersion, writer.uint32(10).fork()).join();
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkloadStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkloadStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.siteVersion = SiteVersion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkloadStatus {
    return {
      siteVersion: isSet(object.siteVersion) ? SiteVersion.fromJSON(object.siteVersion) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: WorkloadStatus): unknown {
    const obj: any = {};
    if (message.siteVersion !== undefined) {
      obj.siteVersion = SiteVersion.toJSON(message.siteVersion);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkloadStatus>): WorkloadStatus {
    return WorkloadStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkloadStatus>): WorkloadStatus {
    const message = createBaseWorkloadStatus();
    message.siteVersion = (object.siteVersion !== undefined && object.siteVersion !== null)
      ? SiteVersion.fromPartial(object.siteVersion)
      : undefined;
    message.status = object.status ?? "";
    return message;
  },
};

/**
 * TelcoAutomation Service manages the control plane cluster a.k.a.
 * Orchestration Cluster (GKE cluster with config controller) of TNA. It also
 * exposes blueprint APIs which manages the lifecycle of blueprints that control
 * the infrastructure setup (e.g GDCE clusters) and deployment of network
 * functions.
 */
export type TelcoAutomationDefinition = typeof TelcoAutomationDefinition;
export const TelcoAutomationDefinition = {
  name: "TelcoAutomation",
  fullName: "google.cloud.telcoautomation.v1.TelcoAutomation",
  methods: {
    /** Lists OrchestrationClusters in a given project and location. */
    listOrchestrationClusters: {
      name: "ListOrchestrationClusters",
      requestType: ListOrchestrationClustersRequest,
      requestStream: false,
      responseType: ListOrchestrationClustersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single OrchestrationCluster. */
    getOrchestrationCluster: {
      name: "GetOrchestrationCluster",
      requestType: GetOrchestrationClusterRequest,
      requestStream: false,
      responseType: OrchestrationCluster,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new OrchestrationCluster in a given project and location. */
    createOrchestrationCluster: {
      name: "CreateOrchestrationCluster",
      requestType: CreateOrchestrationClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              41,
              10,
              20,
              79,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              53,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              44,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              82,
              58,
              21,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a single OrchestrationCluster. */
    deleteOrchestrationCluster: {
      name: "DeleteOrchestrationCluster",
      requestType: DeleteOrchestrationClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              42,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists EdgeSlms in a given project and location. */
    listEdgeSlms: {
      name: "ListEdgeSlms",
      requestType: ListEdgeSlmsRequest,
      requestStream: false,
      responseType: ListEdgeSlmsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              100,
              103,
              101,
              83,
              108,
              109,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a single EdgeSlm. */
    getEdgeSlm: {
      name: "GetEdgeSlm",
      requestType: GetEdgeSlmRequest,
      requestStream: false,
      responseType: EdgeSlm,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              46,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              100,
              103,
              101,
              83,
              108,
              109,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new EdgeSlm in a given project and location. */
    createEdgeSlm: {
      name: "CreateEdgeSlm",
      requestType: CreateEdgeSlmRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              28,
              10,
              7,
              69,
              100,
              103,
              101,
              83,
              108,
              109,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              27,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              101,
              100,
              103,
              101,
              95,
              115,
              108,
              109,
              44,
              101,
              100,
              103,
              101,
              95,
              115,
              108,
              109,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              56,
              58,
              8,
              101,
              100,
              103,
              101,
              95,
              115,
              108,
              109,
              34,
              44,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              100,
              103,
              101,
              83,
              108,
              109,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a single EdgeSlm. */
    deleteEdgeSlm: {
      name: "DeleteEdgeSlm",
      requestType: DeleteEdgeSlmRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              46,
              42,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              100,
              103,
              101,
              83,
              108,
              109,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a blueprint. */
    createBlueprint: {
      name: "CreateBlueprint",
      requestType: CreateBlueprintRequest,
      requestStream: false,
      responseType: Blueprint,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              29,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              44,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              83,
              58,
              9,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              34,
              70,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a blueprint. */
    updateBlueprint: {
      name: "UpdateBlueprint",
      requestType: UpdateBlueprintRequest,
      requestStream: false,
      responseType: Blueprint,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              93,
              58,
              9,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              50,
              80,
              47,
              118,
              49,
              47,
              123,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the requested blueprint. */
    getBlueprint: {
      name: "GetBlueprint",
      requestType: GetBlueprintRequest,
      requestStream: false,
      responseType: Blueprint,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              72,
              18,
              70,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a blueprint and all its revisions. */
    deleteBlueprint: {
      name: "DeleteBlueprint",
      requestType: DeleteBlueprintRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              72,
              42,
              70,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** List all blueprints. */
    listBlueprints: {
      name: "ListBlueprints",
      requestType: ListBlueprintsRequest,
      requestStream: false,
      responseType: ListBlueprintsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              72,
              18,
              70,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Approves a blueprint and commits a new revision. */
    approveBlueprint: {
      name: "ApproveBlueprint",
      requestType: ApproveBlueprintRequest,
      requestStream: false,
      responseType: Blueprint,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              83,
              58,
              1,
              42,
              34,
              78,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              112,
              112,
              114,
              111,
              118,
              101,
            ]),
          ],
        },
      },
    },
    /** Proposes a blueprint for approval of changes. */
    proposeBlueprint: {
      name: "ProposeBlueprint",
      requestType: ProposeBlueprintRequest,
      requestStream: false,
      responseType: Blueprint,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              83,
              58,
              1,
              42,
              34,
              78,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              112,
              114,
              111,
              112,
              111,
              115,
              101,
            ]),
          ],
        },
      },
    },
    /** Rejects a blueprint revision proposal and flips it back to Draft state. */
    rejectBlueprint: {
      name: "RejectBlueprint",
      requestType: RejectBlueprintRequest,
      requestStream: false,
      responseType: Blueprint,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              82,
              58,
              1,
              42,
              34,
              77,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              106,
              101,
              99,
              116,
            ]),
          ],
        },
      },
    },
    /** List blueprint revisions of a given blueprint. */
    listBlueprintRevisions: {
      name: "ListBlueprintRevisions",
      requestType: ListBlueprintRevisionsRequest,
      requestStream: false,
      responseType: ListBlueprintRevisionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              86,
              18,
              84,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              108,
              105,
              115,
              116,
              82,
              101,
              118,
              105,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Searches across blueprint revisions. */
    searchBlueprintRevisions: {
      name: "SearchBlueprintRevisions",
      requestType: SearchBlueprintRevisionsRequest,
      requestStream: false,
      responseType: SearchBlueprintRevisionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 112, 97, 114, 101, 110, 116, 44, 113, 117, 101, 114, 121])],
          578365826: [
            Buffer.from([
              88,
              18,
              86,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              82,
              101,
              118,
              105,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Searches across deployment revisions. */
    searchDeploymentRevisions: {
      name: "SearchDeploymentRevisions",
      requestType: SearchDeploymentRevisionsRequest,
      requestStream: false,
      responseType: SearchDeploymentRevisionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 112, 97, 114, 101, 110, 116, 44, 113, 117, 101, 114, 121])],
          578365826: [
            Buffer.from([
              89,
              18,
              87,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              82,
              101,
              118,
              105,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Discards the changes in a blueprint and reverts the blueprint to the last
     * approved blueprint revision. No changes take place if a blueprint does not
     * have revisions.
     */
    discardBlueprintChanges: {
      name: "DiscardBlueprintChanges",
      requestType: DiscardBlueprintChangesRequest,
      requestStream: false,
      responseType: DiscardBlueprintChangesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              83,
              58,
              1,
              42,
              34,
              78,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              98,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              115,
              99,
              97,
              114,
              100,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the blueprints in TNA's public catalog. Default page size = 20,
     * Max Page Size = 100.
     */
    listPublicBlueprints: {
      name: "ListPublicBlueprints",
      requestType: ListPublicBlueprintsRequest,
      requestStream: false,
      responseType: ListPublicBlueprintsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              112,
              117,
              98,
              108,
              105,
              99,
              66,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns the requested public blueprint. */
    getPublicBlueprint: {
      name: "GetPublicBlueprint",
      requestType: GetPublicBlueprintRequest,
      requestStream: false,
      responseType: PublicBlueprint,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              112,
              117,
              98,
              108,
              105,
              99,
              66,
              108,
              117,
              101,
              112,
              114,
              105,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a deployment. */
    createDeployment: {
      name: "CreateDeployment",
      requestType: CreateDeploymentRequest,
      requestStream: false,
      responseType: Deployment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              44,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              85,
              58,
              10,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              34,
              71,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a deployment. */
    updateDeployment: {
      name: "UpdateDeployment",
      requestType: UpdateDeploymentRequest,
      requestStream: false,
      responseType: Deployment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              96,
              58,
              10,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              50,
              82,
              47,
              118,
              49,
              47,
              123,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Returns the requested deployment. */
    getDeployment: {
      name: "GetDeployment",
      requestType: GetDeploymentRequest,
      requestStream: false,
      responseType: Deployment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              73,
              18,
              71,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Removes the deployment by marking it as DELETING. Post which deployment and
     * it's revisions gets deleted.
     */
    removeDeployment: {
      name: "RemoveDeployment",
      requestType: RemoveDeploymentRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              83,
              58,
              1,
              42,
              34,
              78,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              109,
              111,
              118,
              101,
            ]),
          ],
        },
      },
    },
    /** List all deployments. */
    listDeployments: {
      name: "ListDeployments",
      requestType: ListDeploymentsRequest,
      requestStream: false,
      responseType: ListDeploymentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              73,
              18,
              71,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** List deployment revisions of a given deployment. */
    listDeploymentRevisions: {
      name: "ListDeploymentRevisions",
      requestType: ListDeploymentRevisionsRequest,
      requestStream: false,
      responseType: ListDeploymentRevisionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              87,
              18,
              85,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              108,
              105,
              115,
              116,
              82,
              101,
              118,
              105,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Discards the changes in a deployment and reverts the deployment to the last
     * approved deployment revision. No changes take place if a deployment does
     * not have revisions.
     */
    discardDeploymentChanges: {
      name: "DiscardDeploymentChanges",
      requestType: DiscardDeploymentChangesRequest,
      requestStream: false,
      responseType: DiscardDeploymentChangesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              84,
              58,
              1,
              42,
              34,
              79,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              115,
              99,
              97,
              114,
              100,
            ]),
          ],
        },
      },
    },
    /** Applies the deployment's YAML files to the parent orchestration cluster. */
    applyDeployment: {
      name: "ApplyDeployment",
      requestType: ApplyDeploymentRequest,
      requestStream: false,
      responseType: Deployment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              82,
              58,
              1,
              42,
              34,
              77,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              112,
              112,
              108,
              121,
            ]),
          ],
        },
      },
    },
    /** Returns the requested deployment status. */
    computeDeploymentStatus: {
      name: "ComputeDeploymentStatus",
      requestType: ComputeDeploymentStatusRequest,
      requestStream: false,
      responseType: ComputeDeploymentStatusResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              97,
              18,
              95,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              109,
              112,
              117,
              116,
              101,
              68,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              83,
              116,
              97,
              116,
              117,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Rollback the active deployment to the given past approved deployment
     * revision.
     */
    rollbackDeployment: {
      name: "RollbackDeployment",
      requestType: RollbackDeploymentRequest,
      requestStream: false,
      responseType: Deployment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([16, 110, 97, 109, 101, 44, 114, 101, 118, 105, 115, 105, 111, 110, 95, 105, 100])],
          578365826: [
            Buffer.from([
              85,
              58,
              1,
              42,
              34,
              80,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              111,
              108,
              108,
              98,
              97,
              99,
              107,
            ]),
          ],
        },
      },
    },
    /** Returns the requested hydrated deployment. */
    getHydratedDeployment: {
      name: "GetHydratedDeployment",
      requestType: GetHydratedDeploymentRequest,
      requestStream: false,
      responseType: HydratedDeployment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              95,
              18,
              93,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              104,
              121,
              100,
              114,
              97,
              116,
              101,
              100,
              68,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** List all hydrated deployments present under a deployment. */
    listHydratedDeployments: {
      name: "ListHydratedDeployments",
      requestType: ListHydratedDeploymentsRequest,
      requestStream: false,
      responseType: ListHydratedDeploymentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              95,
              18,
              93,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              104,
              121,
              100,
              114,
              97,
              116,
              101,
              100,
              68,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a hydrated deployment. */
    updateHydratedDeployment: {
      name: "UpdateHydratedDeployment",
      requestType: UpdateHydratedDeploymentRequest,
      requestStream: false,
      responseType: HydratedDeployment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              31,
              104,
              121,
              100,
              114,
              97,
              116,
              101,
              100,
              95,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              136,
              1,
              58,
              19,
              104,
              121,
              100,
              114,
              97,
              116,
              101,
              100,
              95,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              50,
              113,
              47,
              118,
              49,
              47,
              123,
              104,
              121,
              100,
              114,
              97,
              116,
              101,
              100,
              95,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              104,
              121,
              100,
              114,
              97,
              116,
              101,
              100,
              68,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Applies a hydrated deployment to a workload cluster. */
    applyHydratedDeployment: {
      name: "ApplyHydratedDeployment",
      requestType: ApplyHydratedDeploymentRequest,
      requestStream: false,
      responseType: HydratedDeployment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              104,
              58,
              1,
              42,
              34,
              99,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              111,
              114,
              99,
              104,
              101,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              47,
              100,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              47,
              104,
              121,
              100,
              114,
              97,
              116,
              101,
              100,
              68,
              101,
              112,
              108,
              111,
              121,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              112,
              112,
              108,
              121,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TelcoAutomationServiceImplementation<CallContextExt = {}> {
  /** Lists OrchestrationClusters in a given project and location. */
  listOrchestrationClusters(
    request: ListOrchestrationClustersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListOrchestrationClustersResponse>>;
  /** Gets details of a single OrchestrationCluster. */
  getOrchestrationCluster(
    request: GetOrchestrationClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<OrchestrationCluster>>;
  /** Creates a new OrchestrationCluster in a given project and location. */
  createOrchestrationCluster(
    request: CreateOrchestrationClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a single OrchestrationCluster. */
  deleteOrchestrationCluster(
    request: DeleteOrchestrationClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists EdgeSlms in a given project and location. */
  listEdgeSlms(
    request: ListEdgeSlmsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEdgeSlmsResponse>>;
  /** Gets details of a single EdgeSlm. */
  getEdgeSlm(request: GetEdgeSlmRequest, context: CallContext & CallContextExt): Promise<DeepPartial<EdgeSlm>>;
  /** Creates a new EdgeSlm in a given project and location. */
  createEdgeSlm(request: CreateEdgeSlmRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a single EdgeSlm. */
  deleteEdgeSlm(request: DeleteEdgeSlmRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Creates a blueprint. */
  createBlueprint(
    request: CreateBlueprintRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Blueprint>>;
  /** Updates a blueprint. */
  updateBlueprint(
    request: UpdateBlueprintRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Blueprint>>;
  /** Returns the requested blueprint. */
  getBlueprint(request: GetBlueprintRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Blueprint>>;
  /** Deletes a blueprint and all its revisions. */
  deleteBlueprint(request: DeleteBlueprintRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** List all blueprints. */
  listBlueprints(
    request: ListBlueprintsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListBlueprintsResponse>>;
  /** Approves a blueprint and commits a new revision. */
  approveBlueprint(
    request: ApproveBlueprintRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Blueprint>>;
  /** Proposes a blueprint for approval of changes. */
  proposeBlueprint(
    request: ProposeBlueprintRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Blueprint>>;
  /** Rejects a blueprint revision proposal and flips it back to Draft state. */
  rejectBlueprint(
    request: RejectBlueprintRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Blueprint>>;
  /** List blueprint revisions of a given blueprint. */
  listBlueprintRevisions(
    request: ListBlueprintRevisionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListBlueprintRevisionsResponse>>;
  /** Searches across blueprint revisions. */
  searchBlueprintRevisions(
    request: SearchBlueprintRevisionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchBlueprintRevisionsResponse>>;
  /** Searches across deployment revisions. */
  searchDeploymentRevisions(
    request: SearchDeploymentRevisionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchDeploymentRevisionsResponse>>;
  /**
   * Discards the changes in a blueprint and reverts the blueprint to the last
   * approved blueprint revision. No changes take place if a blueprint does not
   * have revisions.
   */
  discardBlueprintChanges(
    request: DiscardBlueprintChangesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DiscardBlueprintChangesResponse>>;
  /**
   * Lists the blueprints in TNA's public catalog. Default page size = 20,
   * Max Page Size = 100.
   */
  listPublicBlueprints(
    request: ListPublicBlueprintsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPublicBlueprintsResponse>>;
  /** Returns the requested public blueprint. */
  getPublicBlueprint(
    request: GetPublicBlueprintRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PublicBlueprint>>;
  /** Creates a deployment. */
  createDeployment(
    request: CreateDeploymentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Deployment>>;
  /** Updates a deployment. */
  updateDeployment(
    request: UpdateDeploymentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Deployment>>;
  /** Returns the requested deployment. */
  getDeployment(request: GetDeploymentRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Deployment>>;
  /**
   * Removes the deployment by marking it as DELETING. Post which deployment and
   * it's revisions gets deleted.
   */
  removeDeployment(
    request: RemoveDeploymentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** List all deployments. */
  listDeployments(
    request: ListDeploymentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDeploymentsResponse>>;
  /** List deployment revisions of a given deployment. */
  listDeploymentRevisions(
    request: ListDeploymentRevisionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDeploymentRevisionsResponse>>;
  /**
   * Discards the changes in a deployment and reverts the deployment to the last
   * approved deployment revision. No changes take place if a deployment does
   * not have revisions.
   */
  discardDeploymentChanges(
    request: DiscardDeploymentChangesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<DiscardDeploymentChangesResponse>>;
  /** Applies the deployment's YAML files to the parent orchestration cluster. */
  applyDeployment(
    request: ApplyDeploymentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Deployment>>;
  /** Returns the requested deployment status. */
  computeDeploymentStatus(
    request: ComputeDeploymentStatusRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ComputeDeploymentStatusResponse>>;
  /**
   * Rollback the active deployment to the given past approved deployment
   * revision.
   */
  rollbackDeployment(
    request: RollbackDeploymentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Deployment>>;
  /** Returns the requested hydrated deployment. */
  getHydratedDeployment(
    request: GetHydratedDeploymentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<HydratedDeployment>>;
  /** List all hydrated deployments present under a deployment. */
  listHydratedDeployments(
    request: ListHydratedDeploymentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListHydratedDeploymentsResponse>>;
  /** Updates a hydrated deployment. */
  updateHydratedDeployment(
    request: UpdateHydratedDeploymentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<HydratedDeployment>>;
  /** Applies a hydrated deployment to a workload cluster. */
  applyHydratedDeployment(
    request: ApplyHydratedDeploymentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<HydratedDeployment>>;
}

export interface TelcoAutomationClient<CallOptionsExt = {}> {
  /** Lists OrchestrationClusters in a given project and location. */
  listOrchestrationClusters(
    request: DeepPartial<ListOrchestrationClustersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListOrchestrationClustersResponse>;
  /** Gets details of a single OrchestrationCluster. */
  getOrchestrationCluster(
    request: DeepPartial<GetOrchestrationClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<OrchestrationCluster>;
  /** Creates a new OrchestrationCluster in a given project and location. */
  createOrchestrationCluster(
    request: DeepPartial<CreateOrchestrationClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a single OrchestrationCluster. */
  deleteOrchestrationCluster(
    request: DeepPartial<DeleteOrchestrationClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists EdgeSlms in a given project and location. */
  listEdgeSlms(
    request: DeepPartial<ListEdgeSlmsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEdgeSlmsResponse>;
  /** Gets details of a single EdgeSlm. */
  getEdgeSlm(request: DeepPartial<GetEdgeSlmRequest>, options?: CallOptions & CallOptionsExt): Promise<EdgeSlm>;
  /** Creates a new EdgeSlm in a given project and location. */
  createEdgeSlm(request: DeepPartial<CreateEdgeSlmRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a single EdgeSlm. */
  deleteEdgeSlm(request: DeepPartial<DeleteEdgeSlmRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Creates a blueprint. */
  createBlueprint(
    request: DeepPartial<CreateBlueprintRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Blueprint>;
  /** Updates a blueprint. */
  updateBlueprint(
    request: DeepPartial<UpdateBlueprintRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Blueprint>;
  /** Returns the requested blueprint. */
  getBlueprint(request: DeepPartial<GetBlueprintRequest>, options?: CallOptions & CallOptionsExt): Promise<Blueprint>;
  /** Deletes a blueprint and all its revisions. */
  deleteBlueprint(request: DeepPartial<DeleteBlueprintRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** List all blueprints. */
  listBlueprints(
    request: DeepPartial<ListBlueprintsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListBlueprintsResponse>;
  /** Approves a blueprint and commits a new revision. */
  approveBlueprint(
    request: DeepPartial<ApproveBlueprintRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Blueprint>;
  /** Proposes a blueprint for approval of changes. */
  proposeBlueprint(
    request: DeepPartial<ProposeBlueprintRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Blueprint>;
  /** Rejects a blueprint revision proposal and flips it back to Draft state. */
  rejectBlueprint(
    request: DeepPartial<RejectBlueprintRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Blueprint>;
  /** List blueprint revisions of a given blueprint. */
  listBlueprintRevisions(
    request: DeepPartial<ListBlueprintRevisionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListBlueprintRevisionsResponse>;
  /** Searches across blueprint revisions. */
  searchBlueprintRevisions(
    request: DeepPartial<SearchBlueprintRevisionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchBlueprintRevisionsResponse>;
  /** Searches across deployment revisions. */
  searchDeploymentRevisions(
    request: DeepPartial<SearchDeploymentRevisionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchDeploymentRevisionsResponse>;
  /**
   * Discards the changes in a blueprint and reverts the blueprint to the last
   * approved blueprint revision. No changes take place if a blueprint does not
   * have revisions.
   */
  discardBlueprintChanges(
    request: DeepPartial<DiscardBlueprintChangesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DiscardBlueprintChangesResponse>;
  /**
   * Lists the blueprints in TNA's public catalog. Default page size = 20,
   * Max Page Size = 100.
   */
  listPublicBlueprints(
    request: DeepPartial<ListPublicBlueprintsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPublicBlueprintsResponse>;
  /** Returns the requested public blueprint. */
  getPublicBlueprint(
    request: DeepPartial<GetPublicBlueprintRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PublicBlueprint>;
  /** Creates a deployment. */
  createDeployment(
    request: DeepPartial<CreateDeploymentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Deployment>;
  /** Updates a deployment. */
  updateDeployment(
    request: DeepPartial<UpdateDeploymentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Deployment>;
  /** Returns the requested deployment. */
  getDeployment(
    request: DeepPartial<GetDeploymentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Deployment>;
  /**
   * Removes the deployment by marking it as DELETING. Post which deployment and
   * it's revisions gets deleted.
   */
  removeDeployment(
    request: DeepPartial<RemoveDeploymentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** List all deployments. */
  listDeployments(
    request: DeepPartial<ListDeploymentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDeploymentsResponse>;
  /** List deployment revisions of a given deployment. */
  listDeploymentRevisions(
    request: DeepPartial<ListDeploymentRevisionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDeploymentRevisionsResponse>;
  /**
   * Discards the changes in a deployment and reverts the deployment to the last
   * approved deployment revision. No changes take place if a deployment does
   * not have revisions.
   */
  discardDeploymentChanges(
    request: DeepPartial<DiscardDeploymentChangesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DiscardDeploymentChangesResponse>;
  /** Applies the deployment's YAML files to the parent orchestration cluster. */
  applyDeployment(
    request: DeepPartial<ApplyDeploymentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Deployment>;
  /** Returns the requested deployment status. */
  computeDeploymentStatus(
    request: DeepPartial<ComputeDeploymentStatusRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ComputeDeploymentStatusResponse>;
  /**
   * Rollback the active deployment to the given past approved deployment
   * revision.
   */
  rollbackDeployment(
    request: DeepPartial<RollbackDeploymentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Deployment>;
  /** Returns the requested hydrated deployment. */
  getHydratedDeployment(
    request: DeepPartial<GetHydratedDeploymentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<HydratedDeployment>;
  /** List all hydrated deployments present under a deployment. */
  listHydratedDeployments(
    request: DeepPartial<ListHydratedDeploymentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListHydratedDeploymentsResponse>;
  /** Updates a hydrated deployment. */
  updateHydratedDeployment(
    request: DeepPartial<UpdateHydratedDeploymentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<HydratedDeployment>;
  /** Applies a hydrated deployment to a workload cluster. */
  applyHydratedDeployment(
    request: DeepPartial<ApplyHydratedDeploymentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<HydratedDeployment>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
