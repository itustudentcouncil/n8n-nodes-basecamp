// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/asset/v1/assets.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Binding, Policy } from "../../../iam/v1/policy.js";
import { AccessLevel } from "../../../identity/accesscontextmanager/v1/access_level.js";
import { AccessPolicy } from "../../../identity/accesscontextmanager/v1/access_policy.js";
import { ServicePerimeter } from "../../../identity/accesscontextmanager/v1/service_perimeter.js";
import { Struct } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Code, codeFromJSON, codeToJSON } from "../../../rpc/code.js";
import { Policy as Policy1 } from "../../orgpolicy/v1/orgpolicy.js";
import { Inventory } from "../../osconfig/v1/inventory.js";

export const protobufPackage = "google.cloud.asset.v1";

/**
 * An asset in Google Cloud and its temporal metadata, including the time window
 * when it was observed and its status during that window.
 */
export interface TemporalAsset {
  /** The time window when the asset data and state was observed. */
  window:
    | TimeWindow
    | undefined;
  /** Whether the asset has been deleted or not. */
  deleted: boolean;
  /** An asset in Google Cloud. */
  asset:
    | Asset
    | undefined;
  /** State of prior_asset. */
  priorAssetState: TemporalAsset_PriorAssetState;
  /**
   * Prior copy of the asset. Populated if prior_asset_state is PRESENT.
   * Currently this is only set for responses in Real-Time Feed.
   */
  priorAsset: Asset | undefined;
}

/** State of prior asset. */
export enum TemporalAsset_PriorAssetState {
  /** PRIOR_ASSET_STATE_UNSPECIFIED - prior_asset is not applicable for the current asset. */
  PRIOR_ASSET_STATE_UNSPECIFIED = 0,
  /** PRESENT - prior_asset is populated correctly. */
  PRESENT = 1,
  /** INVALID - Failed to set prior_asset. */
  INVALID = 2,
  /** DOES_NOT_EXIST - Current asset is the first known state. */
  DOES_NOT_EXIST = 3,
  /** DELETED - prior_asset is a deletion. */
  DELETED = 4,
  UNRECOGNIZED = -1,
}

export function temporalAsset_PriorAssetStateFromJSON(object: any): TemporalAsset_PriorAssetState {
  switch (object) {
    case 0:
    case "PRIOR_ASSET_STATE_UNSPECIFIED":
      return TemporalAsset_PriorAssetState.PRIOR_ASSET_STATE_UNSPECIFIED;
    case 1:
    case "PRESENT":
      return TemporalAsset_PriorAssetState.PRESENT;
    case 2:
    case "INVALID":
      return TemporalAsset_PriorAssetState.INVALID;
    case 3:
    case "DOES_NOT_EXIST":
      return TemporalAsset_PriorAssetState.DOES_NOT_EXIST;
    case 4:
    case "DELETED":
      return TemporalAsset_PriorAssetState.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TemporalAsset_PriorAssetState.UNRECOGNIZED;
  }
}

export function temporalAsset_PriorAssetStateToJSON(object: TemporalAsset_PriorAssetState): string {
  switch (object) {
    case TemporalAsset_PriorAssetState.PRIOR_ASSET_STATE_UNSPECIFIED:
      return "PRIOR_ASSET_STATE_UNSPECIFIED";
    case TemporalAsset_PriorAssetState.PRESENT:
      return "PRESENT";
    case TemporalAsset_PriorAssetState.INVALID:
      return "INVALID";
    case TemporalAsset_PriorAssetState.DOES_NOT_EXIST:
      return "DOES_NOT_EXIST";
    case TemporalAsset_PriorAssetState.DELETED:
      return "DELETED";
    case TemporalAsset_PriorAssetState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A time window specified by its `start_time` and `end_time`. */
export interface TimeWindow {
  /** Start time of the time window (exclusive). */
  startTime:
    | Date
    | undefined;
  /**
   * End time of the time window (inclusive). If not specified, the current
   * timestamp is used instead.
   */
  endTime: Date | undefined;
}

/**
 * An asset in Google Cloud. An asset can be any resource in the Google Cloud
 * [resource
 * hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
 * a resource outside the Google Cloud resource hierarchy (such as Google
 * Kubernetes Engine clusters and objects), or a policy (e.g. IAM policy),
 * or a relationship (e.g. an INSTANCE_TO_INSTANCEGROUP relationship).
 * See [Supported asset
 * types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
 * for more information.
 */
export interface Asset {
  /**
   * The last update timestamp of an asset. update_time is updated when
   * create/update/delete operation is performed.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * The full name of the asset. Example:
   * `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`
   *
   * See [Resource
   * names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
   * for more information.
   */
  name: string;
  /**
   * The type of the asset. Example: `compute.googleapis.com/Disk`
   *
   * See [Supported asset
   * types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
   * for more information.
   */
  assetType: string;
  /** A representation of the resource. */
  resource:
    | Resource
    | undefined;
  /**
   * A representation of the IAM policy set on a Google Cloud resource.
   * There can be a maximum of one IAM policy set on any given resource.
   * In addition, IAM policies inherit their granted access scope from any
   * policies set on parent resources in the resource hierarchy. Therefore, the
   * effectively policy is the union of both the policy set on this resource
   * and each policy set on all of the resource's ancestry resource levels in
   * the hierarchy. See
   * [this topic](https://cloud.google.com/iam/help/allow-policies/inheritance)
   * for more information.
   */
  iamPolicy:
    | Policy
    | undefined;
  /**
   * A representation of an [organization
   * policy](https://cloud.google.com/resource-manager/docs/organization-policy/overview#organization_policy).
   * There can be more than one organization policy with different constraints
   * set on a given resource.
   */
  orgPolicy: Policy1[];
  /**
   * Also refer to the [access policy user
   * guide](https://cloud.google.com/access-context-manager/docs/overview#access-policies).
   */
  accessPolicy?:
    | AccessPolicy
    | undefined;
  /**
   * Also refer to the [access level user
   * guide](https://cloud.google.com/access-context-manager/docs/overview#access-levels).
   */
  accessLevel?:
    | AccessLevel
    | undefined;
  /**
   * Also refer to the [service perimeter user
   * guide](https://cloud.google.com/vpc-service-controls/docs/overview).
   */
  servicePerimeter?:
    | ServicePerimeter
    | undefined;
  /**
   * A representation of runtime OS Inventory information. See [this
   * topic](https://cloud.google.com/compute/docs/instances/os-inventory-management)
   * for more information.
   */
  osInventory:
    | Inventory
    | undefined;
  /**
   * DEPRECATED. This field only presents for the purpose of
   * backward-compatibility. The server will never generate responses with this
   * field.
   * The related assets of the asset of one relationship type. One asset
   * only represents one type of relationship.
   *
   * @deprecated
   */
  relatedAssets:
    | RelatedAssets
    | undefined;
  /** One related asset of the current asset. */
  relatedAsset:
    | RelatedAsset
    | undefined;
  /**
   * The ancestry path of an asset in Google Cloud [resource
   * hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
   * represented as a list of relative resource names. An ancestry path starts
   * with the closest ancestor in the hierarchy and ends at root. If the asset
   * is a project, folder, or organization, the ancestry path starts from the
   * asset itself.
   *
   * Example: `["projects/123456789", "folders/5432", "organizations/1234"]`
   */
  ancestors: string[];
}

/** A representation of a Google Cloud resource. */
export interface Resource {
  /** The API version. Example: `v1` */
  version: string;
  /**
   * The URL of the discovery document containing the resource's JSON schema.
   * Example:
   * `https://www.googleapis.com/discovery/v1/apis/compute/v1/rest`
   *
   * This value is unspecified for resources that do not have an API based on a
   * discovery document, such as Cloud Bigtable.
   */
  discoveryDocumentUri: string;
  /**
   * The JSON schema name listed in the discovery document. Example:
   * `Project`
   *
   * This value is unspecified for resources that do not have an API based on a
   * discovery document, such as Cloud Bigtable.
   */
  discoveryName: string;
  /**
   * The REST URL for accessing the resource. An HTTP `GET` request using this
   * URL returns the resource itself. Example:
   * `https://cloudresourcemanager.googleapis.com/v1/projects/my-project-123`
   *
   * This value is unspecified for resources without a REST API.
   */
  resourceUrl: string;
  /**
   * The full name of the immediate parent of this resource. See
   * [Resource
   * Names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
   * for more information.
   *
   * For Google Cloud assets, this value is the parent resource defined in the
   * [IAM policy
   * hierarchy](https://cloud.google.com/iam/docs/overview#policy_hierarchy).
   * Example:
   * `//cloudresourcemanager.googleapis.com/projects/my_project_123`
   */
  parent: string;
  /**
   * The content of the resource, in which some sensitive fields are removed
   * and may not be present.
   */
  data:
    | { [key: string]: any }
    | undefined;
  /**
   * The location of the resource in Google Cloud, such as its zone and region.
   * For more information, see https://cloud.google.com/about/locations/.
   */
  location: string;
}

/**
 * DEPRECATED. This message only presents for the purpose of
 * backward-compatibility. The server will never populate this message in
 * responses.
 * The detailed related assets with the `relationship_type`.
 *
 * @deprecated
 */
export interface RelatedAssets {
  /** The detailed relationship attributes. */
  relationshipAttributes:
    | RelationshipAttributes
    | undefined;
  /** The peer resources of the relationship. */
  assets: RelatedAsset[];
}

/**
 * DEPRECATED. This message only presents for the purpose of
 * backward-compatibility. The server will never populate this message in
 * responses.
 * The relationship attributes which include  `type`, `source_resource_type`,
 * `target_resource_type` and `action`.
 *
 * @deprecated
 */
export interface RelationshipAttributes {
  /**
   * The unique identifier of the relationship type. Example:
   * `INSTANCE_TO_INSTANCEGROUP`
   */
  type: string;
  /** The source asset type. Example: `compute.googleapis.com/Instance` */
  sourceResourceType: string;
  /** The target asset type. Example: `compute.googleapis.com/Disk` */
  targetResourceType: string;
  /** The detail of the relationship, e.g. `contains`, `attaches` */
  action: string;
}

/**
 * An asset identifier in Google Cloud which contains its name, type and
 * ancestors. An asset can be any resource in the Google Cloud [resource
 * hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
 * a resource outside the Google Cloud resource hierarchy (such as Google
 * Kubernetes Engine clusters and objects), or a policy (e.g. IAM policy).
 * See [Supported asset
 * types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
 * for more information.
 */
export interface RelatedAsset {
  /**
   * The full name of the asset. Example:
   * `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`
   *
   * See [Resource
   * names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
   * for more information.
   */
  asset: string;
  /**
   * The type of the asset. Example: `compute.googleapis.com/Disk`
   *
   * See [Supported asset
   * types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
   * for more information.
   */
  assetType: string;
  /**
   * The ancestors of an asset in Google Cloud [resource
   * hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
   * represented as a list of relative resource names. An ancestry path starts
   * with the closest ancestor in the hierarchy and ends at root.
   *
   * Example: `["projects/123456789", "folders/5432", "organizations/1234"]`
   */
  ancestors: string[];
  /**
   * The unique identifier of the relationship type. Example:
   * `INSTANCE_TO_INSTANCEGROUP`
   */
  relationshipType: string;
}

/**
 * The key and value for a
 * [tag](https://cloud.google.com/resource-manager/docs/tags/tags-overview).
 */
export interface Tag {
  /** TagKey namespaced name, in the format of {ORG_ID}/{TAG_KEY_SHORT_NAME}. */
  tagKey?:
    | string
    | undefined;
  /** TagKey ID, in the format of tagKeys/{TAG_KEY_ID}. */
  tagKeyId?:
    | string
    | undefined;
  /**
   * TagValue namespaced name, in the format of
   * {ORG_ID}/{TAG_KEY_SHORT_NAME}/{TAG_VALUE_SHORT_NAME}.
   */
  tagValue?:
    | string
    | undefined;
  /** TagValue ID, in the format of tagValues/{TAG_VALUE_ID}. */
  tagValueId?: string | undefined;
}

/** The effective tags and the ancestor resources from which they were inherited. */
export interface EffectiveTagDetails {
  /**
   * The [full resource
   * name](https://cloud.google.com/asset-inventory/docs/resource-name-format)
   * of the ancestor from which an [effective_tag][] is inherited, according to
   * [tag
   * inheritance](https://cloud.google.com/resource-manager/docs/tags/tags-overview#inheritance).
   */
  attachedResource?:
    | string
    | undefined;
  /**
   * The effective tags inherited from the
   * [attached_resource][google.cloud.asset.v1.EffectiveTagDetails.attached_resource].
   * Note that tags with the same key but different values may attach to
   * resources at a different hierarchy levels. The lower hierarchy tag value
   * will overwrite the higher hierarchy tag value of the same tag key. In this
   * case, the tag value at the higher hierarchy level will be removed. For more
   * information, see [tag
   * inheritance](https://cloud.google.com/resource-manager/docs/tags/tags-overview#inheritance).
   */
  effectiveTags: Tag[];
}

/** A result of Resource Search, containing information of a cloud resource. */
export interface ResourceSearchResult {
  /**
   * The full resource name of this resource. Example:
   * `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
   * See [Cloud Asset Inventory Resource Name
   * Format](https://cloud.google.com/asset-inventory/docs/resource-name-format)
   * for more information.
   *
   * To search against the `name`:
   *
   * * Use a field query. Example: `name:instance1`
   * * Use a free text query. Example: `instance1`
   */
  name: string;
  /**
   * The type of this resource. Example: `compute.googleapis.com/Disk`.
   *
   * To search against the `asset_type`:
   *
   * * Specify the `asset_type` field in your search request.
   */
  assetType: string;
  /**
   * The project that this resource belongs to, in the form of
   * projects/{PROJECT_NUMBER}. This field is available when the resource
   * belongs to a project.
   *
   * To search against `project`:
   *
   * * Use a field query. Example: `project:12345`
   * * Use a free text query. Example: `12345`
   * * Specify the `scope` field as this project in your search request.
   */
  project: string;
  /**
   * The folder(s) that this resource belongs to, in the form of
   * folders/{FOLDER_NUMBER}. This field is available when the resource
   * belongs to one or more folders.
   *
   * To search against `folders`:
   *
   * * Use a field query. Example: `folders:(123 OR 456)`
   * * Use a free text query. Example: `123`
   * * Specify the `scope` field as this folder in your search request.
   */
  folders: string[];
  /**
   * The organization that this resource belongs to, in the form of
   * organizations/{ORGANIZATION_NUMBER}. This field is available when the
   * resource belongs to an organization.
   *
   * To search against `organization`:
   *
   * * Use a field query. Example: `organization:123`
   * * Use a free text query. Example: `123`
   * * Specify the `scope` field as this organization in your search request.
   */
  organization: string;
  /**
   * The display name of this resource. This field is available only when the
   * resource's Protobuf contains it.
   *
   * To search against the `display_name`:
   *
   * * Use a field query. Example: `displayName:"My Instance"`
   * * Use a free text query. Example: `"My Instance"`
   */
  displayName: string;
  /**
   * One or more paragraphs of text description of this resource. Maximum length
   * could be up to 1M bytes. This field is available only when the resource's
   * Protobuf contains it.
   *
   * To search against the `description`:
   *
   * * Use a field query. Example: `description:"important instance"`
   * * Use a free text query. Example: `"important instance"`
   */
  description: string;
  /**
   * Location can be `global`, regional like `us-east1`, or zonal like
   * `us-west1-b`. This field is available only when the resource's Protobuf
   * contains it.
   *
   * To search against the `location`:
   *
   * * Use a field query. Example: `location:us-west*`
   * * Use a free text query. Example: `us-west*`
   */
  location: string;
  /**
   * User labels associated with this resource. See [Labelling and grouping
   * Google Cloud
   * resources](https://cloud.google.com/blog/products/gcp/labelling-and-grouping-your-google-cloud-platform-resources)
   * for more information. This field is available only when the resource's
   * Protobuf contains it.
   *
   * To search against the `labels`:
   *
   * * Use a field query:
   *     - query on any label's key or value. Example: `labels:prod`
   *     - query by a given label. Example: `labels.env:prod`
   *     - query by a given label's existence. Example: `labels.env:*`
   * * Use a free text query. Example: `prod`
   */
  labels: { [key: string]: string };
  /**
   * Network tags associated with this resource. Like labels, network tags are a
   * type of annotations used to group Google Cloud resources. See [Labelling
   * Google Cloud
   * resources](https://cloud.google.com/blog/products/gcp/labelling-and-grouping-your-google-cloud-platform-resources)
   * for more information. This field is available only when the resource's
   * Protobuf contains it.
   *
   * To search against the `network_tags`:
   *
   * * Use a field query. Example: `networkTags:internal`
   * * Use a free text query. Example: `internal`
   */
  networkTags: string[];
  /**
   * The Cloud KMS
   * [CryptoKey](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys)
   * name or
   * [CryptoKeyVersion](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys.cryptoKeyVersions)
   * name.
   *
   * This field only presents for the purpose of backward compatibility.
   * Use the `kms_keys` field to retrieve Cloud KMS key information. This field
   * is available only when the resource's Protobuf contains it and will only be
   * populated for [these resource
   * types](https://cloud.google.com/asset-inventory/docs/legacy-field-names#resource_types_with_the_to_be_deprecated_kmskey_field)
   * for backward compatible purposes.
   *
   * To search against the `kms_key`:
   *
   * * Use a field query. Example: `kmsKey:key`
   * * Use a free text query. Example: `key`
   *
   * @deprecated
   */
  kmsKey: string;
  /**
   * The Cloud KMS
   * [CryptoKey](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys)
   * names or
   * [CryptoKeyVersion](https://cloud.google.com/kms/docs/reference/rest/v1/projects.locations.keyRings.cryptoKeys.cryptoKeyVersions)
   * names. This field is available only when the resource's Protobuf contains
   * it.
   *
   * To search against the `kms_keys`:
   *
   * * Use a field query. Example: `kmsKeys:key`
   * * Use a free text query. Example: `key`
   */
  kmsKeys: string[];
  /**
   * The create timestamp of this resource, at which the resource was created.
   * The granularity is in seconds. Timestamp.nanos will always be 0. This field
   * is available only when the resource's Protobuf contains it.
   *
   * To search against `create_time`:
   *
   * * Use a field query.
   *     - value in seconds since unix epoch. Example: `createTime > 1609459200`
   *     - value in date string. Example: `createTime > 2021-01-01`
   *     - value in date-time string (must be quoted). Example: `createTime >
   *     "2021-01-01T00:00:00"`
   */
  createTime:
    | Date
    | undefined;
  /**
   * The last update timestamp of this resource, at which the resource was last
   * modified or deleted. The granularity is in seconds. Timestamp.nanos will
   * always be 0. This field is available only when the resource's Protobuf
   * contains it.
   *
   * To search against `update_time`:
   *
   * * Use a field query.
   *     - value in seconds since unix epoch. Example: `updateTime < 1609459200`
   *     - value in date string. Example: `updateTime < 2021-01-01`
   *     - value in date-time string (must be quoted). Example: `updateTime <
   *     "2021-01-01T00:00:00"`
   */
  updateTime:
    | Date
    | undefined;
  /**
   * The state of this resource. Different resources types have different state
   * definitions that are mapped from various fields of different resource
   * types. This field is available only when the resource's Protobuf contains
   * it.
   *
   * Example:
   * If the resource is an instance provided by Compute Engine,
   * its state will include PROVISIONING, STAGING, RUNNING, STOPPING,
   * SUSPENDING, SUSPENDED, REPAIRING, and TERMINATED. See `status` definition
   * in [API
   * Reference](https://cloud.google.com/compute/docs/reference/rest/v1/instances).
   * If the resource is a project provided by Resource Manager, its state
   * will include LIFECYCLE_STATE_UNSPECIFIED, ACTIVE, DELETE_REQUESTED and
   * DELETE_IN_PROGRESS. See `lifecycleState` definition in [API
   * Reference](https://cloud.google.com/resource-manager/reference/rest/v1/projects).
   *
   * To search against the `state`:
   *
   * * Use a field query. Example: `state:RUNNING`
   * * Use a free text query. Example: `RUNNING`
   */
  state: string;
  /**
   * The additional searchable attributes of this resource. The attributes may
   * vary from one resource type to another. Examples: `projectId` for Project,
   * `dnsName` for DNS ManagedZone. This field contains a subset of the resource
   * metadata fields that are returned by the List or Get APIs provided by the
   * corresponding Google Cloud service (e.g., Compute Engine). see [API
   * references and supported searchable
   * attributes](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
   * to see which fields are included.
   *
   * You can search values of these fields through free text search. However,
   * you should not consume the field programically as the field names and
   * values may change as the Google Cloud service updates to a new incompatible
   * API version.
   *
   * To search against the `additional_attributes`:
   *
   * * Use a free text query to match the attributes values. Example: to search
   *   `additional_attributes = { dnsName: "foobar" }`, you can issue a query
   *   `foobar`.
   */
  additionalAttributes:
    | { [key: string]: any }
    | undefined;
  /**
   * The full resource name of this resource's parent, if it has one.
   * To search against the `parent_full_resource_name`:
   *
   * * Use a field query. Example:
   * `parentFullResourceName:"project-name"`
   * * Use a free text query. Example:
   * `project-name`
   */
  parentFullResourceName: string;
  /**
   * Versioned resource representations of this resource. This is repeated
   * because there could be multiple versions of resource representations during
   * version migration.
   *
   * This `versioned_resources` field is not searchable. Some attributes of the
   * resource representations are exposed in `additional_attributes` field, so
   * as to allow users to search on them.
   */
  versionedResources: VersionedResource[];
  /**
   * Attached resources of this resource. For example, an OSConfig
   * Inventory is an attached resource of a Compute Instance. This field is
   * repeated because a resource could have multiple attached resources.
   *
   * This `attached_resources` field is not searchable. Some attributes
   * of the attached resources are exposed in `additional_attributes` field, so
   * as to allow users to search on them.
   */
  attachedResources: AttachedResource[];
  /**
   * A map of related resources of this resource, keyed by the
   * relationship type. A relationship type is in the format of
   * {SourceType}_{ACTION}_{DestType}. Example: `DISK_TO_INSTANCE`,
   * `DISK_TO_NETWORK`, `INSTANCE_TO_INSTANCEGROUP`.
   * See [supported relationship
   * types](https://cloud.google.com/asset-inventory/docs/supported-asset-types#supported_relationship_types).
   */
  relationships: { [key: string]: RelatedResources };
  /**
   * This field is only present for the purpose of backward compatibility.
   * Use the `tags` field instead.
   *
   * TagKey namespaced names, in the format of {ORG_ID}/{TAG_KEY_SHORT_NAME}.
   * To search against the `tagKeys`:
   *
   * * Use a field query. Example:
   *     - `tagKeys:"123456789/env*"`
   *     - `tagKeys="123456789/env"`
   *     - `tagKeys:"env"`
   *
   * * Use a free text query. Example:
   *     - `env`
   *
   * @deprecated
   */
  tagKeys: string[];
  /**
   * This field is only present for the purpose of backward compatibility.
   * Use the `tags` field instead.
   *
   * TagValue namespaced names, in the format of
   * {ORG_ID}/{TAG_KEY_SHORT_NAME}/{TAG_VALUE_SHORT_NAME}.
   * To search against the `tagValues`:
   *
   * * Use a field query. Example:
   *     - `tagValues:"env"`
   *     - `tagValues:"env/prod"`
   *     - `tagValues:"123456789/env/prod*"`
   *     - `tagValues="123456789/env/prod"`
   *
   * * Use a free text query. Example:
   *     - `prod`
   *
   * @deprecated
   */
  tagValues: string[];
  /**
   * This field is only present for the purpose of backward compatibility.
   * Use the `tags` field instead.
   *
   * TagValue IDs, in the format of tagValues/{TAG_VALUE_ID}.
   * To search against the `tagValueIds`:
   *
   * * Use a field query. Example:
   *     - `tagValueIds="tagValues/456"`
   *
   * * Use a free text query. Example:
   *     - `456`
   *
   * @deprecated
   */
  tagValueIds: string[];
  /**
   * The tags directly attached to this resource.
   *
   * To search against the `tags`:
   *
   * * Use a field query. Example:
   *     - `tagKeys:"123456789/env*"`
   *     - `tagKeys="123456789/env"`
   *     - `tagKeys:"env"`
   *     - `tagKeyIds="tagKeys/123"`
   *     - `tagValues:"env"`
   *     - `tagValues:"env/prod"`
   *     - `tagValues:"123456789/env/prod*"`
   *     - `tagValues="123456789/env/prod"`
   *     - `tagValueIds="tagValues/456"`
   *
   * * Use a free text query. Example:
   *     - `env/prod`
   */
  tags: Tag[];
  /**
   * The effective tags on this resource. All of the tags that are both attached
   * to and inherited by a resource are collectively called the effective
   * tags. For more information, see [tag
   * inheritance](https://cloud.google.com/resource-manager/docs/tags/tags-overview#inheritance).
   *
   * To search against the `effective_tags`:
   *
   * * Use a field query. Example:
   *     - `effectiveTagKeys:"123456789/env*"`
   *     - `effectiveTagKeys="123456789/env"`
   *     - `effectiveTagKeys:"env"`
   *     - `effectiveTagKeyIds="tagKeys/123"`
   *     - `effectiveTagValues:"env"`
   *     - `effectiveTagValues:"env/prod"`
   *     - `effectiveTagValues:"123456789/env/prod*"`
   *     - `effectiveTagValues="123456789/env/prod"`
   *     - `effectiveTagValueIds="tagValues/456"`
   */
  effectiveTags: EffectiveTagDetails[];
  /**
   * The type of this resource's immediate parent, if there is one.
   *
   * To search against the `parent_asset_type`:
   *
   * * Use a field query. Example:
   * `parentAssetType:"cloudresourcemanager.googleapis.com/Project"`
   * * Use a free text query. Example:
   * `cloudresourcemanager.googleapis.com/Project`
   */
  parentAssetType: string;
  /**
   * The actual content of Security Command Center security marks associated
   * with the asset.
   *
   * To search against SCC SecurityMarks field:
   *
   *   * Use a field query:
   *     - query by a given key value pair. Example: `sccSecurityMarks.foo=bar`
   *     - query by a given key's existence. Example: `sccSecurityMarks.foo:*`
   */
  sccSecurityMarks: { [key: string]: string };
}

export interface ResourceSearchResult_LabelsEntry {
  key: string;
  value: string;
}

export interface ResourceSearchResult_RelationshipsEntry {
  key: string;
  value: RelatedResources | undefined;
}

export interface ResourceSearchResult_SccSecurityMarksEntry {
  key: string;
  value: string;
}

/**
 * Resource representation as defined by the corresponding service providing the
 * resource for a given API version.
 */
export interface VersionedResource {
  /**
   * API version of the resource.
   *
   * Example:
   * If the resource is an instance provided by Compute Engine v1 API as defined
   * in `https://cloud.google.com/compute/docs/reference/rest/v1/instances`,
   * version will be "v1".
   */
  version: string;
  /**
   * JSON representation of the resource as defined by the corresponding
   * service providing this resource.
   *
   * Example:
   * If the resource is an instance provided by Compute Engine, this field will
   * contain the JSON representation of the instance as defined by Compute
   * Engine:
   * `https://cloud.google.com/compute/docs/reference/rest/v1/instances`.
   *
   * You can find the resource definition for each supported resource type in
   * this table:
   * `https://cloud.google.com/asset-inventory/docs/supported-asset-types`
   */
  resource: { [key: string]: any } | undefined;
}

/**
 * Attached resource representation, which is defined by the corresponding
 * service provider. It represents an attached resource's payload.
 */
export interface AttachedResource {
  /**
   * The type of this attached resource.
   *
   * Example: `osconfig.googleapis.com/Inventory`
   *
   * You can find the supported attached asset types of each resource in this
   * table:
   * `https://cloud.google.com/asset-inventory/docs/supported-asset-types`
   */
  assetType: string;
  /**
   * Versioned resource representations of this attached resource. This is
   * repeated because there could be multiple versions of the attached resource
   * representations during version migration.
   */
  versionedResources: VersionedResource[];
}

/** The related resources of the primary resource. */
export interface RelatedResources {
  /** The detailed related resources of the primary resource. */
  relatedResources: RelatedResource[];
}

/** The detailed related resource. */
export interface RelatedResource {
  /** The type of the asset. Example: `compute.googleapis.com/Instance` */
  assetType: string;
  /**
   * The full resource name of the related resource. Example:
   * `//compute.googleapis.com/projects/my_proj_123/zones/instance/instance123`
   */
  fullResourceName: string;
}

/** A result of IAM Policy search, containing information of an IAM policy. */
export interface IamPolicySearchResult {
  /**
   * The full resource name of the resource associated with this IAM policy.
   * Example:
   * `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
   * See [Cloud Asset Inventory Resource Name
   * Format](https://cloud.google.com/asset-inventory/docs/resource-name-format)
   * for more information.
   *
   * To search against the `resource`:
   *
   * * use a field query. Example: `resource:organizations/123`
   */
  resource: string;
  /**
   * The type of the resource associated with this IAM policy. Example:
   * `compute.googleapis.com/Disk`.
   *
   * To search against the `asset_type`:
   *
   * * specify the `asset_types` field in your search request.
   */
  assetType: string;
  /**
   * The project that the associated Google Cloud resource belongs to, in the
   * form of projects/{PROJECT_NUMBER}. If an IAM policy is set on a resource
   * (like VM instance, Cloud Storage bucket), the project field will indicate
   * the project that contains the resource. If an IAM policy is set on a folder
   * or orgnization, this field will be empty.
   *
   * To search against the `project`:
   *
   * * specify the `scope` field as this project in your search request.
   */
  project: string;
  /**
   * The folder(s) that the IAM policy belongs to, in the form of
   * folders/{FOLDER_NUMBER}. This field is available when the IAM policy
   * belongs to one or more folders.
   *
   * To search against `folders`:
   *
   * * use a field query. Example: `folders:(123 OR 456)`
   * * use a free text query. Example: `123`
   * * specify the `scope` field as this folder in your search request.
   */
  folders: string[];
  /**
   * The organization that the IAM policy belongs to, in the form
   * of organizations/{ORGANIZATION_NUMBER}. This field is available when the
   * IAM policy belongs to an organization.
   *
   * To search against `organization`:
   *
   * * use a field query. Example: `organization:123`
   * * use a free text query. Example: `123`
   * * specify the `scope` field as this organization in your search request.
   */
  organization: string;
  /**
   * The IAM policy directly set on the given resource. Note that the original
   * IAM policy can contain multiple bindings. This only contains the bindings
   * that match the given query. For queries that don't contain a constrain on
   * policies (e.g., an empty query), this contains all the bindings.
   *
   * To search against the `policy` bindings:
   *
   * * use a field query:
   *     - query by the policy contained members. Example:
   *       `policy:amy@gmail.com`
   *     - query by the policy contained roles. Example:
   *       `policy:roles/compute.admin`
   *     - query by the policy contained roles' included permissions. Example:
   *       `policy.role.permissions:compute.instances.create`
   */
  policy:
    | Policy
    | undefined;
  /**
   * Explanation about the IAM policy search result. It contains additional
   * information to explain why the search result matches the query.
   */
  explanation: IamPolicySearchResult_Explanation | undefined;
}

/** Explanation about the IAM policy search result. */
export interface IamPolicySearchResult_Explanation {
  /**
   * The map from roles to their included permissions that match the
   * permission query (i.e., a query containing `policy.role.permissions:`).
   * Example: if query `policy.role.permissions:compute.disk.get`
   * matches a policy binding that contains owner role, the
   * matched_permissions will be `{"roles/owner": ["compute.disk.get"]}`. The
   * roles can also be found in the returned `policy` bindings. Note that the
   * map is populated only for requests with permission queries.
   */
  matchedPermissions: { [key: string]: IamPolicySearchResult_Explanation_Permissions };
}

/** IAM permissions */
export interface IamPolicySearchResult_Explanation_Permissions {
  /** A list of permissions. A sample permission string: `compute.disk.get`. */
  permissions: string[];
}

export interface IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
  key: string;
  value: IamPolicySearchResult_Explanation_Permissions | undefined;
}

/**
 * Represents the detailed state of an entity under analysis, such as a
 * resource, an identity or an access.
 */
export interface IamPolicyAnalysisState {
  /**
   * The Google standard error code that best describes the state.
   * For example:
   * - OK means the analysis on this entity has been successfully finished;
   * - PERMISSION_DENIED means an access denied error is encountered;
   * - DEADLINE_EXCEEDED means the analysis on this entity hasn't been started
   * in time;
   */
  code: Code;
  /** The human-readable description of the cause of failure. */
  cause: string;
}

/** The condition evaluation. */
export interface ConditionEvaluation {
  /** The evaluation result. */
  evaluationValue: ConditionEvaluation_EvaluationValue;
}

/** Value of this expression. */
export enum ConditionEvaluation_EvaluationValue {
  /** EVALUATION_VALUE_UNSPECIFIED - Reserved for future use. */
  EVALUATION_VALUE_UNSPECIFIED = 0,
  /** TRUE - The evaluation result is `true`. */
  TRUE = 1,
  /** FALSE - The evaluation result is `false`. */
  FALSE = 2,
  /**
   * CONDITIONAL - The evaluation result is `conditional` when the condition expression
   * contains variables that are either missing input values or have not been
   * supported by Policy Analyzer yet.
   */
  CONDITIONAL = 3,
  UNRECOGNIZED = -1,
}

export function conditionEvaluation_EvaluationValueFromJSON(object: any): ConditionEvaluation_EvaluationValue {
  switch (object) {
    case 0:
    case "EVALUATION_VALUE_UNSPECIFIED":
      return ConditionEvaluation_EvaluationValue.EVALUATION_VALUE_UNSPECIFIED;
    case 1:
    case "TRUE":
      return ConditionEvaluation_EvaluationValue.TRUE;
    case 2:
    case "FALSE":
      return ConditionEvaluation_EvaluationValue.FALSE;
    case 3:
    case "CONDITIONAL":
      return ConditionEvaluation_EvaluationValue.CONDITIONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConditionEvaluation_EvaluationValue.UNRECOGNIZED;
  }
}

export function conditionEvaluation_EvaluationValueToJSON(object: ConditionEvaluation_EvaluationValue): string {
  switch (object) {
    case ConditionEvaluation_EvaluationValue.EVALUATION_VALUE_UNSPECIFIED:
      return "EVALUATION_VALUE_UNSPECIFIED";
    case ConditionEvaluation_EvaluationValue.TRUE:
      return "TRUE";
    case ConditionEvaluation_EvaluationValue.FALSE:
      return "FALSE";
    case ConditionEvaluation_EvaluationValue.CONDITIONAL:
      return "CONDITIONAL";
    case ConditionEvaluation_EvaluationValue.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * IAM Policy analysis result, consisting of one IAM policy binding and derived
 * access control lists.
 */
export interface IamPolicyAnalysisResult {
  /**
   * The [full resource
   * name](https://cloud.google.com/asset-inventory/docs/resource-name-format)
   * of the resource to which the
   * [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]
   * policy attaches.
   */
  attachedResourceFullName: string;
  /** The IAM policy binding under analysis. */
  iamBinding:
    | Binding
    | undefined;
  /**
   * The access control lists derived from the
   * [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]
   * that match or potentially match resource and access selectors specified in
   * the request.
   */
  accessControlLists: IamPolicyAnalysisResult_AccessControlList[];
  /**
   * The identity list derived from members of the
   * [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]
   * that match or potentially match identity selector specified in the request.
   */
  identityList:
    | IamPolicyAnalysisResult_IdentityList
    | undefined;
  /**
   * Represents whether all analyses on the
   * [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding]
   * have successfully finished.
   */
  fullyExplored: boolean;
}

/** A Google Cloud resource under analysis. */
export interface IamPolicyAnalysisResult_Resource {
  /**
   * The [full resource
   * name](https://cloud.google.com/asset-inventory/docs/resource-name-format)
   */
  fullResourceName: string;
  /** The analysis state of this resource. */
  analysisState: IamPolicyAnalysisState | undefined;
}

/** An IAM role or permission under analysis. */
export interface IamPolicyAnalysisResult_Access {
  /** The role. */
  role?:
    | string
    | undefined;
  /** The permission. */
  permission?:
    | string
    | undefined;
  /** The analysis state of this access. */
  analysisState: IamPolicyAnalysisState | undefined;
}

/** An identity under analysis. */
export interface IamPolicyAnalysisResult_Identity {
  /**
   * The identity of members, formatted as appear in an
   * [IAM policy
   * binding](https://cloud.google.com/iam/reference/rest/v1/Binding). For
   * example, they might be formatted like the following:
   *
   * - user:foo@google.com
   * - group:group1@google.com
   * - serviceAccount:s1@prj1.iam.gserviceaccount.com
   * - projectOwner:some_project_id
   * - domain:google.com
   * - allUsers
   */
  name: string;
  /** The analysis state of this identity. */
  analysisState: IamPolicyAnalysisState | undefined;
}

/** A directional edge. */
export interface IamPolicyAnalysisResult_Edge {
  /**
   * The source node of the edge. For example, it could be a full resource
   * name for a resource node or an email of an identity.
   */
  sourceNode: string;
  /**
   * The target node of the edge. For example, it could be a full resource
   * name for a resource node or an email of an identity.
   */
  targetNode: string;
}

/**
 * An access control list, derived from the above IAM policy binding, which
 * contains a set of resources and accesses. May include one
 * item from each set to compose an access control entry.
 *
 * NOTICE that there could be multiple access control lists for one IAM policy
 * binding. The access control lists are created based on resource and access
 * combinations.
 *
 * For example, assume we have the following cases in one IAM policy binding:
 * - Permission P1 and P2 apply to resource R1 and R2;
 * - Permission P3 applies to resource R2 and R3;
 *
 * This will result in the following access control lists:
 * - AccessControlList 1: [R1, R2], [P1, P2]
 * - AccessControlList 2: [R2, R3], [P3]
 */
export interface IamPolicyAnalysisResult_AccessControlList {
  /**
   * The resources that match one of the following conditions:
   * - The resource_selector, if it is specified in request;
   * - Otherwise, resources reachable from the policy attached resource.
   */
  resources: IamPolicyAnalysisResult_Resource[];
  /**
   * The accesses that match one of the following conditions:
   * - The access_selector, if it is specified in request;
   * - Otherwise, access specifiers reachable from the policy binding's role.
   */
  accesses: IamPolicyAnalysisResult_Access[];
  /**
   * Resource edges of the graph starting from the policy attached
   * resource to any descendant resources. The
   * [Edge.source_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.source_node]
   * contains the full resource name of a parent resource and
   * [Edge.target_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.target_node]
   * contains the full resource name of a child resource. This field is
   * present only if the output_resource_edges option is enabled in request.
   */
  resourceEdges: IamPolicyAnalysisResult_Edge[];
  /**
   * Condition evaluation for this AccessControlList, if there is a condition
   * defined in the above IAM policy binding.
   */
  conditionEvaluation: ConditionEvaluation | undefined;
}

/** The identities and group edges. */
export interface IamPolicyAnalysisResult_IdentityList {
  /**
   * Only the identities that match one of the following conditions will be
   * presented:
   * - The identity_selector, if it is specified in request;
   * - Otherwise, identities reachable from the policy binding's members.
   */
  identities: IamPolicyAnalysisResult_Identity[];
  /**
   * Group identity edges of the graph starting from the binding's
   * group members to any node of the
   * [identities][google.cloud.asset.v1.IamPolicyAnalysisResult.IdentityList.identities].
   * The
   * [Edge.source_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.source_node]
   * contains a group, such as `group:parent@google.com`. The
   * [Edge.target_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.target_node]
   * contains a member of the group, such as `group:child@google.com` or
   * `user:foo@google.com`. This field is present only if the
   * output_group_edges option is enabled in request.
   */
  groupEdges: IamPolicyAnalysisResult_Edge[];
}

function createBaseTemporalAsset(): TemporalAsset {
  return { window: undefined, deleted: false, asset: undefined, priorAssetState: 0, priorAsset: undefined };
}

export const TemporalAsset: MessageFns<TemporalAsset> = {
  encode(message: TemporalAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.window !== undefined) {
      TimeWindow.encode(message.window, writer.uint32(10).fork()).join();
    }
    if (message.deleted !== false) {
      writer.uint32(16).bool(message.deleted);
    }
    if (message.asset !== undefined) {
      Asset.encode(message.asset, writer.uint32(26).fork()).join();
    }
    if (message.priorAssetState !== 0) {
      writer.uint32(32).int32(message.priorAssetState);
    }
    if (message.priorAsset !== undefined) {
      Asset.encode(message.priorAsset, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TemporalAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTemporalAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.window = TimeWindow.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.deleted = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.asset = Asset.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.priorAssetState = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.priorAsset = Asset.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TemporalAsset {
    return {
      window: isSet(object.window) ? TimeWindow.fromJSON(object.window) : undefined,
      deleted: isSet(object.deleted) ? globalThis.Boolean(object.deleted) : false,
      asset: isSet(object.asset) ? Asset.fromJSON(object.asset) : undefined,
      priorAssetState: isSet(object.priorAssetState)
        ? temporalAsset_PriorAssetStateFromJSON(object.priorAssetState)
        : 0,
      priorAsset: isSet(object.priorAsset) ? Asset.fromJSON(object.priorAsset) : undefined,
    };
  },

  toJSON(message: TemporalAsset): unknown {
    const obj: any = {};
    if (message.window !== undefined) {
      obj.window = TimeWindow.toJSON(message.window);
    }
    if (message.deleted !== false) {
      obj.deleted = message.deleted;
    }
    if (message.asset !== undefined) {
      obj.asset = Asset.toJSON(message.asset);
    }
    if (message.priorAssetState !== 0) {
      obj.priorAssetState = temporalAsset_PriorAssetStateToJSON(message.priorAssetState);
    }
    if (message.priorAsset !== undefined) {
      obj.priorAsset = Asset.toJSON(message.priorAsset);
    }
    return obj;
  },

  create(base?: DeepPartial<TemporalAsset>): TemporalAsset {
    return TemporalAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TemporalAsset>): TemporalAsset {
    const message = createBaseTemporalAsset();
    message.window = (object.window !== undefined && object.window !== null)
      ? TimeWindow.fromPartial(object.window)
      : undefined;
    message.deleted = object.deleted ?? false;
    message.asset = (object.asset !== undefined && object.asset !== null) ? Asset.fromPartial(object.asset) : undefined;
    message.priorAssetState = object.priorAssetState ?? 0;
    message.priorAsset = (object.priorAsset !== undefined && object.priorAsset !== null)
      ? Asset.fromPartial(object.priorAsset)
      : undefined;
    return message;
  },
};

function createBaseTimeWindow(): TimeWindow {
  return { startTime: undefined, endTime: undefined };
}

export const TimeWindow: MessageFns<TimeWindow> = {
  encode(message: TimeWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeWindow {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TimeWindow): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TimeWindow>): TimeWindow {
    return TimeWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeWindow>): TimeWindow {
    const message = createBaseTimeWindow();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseAsset(): Asset {
  return {
    updateTime: undefined,
    name: "",
    assetType: "",
    resource: undefined,
    iamPolicy: undefined,
    orgPolicy: [],
    accessPolicy: undefined,
    accessLevel: undefined,
    servicePerimeter: undefined,
    osInventory: undefined,
    relatedAssets: undefined,
    relatedAsset: undefined,
    ancestors: [],
  };
}

export const Asset: MessageFns<Asset> = {
  encode(message: Asset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(90).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.assetType !== "") {
      writer.uint32(18).string(message.assetType);
    }
    if (message.resource !== undefined) {
      Resource.encode(message.resource, writer.uint32(26).fork()).join();
    }
    if (message.iamPolicy !== undefined) {
      Policy.encode(message.iamPolicy, writer.uint32(34).fork()).join();
    }
    for (const v of message.orgPolicy) {
      Policy1.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.accessPolicy !== undefined) {
      AccessPolicy.encode(message.accessPolicy, writer.uint32(58).fork()).join();
    }
    if (message.accessLevel !== undefined) {
      AccessLevel.encode(message.accessLevel, writer.uint32(66).fork()).join();
    }
    if (message.servicePerimeter !== undefined) {
      ServicePerimeter.encode(message.servicePerimeter, writer.uint32(74).fork()).join();
    }
    if (message.osInventory !== undefined) {
      Inventory.encode(message.osInventory, writer.uint32(98).fork()).join();
    }
    if (message.relatedAssets !== undefined) {
      RelatedAssets.encode(message.relatedAssets, writer.uint32(106).fork()).join();
    }
    if (message.relatedAsset !== undefined) {
      RelatedAsset.encode(message.relatedAsset, writer.uint32(122).fork()).join();
    }
    for (const v of message.ancestors) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Asset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = Resource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.iamPolicy = Policy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orgPolicy.push(Policy1.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.accessPolicy = AccessPolicy.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.accessLevel = AccessLevel.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.servicePerimeter = ServicePerimeter.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.osInventory = Inventory.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.relatedAssets = RelatedAssets.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.relatedAsset = RelatedAsset.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.ancestors.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Asset {
    return {
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      assetType: isSet(object.assetType) ? globalThis.String(object.assetType) : "",
      resource: isSet(object.resource) ? Resource.fromJSON(object.resource) : undefined,
      iamPolicy: isSet(object.iamPolicy) ? Policy.fromJSON(object.iamPolicy) : undefined,
      orgPolicy: globalThis.Array.isArray(object?.orgPolicy)
        ? object.orgPolicy.map((e: any) => Policy1.fromJSON(e))
        : [],
      accessPolicy: isSet(object.accessPolicy) ? AccessPolicy.fromJSON(object.accessPolicy) : undefined,
      accessLevel: isSet(object.accessLevel) ? AccessLevel.fromJSON(object.accessLevel) : undefined,
      servicePerimeter: isSet(object.servicePerimeter) ? ServicePerimeter.fromJSON(object.servicePerimeter) : undefined,
      osInventory: isSet(object.osInventory) ? Inventory.fromJSON(object.osInventory) : undefined,
      relatedAssets: isSet(object.relatedAssets) ? RelatedAssets.fromJSON(object.relatedAssets) : undefined,
      relatedAsset: isSet(object.relatedAsset) ? RelatedAsset.fromJSON(object.relatedAsset) : undefined,
      ancestors: globalThis.Array.isArray(object?.ancestors)
        ? object.ancestors.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Asset): unknown {
    const obj: any = {};
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.assetType !== "") {
      obj.assetType = message.assetType;
    }
    if (message.resource !== undefined) {
      obj.resource = Resource.toJSON(message.resource);
    }
    if (message.iamPolicy !== undefined) {
      obj.iamPolicy = Policy.toJSON(message.iamPolicy);
    }
    if (message.orgPolicy?.length) {
      obj.orgPolicy = message.orgPolicy.map((e) => Policy1.toJSON(e));
    }
    if (message.accessPolicy !== undefined) {
      obj.accessPolicy = AccessPolicy.toJSON(message.accessPolicy);
    }
    if (message.accessLevel !== undefined) {
      obj.accessLevel = AccessLevel.toJSON(message.accessLevel);
    }
    if (message.servicePerimeter !== undefined) {
      obj.servicePerimeter = ServicePerimeter.toJSON(message.servicePerimeter);
    }
    if (message.osInventory !== undefined) {
      obj.osInventory = Inventory.toJSON(message.osInventory);
    }
    if (message.relatedAssets !== undefined) {
      obj.relatedAssets = RelatedAssets.toJSON(message.relatedAssets);
    }
    if (message.relatedAsset !== undefined) {
      obj.relatedAsset = RelatedAsset.toJSON(message.relatedAsset);
    }
    if (message.ancestors?.length) {
      obj.ancestors = message.ancestors;
    }
    return obj;
  },

  create(base?: DeepPartial<Asset>): Asset {
    return Asset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Asset>): Asset {
    const message = createBaseAsset();
    message.updateTime = object.updateTime ?? undefined;
    message.name = object.name ?? "";
    message.assetType = object.assetType ?? "";
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? Resource.fromPartial(object.resource)
      : undefined;
    message.iamPolicy = (object.iamPolicy !== undefined && object.iamPolicy !== null)
      ? Policy.fromPartial(object.iamPolicy)
      : undefined;
    message.orgPolicy = object.orgPolicy?.map((e) => Policy1.fromPartial(e)) || [];
    message.accessPolicy = (object.accessPolicy !== undefined && object.accessPolicy !== null)
      ? AccessPolicy.fromPartial(object.accessPolicy)
      : undefined;
    message.accessLevel = (object.accessLevel !== undefined && object.accessLevel !== null)
      ? AccessLevel.fromPartial(object.accessLevel)
      : undefined;
    message.servicePerimeter = (object.servicePerimeter !== undefined && object.servicePerimeter !== null)
      ? ServicePerimeter.fromPartial(object.servicePerimeter)
      : undefined;
    message.osInventory = (object.osInventory !== undefined && object.osInventory !== null)
      ? Inventory.fromPartial(object.osInventory)
      : undefined;
    message.relatedAssets = (object.relatedAssets !== undefined && object.relatedAssets !== null)
      ? RelatedAssets.fromPartial(object.relatedAssets)
      : undefined;
    message.relatedAsset = (object.relatedAsset !== undefined && object.relatedAsset !== null)
      ? RelatedAsset.fromPartial(object.relatedAsset)
      : undefined;
    message.ancestors = object.ancestors?.map((e) => e) || [];
    return message;
  },
};

function createBaseResource(): Resource {
  return {
    version: "",
    discoveryDocumentUri: "",
    discoveryName: "",
    resourceUrl: "",
    parent: "",
    data: undefined,
    location: "",
  };
}

export const Resource: MessageFns<Resource> = {
  encode(message: Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.discoveryDocumentUri !== "") {
      writer.uint32(18).string(message.discoveryDocumentUri);
    }
    if (message.discoveryName !== "") {
      writer.uint32(26).string(message.discoveryName);
    }
    if (message.resourceUrl !== "") {
      writer.uint32(34).string(message.resourceUrl);
    }
    if (message.parent !== "") {
      writer.uint32(42).string(message.parent);
    }
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(50).fork()).join();
    }
    if (message.location !== "") {
      writer.uint32(66).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.discoveryDocumentUri = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.discoveryName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.resourceUrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resource {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      discoveryDocumentUri: isSet(object.discoveryDocumentUri) ? globalThis.String(object.discoveryDocumentUri) : "",
      discoveryName: isSet(object.discoveryName) ? globalThis.String(object.discoveryName) : "",
      resourceUrl: isSet(object.resourceUrl) ? globalThis.String(object.resourceUrl) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      data: isObject(object.data) ? object.data : undefined,
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: Resource): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.discoveryDocumentUri !== "") {
      obj.discoveryDocumentUri = message.discoveryDocumentUri;
    }
    if (message.discoveryName !== "") {
      obj.discoveryName = message.discoveryName;
    }
    if (message.resourceUrl !== "") {
      obj.resourceUrl = message.resourceUrl;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<Resource>): Resource {
    return Resource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Resource>): Resource {
    const message = createBaseResource();
    message.version = object.version ?? "";
    message.discoveryDocumentUri = object.discoveryDocumentUri ?? "";
    message.discoveryName = object.discoveryName ?? "";
    message.resourceUrl = object.resourceUrl ?? "";
    message.parent = object.parent ?? "";
    message.data = object.data ?? undefined;
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseRelatedAssets(): RelatedAssets {
  return { relationshipAttributes: undefined, assets: [] };
}

export const RelatedAssets: MessageFns<RelatedAssets> = {
  encode(message: RelatedAssets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.relationshipAttributes !== undefined) {
      RelationshipAttributes.encode(message.relationshipAttributes, writer.uint32(10).fork()).join();
    }
    for (const v of message.assets) {
      RelatedAsset.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelatedAssets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelatedAssets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.relationshipAttributes = RelationshipAttributes.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assets.push(RelatedAsset.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelatedAssets {
    return {
      relationshipAttributes: isSet(object.relationshipAttributes)
        ? RelationshipAttributes.fromJSON(object.relationshipAttributes)
        : undefined,
      assets: globalThis.Array.isArray(object?.assets) ? object.assets.map((e: any) => RelatedAsset.fromJSON(e)) : [],
    };
  },

  toJSON(message: RelatedAssets): unknown {
    const obj: any = {};
    if (message.relationshipAttributes !== undefined) {
      obj.relationshipAttributes = RelationshipAttributes.toJSON(message.relationshipAttributes);
    }
    if (message.assets?.length) {
      obj.assets = message.assets.map((e) => RelatedAsset.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RelatedAssets>): RelatedAssets {
    return RelatedAssets.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RelatedAssets>): RelatedAssets {
    const message = createBaseRelatedAssets();
    message.relationshipAttributes =
      (object.relationshipAttributes !== undefined && object.relationshipAttributes !== null)
        ? RelationshipAttributes.fromPartial(object.relationshipAttributes)
        : undefined;
    message.assets = object.assets?.map((e) => RelatedAsset.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRelationshipAttributes(): RelationshipAttributes {
  return { type: "", sourceResourceType: "", targetResourceType: "", action: "" };
}

export const RelationshipAttributes: MessageFns<RelationshipAttributes> = {
  encode(message: RelationshipAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.sourceResourceType !== "") {
      writer.uint32(10).string(message.sourceResourceType);
    }
    if (message.targetResourceType !== "") {
      writer.uint32(18).string(message.targetResourceType);
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelationshipAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelationshipAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceResourceType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetResourceType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelationshipAttributes {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      sourceResourceType: isSet(object.sourceResourceType) ? globalThis.String(object.sourceResourceType) : "",
      targetResourceType: isSet(object.targetResourceType) ? globalThis.String(object.targetResourceType) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: RelationshipAttributes): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.sourceResourceType !== "") {
      obj.sourceResourceType = message.sourceResourceType;
    }
    if (message.targetResourceType !== "") {
      obj.targetResourceType = message.targetResourceType;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create(base?: DeepPartial<RelationshipAttributes>): RelationshipAttributes {
    return RelationshipAttributes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RelationshipAttributes>): RelationshipAttributes {
    const message = createBaseRelationshipAttributes();
    message.type = object.type ?? "";
    message.sourceResourceType = object.sourceResourceType ?? "";
    message.targetResourceType = object.targetResourceType ?? "";
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseRelatedAsset(): RelatedAsset {
  return { asset: "", assetType: "", ancestors: [], relationshipType: "" };
}

export const RelatedAsset: MessageFns<RelatedAsset> = {
  encode(message: RelatedAsset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asset !== "") {
      writer.uint32(10).string(message.asset);
    }
    if (message.assetType !== "") {
      writer.uint32(18).string(message.assetType);
    }
    for (const v of message.ancestors) {
      writer.uint32(26).string(v!);
    }
    if (message.relationshipType !== "") {
      writer.uint32(34).string(message.relationshipType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelatedAsset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelatedAsset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ancestors.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.relationshipType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelatedAsset {
    return {
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
      assetType: isSet(object.assetType) ? globalThis.String(object.assetType) : "",
      ancestors: globalThis.Array.isArray(object?.ancestors)
        ? object.ancestors.map((e: any) => globalThis.String(e))
        : [],
      relationshipType: isSet(object.relationshipType) ? globalThis.String(object.relationshipType) : "",
    };
  },

  toJSON(message: RelatedAsset): unknown {
    const obj: any = {};
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.assetType !== "") {
      obj.assetType = message.assetType;
    }
    if (message.ancestors?.length) {
      obj.ancestors = message.ancestors;
    }
    if (message.relationshipType !== "") {
      obj.relationshipType = message.relationshipType;
    }
    return obj;
  },

  create(base?: DeepPartial<RelatedAsset>): RelatedAsset {
    return RelatedAsset.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RelatedAsset>): RelatedAsset {
    const message = createBaseRelatedAsset();
    message.asset = object.asset ?? "";
    message.assetType = object.assetType ?? "";
    message.ancestors = object.ancestors?.map((e) => e) || [];
    message.relationshipType = object.relationshipType ?? "";
    return message;
  },
};

function createBaseTag(): Tag {
  return { tagKey: undefined, tagKeyId: undefined, tagValue: undefined, tagValueId: undefined };
}

export const Tag: MessageFns<Tag> = {
  encode(message: Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagKey !== undefined) {
      writer.uint32(10).string(message.tagKey);
    }
    if (message.tagKeyId !== undefined) {
      writer.uint32(18).string(message.tagKeyId);
    }
    if (message.tagValue !== undefined) {
      writer.uint32(26).string(message.tagValue);
    }
    if (message.tagValueId !== undefined) {
      writer.uint32(34).string(message.tagValueId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tagKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tagKeyId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tagValue = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tagValueId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag {
    return {
      tagKey: isSet(object.tagKey) ? globalThis.String(object.tagKey) : undefined,
      tagKeyId: isSet(object.tagKeyId) ? globalThis.String(object.tagKeyId) : undefined,
      tagValue: isSet(object.tagValue) ? globalThis.String(object.tagValue) : undefined,
      tagValueId: isSet(object.tagValueId) ? globalThis.String(object.tagValueId) : undefined,
    };
  },

  toJSON(message: Tag): unknown {
    const obj: any = {};
    if (message.tagKey !== undefined) {
      obj.tagKey = message.tagKey;
    }
    if (message.tagKeyId !== undefined) {
      obj.tagKeyId = message.tagKeyId;
    }
    if (message.tagValue !== undefined) {
      obj.tagValue = message.tagValue;
    }
    if (message.tagValueId !== undefined) {
      obj.tagValueId = message.tagValueId;
    }
    return obj;
  },

  create(base?: DeepPartial<Tag>): Tag {
    return Tag.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tag>): Tag {
    const message = createBaseTag();
    message.tagKey = object.tagKey ?? undefined;
    message.tagKeyId = object.tagKeyId ?? undefined;
    message.tagValue = object.tagValue ?? undefined;
    message.tagValueId = object.tagValueId ?? undefined;
    return message;
  },
};

function createBaseEffectiveTagDetails(): EffectiveTagDetails {
  return { attachedResource: undefined, effectiveTags: [] };
}

export const EffectiveTagDetails: MessageFns<EffectiveTagDetails> = {
  encode(message: EffectiveTagDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attachedResource !== undefined) {
      writer.uint32(10).string(message.attachedResource);
    }
    for (const v of message.effectiveTags) {
      Tag.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectiveTagDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectiveTagDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attachedResource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.effectiveTags.push(Tag.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectiveTagDetails {
    return {
      attachedResource: isSet(object.attachedResource) ? globalThis.String(object.attachedResource) : undefined,
      effectiveTags: globalThis.Array.isArray(object?.effectiveTags)
        ? object.effectiveTags.map((e: any) => Tag.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EffectiveTagDetails): unknown {
    const obj: any = {};
    if (message.attachedResource !== undefined) {
      obj.attachedResource = message.attachedResource;
    }
    if (message.effectiveTags?.length) {
      obj.effectiveTags = message.effectiveTags.map((e) => Tag.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<EffectiveTagDetails>): EffectiveTagDetails {
    return EffectiveTagDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EffectiveTagDetails>): EffectiveTagDetails {
    const message = createBaseEffectiveTagDetails();
    message.attachedResource = object.attachedResource ?? undefined;
    message.effectiveTags = object.effectiveTags?.map((e) => Tag.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResourceSearchResult(): ResourceSearchResult {
  return {
    name: "",
    assetType: "",
    project: "",
    folders: [],
    organization: "",
    displayName: "",
    description: "",
    location: "",
    labels: {},
    networkTags: [],
    kmsKey: "",
    kmsKeys: [],
    createTime: undefined,
    updateTime: undefined,
    state: "",
    additionalAttributes: undefined,
    parentFullResourceName: "",
    versionedResources: [],
    attachedResources: [],
    relationships: {},
    tagKeys: [],
    tagValues: [],
    tagValueIds: [],
    tags: [],
    effectiveTags: [],
    parentAssetType: "",
    sccSecurityMarks: {},
  };
}

export const ResourceSearchResult: MessageFns<ResourceSearchResult> = {
  encode(message: ResourceSearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.assetType !== "") {
      writer.uint32(18).string(message.assetType);
    }
    if (message.project !== "") {
      writer.uint32(26).string(message.project);
    }
    for (const v of message.folders) {
      writer.uint32(138).string(v!);
    }
    if (message.organization !== "") {
      writer.uint32(146).string(message.organization);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.location !== "") {
      writer.uint32(50).string(message.location);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ResourceSearchResult_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    for (const v of message.networkTags) {
      writer.uint32(66).string(v!);
    }
    if (message.kmsKey !== "") {
      writer.uint32(82).string(message.kmsKey);
    }
    for (const v of message.kmsKeys) {
      writer.uint32(226).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(90).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(98).fork()).join();
    }
    if (message.state !== "") {
      writer.uint32(106).string(message.state);
    }
    if (message.additionalAttributes !== undefined) {
      Struct.encode(Struct.wrap(message.additionalAttributes), writer.uint32(74).fork()).join();
    }
    if (message.parentFullResourceName !== "") {
      writer.uint32(154).string(message.parentFullResourceName);
    }
    for (const v of message.versionedResources) {
      VersionedResource.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.attachedResources) {
      AttachedResource.encode(v!, writer.uint32(162).fork()).join();
    }
    Object.entries(message.relationships).forEach(([key, value]) => {
      ResourceSearchResult_RelationshipsEntry.encode({ key: key as any, value }, writer.uint32(170).fork()).join();
    });
    for (const v of message.tagKeys) {
      writer.uint32(186).string(v!);
    }
    for (const v of message.tagValues) {
      writer.uint32(202).string(v!);
    }
    for (const v of message.tagValueIds) {
      writer.uint32(210).string(v!);
    }
    for (const v of message.tags) {
      Tag.encode(v!, writer.uint32(234).fork()).join();
    }
    for (const v of message.effectiveTags) {
      EffectiveTagDetails.encode(v!, writer.uint32(242).fork()).join();
    }
    if (message.parentAssetType !== "") {
      writer.uint32(826).string(message.parentAssetType);
    }
    Object.entries(message.sccSecurityMarks).forEach(([key, value]) => {
      ResourceSearchResult_SccSecurityMarksEntry.encode({ key: key as any, value }, writer.uint32(258).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceSearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assetType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.project = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.folders.push(reader.string());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.organization = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.location = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = ResourceSearchResult_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.networkTags.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.kmsKey = reader.string();
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.kmsKeys.push(reader.string());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.state = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.additionalAttributes = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.parentFullResourceName = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.versionedResources.push(VersionedResource.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.attachedResources.push(AttachedResource.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          const entry21 = ResourceSearchResult_RelationshipsEntry.decode(reader, reader.uint32());
          if (entry21.value !== undefined) {
            message.relationships[entry21.key] = entry21.value;
          }
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.tagKeys.push(reader.string());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.tagValues.push(reader.string());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.tagValueIds.push(reader.string());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.tags.push(Tag.decode(reader, reader.uint32()));
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.effectiveTags.push(EffectiveTagDetails.decode(reader, reader.uint32()));
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.parentAssetType = reader.string();
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          const entry32 = ResourceSearchResult_SccSecurityMarksEntry.decode(reader, reader.uint32());
          if (entry32.value !== undefined) {
            message.sccSecurityMarks[entry32.key] = entry32.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceSearchResult {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      assetType: isSet(object.assetType) ? globalThis.String(object.assetType) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      folders: globalThis.Array.isArray(object?.folders) ? object.folders.map((e: any) => globalThis.String(e)) : [],
      organization: isSet(object.organization) ? globalThis.String(object.organization) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      networkTags: globalThis.Array.isArray(object?.networkTags)
        ? object.networkTags.map((e: any) => globalThis.String(e))
        : [],
      kmsKey: isSet(object.kmsKey) ? globalThis.String(object.kmsKey) : "",
      kmsKeys: globalThis.Array.isArray(object?.kmsKeys) ? object.kmsKeys.map((e: any) => globalThis.String(e)) : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      additionalAttributes: isObject(object.additionalAttributes) ? object.additionalAttributes : undefined,
      parentFullResourceName: isSet(object.parentFullResourceName)
        ? globalThis.String(object.parentFullResourceName)
        : "",
      versionedResources: globalThis.Array.isArray(object?.versionedResources)
        ? object.versionedResources.map((e: any) => VersionedResource.fromJSON(e))
        : [],
      attachedResources: globalThis.Array.isArray(object?.attachedResources)
        ? object.attachedResources.map((e: any) => AttachedResource.fromJSON(e))
        : [],
      relationships: isObject(object.relationships)
        ? Object.entries(object.relationships).reduce<{ [key: string]: RelatedResources }>((acc, [key, value]) => {
          acc[key] = RelatedResources.fromJSON(value);
          return acc;
        }, {})
        : {},
      tagKeys: globalThis.Array.isArray(object?.tagKeys)
        ? object.tagKeys.map((e: any) => globalThis.String(e))
        : [],
      tagValues: globalThis.Array.isArray(object?.tagValues)
        ? object.tagValues.map((e: any) => globalThis.String(e))
        : [],
      tagValueIds: globalThis.Array.isArray(object?.tagValueIds)
        ? object.tagValueIds.map((e: any) => globalThis.String(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags)
        ? object.tags.map((e: any) => Tag.fromJSON(e))
        : [],
      effectiveTags: globalThis.Array.isArray(object?.effectiveTags)
        ? object.effectiveTags.map((e: any) => EffectiveTagDetails.fromJSON(e))
        : [],
      parentAssetType: isSet(object.parentAssetType) ? globalThis.String(object.parentAssetType) : "",
      sccSecurityMarks: isObject(object.sccSecurityMarks)
        ? Object.entries(object.sccSecurityMarks).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ResourceSearchResult): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.assetType !== "") {
      obj.assetType = message.assetType;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.folders?.length) {
      obj.folders = message.folders;
    }
    if (message.organization !== "") {
      obj.organization = message.organization;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.networkTags?.length) {
      obj.networkTags = message.networkTags;
    }
    if (message.kmsKey !== "") {
      obj.kmsKey = message.kmsKey;
    }
    if (message.kmsKeys?.length) {
      obj.kmsKeys = message.kmsKeys;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.additionalAttributes !== undefined) {
      obj.additionalAttributes = message.additionalAttributes;
    }
    if (message.parentFullResourceName !== "") {
      obj.parentFullResourceName = message.parentFullResourceName;
    }
    if (message.versionedResources?.length) {
      obj.versionedResources = message.versionedResources.map((e) => VersionedResource.toJSON(e));
    }
    if (message.attachedResources?.length) {
      obj.attachedResources = message.attachedResources.map((e) => AttachedResource.toJSON(e));
    }
    if (message.relationships) {
      const entries = Object.entries(message.relationships);
      if (entries.length > 0) {
        obj.relationships = {};
        entries.forEach(([k, v]) => {
          obj.relationships[k] = RelatedResources.toJSON(v);
        });
      }
    }
    if (message.tagKeys?.length) {
      obj.tagKeys = message.tagKeys;
    }
    if (message.tagValues?.length) {
      obj.tagValues = message.tagValues;
    }
    if (message.tagValueIds?.length) {
      obj.tagValueIds = message.tagValueIds;
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => Tag.toJSON(e));
    }
    if (message.effectiveTags?.length) {
      obj.effectiveTags = message.effectiveTags.map((e) => EffectiveTagDetails.toJSON(e));
    }
    if (message.parentAssetType !== "") {
      obj.parentAssetType = message.parentAssetType;
    }
    if (message.sccSecurityMarks) {
      const entries = Object.entries(message.sccSecurityMarks);
      if (entries.length > 0) {
        obj.sccSecurityMarks = {};
        entries.forEach(([k, v]) => {
          obj.sccSecurityMarks[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceSearchResult>): ResourceSearchResult {
    return ResourceSearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceSearchResult>): ResourceSearchResult {
    const message = createBaseResourceSearchResult();
    message.name = object.name ?? "";
    message.assetType = object.assetType ?? "";
    message.project = object.project ?? "";
    message.folders = object.folders?.map((e) => e) || [];
    message.organization = object.organization ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.location = object.location ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.networkTags = object.networkTags?.map((e) => e) || [];
    message.kmsKey = object.kmsKey ?? "";
    message.kmsKeys = object.kmsKeys?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? "";
    message.additionalAttributes = object.additionalAttributes ?? undefined;
    message.parentFullResourceName = object.parentFullResourceName ?? "";
    message.versionedResources = object.versionedResources?.map((e) => VersionedResource.fromPartial(e)) || [];
    message.attachedResources = object.attachedResources?.map((e) => AttachedResource.fromPartial(e)) || [];
    message.relationships = Object.entries(object.relationships ?? {}).reduce<{ [key: string]: RelatedResources }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = RelatedResources.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.tagKeys = object.tagKeys?.map((e) => e) || [];
    message.tagValues = object.tagValues?.map((e) => e) || [];
    message.tagValueIds = object.tagValueIds?.map((e) => e) || [];
    message.tags = object.tags?.map((e) => Tag.fromPartial(e)) || [];
    message.effectiveTags = object.effectiveTags?.map((e) => EffectiveTagDetails.fromPartial(e)) || [];
    message.parentAssetType = object.parentAssetType ?? "";
    message.sccSecurityMarks = Object.entries(object.sccSecurityMarks ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseResourceSearchResult_LabelsEntry(): ResourceSearchResult_LabelsEntry {
  return { key: "", value: "" };
}

export const ResourceSearchResult_LabelsEntry: MessageFns<ResourceSearchResult_LabelsEntry> = {
  encode(message: ResourceSearchResult_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceSearchResult_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceSearchResult_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceSearchResult_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ResourceSearchResult_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceSearchResult_LabelsEntry>): ResourceSearchResult_LabelsEntry {
    return ResourceSearchResult_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceSearchResult_LabelsEntry>): ResourceSearchResult_LabelsEntry {
    const message = createBaseResourceSearchResult_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseResourceSearchResult_RelationshipsEntry(): ResourceSearchResult_RelationshipsEntry {
  return { key: "", value: undefined };
}

export const ResourceSearchResult_RelationshipsEntry: MessageFns<ResourceSearchResult_RelationshipsEntry> = {
  encode(message: ResourceSearchResult_RelationshipsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      RelatedResources.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceSearchResult_RelationshipsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceSearchResult_RelationshipsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = RelatedResources.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceSearchResult_RelationshipsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? RelatedResources.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ResourceSearchResult_RelationshipsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = RelatedResources.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceSearchResult_RelationshipsEntry>): ResourceSearchResult_RelationshipsEntry {
    return ResourceSearchResult_RelationshipsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceSearchResult_RelationshipsEntry>): ResourceSearchResult_RelationshipsEntry {
    const message = createBaseResourceSearchResult_RelationshipsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? RelatedResources.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseResourceSearchResult_SccSecurityMarksEntry(): ResourceSearchResult_SccSecurityMarksEntry {
  return { key: "", value: "" };
}

export const ResourceSearchResult_SccSecurityMarksEntry: MessageFns<ResourceSearchResult_SccSecurityMarksEntry> = {
  encode(message: ResourceSearchResult_SccSecurityMarksEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceSearchResult_SccSecurityMarksEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceSearchResult_SccSecurityMarksEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceSearchResult_SccSecurityMarksEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ResourceSearchResult_SccSecurityMarksEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceSearchResult_SccSecurityMarksEntry>): ResourceSearchResult_SccSecurityMarksEntry {
    return ResourceSearchResult_SccSecurityMarksEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ResourceSearchResult_SccSecurityMarksEntry>,
  ): ResourceSearchResult_SccSecurityMarksEntry {
    const message = createBaseResourceSearchResult_SccSecurityMarksEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseVersionedResource(): VersionedResource {
  return { version: "", resource: undefined };
}

export const VersionedResource: MessageFns<VersionedResource> = {
  encode(message: VersionedResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.resource !== undefined) {
      Struct.encode(Struct.wrap(message.resource), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionedResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionedResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resource = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VersionedResource {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      resource: isObject(object.resource) ? object.resource : undefined,
    };
  },

  toJSON(message: VersionedResource): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.resource !== undefined) {
      obj.resource = message.resource;
    }
    return obj;
  },

  create(base?: DeepPartial<VersionedResource>): VersionedResource {
    return VersionedResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VersionedResource>): VersionedResource {
    const message = createBaseVersionedResource();
    message.version = object.version ?? "";
    message.resource = object.resource ?? undefined;
    return message;
  },
};

function createBaseAttachedResource(): AttachedResource {
  return { assetType: "", versionedResources: [] };
}

export const AttachedResource: MessageFns<AttachedResource> = {
  encode(message: AttachedResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetType !== "") {
      writer.uint32(10).string(message.assetType);
    }
    for (const v of message.versionedResources) {
      VersionedResource.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttachedResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachedResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.versionedResources.push(VersionedResource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttachedResource {
    return {
      assetType: isSet(object.assetType) ? globalThis.String(object.assetType) : "",
      versionedResources: globalThis.Array.isArray(object?.versionedResources)
        ? object.versionedResources.map((e: any) => VersionedResource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AttachedResource): unknown {
    const obj: any = {};
    if (message.assetType !== "") {
      obj.assetType = message.assetType;
    }
    if (message.versionedResources?.length) {
      obj.versionedResources = message.versionedResources.map((e) => VersionedResource.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AttachedResource>): AttachedResource {
    return AttachedResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttachedResource>): AttachedResource {
    const message = createBaseAttachedResource();
    message.assetType = object.assetType ?? "";
    message.versionedResources = object.versionedResources?.map((e) => VersionedResource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRelatedResources(): RelatedResources {
  return { relatedResources: [] };
}

export const RelatedResources: MessageFns<RelatedResources> = {
  encode(message: RelatedResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.relatedResources) {
      RelatedResource.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelatedResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelatedResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.relatedResources.push(RelatedResource.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelatedResources {
    return {
      relatedResources: globalThis.Array.isArray(object?.relatedResources)
        ? object.relatedResources.map((e: any) => RelatedResource.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RelatedResources): unknown {
    const obj: any = {};
    if (message.relatedResources?.length) {
      obj.relatedResources = message.relatedResources.map((e) => RelatedResource.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RelatedResources>): RelatedResources {
    return RelatedResources.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RelatedResources>): RelatedResources {
    const message = createBaseRelatedResources();
    message.relatedResources = object.relatedResources?.map((e) => RelatedResource.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRelatedResource(): RelatedResource {
  return { assetType: "", fullResourceName: "" };
}

export const RelatedResource: MessageFns<RelatedResource> = {
  encode(message: RelatedResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetType !== "") {
      writer.uint32(10).string(message.assetType);
    }
    if (message.fullResourceName !== "") {
      writer.uint32(18).string(message.fullResourceName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RelatedResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRelatedResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fullResourceName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RelatedResource {
    return {
      assetType: isSet(object.assetType) ? globalThis.String(object.assetType) : "",
      fullResourceName: isSet(object.fullResourceName) ? globalThis.String(object.fullResourceName) : "",
    };
  },

  toJSON(message: RelatedResource): unknown {
    const obj: any = {};
    if (message.assetType !== "") {
      obj.assetType = message.assetType;
    }
    if (message.fullResourceName !== "") {
      obj.fullResourceName = message.fullResourceName;
    }
    return obj;
  },

  create(base?: DeepPartial<RelatedResource>): RelatedResource {
    return RelatedResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RelatedResource>): RelatedResource {
    const message = createBaseRelatedResource();
    message.assetType = object.assetType ?? "";
    message.fullResourceName = object.fullResourceName ?? "";
    return message;
  },
};

function createBaseIamPolicySearchResult(): IamPolicySearchResult {
  return {
    resource: "",
    assetType: "",
    project: "",
    folders: [],
    organization: "",
    policy: undefined,
    explanation: undefined,
  };
}

export const IamPolicySearchResult: MessageFns<IamPolicySearchResult> = {
  encode(message: IamPolicySearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.assetType !== "") {
      writer.uint32(42).string(message.assetType);
    }
    if (message.project !== "") {
      writer.uint32(18).string(message.project);
    }
    for (const v of message.folders) {
      writer.uint32(50).string(v!);
    }
    if (message.organization !== "") {
      writer.uint32(58).string(message.organization);
    }
    if (message.policy !== undefined) {
      Policy.encode(message.policy, writer.uint32(26).fork()).join();
    }
    if (message.explanation !== undefined) {
      IamPolicySearchResult_Explanation.encode(message.explanation, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicySearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicySearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.assetType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.project = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.folders.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.organization = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.policy = Policy.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.explanation = IamPolicySearchResult_Explanation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicySearchResult {
    return {
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      assetType: isSet(object.assetType) ? globalThis.String(object.assetType) : "",
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      folders: globalThis.Array.isArray(object?.folders) ? object.folders.map((e: any) => globalThis.String(e)) : [],
      organization: isSet(object.organization) ? globalThis.String(object.organization) : "",
      policy: isSet(object.policy) ? Policy.fromJSON(object.policy) : undefined,
      explanation: isSet(object.explanation)
        ? IamPolicySearchResult_Explanation.fromJSON(object.explanation)
        : undefined,
    };
  },

  toJSON(message: IamPolicySearchResult): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.assetType !== "") {
      obj.assetType = message.assetType;
    }
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.folders?.length) {
      obj.folders = message.folders;
    }
    if (message.organization !== "") {
      obj.organization = message.organization;
    }
    if (message.policy !== undefined) {
      obj.policy = Policy.toJSON(message.policy);
    }
    if (message.explanation !== undefined) {
      obj.explanation = IamPolicySearchResult_Explanation.toJSON(message.explanation);
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicySearchResult>): IamPolicySearchResult {
    return IamPolicySearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicySearchResult>): IamPolicySearchResult {
    const message = createBaseIamPolicySearchResult();
    message.resource = object.resource ?? "";
    message.assetType = object.assetType ?? "";
    message.project = object.project ?? "";
    message.folders = object.folders?.map((e) => e) || [];
    message.organization = object.organization ?? "";
    message.policy = (object.policy !== undefined && object.policy !== null)
      ? Policy.fromPartial(object.policy)
      : undefined;
    message.explanation = (object.explanation !== undefined && object.explanation !== null)
      ? IamPolicySearchResult_Explanation.fromPartial(object.explanation)
      : undefined;
    return message;
  },
};

function createBaseIamPolicySearchResult_Explanation(): IamPolicySearchResult_Explanation {
  return { matchedPermissions: {} };
}

export const IamPolicySearchResult_Explanation: MessageFns<IamPolicySearchResult_Explanation> = {
  encode(message: IamPolicySearchResult_Explanation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.matchedPermissions).forEach(([key, value]) => {
      IamPolicySearchResult_Explanation_MatchedPermissionsEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicySearchResult_Explanation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicySearchResult_Explanation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = IamPolicySearchResult_Explanation_MatchedPermissionsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.matchedPermissions[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicySearchResult_Explanation {
    return {
      matchedPermissions: isObject(object.matchedPermissions)
        ? Object.entries(object.matchedPermissions).reduce<
          { [key: string]: IamPolicySearchResult_Explanation_Permissions }
        >((acc, [key, value]) => {
          acc[key] = IamPolicySearchResult_Explanation_Permissions.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: IamPolicySearchResult_Explanation): unknown {
    const obj: any = {};
    if (message.matchedPermissions) {
      const entries = Object.entries(message.matchedPermissions);
      if (entries.length > 0) {
        obj.matchedPermissions = {};
        entries.forEach(([k, v]) => {
          obj.matchedPermissions[k] = IamPolicySearchResult_Explanation_Permissions.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicySearchResult_Explanation>): IamPolicySearchResult_Explanation {
    return IamPolicySearchResult_Explanation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicySearchResult_Explanation>): IamPolicySearchResult_Explanation {
    const message = createBaseIamPolicySearchResult_Explanation();
    message.matchedPermissions = Object.entries(object.matchedPermissions ?? {}).reduce<
      { [key: string]: IamPolicySearchResult_Explanation_Permissions }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = IamPolicySearchResult_Explanation_Permissions.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseIamPolicySearchResult_Explanation_Permissions(): IamPolicySearchResult_Explanation_Permissions {
  return { permissions: [] };
}

export const IamPolicySearchResult_Explanation_Permissions: MessageFns<IamPolicySearchResult_Explanation_Permissions> =
  {
    encode(
      message: IamPolicySearchResult_Explanation_Permissions,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.permissions) {
        writer.uint32(10).string(v!);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): IamPolicySearchResult_Explanation_Permissions {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseIamPolicySearchResult_Explanation_Permissions();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.permissions.push(reader.string());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): IamPolicySearchResult_Explanation_Permissions {
      return {
        permissions: globalThis.Array.isArray(object?.permissions)
          ? object.permissions.map((e: any) => globalThis.String(e))
          : [],
      };
    },

    toJSON(message: IamPolicySearchResult_Explanation_Permissions): unknown {
      const obj: any = {};
      if (message.permissions?.length) {
        obj.permissions = message.permissions;
      }
      return obj;
    },

    create(
      base?: DeepPartial<IamPolicySearchResult_Explanation_Permissions>,
    ): IamPolicySearchResult_Explanation_Permissions {
      return IamPolicySearchResult_Explanation_Permissions.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<IamPolicySearchResult_Explanation_Permissions>,
    ): IamPolicySearchResult_Explanation_Permissions {
      const message = createBaseIamPolicySearchResult_Explanation_Permissions();
      message.permissions = object.permissions?.map((e) => e) || [];
      return message;
    },
  };

function createBaseIamPolicySearchResult_Explanation_MatchedPermissionsEntry(): IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
  return { key: "", value: undefined };
}

export const IamPolicySearchResult_Explanation_MatchedPermissionsEntry: MessageFns<
  IamPolicySearchResult_Explanation_MatchedPermissionsEntry
> = {
  encode(
    message: IamPolicySearchResult_Explanation_MatchedPermissionsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      IamPolicySearchResult_Explanation_Permissions.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicySearchResult_Explanation_MatchedPermissionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = IamPolicySearchResult_Explanation_Permissions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? IamPolicySearchResult_Explanation_Permissions.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: IamPolicySearchResult_Explanation_MatchedPermissionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = IamPolicySearchResult_Explanation_Permissions.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<IamPolicySearchResult_Explanation_MatchedPermissionsEntry>,
  ): IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
    return IamPolicySearchResult_Explanation_MatchedPermissionsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<IamPolicySearchResult_Explanation_MatchedPermissionsEntry>,
  ): IamPolicySearchResult_Explanation_MatchedPermissionsEntry {
    const message = createBaseIamPolicySearchResult_Explanation_MatchedPermissionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? IamPolicySearchResult_Explanation_Permissions.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseIamPolicyAnalysisState(): IamPolicyAnalysisState {
  return { code: 0, cause: "" };
}

export const IamPolicyAnalysisState: MessageFns<IamPolicyAnalysisState> = {
  encode(message: IamPolicyAnalysisState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.cause !== "") {
      writer.uint32(18).string(message.cause);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicyAnalysisState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicyAnalysisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cause = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicyAnalysisState {
    return {
      code: isSet(object.code) ? codeFromJSON(object.code) : 0,
      cause: isSet(object.cause) ? globalThis.String(object.cause) : "",
    };
  },

  toJSON(message: IamPolicyAnalysisState): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = codeToJSON(message.code);
    }
    if (message.cause !== "") {
      obj.cause = message.cause;
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicyAnalysisState>): IamPolicyAnalysisState {
    return IamPolicyAnalysisState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicyAnalysisState>): IamPolicyAnalysisState {
    const message = createBaseIamPolicyAnalysisState();
    message.code = object.code ?? 0;
    message.cause = object.cause ?? "";
    return message;
  },
};

function createBaseConditionEvaluation(): ConditionEvaluation {
  return { evaluationValue: 0 };
}

export const ConditionEvaluation: MessageFns<ConditionEvaluation> = {
  encode(message: ConditionEvaluation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evaluationValue !== 0) {
      writer.uint32(8).int32(message.evaluationValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionEvaluation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionEvaluation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.evaluationValue = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionEvaluation {
    return {
      evaluationValue: isSet(object.evaluationValue)
        ? conditionEvaluation_EvaluationValueFromJSON(object.evaluationValue)
        : 0,
    };
  },

  toJSON(message: ConditionEvaluation): unknown {
    const obj: any = {};
    if (message.evaluationValue !== 0) {
      obj.evaluationValue = conditionEvaluation_EvaluationValueToJSON(message.evaluationValue);
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionEvaluation>): ConditionEvaluation {
    return ConditionEvaluation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionEvaluation>): ConditionEvaluation {
    const message = createBaseConditionEvaluation();
    message.evaluationValue = object.evaluationValue ?? 0;
    return message;
  },
};

function createBaseIamPolicyAnalysisResult(): IamPolicyAnalysisResult {
  return {
    attachedResourceFullName: "",
    iamBinding: undefined,
    accessControlLists: [],
    identityList: undefined,
    fullyExplored: false,
  };
}

export const IamPolicyAnalysisResult: MessageFns<IamPolicyAnalysisResult> = {
  encode(message: IamPolicyAnalysisResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attachedResourceFullName !== "") {
      writer.uint32(10).string(message.attachedResourceFullName);
    }
    if (message.iamBinding !== undefined) {
      Binding.encode(message.iamBinding, writer.uint32(18).fork()).join();
    }
    for (const v of message.accessControlLists) {
      IamPolicyAnalysisResult_AccessControlList.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.identityList !== undefined) {
      IamPolicyAnalysisResult_IdentityList.encode(message.identityList, writer.uint32(34).fork()).join();
    }
    if (message.fullyExplored !== false) {
      writer.uint32(40).bool(message.fullyExplored);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicyAnalysisResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicyAnalysisResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attachedResourceFullName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.iamBinding = Binding.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accessControlLists.push(IamPolicyAnalysisResult_AccessControlList.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.identityList = IamPolicyAnalysisResult_IdentityList.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fullyExplored = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicyAnalysisResult {
    return {
      attachedResourceFullName: isSet(object.attachedResourceFullName)
        ? globalThis.String(object.attachedResourceFullName)
        : "",
      iamBinding: isSet(object.iamBinding) ? Binding.fromJSON(object.iamBinding) : undefined,
      accessControlLists: globalThis.Array.isArray(object?.accessControlLists)
        ? object.accessControlLists.map((e: any) => IamPolicyAnalysisResult_AccessControlList.fromJSON(e))
        : [],
      identityList: isSet(object.identityList)
        ? IamPolicyAnalysisResult_IdentityList.fromJSON(object.identityList)
        : undefined,
      fullyExplored: isSet(object.fullyExplored) ? globalThis.Boolean(object.fullyExplored) : false,
    };
  },

  toJSON(message: IamPolicyAnalysisResult): unknown {
    const obj: any = {};
    if (message.attachedResourceFullName !== "") {
      obj.attachedResourceFullName = message.attachedResourceFullName;
    }
    if (message.iamBinding !== undefined) {
      obj.iamBinding = Binding.toJSON(message.iamBinding);
    }
    if (message.accessControlLists?.length) {
      obj.accessControlLists = message.accessControlLists.map((e) =>
        IamPolicyAnalysisResult_AccessControlList.toJSON(e)
      );
    }
    if (message.identityList !== undefined) {
      obj.identityList = IamPolicyAnalysisResult_IdentityList.toJSON(message.identityList);
    }
    if (message.fullyExplored !== false) {
      obj.fullyExplored = message.fullyExplored;
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicyAnalysisResult>): IamPolicyAnalysisResult {
    return IamPolicyAnalysisResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicyAnalysisResult>): IamPolicyAnalysisResult {
    const message = createBaseIamPolicyAnalysisResult();
    message.attachedResourceFullName = object.attachedResourceFullName ?? "";
    message.iamBinding = (object.iamBinding !== undefined && object.iamBinding !== null)
      ? Binding.fromPartial(object.iamBinding)
      : undefined;
    message.accessControlLists =
      object.accessControlLists?.map((e) => IamPolicyAnalysisResult_AccessControlList.fromPartial(e)) || [];
    message.identityList = (object.identityList !== undefined && object.identityList !== null)
      ? IamPolicyAnalysisResult_IdentityList.fromPartial(object.identityList)
      : undefined;
    message.fullyExplored = object.fullyExplored ?? false;
    return message;
  },
};

function createBaseIamPolicyAnalysisResult_Resource(): IamPolicyAnalysisResult_Resource {
  return { fullResourceName: "", analysisState: undefined };
}

export const IamPolicyAnalysisResult_Resource: MessageFns<IamPolicyAnalysisResult_Resource> = {
  encode(message: IamPolicyAnalysisResult_Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fullResourceName !== "") {
      writer.uint32(10).string(message.fullResourceName);
    }
    if (message.analysisState !== undefined) {
      IamPolicyAnalysisState.encode(message.analysisState, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicyAnalysisResult_Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicyAnalysisResult_Resource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fullResourceName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.analysisState = IamPolicyAnalysisState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicyAnalysisResult_Resource {
    return {
      fullResourceName: isSet(object.fullResourceName) ? globalThis.String(object.fullResourceName) : "",
      analysisState: isSet(object.analysisState) ? IamPolicyAnalysisState.fromJSON(object.analysisState) : undefined,
    };
  },

  toJSON(message: IamPolicyAnalysisResult_Resource): unknown {
    const obj: any = {};
    if (message.fullResourceName !== "") {
      obj.fullResourceName = message.fullResourceName;
    }
    if (message.analysisState !== undefined) {
      obj.analysisState = IamPolicyAnalysisState.toJSON(message.analysisState);
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicyAnalysisResult_Resource>): IamPolicyAnalysisResult_Resource {
    return IamPolicyAnalysisResult_Resource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicyAnalysisResult_Resource>): IamPolicyAnalysisResult_Resource {
    const message = createBaseIamPolicyAnalysisResult_Resource();
    message.fullResourceName = object.fullResourceName ?? "";
    message.analysisState = (object.analysisState !== undefined && object.analysisState !== null)
      ? IamPolicyAnalysisState.fromPartial(object.analysisState)
      : undefined;
    return message;
  },
};

function createBaseIamPolicyAnalysisResult_Access(): IamPolicyAnalysisResult_Access {
  return { role: undefined, permission: undefined, analysisState: undefined };
}

export const IamPolicyAnalysisResult_Access: MessageFns<IamPolicyAnalysisResult_Access> = {
  encode(message: IamPolicyAnalysisResult_Access, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== undefined) {
      writer.uint32(10).string(message.role);
    }
    if (message.permission !== undefined) {
      writer.uint32(18).string(message.permission);
    }
    if (message.analysisState !== undefined) {
      IamPolicyAnalysisState.encode(message.analysisState, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicyAnalysisResult_Access {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicyAnalysisResult_Access();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.permission = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.analysisState = IamPolicyAnalysisState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicyAnalysisResult_Access {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : undefined,
      permission: isSet(object.permission) ? globalThis.String(object.permission) : undefined,
      analysisState: isSet(object.analysisState) ? IamPolicyAnalysisState.fromJSON(object.analysisState) : undefined,
    };
  },

  toJSON(message: IamPolicyAnalysisResult_Access): unknown {
    const obj: any = {};
    if (message.role !== undefined) {
      obj.role = message.role;
    }
    if (message.permission !== undefined) {
      obj.permission = message.permission;
    }
    if (message.analysisState !== undefined) {
      obj.analysisState = IamPolicyAnalysisState.toJSON(message.analysisState);
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicyAnalysisResult_Access>): IamPolicyAnalysisResult_Access {
    return IamPolicyAnalysisResult_Access.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicyAnalysisResult_Access>): IamPolicyAnalysisResult_Access {
    const message = createBaseIamPolicyAnalysisResult_Access();
    message.role = object.role ?? undefined;
    message.permission = object.permission ?? undefined;
    message.analysisState = (object.analysisState !== undefined && object.analysisState !== null)
      ? IamPolicyAnalysisState.fromPartial(object.analysisState)
      : undefined;
    return message;
  },
};

function createBaseIamPolicyAnalysisResult_Identity(): IamPolicyAnalysisResult_Identity {
  return { name: "", analysisState: undefined };
}

export const IamPolicyAnalysisResult_Identity: MessageFns<IamPolicyAnalysisResult_Identity> = {
  encode(message: IamPolicyAnalysisResult_Identity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.analysisState !== undefined) {
      IamPolicyAnalysisState.encode(message.analysisState, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicyAnalysisResult_Identity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicyAnalysisResult_Identity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.analysisState = IamPolicyAnalysisState.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicyAnalysisResult_Identity {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      analysisState: isSet(object.analysisState) ? IamPolicyAnalysisState.fromJSON(object.analysisState) : undefined,
    };
  },

  toJSON(message: IamPolicyAnalysisResult_Identity): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.analysisState !== undefined) {
      obj.analysisState = IamPolicyAnalysisState.toJSON(message.analysisState);
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicyAnalysisResult_Identity>): IamPolicyAnalysisResult_Identity {
    return IamPolicyAnalysisResult_Identity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicyAnalysisResult_Identity>): IamPolicyAnalysisResult_Identity {
    const message = createBaseIamPolicyAnalysisResult_Identity();
    message.name = object.name ?? "";
    message.analysisState = (object.analysisState !== undefined && object.analysisState !== null)
      ? IamPolicyAnalysisState.fromPartial(object.analysisState)
      : undefined;
    return message;
  },
};

function createBaseIamPolicyAnalysisResult_Edge(): IamPolicyAnalysisResult_Edge {
  return { sourceNode: "", targetNode: "" };
}

export const IamPolicyAnalysisResult_Edge: MessageFns<IamPolicyAnalysisResult_Edge> = {
  encode(message: IamPolicyAnalysisResult_Edge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceNode !== "") {
      writer.uint32(10).string(message.sourceNode);
    }
    if (message.targetNode !== "") {
      writer.uint32(18).string(message.targetNode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicyAnalysisResult_Edge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicyAnalysisResult_Edge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceNode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetNode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicyAnalysisResult_Edge {
    return {
      sourceNode: isSet(object.sourceNode) ? globalThis.String(object.sourceNode) : "",
      targetNode: isSet(object.targetNode) ? globalThis.String(object.targetNode) : "",
    };
  },

  toJSON(message: IamPolicyAnalysisResult_Edge): unknown {
    const obj: any = {};
    if (message.sourceNode !== "") {
      obj.sourceNode = message.sourceNode;
    }
    if (message.targetNode !== "") {
      obj.targetNode = message.targetNode;
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicyAnalysisResult_Edge>): IamPolicyAnalysisResult_Edge {
    return IamPolicyAnalysisResult_Edge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicyAnalysisResult_Edge>): IamPolicyAnalysisResult_Edge {
    const message = createBaseIamPolicyAnalysisResult_Edge();
    message.sourceNode = object.sourceNode ?? "";
    message.targetNode = object.targetNode ?? "";
    return message;
  },
};

function createBaseIamPolicyAnalysisResult_AccessControlList(): IamPolicyAnalysisResult_AccessControlList {
  return { resources: [], accesses: [], resourceEdges: [], conditionEvaluation: undefined };
}

export const IamPolicyAnalysisResult_AccessControlList: MessageFns<IamPolicyAnalysisResult_AccessControlList> = {
  encode(message: IamPolicyAnalysisResult_AccessControlList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.resources) {
      IamPolicyAnalysisResult_Resource.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.accesses) {
      IamPolicyAnalysisResult_Access.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.resourceEdges) {
      IamPolicyAnalysisResult_Edge.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.conditionEvaluation !== undefined) {
      ConditionEvaluation.encode(message.conditionEvaluation, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicyAnalysisResult_AccessControlList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicyAnalysisResult_AccessControlList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resources.push(IamPolicyAnalysisResult_Resource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accesses.push(IamPolicyAnalysisResult_Access.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resourceEdges.push(IamPolicyAnalysisResult_Edge.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.conditionEvaluation = ConditionEvaluation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicyAnalysisResult_AccessControlList {
    return {
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => IamPolicyAnalysisResult_Resource.fromJSON(e))
        : [],
      accesses: globalThis.Array.isArray(object?.accesses)
        ? object.accesses.map((e: any) => IamPolicyAnalysisResult_Access.fromJSON(e))
        : [],
      resourceEdges: globalThis.Array.isArray(object?.resourceEdges)
        ? object.resourceEdges.map((e: any) => IamPolicyAnalysisResult_Edge.fromJSON(e))
        : [],
      conditionEvaluation: isSet(object.conditionEvaluation)
        ? ConditionEvaluation.fromJSON(object.conditionEvaluation)
        : undefined,
    };
  },

  toJSON(message: IamPolicyAnalysisResult_AccessControlList): unknown {
    const obj: any = {};
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => IamPolicyAnalysisResult_Resource.toJSON(e));
    }
    if (message.accesses?.length) {
      obj.accesses = message.accesses.map((e) => IamPolicyAnalysisResult_Access.toJSON(e));
    }
    if (message.resourceEdges?.length) {
      obj.resourceEdges = message.resourceEdges.map((e) => IamPolicyAnalysisResult_Edge.toJSON(e));
    }
    if (message.conditionEvaluation !== undefined) {
      obj.conditionEvaluation = ConditionEvaluation.toJSON(message.conditionEvaluation);
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicyAnalysisResult_AccessControlList>): IamPolicyAnalysisResult_AccessControlList {
    return IamPolicyAnalysisResult_AccessControlList.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<IamPolicyAnalysisResult_AccessControlList>,
  ): IamPolicyAnalysisResult_AccessControlList {
    const message = createBaseIamPolicyAnalysisResult_AccessControlList();
    message.resources = object.resources?.map((e) => IamPolicyAnalysisResult_Resource.fromPartial(e)) || [];
    message.accesses = object.accesses?.map((e) => IamPolicyAnalysisResult_Access.fromPartial(e)) || [];
    message.resourceEdges = object.resourceEdges?.map((e) => IamPolicyAnalysisResult_Edge.fromPartial(e)) || [];
    message.conditionEvaluation = (object.conditionEvaluation !== undefined && object.conditionEvaluation !== null)
      ? ConditionEvaluation.fromPartial(object.conditionEvaluation)
      : undefined;
    return message;
  },
};

function createBaseIamPolicyAnalysisResult_IdentityList(): IamPolicyAnalysisResult_IdentityList {
  return { identities: [], groupEdges: [] };
}

export const IamPolicyAnalysisResult_IdentityList: MessageFns<IamPolicyAnalysisResult_IdentityList> = {
  encode(message: IamPolicyAnalysisResult_IdentityList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.identities) {
      IamPolicyAnalysisResult_Identity.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.groupEdges) {
      IamPolicyAnalysisResult_Edge.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IamPolicyAnalysisResult_IdentityList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIamPolicyAnalysisResult_IdentityList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.identities.push(IamPolicyAnalysisResult_Identity.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupEdges.push(IamPolicyAnalysisResult_Edge.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IamPolicyAnalysisResult_IdentityList {
    return {
      identities: globalThis.Array.isArray(object?.identities)
        ? object.identities.map((e: any) => IamPolicyAnalysisResult_Identity.fromJSON(e))
        : [],
      groupEdges: globalThis.Array.isArray(object?.groupEdges)
        ? object.groupEdges.map((e: any) => IamPolicyAnalysisResult_Edge.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IamPolicyAnalysisResult_IdentityList): unknown {
    const obj: any = {};
    if (message.identities?.length) {
      obj.identities = message.identities.map((e) => IamPolicyAnalysisResult_Identity.toJSON(e));
    }
    if (message.groupEdges?.length) {
      obj.groupEdges = message.groupEdges.map((e) => IamPolicyAnalysisResult_Edge.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IamPolicyAnalysisResult_IdentityList>): IamPolicyAnalysisResult_IdentityList {
    return IamPolicyAnalysisResult_IdentityList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IamPolicyAnalysisResult_IdentityList>): IamPolicyAnalysisResult_IdentityList {
    const message = createBaseIamPolicyAnalysisResult_IdentityList();
    message.identities = object.identities?.map((e) => IamPolicyAnalysisResult_Identity.fromPartial(e)) || [];
    message.groupEdges = object.groupEdges?.map((e) => IamPolicyAnalysisResult_Edge.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
