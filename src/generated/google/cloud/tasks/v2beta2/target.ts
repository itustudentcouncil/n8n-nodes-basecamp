// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/tasks/v2beta2/target.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.tasks.v2beta2";

/** The HTTP method used to execute the task. */
export enum HttpMethod {
  /** HTTP_METHOD_UNSPECIFIED - HTTP method unspecified */
  HTTP_METHOD_UNSPECIFIED = 0,
  /** POST - HTTP POST */
  POST = 1,
  /** GET - HTTP GET */
  GET = 2,
  /** HEAD - HTTP HEAD */
  HEAD = 3,
  /** PUT - HTTP PUT */
  PUT = 4,
  /** DELETE - HTTP DELETE */
  DELETE = 5,
  /** PATCH - HTTP PATCH */
  PATCH = 6,
  /** OPTIONS - HTTP OPTIONS */
  OPTIONS = 7,
  UNRECOGNIZED = -1,
}

export function httpMethodFromJSON(object: any): HttpMethod {
  switch (object) {
    case 0:
    case "HTTP_METHOD_UNSPECIFIED":
      return HttpMethod.HTTP_METHOD_UNSPECIFIED;
    case 1:
    case "POST":
      return HttpMethod.POST;
    case 2:
    case "GET":
      return HttpMethod.GET;
    case 3:
    case "HEAD":
      return HttpMethod.HEAD;
    case 4:
    case "PUT":
      return HttpMethod.PUT;
    case 5:
    case "DELETE":
      return HttpMethod.DELETE;
    case 6:
    case "PATCH":
      return HttpMethod.PATCH;
    case 7:
    case "OPTIONS":
      return HttpMethod.OPTIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HttpMethod.UNRECOGNIZED;
  }
}

export function httpMethodToJSON(object: HttpMethod): string {
  switch (object) {
    case HttpMethod.HTTP_METHOD_UNSPECIFIED:
      return "HTTP_METHOD_UNSPECIFIED";
    case HttpMethod.POST:
      return "POST";
    case HttpMethod.GET:
      return "GET";
    case HttpMethod.HEAD:
      return "HEAD";
    case HttpMethod.PUT:
      return "PUT";
    case HttpMethod.DELETE:
      return "DELETE";
    case HttpMethod.PATCH:
      return "PATCH";
    case HttpMethod.OPTIONS:
      return "OPTIONS";
    case HttpMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Pull target. */
export interface PullTarget {
}

/**
 * The pull message contains data that can be used by the caller of
 * [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] to process the
 * task.
 *
 * This proto can only be used for tasks in a queue which has
 * [pull_target][google.cloud.tasks.v2beta2.Queue.pull_target] set.
 */
export interface PullMessage {
  /** A data payload consumed by the worker to execute the task. */
  payload: Buffer;
  /**
   * The task's tag.
   *
   * Tags allow similar tasks to be processed in a batch. If you label
   * tasks with a tag, your worker can
   * [lease tasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] with the
   * same tag using
   * [filter][google.cloud.tasks.v2beta2.LeaseTasksRequest.filter]. For example,
   * if you want to aggregate the events associated with a specific user once a
   * day, you could tag tasks with the user ID.
   *
   * The task's tag can only be set when the
   * [task is created][google.cloud.tasks.v2beta2.CloudTasks.CreateTask].
   *
   * The tag must be less than 500 characters.
   *
   * SDK compatibility: Although the SDK allows tags to be either
   * string or
   * [bytes](https://cloud.google.com/appengine/docs/standard/java/javadoc/com/google/appengine/api/taskqueue/TaskOptions.html#tag-byte:A-),
   * only UTF-8 encoded tags can be used in Cloud Tasks. If a tag isn't UTF-8
   * encoded, the tag will be empty when the task is returned by Cloud Tasks.
   */
  tag: string;
}

/**
 * App Engine HTTP target.
 *
 * The task will be delivered to the App Engine application hostname
 * specified by its
 * [AppEngineHttpTarget][google.cloud.tasks.v2beta2.AppEngineHttpTarget] and
 * [AppEngineHttpRequest][google.cloud.tasks.v2beta2.AppEngineHttpRequest]. The
 * documentation for
 * [AppEngineHttpRequest][google.cloud.tasks.v2beta2.AppEngineHttpRequest]
 * explains how the task's host URL is constructed.
 *
 * Using [AppEngineHttpTarget][google.cloud.tasks.v2beta2.AppEngineHttpTarget]
 * requires
 * [`appengine.applications.get`](https://cloud.google.com/appengine/docs/admin-api/access-control)
 * Google IAM permission for the project
 * and the following scope:
 *
 * `https://www.googleapis.com/auth/cloud-platform`
 */
export interface AppEngineHttpTarget {
  /**
   * Overrides for the
   * [task-level
   * app_engine_routing][google.cloud.tasks.v2beta2.AppEngineHttpRequest.app_engine_routing].
   *
   * If set, `app_engine_routing_override` is used for all tasks in
   * the queue, no matter what the setting is for the
   * [task-level
   * app_engine_routing][google.cloud.tasks.v2beta2.AppEngineHttpRequest.app_engine_routing].
   */
  appEngineRoutingOverride: AppEngineRouting | undefined;
}

/**
 * App Engine HTTP request.
 *
 * The message defines the HTTP request that is sent to an App Engine app when
 * the task is dispatched.
 *
 * This proto can only be used for tasks in a queue which has
 * [app_engine_http_target][google.cloud.tasks.v2beta2.Queue.app_engine_http_target]
 * set.
 *
 * Using [AppEngineHttpRequest][google.cloud.tasks.v2beta2.AppEngineHttpRequest]
 * requires
 * [`appengine.applications.get`](https://cloud.google.com/appengine/docs/admin-api/access-control)
 * Google IAM permission for the project
 * and the following scope:
 *
 * `https://www.googleapis.com/auth/cloud-platform`
 *
 * The task will be delivered to the App Engine app which belongs to the same
 * project as the queue. For more information, see
 * [How Requests are
 * Routed](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
 * and how routing is affected by
 * [dispatch
 * files](https://cloud.google.com/appengine/docs/python/config/dispatchref).
 * Traffic is encrypted during transport and never leaves Google datacenters.
 * Because this traffic is carried over a communication mechanism internal to
 * Google, you cannot explicitly set the protocol (for example, HTTP or HTTPS).
 * The request to the handler, however, will appear to have used the HTTP
 * protocol.
 *
 * The [AppEngineRouting][google.cloud.tasks.v2beta2.AppEngineRouting] used to
 * construct the URL that the task is delivered to can be set at the queue-level
 * or task-level:
 *
 * * If set,
 *   [app_engine_routing_override][google.cloud.tasks.v2beta2.AppEngineHttpTarget.app_engine_routing_override]
 *   is used for all tasks in the queue, no matter what the setting
 *   is for the
 *   [task-level
 *   app_engine_routing][google.cloud.tasks.v2beta2.AppEngineHttpRequest.app_engine_routing].
 *
 * The `url` that the task will be sent to is:
 *
 * * `url =` [host][google.cloud.tasks.v2beta2.AppEngineRouting.host] `+`
 *   [relative_url][google.cloud.tasks.v2beta2.AppEngineHttpRequest.relative_url]
 *
 * Tasks can be dispatched to secure app handlers, unsecure app handlers, and
 * URIs restricted with
 * [`login:
 * admin`](https://cloud.google.com/appengine/docs/standard/python/config/appref).
 * Because tasks are not run as any user, they cannot be dispatched to URIs
 * restricted with
 * [`login:
 * required`](https://cloud.google.com/appengine/docs/standard/python/config/appref)
 * Task dispatches also do not follow redirects.
 *
 * The task attempt has succeeded if the app's request handler returns an HTTP
 * response code in the range [`200` - `299`]. The task attempt has failed if
 * the app's handler returns a non-2xx response code or Cloud Tasks does
 * not receive response before the [deadline][Task.dispatch_deadline]. Failed
 * tasks will be retried according to the
 * [retry configuration][google.cloud.tasks.v2beta2.Queue.retry_config]. `503`
 * (Service Unavailable) is considered an App Engine system error instead of an
 * application error and will cause Cloud Tasks' traffic congestion control to
 * temporarily throttle the queue's dispatches. Unlike other types of task
 * targets, a `429` (Too Many Requests) response from an app handler does not
 * cause traffic congestion control to throttle the queue.
 */
export interface AppEngineHttpRequest {
  /**
   * The HTTP method to use for the request. The default is POST.
   *
   * The app's request handler for the task's target URL must be able to handle
   * HTTP requests with this http_method, otherwise the task attempt fails with
   * error code 405 (Method Not Allowed). See [Writing a push task request
   * handler](https://cloud.google.com/appengine/docs/java/taskqueue/push/creating-handlers#writing_a_push_task_request_handler)
   * and the App Engine documentation for your runtime on [How Requests are
   * Handled](https://cloud.google.com/appengine/docs/standard/python3/how-requests-are-handled).
   */
  httpMethod: HttpMethod;
  /**
   * Task-level setting for App Engine routing.
   *
   * If set,
   * [app_engine_routing_override][google.cloud.tasks.v2beta2.AppEngineHttpTarget.app_engine_routing_override]
   * is used for all tasks in the queue, no matter what the setting is for the
   * [task-level
   * app_engine_routing][google.cloud.tasks.v2beta2.AppEngineHttpRequest.app_engine_routing].
   */
  appEngineRouting:
    | AppEngineRouting
    | undefined;
  /**
   * The relative URL.
   *
   * The relative URL must begin with "/" and must be a valid HTTP relative URL.
   * It can contain a path and query string arguments.
   * If the relative URL is empty, then the root path "/" will be used.
   * No spaces are allowed, and the maximum length allowed is 2083 characters.
   */
  relativeUrl: string;
  /**
   * HTTP request headers.
   *
   * This map contains the header field names and values.
   * Headers can be set when the
   * [task is created][google.cloud.tasks.v2beta2.CloudTasks.CreateTask].
   * Repeated headers are not supported but a header value can contain commas.
   *
   * Cloud Tasks sets some headers to default values:
   *
   * * `User-Agent`: By default, this header is
   *   `"AppEngine-Google; (+http://code.google.com/appengine)"`.
   *   This header can be modified, but Cloud Tasks will append
   *   `"AppEngine-Google; (+http://code.google.com/appengine)"` to the
   *   modified `User-Agent`.
   *
   * If the task has a
   * [payload][google.cloud.tasks.v2beta2.AppEngineHttpRequest.payload], Cloud
   * Tasks sets the following headers:
   *
   * * `Content-Type`: By default, the `Content-Type` header is set to
   *   `"application/octet-stream"`. The default can be overridden by explicitly
   *   setting `Content-Type` to a particular media type when the
   *   [task is created][google.cloud.tasks.v2beta2.CloudTasks.CreateTask].
   *   For example, `Content-Type` can be set to `"application/json"`.
   * * `Content-Length`: This is computed by Cloud Tasks. This value is
   *   output only.   It cannot be changed.
   *
   * The headers below cannot be set or overridden:
   *
   * * `Host`
   * * `X-Google-*`
   * * `X-AppEngine-*`
   *
   * In addition, Cloud Tasks sets some headers when the task is dispatched,
   * such as headers containing information about the task; see
   * [request
   * headers](https://cloud.google.com/appengine/docs/python/taskqueue/push/creating-handlers#reading_request_headers).
   * These headers are set only when the task is dispatched, so they are not
   * visible when the task is returned in a Cloud Tasks response.
   *
   * Although there is no specific limit for the maximum number of headers or
   * the size, there is a limit on the maximum size of the
   * [Task][google.cloud.tasks.v2beta2.Task]. For more information, see the
   * [CreateTask][google.cloud.tasks.v2beta2.CloudTasks.CreateTask]
   * documentation.
   */
  headers: { [key: string]: string };
  /**
   * Payload.
   *
   * The payload will be sent as the HTTP message body. A message
   * body, and thus a payload, is allowed only if the HTTP method is
   * POST or PUT. It is an error to set a data payload on a task with
   * an incompatible [HttpMethod][google.cloud.tasks.v2beta2.HttpMethod].
   */
  payload: Buffer;
}

export interface AppEngineHttpRequest_HeadersEntry {
  key: string;
  value: string;
}

/**
 * App Engine Routing.
 *
 * Defines routing characteristics specific to App Engine - service, version,
 * and instance.
 *
 * For more information about services, versions, and instances see
 * [An Overview of App
 * Engine](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine),
 * [Microservices Architecture on Google App
 * Engine](https://cloud.google.com/appengine/docs/python/microservices-on-app-engine),
 * [App Engine Standard request
 * routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed),
 * and [App Engine Flex request
 * routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
 */
export interface AppEngineRouting {
  /**
   * App service.
   *
   * By default, the task is sent to the service which is the default
   * service when the task is attempted.
   *
   * For some queues or tasks which were created using the App Engine
   * Task Queue API, [host][google.cloud.tasks.v2beta2.AppEngineRouting.host] is
   * not parsable into
   * [service][google.cloud.tasks.v2beta2.AppEngineRouting.service],
   * [version][google.cloud.tasks.v2beta2.AppEngineRouting.version], and
   * [instance][google.cloud.tasks.v2beta2.AppEngineRouting.instance]. For
   * example, some tasks which were created using the App Engine SDK use a
   * custom domain name; custom domains are not parsed by Cloud Tasks. If
   * [host][google.cloud.tasks.v2beta2.AppEngineRouting.host] is not parsable,
   * then [service][google.cloud.tasks.v2beta2.AppEngineRouting.service],
   * [version][google.cloud.tasks.v2beta2.AppEngineRouting.version], and
   * [instance][google.cloud.tasks.v2beta2.AppEngineRouting.instance] are the
   * empty string.
   */
  service: string;
  /**
   * App version.
   *
   * By default, the task is sent to the version which is the default
   * version when the task is attempted.
   *
   * For some queues or tasks which were created using the App Engine
   * Task Queue API, [host][google.cloud.tasks.v2beta2.AppEngineRouting.host] is
   * not parsable into
   * [service][google.cloud.tasks.v2beta2.AppEngineRouting.service],
   * [version][google.cloud.tasks.v2beta2.AppEngineRouting.version], and
   * [instance][google.cloud.tasks.v2beta2.AppEngineRouting.instance]. For
   * example, some tasks which were created using the App Engine SDK use a
   * custom domain name; custom domains are not parsed by Cloud Tasks. If
   * [host][google.cloud.tasks.v2beta2.AppEngineRouting.host] is not parsable,
   * then [service][google.cloud.tasks.v2beta2.AppEngineRouting.service],
   * [version][google.cloud.tasks.v2beta2.AppEngineRouting.version], and
   * [instance][google.cloud.tasks.v2beta2.AppEngineRouting.instance] are the
   * empty string.
   */
  version: string;
  /**
   * App instance.
   *
   * By default, the task is sent to an instance which is available when
   * the task is attempted.
   *
   * Requests can only be sent to a specific instance if
   * [manual scaling is used in App Engine
   * Standard](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine?hl=en_US#scaling_types_and_instance_classes).
   * App Engine Flex does not support instances. For more information, see
   * [App Engine Standard request
   * routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
   * and [App Engine Flex request
   * routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
   */
  instance: string;
  /**
   * Output only. The host that the task is sent to.
   *
   * For more information, see
   * [How Requests are
   * Routed](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed).
   *
   * The host is constructed as:
   *
   * * `host = [application_domain_name]`</br>
   *   `| [service] + '.' + [application_domain_name]`</br>
   *   `| [version] + '.' + [application_domain_name]`</br>
   *   `| [version_dot_service]+ '.' + [application_domain_name]`</br>
   *   `| [instance] + '.' + [application_domain_name]`</br>
   *   `| [instance_dot_service] + '.' + [application_domain_name]`</br>
   *   `| [instance_dot_version] + '.' + [application_domain_name]`</br>
   *   `| [instance_dot_version_dot_service] + '.' + [application_domain_name]`
   *
   * * `application_domain_name` = The domain name of the app, for
   *   example <app-id>.appspot.com, which is associated with the
   *   queue's project ID. Some tasks which were created using the App Engine
   *   SDK use a custom domain name.
   *
   * * `service =`
   * [service][google.cloud.tasks.v2beta2.AppEngineRouting.service]
   *
   * * `version =`
   * [version][google.cloud.tasks.v2beta2.AppEngineRouting.version]
   *
   * * `version_dot_service =`
   *   [version][google.cloud.tasks.v2beta2.AppEngineRouting.version] `+ '.' +`
   *   [service][google.cloud.tasks.v2beta2.AppEngineRouting.service]
   *
   * * `instance =`
   * [instance][google.cloud.tasks.v2beta2.AppEngineRouting.instance]
   *
   * * `instance_dot_service =`
   *   [instance][google.cloud.tasks.v2beta2.AppEngineRouting.instance] `+ '.'
   *   +` [service][google.cloud.tasks.v2beta2.AppEngineRouting.service]
   *
   * * `instance_dot_version =`
   *   [instance][google.cloud.tasks.v2beta2.AppEngineRouting.instance] `+ '.'
   *   +` [version][google.cloud.tasks.v2beta2.AppEngineRouting.version]
   *
   * * `instance_dot_version_dot_service =`
   *   [instance][google.cloud.tasks.v2beta2.AppEngineRouting.instance] `+ '.'
   *   +` [version][google.cloud.tasks.v2beta2.AppEngineRouting.version] `+ '.'
   *   +` [service][google.cloud.tasks.v2beta2.AppEngineRouting.service]
   *
   * If [service][google.cloud.tasks.v2beta2.AppEngineRouting.service] is empty,
   * then the task will be sent to the service which is the default service when
   * the task is attempted.
   *
   * If [version][google.cloud.tasks.v2beta2.AppEngineRouting.version] is empty,
   * then the task will be sent to the version which is the default version when
   * the task is attempted.
   *
   * If [instance][google.cloud.tasks.v2beta2.AppEngineRouting.instance] is
   * empty, then the task will be sent to an instance which is available when
   * the task is attempted.
   *
   * If [service][google.cloud.tasks.v2beta2.AppEngineRouting.service],
   * [version][google.cloud.tasks.v2beta2.AppEngineRouting.version], or
   * [instance][google.cloud.tasks.v2beta2.AppEngineRouting.instance] is
   * invalid, then the task will be sent to the default version of the default
   * service when the task is attempted.
   */
  host: string;
}

/**
 * HTTP request.
 *
 * The task will be pushed to the worker as an HTTP request. An HTTP request
 * embodies a url, an http method, headers, body and authorization for the http
 * task.
 */
export interface HttpRequest {
  /**
   * Required. The full url path that the request will be sent to.
   *
   * This string must begin with either "http://" or "https://". Some examples
   * are: `http://acme.com` and `https://acme.com/sales:8080`. Cloud Tasks will
   * encode some characters for safety and compatibility. The maximum allowed
   * URL length is 2083 characters after encoding.
   *
   * The `Location` header response from a redirect response [`300` - `399`]
   * may be followed. The redirect is not counted as a separate attempt.
   */
  url: string;
  /** The HTTP method to use for the request. The default is POST. */
  httpMethod: HttpMethod;
  /**
   * HTTP request headers.
   *
   * This map contains the header field names and values.
   * Headers can be set when running the
   * [task is created][google.cloud.tasks.v2beta2.CloudTasks.CreateTask] or
   * [task is created][google.cloud.tasks.v2beta2.CloudTasks.BufferTask].
   *
   * These headers represent a subset of the headers that will accompany the
   * task's HTTP request. Some HTTP request headers will be ignored or replaced.
   *
   * A partial list of headers that will be ignored or replaced is:
   *
   * * Any header that is prefixed with "X-CloudTasks-" will be treated
   * as service header. Service headers define properties of the task and are
   * predefined in CloudTask.
   * * Host: This will be computed by Cloud Tasks and derived from
   *   [HttpRequest.url][google.cloud.tasks.v2beta2.HttpRequest.url].
   * * Content-Length: This will be computed by Cloud Tasks.
   * * User-Agent: This will be set to `"Google-Cloud-Tasks"`.
   * * `X-Google-*`: Google use only.
   * * `X-AppEngine-*`: Google use only.
   *
   * `Content-Type` won't be set by Cloud Tasks. You can explicitly set
   * `Content-Type` to a media type when the
   *  [task is created][google.cloud.tasks.v2beta3.CloudTasks.CreateTask].
   *  For example, `Content-Type` can be set to `"application/octet-stream"` or
   *  `"application/json"`.
   *
   * Headers which can have multiple values (according to RFC2616) can be
   * specified using comma-separated values.
   *
   * The size of the headers must be less than 80KB.
   */
  headers: { [key: string]: string };
  /**
   * HTTP request body.
   *
   * A request body is allowed only if the
   * [HTTP method][google.cloud.tasks.v2beta2.HttpRequest.http_method] is POST,
   * PUT, or PATCH. It is an error to set body on a task with an incompatible
   * [HttpMethod][google.cloud.tasks.v2beta2.HttpMethod].
   */
  body: Buffer;
  /**
   * If specified, an
   * [OAuth token](https://developers.google.com/identity/protocols/OAuth2)
   * will be generated and attached as an `Authorization` header in the HTTP
   * request.
   *
   * This type of authorization should generally only be used when calling
   * Google APIs hosted on *.googleapis.com.
   */
  oauthToken?:
    | OAuthToken
    | undefined;
  /**
   * If specified, an
   * [OIDC](https://developers.google.com/identity/protocols/OpenIDConnect)
   * token will be generated and attached as an `Authorization` header in the
   * HTTP request.
   *
   * This type of authorization can be used for many scenarios, including
   * calling Cloud Run, or endpoints where you intend to validate the token
   * yourself.
   */
  oidcToken?: OidcToken | undefined;
}

export interface HttpRequest_HeadersEntry {
  key: string;
  value: string;
}

/**
 * PathOverride.
 *
 * Path message defines path override for HTTP targets.
 */
export interface PathOverride {
  /** The URI path (e.g., /users/1234). Default is an empty string. */
  path: string;
}

/**
 * QueryOverride.
 *
 * Query message defines query override for HTTP targets.
 */
export interface QueryOverride {
  /**
   * The query parameters (e.g., qparam1=123&qparam2=456). Default is an empty
   * string.
   */
  queryParams: string;
}

/**
 * Uri Override.
 *
 * When specified, all the HTTP tasks inside the queue will be partially or
 * fully overridden depending on the configured values.
 */
export interface UriOverride {
  /**
   * Scheme override.
   *
   * When specified, the task URI scheme is replaced by the provided value (HTTP
   * or HTTPS).
   */
  scheme?:
    | UriOverride_Scheme
    | undefined;
  /**
   * Host override.
   *
   * When specified, replaces the host part of the task URL. For example,
   * if the task URL is "https://www.google.com," and host value is set to
   * "example.net", the overridden URI will be changed to "https://example.net."
   * Host value cannot be an empty string (INVALID_ARGUMENT).
   */
  host?:
    | string
    | undefined;
  /**
   * Port override.
   *
   * When specified, replaces the port part of the task URI. For instance,
   * for a URI http://www.google.com/foo and port=123, the overridden URI
   * becomes http://www.google.com:123/foo. Note that the port value must be a
   * positive integer. Setting the port to 0 (Zero) clears the URI port.
   */
  port?:
    | Long
    | undefined;
  /**
   * URI path.
   *
   * When specified, replaces the existing path of the task URL. Setting the
   * path value to an empty string clears the URI path segment.
   */
  pathOverride:
    | PathOverride
    | undefined;
  /**
   * URI Query.
   *
   * When specified, replaces the query part of the task URI. Setting the
   * query value to an empty string clears the URI query segment.
   */
  queryOverride:
    | QueryOverride
    | undefined;
  /**
   * URI Override Enforce Mode
   *
   * When specified, determines the Target UriOverride mode. If not specified,
   * it defaults to ALWAYS.
   */
  uriOverrideEnforceMode: UriOverride_UriOverrideEnforceMode;
}

/** The Scheme for an HTTP request. By default, it is HTTPS. */
export enum UriOverride_Scheme {
  /** SCHEME_UNSPECIFIED - Scheme unspecified. Defaults to HTTPS. */
  SCHEME_UNSPECIFIED = 0,
  /**
   * HTTP - Convert the scheme to HTTP, e.g., https://www.google.ca will change to
   * http://www.google.ca.
   */
  HTTP = 1,
  /**
   * HTTPS - Convert the scheme to HTTPS, e.g., http://www.google.ca will change to
   * https://www.google.ca.
   */
  HTTPS = 2,
  UNRECOGNIZED = -1,
}

export function uriOverride_SchemeFromJSON(object: any): UriOverride_Scheme {
  switch (object) {
    case 0:
    case "SCHEME_UNSPECIFIED":
      return UriOverride_Scheme.SCHEME_UNSPECIFIED;
    case 1:
    case "HTTP":
      return UriOverride_Scheme.HTTP;
    case 2:
    case "HTTPS":
      return UriOverride_Scheme.HTTPS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UriOverride_Scheme.UNRECOGNIZED;
  }
}

export function uriOverride_SchemeToJSON(object: UriOverride_Scheme): string {
  switch (object) {
    case UriOverride_Scheme.SCHEME_UNSPECIFIED:
      return "SCHEME_UNSPECIFIED";
    case UriOverride_Scheme.HTTP:
      return "HTTP";
    case UriOverride_Scheme.HTTPS:
      return "HTTPS";
    case UriOverride_Scheme.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * UriOverrideEnforceMode mode is to define enforcing mode for the override
 * modes.
 */
export enum UriOverride_UriOverrideEnforceMode {
  /** URI_OVERRIDE_ENFORCE_MODE_UNSPECIFIED - OverrideMode Unspecified. Defaults to ALWAYS. */
  URI_OVERRIDE_ENFORCE_MODE_UNSPECIFIED = 0,
  /**
   * IF_NOT_EXISTS - In the IF_NOT_EXISTS mode, queue-level configuration is only
   * applied where task-level configuration does not exist.
   */
  IF_NOT_EXISTS = 1,
  /**
   * ALWAYS - In the ALWAYS mode, queue-level configuration overrides all
   * task-level configuration
   */
  ALWAYS = 2,
  UNRECOGNIZED = -1,
}

export function uriOverride_UriOverrideEnforceModeFromJSON(object: any): UriOverride_UriOverrideEnforceMode {
  switch (object) {
    case 0:
    case "URI_OVERRIDE_ENFORCE_MODE_UNSPECIFIED":
      return UriOverride_UriOverrideEnforceMode.URI_OVERRIDE_ENFORCE_MODE_UNSPECIFIED;
    case 1:
    case "IF_NOT_EXISTS":
      return UriOverride_UriOverrideEnforceMode.IF_NOT_EXISTS;
    case 2:
    case "ALWAYS":
      return UriOverride_UriOverrideEnforceMode.ALWAYS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UriOverride_UriOverrideEnforceMode.UNRECOGNIZED;
  }
}

export function uriOverride_UriOverrideEnforceModeToJSON(object: UriOverride_UriOverrideEnforceMode): string {
  switch (object) {
    case UriOverride_UriOverrideEnforceMode.URI_OVERRIDE_ENFORCE_MODE_UNSPECIFIED:
      return "URI_OVERRIDE_ENFORCE_MODE_UNSPECIFIED";
    case UriOverride_UriOverrideEnforceMode.IF_NOT_EXISTS:
      return "IF_NOT_EXISTS";
    case UriOverride_UriOverrideEnforceMode.ALWAYS:
      return "ALWAYS";
    case UriOverride_UriOverrideEnforceMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * HTTP target.
 *
 * When specified as a [Queue][target_type], all the tasks with [HttpRequest]
 * will be overridden according to the target.
 */
export interface HttpTarget {
  /**
   * Uri override.
   *
   * When specified, overrides the execution Uri for all the tasks in the queue.
   */
  uriOverride:
    | UriOverride
    | undefined;
  /**
   * The HTTP method to use for the request.
   *
   * When specified, it overrides
   * [HttpRequest][google.cloud.tasks.v2beta2.HttpTarget.http_method] for the
   * task. Note that if the value is set to [HttpMethod][GET] the
   * [HttpRequest][body] of the task will be ignored at execution time.
   */
  httpMethod: HttpMethod;
  /**
   * HTTP target headers.
   *
   * This map contains the header field names and values.
   * Headers will be set when running the
   * [task is created][google.cloud.tasks.v2beta2.CloudTasks.CreateTask] and/or
   * [task is created][google.cloud.tasks.v2beta2.CloudTasks.BufferTask].
   *
   * These headers represent a subset of the headers that will accompany the
   * task's HTTP request. Some HTTP request headers will be ignored or replaced.
   *
   * A partial list of headers that will be ignored or replaced is:
   * * Any header that is prefixed with "X-CloudTasks-" will be treated
   * as service header. Service headers define properties of the task and are
   * predefined in CloudTask.
   * * Host: This will be computed by Cloud Tasks and derived from
   *   [HttpRequest.url][google.cloud.tasks.v2beta2.HttpRequest.url].
   * * Content-Length: This will be computed by Cloud Tasks.
   * * User-Agent: This will be set to `"Google-CloudTasks"`.
   * * `X-Google-*`: Google use only.
   * * `X-AppEngine-*`: Google use only.
   *
   * `Content-Type` won't be set by Cloud Tasks. You can explicitly set
   * `Content-Type` to a media type when the
   *  [task is created][google.cloud.tasks.v2beta3.CloudTasks.CreateTask].
   *  For example, `Content-Type` can be set to `"application/octet-stream"` or
   *  `"application/json"`.
   *
   * Headers which can have multiple values (according to RFC2616) can be
   * specified using comma-separated values.
   *
   * The size of the headers must be less than 80KB.
   * Queue-level headers to override headers of all the tasks in the queue.
   */
  headerOverrides: HttpTarget_HeaderOverride[];
  /**
   * If specified, an
   * [OAuth token](https://developers.google.com/identity/protocols/OAuth2)
   * will be generated and attached as an `Authorization` header in the HTTP
   * request.
   *
   * This type of authorization should generally only be used when calling
   * Google APIs hosted on *.googleapis.com.
   */
  oauthToken?:
    | OAuthToken
    | undefined;
  /**
   * If specified, an
   * [OIDC](https://developers.google.com/identity/protocols/OpenIDConnect)
   * token will be generated and attached as an `Authorization` header in the
   * HTTP request.
   *
   * This type of authorization can be used for many scenarios, including
   * calling Cloud Run, or endpoints where you intend to validate the token
   * yourself.
   */
  oidcToken?: OidcToken | undefined;
}

/** Defines a header message. A header can have a key and a value. */
export interface HttpTarget_Header {
  /** The key of the header. */
  key: string;
  /** The value of the header. */
  value: string;
}

/** Wraps the Header object. */
export interface HttpTarget_HeaderOverride {
  /** header embodying a key and a value. */
  header: HttpTarget_Header | undefined;
}

/**
 * Contains information needed for generating an
 * [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
 * This type of authorization should generally only be used when calling Google
 * APIs hosted on *.googleapis.com.
 */
export interface OAuthToken {
  /**
   * [Service account email](https://cloud.google.com/iam/docs/service-accounts)
   * to be used for generating OAuth token.
   * The service account must be within the same project as the queue. The
   * caller must have iam.serviceAccounts.actAs permission for the service
   * account.
   */
  serviceAccountEmail: string;
  /**
   * OAuth scope to be used for generating OAuth access token.
   * If not specified, "https://www.googleapis.com/auth/cloud-platform"
   * will be used.
   */
  scope: string;
}

/**
 * Contains information needed for generating an
 * [OpenID Connect
 * token](https://developers.google.com/identity/protocols/OpenIDConnect).
 * This type of authorization can be used for many scenarios, including
 * calling Cloud Run, or endpoints where you intend to validate the token
 * yourself.
 */
export interface OidcToken {
  /**
   * [Service account email](https://cloud.google.com/iam/docs/service-accounts)
   * to be used for generating OIDC token.
   * The service account must be within the same project as the queue. The
   * caller must have iam.serviceAccounts.actAs permission for the service
   * account.
   */
  serviceAccountEmail: string;
  /**
   * Audience to be used when generating OIDC token. If not specified, the URI
   * specified in target will be used.
   */
  audience: string;
}

function createBasePullTarget(): PullTarget {
  return {};
}

export const PullTarget: MessageFns<PullTarget> = {
  encode(_: PullTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PullTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePullTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PullTarget {
    return {};
  },

  toJSON(_: PullTarget): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PullTarget>): PullTarget {
    return PullTarget.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PullTarget>): PullTarget {
    const message = createBasePullTarget();
    return message;
  },
};

function createBasePullMessage(): PullMessage {
  return { payload: Buffer.alloc(0), tag: "" };
}

export const PullMessage: MessageFns<PullMessage> = {
  encode(message: PullMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payload.length !== 0) {
      writer.uint32(10).bytes(message.payload);
    }
    if (message.tag !== "") {
      writer.uint32(18).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PullMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePullMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.payload = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PullMessage {
    return {
      payload: isSet(object.payload) ? Buffer.from(bytesFromBase64(object.payload)) : Buffer.alloc(0),
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
    };
  },

  toJSON(message: PullMessage): unknown {
    const obj: any = {};
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create(base?: DeepPartial<PullMessage>): PullMessage {
    return PullMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PullMessage>): PullMessage {
    const message = createBasePullMessage();
    message.payload = object.payload ?? Buffer.alloc(0);
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseAppEngineHttpTarget(): AppEngineHttpTarget {
  return { appEngineRoutingOverride: undefined };
}

export const AppEngineHttpTarget: MessageFns<AppEngineHttpTarget> = {
  encode(message: AppEngineHttpTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appEngineRoutingOverride !== undefined) {
      AppEngineRouting.encode(message.appEngineRoutingOverride, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineHttpTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineHttpTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.appEngineRoutingOverride = AppEngineRouting.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineHttpTarget {
    return {
      appEngineRoutingOverride: isSet(object.appEngineRoutingOverride)
        ? AppEngineRouting.fromJSON(object.appEngineRoutingOverride)
        : undefined,
    };
  },

  toJSON(message: AppEngineHttpTarget): unknown {
    const obj: any = {};
    if (message.appEngineRoutingOverride !== undefined) {
      obj.appEngineRoutingOverride = AppEngineRouting.toJSON(message.appEngineRoutingOverride);
    }
    return obj;
  },

  create(base?: DeepPartial<AppEngineHttpTarget>): AppEngineHttpTarget {
    return AppEngineHttpTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppEngineHttpTarget>): AppEngineHttpTarget {
    const message = createBaseAppEngineHttpTarget();
    message.appEngineRoutingOverride =
      (object.appEngineRoutingOverride !== undefined && object.appEngineRoutingOverride !== null)
        ? AppEngineRouting.fromPartial(object.appEngineRoutingOverride)
        : undefined;
    return message;
  },
};

function createBaseAppEngineHttpRequest(): AppEngineHttpRequest {
  return { httpMethod: 0, appEngineRouting: undefined, relativeUrl: "", headers: {}, payload: Buffer.alloc(0) };
}

export const AppEngineHttpRequest: MessageFns<AppEngineHttpRequest> = {
  encode(message: AppEngineHttpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpMethod !== 0) {
      writer.uint32(8).int32(message.httpMethod);
    }
    if (message.appEngineRouting !== undefined) {
      AppEngineRouting.encode(message.appEngineRouting, writer.uint32(18).fork()).join();
    }
    if (message.relativeUrl !== "") {
      writer.uint32(26).string(message.relativeUrl);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      AppEngineHttpRequest_HeadersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.payload.length !== 0) {
      writer.uint32(42).bytes(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineHttpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineHttpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.httpMethod = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.appEngineRouting = AppEngineRouting.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.relativeUrl = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = AppEngineHttpRequest_HeadersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.headers[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.payload = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineHttpRequest {
    return {
      httpMethod: isSet(object.httpMethod) ? httpMethodFromJSON(object.httpMethod) : 0,
      appEngineRouting: isSet(object.appEngineRouting) ? AppEngineRouting.fromJSON(object.appEngineRouting) : undefined,
      relativeUrl: isSet(object.relativeUrl) ? globalThis.String(object.relativeUrl) : "",
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      payload: isSet(object.payload) ? Buffer.from(bytesFromBase64(object.payload)) : Buffer.alloc(0),
    };
  },

  toJSON(message: AppEngineHttpRequest): unknown {
    const obj: any = {};
    if (message.httpMethod !== 0) {
      obj.httpMethod = httpMethodToJSON(message.httpMethod);
    }
    if (message.appEngineRouting !== undefined) {
      obj.appEngineRouting = AppEngineRouting.toJSON(message.appEngineRouting);
    }
    if (message.relativeUrl !== "") {
      obj.relativeUrl = message.relativeUrl;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    return obj;
  },

  create(base?: DeepPartial<AppEngineHttpRequest>): AppEngineHttpRequest {
    return AppEngineHttpRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppEngineHttpRequest>): AppEngineHttpRequest {
    const message = createBaseAppEngineHttpRequest();
    message.httpMethod = object.httpMethod ?? 0;
    message.appEngineRouting = (object.appEngineRouting !== undefined && object.appEngineRouting !== null)
      ? AppEngineRouting.fromPartial(object.appEngineRouting)
      : undefined;
    message.relativeUrl = object.relativeUrl ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.payload = object.payload ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseAppEngineHttpRequest_HeadersEntry(): AppEngineHttpRequest_HeadersEntry {
  return { key: "", value: "" };
}

export const AppEngineHttpRequest_HeadersEntry: MessageFns<AppEngineHttpRequest_HeadersEntry> = {
  encode(message: AppEngineHttpRequest_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineHttpRequest_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineHttpRequest_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineHttpRequest_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AppEngineHttpRequest_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AppEngineHttpRequest_HeadersEntry>): AppEngineHttpRequest_HeadersEntry {
    return AppEngineHttpRequest_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppEngineHttpRequest_HeadersEntry>): AppEngineHttpRequest_HeadersEntry {
    const message = createBaseAppEngineHttpRequest_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAppEngineRouting(): AppEngineRouting {
  return { service: "", version: "", instance: "", host: "" };
}

export const AppEngineRouting: MessageFns<AppEngineRouting> = {
  encode(message: AppEngineRouting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.instance !== "") {
      writer.uint32(26).string(message.instance);
    }
    if (message.host !== "") {
      writer.uint32(34).string(message.host);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineRouting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineRouting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.host = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineRouting {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
    };
  },

  toJSON(message: AppEngineRouting): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    return obj;
  },

  create(base?: DeepPartial<AppEngineRouting>): AppEngineRouting {
    return AppEngineRouting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppEngineRouting>): AppEngineRouting {
    const message = createBaseAppEngineRouting();
    message.service = object.service ?? "";
    message.version = object.version ?? "";
    message.instance = object.instance ?? "";
    message.host = object.host ?? "";
    return message;
  },
};

function createBaseHttpRequest(): HttpRequest {
  return { url: "", httpMethod: 0, headers: {}, body: Buffer.alloc(0), oauthToken: undefined, oidcToken: undefined };
}

export const HttpRequest: MessageFns<HttpRequest> = {
  encode(message: HttpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.httpMethod !== 0) {
      writer.uint32(16).int32(message.httpMethod);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      HttpRequest_HeadersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.body.length !== 0) {
      writer.uint32(34).bytes(message.body);
    }
    if (message.oauthToken !== undefined) {
      OAuthToken.encode(message.oauthToken, writer.uint32(42).fork()).join();
    }
    if (message.oidcToken !== undefined) {
      OidcToken.encode(message.oidcToken, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.httpMethod = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = HttpRequest_HeadersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.headers[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.body = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.oauthToken = OAuthToken.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.oidcToken = OidcToken.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRequest {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      httpMethod: isSet(object.httpMethod) ? httpMethodFromJSON(object.httpMethod) : 0,
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      body: isSet(object.body) ? Buffer.from(bytesFromBase64(object.body)) : Buffer.alloc(0),
      oauthToken: isSet(object.oauthToken) ? OAuthToken.fromJSON(object.oauthToken) : undefined,
      oidcToken: isSet(object.oidcToken) ? OidcToken.fromJSON(object.oidcToken) : undefined,
    };
  },

  toJSON(message: HttpRequest): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.httpMethod !== 0) {
      obj.httpMethod = httpMethodToJSON(message.httpMethod);
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.oauthToken !== undefined) {
      obj.oauthToken = OAuthToken.toJSON(message.oauthToken);
    }
    if (message.oidcToken !== undefined) {
      obj.oidcToken = OidcToken.toJSON(message.oidcToken);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRequest>): HttpRequest {
    return HttpRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRequest>): HttpRequest {
    const message = createBaseHttpRequest();
    message.url = object.url ?? "";
    message.httpMethod = object.httpMethod ?? 0;
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? Buffer.alloc(0);
    message.oauthToken = (object.oauthToken !== undefined && object.oauthToken !== null)
      ? OAuthToken.fromPartial(object.oauthToken)
      : undefined;
    message.oidcToken = (object.oidcToken !== undefined && object.oidcToken !== null)
      ? OidcToken.fromPartial(object.oidcToken)
      : undefined;
    return message;
  },
};

function createBaseHttpRequest_HeadersEntry(): HttpRequest_HeadersEntry {
  return { key: "", value: "" };
}

export const HttpRequest_HeadersEntry: MessageFns<HttpRequest_HeadersEntry> = {
  encode(message: HttpRequest_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRequest_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRequest_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRequest_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpRequest_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRequest_HeadersEntry>): HttpRequest_HeadersEntry {
    return HttpRequest_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRequest_HeadersEntry>): HttpRequest_HeadersEntry {
    const message = createBaseHttpRequest_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePathOverride(): PathOverride {
  return { path: "" };
}

export const PathOverride: MessageFns<PathOverride> = {
  encode(message: PathOverride, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PathOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePathOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PathOverride {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: PathOverride): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<PathOverride>): PathOverride {
    return PathOverride.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PathOverride>): PathOverride {
    const message = createBasePathOverride();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseQueryOverride(): QueryOverride {
  return { queryParams: "" };
}

export const QueryOverride: MessageFns<QueryOverride> = {
  encode(message: QueryOverride, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryParams !== "") {
      writer.uint32(10).string(message.queryParams);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryParams = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOverride {
    return { queryParams: isSet(object.queryParams) ? globalThis.String(object.queryParams) : "" };
  },

  toJSON(message: QueryOverride): unknown {
    const obj: any = {};
    if (message.queryParams !== "") {
      obj.queryParams = message.queryParams;
    }
    return obj;
  },

  create(base?: DeepPartial<QueryOverride>): QueryOverride {
    return QueryOverride.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryOverride>): QueryOverride {
    const message = createBaseQueryOverride();
    message.queryParams = object.queryParams ?? "";
    return message;
  },
};

function createBaseUriOverride(): UriOverride {
  return {
    scheme: undefined,
    host: undefined,
    port: undefined,
    pathOverride: undefined,
    queryOverride: undefined,
    uriOverrideEnforceMode: 0,
  };
}

export const UriOverride: MessageFns<UriOverride> = {
  encode(message: UriOverride, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheme !== undefined) {
      writer.uint32(8).int32(message.scheme);
    }
    if (message.host !== undefined) {
      writer.uint32(18).string(message.host);
    }
    if (message.port !== undefined) {
      writer.uint32(24).int64(message.port.toString());
    }
    if (message.pathOverride !== undefined) {
      PathOverride.encode(message.pathOverride, writer.uint32(34).fork()).join();
    }
    if (message.queryOverride !== undefined) {
      QueryOverride.encode(message.queryOverride, writer.uint32(42).fork()).join();
    }
    if (message.uriOverrideEnforceMode !== 0) {
      writer.uint32(48).int32(message.uriOverrideEnforceMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UriOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUriOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.scheme = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.port = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pathOverride = PathOverride.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.queryOverride = QueryOverride.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.uriOverrideEnforceMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UriOverride {
    return {
      scheme: isSet(object.scheme) ? uriOverride_SchemeFromJSON(object.scheme) : undefined,
      host: isSet(object.host) ? globalThis.String(object.host) : undefined,
      port: isSet(object.port) ? Long.fromValue(object.port) : undefined,
      pathOverride: isSet(object.pathOverride) ? PathOverride.fromJSON(object.pathOverride) : undefined,
      queryOverride: isSet(object.queryOverride) ? QueryOverride.fromJSON(object.queryOverride) : undefined,
      uriOverrideEnforceMode: isSet(object.uriOverrideEnforceMode)
        ? uriOverride_UriOverrideEnforceModeFromJSON(object.uriOverrideEnforceMode)
        : 0,
    };
  },

  toJSON(message: UriOverride): unknown {
    const obj: any = {};
    if (message.scheme !== undefined) {
      obj.scheme = uriOverride_SchemeToJSON(message.scheme);
    }
    if (message.host !== undefined) {
      obj.host = message.host;
    }
    if (message.port !== undefined) {
      obj.port = (message.port || Long.ZERO).toString();
    }
    if (message.pathOverride !== undefined) {
      obj.pathOverride = PathOverride.toJSON(message.pathOverride);
    }
    if (message.queryOverride !== undefined) {
      obj.queryOverride = QueryOverride.toJSON(message.queryOverride);
    }
    if (message.uriOverrideEnforceMode !== 0) {
      obj.uriOverrideEnforceMode = uriOverride_UriOverrideEnforceModeToJSON(message.uriOverrideEnforceMode);
    }
    return obj;
  },

  create(base?: DeepPartial<UriOverride>): UriOverride {
    return UriOverride.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UriOverride>): UriOverride {
    const message = createBaseUriOverride();
    message.scheme = object.scheme ?? undefined;
    message.host = object.host ?? undefined;
    message.port = (object.port !== undefined && object.port !== null) ? Long.fromValue(object.port) : undefined;
    message.pathOverride = (object.pathOverride !== undefined && object.pathOverride !== null)
      ? PathOverride.fromPartial(object.pathOverride)
      : undefined;
    message.queryOverride = (object.queryOverride !== undefined && object.queryOverride !== null)
      ? QueryOverride.fromPartial(object.queryOverride)
      : undefined;
    message.uriOverrideEnforceMode = object.uriOverrideEnforceMode ?? 0;
    return message;
  },
};

function createBaseHttpTarget(): HttpTarget {
  return { uriOverride: undefined, httpMethod: 0, headerOverrides: [], oauthToken: undefined, oidcToken: undefined };
}

export const HttpTarget: MessageFns<HttpTarget> = {
  encode(message: HttpTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uriOverride !== undefined) {
      UriOverride.encode(message.uriOverride, writer.uint32(10).fork()).join();
    }
    if (message.httpMethod !== 0) {
      writer.uint32(16).int32(message.httpMethod);
    }
    for (const v of message.headerOverrides) {
      HttpTarget_HeaderOverride.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.oauthToken !== undefined) {
      OAuthToken.encode(message.oauthToken, writer.uint32(42).fork()).join();
    }
    if (message.oidcToken !== undefined) {
      OidcToken.encode(message.oidcToken, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uriOverride = UriOverride.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.httpMethod = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.headerOverrides.push(HttpTarget_HeaderOverride.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.oauthToken = OAuthToken.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.oidcToken = OidcToken.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpTarget {
    return {
      uriOverride: isSet(object.uriOverride) ? UriOverride.fromJSON(object.uriOverride) : undefined,
      httpMethod: isSet(object.httpMethod) ? httpMethodFromJSON(object.httpMethod) : 0,
      headerOverrides: globalThis.Array.isArray(object?.headerOverrides)
        ? object.headerOverrides.map((e: any) => HttpTarget_HeaderOverride.fromJSON(e))
        : [],
      oauthToken: isSet(object.oauthToken) ? OAuthToken.fromJSON(object.oauthToken) : undefined,
      oidcToken: isSet(object.oidcToken) ? OidcToken.fromJSON(object.oidcToken) : undefined,
    };
  },

  toJSON(message: HttpTarget): unknown {
    const obj: any = {};
    if (message.uriOverride !== undefined) {
      obj.uriOverride = UriOverride.toJSON(message.uriOverride);
    }
    if (message.httpMethod !== 0) {
      obj.httpMethod = httpMethodToJSON(message.httpMethod);
    }
    if (message.headerOverrides?.length) {
      obj.headerOverrides = message.headerOverrides.map((e) => HttpTarget_HeaderOverride.toJSON(e));
    }
    if (message.oauthToken !== undefined) {
      obj.oauthToken = OAuthToken.toJSON(message.oauthToken);
    }
    if (message.oidcToken !== undefined) {
      obj.oidcToken = OidcToken.toJSON(message.oidcToken);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpTarget>): HttpTarget {
    return HttpTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpTarget>): HttpTarget {
    const message = createBaseHttpTarget();
    message.uriOverride = (object.uriOverride !== undefined && object.uriOverride !== null)
      ? UriOverride.fromPartial(object.uriOverride)
      : undefined;
    message.httpMethod = object.httpMethod ?? 0;
    message.headerOverrides = object.headerOverrides?.map((e) => HttpTarget_HeaderOverride.fromPartial(e)) || [];
    message.oauthToken = (object.oauthToken !== undefined && object.oauthToken !== null)
      ? OAuthToken.fromPartial(object.oauthToken)
      : undefined;
    message.oidcToken = (object.oidcToken !== undefined && object.oidcToken !== null)
      ? OidcToken.fromPartial(object.oidcToken)
      : undefined;
    return message;
  },
};

function createBaseHttpTarget_Header(): HttpTarget_Header {
  return { key: "", value: "" };
}

export const HttpTarget_Header: MessageFns<HttpTarget_Header> = {
  encode(message: HttpTarget_Header, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpTarget_Header {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpTarget_Header();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpTarget_Header {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpTarget_Header): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpTarget_Header>): HttpTarget_Header {
    return HttpTarget_Header.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpTarget_Header>): HttpTarget_Header {
    const message = createBaseHttpTarget_Header();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHttpTarget_HeaderOverride(): HttpTarget_HeaderOverride {
  return { header: undefined };
}

export const HttpTarget_HeaderOverride: MessageFns<HttpTarget_HeaderOverride> = {
  encode(message: HttpTarget_HeaderOverride, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      HttpTarget_Header.encode(message.header, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpTarget_HeaderOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpTarget_HeaderOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = HttpTarget_Header.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpTarget_HeaderOverride {
    return { header: isSet(object.header) ? HttpTarget_Header.fromJSON(object.header) : undefined };
  },

  toJSON(message: HttpTarget_HeaderOverride): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = HttpTarget_Header.toJSON(message.header);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpTarget_HeaderOverride>): HttpTarget_HeaderOverride {
    return HttpTarget_HeaderOverride.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpTarget_HeaderOverride>): HttpTarget_HeaderOverride {
    const message = createBaseHttpTarget_HeaderOverride();
    message.header = (object.header !== undefined && object.header !== null)
      ? HttpTarget_Header.fromPartial(object.header)
      : undefined;
    return message;
  },
};

function createBaseOAuthToken(): OAuthToken {
  return { serviceAccountEmail: "", scope: "" };
}

export const OAuthToken: MessageFns<OAuthToken> = {
  encode(message: OAuthToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccountEmail !== "") {
      writer.uint32(10).string(message.serviceAccountEmail);
    }
    if (message.scope !== "") {
      writer.uint32(18).string(message.scope);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceAccountEmail = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scope = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthToken {
    return {
      serviceAccountEmail: isSet(object.serviceAccountEmail) ? globalThis.String(object.serviceAccountEmail) : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
    };
  },

  toJSON(message: OAuthToken): unknown {
    const obj: any = {};
    if (message.serviceAccountEmail !== "") {
      obj.serviceAccountEmail = message.serviceAccountEmail;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    return obj;
  },

  create(base?: DeepPartial<OAuthToken>): OAuthToken {
    return OAuthToken.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OAuthToken>): OAuthToken {
    const message = createBaseOAuthToken();
    message.serviceAccountEmail = object.serviceAccountEmail ?? "";
    message.scope = object.scope ?? "";
    return message;
  },
};

function createBaseOidcToken(): OidcToken {
  return { serviceAccountEmail: "", audience: "" };
}

export const OidcToken: MessageFns<OidcToken> = {
  encode(message: OidcToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccountEmail !== "") {
      writer.uint32(10).string(message.serviceAccountEmail);
    }
    if (message.audience !== "") {
      writer.uint32(18).string(message.audience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OidcToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOidcToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceAccountEmail = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audience = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OidcToken {
    return {
      serviceAccountEmail: isSet(object.serviceAccountEmail) ? globalThis.String(object.serviceAccountEmail) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
    };
  },

  toJSON(message: OidcToken): unknown {
    const obj: any = {};
    if (message.serviceAccountEmail !== "") {
      obj.serviceAccountEmail = message.serviceAccountEmail;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    return obj;
  },

  create(base?: DeepPartial<OidcToken>): OidcToken {
    return OidcToken.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OidcToken>): OidcToken {
    const message = createBaseOidcToken();
    message.serviceAccountEmail = object.serviceAccountEmail ?? "";
    message.audience = object.audience ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
