// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/tasks/v2/target.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.tasks.v2";

/** The HTTP method used to deliver the task. */
export enum HttpMethod {
  /** HTTP_METHOD_UNSPECIFIED - HTTP method unspecified */
  HTTP_METHOD_UNSPECIFIED = 0,
  /** POST - HTTP POST */
  POST = 1,
  /** GET - HTTP GET */
  GET = 2,
  /** HEAD - HTTP HEAD */
  HEAD = 3,
  /** PUT - HTTP PUT */
  PUT = 4,
  /** DELETE - HTTP DELETE */
  DELETE = 5,
  /** PATCH - HTTP PATCH */
  PATCH = 6,
  /** OPTIONS - HTTP OPTIONS */
  OPTIONS = 7,
  UNRECOGNIZED = -1,
}

export function httpMethodFromJSON(object: any): HttpMethod {
  switch (object) {
    case 0:
    case "HTTP_METHOD_UNSPECIFIED":
      return HttpMethod.HTTP_METHOD_UNSPECIFIED;
    case 1:
    case "POST":
      return HttpMethod.POST;
    case 2:
    case "GET":
      return HttpMethod.GET;
    case 3:
    case "HEAD":
      return HttpMethod.HEAD;
    case 4:
    case "PUT":
      return HttpMethod.PUT;
    case 5:
    case "DELETE":
      return HttpMethod.DELETE;
    case 6:
    case "PATCH":
      return HttpMethod.PATCH;
    case 7:
    case "OPTIONS":
      return HttpMethod.OPTIONS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HttpMethod.UNRECOGNIZED;
  }
}

export function httpMethodToJSON(object: HttpMethod): string {
  switch (object) {
    case HttpMethod.HTTP_METHOD_UNSPECIFIED:
      return "HTTP_METHOD_UNSPECIFIED";
    case HttpMethod.POST:
      return "POST";
    case HttpMethod.GET:
      return "GET";
    case HttpMethod.HEAD:
      return "HEAD";
    case HttpMethod.PUT:
      return "PUT";
    case HttpMethod.DELETE:
      return "DELETE";
    case HttpMethod.PATCH:
      return "PATCH";
    case HttpMethod.OPTIONS:
      return "OPTIONS";
    case HttpMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * HTTP request.
 *
 * The task will be pushed to the worker as an HTTP request. If the worker
 * or the redirected worker acknowledges the task by returning a successful HTTP
 * response code ([`200` - `299`]), the task will be removed from the queue. If
 * any other HTTP response code is returned or no response is received, the
 * task will be retried according to the following:
 *
 * * User-specified throttling: [retry
 * configuration][google.cloud.tasks.v2.Queue.retry_config],
 *   [rate limits][google.cloud.tasks.v2.Queue.rate_limits], and the [queue's
 *   state][google.cloud.tasks.v2.Queue.state].
 *
 * * System throttling: To prevent the worker from overloading, Cloud Tasks may
 *   temporarily reduce the queue's effective rate. User-specified settings
 *   will not be changed.
 *
 *  System throttling happens because:
 *
 *   * Cloud Tasks backs off on all errors. Normally the backoff specified in
 *     [rate limits][google.cloud.tasks.v2.Queue.rate_limits] will be used. But
 *     if the worker returns `429` (Too Many Requests), `503` (Service
 *     Unavailable), or the rate of errors is high, Cloud Tasks will use a
 *     higher backoff rate. The retry specified in the `Retry-After` HTTP
 *     response header is considered.
 *
 *   * To prevent traffic spikes and to smooth sudden increases in traffic,
 *     dispatches ramp up slowly when the queue is newly created or idle and
 *     if large numbers of tasks suddenly become available to dispatch (due to
 *     spikes in create task rates, the queue being unpaused, or many tasks
 *     that are scheduled at the same time).
 */
export interface HttpRequest {
  /**
   * Required. The full url path that the request will be sent to.
   *
   * This string must begin with either "http://" or "https://". Some examples
   * are: `http://acme.com` and `https://acme.com/sales:8080`. Cloud Tasks will
   * encode some characters for safety and compatibility. The maximum allowed
   * URL length is 2083 characters after encoding.
   *
   * The `Location` header response from a redirect response [`300` - `399`]
   * may be followed. The redirect is not counted as a separate attempt.
   */
  url: string;
  /** The HTTP method to use for the request. The default is POST. */
  httpMethod: HttpMethod;
  /**
   * HTTP request headers.
   *
   * This map contains the header field names and values.
   * Headers can be set when the
   * [task is created][google.cloud.tasks.v2beta3.CloudTasks.CreateTask].
   *
   * These headers represent a subset of the headers that will accompany the
   * task's HTTP request. Some HTTP request headers will be ignored or replaced.
   *
   * A partial list of headers that will be ignored or replaced is:
   *
   * * Host: This will be computed by Cloud Tasks and derived from
   *   [HttpRequest.url][google.cloud.tasks.v2.HttpRequest.url].
   * * Content-Length: This will be computed by Cloud Tasks.
   * * User-Agent: This will be set to `"Google-Cloud-Tasks"`.
   * * `X-Google-*`: Google use only.
   * * `X-AppEngine-*`: Google use only.
   *
   * `Content-Type` won't be set by Cloud Tasks. You can explicitly set
   * `Content-Type` to a media type when the
   *  [task is created][google.cloud.tasks.v2beta3.CloudTasks.CreateTask].
   *  For example, `Content-Type` can be set to `"application/octet-stream"` or
   *  `"application/json"`.
   *
   * Headers which can have multiple values (according to RFC2616) can be
   * specified using comma-separated values.
   *
   * The size of the headers must be less than 80KB.
   */
  headers: { [key: string]: string };
  /**
   * HTTP request body.
   *
   * A request body is allowed only if the
   * [HTTP method][google.cloud.tasks.v2.HttpRequest.http_method] is POST, PUT,
   * or PATCH. It is an error to set body on a task with an incompatible
   * [HttpMethod][google.cloud.tasks.v2.HttpMethod].
   */
  body: Buffer;
  /**
   * If specified, an
   * [OAuth token](https://developers.google.com/identity/protocols/OAuth2)
   * will be generated and attached as an `Authorization` header in the HTTP
   * request.
   *
   * This type of authorization should generally only be used when calling
   * Google APIs hosted on *.googleapis.com.
   */
  oauthToken?:
    | OAuthToken
    | undefined;
  /**
   * If specified, an
   * [OIDC](https://developers.google.com/identity/protocols/OpenIDConnect)
   * token will be generated and attached as an `Authorization` header in the
   * HTTP request.
   *
   * This type of authorization can be used for many scenarios, including
   * calling Cloud Run, or endpoints where you intend to validate the token
   * yourself.
   */
  oidcToken?: OidcToken | undefined;
}

export interface HttpRequest_HeadersEntry {
  key: string;
  value: string;
}

/**
 * App Engine HTTP request.
 *
 * The message defines the HTTP request that is sent to an App Engine app when
 * the task is dispatched.
 *
 * Using [AppEngineHttpRequest][google.cloud.tasks.v2.AppEngineHttpRequest]
 * requires
 * [`appengine.applications.get`](https://cloud.google.com/appengine/docs/admin-api/access-control)
 * Google IAM permission for the project
 * and the following scope:
 *
 * `https://www.googleapis.com/auth/cloud-platform`
 *
 * The task will be delivered to the App Engine app which belongs to the same
 * project as the queue. For more information, see
 * [How Requests are
 * Routed](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
 * and how routing is affected by
 * [dispatch
 * files](https://cloud.google.com/appengine/docs/python/config/dispatchref).
 * Traffic is encrypted during transport and never leaves Google datacenters.
 * Because this traffic is carried over a communication mechanism internal to
 * Google, you cannot explicitly set the protocol (for example, HTTP or HTTPS).
 * The request to the handler, however, will appear to have used the HTTP
 * protocol.
 *
 * The [AppEngineRouting][google.cloud.tasks.v2.AppEngineRouting] used to
 * construct the URL that the task is delivered to can be set at the queue-level
 * or task-level:
 *
 * * If [app_engine_routing_override is set on the
 *   queue][google.cloud.tasks.v2.Queue.app_engine_routing_override], this value
 *   is used for all tasks in the queue, no matter what the setting is for the
 *   [task-level
 *   app_engine_routing][google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing].
 *
 * The `url` that the task will be sent to is:
 *
 * * `url =` [host][google.cloud.tasks.v2.AppEngineRouting.host] `+`
 *   [relative_uri][google.cloud.tasks.v2.AppEngineHttpRequest.relative_uri]
 *
 * Tasks can be dispatched to secure app handlers, unsecure app handlers, and
 * URIs restricted with
 * [`login:
 * admin`](https://cloud.google.com/appengine/docs/standard/python/config/appref).
 * Because tasks are not run as any user, they cannot be dispatched to URIs
 * restricted with
 * [`login:
 * required`](https://cloud.google.com/appengine/docs/standard/python/config/appref)
 * Task dispatches also do not follow redirects.
 *
 * The task attempt has succeeded if the app's request handler returns an HTTP
 * response code in the range [`200` - `299`]. The task attempt has failed if
 * the app's handler returns a non-2xx response code or Cloud Tasks does
 * not receive response before the
 * [deadline][google.cloud.tasks.v2.Task.dispatch_deadline]. Failed tasks will
 * be retried according to the [retry
 * configuration][google.cloud.tasks.v2.Queue.retry_config]. `503` (Service
 * Unavailable) is considered an App Engine system error instead of an
 * application error and will cause Cloud Tasks' traffic congestion control to
 * temporarily throttle the queue's dispatches. Unlike other types of task
 * targets, a `429` (Too Many Requests) response from an app handler does not
 * cause traffic congestion control to throttle the queue.
 */
export interface AppEngineHttpRequest {
  /**
   * The HTTP method to use for the request. The default is POST.
   *
   * The app's request handler for the task's target URL must be able to handle
   * HTTP requests with this http_method, otherwise the task attempt fails with
   * error code 405 (Method Not Allowed). See [Writing a push task request
   * handler](https://cloud.google.com/appengine/docs/java/taskqueue/push/creating-handlers#writing_a_push_task_request_handler)
   * and the App Engine documentation for your runtime on [How Requests are
   * Handled](https://cloud.google.com/appengine/docs/standard/python3/how-requests-are-handled).
   */
  httpMethod: HttpMethod;
  /**
   * Task-level setting for App Engine routing.
   *
   * * If [app_engine_routing_override is set on the
   *   queue][google.cloud.tasks.v2.Queue.app_engine_routing_override], this
   *   value is used for all tasks in the queue, no matter what the setting is
   *   for the [task-level
   *   app_engine_routing][google.cloud.tasks.v2.AppEngineHttpRequest.app_engine_routing].
   */
  appEngineRouting:
    | AppEngineRouting
    | undefined;
  /**
   * The relative URI.
   *
   * The relative URI must begin with "/" and must be a valid HTTP relative URI.
   * It can contain a path and query string arguments.
   * If the relative URI is empty, then the root path "/" will be used.
   * No spaces are allowed, and the maximum length allowed is 2083 characters.
   */
  relativeUri: string;
  /**
   * HTTP request headers.
   *
   * This map contains the header field names and values.
   * Headers can be set when the
   * [task is created][google.cloud.tasks.v2.CloudTasks.CreateTask].
   * Repeated headers are not supported but a header value can contain commas.
   *
   * Cloud Tasks sets some headers to default values:
   *
   * * `User-Agent`: By default, this header is
   *   `"AppEngine-Google; (+http://code.google.com/appengine)"`.
   *   This header can be modified, but Cloud Tasks will append
   *   `"AppEngine-Google; (+http://code.google.com/appengine)"` to the
   *   modified `User-Agent`.
   *
   * If the task has a [body][google.cloud.tasks.v2.AppEngineHttpRequest.body],
   * Cloud Tasks sets the following headers:
   *
   * * `Content-Type`: By default, the `Content-Type` header is set to
   *   `"application/octet-stream"`. The default can be overridden by explicitly
   *   setting `Content-Type` to a particular media type when the
   *   [task is created][google.cloud.tasks.v2.CloudTasks.CreateTask].
   *   For example, `Content-Type` can be set to `"application/json"`.
   * * `Content-Length`: This is computed by Cloud Tasks. This value is
   *   output only.   It cannot be changed.
   *
   * The headers below cannot be set or overridden:
   *
   * * `Host`
   * * `X-Google-*`
   * * `X-AppEngine-*`
   *
   * In addition, Cloud Tasks sets some headers when the task is dispatched,
   * such as headers containing information about the task; see
   * [request
   * headers](https://cloud.google.com/tasks/docs/creating-appengine-handlers#reading_request_headers).
   * These headers are set only when the task is dispatched, so they are not
   * visible when the task is returned in a Cloud Tasks response.
   *
   * Although there is no specific limit for the maximum number of headers or
   * the size, there is a limit on the maximum size of the
   * [Task][google.cloud.tasks.v2.Task]. For more information, see the
   * [CreateTask][google.cloud.tasks.v2.CloudTasks.CreateTask] documentation.
   */
  headers: { [key: string]: string };
  /**
   * HTTP request body.
   *
   * A request body is allowed only if the HTTP method is POST or PUT. It is
   * an error to set a body on a task with an incompatible
   * [HttpMethod][google.cloud.tasks.v2.HttpMethod].
   */
  body: Buffer;
}

export interface AppEngineHttpRequest_HeadersEntry {
  key: string;
  value: string;
}

/**
 * App Engine Routing.
 *
 * Defines routing characteristics specific to App Engine - service, version,
 * and instance.
 *
 * For more information about services, versions, and instances see
 * [An Overview of App
 * Engine](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine),
 * [Microservices Architecture on Google App
 * Engine](https://cloud.google.com/appengine/docs/python/microservices-on-app-engine),
 * [App Engine Standard request
 * routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed),
 * and [App Engine Flex request
 * routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
 *
 * Using [AppEngineRouting][google.cloud.tasks.v2.AppEngineRouting] requires
 * [`appengine.applications.get`](https://cloud.google.com/appengine/docs/admin-api/access-control)
 * Google IAM permission for the project
 * and the following scope:
 *
 * `https://www.googleapis.com/auth/cloud-platform`
 */
export interface AppEngineRouting {
  /**
   * App service.
   *
   * By default, the task is sent to the service which is the default
   * service when the task is attempted.
   *
   * For some queues or tasks which were created using the App Engine
   * Task Queue API, [host][google.cloud.tasks.v2.AppEngineRouting.host] is not
   * parsable into [service][google.cloud.tasks.v2.AppEngineRouting.service],
   * [version][google.cloud.tasks.v2.AppEngineRouting.version], and
   * [instance][google.cloud.tasks.v2.AppEngineRouting.instance]. For example,
   * some tasks which were created using the App Engine SDK use a custom domain
   * name; custom domains are not parsed by Cloud Tasks. If
   * [host][google.cloud.tasks.v2.AppEngineRouting.host] is not parsable, then
   * [service][google.cloud.tasks.v2.AppEngineRouting.service],
   * [version][google.cloud.tasks.v2.AppEngineRouting.version], and
   * [instance][google.cloud.tasks.v2.AppEngineRouting.instance] are the empty
   * string.
   */
  service: string;
  /**
   * App version.
   *
   * By default, the task is sent to the version which is the default
   * version when the task is attempted.
   *
   * For some queues or tasks which were created using the App Engine
   * Task Queue API, [host][google.cloud.tasks.v2.AppEngineRouting.host] is not
   * parsable into [service][google.cloud.tasks.v2.AppEngineRouting.service],
   * [version][google.cloud.tasks.v2.AppEngineRouting.version], and
   * [instance][google.cloud.tasks.v2.AppEngineRouting.instance]. For example,
   * some tasks which were created using the App Engine SDK use a custom domain
   * name; custom domains are not parsed by Cloud Tasks. If
   * [host][google.cloud.tasks.v2.AppEngineRouting.host] is not parsable, then
   * [service][google.cloud.tasks.v2.AppEngineRouting.service],
   * [version][google.cloud.tasks.v2.AppEngineRouting.version], and
   * [instance][google.cloud.tasks.v2.AppEngineRouting.instance] are the empty
   * string.
   */
  version: string;
  /**
   * App instance.
   *
   * By default, the task is sent to an instance which is available when
   * the task is attempted.
   *
   * Requests can only be sent to a specific instance if
   * [manual scaling is used in App Engine
   * Standard](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine?hl=en_US#scaling_types_and_instance_classes).
   * App Engine Flex does not support instances. For more information, see
   * [App Engine Standard request
   * routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
   * and [App Engine Flex request
   * routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
   */
  instance: string;
  /**
   * Output only. The host that the task is sent to.
   *
   * The host is constructed from the domain name of the app associated with
   * the queue's project ID (for example <app-id>.appspot.com), and the
   * [service][google.cloud.tasks.v2.AppEngineRouting.service],
   * [version][google.cloud.tasks.v2.AppEngineRouting.version], and
   * [instance][google.cloud.tasks.v2.AppEngineRouting.instance]. Tasks which
   * were created using the App Engine SDK might have a custom domain name.
   *
   * For more information, see
   * [How Requests are
   * Routed](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed).
   */
  host: string;
}

/**
 * Contains information needed for generating an
 * [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
 * This type of authorization should generally only be used when calling Google
 * APIs hosted on *.googleapis.com.
 */
export interface OAuthToken {
  /**
   * [Service account email](https://cloud.google.com/iam/docs/service-accounts)
   * to be used for generating OAuth token.
   * The service account must be within the same project as the queue. The
   * caller must have iam.serviceAccounts.actAs permission for the service
   * account.
   */
  serviceAccountEmail: string;
  /**
   * OAuth scope to be used for generating OAuth access token.
   * If not specified, "https://www.googleapis.com/auth/cloud-platform"
   * will be used.
   */
  scope: string;
}

/**
 * Contains information needed for generating an
 * [OpenID Connect
 * token](https://developers.google.com/identity/protocols/OpenIDConnect).
 * This type of authorization can be used for many scenarios, including
 * calling Cloud Run, or endpoints where you intend to validate the token
 * yourself.
 */
export interface OidcToken {
  /**
   * [Service account email](https://cloud.google.com/iam/docs/service-accounts)
   * to be used for generating OIDC token.
   * The service account must be within the same project as the queue. The
   * caller must have iam.serviceAccounts.actAs permission for the service
   * account.
   */
  serviceAccountEmail: string;
  /**
   * Audience to be used when generating OIDC token. If not specified, the URI
   * specified in target will be used.
   */
  audience: string;
}

function createBaseHttpRequest(): HttpRequest {
  return { url: "", httpMethod: 0, headers: {}, body: Buffer.alloc(0), oauthToken: undefined, oidcToken: undefined };
}

export const HttpRequest: MessageFns<HttpRequest> = {
  encode(message: HttpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.httpMethod !== 0) {
      writer.uint32(16).int32(message.httpMethod);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      HttpRequest_HeadersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.body.length !== 0) {
      writer.uint32(34).bytes(message.body);
    }
    if (message.oauthToken !== undefined) {
      OAuthToken.encode(message.oauthToken, writer.uint32(42).fork()).join();
    }
    if (message.oidcToken !== undefined) {
      OidcToken.encode(message.oidcToken, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.httpMethod = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = HttpRequest_HeadersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.headers[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.body = Buffer.from(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.oauthToken = OAuthToken.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.oidcToken = OidcToken.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRequest {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      httpMethod: isSet(object.httpMethod) ? httpMethodFromJSON(object.httpMethod) : 0,
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      body: isSet(object.body) ? Buffer.from(bytesFromBase64(object.body)) : Buffer.alloc(0),
      oauthToken: isSet(object.oauthToken) ? OAuthToken.fromJSON(object.oauthToken) : undefined,
      oidcToken: isSet(object.oidcToken) ? OidcToken.fromJSON(object.oidcToken) : undefined,
    };
  },

  toJSON(message: HttpRequest): unknown {
    const obj: any = {};
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.httpMethod !== 0) {
      obj.httpMethod = httpMethodToJSON(message.httpMethod);
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.oauthToken !== undefined) {
      obj.oauthToken = OAuthToken.toJSON(message.oauthToken);
    }
    if (message.oidcToken !== undefined) {
      obj.oidcToken = OidcToken.toJSON(message.oidcToken);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRequest>): HttpRequest {
    return HttpRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRequest>): HttpRequest {
    const message = createBaseHttpRequest();
    message.url = object.url ?? "";
    message.httpMethod = object.httpMethod ?? 0;
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? Buffer.alloc(0);
    message.oauthToken = (object.oauthToken !== undefined && object.oauthToken !== null)
      ? OAuthToken.fromPartial(object.oauthToken)
      : undefined;
    message.oidcToken = (object.oidcToken !== undefined && object.oidcToken !== null)
      ? OidcToken.fromPartial(object.oidcToken)
      : undefined;
    return message;
  },
};

function createBaseHttpRequest_HeadersEntry(): HttpRequest_HeadersEntry {
  return { key: "", value: "" };
}

export const HttpRequest_HeadersEntry: MessageFns<HttpRequest_HeadersEntry> = {
  encode(message: HttpRequest_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRequest_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRequest_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRequest_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpRequest_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRequest_HeadersEntry>): HttpRequest_HeadersEntry {
    return HttpRequest_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRequest_HeadersEntry>): HttpRequest_HeadersEntry {
    const message = createBaseHttpRequest_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAppEngineHttpRequest(): AppEngineHttpRequest {
  return { httpMethod: 0, appEngineRouting: undefined, relativeUri: "", headers: {}, body: Buffer.alloc(0) };
}

export const AppEngineHttpRequest: MessageFns<AppEngineHttpRequest> = {
  encode(message: AppEngineHttpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpMethod !== 0) {
      writer.uint32(8).int32(message.httpMethod);
    }
    if (message.appEngineRouting !== undefined) {
      AppEngineRouting.encode(message.appEngineRouting, writer.uint32(18).fork()).join();
    }
    if (message.relativeUri !== "") {
      writer.uint32(26).string(message.relativeUri);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      AppEngineHttpRequest_HeadersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.body.length !== 0) {
      writer.uint32(42).bytes(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineHttpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineHttpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.httpMethod = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.appEngineRouting = AppEngineRouting.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.relativeUri = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = AppEngineHttpRequest_HeadersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.headers[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.body = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineHttpRequest {
    return {
      httpMethod: isSet(object.httpMethod) ? httpMethodFromJSON(object.httpMethod) : 0,
      appEngineRouting: isSet(object.appEngineRouting) ? AppEngineRouting.fromJSON(object.appEngineRouting) : undefined,
      relativeUri: isSet(object.relativeUri) ? globalThis.String(object.relativeUri) : "",
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      body: isSet(object.body) ? Buffer.from(bytesFromBase64(object.body)) : Buffer.alloc(0),
    };
  },

  toJSON(message: AppEngineHttpRequest): unknown {
    const obj: any = {};
    if (message.httpMethod !== 0) {
      obj.httpMethod = httpMethodToJSON(message.httpMethod);
    }
    if (message.appEngineRouting !== undefined) {
      obj.appEngineRouting = AppEngineRouting.toJSON(message.appEngineRouting);
    }
    if (message.relativeUri !== "") {
      obj.relativeUri = message.relativeUri;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    return obj;
  },

  create(base?: DeepPartial<AppEngineHttpRequest>): AppEngineHttpRequest {
    return AppEngineHttpRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppEngineHttpRequest>): AppEngineHttpRequest {
    const message = createBaseAppEngineHttpRequest();
    message.httpMethod = object.httpMethod ?? 0;
    message.appEngineRouting = (object.appEngineRouting !== undefined && object.appEngineRouting !== null)
      ? AppEngineRouting.fromPartial(object.appEngineRouting)
      : undefined;
    message.relativeUri = object.relativeUri ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.body = object.body ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseAppEngineHttpRequest_HeadersEntry(): AppEngineHttpRequest_HeadersEntry {
  return { key: "", value: "" };
}

export const AppEngineHttpRequest_HeadersEntry: MessageFns<AppEngineHttpRequest_HeadersEntry> = {
  encode(message: AppEngineHttpRequest_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineHttpRequest_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineHttpRequest_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineHttpRequest_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AppEngineHttpRequest_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AppEngineHttpRequest_HeadersEntry>): AppEngineHttpRequest_HeadersEntry {
    return AppEngineHttpRequest_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppEngineHttpRequest_HeadersEntry>): AppEngineHttpRequest_HeadersEntry {
    const message = createBaseAppEngineHttpRequest_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAppEngineRouting(): AppEngineRouting {
  return { service: "", version: "", instance: "", host: "" };
}

export const AppEngineRouting: MessageFns<AppEngineRouting> = {
  encode(message: AppEngineRouting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.instance !== "") {
      writer.uint32(26).string(message.instance);
    }
    if (message.host !== "") {
      writer.uint32(34).string(message.host);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppEngineRouting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppEngineRouting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.host = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppEngineRouting {
    return {
      service: isSet(object.service) ? globalThis.String(object.service) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
    };
  },

  toJSON(message: AppEngineRouting): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    return obj;
  },

  create(base?: DeepPartial<AppEngineRouting>): AppEngineRouting {
    return AppEngineRouting.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppEngineRouting>): AppEngineRouting {
    const message = createBaseAppEngineRouting();
    message.service = object.service ?? "";
    message.version = object.version ?? "";
    message.instance = object.instance ?? "";
    message.host = object.host ?? "";
    return message;
  },
};

function createBaseOAuthToken(): OAuthToken {
  return { serviceAccountEmail: "", scope: "" };
}

export const OAuthToken: MessageFns<OAuthToken> = {
  encode(message: OAuthToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccountEmail !== "") {
      writer.uint32(10).string(message.serviceAccountEmail);
    }
    if (message.scope !== "") {
      writer.uint32(18).string(message.scope);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceAccountEmail = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scope = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthToken {
    return {
      serviceAccountEmail: isSet(object.serviceAccountEmail) ? globalThis.String(object.serviceAccountEmail) : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
    };
  },

  toJSON(message: OAuthToken): unknown {
    const obj: any = {};
    if (message.serviceAccountEmail !== "") {
      obj.serviceAccountEmail = message.serviceAccountEmail;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    return obj;
  },

  create(base?: DeepPartial<OAuthToken>): OAuthToken {
    return OAuthToken.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OAuthToken>): OAuthToken {
    const message = createBaseOAuthToken();
    message.serviceAccountEmail = object.serviceAccountEmail ?? "";
    message.scope = object.scope ?? "";
    return message;
  },
};

function createBaseOidcToken(): OidcToken {
  return { serviceAccountEmail: "", audience: "" };
}

export const OidcToken: MessageFns<OidcToken> = {
  encode(message: OidcToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceAccountEmail !== "") {
      writer.uint32(10).string(message.serviceAccountEmail);
    }
    if (message.audience !== "") {
      writer.uint32(18).string(message.audience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OidcToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOidcToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceAccountEmail = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.audience = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OidcToken {
    return {
      serviceAccountEmail: isSet(object.serviceAccountEmail) ? globalThis.String(object.serviceAccountEmail) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
    };
  },

  toJSON(message: OidcToken): unknown {
    const obj: any = {};
    if (message.serviceAccountEmail !== "") {
      obj.serviceAccountEmail = message.serviceAccountEmail;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    return obj;
  },

  create(base?: DeepPartial<OidcToken>): OidcToken {
    return OidcToken.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OidcToken>): OidcToken {
    const message = createBaseOidcToken();
    message.serviceAccountEmail = object.serviceAccountEmail ?? "";
    message.audience = object.audience ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
