// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/gkemulticloud/v1/attached_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { AttachedCluster, AttachedProxyConfig, AttachedServerConfig } from "./attached_resources.js";

export const protobufPackage = "google.cloud.gkemulticloud.v1";

/**
 * Request message for `AttachedClusters.GenerateAttachedClusterInstallManifest`
 * method.
 */
export interface GenerateAttachedClusterInstallManifestRequest {
  /**
   * Required. The parent location where this
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * will be created.
   *
   * Location names are formatted as `projects/<project-id>/locations/<region>`.
   *
   * See [Resource Names](https://cloud.google.com/apis/design/resource_names)
   * for more details on Google Cloud resource names.
   */
  parent: string;
  /**
   * Required. A client provided ID of the resource. Must be unique within the
   * parent resource.
   *
   * The provided ID will be part of the
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * name formatted as
   * `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
   *
   * Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
   *
   * When generating an install manifest for importing an existing Membership
   * resource, the attached_cluster_id field must be the Membership id.
   *
   * Membership names are formatted as
   * `projects/<project-id>/locations/<region>/memberships/<membership-id>`.
   */
  attachedClusterId: string;
  /**
   * Required. The platform version for the cluster (e.g. `1.19.0-gke.1000`).
   *
   * You can list all supported versions on a given Google Cloud region by
   * calling
   * [GetAttachedServerConfig][google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig].
   */
  platformVersion: string;
  /** Optional. Proxy configuration for outbound HTTP(S) traffic. */
  proxyConfig: AttachedProxyConfig | undefined;
}

/**
 * Response message for
 * `AttachedClusters.GenerateAttachedClusterInstallManifest` method.
 */
export interface GenerateAttachedClusterInstallManifestResponse {
  /**
   * A set of Kubernetes resources (in YAML format) to be applied
   * to the cluster to be attached.
   */
  manifest: string;
}

/** Request message for `AttachedClusters.CreateAttachedCluster` method. */
export interface CreateAttachedClusterRequest {
  /**
   * Required. The parent location where this
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * will be created.
   *
   * Location names are formatted as `projects/<project-id>/locations/<region>`.
   *
   * See [Resource Names](https://cloud.google.com/apis/design/resource_names)
   * for more details on Google Cloud resource names.
   */
  parent: string;
  /**
   * Required. The specification of the
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] to create.
   */
  attachedCluster:
    | AttachedCluster
    | undefined;
  /**
   * Required. A client provided ID the resource. Must be unique within the
   * parent resource.
   *
   * The provided ID will be part of the
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * name formatted as
   * `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
   *
   * Valid characters are `/[a-z][0-9]-/`. Cannot be longer than 63 characters.
   */
  attachedClusterId: string;
  /** If set, only validate the request, but do not actually create the cluster. */
  validateOnly: boolean;
}

/** Request message for `AttachedClusters.ImportAttachedCluster` method. */
export interface ImportAttachedClusterRequest {
  /**
   * Required. The parent location where this
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * will be created.
   *
   * Location names are formatted as `projects/<project-id>/locations/<region>`.
   *
   * See [Resource Names](https://cloud.google.com/apis/design/resource_names)
   * for more details on Google Cloud resource names.
   */
  parent: string;
  /** If set, only validate the request, but do not actually import the cluster. */
  validateOnly: boolean;
  /** Required. The name of the fleet membership resource to import. */
  fleetMembership: string;
  /**
   * Required. The platform version for the cluster (e.g. `1.19.0-gke.1000`).
   *
   * You can list all supported versions on a given Google Cloud region by
   * calling
   * [GetAttachedServerConfig][google.cloud.gkemulticloud.v1.AttachedClusters.GetAttachedServerConfig].
   */
  platformVersion: string;
  /**
   * Required. The Kubernetes distribution of the underlying attached cluster.
   *
   * Supported values: ["eks", "aks", "generic"].
   */
  distribution: string;
  /** Optional. Proxy configuration for outbound HTTP(S) traffic. */
  proxyConfig: AttachedProxyConfig | undefined;
}

/** Request message for `AttachedClusters.UpdateAttachedCluster` method. */
export interface UpdateAttachedClusterRequest {
  /**
   * Required. The
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * to update.
   */
  attachedCluster:
    | AttachedCluster
    | undefined;
  /** If set, only validate the request, but do not actually update the cluster. */
  validateOnly: boolean;
  /**
   * Required. Mask of fields to update. At least one path must be supplied in
   * this field. The elements of the repeated paths field can only include these
   * fields from
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster]:
   *
   *  *   `annotations`.
   *  *   `authorization.admin_groups`.
   *  *   `authorization.admin_users`.
   *  *   `binary_authorization.evaluation_mode`.
   *  *   `description`.
   *  *   `logging_config.component_config.enable_components`.
   *  *   `monitoring_config.managed_prometheus_config.enabled`.
   *  *   `platform_version`.
   *  *   `proxy_config.kubernetes_secret.name`.
   *  *   `proxy_config.kubernetes_secret.namespace`.
   *  *   `security_posture_config.vulnerability_mode`
   */
  updateMask: string[] | undefined;
}

/** Request message for `AttachedClusters.GetAttachedCluster` method. */
export interface GetAttachedClusterRequest {
  /**
   * Required. The name of the
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * to describe.
   *
   * `AttachedCluster` names are formatted as
   * `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
   *
   * See [Resource Names](https://cloud.google.com/apis/design/resource_names)
   * for more details on Google Cloud Platform resource names.
   */
  name: string;
}

/** Request message for `AttachedClusters.ListAttachedClusters` method. */
export interface ListAttachedClustersRequest {
  /**
   * Required. The parent location which owns this collection of
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resources.
   *
   * Location names are formatted as `projects/<project-id>/locations/<region>`.
   *
   * See [Resource Names](https://cloud.google.com/apis/design/resource_names)
   * for more details on Google Cloud Platform resource names.
   */
  parent: string;
  /**
   * The maximum number of items to return.
   *
   * If not specified, a default value of 50 will be used by the service.
   * Regardless of the pageSize value, the response can include a partial list
   * and a caller should only rely on response's
   * [nextPageToken][google.cloud.gkemulticloud.v1.ListAttachedClustersResponse.next_page_token]
   * to determine if there are more instances left to be queried.
   */
  pageSize: number;
  /**
   * The `nextPageToken` value returned from a previous
   * [attachedClusters.list][google.cloud.gkemulticloud.v1.AttachedClusters.ListAttachedClusters]
   * request, if any.
   */
  pageToken: string;
}

/** Response message for `AttachedClusters.ListAttachedClusters` method. */
export interface ListAttachedClustersResponse {
  /**
   * A list of [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster]
   * resources in the specified Google Cloud Platform project and region region.
   */
  attachedClusters: AttachedCluster[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/** Request message for `AttachedClusters.DeleteAttachedCluster` method. */
export interface DeleteAttachedClusterRequest {
  /**
   * Required. The resource name the
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] to delete.
   *
   * `AttachedCluster` names are formatted as
   * `projects/<project-id>/locations/<region>/attachedClusters/<cluster-id>`.
   *
   * See [Resource Names](https://cloud.google.com/apis/design/resource_names)
   * for more details on Google Cloud Platform resource names.
   */
  name: string;
  /** If set, only validate the request, but do not actually delete the resource. */
  validateOnly: boolean;
  /**
   * If set to true, and the
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * is not found, the request will succeed but no action will be taken on the
   * server and a completed [Operation][google.longrunning.Operation] will be
   * returned.
   *
   * Useful for idempotent deletion.
   */
  allowMissing: boolean;
  /**
   * If set to true, the deletion of
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * will succeed even if errors occur during deleting in cluster resources.
   * Using this parameter may result in orphaned resources in the cluster.
   */
  ignoreErrors: boolean;
  /**
   * The current etag of the
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster].
   *
   * Allows clients to perform deletions through optimistic concurrency control.
   *
   * If the provided etag does not match the current etag of the cluster,
   * the request will fail and an ABORTED error will be returned.
   */
  etag: string;
}

/**
 * GetAttachedServerConfigRequest gets the server config for attached
 * clusters.
 */
export interface GetAttachedServerConfigRequest {
  /**
   * Required. The name of the
   * [AttachedServerConfig][google.cloud.gkemulticloud.v1.AttachedServerConfig]
   * resource to describe.
   *
   * `AttachedServerConfig` names are formatted as
   * `projects/<project-id>/locations/<region>/attachedServerConfig`.
   *
   * See [Resource Names](https://cloud.google.com/apis/design/resource_names)
   * for more details on Google Cloud resource names.
   */
  name: string;
}

export interface GenerateAttachedClusterAgentTokenRequest {
  /** Required. */
  attachedCluster: string;
  /** Required. */
  subjectToken: string;
  /** Required. */
  subjectTokenType: string;
  /** Required. */
  version: string;
  /** Optional. */
  grantType: string;
  /** Optional. */
  audience: string;
  /** Optional. */
  scope: string;
  /** Optional. */
  requestedTokenType: string;
  /** Optional. */
  options: string;
}

export interface GenerateAttachedClusterAgentTokenResponse {
  accessToken: string;
  expiresIn: number;
  tokenType: string;
}

function createBaseGenerateAttachedClusterInstallManifestRequest(): GenerateAttachedClusterInstallManifestRequest {
  return { parent: "", attachedClusterId: "", platformVersion: "", proxyConfig: undefined };
}

export const GenerateAttachedClusterInstallManifestRequest: MessageFns<GenerateAttachedClusterInstallManifestRequest> =
  {
    encode(
      message: GenerateAttachedClusterInstallManifestRequest,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.parent !== "") {
        writer.uint32(10).string(message.parent);
      }
      if (message.attachedClusterId !== "") {
        writer.uint32(18).string(message.attachedClusterId);
      }
      if (message.platformVersion !== "") {
        writer.uint32(26).string(message.platformVersion);
      }
      if (message.proxyConfig !== undefined) {
        AttachedProxyConfig.encode(message.proxyConfig, writer.uint32(34).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GenerateAttachedClusterInstallManifestRequest {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseGenerateAttachedClusterInstallManifestRequest();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.parent = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.attachedClusterId = reader.string();
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.platformVersion = reader.string();
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            message.proxyConfig = AttachedProxyConfig.decode(reader, reader.uint32());
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): GenerateAttachedClusterInstallManifestRequest {
      return {
        parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
        attachedClusterId: isSet(object.attachedClusterId) ? globalThis.String(object.attachedClusterId) : "",
        platformVersion: isSet(object.platformVersion) ? globalThis.String(object.platformVersion) : "",
        proxyConfig: isSet(object.proxyConfig) ? AttachedProxyConfig.fromJSON(object.proxyConfig) : undefined,
      };
    },

    toJSON(message: GenerateAttachedClusterInstallManifestRequest): unknown {
      const obj: any = {};
      if (message.parent !== "") {
        obj.parent = message.parent;
      }
      if (message.attachedClusterId !== "") {
        obj.attachedClusterId = message.attachedClusterId;
      }
      if (message.platformVersion !== "") {
        obj.platformVersion = message.platformVersion;
      }
      if (message.proxyConfig !== undefined) {
        obj.proxyConfig = AttachedProxyConfig.toJSON(message.proxyConfig);
      }
      return obj;
    },

    create(
      base?: DeepPartial<GenerateAttachedClusterInstallManifestRequest>,
    ): GenerateAttachedClusterInstallManifestRequest {
      return GenerateAttachedClusterInstallManifestRequest.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<GenerateAttachedClusterInstallManifestRequest>,
    ): GenerateAttachedClusterInstallManifestRequest {
      const message = createBaseGenerateAttachedClusterInstallManifestRequest();
      message.parent = object.parent ?? "";
      message.attachedClusterId = object.attachedClusterId ?? "";
      message.platformVersion = object.platformVersion ?? "";
      message.proxyConfig = (object.proxyConfig !== undefined && object.proxyConfig !== null)
        ? AttachedProxyConfig.fromPartial(object.proxyConfig)
        : undefined;
      return message;
    },
  };

function createBaseGenerateAttachedClusterInstallManifestResponse(): GenerateAttachedClusterInstallManifestResponse {
  return { manifest: "" };
}

export const GenerateAttachedClusterInstallManifestResponse: MessageFns<
  GenerateAttachedClusterInstallManifestResponse
> = {
  encode(
    message: GenerateAttachedClusterInstallManifestResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.manifest !== "") {
      writer.uint32(10).string(message.manifest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAttachedClusterInstallManifestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAttachedClusterInstallManifestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.manifest = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAttachedClusterInstallManifestResponse {
    return { manifest: isSet(object.manifest) ? globalThis.String(object.manifest) : "" };
  },

  toJSON(message: GenerateAttachedClusterInstallManifestResponse): unknown {
    const obj: any = {};
    if (message.manifest !== "") {
      obj.manifest = message.manifest;
    }
    return obj;
  },

  create(
    base?: DeepPartial<GenerateAttachedClusterInstallManifestResponse>,
  ): GenerateAttachedClusterInstallManifestResponse {
    return GenerateAttachedClusterInstallManifestResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerateAttachedClusterInstallManifestResponse>,
  ): GenerateAttachedClusterInstallManifestResponse {
    const message = createBaseGenerateAttachedClusterInstallManifestResponse();
    message.manifest = object.manifest ?? "";
    return message;
  },
};

function createBaseCreateAttachedClusterRequest(): CreateAttachedClusterRequest {
  return { parent: "", attachedCluster: undefined, attachedClusterId: "", validateOnly: false };
}

export const CreateAttachedClusterRequest: MessageFns<CreateAttachedClusterRequest> = {
  encode(message: CreateAttachedClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.attachedCluster !== undefined) {
      AttachedCluster.encode(message.attachedCluster, writer.uint32(18).fork()).join();
    }
    if (message.attachedClusterId !== "") {
      writer.uint32(26).string(message.attachedClusterId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAttachedClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAttachedClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attachedCluster = AttachedCluster.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.attachedClusterId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAttachedClusterRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      attachedCluster: isSet(object.attachedCluster) ? AttachedCluster.fromJSON(object.attachedCluster) : undefined,
      attachedClusterId: isSet(object.attachedClusterId) ? globalThis.String(object.attachedClusterId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateAttachedClusterRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.attachedCluster !== undefined) {
      obj.attachedCluster = AttachedCluster.toJSON(message.attachedCluster);
    }
    if (message.attachedClusterId !== "") {
      obj.attachedClusterId = message.attachedClusterId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAttachedClusterRequest>): CreateAttachedClusterRequest {
    return CreateAttachedClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAttachedClusterRequest>): CreateAttachedClusterRequest {
    const message = createBaseCreateAttachedClusterRequest();
    message.parent = object.parent ?? "";
    message.attachedCluster = (object.attachedCluster !== undefined && object.attachedCluster !== null)
      ? AttachedCluster.fromPartial(object.attachedCluster)
      : undefined;
    message.attachedClusterId = object.attachedClusterId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseImportAttachedClusterRequest(): ImportAttachedClusterRequest {
  return {
    parent: "",
    validateOnly: false,
    fleetMembership: "",
    platformVersion: "",
    distribution: "",
    proxyConfig: undefined,
  };
}

export const ImportAttachedClusterRequest: MessageFns<ImportAttachedClusterRequest> = {
  encode(message: ImportAttachedClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.validateOnly !== false) {
      writer.uint32(16).bool(message.validateOnly);
    }
    if (message.fleetMembership !== "") {
      writer.uint32(26).string(message.fleetMembership);
    }
    if (message.platformVersion !== "") {
      writer.uint32(34).string(message.platformVersion);
    }
    if (message.distribution !== "") {
      writer.uint32(42).string(message.distribution);
    }
    if (message.proxyConfig !== undefined) {
      AttachedProxyConfig.encode(message.proxyConfig, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ImportAttachedClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportAttachedClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fleetMembership = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.platformVersion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.distribution = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.proxyConfig = AttachedProxyConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ImportAttachedClusterRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      fleetMembership: isSet(object.fleetMembership) ? globalThis.String(object.fleetMembership) : "",
      platformVersion: isSet(object.platformVersion) ? globalThis.String(object.platformVersion) : "",
      distribution: isSet(object.distribution) ? globalThis.String(object.distribution) : "",
      proxyConfig: isSet(object.proxyConfig) ? AttachedProxyConfig.fromJSON(object.proxyConfig) : undefined,
    };
  },

  toJSON(message: ImportAttachedClusterRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.fleetMembership !== "") {
      obj.fleetMembership = message.fleetMembership;
    }
    if (message.platformVersion !== "") {
      obj.platformVersion = message.platformVersion;
    }
    if (message.distribution !== "") {
      obj.distribution = message.distribution;
    }
    if (message.proxyConfig !== undefined) {
      obj.proxyConfig = AttachedProxyConfig.toJSON(message.proxyConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ImportAttachedClusterRequest>): ImportAttachedClusterRequest {
    return ImportAttachedClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ImportAttachedClusterRequest>): ImportAttachedClusterRequest {
    const message = createBaseImportAttachedClusterRequest();
    message.parent = object.parent ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.fleetMembership = object.fleetMembership ?? "";
    message.platformVersion = object.platformVersion ?? "";
    message.distribution = object.distribution ?? "";
    message.proxyConfig = (object.proxyConfig !== undefined && object.proxyConfig !== null)
      ? AttachedProxyConfig.fromPartial(object.proxyConfig)
      : undefined;
    return message;
  },
};

function createBaseUpdateAttachedClusterRequest(): UpdateAttachedClusterRequest {
  return { attachedCluster: undefined, validateOnly: false, updateMask: undefined };
}

export const UpdateAttachedClusterRequest: MessageFns<UpdateAttachedClusterRequest> = {
  encode(message: UpdateAttachedClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attachedCluster !== undefined) {
      AttachedCluster.encode(message.attachedCluster, writer.uint32(10).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(16).bool(message.validateOnly);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAttachedClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAttachedClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attachedCluster = AttachedCluster.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAttachedClusterRequest {
    return {
      attachedCluster: isSet(object.attachedCluster) ? AttachedCluster.fromJSON(object.attachedCluster) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAttachedClusterRequest): unknown {
    const obj: any = {};
    if (message.attachedCluster !== undefined) {
      obj.attachedCluster = AttachedCluster.toJSON(message.attachedCluster);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAttachedClusterRequest>): UpdateAttachedClusterRequest {
    return UpdateAttachedClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAttachedClusterRequest>): UpdateAttachedClusterRequest {
    const message = createBaseUpdateAttachedClusterRequest();
    message.attachedCluster = (object.attachedCluster !== undefined && object.attachedCluster !== null)
      ? AttachedCluster.fromPartial(object.attachedCluster)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetAttachedClusterRequest(): GetAttachedClusterRequest {
  return { name: "" };
}

export const GetAttachedClusterRequest: MessageFns<GetAttachedClusterRequest> = {
  encode(message: GetAttachedClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAttachedClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttachedClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAttachedClusterRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAttachedClusterRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAttachedClusterRequest>): GetAttachedClusterRequest {
    return GetAttachedClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAttachedClusterRequest>): GetAttachedClusterRequest {
    const message = createBaseGetAttachedClusterRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListAttachedClustersRequest(): ListAttachedClustersRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListAttachedClustersRequest: MessageFns<ListAttachedClustersRequest> = {
  encode(message: ListAttachedClustersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAttachedClustersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAttachedClustersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAttachedClustersRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListAttachedClustersRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAttachedClustersRequest>): ListAttachedClustersRequest {
    return ListAttachedClustersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAttachedClustersRequest>): ListAttachedClustersRequest {
    const message = createBaseListAttachedClustersRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListAttachedClustersResponse(): ListAttachedClustersResponse {
  return { attachedClusters: [], nextPageToken: "" };
}

export const ListAttachedClustersResponse: MessageFns<ListAttachedClustersResponse> = {
  encode(message: ListAttachedClustersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.attachedClusters) {
      AttachedCluster.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAttachedClustersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAttachedClustersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attachedClusters.push(AttachedCluster.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAttachedClustersResponse {
    return {
      attachedClusters: globalThis.Array.isArray(object?.attachedClusters)
        ? object.attachedClusters.map((e: any) => AttachedCluster.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAttachedClustersResponse): unknown {
    const obj: any = {};
    if (message.attachedClusters?.length) {
      obj.attachedClusters = message.attachedClusters.map((e) => AttachedCluster.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAttachedClustersResponse>): ListAttachedClustersResponse {
    return ListAttachedClustersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAttachedClustersResponse>): ListAttachedClustersResponse {
    const message = createBaseListAttachedClustersResponse();
    message.attachedClusters = object.attachedClusters?.map((e) => AttachedCluster.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteAttachedClusterRequest(): DeleteAttachedClusterRequest {
  return { name: "", validateOnly: false, allowMissing: false, ignoreErrors: false, etag: "" };
}

export const DeleteAttachedClusterRequest: MessageFns<DeleteAttachedClusterRequest> = {
  encode(message: DeleteAttachedClusterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.validateOnly !== false) {
      writer.uint32(16).bool(message.validateOnly);
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    if (message.ignoreErrors !== false) {
      writer.uint32(40).bool(message.ignoreErrors);
    }
    if (message.etag !== "") {
      writer.uint32(34).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAttachedClusterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAttachedClusterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.ignoreErrors = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAttachedClusterRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      ignoreErrors: isSet(object.ignoreErrors) ? globalThis.Boolean(object.ignoreErrors) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteAttachedClusterRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.ignoreErrors !== false) {
      obj.ignoreErrors = message.ignoreErrors;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAttachedClusterRequest>): DeleteAttachedClusterRequest {
    return DeleteAttachedClusterRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAttachedClusterRequest>): DeleteAttachedClusterRequest {
    const message = createBaseDeleteAttachedClusterRequest();
    message.name = object.name ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.allowMissing = object.allowMissing ?? false;
    message.ignoreErrors = object.ignoreErrors ?? false;
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseGetAttachedServerConfigRequest(): GetAttachedServerConfigRequest {
  return { name: "" };
}

export const GetAttachedServerConfigRequest: MessageFns<GetAttachedServerConfigRequest> = {
  encode(message: GetAttachedServerConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAttachedServerConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttachedServerConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAttachedServerConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAttachedServerConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAttachedServerConfigRequest>): GetAttachedServerConfigRequest {
    return GetAttachedServerConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAttachedServerConfigRequest>): GetAttachedServerConfigRequest {
    const message = createBaseGetAttachedServerConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGenerateAttachedClusterAgentTokenRequest(): GenerateAttachedClusterAgentTokenRequest {
  return {
    attachedCluster: "",
    subjectToken: "",
    subjectTokenType: "",
    version: "",
    grantType: "",
    audience: "",
    scope: "",
    requestedTokenType: "",
    options: "",
  };
}

export const GenerateAttachedClusterAgentTokenRequest: MessageFns<GenerateAttachedClusterAgentTokenRequest> = {
  encode(message: GenerateAttachedClusterAgentTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attachedCluster !== "") {
      writer.uint32(10).string(message.attachedCluster);
    }
    if (message.subjectToken !== "") {
      writer.uint32(18).string(message.subjectToken);
    }
    if (message.subjectTokenType !== "") {
      writer.uint32(26).string(message.subjectTokenType);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    if (message.grantType !== "") {
      writer.uint32(50).string(message.grantType);
    }
    if (message.audience !== "") {
      writer.uint32(58).string(message.audience);
    }
    if (message.scope !== "") {
      writer.uint32(66).string(message.scope);
    }
    if (message.requestedTokenType !== "") {
      writer.uint32(74).string(message.requestedTokenType);
    }
    if (message.options !== "") {
      writer.uint32(82).string(message.options);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAttachedClusterAgentTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAttachedClusterAgentTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attachedCluster = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subjectToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subjectTokenType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.grantType = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.audience = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.scope = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.requestedTokenType = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.options = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAttachedClusterAgentTokenRequest {
    return {
      attachedCluster: isSet(object.attachedCluster) ? globalThis.String(object.attachedCluster) : "",
      subjectToken: isSet(object.subjectToken) ? globalThis.String(object.subjectToken) : "",
      subjectTokenType: isSet(object.subjectTokenType) ? globalThis.String(object.subjectTokenType) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      grantType: isSet(object.grantType) ? globalThis.String(object.grantType) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
      requestedTokenType: isSet(object.requestedTokenType) ? globalThis.String(object.requestedTokenType) : "",
      options: isSet(object.options) ? globalThis.String(object.options) : "",
    };
  },

  toJSON(message: GenerateAttachedClusterAgentTokenRequest): unknown {
    const obj: any = {};
    if (message.attachedCluster !== "") {
      obj.attachedCluster = message.attachedCluster;
    }
    if (message.subjectToken !== "") {
      obj.subjectToken = message.subjectToken;
    }
    if (message.subjectTokenType !== "") {
      obj.subjectTokenType = message.subjectTokenType;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.grantType !== "") {
      obj.grantType = message.grantType;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.requestedTokenType !== "") {
      obj.requestedTokenType = message.requestedTokenType;
    }
    if (message.options !== "") {
      obj.options = message.options;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateAttachedClusterAgentTokenRequest>): GenerateAttachedClusterAgentTokenRequest {
    return GenerateAttachedClusterAgentTokenRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateAttachedClusterAgentTokenRequest>): GenerateAttachedClusterAgentTokenRequest {
    const message = createBaseGenerateAttachedClusterAgentTokenRequest();
    message.attachedCluster = object.attachedCluster ?? "";
    message.subjectToken = object.subjectToken ?? "";
    message.subjectTokenType = object.subjectTokenType ?? "";
    message.version = object.version ?? "";
    message.grantType = object.grantType ?? "";
    message.audience = object.audience ?? "";
    message.scope = object.scope ?? "";
    message.requestedTokenType = object.requestedTokenType ?? "";
    message.options = object.options ?? "";
    return message;
  },
};

function createBaseGenerateAttachedClusterAgentTokenResponse(): GenerateAttachedClusterAgentTokenResponse {
  return { accessToken: "", expiresIn: 0, tokenType: "" };
}

export const GenerateAttachedClusterAgentTokenResponse: MessageFns<GenerateAttachedClusterAgentTokenResponse> = {
  encode(message: GenerateAttachedClusterAgentTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.expiresIn !== 0) {
      writer.uint32(16).int32(message.expiresIn);
    }
    if (message.tokenType !== "") {
      writer.uint32(26).string(message.tokenType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateAttachedClusterAgentTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateAttachedClusterAgentTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.expiresIn = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tokenType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateAttachedClusterAgentTokenResponse {
    return {
      accessToken: isSet(object.accessToken) ? globalThis.String(object.accessToken) : "",
      expiresIn: isSet(object.expiresIn) ? globalThis.Number(object.expiresIn) : 0,
      tokenType: isSet(object.tokenType) ? globalThis.String(object.tokenType) : "",
    };
  },

  toJSON(message: GenerateAttachedClusterAgentTokenResponse): unknown {
    const obj: any = {};
    if (message.accessToken !== "") {
      obj.accessToken = message.accessToken;
    }
    if (message.expiresIn !== 0) {
      obj.expiresIn = Math.round(message.expiresIn);
    }
    if (message.tokenType !== "") {
      obj.tokenType = message.tokenType;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateAttachedClusterAgentTokenResponse>): GenerateAttachedClusterAgentTokenResponse {
    return GenerateAttachedClusterAgentTokenResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerateAttachedClusterAgentTokenResponse>,
  ): GenerateAttachedClusterAgentTokenResponse {
    const message = createBaseGenerateAttachedClusterAgentTokenResponse();
    message.accessToken = object.accessToken ?? "";
    message.expiresIn = object.expiresIn ?? 0;
    message.tokenType = object.tokenType ?? "";
    return message;
  },
};

/**
 * The AttachedClusters API provides a single centrally managed service
 * to register and manage Anthos attached clusters that run on customer's owned
 * infrastructure.
 */
export type AttachedClustersDefinition = typeof AttachedClustersDefinition;
export const AttachedClustersDefinition = {
  name: "AttachedClusters",
  fullName: "google.cloud.gkemulticloud.v1.AttachedClusters",
  methods: {
    /**
     * Creates a new
     * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
     * on a given Google Cloud Platform project and region.
     *
     * If successful, the response contains a newly created
     * [Operation][google.longrunning.Operation] resource that can be
     * described to track the status of the operation.
     */
    createAttachedCluster: {
      name: "CreateAttachedCluster",
      requestType: CreateAttachedClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              36,
              10,
              15,
              65,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              43,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              44,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              72,
              58,
              16,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              34,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an
     * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster].
     */
    updateAttachedCluster: {
      name: "UpdateAttachedCluster",
      requestType: UpdateAttachedClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              36,
              10,
              15,
              65,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              28,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              89,
              58,
              16,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              50,
              69,
              47,
              118,
              49,
              47,
              123,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Imports creates a new
     * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
     * by importing an existing Fleet Membership resource.
     *
     * Attached Clusters created before the introduction of the Anthos Multi-Cloud
     * API can be imported through this method.
     *
     * If successful, the response contains a newly created
     * [Operation][google.longrunning.Operation] resource that can be
     * described to track the status of the operation.
     */
    importAttachedCluster: {
      name: "ImportAttachedCluster",
      requestType: ImportAttachedClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              36,
              10,
              15,
              65,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              102,
              108,
              101,
              101,
              116,
              95,
              109,
              101,
              109,
              98,
              101,
              114,
              115,
              104,
              105,
              112,
            ]),
          ],
          578365826: [
            Buffer.from([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              58,
              105,
              109,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Describes a specific
     * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource.
     */
    getAttachedCluster: {
      name: "GetAttachedCluster",
      requestType: GetAttachedClusterRequest,
      requestStream: false,
      responseType: AttachedCluster,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists all [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster]
     * resources on a given Google Cloud project and region.
     */
    listAttachedClusters: {
      name: "ListAttachedClusters",
      requestType: ListAttachedClustersRequest,
      requestStream: false,
      responseType: ListAttachedClustersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a specific
     * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource.
     *
     * If successful, the response contains a newly created
     * [Operation][google.longrunning.Operation] resource that can be
     * described to track the status of the operation.
     */
    deleteAttachedCluster: {
      name: "DeleteAttachedCluster",
      requestType: DeleteAttachedClusterRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              42,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Returns information, such as supported Kubernetes versions, on a given
     * Google Cloud location.
     */
    getAttachedServerConfig: {
      name: "GetAttachedServerConfig",
      requestType: GetAttachedServerConfigRequest,
      requestStream: false,
      responseType: AttachedServerConfig,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              83,
              101,
              114,
              118,
              101,
              114,
              67,
              111,
              110,
              102,
              105,
              103,
              125,
            ]),
          ],
        },
      },
    },
    /** Generates the install manifest to be installed on the target cluster. */
    generateAttachedClusterInstallManifest: {
      name: "GenerateAttachedClusterInstallManifest",
      requestType: GenerateAttachedClusterInstallManifestRequest,
      requestStream: false,
      responseType: GenerateAttachedClusterInstallManifestResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              76,
              18,
              74,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              65,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              73,
              110,
              115,
              116,
              97,
              108,
              108,
              77,
              97,
              110,
              105,
              102,
              101,
              115,
              116,
            ]),
          ],
        },
      },
    },
    /** Generates an access token for a cluster agent. */
    generateAttachedClusterAgentToken: {
      name: "GenerateAttachedClusterAgentToken",
      requestType: GenerateAttachedClusterAgentTokenRequest,
      requestStream: false,
      responseType: GenerateAttachedClusterAgentTokenResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              103,
              58,
              1,
              42,
              34,
              98,
              47,
              118,
              49,
              47,
              123,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              95,
              99,
              108,
              117,
              115,
              116,
              101,
              114,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              65,
              116,
              116,
              97,
              99,
              104,
              101,
              100,
              67,
              108,
              117,
              115,
              116,
              101,
              114,
              65,
              103,
              101,
              110,
              116,
              84,
              111,
              107,
              101,
              110,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AttachedClustersServiceImplementation<CallContextExt = {}> {
  /**
   * Creates a new
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * on a given Google Cloud Platform project and region.
   *
   * If successful, the response contains a newly created
   * [Operation][google.longrunning.Operation] resource that can be
   * described to track the status of the operation.
   */
  createAttachedCluster(
    request: CreateAttachedClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates an
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster].
   */
  updateAttachedCluster(
    request: UpdateAttachedClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Imports creates a new
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * by importing an existing Fleet Membership resource.
   *
   * Attached Clusters created before the introduction of the Anthos Multi-Cloud
   * API can be imported through this method.
   *
   * If successful, the response contains a newly created
   * [Operation][google.longrunning.Operation] resource that can be
   * described to track the status of the operation.
   */
  importAttachedCluster(
    request: ImportAttachedClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Describes a specific
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource.
   */
  getAttachedCluster(
    request: GetAttachedClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AttachedCluster>>;
  /**
   * Lists all [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster]
   * resources on a given Google Cloud project and region.
   */
  listAttachedClusters(
    request: ListAttachedClustersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAttachedClustersResponse>>;
  /**
   * Deletes a specific
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource.
   *
   * If successful, the response contains a newly created
   * [Operation][google.longrunning.Operation] resource that can be
   * described to track the status of the operation.
   */
  deleteAttachedCluster(
    request: DeleteAttachedClusterRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Returns information, such as supported Kubernetes versions, on a given
   * Google Cloud location.
   */
  getAttachedServerConfig(
    request: GetAttachedServerConfigRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AttachedServerConfig>>;
  /** Generates the install manifest to be installed on the target cluster. */
  generateAttachedClusterInstallManifest(
    request: GenerateAttachedClusterInstallManifestRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateAttachedClusterInstallManifestResponse>>;
  /** Generates an access token for a cluster agent. */
  generateAttachedClusterAgentToken(
    request: GenerateAttachedClusterAgentTokenRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateAttachedClusterAgentTokenResponse>>;
}

export interface AttachedClustersClient<CallOptionsExt = {}> {
  /**
   * Creates a new
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * on a given Google Cloud Platform project and region.
   *
   * If successful, the response contains a newly created
   * [Operation][google.longrunning.Operation] resource that can be
   * described to track the status of the operation.
   */
  createAttachedCluster(
    request: DeepPartial<CreateAttachedClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates an
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster].
   */
  updateAttachedCluster(
    request: DeepPartial<UpdateAttachedClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Imports creates a new
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource
   * by importing an existing Fleet Membership resource.
   *
   * Attached Clusters created before the introduction of the Anthos Multi-Cloud
   * API can be imported through this method.
   *
   * If successful, the response contains a newly created
   * [Operation][google.longrunning.Operation] resource that can be
   * described to track the status of the operation.
   */
  importAttachedCluster(
    request: DeepPartial<ImportAttachedClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Describes a specific
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource.
   */
  getAttachedCluster(
    request: DeepPartial<GetAttachedClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AttachedCluster>;
  /**
   * Lists all [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster]
   * resources on a given Google Cloud project and region.
   */
  listAttachedClusters(
    request: DeepPartial<ListAttachedClustersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAttachedClustersResponse>;
  /**
   * Deletes a specific
   * [AttachedCluster][google.cloud.gkemulticloud.v1.AttachedCluster] resource.
   *
   * If successful, the response contains a newly created
   * [Operation][google.longrunning.Operation] resource that can be
   * described to track the status of the operation.
   */
  deleteAttachedCluster(
    request: DeepPartial<DeleteAttachedClusterRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Returns information, such as supported Kubernetes versions, on a given
   * Google Cloud location.
   */
  getAttachedServerConfig(
    request: DeepPartial<GetAttachedServerConfigRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AttachedServerConfig>;
  /** Generates the install manifest to be installed on the target cluster. */
  generateAttachedClusterInstallManifest(
    request: DeepPartial<GenerateAttachedClusterInstallManifestRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateAttachedClusterInstallManifestResponse>;
  /** Generates an access token for a cluster agent. */
  generateAttachedClusterAgentToken(
    request: DeepPartial<GenerateAttachedClusterAgentTokenRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateAttachedClusterAgentTokenResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
