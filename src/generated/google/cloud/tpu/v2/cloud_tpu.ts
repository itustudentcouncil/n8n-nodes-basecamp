// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/tpu/v2/cloud_tpu.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.tpu.v2";

/** A guest attributes. */
export interface GuestAttributes {
  /**
   * The path to be queried. This can be the default namespace ('/') or a
   * nested namespace ('/\<namespace\>/') or a specified key
   * ('/\<namespace\>/\<key\>')
   */
  queryPath: string;
  /** The value of the requested queried path. */
  queryValue: GuestAttributesValue | undefined;
}

/** Array of guest attribute namespace/key/value tuples. */
export interface GuestAttributesValue {
  /** The list of guest attributes entries. */
  items: GuestAttributesEntry[];
}

/** A guest attributes namespace/key/value entry. */
export interface GuestAttributesEntry {
  /** Namespace for the guest attribute entry. */
  namespace: string;
  /** Key for the guest attribute entry. */
  key: string;
  /** Value for the guest attribute entry. */
  value: string;
}

/**
 * A node-attached disk resource.
 * Next ID: 8;
 */
export interface AttachedDisk {
  /**
   * Specifies the full path to an existing disk.
   * For example: "projects/my-project/zones/us-central1-c/disks/my-disk".
   */
  sourceDisk: string;
  /**
   * The mode in which to attach this disk.
   * If not specified, the default is READ_WRITE mode.
   * Only applicable to data_disks.
   */
  mode: AttachedDisk_DiskMode;
}

/** The different mode of the attached disk. */
export enum AttachedDisk_DiskMode {
  /** DISK_MODE_UNSPECIFIED - The disk mode is not known/set. */
  DISK_MODE_UNSPECIFIED = 0,
  /**
   * READ_WRITE - Attaches the disk in read-write mode. Only one TPU node can attach a disk
   * in read-write mode at a time.
   */
  READ_WRITE = 1,
  /**
   * READ_ONLY - Attaches the disk in read-only mode. Multiple TPU nodes can attach
   * a disk in read-only mode at a time.
   */
  READ_ONLY = 2,
  UNRECOGNIZED = -1,
}

export function attachedDisk_DiskModeFromJSON(object: any): AttachedDisk_DiskMode {
  switch (object) {
    case 0:
    case "DISK_MODE_UNSPECIFIED":
      return AttachedDisk_DiskMode.DISK_MODE_UNSPECIFIED;
    case 1:
    case "READ_WRITE":
      return AttachedDisk_DiskMode.READ_WRITE;
    case 2:
    case "READ_ONLY":
      return AttachedDisk_DiskMode.READ_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttachedDisk_DiskMode.UNRECOGNIZED;
  }
}

export function attachedDisk_DiskModeToJSON(object: AttachedDisk_DiskMode): string {
  switch (object) {
    case AttachedDisk_DiskMode.DISK_MODE_UNSPECIFIED:
      return "DISK_MODE_UNSPECIFIED";
    case AttachedDisk_DiskMode.READ_WRITE:
      return "READ_WRITE";
    case AttachedDisk_DiskMode.READ_ONLY:
      return "READ_ONLY";
    case AttachedDisk_DiskMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Sets the scheduling options for this node. */
export interface SchedulingConfig {
  /** Defines whether the node is preemptible. */
  preemptible: boolean;
  /** Whether the node is created under a reservation. */
  reserved: boolean;
}

/** A network endpoint over which a TPU worker can be reached. */
export interface NetworkEndpoint {
  /** The internal IP address of this network endpoint. */
  ipAddress: string;
  /** The port of this network endpoint. */
  port: number;
  /** The access config for the TPU worker. */
  accessConfig: AccessConfig | undefined;
}

/** An access config attached to the TPU worker. */
export interface AccessConfig {
  /** Output only. An external IP address associated with the TPU worker. */
  externalIp: string;
}

/** Network related configurations. */
export interface NetworkConfig {
  /**
   * The name of the network for the TPU node. It must be a preexisting Google
   * Compute Engine network. If none is provided, "default" will be used.
   */
  network: string;
  /**
   * The name of the subnetwork for the TPU node. It must be a preexisting
   * Google Compute Engine subnetwork. If none is provided, "default" will be
   * used.
   */
  subnetwork: string;
  /**
   * Indicates that external IP addresses would be associated with the TPU
   * workers. If set to false, the specified subnetwork or network should have
   * Private Google Access enabled.
   */
  enableExternalIps: boolean;
  /**
   * Allows the TPU node to send and receive packets with non-matching
   * destination or source IPs. This is required if you plan to use the TPU
   * workers to forward routes.
   */
  canIpForward: boolean;
}

/** A service account. */
export interface ServiceAccount {
  /**
   * Email address of the service account. If empty, default Compute service
   * account will be used.
   */
  email: string;
  /**
   * The list of scopes to be made available for this service account. If empty,
   * access to all Cloud APIs will be allowed.
   */
  scope: string[];
}

/** A TPU instance. */
export interface Node {
  /** Output only. Immutable. The name of the TPU. */
  name: string;
  /** The user-supplied description of the TPU. Maximum of 512 characters. */
  description: string;
  /** Optional. The type of hardware accelerators associated with this node. */
  acceleratorType: string;
  /** Output only. The current state for the TPU Node. */
  state: Node_State;
  /**
   * Output only. If this field is populated, it contains a description of why
   * the TPU Node is unhealthy.
   */
  healthDescription: string;
  /** Required. The runtime version running in the Node. */
  runtimeVersion: string;
  /** Network configurations for the TPU node. */
  networkConfig:
    | NetworkConfig
    | undefined;
  /**
   * The CIDR block that the TPU node will use when selecting an IP address.
   * This CIDR block must be a /29 block; the Compute Engine networks API
   * forbids a smaller block, and using a larger block would be wasteful (a
   * node can only consume one IP address). Errors will occur if the CIDR block
   * has already been used for a currently existing TPU node, the CIDR block
   * conflicts with any subnetworks in the user's provided network, or the
   * provided network is peered with another network that is using that CIDR
   * block.
   */
  cidrBlock: string;
  /**
   * The Google Cloud Platform Service Account to be used by the TPU node VMs.
   * If None is specified, the default compute service account will be used.
   */
  serviceAccount:
    | ServiceAccount
    | undefined;
  /** Output only. The time when the node was created. */
  createTime:
    | Date
    | undefined;
  /** The scheduling options for this node. */
  schedulingConfig:
    | SchedulingConfig
    | undefined;
  /**
   * Output only. The network endpoints where TPU workers can be accessed and
   * sent work. It is recommended that runtime clients of the node reach out
   * to the 0th entry in this map first.
   */
  networkEndpoints: NetworkEndpoint[];
  /** The health status of the TPU node. */
  health: Node_Health;
  /** Resource labels to represent user-provided metadata. */
  labels: { [key: string]: string };
  /**
   * Custom metadata to apply to the TPU Node.
   * Can set startup-script and shutdown-script
   */
  metadata: { [key: string]: string };
  /**
   * Tags to apply to the TPU Node. Tags are used to identify valid sources or
   * targets for network firewalls.
   */
  tags: string[];
  /** Output only. The unique identifier for the TPU Node. */
  id: Long;
  /** The additional data disks for the Node. */
  dataDisks: AttachedDisk[];
  /** Output only. The API version that created this Node. */
  apiVersion: Node_ApiVersion;
  /** Output only. The Symptoms that have occurred to the TPU Node. */
  symptoms: Symptom[];
  /** Shielded Instance options. */
  shieldedInstanceConfig:
    | ShieldedInstanceConfig
    | undefined;
  /** The AccleratorConfig for the TPU Node. */
  acceleratorConfig:
    | AcceleratorConfig
    | undefined;
  /**
   * Output only. The qualified name of the QueuedResource that requested this
   * Node.
   */
  queuedResource: string;
  /** Output only. Whether the Node belongs to a Multislice group. */
  multisliceNode: boolean;
}

/** Represents the different states of a TPU node during its lifecycle. */
export enum Node_State {
  /** STATE_UNSPECIFIED - TPU node state is not known/set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - TPU node is being created. */
  CREATING = 1,
  /** READY - TPU node has been created. */
  READY = 2,
  /** RESTARTING - TPU node is restarting. */
  RESTARTING = 3,
  /** REIMAGING - TPU node is undergoing reimaging. */
  REIMAGING = 4,
  /** DELETING - TPU node is being deleted. */
  DELETING = 5,
  /**
   * REPAIRING - TPU node is being repaired and may be unusable. Details can be
   * found in the 'help_description' field.
   */
  REPAIRING = 6,
  /** STOPPED - TPU node is stopped. */
  STOPPED = 8,
  /** STOPPING - TPU node is currently stopping. */
  STOPPING = 9,
  /** STARTING - TPU node is currently starting. */
  STARTING = 10,
  /** PREEMPTED - TPU node has been preempted. Only applies to Preemptible TPU Nodes. */
  PREEMPTED = 11,
  /**
   * TERMINATED - TPU node has been terminated due to maintenance or has reached the end of
   * its life cycle (for preemptible nodes).
   */
  TERMINATED = 12,
  /** HIDING - TPU node is currently hiding. */
  HIDING = 13,
  /** HIDDEN - TPU node has been hidden. */
  HIDDEN = 14,
  /** UNHIDING - TPU node is currently unhiding. */
  UNHIDING = 15,
  UNRECOGNIZED = -1,
}

export function node_StateFromJSON(object: any): Node_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Node_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Node_State.CREATING;
    case 2:
    case "READY":
      return Node_State.READY;
    case 3:
    case "RESTARTING":
      return Node_State.RESTARTING;
    case 4:
    case "REIMAGING":
      return Node_State.REIMAGING;
    case 5:
    case "DELETING":
      return Node_State.DELETING;
    case 6:
    case "REPAIRING":
      return Node_State.REPAIRING;
    case 8:
    case "STOPPED":
      return Node_State.STOPPED;
    case 9:
    case "STOPPING":
      return Node_State.STOPPING;
    case 10:
    case "STARTING":
      return Node_State.STARTING;
    case 11:
    case "PREEMPTED":
      return Node_State.PREEMPTED;
    case 12:
    case "TERMINATED":
      return Node_State.TERMINATED;
    case 13:
    case "HIDING":
      return Node_State.HIDING;
    case 14:
    case "HIDDEN":
      return Node_State.HIDDEN;
    case 15:
    case "UNHIDING":
      return Node_State.UNHIDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Node_State.UNRECOGNIZED;
  }
}

export function node_StateToJSON(object: Node_State): string {
  switch (object) {
    case Node_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Node_State.CREATING:
      return "CREATING";
    case Node_State.READY:
      return "READY";
    case Node_State.RESTARTING:
      return "RESTARTING";
    case Node_State.REIMAGING:
      return "REIMAGING";
    case Node_State.DELETING:
      return "DELETING";
    case Node_State.REPAIRING:
      return "REPAIRING";
    case Node_State.STOPPED:
      return "STOPPED";
    case Node_State.STOPPING:
      return "STOPPING";
    case Node_State.STARTING:
      return "STARTING";
    case Node_State.PREEMPTED:
      return "PREEMPTED";
    case Node_State.TERMINATED:
      return "TERMINATED";
    case Node_State.HIDING:
      return "HIDING";
    case Node_State.HIDDEN:
      return "HIDDEN";
    case Node_State.UNHIDING:
      return "UNHIDING";
    case Node_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Health defines the status of a TPU node as reported by
 * Health Monitor.
 */
export enum Node_Health {
  /** HEALTH_UNSPECIFIED - Health status is unknown: not initialized or failed to retrieve. */
  HEALTH_UNSPECIFIED = 0,
  /** HEALTHY - The resource is healthy. */
  HEALTHY = 1,
  /** TIMEOUT - The resource is unresponsive. */
  TIMEOUT = 3,
  /** UNHEALTHY_TENSORFLOW - The in-guest ML stack is unhealthy. */
  UNHEALTHY_TENSORFLOW = 4,
  /**
   * UNHEALTHY_MAINTENANCE - The node is under maintenance/priority boost caused rescheduling and
   * will resume running once rescheduled.
   */
  UNHEALTHY_MAINTENANCE = 5,
  UNRECOGNIZED = -1,
}

export function node_HealthFromJSON(object: any): Node_Health {
  switch (object) {
    case 0:
    case "HEALTH_UNSPECIFIED":
      return Node_Health.HEALTH_UNSPECIFIED;
    case 1:
    case "HEALTHY":
      return Node_Health.HEALTHY;
    case 3:
    case "TIMEOUT":
      return Node_Health.TIMEOUT;
    case 4:
    case "UNHEALTHY_TENSORFLOW":
      return Node_Health.UNHEALTHY_TENSORFLOW;
    case 5:
    case "UNHEALTHY_MAINTENANCE":
      return Node_Health.UNHEALTHY_MAINTENANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Node_Health.UNRECOGNIZED;
  }
}

export function node_HealthToJSON(object: Node_Health): string {
  switch (object) {
    case Node_Health.HEALTH_UNSPECIFIED:
      return "HEALTH_UNSPECIFIED";
    case Node_Health.HEALTHY:
      return "HEALTHY";
    case Node_Health.TIMEOUT:
      return "TIMEOUT";
    case Node_Health.UNHEALTHY_TENSORFLOW:
      return "UNHEALTHY_TENSORFLOW";
    case Node_Health.UNHEALTHY_MAINTENANCE:
      return "UNHEALTHY_MAINTENANCE";
    case Node_Health.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TPU API Version. */
export enum Node_ApiVersion {
  /** API_VERSION_UNSPECIFIED - API version is unknown. */
  API_VERSION_UNSPECIFIED = 0,
  /** V1_ALPHA1 - TPU API V1Alpha1 version. */
  V1_ALPHA1 = 1,
  /** V1 - TPU API V1 version. */
  V1 = 2,
  /** V2_ALPHA1 - TPU API V2Alpha1 version. */
  V2_ALPHA1 = 3,
  /** V2 - TPU API V2 version. */
  V2 = 4,
  UNRECOGNIZED = -1,
}

export function node_ApiVersionFromJSON(object: any): Node_ApiVersion {
  switch (object) {
    case 0:
    case "API_VERSION_UNSPECIFIED":
      return Node_ApiVersion.API_VERSION_UNSPECIFIED;
    case 1:
    case "V1_ALPHA1":
      return Node_ApiVersion.V1_ALPHA1;
    case 2:
    case "V1":
      return Node_ApiVersion.V1;
    case 3:
    case "V2_ALPHA1":
      return Node_ApiVersion.V2_ALPHA1;
    case 4:
    case "V2":
      return Node_ApiVersion.V2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Node_ApiVersion.UNRECOGNIZED;
  }
}

export function node_ApiVersionToJSON(object: Node_ApiVersion): string {
  switch (object) {
    case Node_ApiVersion.API_VERSION_UNSPECIFIED:
      return "API_VERSION_UNSPECIFIED";
    case Node_ApiVersion.V1_ALPHA1:
      return "V1_ALPHA1";
    case Node_ApiVersion.V1:
      return "V1";
    case Node_ApiVersion.V2_ALPHA1:
      return "V2_ALPHA1";
    case Node_ApiVersion.V2:
      return "V2";
    case Node_ApiVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Node_LabelsEntry {
  key: string;
  value: string;
}

export interface Node_MetadataEntry {
  key: string;
  value: string;
}

/** Request for [ListNodes][google.cloud.tpu.v2.Tpu.ListNodes]. */
export interface ListNodesRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
}

/** Response for [ListNodes][google.cloud.tpu.v2.Tpu.ListNodes]. */
export interface ListNodesResponse {
  /** The listed nodes. */
  nodes: Node[];
  /** The next page token or empty if none. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request for [GetNode][google.cloud.tpu.v2.Tpu.GetNode]. */
export interface GetNodeRequest {
  /** Required. The resource name. */
  name: string;
}

/** Request for [CreateNode][google.cloud.tpu.v2.Tpu.CreateNode]. */
export interface CreateNodeRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The unqualified resource name. */
  nodeId: string;
  /** Required. The node. */
  node: Node | undefined;
}

/** Request for [DeleteNode][google.cloud.tpu.v2.Tpu.DeleteNode]. */
export interface DeleteNodeRequest {
  /** Required. The resource name. */
  name: string;
}

/** Request for [StopNode][google.cloud.tpu.v2.Tpu.StopNode]. */
export interface StopNodeRequest {
  /** Required. The resource name. */
  name: string;
}

/** Request for [StartNode][google.cloud.tpu.v2.Tpu.StartNode]. */
export interface StartNodeRequest {
  /** Required. The resource name. */
  name: string;
}

/** Request for [UpdateNode][google.cloud.tpu.v2.Tpu.UpdateNode]. */
export interface UpdateNodeRequest {
  /**
   * Required. Mask of fields from [Node][Tpu.Node] to update.
   * Supported fields: [description, tags, labels, metadata,
   * network_config.enable_external_ips].
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The node. Only fields specified in update_mask are updated. */
  node: Node | undefined;
}

/** The per-product per-project service identity for Cloud TPU service. */
export interface ServiceIdentity {
  /** The email address of the service identity. */
  email: string;
}

/**
 * Request for
 * [GenerateServiceIdentity][google.cloud.tpu.v2.Tpu.GenerateServiceIdentity].
 */
export interface GenerateServiceIdentityRequest {
  /** Required. The parent resource name. */
  parent: string;
}

/**
 * Response for
 * [GenerateServiceIdentity][google.cloud.tpu.v2.Tpu.GenerateServiceIdentity].
 */
export interface GenerateServiceIdentityResponse {
  /** ServiceIdentity that was created or retrieved. */
  identity: ServiceIdentity | undefined;
}

/** A accelerator type that a Node can be configured with. */
export interface AcceleratorType {
  /** The resource name. */
  name: string;
  /** The accelerator type. */
  type: string;
  /** The accelerator config. */
  acceleratorConfigs: AcceleratorConfig[];
}

/** Request for [GetAcceleratorType][google.cloud.tpu.v2.Tpu.GetAcceleratorType]. */
export interface GetAcceleratorTypeRequest {
  /** Required. The resource name. */
  name: string;
}

/**
 * Request for
 * [ListAcceleratorTypes][google.cloud.tpu.v2.Tpu.ListAcceleratorTypes].
 */
export interface ListAcceleratorTypesRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
  /** List filter. */
  filter: string;
  /** Sort results. */
  orderBy: string;
}

/**
 * Response for
 * [ListAcceleratorTypes][google.cloud.tpu.v2.Tpu.ListAcceleratorTypes].
 */
export interface ListAcceleratorTypesResponse {
  /** The listed nodes. */
  acceleratorTypes: AcceleratorType[];
  /** The next page token or empty if none. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** A runtime version that a Node can be configured with. */
export interface RuntimeVersion {
  /** The resource name. */
  name: string;
  /** The runtime version. */
  version: string;
}

/** Request for [GetRuntimeVersion][google.cloud.tpu.v2.Tpu.GetRuntimeVersion]. */
export interface GetRuntimeVersionRequest {
  /** Required. The resource name. */
  name: string;
}

/**
 * Request for
 * [ListRuntimeVersions][google.cloud.tpu.v2.Tpu.ListRuntimeVersions].
 */
export interface ListRuntimeVersionsRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
  /** List filter. */
  filter: string;
  /** Sort results. */
  orderBy: string;
}

/**
 * Response for
 * [ListRuntimeVersions][google.cloud.tpu.v2.Tpu.ListRuntimeVersions].
 */
export interface ListRuntimeVersionsResponse {
  /** The listed nodes. */
  runtimeVersions: RuntimeVersion[];
  /** The next page token or empty if none. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Metadata describing an [Operation][google.longrunning.Operation] */
export interface OperationMetadata {
  /** The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /**
   * Target of the operation - for example
   * projects/project-1/connectivityTests/test-1
   */
  target: string;
  /** Name of the verb executed by the operation. */
  verb: string;
  /** Human-readable status of the operation, if any. */
  statusDetail: string;
  /** Specifies if cancellation was requested for the operation. */
  cancelRequested: boolean;
  /** API version. */
  apiVersion: string;
}

/** A Symptom instance. */
export interface Symptom {
  /** Timestamp when the Symptom is created. */
  createTime:
    | Date
    | undefined;
  /** Type of the Symptom. */
  symptomType: Symptom_SymptomType;
  /** Detailed information of the current Symptom. */
  details: string;
  /** A string used to uniquely distinguish a worker within a TPU node. */
  workerId: string;
}

/**
 * SymptomType represents the different types of Symptoms that a TPU can be
 * at.
 */
export enum Symptom_SymptomType {
  /** SYMPTOM_TYPE_UNSPECIFIED - Unspecified symptom. */
  SYMPTOM_TYPE_UNSPECIFIED = 0,
  /** LOW_MEMORY - TPU VM memory is low. */
  LOW_MEMORY = 1,
  /** OUT_OF_MEMORY - TPU runtime is out of memory. */
  OUT_OF_MEMORY = 2,
  /** EXECUTE_TIMED_OUT - TPU runtime execution has timed out. */
  EXECUTE_TIMED_OUT = 3,
  /**
   * MESH_BUILD_FAIL - TPU runtime fails to construct a mesh that recognizes each TPU device's
   * neighbors.
   */
  MESH_BUILD_FAIL = 4,
  /** HBM_OUT_OF_MEMORY - TPU HBM is out of memory. */
  HBM_OUT_OF_MEMORY = 5,
  /** PROJECT_ABUSE - Abusive behaviors have been identified on the current project. */
  PROJECT_ABUSE = 6,
  UNRECOGNIZED = -1,
}

export function symptom_SymptomTypeFromJSON(object: any): Symptom_SymptomType {
  switch (object) {
    case 0:
    case "SYMPTOM_TYPE_UNSPECIFIED":
      return Symptom_SymptomType.SYMPTOM_TYPE_UNSPECIFIED;
    case 1:
    case "LOW_MEMORY":
      return Symptom_SymptomType.LOW_MEMORY;
    case 2:
    case "OUT_OF_MEMORY":
      return Symptom_SymptomType.OUT_OF_MEMORY;
    case 3:
    case "EXECUTE_TIMED_OUT":
      return Symptom_SymptomType.EXECUTE_TIMED_OUT;
    case 4:
    case "MESH_BUILD_FAIL":
      return Symptom_SymptomType.MESH_BUILD_FAIL;
    case 5:
    case "HBM_OUT_OF_MEMORY":
      return Symptom_SymptomType.HBM_OUT_OF_MEMORY;
    case 6:
    case "PROJECT_ABUSE":
      return Symptom_SymptomType.PROJECT_ABUSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Symptom_SymptomType.UNRECOGNIZED;
  }
}

export function symptom_SymptomTypeToJSON(object: Symptom_SymptomType): string {
  switch (object) {
    case Symptom_SymptomType.SYMPTOM_TYPE_UNSPECIFIED:
      return "SYMPTOM_TYPE_UNSPECIFIED";
    case Symptom_SymptomType.LOW_MEMORY:
      return "LOW_MEMORY";
    case Symptom_SymptomType.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case Symptom_SymptomType.EXECUTE_TIMED_OUT:
      return "EXECUTE_TIMED_OUT";
    case Symptom_SymptomType.MESH_BUILD_FAIL:
      return "MESH_BUILD_FAIL";
    case Symptom_SymptomType.HBM_OUT_OF_MEMORY:
      return "HBM_OUT_OF_MEMORY";
    case Symptom_SymptomType.PROJECT_ABUSE:
      return "PROJECT_ABUSE";
    case Symptom_SymptomType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request for [GetGuestAttributes][google.cloud.tpu.v2.Tpu.GetGuestAttributes]. */
export interface GetGuestAttributesRequest {
  /** Required. The resource name. */
  name: string;
  /** The guest attributes path to be queried. */
  queryPath: string;
  /**
   * The 0-based worker ID. If it is empty, all workers' GuestAttributes will be
   * returned.
   */
  workerIds: string[];
}

/**
 * Response for
 * [GetGuestAttributes][google.cloud.tpu.v2.Tpu.GetGuestAttributes].
 */
export interface GetGuestAttributesResponse {
  /** The guest attributes for the TPU workers. */
  guestAttributes: GuestAttributes[];
}

/** A TPU accelerator configuration. */
export interface AcceleratorConfig {
  /** Required. Type of TPU. */
  type: AcceleratorConfig_Type;
  /** Required. Topology of TPU in chips. */
  topology: string;
}

/** TPU type. */
export enum AcceleratorConfig_Type {
  /** TYPE_UNSPECIFIED - Unspecified version. */
  TYPE_UNSPECIFIED = 0,
  /** V2 - TPU v2. */
  V2 = 2,
  /** V3 - TPU v3. */
  V3 = 4,
  /** V4 - TPU v4. */
  V4 = 7,
  UNRECOGNIZED = -1,
}

export function acceleratorConfig_TypeFromJSON(object: any): AcceleratorConfig_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return AcceleratorConfig_Type.TYPE_UNSPECIFIED;
    case 2:
    case "V2":
      return AcceleratorConfig_Type.V2;
    case 4:
    case "V3":
      return AcceleratorConfig_Type.V3;
    case 7:
    case "V4":
      return AcceleratorConfig_Type.V4;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AcceleratorConfig_Type.UNRECOGNIZED;
  }
}

export function acceleratorConfig_TypeToJSON(object: AcceleratorConfig_Type): string {
  switch (object) {
    case AcceleratorConfig_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case AcceleratorConfig_Type.V2:
      return "V2";
    case AcceleratorConfig_Type.V3:
      return "V3";
    case AcceleratorConfig_Type.V4:
      return "V4";
    case AcceleratorConfig_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A set of Shielded Instance options. */
export interface ShieldedInstanceConfig {
  /** Defines whether the instance has Secure Boot enabled. */
  enableSecureBoot: boolean;
}

function createBaseGuestAttributes(): GuestAttributes {
  return { queryPath: "", queryValue: undefined };
}

export const GuestAttributes: MessageFns<GuestAttributes> = {
  encode(message: GuestAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryPath !== "") {
      writer.uint32(10).string(message.queryPath);
    }
    if (message.queryValue !== undefined) {
      GuestAttributesValue.encode(message.queryValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryPath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queryValue = GuestAttributesValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestAttributes {
    return {
      queryPath: isSet(object.queryPath) ? globalThis.String(object.queryPath) : "",
      queryValue: isSet(object.queryValue) ? GuestAttributesValue.fromJSON(object.queryValue) : undefined,
    };
  },

  toJSON(message: GuestAttributes): unknown {
    const obj: any = {};
    if (message.queryPath !== "") {
      obj.queryPath = message.queryPath;
    }
    if (message.queryValue !== undefined) {
      obj.queryValue = GuestAttributesValue.toJSON(message.queryValue);
    }
    return obj;
  },

  create(base?: DeepPartial<GuestAttributes>): GuestAttributes {
    return GuestAttributes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestAttributes>): GuestAttributes {
    const message = createBaseGuestAttributes();
    message.queryPath = object.queryPath ?? "";
    message.queryValue = (object.queryValue !== undefined && object.queryValue !== null)
      ? GuestAttributesValue.fromPartial(object.queryValue)
      : undefined;
    return message;
  },
};

function createBaseGuestAttributesValue(): GuestAttributesValue {
  return { items: [] };
}

export const GuestAttributesValue: MessageFns<GuestAttributesValue> = {
  encode(message: GuestAttributesValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      GuestAttributesEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestAttributesValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestAttributesValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(GuestAttributesEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestAttributesValue {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => GuestAttributesEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GuestAttributesValue): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => GuestAttributesEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GuestAttributesValue>): GuestAttributesValue {
    return GuestAttributesValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestAttributesValue>): GuestAttributesValue {
    const message = createBaseGuestAttributesValue();
    message.items = object.items?.map((e) => GuestAttributesEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGuestAttributesEntry(): GuestAttributesEntry {
  return { namespace: "", key: "", value: "" };
}

export const GuestAttributesEntry: MessageFns<GuestAttributesEntry> = {
  encode(message: GuestAttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestAttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestAttributesEntry {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GuestAttributesEntry): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GuestAttributesEntry>): GuestAttributesEntry {
    return GuestAttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestAttributesEntry>): GuestAttributesEntry {
    const message = createBaseGuestAttributesEntry();
    message.namespace = object.namespace ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAttachedDisk(): AttachedDisk {
  return { sourceDisk: "", mode: 0 };
}

export const AttachedDisk: MessageFns<AttachedDisk> = {
  encode(message: AttachedDisk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceDisk !== "") {
      writer.uint32(26).string(message.sourceDisk);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttachedDisk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachedDisk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceDisk = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttachedDisk {
    return {
      sourceDisk: isSet(object.sourceDisk) ? globalThis.String(object.sourceDisk) : "",
      mode: isSet(object.mode) ? attachedDisk_DiskModeFromJSON(object.mode) : 0,
    };
  },

  toJSON(message: AttachedDisk): unknown {
    const obj: any = {};
    if (message.sourceDisk !== "") {
      obj.sourceDisk = message.sourceDisk;
    }
    if (message.mode !== 0) {
      obj.mode = attachedDisk_DiskModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<AttachedDisk>): AttachedDisk {
    return AttachedDisk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttachedDisk>): AttachedDisk {
    const message = createBaseAttachedDisk();
    message.sourceDisk = object.sourceDisk ?? "";
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseSchedulingConfig(): SchedulingConfig {
  return { preemptible: false, reserved: false };
}

export const SchedulingConfig: MessageFns<SchedulingConfig> = {
  encode(message: SchedulingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preemptible !== false) {
      writer.uint32(8).bool(message.preemptible);
    }
    if (message.reserved !== false) {
      writer.uint32(16).bool(message.reserved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchedulingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedulingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.preemptible = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reserved = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchedulingConfig {
    return {
      preemptible: isSet(object.preemptible) ? globalThis.Boolean(object.preemptible) : false,
      reserved: isSet(object.reserved) ? globalThis.Boolean(object.reserved) : false,
    };
  },

  toJSON(message: SchedulingConfig): unknown {
    const obj: any = {};
    if (message.preemptible !== false) {
      obj.preemptible = message.preemptible;
    }
    if (message.reserved !== false) {
      obj.reserved = message.reserved;
    }
    return obj;
  },

  create(base?: DeepPartial<SchedulingConfig>): SchedulingConfig {
    return SchedulingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchedulingConfig>): SchedulingConfig {
    const message = createBaseSchedulingConfig();
    message.preemptible = object.preemptible ?? false;
    message.reserved = object.reserved ?? false;
    return message;
  },
};

function createBaseNetworkEndpoint(): NetworkEndpoint {
  return { ipAddress: "", port: 0, accessConfig: undefined };
}

export const NetworkEndpoint: MessageFns<NetworkEndpoint> = {
  encode(message: NetworkEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== "") {
      writer.uint32(10).string(message.ipAddress);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message.accessConfig !== undefined) {
      AccessConfig.encode(message.accessConfig, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.accessConfig = AccessConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkEndpoint {
    return {
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      accessConfig: isSet(object.accessConfig) ? AccessConfig.fromJSON(object.accessConfig) : undefined,
    };
  },

  toJSON(message: NetworkEndpoint): unknown {
    const obj: any = {};
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.accessConfig !== undefined) {
      obj.accessConfig = AccessConfig.toJSON(message.accessConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkEndpoint>): NetworkEndpoint {
    return NetworkEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkEndpoint>): NetworkEndpoint {
    const message = createBaseNetworkEndpoint();
    message.ipAddress = object.ipAddress ?? "";
    message.port = object.port ?? 0;
    message.accessConfig = (object.accessConfig !== undefined && object.accessConfig !== null)
      ? AccessConfig.fromPartial(object.accessConfig)
      : undefined;
    return message;
  },
};

function createBaseAccessConfig(): AccessConfig {
  return { externalIp: "" };
}

export const AccessConfig: MessageFns<AccessConfig> = {
  encode(message: AccessConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.externalIp !== "") {
      writer.uint32(10).string(message.externalIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalIp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessConfig {
    return { externalIp: isSet(object.externalIp) ? globalThis.String(object.externalIp) : "" };
  },

  toJSON(message: AccessConfig): unknown {
    const obj: any = {};
    if (message.externalIp !== "") {
      obj.externalIp = message.externalIp;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessConfig>): AccessConfig {
    return AccessConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessConfig>): AccessConfig {
    const message = createBaseAccessConfig();
    message.externalIp = object.externalIp ?? "";
    return message;
  },
};

function createBaseNetworkConfig(): NetworkConfig {
  return { network: "", subnetwork: "", enableExternalIps: false, canIpForward: false };
}

export const NetworkConfig: MessageFns<NetworkConfig> = {
  encode(message: NetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.subnetwork !== "") {
      writer.uint32(18).string(message.subnetwork);
    }
    if (message.enableExternalIps !== false) {
      writer.uint32(24).bool(message.enableExternalIps);
    }
    if (message.canIpForward !== false) {
      writer.uint32(32).bool(message.canIpForward);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableExternalIps = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.canIpForward = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConfig {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      enableExternalIps: isSet(object.enableExternalIps) ? globalThis.Boolean(object.enableExternalIps) : false,
      canIpForward: isSet(object.canIpForward) ? globalThis.Boolean(object.canIpForward) : false,
    };
  },

  toJSON(message: NetworkConfig): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.enableExternalIps !== false) {
      obj.enableExternalIps = message.enableExternalIps;
    }
    if (message.canIpForward !== false) {
      obj.canIpForward = message.canIpForward;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkConfig>): NetworkConfig {
    return NetworkConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkConfig>): NetworkConfig {
    const message = createBaseNetworkConfig();
    message.network = object.network ?? "";
    message.subnetwork = object.subnetwork ?? "";
    message.enableExternalIps = object.enableExternalIps ?? false;
    message.canIpForward = object.canIpForward ?? false;
    return message;
  },
};

function createBaseServiceAccount(): ServiceAccount {
  return { email: "", scope: [] };
}

export const ServiceAccount: MessageFns<ServiceAccount> = {
  encode(message: ServiceAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    for (const v of message.scope) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scope.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccount {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      scope: globalThis.Array.isArray(object?.scope) ? object.scope.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ServiceAccount): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.scope?.length) {
      obj.scope = message.scope;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceAccount>): ServiceAccount {
    return ServiceAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceAccount>): ServiceAccount {
    const message = createBaseServiceAccount();
    message.email = object.email ?? "";
    message.scope = object.scope?.map((e) => e) || [];
    return message;
  },
};

function createBaseNode(): Node {
  return {
    name: "",
    description: "",
    acceleratorType: "",
    state: 0,
    healthDescription: "",
    runtimeVersion: "",
    networkConfig: undefined,
    cidrBlock: "",
    serviceAccount: undefined,
    createTime: undefined,
    schedulingConfig: undefined,
    networkEndpoints: [],
    health: 0,
    labels: {},
    metadata: {},
    tags: [],
    id: Long.ZERO,
    dataDisks: [],
    apiVersion: 0,
    symptoms: [],
    shieldedInstanceConfig: undefined,
    acceleratorConfig: undefined,
    queuedResource: "",
    multisliceNode: false,
  };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.acceleratorType !== "") {
      writer.uint32(42).string(message.acceleratorType);
    }
    if (message.state !== 0) {
      writer.uint32(72).int32(message.state);
    }
    if (message.healthDescription !== "") {
      writer.uint32(82).string(message.healthDescription);
    }
    if (message.runtimeVersion !== "") {
      writer.uint32(90).string(message.runtimeVersion);
    }
    if (message.networkConfig !== undefined) {
      NetworkConfig.encode(message.networkConfig, writer.uint32(290).fork()).join();
    }
    if (message.cidrBlock !== "") {
      writer.uint32(106).string(message.cidrBlock);
    }
    if (message.serviceAccount !== undefined) {
      ServiceAccount.encode(message.serviceAccount, writer.uint32(298).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(130).fork()).join();
    }
    if (message.schedulingConfig !== undefined) {
      SchedulingConfig.encode(message.schedulingConfig, writer.uint32(138).fork()).join();
    }
    for (const v of message.networkEndpoints) {
      NetworkEndpoint.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.health !== 0) {
      writer.uint32(176).int32(message.health);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Node_LabelsEntry.encode({ key: key as any, value }, writer.uint32(194).fork()).join();
    });
    Object.entries(message.metadata).forEach(([key, value]) => {
      Node_MetadataEntry.encode({ key: key as any, value }, writer.uint32(274).fork()).join();
    });
    for (const v of message.tags) {
      writer.uint32(322).string(v!);
    }
    if (!message.id.equals(Long.ZERO)) {
      writer.uint32(264).int64(message.id.toString());
    }
    for (const v of message.dataDisks) {
      AttachedDisk.encode(v!, writer.uint32(330).fork()).join();
    }
    if (message.apiVersion !== 0) {
      writer.uint32(304).int32(message.apiVersion);
    }
    for (const v of message.symptoms) {
      Symptom.encode(v!, writer.uint32(314).fork()).join();
    }
    if (message.shieldedInstanceConfig !== undefined) {
      ShieldedInstanceConfig.encode(message.shieldedInstanceConfig, writer.uint32(362).fork()).join();
    }
    if (message.acceleratorConfig !== undefined) {
      AcceleratorConfig.encode(message.acceleratorConfig, writer.uint32(370).fork()).join();
    }
    if (message.queuedResource !== "") {
      writer.uint32(378).string(message.queuedResource);
    }
    if (message.multisliceNode !== false) {
      writer.uint32(384).bool(message.multisliceNode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.acceleratorType = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.healthDescription = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.runtimeVersion = reader.string();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.networkConfig = NetworkConfig.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.cidrBlock = reader.string();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.serviceAccount = ServiceAccount.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.schedulingConfig = SchedulingConfig.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.networkEndpoints.push(NetworkEndpoint.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.health = reader.int32() as any;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          const entry24 = Node_LabelsEntry.decode(reader, reader.uint32());
          if (entry24.value !== undefined) {
            message.labels[entry24.key] = entry24.value;
          }
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          const entry34 = Node_MetadataEntry.decode(reader, reader.uint32());
          if (entry34.value !== undefined) {
            message.metadata[entry34.key] = entry34.value;
          }
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.dataDisks.push(AttachedDisk.decode(reader, reader.uint32()));
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.apiVersion = reader.int32() as any;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.symptoms.push(Symptom.decode(reader, reader.uint32()));
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }

          message.shieldedInstanceConfig = ShieldedInstanceConfig.decode(reader, reader.uint32());
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.acceleratorConfig = AcceleratorConfig.decode(reader, reader.uint32());
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.queuedResource = reader.string();
          continue;
        case 48:
          if (tag !== 384) {
            break;
          }

          message.multisliceNode = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      acceleratorType: isSet(object.acceleratorType) ? globalThis.String(object.acceleratorType) : "",
      state: isSet(object.state) ? node_StateFromJSON(object.state) : 0,
      healthDescription: isSet(object.healthDescription) ? globalThis.String(object.healthDescription) : "",
      runtimeVersion: isSet(object.runtimeVersion) ? globalThis.String(object.runtimeVersion) : "",
      networkConfig: isSet(object.networkConfig) ? NetworkConfig.fromJSON(object.networkConfig) : undefined,
      cidrBlock: isSet(object.cidrBlock) ? globalThis.String(object.cidrBlock) : "",
      serviceAccount: isSet(object.serviceAccount) ? ServiceAccount.fromJSON(object.serviceAccount) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      schedulingConfig: isSet(object.schedulingConfig) ? SchedulingConfig.fromJSON(object.schedulingConfig) : undefined,
      networkEndpoints: globalThis.Array.isArray(object?.networkEndpoints)
        ? object.networkEndpoints.map((e: any) => NetworkEndpoint.fromJSON(e))
        : [],
      health: isSet(object.health) ? node_HealthFromJSON(object.health) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.ZERO,
      dataDisks: globalThis.Array.isArray(object?.dataDisks)
        ? object.dataDisks.map((e: any) => AttachedDisk.fromJSON(e))
        : [],
      apiVersion: isSet(object.apiVersion) ? node_ApiVersionFromJSON(object.apiVersion) : 0,
      symptoms: globalThis.Array.isArray(object?.symptoms)
        ? object.symptoms.map((e: any) => Symptom.fromJSON(e))
        : [],
      shieldedInstanceConfig: isSet(object.shieldedInstanceConfig)
        ? ShieldedInstanceConfig.fromJSON(object.shieldedInstanceConfig)
        : undefined,
      acceleratorConfig: isSet(object.acceleratorConfig)
        ? AcceleratorConfig.fromJSON(object.acceleratorConfig)
        : undefined,
      queuedResource: isSet(object.queuedResource) ? globalThis.String(object.queuedResource) : "",
      multisliceNode: isSet(object.multisliceNode) ? globalThis.Boolean(object.multisliceNode) : false,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.acceleratorType !== "") {
      obj.acceleratorType = message.acceleratorType;
    }
    if (message.state !== 0) {
      obj.state = node_StateToJSON(message.state);
    }
    if (message.healthDescription !== "") {
      obj.healthDescription = message.healthDescription;
    }
    if (message.runtimeVersion !== "") {
      obj.runtimeVersion = message.runtimeVersion;
    }
    if (message.networkConfig !== undefined) {
      obj.networkConfig = NetworkConfig.toJSON(message.networkConfig);
    }
    if (message.cidrBlock !== "") {
      obj.cidrBlock = message.cidrBlock;
    }
    if (message.serviceAccount !== undefined) {
      obj.serviceAccount = ServiceAccount.toJSON(message.serviceAccount);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.schedulingConfig !== undefined) {
      obj.schedulingConfig = SchedulingConfig.toJSON(message.schedulingConfig);
    }
    if (message.networkEndpoints?.length) {
      obj.networkEndpoints = message.networkEndpoints.map((e) => NetworkEndpoint.toJSON(e));
    }
    if (message.health !== 0) {
      obj.health = node_HealthToJSON(message.health);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (!message.id.equals(Long.ZERO)) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.dataDisks?.length) {
      obj.dataDisks = message.dataDisks.map((e) => AttachedDisk.toJSON(e));
    }
    if (message.apiVersion !== 0) {
      obj.apiVersion = node_ApiVersionToJSON(message.apiVersion);
    }
    if (message.symptoms?.length) {
      obj.symptoms = message.symptoms.map((e) => Symptom.toJSON(e));
    }
    if (message.shieldedInstanceConfig !== undefined) {
      obj.shieldedInstanceConfig = ShieldedInstanceConfig.toJSON(message.shieldedInstanceConfig);
    }
    if (message.acceleratorConfig !== undefined) {
      obj.acceleratorConfig = AcceleratorConfig.toJSON(message.acceleratorConfig);
    }
    if (message.queuedResource !== "") {
      obj.queuedResource = message.queuedResource;
    }
    if (message.multisliceNode !== false) {
      obj.multisliceNode = message.multisliceNode;
    }
    return obj;
  },

  create(base?: DeepPartial<Node>): Node {
    return Node.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node>): Node {
    const message = createBaseNode();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.acceleratorType = object.acceleratorType ?? "";
    message.state = object.state ?? 0;
    message.healthDescription = object.healthDescription ?? "";
    message.runtimeVersion = object.runtimeVersion ?? "";
    message.networkConfig = (object.networkConfig !== undefined && object.networkConfig !== null)
      ? NetworkConfig.fromPartial(object.networkConfig)
      : undefined;
    message.cidrBlock = object.cidrBlock ?? "";
    message.serviceAccount = (object.serviceAccount !== undefined && object.serviceAccount !== null)
      ? ServiceAccount.fromPartial(object.serviceAccount)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.schedulingConfig = (object.schedulingConfig !== undefined && object.schedulingConfig !== null)
      ? SchedulingConfig.fromPartial(object.schedulingConfig)
      : undefined;
    message.networkEndpoints = object.networkEndpoints?.map((e) => NetworkEndpoint.fromPartial(e)) || [];
    message.health = object.health ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.tags = object.tags?.map((e) => e) || [];
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.ZERO;
    message.dataDisks = object.dataDisks?.map((e) => AttachedDisk.fromPartial(e)) || [];
    message.apiVersion = object.apiVersion ?? 0;
    message.symptoms = object.symptoms?.map((e) => Symptom.fromPartial(e)) || [];
    message.shieldedInstanceConfig =
      (object.shieldedInstanceConfig !== undefined && object.shieldedInstanceConfig !== null)
        ? ShieldedInstanceConfig.fromPartial(object.shieldedInstanceConfig)
        : undefined;
    message.acceleratorConfig = (object.acceleratorConfig !== undefined && object.acceleratorConfig !== null)
      ? AcceleratorConfig.fromPartial(object.acceleratorConfig)
      : undefined;
    message.queuedResource = object.queuedResource ?? "";
    message.multisliceNode = object.multisliceNode ?? false;
    return message;
  },
};

function createBaseNode_LabelsEntry(): Node_LabelsEntry {
  return { key: "", value: "" };
}

export const Node_LabelsEntry: MessageFns<Node_LabelsEntry> = {
  encode(message: Node_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Node_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Node_LabelsEntry>): Node_LabelsEntry {
    return Node_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node_LabelsEntry>): Node_LabelsEntry {
    const message = createBaseNode_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNode_MetadataEntry(): Node_MetadataEntry {
  return { key: "", value: "" };
}

export const Node_MetadataEntry: MessageFns<Node_MetadataEntry> = {
  encode(message: Node_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Node_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Node_MetadataEntry>): Node_MetadataEntry {
    return Node_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node_MetadataEntry>): Node_MetadataEntry {
    const message = createBaseNode_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListNodesRequest(): ListNodesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListNodesRequest: MessageFns<ListNodesRequest> = {
  encode(message: ListNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListNodesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodesRequest>): ListNodesRequest {
    return ListNodesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodesRequest>): ListNodesRequest {
    const message = createBaseListNodesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListNodesResponse(): ListNodesResponse {
  return { nodes: [], nextPageToken: "", unreachable: [] };
}

export const ListNodesResponse: MessageFns<ListNodesResponse> = {
  encode(message: ListNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodesResponse {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListNodesResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodesResponse>): ListNodesResponse {
    return ListNodesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodesResponse>): ListNodesResponse {
    const message = createBaseListNodesResponse();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetNodeRequest(): GetNodeRequest {
  return { name: "" };
}

export const GetNodeRequest: MessageFns<GetNodeRequest> = {
  encode(message: GetNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNodeRequest>): GetNodeRequest {
    return GetNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNodeRequest>): GetNodeRequest {
    const message = createBaseGetNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateNodeRequest(): CreateNodeRequest {
  return { parent: "", nodeId: "", node: undefined };
}

export const CreateNodeRequest: MessageFns<CreateNodeRequest> = {
  encode(message: CreateNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.nodeId !== "") {
      writer.uint32(18).string(message.nodeId);
    }
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNodeRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
    };
  },

  toJSON(message: CreateNodeRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNodeRequest>): CreateNodeRequest {
    return CreateNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNodeRequest>): CreateNodeRequest {
    const message = createBaseCreateNodeRequest();
    message.parent = object.parent ?? "";
    message.nodeId = object.nodeId ?? "";
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    return message;
  },
};

function createBaseDeleteNodeRequest(): DeleteNodeRequest {
  return { name: "" };
}

export const DeleteNodeRequest: MessageFns<DeleteNodeRequest> = {
  encode(message: DeleteNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteNodeRequest>): DeleteNodeRequest {
    return DeleteNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteNodeRequest>): DeleteNodeRequest {
    const message = createBaseDeleteNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStopNodeRequest(): StopNodeRequest {
  return { name: "" };
}

export const StopNodeRequest: MessageFns<StopNodeRequest> = {
  encode(message: StopNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: StopNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<StopNodeRequest>): StopNodeRequest {
    return StopNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopNodeRequest>): StopNodeRequest {
    const message = createBaseStopNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStartNodeRequest(): StartNodeRequest {
  return { name: "" };
}

export const StartNodeRequest: MessageFns<StartNodeRequest> = {
  encode(message: StartNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: StartNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<StartNodeRequest>): StartNodeRequest {
    return StartNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartNodeRequest>): StartNodeRequest {
    const message = createBaseStartNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateNodeRequest(): UpdateNodeRequest {
  return { updateMask: undefined, node: undefined };
}

export const UpdateNodeRequest: MessageFns<UpdateNodeRequest> = {
  encode(message: UpdateNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNodeRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
    };
  },

  toJSON(message: UpdateNodeRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateNodeRequest>): UpdateNodeRequest {
    return UpdateNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateNodeRequest>): UpdateNodeRequest {
    const message = createBaseUpdateNodeRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    return message;
  },
};

function createBaseServiceIdentity(): ServiceIdentity {
  return { email: "" };
}

export const ServiceIdentity: MessageFns<ServiceIdentity> = {
  encode(message: ServiceIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceIdentity {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ServiceIdentity): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceIdentity>): ServiceIdentity {
    return ServiceIdentity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceIdentity>): ServiceIdentity {
    const message = createBaseServiceIdentity();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseGenerateServiceIdentityRequest(): GenerateServiceIdentityRequest {
  return { parent: "" };
}

export const GenerateServiceIdentityRequest: MessageFns<GenerateServiceIdentityRequest> = {
  encode(message: GenerateServiceIdentityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateServiceIdentityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateServiceIdentityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateServiceIdentityRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: GenerateServiceIdentityRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateServiceIdentityRequest>): GenerateServiceIdentityRequest {
    return GenerateServiceIdentityRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateServiceIdentityRequest>): GenerateServiceIdentityRequest {
    const message = createBaseGenerateServiceIdentityRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseGenerateServiceIdentityResponse(): GenerateServiceIdentityResponse {
  return { identity: undefined };
}

export const GenerateServiceIdentityResponse: MessageFns<GenerateServiceIdentityResponse> = {
  encode(message: GenerateServiceIdentityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identity !== undefined) {
      ServiceIdentity.encode(message.identity, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateServiceIdentityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateServiceIdentityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.identity = ServiceIdentity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateServiceIdentityResponse {
    return { identity: isSet(object.identity) ? ServiceIdentity.fromJSON(object.identity) : undefined };
  },

  toJSON(message: GenerateServiceIdentityResponse): unknown {
    const obj: any = {};
    if (message.identity !== undefined) {
      obj.identity = ServiceIdentity.toJSON(message.identity);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateServiceIdentityResponse>): GenerateServiceIdentityResponse {
    return GenerateServiceIdentityResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateServiceIdentityResponse>): GenerateServiceIdentityResponse {
    const message = createBaseGenerateServiceIdentityResponse();
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? ServiceIdentity.fromPartial(object.identity)
      : undefined;
    return message;
  },
};

function createBaseAcceleratorType(): AcceleratorType {
  return { name: "", type: "", acceleratorConfigs: [] };
}

export const AcceleratorType: MessageFns<AcceleratorType> = {
  encode(message: AcceleratorType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    for (const v of message.acceleratorConfigs) {
      AcceleratorConfig.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceleratorType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceleratorType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.acceleratorConfigs.push(AcceleratorConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceleratorType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      acceleratorConfigs: globalThis.Array.isArray(object?.acceleratorConfigs)
        ? object.acceleratorConfigs.map((e: any) => AcceleratorConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AcceleratorType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.acceleratorConfigs?.length) {
      obj.acceleratorConfigs = message.acceleratorConfigs.map((e) => AcceleratorConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AcceleratorType>): AcceleratorType {
    return AcceleratorType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcceleratorType>): AcceleratorType {
    const message = createBaseAcceleratorType();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.acceleratorConfigs = object.acceleratorConfigs?.map((e) => AcceleratorConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAcceleratorTypeRequest(): GetAcceleratorTypeRequest {
  return { name: "" };
}

export const GetAcceleratorTypeRequest: MessageFns<GetAcceleratorTypeRequest> = {
  encode(message: GetAcceleratorTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAcceleratorTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAcceleratorTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAcceleratorTypeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAcceleratorTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAcceleratorTypeRequest>): GetAcceleratorTypeRequest {
    return GetAcceleratorTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAcceleratorTypeRequest>): GetAcceleratorTypeRequest {
    const message = createBaseGetAcceleratorTypeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListAcceleratorTypesRequest(): ListAcceleratorTypesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListAcceleratorTypesRequest: MessageFns<ListAcceleratorTypesRequest> = {
  encode(message: ListAcceleratorTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(50).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAcceleratorTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAcceleratorTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAcceleratorTypesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListAcceleratorTypesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAcceleratorTypesRequest>): ListAcceleratorTypesRequest {
    return ListAcceleratorTypesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAcceleratorTypesRequest>): ListAcceleratorTypesRequest {
    const message = createBaseListAcceleratorTypesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListAcceleratorTypesResponse(): ListAcceleratorTypesResponse {
  return { acceleratorTypes: [], nextPageToken: "", unreachable: [] };
}

export const ListAcceleratorTypesResponse: MessageFns<ListAcceleratorTypesResponse> = {
  encode(message: ListAcceleratorTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.acceleratorTypes) {
      AcceleratorType.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAcceleratorTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAcceleratorTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.acceleratorTypes.push(AcceleratorType.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAcceleratorTypesResponse {
    return {
      acceleratorTypes: globalThis.Array.isArray(object?.acceleratorTypes)
        ? object.acceleratorTypes.map((e: any) => AcceleratorType.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListAcceleratorTypesResponse): unknown {
    const obj: any = {};
    if (message.acceleratorTypes?.length) {
      obj.acceleratorTypes = message.acceleratorTypes.map((e) => AcceleratorType.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAcceleratorTypesResponse>): ListAcceleratorTypesResponse {
    return ListAcceleratorTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAcceleratorTypesResponse>): ListAcceleratorTypesResponse {
    const message = createBaseListAcceleratorTypesResponse();
    message.acceleratorTypes = object.acceleratorTypes?.map((e) => AcceleratorType.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseRuntimeVersion(): RuntimeVersion {
  return { name: "", version: "" };
}

export const RuntimeVersion: MessageFns<RuntimeVersion> = {
  encode(message: RuntimeVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeVersion {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: RuntimeVersion): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeVersion>): RuntimeVersion {
    return RuntimeVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeVersion>): RuntimeVersion {
    const message = createBaseRuntimeVersion();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseGetRuntimeVersionRequest(): GetRuntimeVersionRequest {
  return { name: "" };
}

export const GetRuntimeVersionRequest: MessageFns<GetRuntimeVersionRequest> = {
  encode(message: GetRuntimeVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRuntimeVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRuntimeVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRuntimeVersionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRuntimeVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRuntimeVersionRequest>): GetRuntimeVersionRequest {
    return GetRuntimeVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRuntimeVersionRequest>): GetRuntimeVersionRequest {
    const message = createBaseGetRuntimeVersionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListRuntimeVersionsRequest(): ListRuntimeVersionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListRuntimeVersionsRequest: MessageFns<ListRuntimeVersionsRequest> = {
  encode(message: ListRuntimeVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(50).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuntimeVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuntimeVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuntimeVersionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListRuntimeVersionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuntimeVersionsRequest>): ListRuntimeVersionsRequest {
    return ListRuntimeVersionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuntimeVersionsRequest>): ListRuntimeVersionsRequest {
    const message = createBaseListRuntimeVersionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListRuntimeVersionsResponse(): ListRuntimeVersionsResponse {
  return { runtimeVersions: [], nextPageToken: "", unreachable: [] };
}

export const ListRuntimeVersionsResponse: MessageFns<ListRuntimeVersionsResponse> = {
  encode(message: ListRuntimeVersionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runtimeVersions) {
      RuntimeVersion.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuntimeVersionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuntimeVersionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.runtimeVersions.push(RuntimeVersion.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuntimeVersionsResponse {
    return {
      runtimeVersions: globalThis.Array.isArray(object?.runtimeVersions)
        ? object.runtimeVersions.map((e: any) => RuntimeVersion.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListRuntimeVersionsResponse): unknown {
    const obj: any = {};
    if (message.runtimeVersions?.length) {
      obj.runtimeVersions = message.runtimeVersions.map((e) => RuntimeVersion.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuntimeVersionsResponse>): ListRuntimeVersionsResponse {
    return ListRuntimeVersionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuntimeVersionsResponse>): ListRuntimeVersionsResponse {
    const message = createBaseListRuntimeVersionsResponse();
    message.runtimeVersions = object.runtimeVersions?.map((e) => RuntimeVersion.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusDetail: "",
    cancelRequested: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusDetail !== "") {
      writer.uint32(42).string(message.statusDetail);
    }
    if (message.cancelRequested !== false) {
      writer.uint32(48).bool(message.cancelRequested);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusDetail = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cancelRequested = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusDetail: isSet(object.statusDetail) ? globalThis.String(object.statusDetail) : "",
      cancelRequested: isSet(object.cancelRequested) ? globalThis.Boolean(object.cancelRequested) : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusDetail !== "") {
      obj.statusDetail = message.statusDetail;
    }
    if (message.cancelRequested !== false) {
      obj.cancelRequested = message.cancelRequested;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusDetail = object.statusDetail ?? "";
    message.cancelRequested = object.cancelRequested ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseSymptom(): Symptom {
  return { createTime: undefined, symptomType: 0, details: "", workerId: "" };
}

export const Symptom: MessageFns<Symptom> = {
  encode(message: Symptom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.symptomType !== 0) {
      writer.uint32(16).int32(message.symptomType);
    }
    if (message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    if (message.workerId !== "") {
      writer.uint32(34).string(message.workerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Symptom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSymptom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.symptomType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workerId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Symptom {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      symptomType: isSet(object.symptomType) ? symptom_SymptomTypeFromJSON(object.symptomType) : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
    };
  },

  toJSON(message: Symptom): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.symptomType !== 0) {
      obj.symptomType = symptom_SymptomTypeToJSON(message.symptomType);
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    return obj;
  },

  create(base?: DeepPartial<Symptom>): Symptom {
    return Symptom.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Symptom>): Symptom {
    const message = createBaseSymptom();
    message.createTime = object.createTime ?? undefined;
    message.symptomType = object.symptomType ?? 0;
    message.details = object.details ?? "";
    message.workerId = object.workerId ?? "";
    return message;
  },
};

function createBaseGetGuestAttributesRequest(): GetGuestAttributesRequest {
  return { name: "", queryPath: "", workerIds: [] };
}

export const GetGuestAttributesRequest: MessageFns<GetGuestAttributesRequest> = {
  encode(message: GetGuestAttributesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.queryPath !== "") {
      writer.uint32(18).string(message.queryPath);
    }
    for (const v of message.workerIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGuestAttributesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGuestAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queryPath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.workerIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGuestAttributesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      queryPath: isSet(object.queryPath) ? globalThis.String(object.queryPath) : "",
      workerIds: globalThis.Array.isArray(object?.workerIds)
        ? object.workerIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetGuestAttributesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.queryPath !== "") {
      obj.queryPath = message.queryPath;
    }
    if (message.workerIds?.length) {
      obj.workerIds = message.workerIds;
    }
    return obj;
  },

  create(base?: DeepPartial<GetGuestAttributesRequest>): GetGuestAttributesRequest {
    return GetGuestAttributesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetGuestAttributesRequest>): GetGuestAttributesRequest {
    const message = createBaseGetGuestAttributesRequest();
    message.name = object.name ?? "";
    message.queryPath = object.queryPath ?? "";
    message.workerIds = object.workerIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetGuestAttributesResponse(): GetGuestAttributesResponse {
  return { guestAttributes: [] };
}

export const GetGuestAttributesResponse: MessageFns<GetGuestAttributesResponse> = {
  encode(message: GetGuestAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.guestAttributes) {
      GuestAttributes.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGuestAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGuestAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.guestAttributes.push(GuestAttributes.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGuestAttributesResponse {
    return {
      guestAttributes: globalThis.Array.isArray(object?.guestAttributes)
        ? object.guestAttributes.map((e: any) => GuestAttributes.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetGuestAttributesResponse): unknown {
    const obj: any = {};
    if (message.guestAttributes?.length) {
      obj.guestAttributes = message.guestAttributes.map((e) => GuestAttributes.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetGuestAttributesResponse>): GetGuestAttributesResponse {
    return GetGuestAttributesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetGuestAttributesResponse>): GetGuestAttributesResponse {
    const message = createBaseGetGuestAttributesResponse();
    message.guestAttributes = object.guestAttributes?.map((e) => GuestAttributes.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAcceleratorConfig(): AcceleratorConfig {
  return { type: 0, topology: "" };
}

export const AcceleratorConfig: MessageFns<AcceleratorConfig> = {
  encode(message: AcceleratorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.topology !== "") {
      writer.uint32(18).string(message.topology);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceleratorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceleratorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topology = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceleratorConfig {
    return {
      type: isSet(object.type) ? acceleratorConfig_TypeFromJSON(object.type) : 0,
      topology: isSet(object.topology) ? globalThis.String(object.topology) : "",
    };
  },

  toJSON(message: AcceleratorConfig): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = acceleratorConfig_TypeToJSON(message.type);
    }
    if (message.topology !== "") {
      obj.topology = message.topology;
    }
    return obj;
  },

  create(base?: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    return AcceleratorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    const message = createBaseAcceleratorConfig();
    message.type = object.type ?? 0;
    message.topology = object.topology ?? "";
    return message;
  },
};

function createBaseShieldedInstanceConfig(): ShieldedInstanceConfig {
  return { enableSecureBoot: false };
}

export const ShieldedInstanceConfig: MessageFns<ShieldedInstanceConfig> = {
  encode(message: ShieldedInstanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableSecureBoot !== false) {
      writer.uint32(8).bool(message.enableSecureBoot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShieldedInstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShieldedInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableSecureBoot = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShieldedInstanceConfig {
    return { enableSecureBoot: isSet(object.enableSecureBoot) ? globalThis.Boolean(object.enableSecureBoot) : false };
  },

  toJSON(message: ShieldedInstanceConfig): unknown {
    const obj: any = {};
    if (message.enableSecureBoot !== false) {
      obj.enableSecureBoot = message.enableSecureBoot;
    }
    return obj;
  },

  create(base?: DeepPartial<ShieldedInstanceConfig>): ShieldedInstanceConfig {
    return ShieldedInstanceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShieldedInstanceConfig>): ShieldedInstanceConfig {
    const message = createBaseShieldedInstanceConfig();
    message.enableSecureBoot = object.enableSecureBoot ?? false;
    return message;
  },
};

/**
 * Manages TPU nodes and other resources
 *
 * TPU API v2
 */
export type TpuDefinition = typeof TpuDefinition;
export const TpuDefinition = {
  name: "Tpu",
  fullName: "google.cloud.tpu.v2.Tpu",
  methods: {
    /** Lists nodes. */
    listNodes: {
      name: "ListNodes",
      requestType: ListNodesRequest,
      requestStream: false,
      responseType: ListNodesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a node. */
    getNode: {
      name: "GetNode",
      requestType: GetNodeRequest,
      requestStream: false,
      responseType: Node,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              43,
              18,
              41,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a node. */
    createNode: {
      name: "CreateNode",
      requestType: CreateNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              19,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              110,
              111,
              100,
              101,
              44,
              110,
              111,
              100,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              49,
              58,
              4,
              110,
              111,
              100,
              101,
              34,
              41,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a node. */
    deleteNode: {
      name: "DeleteNode",
      requestType: DeleteNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              43,
              42,
              41,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Stops a node. This operation is only available with single TPU nodes. */
    stopNode: {
      name: "StopNode",
      requestType: StopNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              51,
              58,
              1,
              42,
              34,
              46,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              111,
              112,
            ]),
          ],
        },
      },
    },
    /** Starts a node. */
    startNode: {
      name: "StartNode",
      requestType: StartNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              97,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /** Updates the configurations of a node. */
    updateNode: {
      name: "UpdateNode",
      requestType: UpdateNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([16, 110, 111, 100, 101, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              54,
              58,
              4,
              110,
              111,
              100,
              101,
              50,
              46,
              47,
              118,
              50,
              47,
              123,
              110,
              111,
              100,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Generates the Cloud TPU service identity for the project. */
    generateServiceIdentity: {
      name: "GenerateServiceIdentity",
      requestType: GenerateServiceIdentityRequest,
      requestStream: false,
      responseType: GenerateServiceIdentityResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              83,
              101,
              114,
              118,
              105,
              99,
              101,
              73,
              100,
              101,
              110,
              116,
              105,
              116,
              121,
            ]),
          ],
        },
      },
    },
    /** Lists accelerator types supported by this API. */
    listAcceleratorTypes: {
      name: "ListAcceleratorTypes",
      requestType: ListAcceleratorTypesRequest,
      requestStream: false,
      responseType: ListAcceleratorTypesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              99,
              99,
              101,
              108,
              101,
              114,
              97,
              116,
              111,
              114,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets AcceleratorType. */
    getAcceleratorType: {
      name: "GetAcceleratorType",
      requestType: GetAcceleratorTypeRequest,
      requestStream: false,
      responseType: AcceleratorType,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              54,
              18,
              52,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              108,
              101,
              114,
              97,
              116,
              111,
              114,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists runtime versions supported by this API. */
    listRuntimeVersions: {
      name: "ListRuntimeVersions",
      requestType: ListRuntimeVersionsRequest,
      requestStream: false,
      responseType: ListRuntimeVersionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              117,
              110,
              116,
              105,
              109,
              101,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a runtime version. */
    getRuntimeVersion: {
      name: "GetRuntimeVersion",
      requestType: GetRuntimeVersionRequest,
      requestStream: false,
      responseType: RuntimeVersion,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              53,
              18,
              51,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              117,
              110,
              116,
              105,
              109,
              101,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Retrieves the guest attributes for the node. */
    getGuestAttributes: {
      name: "GetGuestAttributes",
      requestType: GetGuestAttributesRequest,
      requestStream: false,
      responseType: GetGuestAttributesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              65,
              58,
              1,
              42,
              34,
              60,
              47,
              118,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              71,
              117,
              101,
              115,
              116,
              65,
              116,
              116,
              114,
              105,
              98,
              117,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TpuServiceImplementation<CallContextExt = {}> {
  /** Lists nodes. */
  listNodes(request: ListNodesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListNodesResponse>>;
  /** Gets the details of a node. */
  getNode(request: GetNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Node>>;
  /** Creates a node. */
  createNode(request: CreateNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a node. */
  deleteNode(request: DeleteNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Stops a node. This operation is only available with single TPU nodes. */
  stopNode(request: StopNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Starts a node. */
  startNode(request: StartNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the configurations of a node. */
  updateNode(request: UpdateNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Generates the Cloud TPU service identity for the project. */
  generateServiceIdentity(
    request: GenerateServiceIdentityRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateServiceIdentityResponse>>;
  /** Lists accelerator types supported by this API. */
  listAcceleratorTypes(
    request: ListAcceleratorTypesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAcceleratorTypesResponse>>;
  /** Gets AcceleratorType. */
  getAcceleratorType(
    request: GetAcceleratorTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AcceleratorType>>;
  /** Lists runtime versions supported by this API. */
  listRuntimeVersions(
    request: ListRuntimeVersionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRuntimeVersionsResponse>>;
  /** Gets a runtime version. */
  getRuntimeVersion(
    request: GetRuntimeVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RuntimeVersion>>;
  /** Retrieves the guest attributes for the node. */
  getGuestAttributes(
    request: GetGuestAttributesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetGuestAttributesResponse>>;
}

export interface TpuClient<CallOptionsExt = {}> {
  /** Lists nodes. */
  listNodes(request: DeepPartial<ListNodesRequest>, options?: CallOptions & CallOptionsExt): Promise<ListNodesResponse>;
  /** Gets the details of a node. */
  getNode(request: DeepPartial<GetNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Node>;
  /** Creates a node. */
  createNode(request: DeepPartial<CreateNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a node. */
  deleteNode(request: DeepPartial<DeleteNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Stops a node. This operation is only available with single TPU nodes. */
  stopNode(request: DeepPartial<StopNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Starts a node. */
  startNode(request: DeepPartial<StartNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the configurations of a node. */
  updateNode(request: DeepPartial<UpdateNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Generates the Cloud TPU service identity for the project. */
  generateServiceIdentity(
    request: DeepPartial<GenerateServiceIdentityRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateServiceIdentityResponse>;
  /** Lists accelerator types supported by this API. */
  listAcceleratorTypes(
    request: DeepPartial<ListAcceleratorTypesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAcceleratorTypesResponse>;
  /** Gets AcceleratorType. */
  getAcceleratorType(
    request: DeepPartial<GetAcceleratorTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AcceleratorType>;
  /** Lists runtime versions supported by this API. */
  listRuntimeVersions(
    request: DeepPartial<ListRuntimeVersionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRuntimeVersionsResponse>;
  /** Gets a runtime version. */
  getRuntimeVersion(
    request: DeepPartial<GetRuntimeVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RuntimeVersion>;
  /** Retrieves the guest attributes for the node. */
  getGuestAttributes(
    request: DeepPartial<GetGuestAttributesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetGuestAttributesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
