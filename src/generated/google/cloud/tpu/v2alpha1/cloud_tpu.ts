// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/tpu/v2alpha1/cloud_tpu.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { Interval } from "../../../type/interval.js";

export const protobufPackage = "google.cloud.tpu.v2alpha1";

/** A guest attributes. */
export interface GuestAttributes {
  /**
   * The path to be queried. This can be the default namespace ('/') or a
   * nested namespace ('/\<namespace\>/') or a specified key
   * ('/\<namespace\>/\<key\>')
   */
  queryPath: string;
  /** The value of the requested queried path. */
  queryValue: GuestAttributesValue | undefined;
}

/** Array of guest attribute namespace/key/value tuples. */
export interface GuestAttributesValue {
  /** The list of guest attributes entries. */
  items: GuestAttributesEntry[];
}

/** A guest attributes namespace/key/value entry. */
export interface GuestAttributesEntry {
  /** Namespace for the guest attribute entry. */
  namespace: string;
  /** Key for the guest attribute entry. */
  key: string;
  /** Value for the guest attribute entry. */
  value: string;
}

/**
 * A node-attached disk resource.
 * Next ID: 8;
 */
export interface AttachedDisk {
  /**
   * Specifies the full path to an existing disk.
   * For example: "projects/my-project/zones/us-central1-c/disks/my-disk".
   */
  sourceDisk: string;
  /**
   * The mode in which to attach this disk.
   * If not specified, the default is READ_WRITE mode.
   * Only applicable to data_disks.
   */
  mode: AttachedDisk_DiskMode;
}

/** The different mode of the attached disk. */
export enum AttachedDisk_DiskMode {
  /** DISK_MODE_UNSPECIFIED - The disk mode is not known/set. */
  DISK_MODE_UNSPECIFIED = 0,
  /**
   * READ_WRITE - Attaches the disk in read-write mode. Only one TPU node can attach a disk
   * in read-write mode at a time.
   */
  READ_WRITE = 1,
  /**
   * READ_ONLY - Attaches the disk in read-only mode. Multiple TPU nodes can attach
   * a disk in read-only mode at a time.
   */
  READ_ONLY = 2,
  UNRECOGNIZED = -1,
}

export function attachedDisk_DiskModeFromJSON(object: any): AttachedDisk_DiskMode {
  switch (object) {
    case 0:
    case "DISK_MODE_UNSPECIFIED":
      return AttachedDisk_DiskMode.DISK_MODE_UNSPECIFIED;
    case 1:
    case "READ_WRITE":
      return AttachedDisk_DiskMode.READ_WRITE;
    case 2:
    case "READ_ONLY":
      return AttachedDisk_DiskMode.READ_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttachedDisk_DiskMode.UNRECOGNIZED;
  }
}

export function attachedDisk_DiskModeToJSON(object: AttachedDisk_DiskMode): string {
  switch (object) {
    case AttachedDisk_DiskMode.DISK_MODE_UNSPECIFIED:
      return "DISK_MODE_UNSPECIFIED";
    case AttachedDisk_DiskMode.READ_WRITE:
      return "READ_WRITE";
    case AttachedDisk_DiskMode.READ_ONLY:
      return "READ_ONLY";
    case AttachedDisk_DiskMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Sets the scheduling options for this node. */
export interface SchedulingConfig {
  /** Defines whether the node is preemptible. */
  preemptible: boolean;
  /** Whether the node is created under a reservation. */
  reserved: boolean;
}

/** A network endpoint over which a TPU worker can be reached. */
export interface NetworkEndpoint {
  /** The internal IP address of this network endpoint. */
  ipAddress: string;
  /** The port of this network endpoint. */
  port: number;
  /** The access config for the TPU worker. */
  accessConfig: AccessConfig | undefined;
}

/** An access config attached to the TPU worker. */
export interface AccessConfig {
  /** Output only. An external IP address associated with the TPU worker. */
  externalIp: string;
}

/** Network related configurations. */
export interface NetworkConfig {
  /**
   * The name of the network for the TPU node. It must be a preexisting Google
   * Compute Engine network. If none is provided, "default" will be used.
   */
  network: string;
  /**
   * The name of the subnetwork for the TPU node. It must be a preexisting
   * Google Compute Engine subnetwork. If none is provided, "default" will be
   * used.
   */
  subnetwork: string;
  /**
   * Indicates that external IP addresses would be associated with the TPU
   * workers. If set to false, the specified subnetwork or network should have
   * Private Google Access enabled.
   */
  enableExternalIps: boolean;
  /**
   * Allows the TPU node to send and receive packets with non-matching
   * destination or source IPs. This is required if you plan to use the TPU
   * workers to forward routes.
   */
  canIpForward: boolean;
}

/** A service account. */
export interface ServiceAccount {
  /**
   * Email address of the service account. If empty, default Compute service
   * account will be used.
   */
  email: string;
  /**
   * The list of scopes to be made available for this service account. If empty,
   * access to all Cloud APIs will be allowed.
   */
  scope: string[];
}

/** A TPU instance. */
export interface Node {
  /** Output only. Immutable. The name of the TPU. */
  name: string;
  /** The user-supplied description of the TPU. Maximum of 512 characters. */
  description: string;
  /** The type of hardware accelerators associated with this node. */
  acceleratorType: string;
  /** Output only. The current state for the TPU Node. */
  state: Node_State;
  /**
   * Output only. If this field is populated, it contains a description of why
   * the TPU Node is unhealthy.
   */
  healthDescription: string;
  /** Required. The runtime version running in the Node. */
  runtimeVersion: string;
  /** Network configurations for the TPU node. */
  networkConfig:
    | NetworkConfig
    | undefined;
  /**
   * The CIDR block that the TPU node will use when selecting an IP address.
   * This CIDR block must be a /29 block; the Compute Engine networks API
   * forbids a smaller block, and using a larger block would be wasteful (a
   * node can only consume one IP address). Errors will occur if the CIDR block
   * has already been used for a currently existing TPU node, the CIDR block
   * conflicts with any subnetworks in the user's provided network, or the
   * provided network is peered with another network that is using that CIDR
   * block.
   */
  cidrBlock: string;
  /**
   * The Google Cloud Platform Service Account to be used by the TPU node VMs.
   * If None is specified, the default compute service account will be used.
   */
  serviceAccount:
    | ServiceAccount
    | undefined;
  /** Output only. The time when the node was created. */
  createTime:
    | Date
    | undefined;
  /** The scheduling options for this node. */
  schedulingConfig:
    | SchedulingConfig
    | undefined;
  /**
   * Output only. The network endpoints where TPU workers can be accessed and
   * sent work. It is recommended that runtime clients of the node reach out
   * to the 0th entry in this map first.
   */
  networkEndpoints: NetworkEndpoint[];
  /** The health status of the TPU node. */
  health: Node_Health;
  /** Resource labels to represent user-provided metadata. */
  labels: { [key: string]: string };
  /**
   * Custom metadata to apply to the TPU Node.
   * Can set startup-script and shutdown-script
   */
  metadata: { [key: string]: string };
  /**
   * Tags to apply to the TPU Node. Tags are used to identify valid sources or
   * targets for network firewalls.
   */
  tags: string[];
  /** Output only. The unique identifier for the TPU Node. */
  id: Long;
  /** The additional data disks for the Node. */
  dataDisks: AttachedDisk[];
  /** Output only. The API version that created this Node. */
  apiVersion: Node_ApiVersion;
  /** Output only. The Symptoms that have occurred to the TPU Node. */
  symptoms: Symptom[];
  /**
   * Output only. The qualified name of the QueuedResource that requested this
   * Node.
   */
  queuedResource: string;
  /** The AccleratorConfig for the TPU Node. */
  acceleratorConfig:
    | AcceleratorConfig
    | undefined;
  /** Shielded Instance options. */
  shieldedInstanceConfig:
    | ShieldedInstanceConfig
    | undefined;
  /** Output only. Whether the Node belongs to a Multislice group. */
  multisliceNode: boolean;
  /** Optional. Boot disk configuration. */
  bootDiskConfig: BootDiskConfig | undefined;
}

/** Represents the different states of a TPU node during its lifecycle. */
export enum Node_State {
  /** STATE_UNSPECIFIED - TPU node state is not known/set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - TPU node is being created. */
  CREATING = 1,
  /** READY - TPU node has been created. */
  READY = 2,
  /** RESTARTING - TPU node is restarting. */
  RESTARTING = 3,
  /** REIMAGING - TPU node is undergoing reimaging. */
  REIMAGING = 4,
  /** DELETING - TPU node is being deleted. */
  DELETING = 5,
  /**
   * REPAIRING - TPU node is being repaired and may be unusable. Details can be
   * found in the 'help_description' field.
   */
  REPAIRING = 6,
  /** STOPPED - TPU node is stopped. */
  STOPPED = 8,
  /** STOPPING - TPU node is currently stopping. */
  STOPPING = 9,
  /** STARTING - TPU node is currently starting. */
  STARTING = 10,
  /** PREEMPTED - TPU node has been preempted. Only applies to Preemptible TPU Nodes. */
  PREEMPTED = 11,
  /**
   * TERMINATED - TPU node has been terminated due to maintenance or has reached the end of
   * its life cycle (for preemptible nodes).
   */
  TERMINATED = 12,
  /** HIDING - TPU node is currently hiding. */
  HIDING = 13,
  /** HIDDEN - TPU node has been hidden. */
  HIDDEN = 14,
  /** UNHIDING - TPU node is currently unhiding. */
  UNHIDING = 15,
  UNRECOGNIZED = -1,
}

export function node_StateFromJSON(object: any): Node_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Node_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Node_State.CREATING;
    case 2:
    case "READY":
      return Node_State.READY;
    case 3:
    case "RESTARTING":
      return Node_State.RESTARTING;
    case 4:
    case "REIMAGING":
      return Node_State.REIMAGING;
    case 5:
    case "DELETING":
      return Node_State.DELETING;
    case 6:
    case "REPAIRING":
      return Node_State.REPAIRING;
    case 8:
    case "STOPPED":
      return Node_State.STOPPED;
    case 9:
    case "STOPPING":
      return Node_State.STOPPING;
    case 10:
    case "STARTING":
      return Node_State.STARTING;
    case 11:
    case "PREEMPTED":
      return Node_State.PREEMPTED;
    case 12:
    case "TERMINATED":
      return Node_State.TERMINATED;
    case 13:
    case "HIDING":
      return Node_State.HIDING;
    case 14:
    case "HIDDEN":
      return Node_State.HIDDEN;
    case 15:
    case "UNHIDING":
      return Node_State.UNHIDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Node_State.UNRECOGNIZED;
  }
}

export function node_StateToJSON(object: Node_State): string {
  switch (object) {
    case Node_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Node_State.CREATING:
      return "CREATING";
    case Node_State.READY:
      return "READY";
    case Node_State.RESTARTING:
      return "RESTARTING";
    case Node_State.REIMAGING:
      return "REIMAGING";
    case Node_State.DELETING:
      return "DELETING";
    case Node_State.REPAIRING:
      return "REPAIRING";
    case Node_State.STOPPED:
      return "STOPPED";
    case Node_State.STOPPING:
      return "STOPPING";
    case Node_State.STARTING:
      return "STARTING";
    case Node_State.PREEMPTED:
      return "PREEMPTED";
    case Node_State.TERMINATED:
      return "TERMINATED";
    case Node_State.HIDING:
      return "HIDING";
    case Node_State.HIDDEN:
      return "HIDDEN";
    case Node_State.UNHIDING:
      return "UNHIDING";
    case Node_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Health defines the status of a TPU node as reported by
 * Health Monitor.
 */
export enum Node_Health {
  /** HEALTH_UNSPECIFIED - Health status is unknown: not initialized or failed to retrieve. */
  HEALTH_UNSPECIFIED = 0,
  /** HEALTHY - The resource is healthy. */
  HEALTHY = 1,
  /** TIMEOUT - The resource is unresponsive. */
  TIMEOUT = 3,
  /** UNHEALTHY_TENSORFLOW - The in-guest ML stack is unhealthy. */
  UNHEALTHY_TENSORFLOW = 4,
  /**
   * UNHEALTHY_MAINTENANCE - The node is under maintenance/priority boost caused rescheduling and
   * will resume running once rescheduled.
   */
  UNHEALTHY_MAINTENANCE = 5,
  UNRECOGNIZED = -1,
}

export function node_HealthFromJSON(object: any): Node_Health {
  switch (object) {
    case 0:
    case "HEALTH_UNSPECIFIED":
      return Node_Health.HEALTH_UNSPECIFIED;
    case 1:
    case "HEALTHY":
      return Node_Health.HEALTHY;
    case 3:
    case "TIMEOUT":
      return Node_Health.TIMEOUT;
    case 4:
    case "UNHEALTHY_TENSORFLOW":
      return Node_Health.UNHEALTHY_TENSORFLOW;
    case 5:
    case "UNHEALTHY_MAINTENANCE":
      return Node_Health.UNHEALTHY_MAINTENANCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Node_Health.UNRECOGNIZED;
  }
}

export function node_HealthToJSON(object: Node_Health): string {
  switch (object) {
    case Node_Health.HEALTH_UNSPECIFIED:
      return "HEALTH_UNSPECIFIED";
    case Node_Health.HEALTHY:
      return "HEALTHY";
    case Node_Health.TIMEOUT:
      return "TIMEOUT";
    case Node_Health.UNHEALTHY_TENSORFLOW:
      return "UNHEALTHY_TENSORFLOW";
    case Node_Health.UNHEALTHY_MAINTENANCE:
      return "UNHEALTHY_MAINTENANCE";
    case Node_Health.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** TPU API Version. */
export enum Node_ApiVersion {
  /** API_VERSION_UNSPECIFIED - API version is unknown. */
  API_VERSION_UNSPECIFIED = 0,
  /** V1_ALPHA1 - TPU API V1Alpha1 version. */
  V1_ALPHA1 = 1,
  /** V1 - TPU API V1 version. */
  V1 = 2,
  /** V2_ALPHA1 - TPU API V2Alpha1 version. */
  V2_ALPHA1 = 3,
  UNRECOGNIZED = -1,
}

export function node_ApiVersionFromJSON(object: any): Node_ApiVersion {
  switch (object) {
    case 0:
    case "API_VERSION_UNSPECIFIED":
      return Node_ApiVersion.API_VERSION_UNSPECIFIED;
    case 1:
    case "V1_ALPHA1":
      return Node_ApiVersion.V1_ALPHA1;
    case 2:
    case "V1":
      return Node_ApiVersion.V1;
    case 3:
    case "V2_ALPHA1":
      return Node_ApiVersion.V2_ALPHA1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Node_ApiVersion.UNRECOGNIZED;
  }
}

export function node_ApiVersionToJSON(object: Node_ApiVersion): string {
  switch (object) {
    case Node_ApiVersion.API_VERSION_UNSPECIFIED:
      return "API_VERSION_UNSPECIFIED";
    case Node_ApiVersion.V1_ALPHA1:
      return "V1_ALPHA1";
    case Node_ApiVersion.V1:
      return "V1";
    case Node_ApiVersion.V2_ALPHA1:
      return "V2_ALPHA1";
    case Node_ApiVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Node_LabelsEntry {
  key: string;
  value: string;
}

export interface Node_MetadataEntry {
  key: string;
  value: string;
}

/**
 * A QueuedResource represents a request for resources that will be placed
 * in a queue and fulfilled when the necessary resources are available.
 */
export interface QueuedResource {
  /** Output only. Immutable. The name of the QueuedResource. */
  name: string;
  /** Defines a TPU resource. */
  tpu?:
    | QueuedResource_Tpu
    | undefined;
  /** The BestEffort tier. */
  bestEffort?:
    | QueuedResource_BestEffort
    | undefined;
  /** The Guaranteed tier. */
  guaranteed?:
    | QueuedResource_Guaranteed
    | undefined;
  /** Optional. The Spot tier. */
  spot?:
    | QueuedResource_Spot
    | undefined;
  /** The queueing policy of the QueuedRequest. */
  queueingPolicy:
    | QueuedResource_QueueingPolicy
    | undefined;
  /** Output only. State of the QueuedResource request. */
  state:
    | QueuedResourceState
    | undefined;
  /**
   * Name of the reservation in which the resource should be provisioned.
   * Format: projects/{project}/locations/{zone}/reservations/{reservation}
   */
  reservationName: string;
}

/** Details of the TPU resource(s) being requested. */
export interface QueuedResource_Tpu {
  /** The TPU node(s) being requested. */
  nodeSpec: QueuedResource_Tpu_NodeSpec[];
}

/**
 * Details of the TPU node(s) being requested. Users can request either a
 * single node or multiple nodes.
 * NodeSpec provides the specification for node(s) to be created.
 */
export interface QueuedResource_Tpu_NodeSpec {
  /** Required. The parent resource name. */
  parent: string;
  /**
   * The unqualified resource name. Should follow the `^[A-Za-z0-9_.~+%-]+$`
   * regex format. This is only specified when requesting a single node.
   * In case of multi-node requests, multi_node_params must be populated
   * instead. It's an error to specify both node_id and multi_node_params.
   */
  nodeId: string;
  /** Optional. Fields to specify in case of multi-node request. */
  multiNodeParams:
    | QueuedResource_Tpu_NodeSpec_MultiNodeParams
    | undefined;
  /** Required. The node. */
  node: Node | undefined;
}

/**
 * Parameters to specify for multi-node QueuedResource requests. This
 * field must be populated in case of multi-node requests instead of
 * node_id. It's an error to specify both node_id and multi_node_params.
 */
export interface QueuedResource_Tpu_NodeSpec_MultiNodeParams {
  /**
   * Required. Number of nodes with this spec. The system will attempt
   * to provison "node_count" nodes as part of the request.
   * This needs to be > 1.
   */
  nodeCount: number;
  /**
   * Prefix of node_ids in case of multi-node request
   * Should follow the `^[A-Za-z0-9_.~+%-]+$` regex format.
   * If node_count = 3 and node_id_prefix = "np", node ids of nodes
   * created will be "np-0", "np-1", "np-2". If this field is not
   * provided we use queued_resource_id as the node_id_prefix.
   */
  nodeIdPrefix: string;
}

/** BestEffort tier definition. */
export interface QueuedResource_BestEffort {
}

/** Spot tier definition. */
export interface QueuedResource_Spot {
}

/** Guaranteed tier definition. */
export interface QueuedResource_Guaranteed {
  /**
   * Optional. Defines the minimum duration of the guarantee. If specified,
   * the requested resources will only be provisioned if they can be
   * allocated for at least the given duration.
   */
  minDuration:
    | Duration
    | undefined;
  /** Optional. Specifies the request should be scheduled on reserved capacity. */
  reserved: boolean;
}

/** Defines the policy of the QueuedRequest. */
export interface QueuedResource_QueueingPolicy {
  /**
   * A relative time after which resources should not be created.
   * If the request cannot be fulfilled by this time the request will be
   * failed.
   */
  validUntilDuration?:
    | Duration
    | undefined;
  /**
   * An absolute time after which resources should not be created.
   * If the request cannot be fulfilled by this time the request will be
   * failed.
   */
  validUntilTime?:
    | Date
    | undefined;
  /** A relative time after which resources may be created. */
  validAfterDuration?:
    | Duration
    | undefined;
  /** An absolute time at which resources may be created. */
  validAfterTime?:
    | Date
    | undefined;
  /** An absolute time interval within which resources may be created. */
  validInterval?: Interval | undefined;
}

/** QueuedResourceState defines the details of the QueuedResource request. */
export interface QueuedResourceState {
  /** State of the QueuedResource request. */
  state: QueuedResourceState_State;
  /** Further data for the creating state. */
  creatingData?:
    | QueuedResourceState_CreatingData
    | undefined;
  /** Further data for the accepted state. */
  acceptedData?:
    | QueuedResourceState_AcceptedData
    | undefined;
  /** Further data for the provisioning state. */
  provisioningData?:
    | QueuedResourceState_ProvisioningData
    | undefined;
  /** Further data for the failed state. */
  failedData?:
    | QueuedResourceState_FailedData
    | undefined;
  /** Further data for the deleting state. */
  deletingData?:
    | QueuedResourceState_DeletingData
    | undefined;
  /** Further data for the active state. */
  activeData?:
    | QueuedResourceState_ActiveData
    | undefined;
  /** Further data for the suspending state. */
  suspendingData?:
    | QueuedResourceState_SuspendingData
    | undefined;
  /** Further data for the suspended state. */
  suspendedData?:
    | QueuedResourceState_SuspendedData
    | undefined;
  /** Output only. The initiator of the QueuedResources's current state. */
  stateInitiator: QueuedResourceState_StateInitiator;
}

/** Output only state of the request */
export enum QueuedResourceState_State {
  /** STATE_UNSPECIFIED - State of the QueuedResource request is not known/set. */
  STATE_UNSPECIFIED = 0,
  /**
   * CREATING - The QueuedResource request has been received. We're still working on
   * determining if we will be able to honor this request.
   */
  CREATING = 1,
  /**
   * ACCEPTED - The QueuedResource request has passed initial validation/admission
   * control and has been persisted in the queue.
   */
  ACCEPTED = 2,
  /**
   * PROVISIONING - The QueuedResource request has been selected. The
   * associated resources are currently being provisioned (or very soon
   * will begin provisioning).
   */
  PROVISIONING = 3,
  /**
   * FAILED - The request could not be completed. This may be due to some
   * late-discovered problem with the request itself, or due to
   * unavailability of resources within the constraints of the request
   * (e.g., the 'valid until' start timing constraint expired).
   */
  FAILED = 4,
  /** DELETING - The QueuedResource is being deleted. */
  DELETING = 5,
  /**
   * ACTIVE - The resources specified in the QueuedResource request have been
   * provisioned and are ready for use by the end-user/consumer.
   */
  ACTIVE = 6,
  /**
   * SUSPENDING - The resources specified in the QueuedResource request are being
   * deleted. This may have been initiated by the user, or
   * the Cloud TPU service. Inspect the state data for more details.
   */
  SUSPENDING = 7,
  /**
   * SUSPENDED - The resources specified in the QueuedResource request have been
   * deleted.
   */
  SUSPENDED = 8,
  /**
   * WAITING_FOR_RESOURCES - The QueuedResource request has passed initial validation and has been
   * persisted in the queue. It will remain in this state until there are
   * sufficient free resources to begin provisioning your request. Wait times
   * will vary significantly depending on demand levels. When demand is high,
   * not all requests can be immediately provisioned. If you
   * need more reliable obtainability of TPUs consider purchasing a
   * reservation. To put a limit on how long you are willing to wait, use
   * [timing
   * constraints](https://cloud.google.com/tpu/docs/queued-resources#request_a_queued_resource_before_a_specified_time).
   */
  WAITING_FOR_RESOURCES = 9,
  UNRECOGNIZED = -1,
}

export function queuedResourceState_StateFromJSON(object: any): QueuedResourceState_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return QueuedResourceState_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return QueuedResourceState_State.CREATING;
    case 2:
    case "ACCEPTED":
      return QueuedResourceState_State.ACCEPTED;
    case 3:
    case "PROVISIONING":
      return QueuedResourceState_State.PROVISIONING;
    case 4:
    case "FAILED":
      return QueuedResourceState_State.FAILED;
    case 5:
    case "DELETING":
      return QueuedResourceState_State.DELETING;
    case 6:
    case "ACTIVE":
      return QueuedResourceState_State.ACTIVE;
    case 7:
    case "SUSPENDING":
      return QueuedResourceState_State.SUSPENDING;
    case 8:
    case "SUSPENDED":
      return QueuedResourceState_State.SUSPENDED;
    case 9:
    case "WAITING_FOR_RESOURCES":
      return QueuedResourceState_State.WAITING_FOR_RESOURCES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QueuedResourceState_State.UNRECOGNIZED;
  }
}

export function queuedResourceState_StateToJSON(object: QueuedResourceState_State): string {
  switch (object) {
    case QueuedResourceState_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case QueuedResourceState_State.CREATING:
      return "CREATING";
    case QueuedResourceState_State.ACCEPTED:
      return "ACCEPTED";
    case QueuedResourceState_State.PROVISIONING:
      return "PROVISIONING";
    case QueuedResourceState_State.FAILED:
      return "FAILED";
    case QueuedResourceState_State.DELETING:
      return "DELETING";
    case QueuedResourceState_State.ACTIVE:
      return "ACTIVE";
    case QueuedResourceState_State.SUSPENDING:
      return "SUSPENDING";
    case QueuedResourceState_State.SUSPENDED:
      return "SUSPENDED";
    case QueuedResourceState_State.WAITING_FOR_RESOURCES:
      return "WAITING_FOR_RESOURCES";
    case QueuedResourceState_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The initiator of the QueuedResource's SUSPENDING/SUSPENDED state. */
export enum QueuedResourceState_StateInitiator {
  /** STATE_INITIATOR_UNSPECIFIED - The state initiator is unspecified. */
  STATE_INITIATOR_UNSPECIFIED = 0,
  /** USER - The current QueuedResource state was initiated by the user. */
  USER = 1,
  /** SERVICE - The current QueuedResource state was initiated by the service. */
  SERVICE = 2,
  UNRECOGNIZED = -1,
}

export function queuedResourceState_StateInitiatorFromJSON(object: any): QueuedResourceState_StateInitiator {
  switch (object) {
    case 0:
    case "STATE_INITIATOR_UNSPECIFIED":
      return QueuedResourceState_StateInitiator.STATE_INITIATOR_UNSPECIFIED;
    case 1:
    case "USER":
      return QueuedResourceState_StateInitiator.USER;
    case 2:
    case "SERVICE":
      return QueuedResourceState_StateInitiator.SERVICE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QueuedResourceState_StateInitiator.UNRECOGNIZED;
  }
}

export function queuedResourceState_StateInitiatorToJSON(object: QueuedResourceState_StateInitiator): string {
  switch (object) {
    case QueuedResourceState_StateInitiator.STATE_INITIATOR_UNSPECIFIED:
      return "STATE_INITIATOR_UNSPECIFIED";
    case QueuedResourceState_StateInitiator.USER:
      return "USER";
    case QueuedResourceState_StateInitiator.SERVICE:
      return "SERVICE";
    case QueuedResourceState_StateInitiator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Further data for the creating state. */
export interface QueuedResourceState_CreatingData {
}

/** Further data for the accepted state. */
export interface QueuedResourceState_AcceptedData {
}

/** Further data for the provisioning state. */
export interface QueuedResourceState_ProvisioningData {
}

/** Further data for the failed state. */
export interface QueuedResourceState_FailedData {
  /** The error that caused the queued resource to enter the FAILED state. */
  error: Status | undefined;
}

/** Further data for the deleting state. */
export interface QueuedResourceState_DeletingData {
}

/** Further data for the active state. */
export interface QueuedResourceState_ActiveData {
}

/** Further data for the suspending state. */
export interface QueuedResourceState_SuspendingData {
}

/** Further data for the suspended state. */
export interface QueuedResourceState_SuspendedData {
}

/** Request for [ListNodes][google.cloud.tpu.v2alpha1.Tpu.ListNodes]. */
export interface ListNodesRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
}

/** Response for [ListNodes][google.cloud.tpu.v2alpha1.Tpu.ListNodes]. */
export interface ListNodesResponse {
  /** The listed nodes. */
  nodes: Node[];
  /** The next page token or empty if none. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request for [GetNode][google.cloud.tpu.v2alpha1.Tpu.GetNode]. */
export interface GetNodeRequest {
  /** Required. The resource name. */
  name: string;
}

/** Request for [CreateNode][google.cloud.tpu.v2alpha1.Tpu.CreateNode]. */
export interface CreateNodeRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The unqualified resource name. */
  nodeId: string;
  /** Required. The node. */
  node:
    | Node
    | undefined;
  /** Idempotent request UUID. */
  requestId: string;
}

/** Request for [DeleteNode][google.cloud.tpu.v2alpha1.Tpu.DeleteNode]. */
export interface DeleteNodeRequest {
  /** Required. The resource name. */
  name: string;
  /** Idempotent request UUID. */
  requestId: string;
}

/** Request for [StopNode][google.cloud.tpu.v2alpha1.Tpu.StopNode]. */
export interface StopNodeRequest {
  /** Required. The resource name. */
  name: string;
}

/** Request for [StartNode][google.cloud.tpu.v2alpha1.Tpu.StartNode]. */
export interface StartNodeRequest {
  /** Required. The resource name. */
  name: string;
}

/** Request for [UpdateNode][google.cloud.tpu.v2alpha1.Tpu.UpdateNode]. */
export interface UpdateNodeRequest {
  /**
   * Required. Mask of fields from [Node][Tpu.Node] to update.
   * Supported fields: [description, tags, labels, metadata,
   * network_config.enable_external_ips].
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The node. Only fields specified in update_mask are updated. */
  node: Node | undefined;
}

/**
 * Request for
 * [ListQueuedResources][google.cloud.tpu.v2alpha1.Tpu.ListQueuedResources].
 */
export interface ListQueuedResourcesRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
}

/**
 * Response for
 * [ListQueuedResources][google.cloud.tpu.v2alpha1.Tpu.ListQueuedResources].
 */
export interface ListQueuedResourcesResponse {
  /** The listed queued resources. */
  queuedResources: QueuedResource[];
  /** The next page token or empty if none. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/**
 * Request for
 * [GetQueuedResource][google.cloud.tpu.v2alpha1.Tpu.GetQueuedResource]
 */
export interface GetQueuedResourceRequest {
  /** Required. The resource name. */
  name: string;
}

/**
 * Request for
 * [CreateQueuedResource][google.cloud.tpu.v2alpha1.Tpu.CreateQueuedResource].
 */
export interface CreateQueuedResourceRequest {
  /** Required. The parent resource name. */
  parent: string;
  /**
   * The unqualified resource name. Should follow the `^[A-Za-z0-9_.~+%-]+$`
   * regex format.
   */
  queuedResourceId: string;
  /** Required. The queued resource. */
  queuedResource:
    | QueuedResource
    | undefined;
  /** Idempotent request UUID. */
  requestId: string;
}

/**
 * Request for
 * [DeleteQueuedResource][google.cloud.tpu.v2alpha1.Tpu.DeleteQueuedResource].
 */
export interface DeleteQueuedResourceRequest {
  /** Required. The resource name. */
  name: string;
  /** Idempotent request UUID. */
  requestId: string;
  /**
   * If set to true, all running nodes belonging to this queued resource will
   * be deleted first and then the queued resource will be deleted.
   * Otherwise (i.e. force=false), the queued resource will only be deleted if
   * its nodes have already been deleted or the queued resource is in the
   * ACCEPTED, FAILED, or SUSPENDED state.
   */
  force: boolean;
}

/**
 * Request for
 * [ResetQueuedResource][google.cloud.tpu.v2alpha1.Tpu.ResetQueuedResource].
 */
export interface ResetQueuedResourceRequest {
  /** Required. The name of the queued resource. */
  name: string;
}

/** The per-product per-project service identity for Cloud TPU service. */
export interface ServiceIdentity {
  /** The email address of the service identity. */
  email: string;
}

/**
 * Request for
 * [GenerateServiceIdentity][google.cloud.tpu.v2alpha1.Tpu.GenerateServiceIdentity].
 */
export interface GenerateServiceIdentityRequest {
  /** Required. The parent resource name. */
  parent: string;
}

/**
 * Response for
 * [GenerateServiceIdentity][google.cloud.tpu.v2alpha1.Tpu.GenerateServiceIdentity].
 */
export interface GenerateServiceIdentityResponse {
  /** ServiceIdentity that was created or retrieved. */
  identity: ServiceIdentity | undefined;
}

/** A accelerator type that a Node can be configured with. */
export interface AcceleratorType {
  /** The resource name. */
  name: string;
  /** The accelerator type. */
  type: string;
  /** The accelerator config. */
  acceleratorConfigs: AcceleratorConfig[];
}

/**
 * Request for
 * [GetAcceleratorType][google.cloud.tpu.v2alpha1.Tpu.GetAcceleratorType].
 */
export interface GetAcceleratorTypeRequest {
  /** Required. The resource name. */
  name: string;
}

/**
 * Request for
 * [ListAcceleratorTypes][google.cloud.tpu.v2alpha1.Tpu.ListAcceleratorTypes].
 */
export interface ListAcceleratorTypesRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
  /** List filter. */
  filter: string;
  /** Sort results. */
  orderBy: string;
}

/**
 * Response for
 * [ListAcceleratorTypes][google.cloud.tpu.v2alpha1.Tpu.ListAcceleratorTypes].
 */
export interface ListAcceleratorTypesResponse {
  /** The listed nodes. */
  acceleratorTypes: AcceleratorType[];
  /** The next page token or empty if none. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** A runtime version that a Node can be configured with. */
export interface RuntimeVersion {
  /** The resource name. */
  name: string;
  /** The runtime version. */
  version: string;
}

/**
 * Request for
 * [GetRuntimeVersion][google.cloud.tpu.v2alpha1.Tpu.GetRuntimeVersion].
 */
export interface GetRuntimeVersionRequest {
  /** Required. The resource name. */
  name: string;
}

/**
 * Request for
 * [ListRuntimeVersions][google.cloud.tpu.v2alpha1.Tpu.ListRuntimeVersions].
 */
export interface ListRuntimeVersionsRequest {
  /** Required. The parent resource name. */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
  /** List filter. */
  filter: string;
  /** Sort results. */
  orderBy: string;
}

/**
 * Response for
 * [ListRuntimeVersions][google.cloud.tpu.v2alpha1.Tpu.ListRuntimeVersions].
 */
export interface ListRuntimeVersionsResponse {
  /** The listed nodes. */
  runtimeVersions: RuntimeVersion[];
  /** The next page token or empty if none. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Metadata describing an [Operation][google.longrunning.Operation] */
export interface OperationMetadata {
  /** The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /**
   * Target of the operation - for example
   * projects/project-1/connectivityTests/test-1
   */
  target: string;
  /** Name of the verb executed by the operation. */
  verb: string;
  /** Human-readable status of the operation, if any. */
  statusDetail: string;
  /** Specifies if cancellation was requested for the operation. */
  cancelRequested: boolean;
  /** API version. */
  apiVersion: string;
}

/** A Symptom instance. */
export interface Symptom {
  /** Timestamp when the Symptom is created. */
  createTime:
    | Date
    | undefined;
  /** Type of the Symptom. */
  symptomType: Symptom_SymptomType;
  /** Detailed information of the current Symptom. */
  details: string;
  /** A string used to uniquely distinguish a worker within a TPU node. */
  workerId: string;
}

/**
 * SymptomType represents the different types of Symptoms that a TPU can be
 * at.
 */
export enum Symptom_SymptomType {
  /** SYMPTOM_TYPE_UNSPECIFIED - Unspecified symptom. */
  SYMPTOM_TYPE_UNSPECIFIED = 0,
  /** LOW_MEMORY - TPU VM memory is low. */
  LOW_MEMORY = 1,
  /** OUT_OF_MEMORY - TPU runtime is out of memory. */
  OUT_OF_MEMORY = 2,
  /** EXECUTE_TIMED_OUT - TPU runtime execution has timed out. */
  EXECUTE_TIMED_OUT = 3,
  /**
   * MESH_BUILD_FAIL - TPU runtime fails to construct a mesh that recognizes each TPU device's
   * neighbors.
   */
  MESH_BUILD_FAIL = 4,
  /** HBM_OUT_OF_MEMORY - TPU HBM is out of memory. */
  HBM_OUT_OF_MEMORY = 5,
  /** PROJECT_ABUSE - Abusive behaviors have been identified on the current project. */
  PROJECT_ABUSE = 6,
  UNRECOGNIZED = -1,
}

export function symptom_SymptomTypeFromJSON(object: any): Symptom_SymptomType {
  switch (object) {
    case 0:
    case "SYMPTOM_TYPE_UNSPECIFIED":
      return Symptom_SymptomType.SYMPTOM_TYPE_UNSPECIFIED;
    case 1:
    case "LOW_MEMORY":
      return Symptom_SymptomType.LOW_MEMORY;
    case 2:
    case "OUT_OF_MEMORY":
      return Symptom_SymptomType.OUT_OF_MEMORY;
    case 3:
    case "EXECUTE_TIMED_OUT":
      return Symptom_SymptomType.EXECUTE_TIMED_OUT;
    case 4:
    case "MESH_BUILD_FAIL":
      return Symptom_SymptomType.MESH_BUILD_FAIL;
    case 5:
    case "HBM_OUT_OF_MEMORY":
      return Symptom_SymptomType.HBM_OUT_OF_MEMORY;
    case 6:
    case "PROJECT_ABUSE":
      return Symptom_SymptomType.PROJECT_ABUSE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Symptom_SymptomType.UNRECOGNIZED;
  }
}

export function symptom_SymptomTypeToJSON(object: Symptom_SymptomType): string {
  switch (object) {
    case Symptom_SymptomType.SYMPTOM_TYPE_UNSPECIFIED:
      return "SYMPTOM_TYPE_UNSPECIFIED";
    case Symptom_SymptomType.LOW_MEMORY:
      return "LOW_MEMORY";
    case Symptom_SymptomType.OUT_OF_MEMORY:
      return "OUT_OF_MEMORY";
    case Symptom_SymptomType.EXECUTE_TIMED_OUT:
      return "EXECUTE_TIMED_OUT";
    case Symptom_SymptomType.MESH_BUILD_FAIL:
      return "MESH_BUILD_FAIL";
    case Symptom_SymptomType.HBM_OUT_OF_MEMORY:
      return "HBM_OUT_OF_MEMORY";
    case Symptom_SymptomType.PROJECT_ABUSE:
      return "PROJECT_ABUSE";
    case Symptom_SymptomType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Request for
 * [GetGuestAttributes][google.cloud.tpu.v2alpha1.Tpu.GetGuestAttributes].
 */
export interface GetGuestAttributesRequest {
  /** Required. The resource name. */
  name: string;
  /** The guest attributes path to be queried. */
  queryPath: string;
  /**
   * The 0-based worker ID. If it is empty, all workers' GuestAttributes will be
   * returned.
   */
  workerIds: string[];
}

/**
 * Response for
 * [GetGuestAttributes][google.cloud.tpu.v2alpha1.Tpu.GetGuestAttributes].
 */
export interface GetGuestAttributesResponse {
  /** The guest attributes for the TPU workers. */
  guestAttributes: GuestAttributes[];
}

/**
 * Request for
 * [SimulateMaintenanceEvent][google.cloud.tpu.v2alpha1.Tpu.SimulateMaintenanceEvent].
 */
export interface SimulateMaintenanceEventRequest {
  /** Required. The resource name. */
  name: string;
  /**
   * The 0-based worker ID. If it is empty, worker ID 0 will be selected for
   * maintenance event simulation. A maintenance event will only be fired on the
   * first specified worker ID. Future implementations may support firing on
   * multiple workers.
   */
  workerIds: string[];
}

/** A TPU accelerator configuration. */
export interface AcceleratorConfig {
  /** Required. Type of TPU. */
  type: AcceleratorConfig_Type;
  /** Required. Topology of TPU in chips. */
  topology: string;
}

/** TPU type. */
export enum AcceleratorConfig_Type {
  /** TYPE_UNSPECIFIED - Unspecified version. */
  TYPE_UNSPECIFIED = 0,
  /** V2 - TPU v2. */
  V2 = 2,
  /** V3 - TPU v3. */
  V3 = 4,
  /** V4 - TPU v4. */
  V4 = 7,
  UNRECOGNIZED = -1,
}

export function acceleratorConfig_TypeFromJSON(object: any): AcceleratorConfig_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return AcceleratorConfig_Type.TYPE_UNSPECIFIED;
    case 2:
    case "V2":
      return AcceleratorConfig_Type.V2;
    case 4:
    case "V3":
      return AcceleratorConfig_Type.V3;
    case 7:
    case "V4":
      return AcceleratorConfig_Type.V4;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AcceleratorConfig_Type.UNRECOGNIZED;
  }
}

export function acceleratorConfig_TypeToJSON(object: AcceleratorConfig_Type): string {
  switch (object) {
    case AcceleratorConfig_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case AcceleratorConfig_Type.V2:
      return "V2";
    case AcceleratorConfig_Type.V3:
      return "V3";
    case AcceleratorConfig_Type.V4:
      return "V4";
    case AcceleratorConfig_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A set of Shielded Instance options. */
export interface ShieldedInstanceConfig {
  /** Defines whether the instance has Secure Boot enabled. */
  enableSecureBoot: boolean;
}

/** Boot disk configurations. */
export interface BootDiskConfig {
  /** Optional. Customer encryption key for boot disk. */
  customerEncryptionKey:
    | CustomerEncryptionKey
    | undefined;
  /**
   * Optional. Whether the boot disk will be created with confidential compute
   * mode.
   */
  enableConfidentialCompute: boolean;
}

/** Customer's encryption key. */
export interface CustomerEncryptionKey {
  /**
   * The name of the encryption key that is stored in Google Cloud KMS.
   * For example:
   * <pre class="lang-html">"kmsKeyName": "projects/
   * <var class="apiparam">kms_project_id</var>/locations/
   * <var class="apiparam">region</var>/keyRings/<var class="apiparam">
   * key_region</var>/cryptoKeys/<var class="apiparam">key</var>
   * </pre>
   * The fully-qualifed key name may be returned for resource GET requests.
   * For example:
   * <pre class="lang-html">"kmsKeyName": "projects/
   * <var class="apiparam">kms_project_id</var>/locations/
   * <var class="apiparam">region</var>/keyRings/<var class="apiparam">
   * key_region</var>/cryptoKeys/<var class="apiparam">key</var>
   * /cryptoKeyVersions/1</pre>
   */
  kmsKeyName?: string | undefined;
}

function createBaseGuestAttributes(): GuestAttributes {
  return { queryPath: "", queryValue: undefined };
}

export const GuestAttributes: MessageFns<GuestAttributes> = {
  encode(message: GuestAttributes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryPath !== "") {
      writer.uint32(10).string(message.queryPath);
    }
    if (message.queryValue !== undefined) {
      GuestAttributesValue.encode(message.queryValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestAttributes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryPath = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queryValue = GuestAttributesValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestAttributes {
    return {
      queryPath: isSet(object.queryPath) ? globalThis.String(object.queryPath) : "",
      queryValue: isSet(object.queryValue) ? GuestAttributesValue.fromJSON(object.queryValue) : undefined,
    };
  },

  toJSON(message: GuestAttributes): unknown {
    const obj: any = {};
    if (message.queryPath !== "") {
      obj.queryPath = message.queryPath;
    }
    if (message.queryValue !== undefined) {
      obj.queryValue = GuestAttributesValue.toJSON(message.queryValue);
    }
    return obj;
  },

  create(base?: DeepPartial<GuestAttributes>): GuestAttributes {
    return GuestAttributes.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestAttributes>): GuestAttributes {
    const message = createBaseGuestAttributes();
    message.queryPath = object.queryPath ?? "";
    message.queryValue = (object.queryValue !== undefined && object.queryValue !== null)
      ? GuestAttributesValue.fromPartial(object.queryValue)
      : undefined;
    return message;
  },
};

function createBaseGuestAttributesValue(): GuestAttributesValue {
  return { items: [] };
}

export const GuestAttributesValue: MessageFns<GuestAttributesValue> = {
  encode(message: GuestAttributesValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      GuestAttributesEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestAttributesValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestAttributesValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(GuestAttributesEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestAttributesValue {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => GuestAttributesEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GuestAttributesValue): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => GuestAttributesEntry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GuestAttributesValue>): GuestAttributesValue {
    return GuestAttributesValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestAttributesValue>): GuestAttributesValue {
    const message = createBaseGuestAttributesValue();
    message.items = object.items?.map((e) => GuestAttributesEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGuestAttributesEntry(): GuestAttributesEntry {
  return { namespace: "", key: "", value: "" };
}

export const GuestAttributesEntry: MessageFns<GuestAttributesEntry> = {
  encode(message: GuestAttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.key !== "") {
      writer.uint32(18).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestAttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestAttributesEntry {
    return {
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: GuestAttributesEntry): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<GuestAttributesEntry>): GuestAttributesEntry {
    return GuestAttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestAttributesEntry>): GuestAttributesEntry {
    const message = createBaseGuestAttributesEntry();
    message.namespace = object.namespace ?? "";
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAttachedDisk(): AttachedDisk {
  return { sourceDisk: "", mode: 0 };
}

export const AttachedDisk: MessageFns<AttachedDisk> = {
  encode(message: AttachedDisk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceDisk !== "") {
      writer.uint32(26).string(message.sourceDisk);
    }
    if (message.mode !== 0) {
      writer.uint32(32).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttachedDisk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachedDisk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceDisk = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttachedDisk {
    return {
      sourceDisk: isSet(object.sourceDisk) ? globalThis.String(object.sourceDisk) : "",
      mode: isSet(object.mode) ? attachedDisk_DiskModeFromJSON(object.mode) : 0,
    };
  },

  toJSON(message: AttachedDisk): unknown {
    const obj: any = {};
    if (message.sourceDisk !== "") {
      obj.sourceDisk = message.sourceDisk;
    }
    if (message.mode !== 0) {
      obj.mode = attachedDisk_DiskModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<AttachedDisk>): AttachedDisk {
    return AttachedDisk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttachedDisk>): AttachedDisk {
    const message = createBaseAttachedDisk();
    message.sourceDisk = object.sourceDisk ?? "";
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseSchedulingConfig(): SchedulingConfig {
  return { preemptible: false, reserved: false };
}

export const SchedulingConfig: MessageFns<SchedulingConfig> = {
  encode(message: SchedulingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.preemptible !== false) {
      writer.uint32(8).bool(message.preemptible);
    }
    if (message.reserved !== false) {
      writer.uint32(16).bool(message.reserved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchedulingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedulingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.preemptible = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reserved = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchedulingConfig {
    return {
      preemptible: isSet(object.preemptible) ? globalThis.Boolean(object.preemptible) : false,
      reserved: isSet(object.reserved) ? globalThis.Boolean(object.reserved) : false,
    };
  },

  toJSON(message: SchedulingConfig): unknown {
    const obj: any = {};
    if (message.preemptible !== false) {
      obj.preemptible = message.preemptible;
    }
    if (message.reserved !== false) {
      obj.reserved = message.reserved;
    }
    return obj;
  },

  create(base?: DeepPartial<SchedulingConfig>): SchedulingConfig {
    return SchedulingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchedulingConfig>): SchedulingConfig {
    const message = createBaseSchedulingConfig();
    message.preemptible = object.preemptible ?? false;
    message.reserved = object.reserved ?? false;
    return message;
  },
};

function createBaseNetworkEndpoint(): NetworkEndpoint {
  return { ipAddress: "", port: 0, accessConfig: undefined };
}

export const NetworkEndpoint: MessageFns<NetworkEndpoint> = {
  encode(message: NetworkEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipAddress !== "") {
      writer.uint32(10).string(message.ipAddress);
    }
    if (message.port !== 0) {
      writer.uint32(16).int32(message.port);
    }
    if (message.accessConfig !== undefined) {
      AccessConfig.encode(message.accessConfig, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.port = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.accessConfig = AccessConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkEndpoint {
    return {
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      accessConfig: isSet(object.accessConfig) ? AccessConfig.fromJSON(object.accessConfig) : undefined,
    };
  },

  toJSON(message: NetworkEndpoint): unknown {
    const obj: any = {};
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.accessConfig !== undefined) {
      obj.accessConfig = AccessConfig.toJSON(message.accessConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkEndpoint>): NetworkEndpoint {
    return NetworkEndpoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkEndpoint>): NetworkEndpoint {
    const message = createBaseNetworkEndpoint();
    message.ipAddress = object.ipAddress ?? "";
    message.port = object.port ?? 0;
    message.accessConfig = (object.accessConfig !== undefined && object.accessConfig !== null)
      ? AccessConfig.fromPartial(object.accessConfig)
      : undefined;
    return message;
  },
};

function createBaseAccessConfig(): AccessConfig {
  return { externalIp: "" };
}

export const AccessConfig: MessageFns<AccessConfig> = {
  encode(message: AccessConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.externalIp !== "") {
      writer.uint32(10).string(message.externalIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalIp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessConfig {
    return { externalIp: isSet(object.externalIp) ? globalThis.String(object.externalIp) : "" };
  },

  toJSON(message: AccessConfig): unknown {
    const obj: any = {};
    if (message.externalIp !== "") {
      obj.externalIp = message.externalIp;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessConfig>): AccessConfig {
    return AccessConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessConfig>): AccessConfig {
    const message = createBaseAccessConfig();
    message.externalIp = object.externalIp ?? "";
    return message;
  },
};

function createBaseNetworkConfig(): NetworkConfig {
  return { network: "", subnetwork: "", enableExternalIps: false, canIpForward: false };
}

export const NetworkConfig: MessageFns<NetworkConfig> = {
  encode(message: NetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.subnetwork !== "") {
      writer.uint32(18).string(message.subnetwork);
    }
    if (message.enableExternalIps !== false) {
      writer.uint32(24).bool(message.enableExternalIps);
    }
    if (message.canIpForward !== false) {
      writer.uint32(32).bool(message.canIpForward);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.enableExternalIps = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.canIpForward = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConfig {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      enableExternalIps: isSet(object.enableExternalIps) ? globalThis.Boolean(object.enableExternalIps) : false,
      canIpForward: isSet(object.canIpForward) ? globalThis.Boolean(object.canIpForward) : false,
    };
  },

  toJSON(message: NetworkConfig): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.enableExternalIps !== false) {
      obj.enableExternalIps = message.enableExternalIps;
    }
    if (message.canIpForward !== false) {
      obj.canIpForward = message.canIpForward;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkConfig>): NetworkConfig {
    return NetworkConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkConfig>): NetworkConfig {
    const message = createBaseNetworkConfig();
    message.network = object.network ?? "";
    message.subnetwork = object.subnetwork ?? "";
    message.enableExternalIps = object.enableExternalIps ?? false;
    message.canIpForward = object.canIpForward ?? false;
    return message;
  },
};

function createBaseServiceAccount(): ServiceAccount {
  return { email: "", scope: [] };
}

export const ServiceAccount: MessageFns<ServiceAccount> = {
  encode(message: ServiceAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    for (const v of message.scope) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scope.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccount {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      scope: globalThis.Array.isArray(object?.scope) ? object.scope.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ServiceAccount): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.scope?.length) {
      obj.scope = message.scope;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceAccount>): ServiceAccount {
    return ServiceAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceAccount>): ServiceAccount {
    const message = createBaseServiceAccount();
    message.email = object.email ?? "";
    message.scope = object.scope?.map((e) => e) || [];
    return message;
  },
};

function createBaseNode(): Node {
  return {
    name: "",
    description: "",
    acceleratorType: "",
    state: 0,
    healthDescription: "",
    runtimeVersion: "",
    networkConfig: undefined,
    cidrBlock: "",
    serviceAccount: undefined,
    createTime: undefined,
    schedulingConfig: undefined,
    networkEndpoints: [],
    health: 0,
    labels: {},
    metadata: {},
    tags: [],
    id: Long.ZERO,
    dataDisks: [],
    apiVersion: 0,
    symptoms: [],
    queuedResource: "",
    acceleratorConfig: undefined,
    shieldedInstanceConfig: undefined,
    multisliceNode: false,
    bootDiskConfig: undefined,
  };
}

export const Node: MessageFns<Node> = {
  encode(message: Node, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.acceleratorType !== "") {
      writer.uint32(42).string(message.acceleratorType);
    }
    if (message.state !== 0) {
      writer.uint32(72).int32(message.state);
    }
    if (message.healthDescription !== "") {
      writer.uint32(82).string(message.healthDescription);
    }
    if (message.runtimeVersion !== "") {
      writer.uint32(90).string(message.runtimeVersion);
    }
    if (message.networkConfig !== undefined) {
      NetworkConfig.encode(message.networkConfig, writer.uint32(290).fork()).join();
    }
    if (message.cidrBlock !== "") {
      writer.uint32(106).string(message.cidrBlock);
    }
    if (message.serviceAccount !== undefined) {
      ServiceAccount.encode(message.serviceAccount, writer.uint32(298).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(130).fork()).join();
    }
    if (message.schedulingConfig !== undefined) {
      SchedulingConfig.encode(message.schedulingConfig, writer.uint32(138).fork()).join();
    }
    for (const v of message.networkEndpoints) {
      NetworkEndpoint.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.health !== 0) {
      writer.uint32(176).int32(message.health);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Node_LabelsEntry.encode({ key: key as any, value }, writer.uint32(194).fork()).join();
    });
    Object.entries(message.metadata).forEach(([key, value]) => {
      Node_MetadataEntry.encode({ key: key as any, value }, writer.uint32(274).fork()).join();
    });
    for (const v of message.tags) {
      writer.uint32(322).string(v!);
    }
    if (!message.id.equals(Long.ZERO)) {
      writer.uint32(264).int64(message.id.toString());
    }
    for (const v of message.dataDisks) {
      AttachedDisk.encode(v!, writer.uint32(330).fork()).join();
    }
    if (message.apiVersion !== 0) {
      writer.uint32(304).int32(message.apiVersion);
    }
    for (const v of message.symptoms) {
      Symptom.encode(v!, writer.uint32(314).fork()).join();
    }
    if (message.queuedResource !== "") {
      writer.uint32(346).string(message.queuedResource);
    }
    if (message.acceleratorConfig !== undefined) {
      AcceleratorConfig.encode(message.acceleratorConfig, writer.uint32(354).fork()).join();
    }
    if (message.shieldedInstanceConfig !== undefined) {
      ShieldedInstanceConfig.encode(message.shieldedInstanceConfig, writer.uint32(362).fork()).join();
    }
    if (message.multisliceNode !== false) {
      writer.uint32(376).bool(message.multisliceNode);
    }
    if (message.bootDiskConfig !== undefined) {
      BootDiskConfig.encode(message.bootDiskConfig, writer.uint32(394).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.acceleratorType = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.healthDescription = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.runtimeVersion = reader.string();
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.networkConfig = NetworkConfig.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.cidrBlock = reader.string();
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.serviceAccount = ServiceAccount.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.schedulingConfig = SchedulingConfig.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.networkEndpoints.push(NetworkEndpoint.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.health = reader.int32() as any;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          const entry24 = Node_LabelsEntry.decode(reader, reader.uint32());
          if (entry24.value !== undefined) {
            message.labels[entry24.key] = entry24.value;
          }
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          const entry34 = Node_MetadataEntry.decode(reader, reader.uint32());
          if (entry34.value !== undefined) {
            message.metadata[entry34.key] = entry34.value;
          }
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 33:
          if (tag !== 264) {
            break;
          }

          message.id = Long.fromString(reader.int64().toString());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.dataDisks.push(AttachedDisk.decode(reader, reader.uint32()));
          continue;
        case 38:
          if (tag !== 304) {
            break;
          }

          message.apiVersion = reader.int32() as any;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.symptoms.push(Symptom.decode(reader, reader.uint32()));
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.queuedResource = reader.string();
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }

          message.acceleratorConfig = AcceleratorConfig.decode(reader, reader.uint32());
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }

          message.shieldedInstanceConfig = ShieldedInstanceConfig.decode(reader, reader.uint32());
          continue;
        case 47:
          if (tag !== 376) {
            break;
          }

          message.multisliceNode = reader.bool();
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }

          message.bootDiskConfig = BootDiskConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      acceleratorType: isSet(object.acceleratorType) ? globalThis.String(object.acceleratorType) : "",
      state: isSet(object.state) ? node_StateFromJSON(object.state) : 0,
      healthDescription: isSet(object.healthDescription) ? globalThis.String(object.healthDescription) : "",
      runtimeVersion: isSet(object.runtimeVersion) ? globalThis.String(object.runtimeVersion) : "",
      networkConfig: isSet(object.networkConfig) ? NetworkConfig.fromJSON(object.networkConfig) : undefined,
      cidrBlock: isSet(object.cidrBlock) ? globalThis.String(object.cidrBlock) : "",
      serviceAccount: isSet(object.serviceAccount) ? ServiceAccount.fromJSON(object.serviceAccount) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      schedulingConfig: isSet(object.schedulingConfig) ? SchedulingConfig.fromJSON(object.schedulingConfig) : undefined,
      networkEndpoints: globalThis.Array.isArray(object?.networkEndpoints)
        ? object.networkEndpoints.map((e: any) => NetworkEndpoint.fromJSON(e))
        : [],
      health: isSet(object.health) ? node_HealthFromJSON(object.health) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      id: isSet(object.id) ? Long.fromValue(object.id) : Long.ZERO,
      dataDisks: globalThis.Array.isArray(object?.dataDisks)
        ? object.dataDisks.map((e: any) => AttachedDisk.fromJSON(e))
        : [],
      apiVersion: isSet(object.apiVersion) ? node_ApiVersionFromJSON(object.apiVersion) : 0,
      symptoms: globalThis.Array.isArray(object?.symptoms)
        ? object.symptoms.map((e: any) => Symptom.fromJSON(e))
        : [],
      queuedResource: isSet(object.queuedResource) ? globalThis.String(object.queuedResource) : "",
      acceleratorConfig: isSet(object.acceleratorConfig)
        ? AcceleratorConfig.fromJSON(object.acceleratorConfig)
        : undefined,
      shieldedInstanceConfig: isSet(object.shieldedInstanceConfig)
        ? ShieldedInstanceConfig.fromJSON(object.shieldedInstanceConfig)
        : undefined,
      multisliceNode: isSet(object.multisliceNode) ? globalThis.Boolean(object.multisliceNode) : false,
      bootDiskConfig: isSet(object.bootDiskConfig) ? BootDiskConfig.fromJSON(object.bootDiskConfig) : undefined,
    };
  },

  toJSON(message: Node): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.acceleratorType !== "") {
      obj.acceleratorType = message.acceleratorType;
    }
    if (message.state !== 0) {
      obj.state = node_StateToJSON(message.state);
    }
    if (message.healthDescription !== "") {
      obj.healthDescription = message.healthDescription;
    }
    if (message.runtimeVersion !== "") {
      obj.runtimeVersion = message.runtimeVersion;
    }
    if (message.networkConfig !== undefined) {
      obj.networkConfig = NetworkConfig.toJSON(message.networkConfig);
    }
    if (message.cidrBlock !== "") {
      obj.cidrBlock = message.cidrBlock;
    }
    if (message.serviceAccount !== undefined) {
      obj.serviceAccount = ServiceAccount.toJSON(message.serviceAccount);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.schedulingConfig !== undefined) {
      obj.schedulingConfig = SchedulingConfig.toJSON(message.schedulingConfig);
    }
    if (message.networkEndpoints?.length) {
      obj.networkEndpoints = message.networkEndpoints.map((e) => NetworkEndpoint.toJSON(e));
    }
    if (message.health !== 0) {
      obj.health = node_HealthToJSON(message.health);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (!message.id.equals(Long.ZERO)) {
      obj.id = (message.id || Long.ZERO).toString();
    }
    if (message.dataDisks?.length) {
      obj.dataDisks = message.dataDisks.map((e) => AttachedDisk.toJSON(e));
    }
    if (message.apiVersion !== 0) {
      obj.apiVersion = node_ApiVersionToJSON(message.apiVersion);
    }
    if (message.symptoms?.length) {
      obj.symptoms = message.symptoms.map((e) => Symptom.toJSON(e));
    }
    if (message.queuedResource !== "") {
      obj.queuedResource = message.queuedResource;
    }
    if (message.acceleratorConfig !== undefined) {
      obj.acceleratorConfig = AcceleratorConfig.toJSON(message.acceleratorConfig);
    }
    if (message.shieldedInstanceConfig !== undefined) {
      obj.shieldedInstanceConfig = ShieldedInstanceConfig.toJSON(message.shieldedInstanceConfig);
    }
    if (message.multisliceNode !== false) {
      obj.multisliceNode = message.multisliceNode;
    }
    if (message.bootDiskConfig !== undefined) {
      obj.bootDiskConfig = BootDiskConfig.toJSON(message.bootDiskConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Node>): Node {
    return Node.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node>): Node {
    const message = createBaseNode();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.acceleratorType = object.acceleratorType ?? "";
    message.state = object.state ?? 0;
    message.healthDescription = object.healthDescription ?? "";
    message.runtimeVersion = object.runtimeVersion ?? "";
    message.networkConfig = (object.networkConfig !== undefined && object.networkConfig !== null)
      ? NetworkConfig.fromPartial(object.networkConfig)
      : undefined;
    message.cidrBlock = object.cidrBlock ?? "";
    message.serviceAccount = (object.serviceAccount !== undefined && object.serviceAccount !== null)
      ? ServiceAccount.fromPartial(object.serviceAccount)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.schedulingConfig = (object.schedulingConfig !== undefined && object.schedulingConfig !== null)
      ? SchedulingConfig.fromPartial(object.schedulingConfig)
      : undefined;
    message.networkEndpoints = object.networkEndpoints?.map((e) => NetworkEndpoint.fromPartial(e)) || [];
    message.health = object.health ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.tags = object.tags?.map((e) => e) || [];
    message.id = (object.id !== undefined && object.id !== null) ? Long.fromValue(object.id) : Long.ZERO;
    message.dataDisks = object.dataDisks?.map((e) => AttachedDisk.fromPartial(e)) || [];
    message.apiVersion = object.apiVersion ?? 0;
    message.symptoms = object.symptoms?.map((e) => Symptom.fromPartial(e)) || [];
    message.queuedResource = object.queuedResource ?? "";
    message.acceleratorConfig = (object.acceleratorConfig !== undefined && object.acceleratorConfig !== null)
      ? AcceleratorConfig.fromPartial(object.acceleratorConfig)
      : undefined;
    message.shieldedInstanceConfig =
      (object.shieldedInstanceConfig !== undefined && object.shieldedInstanceConfig !== null)
        ? ShieldedInstanceConfig.fromPartial(object.shieldedInstanceConfig)
        : undefined;
    message.multisliceNode = object.multisliceNode ?? false;
    message.bootDiskConfig = (object.bootDiskConfig !== undefined && object.bootDiskConfig !== null)
      ? BootDiskConfig.fromPartial(object.bootDiskConfig)
      : undefined;
    return message;
  },
};

function createBaseNode_LabelsEntry(): Node_LabelsEntry {
  return { key: "", value: "" };
}

export const Node_LabelsEntry: MessageFns<Node_LabelsEntry> = {
  encode(message: Node_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Node_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Node_LabelsEntry>): Node_LabelsEntry {
    return Node_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node_LabelsEntry>): Node_LabelsEntry {
    const message = createBaseNode_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNode_MetadataEntry(): Node_MetadataEntry {
  return { key: "", value: "" };
}

export const Node_MetadataEntry: MessageFns<Node_MetadataEntry> = {
  encode(message: Node_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Node_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNode_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Node_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Node_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Node_MetadataEntry>): Node_MetadataEntry {
    return Node_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Node_MetadataEntry>): Node_MetadataEntry {
    const message = createBaseNode_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseQueuedResource(): QueuedResource {
  return {
    name: "",
    tpu: undefined,
    bestEffort: undefined,
    guaranteed: undefined,
    spot: undefined,
    queueingPolicy: undefined,
    state: undefined,
    reservationName: "",
  };
}

export const QueuedResource: MessageFns<QueuedResource> = {
  encode(message: QueuedResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tpu !== undefined) {
      QueuedResource_Tpu.encode(message.tpu, writer.uint32(18).fork()).join();
    }
    if (message.bestEffort !== undefined) {
      QueuedResource_BestEffort.encode(message.bestEffort, writer.uint32(26).fork()).join();
    }
    if (message.guaranteed !== undefined) {
      QueuedResource_Guaranteed.encode(message.guaranteed, writer.uint32(34).fork()).join();
    }
    if (message.spot !== undefined) {
      QueuedResource_Spot.encode(message.spot, writer.uint32(74).fork()).join();
    }
    if (message.queueingPolicy !== undefined) {
      QueuedResource_QueueingPolicy.encode(message.queueingPolicy, writer.uint32(42).fork()).join();
    }
    if (message.state !== undefined) {
      QueuedResourceState.encode(message.state, writer.uint32(50).fork()).join();
    }
    if (message.reservationName !== "") {
      writer.uint32(66).string(message.reservationName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tpu = QueuedResource_Tpu.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bestEffort = QueuedResource_BestEffort.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.guaranteed = QueuedResource_Guaranteed.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.spot = QueuedResource_Spot.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.queueingPolicy = QueuedResource_QueueingPolicy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.state = QueuedResourceState.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.reservationName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueuedResource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      tpu: isSet(object.tpu) ? QueuedResource_Tpu.fromJSON(object.tpu) : undefined,
      bestEffort: isSet(object.bestEffort) ? QueuedResource_BestEffort.fromJSON(object.bestEffort) : undefined,
      guaranteed: isSet(object.guaranteed) ? QueuedResource_Guaranteed.fromJSON(object.guaranteed) : undefined,
      spot: isSet(object.spot) ? QueuedResource_Spot.fromJSON(object.spot) : undefined,
      queueingPolicy: isSet(object.queueingPolicy)
        ? QueuedResource_QueueingPolicy.fromJSON(object.queueingPolicy)
        : undefined,
      state: isSet(object.state) ? QueuedResourceState.fromJSON(object.state) : undefined,
      reservationName: isSet(object.reservationName) ? globalThis.String(object.reservationName) : "",
    };
  },

  toJSON(message: QueuedResource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.tpu !== undefined) {
      obj.tpu = QueuedResource_Tpu.toJSON(message.tpu);
    }
    if (message.bestEffort !== undefined) {
      obj.bestEffort = QueuedResource_BestEffort.toJSON(message.bestEffort);
    }
    if (message.guaranteed !== undefined) {
      obj.guaranteed = QueuedResource_Guaranteed.toJSON(message.guaranteed);
    }
    if (message.spot !== undefined) {
      obj.spot = QueuedResource_Spot.toJSON(message.spot);
    }
    if (message.queueingPolicy !== undefined) {
      obj.queueingPolicy = QueuedResource_QueueingPolicy.toJSON(message.queueingPolicy);
    }
    if (message.state !== undefined) {
      obj.state = QueuedResourceState.toJSON(message.state);
    }
    if (message.reservationName !== "") {
      obj.reservationName = message.reservationName;
    }
    return obj;
  },

  create(base?: DeepPartial<QueuedResource>): QueuedResource {
    return QueuedResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueuedResource>): QueuedResource {
    const message = createBaseQueuedResource();
    message.name = object.name ?? "";
    message.tpu = (object.tpu !== undefined && object.tpu !== null)
      ? QueuedResource_Tpu.fromPartial(object.tpu)
      : undefined;
    message.bestEffort = (object.bestEffort !== undefined && object.bestEffort !== null)
      ? QueuedResource_BestEffort.fromPartial(object.bestEffort)
      : undefined;
    message.guaranteed = (object.guaranteed !== undefined && object.guaranteed !== null)
      ? QueuedResource_Guaranteed.fromPartial(object.guaranteed)
      : undefined;
    message.spot = (object.spot !== undefined && object.spot !== null)
      ? QueuedResource_Spot.fromPartial(object.spot)
      : undefined;
    message.queueingPolicy = (object.queueingPolicy !== undefined && object.queueingPolicy !== null)
      ? QueuedResource_QueueingPolicy.fromPartial(object.queueingPolicy)
      : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? QueuedResourceState.fromPartial(object.state)
      : undefined;
    message.reservationName = object.reservationName ?? "";
    return message;
  },
};

function createBaseQueuedResource_Tpu(): QueuedResource_Tpu {
  return { nodeSpec: [] };
}

export const QueuedResource_Tpu: MessageFns<QueuedResource_Tpu> = {
  encode(message: QueuedResource_Tpu, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodeSpec) {
      QueuedResource_Tpu_NodeSpec.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResource_Tpu {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResource_Tpu();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodeSpec.push(QueuedResource_Tpu_NodeSpec.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueuedResource_Tpu {
    return {
      nodeSpec: globalThis.Array.isArray(object?.nodeSpec)
        ? object.nodeSpec.map((e: any) => QueuedResource_Tpu_NodeSpec.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueuedResource_Tpu): unknown {
    const obj: any = {};
    if (message.nodeSpec?.length) {
      obj.nodeSpec = message.nodeSpec.map((e) => QueuedResource_Tpu_NodeSpec.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<QueuedResource_Tpu>): QueuedResource_Tpu {
    return QueuedResource_Tpu.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueuedResource_Tpu>): QueuedResource_Tpu {
    const message = createBaseQueuedResource_Tpu();
    message.nodeSpec = object.nodeSpec?.map((e) => QueuedResource_Tpu_NodeSpec.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueuedResource_Tpu_NodeSpec(): QueuedResource_Tpu_NodeSpec {
  return { parent: "", nodeId: "", multiNodeParams: undefined, node: undefined };
}

export const QueuedResource_Tpu_NodeSpec: MessageFns<QueuedResource_Tpu_NodeSpec> = {
  encode(message: QueuedResource_Tpu_NodeSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.nodeId !== "") {
      writer.uint32(18).string(message.nodeId);
    }
    if (message.multiNodeParams !== undefined) {
      QueuedResource_Tpu_NodeSpec_MultiNodeParams.encode(message.multiNodeParams, writer.uint32(50).fork()).join();
    }
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResource_Tpu_NodeSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResource_Tpu_NodeSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.multiNodeParams = QueuedResource_Tpu_NodeSpec_MultiNodeParams.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueuedResource_Tpu_NodeSpec {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      multiNodeParams: isSet(object.multiNodeParams)
        ? QueuedResource_Tpu_NodeSpec_MultiNodeParams.fromJSON(object.multiNodeParams)
        : undefined,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
    };
  },

  toJSON(message: QueuedResource_Tpu_NodeSpec): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.multiNodeParams !== undefined) {
      obj.multiNodeParams = QueuedResource_Tpu_NodeSpec_MultiNodeParams.toJSON(message.multiNodeParams);
    }
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<QueuedResource_Tpu_NodeSpec>): QueuedResource_Tpu_NodeSpec {
    return QueuedResource_Tpu_NodeSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueuedResource_Tpu_NodeSpec>): QueuedResource_Tpu_NodeSpec {
    const message = createBaseQueuedResource_Tpu_NodeSpec();
    message.parent = object.parent ?? "";
    message.nodeId = object.nodeId ?? "";
    message.multiNodeParams = (object.multiNodeParams !== undefined && object.multiNodeParams !== null)
      ? QueuedResource_Tpu_NodeSpec_MultiNodeParams.fromPartial(object.multiNodeParams)
      : undefined;
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    return message;
  },
};

function createBaseQueuedResource_Tpu_NodeSpec_MultiNodeParams(): QueuedResource_Tpu_NodeSpec_MultiNodeParams {
  return { nodeCount: 0, nodeIdPrefix: "" };
}

export const QueuedResource_Tpu_NodeSpec_MultiNodeParams: MessageFns<QueuedResource_Tpu_NodeSpec_MultiNodeParams> = {
  encode(
    message: QueuedResource_Tpu_NodeSpec_MultiNodeParams,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nodeCount !== 0) {
      writer.uint32(8).int32(message.nodeCount);
    }
    if (message.nodeIdPrefix !== "") {
      writer.uint32(18).string(message.nodeIdPrefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResource_Tpu_NodeSpec_MultiNodeParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResource_Tpu_NodeSpec_MultiNodeParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeIdPrefix = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueuedResource_Tpu_NodeSpec_MultiNodeParams {
    return {
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      nodeIdPrefix: isSet(object.nodeIdPrefix) ? globalThis.String(object.nodeIdPrefix) : "",
    };
  },

  toJSON(message: QueuedResource_Tpu_NodeSpec_MultiNodeParams): unknown {
    const obj: any = {};
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.nodeIdPrefix !== "") {
      obj.nodeIdPrefix = message.nodeIdPrefix;
    }
    return obj;
  },

  create(base?: DeepPartial<QueuedResource_Tpu_NodeSpec_MultiNodeParams>): QueuedResource_Tpu_NodeSpec_MultiNodeParams {
    return QueuedResource_Tpu_NodeSpec_MultiNodeParams.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<QueuedResource_Tpu_NodeSpec_MultiNodeParams>,
  ): QueuedResource_Tpu_NodeSpec_MultiNodeParams {
    const message = createBaseQueuedResource_Tpu_NodeSpec_MultiNodeParams();
    message.nodeCount = object.nodeCount ?? 0;
    message.nodeIdPrefix = object.nodeIdPrefix ?? "";
    return message;
  },
};

function createBaseQueuedResource_BestEffort(): QueuedResource_BestEffort {
  return {};
}

export const QueuedResource_BestEffort: MessageFns<QueuedResource_BestEffort> = {
  encode(_: QueuedResource_BestEffort, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResource_BestEffort {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResource_BestEffort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueuedResource_BestEffort {
    return {};
  },

  toJSON(_: QueuedResource_BestEffort): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueuedResource_BestEffort>): QueuedResource_BestEffort {
    return QueuedResource_BestEffort.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueuedResource_BestEffort>): QueuedResource_BestEffort {
    const message = createBaseQueuedResource_BestEffort();
    return message;
  },
};

function createBaseQueuedResource_Spot(): QueuedResource_Spot {
  return {};
}

export const QueuedResource_Spot: MessageFns<QueuedResource_Spot> = {
  encode(_: QueuedResource_Spot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResource_Spot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResource_Spot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueuedResource_Spot {
    return {};
  },

  toJSON(_: QueuedResource_Spot): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueuedResource_Spot>): QueuedResource_Spot {
    return QueuedResource_Spot.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueuedResource_Spot>): QueuedResource_Spot {
    const message = createBaseQueuedResource_Spot();
    return message;
  },
};

function createBaseQueuedResource_Guaranteed(): QueuedResource_Guaranteed {
  return { minDuration: undefined, reserved: false };
}

export const QueuedResource_Guaranteed: MessageFns<QueuedResource_Guaranteed> = {
  encode(message: QueuedResource_Guaranteed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minDuration !== undefined) {
      Duration.encode(message.minDuration, writer.uint32(10).fork()).join();
    }
    if (message.reserved !== false) {
      writer.uint32(16).bool(message.reserved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResource_Guaranteed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResource_Guaranteed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.minDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reserved = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueuedResource_Guaranteed {
    return {
      minDuration: isSet(object.minDuration) ? Duration.fromJSON(object.minDuration) : undefined,
      reserved: isSet(object.reserved) ? globalThis.Boolean(object.reserved) : false,
    };
  },

  toJSON(message: QueuedResource_Guaranteed): unknown {
    const obj: any = {};
    if (message.minDuration !== undefined) {
      obj.minDuration = Duration.toJSON(message.minDuration);
    }
    if (message.reserved !== false) {
      obj.reserved = message.reserved;
    }
    return obj;
  },

  create(base?: DeepPartial<QueuedResource_Guaranteed>): QueuedResource_Guaranteed {
    return QueuedResource_Guaranteed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueuedResource_Guaranteed>): QueuedResource_Guaranteed {
    const message = createBaseQueuedResource_Guaranteed();
    message.minDuration = (object.minDuration !== undefined && object.minDuration !== null)
      ? Duration.fromPartial(object.minDuration)
      : undefined;
    message.reserved = object.reserved ?? false;
    return message;
  },
};

function createBaseQueuedResource_QueueingPolicy(): QueuedResource_QueueingPolicy {
  return {
    validUntilDuration: undefined,
    validUntilTime: undefined,
    validAfterDuration: undefined,
    validAfterTime: undefined,
    validInterval: undefined,
  };
}

export const QueuedResource_QueueingPolicy: MessageFns<QueuedResource_QueueingPolicy> = {
  encode(message: QueuedResource_QueueingPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validUntilDuration !== undefined) {
      Duration.encode(message.validUntilDuration, writer.uint32(10).fork()).join();
    }
    if (message.validUntilTime !== undefined) {
      Timestamp.encode(toTimestamp(message.validUntilTime), writer.uint32(18).fork()).join();
    }
    if (message.validAfterDuration !== undefined) {
      Duration.encode(message.validAfterDuration, writer.uint32(26).fork()).join();
    }
    if (message.validAfterTime !== undefined) {
      Timestamp.encode(toTimestamp(message.validAfterTime), writer.uint32(34).fork()).join();
    }
    if (message.validInterval !== undefined) {
      Interval.encode(message.validInterval, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResource_QueueingPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResource_QueueingPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.validUntilDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.validUntilTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.validAfterDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.validAfterTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.validInterval = Interval.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueuedResource_QueueingPolicy {
    return {
      validUntilDuration: isSet(object.validUntilDuration) ? Duration.fromJSON(object.validUntilDuration) : undefined,
      validUntilTime: isSet(object.validUntilTime) ? fromJsonTimestamp(object.validUntilTime) : undefined,
      validAfterDuration: isSet(object.validAfterDuration) ? Duration.fromJSON(object.validAfterDuration) : undefined,
      validAfterTime: isSet(object.validAfterTime) ? fromJsonTimestamp(object.validAfterTime) : undefined,
      validInterval: isSet(object.validInterval) ? Interval.fromJSON(object.validInterval) : undefined,
    };
  },

  toJSON(message: QueuedResource_QueueingPolicy): unknown {
    const obj: any = {};
    if (message.validUntilDuration !== undefined) {
      obj.validUntilDuration = Duration.toJSON(message.validUntilDuration);
    }
    if (message.validUntilTime !== undefined) {
      obj.validUntilTime = message.validUntilTime.toISOString();
    }
    if (message.validAfterDuration !== undefined) {
      obj.validAfterDuration = Duration.toJSON(message.validAfterDuration);
    }
    if (message.validAfterTime !== undefined) {
      obj.validAfterTime = message.validAfterTime.toISOString();
    }
    if (message.validInterval !== undefined) {
      obj.validInterval = Interval.toJSON(message.validInterval);
    }
    return obj;
  },

  create(base?: DeepPartial<QueuedResource_QueueingPolicy>): QueuedResource_QueueingPolicy {
    return QueuedResource_QueueingPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueuedResource_QueueingPolicy>): QueuedResource_QueueingPolicy {
    const message = createBaseQueuedResource_QueueingPolicy();
    message.validUntilDuration = (object.validUntilDuration !== undefined && object.validUntilDuration !== null)
      ? Duration.fromPartial(object.validUntilDuration)
      : undefined;
    message.validUntilTime = object.validUntilTime ?? undefined;
    message.validAfterDuration = (object.validAfterDuration !== undefined && object.validAfterDuration !== null)
      ? Duration.fromPartial(object.validAfterDuration)
      : undefined;
    message.validAfterTime = object.validAfterTime ?? undefined;
    message.validInterval = (object.validInterval !== undefined && object.validInterval !== null)
      ? Interval.fromPartial(object.validInterval)
      : undefined;
    return message;
  },
};

function createBaseQueuedResourceState(): QueuedResourceState {
  return {
    state: 0,
    creatingData: undefined,
    acceptedData: undefined,
    provisioningData: undefined,
    failedData: undefined,
    deletingData: undefined,
    activeData: undefined,
    suspendingData: undefined,
    suspendedData: undefined,
    stateInitiator: 0,
  };
}

export const QueuedResourceState: MessageFns<QueuedResourceState> = {
  encode(message: QueuedResourceState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.creatingData !== undefined) {
      QueuedResourceState_CreatingData.encode(message.creatingData, writer.uint32(18).fork()).join();
    }
    if (message.acceptedData !== undefined) {
      QueuedResourceState_AcceptedData.encode(message.acceptedData, writer.uint32(26).fork()).join();
    }
    if (message.provisioningData !== undefined) {
      QueuedResourceState_ProvisioningData.encode(message.provisioningData, writer.uint32(34).fork()).join();
    }
    if (message.failedData !== undefined) {
      QueuedResourceState_FailedData.encode(message.failedData, writer.uint32(42).fork()).join();
    }
    if (message.deletingData !== undefined) {
      QueuedResourceState_DeletingData.encode(message.deletingData, writer.uint32(50).fork()).join();
    }
    if (message.activeData !== undefined) {
      QueuedResourceState_ActiveData.encode(message.activeData, writer.uint32(58).fork()).join();
    }
    if (message.suspendingData !== undefined) {
      QueuedResourceState_SuspendingData.encode(message.suspendingData, writer.uint32(66).fork()).join();
    }
    if (message.suspendedData !== undefined) {
      QueuedResourceState_SuspendedData.encode(message.suspendedData, writer.uint32(74).fork()).join();
    }
    if (message.stateInitiator !== 0) {
      writer.uint32(80).int32(message.stateInitiator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResourceState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResourceState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.creatingData = QueuedResourceState_CreatingData.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.acceptedData = QueuedResourceState_AcceptedData.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.provisioningData = QueuedResourceState_ProvisioningData.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.failedData = QueuedResourceState_FailedData.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.deletingData = QueuedResourceState_DeletingData.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.activeData = QueuedResourceState_ActiveData.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.suspendingData = QueuedResourceState_SuspendingData.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.suspendedData = QueuedResourceState_SuspendedData.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.stateInitiator = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueuedResourceState {
    return {
      state: isSet(object.state) ? queuedResourceState_StateFromJSON(object.state) : 0,
      creatingData: isSet(object.creatingData)
        ? QueuedResourceState_CreatingData.fromJSON(object.creatingData)
        : undefined,
      acceptedData: isSet(object.acceptedData)
        ? QueuedResourceState_AcceptedData.fromJSON(object.acceptedData)
        : undefined,
      provisioningData: isSet(object.provisioningData)
        ? QueuedResourceState_ProvisioningData.fromJSON(object.provisioningData)
        : undefined,
      failedData: isSet(object.failedData) ? QueuedResourceState_FailedData.fromJSON(object.failedData) : undefined,
      deletingData: isSet(object.deletingData)
        ? QueuedResourceState_DeletingData.fromJSON(object.deletingData)
        : undefined,
      activeData: isSet(object.activeData) ? QueuedResourceState_ActiveData.fromJSON(object.activeData) : undefined,
      suspendingData: isSet(object.suspendingData)
        ? QueuedResourceState_SuspendingData.fromJSON(object.suspendingData)
        : undefined,
      suspendedData: isSet(object.suspendedData)
        ? QueuedResourceState_SuspendedData.fromJSON(object.suspendedData)
        : undefined,
      stateInitiator: isSet(object.stateInitiator)
        ? queuedResourceState_StateInitiatorFromJSON(object.stateInitiator)
        : 0,
    };
  },

  toJSON(message: QueuedResourceState): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = queuedResourceState_StateToJSON(message.state);
    }
    if (message.creatingData !== undefined) {
      obj.creatingData = QueuedResourceState_CreatingData.toJSON(message.creatingData);
    }
    if (message.acceptedData !== undefined) {
      obj.acceptedData = QueuedResourceState_AcceptedData.toJSON(message.acceptedData);
    }
    if (message.provisioningData !== undefined) {
      obj.provisioningData = QueuedResourceState_ProvisioningData.toJSON(message.provisioningData);
    }
    if (message.failedData !== undefined) {
      obj.failedData = QueuedResourceState_FailedData.toJSON(message.failedData);
    }
    if (message.deletingData !== undefined) {
      obj.deletingData = QueuedResourceState_DeletingData.toJSON(message.deletingData);
    }
    if (message.activeData !== undefined) {
      obj.activeData = QueuedResourceState_ActiveData.toJSON(message.activeData);
    }
    if (message.suspendingData !== undefined) {
      obj.suspendingData = QueuedResourceState_SuspendingData.toJSON(message.suspendingData);
    }
    if (message.suspendedData !== undefined) {
      obj.suspendedData = QueuedResourceState_SuspendedData.toJSON(message.suspendedData);
    }
    if (message.stateInitiator !== 0) {
      obj.stateInitiator = queuedResourceState_StateInitiatorToJSON(message.stateInitiator);
    }
    return obj;
  },

  create(base?: DeepPartial<QueuedResourceState>): QueuedResourceState {
    return QueuedResourceState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueuedResourceState>): QueuedResourceState {
    const message = createBaseQueuedResourceState();
    message.state = object.state ?? 0;
    message.creatingData = (object.creatingData !== undefined && object.creatingData !== null)
      ? QueuedResourceState_CreatingData.fromPartial(object.creatingData)
      : undefined;
    message.acceptedData = (object.acceptedData !== undefined && object.acceptedData !== null)
      ? QueuedResourceState_AcceptedData.fromPartial(object.acceptedData)
      : undefined;
    message.provisioningData = (object.provisioningData !== undefined && object.provisioningData !== null)
      ? QueuedResourceState_ProvisioningData.fromPartial(object.provisioningData)
      : undefined;
    message.failedData = (object.failedData !== undefined && object.failedData !== null)
      ? QueuedResourceState_FailedData.fromPartial(object.failedData)
      : undefined;
    message.deletingData = (object.deletingData !== undefined && object.deletingData !== null)
      ? QueuedResourceState_DeletingData.fromPartial(object.deletingData)
      : undefined;
    message.activeData = (object.activeData !== undefined && object.activeData !== null)
      ? QueuedResourceState_ActiveData.fromPartial(object.activeData)
      : undefined;
    message.suspendingData = (object.suspendingData !== undefined && object.suspendingData !== null)
      ? QueuedResourceState_SuspendingData.fromPartial(object.suspendingData)
      : undefined;
    message.suspendedData = (object.suspendedData !== undefined && object.suspendedData !== null)
      ? QueuedResourceState_SuspendedData.fromPartial(object.suspendedData)
      : undefined;
    message.stateInitiator = object.stateInitiator ?? 0;
    return message;
  },
};

function createBaseQueuedResourceState_CreatingData(): QueuedResourceState_CreatingData {
  return {};
}

export const QueuedResourceState_CreatingData: MessageFns<QueuedResourceState_CreatingData> = {
  encode(_: QueuedResourceState_CreatingData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResourceState_CreatingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResourceState_CreatingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueuedResourceState_CreatingData {
    return {};
  },

  toJSON(_: QueuedResourceState_CreatingData): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueuedResourceState_CreatingData>): QueuedResourceState_CreatingData {
    return QueuedResourceState_CreatingData.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueuedResourceState_CreatingData>): QueuedResourceState_CreatingData {
    const message = createBaseQueuedResourceState_CreatingData();
    return message;
  },
};

function createBaseQueuedResourceState_AcceptedData(): QueuedResourceState_AcceptedData {
  return {};
}

export const QueuedResourceState_AcceptedData: MessageFns<QueuedResourceState_AcceptedData> = {
  encode(_: QueuedResourceState_AcceptedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResourceState_AcceptedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResourceState_AcceptedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueuedResourceState_AcceptedData {
    return {};
  },

  toJSON(_: QueuedResourceState_AcceptedData): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueuedResourceState_AcceptedData>): QueuedResourceState_AcceptedData {
    return QueuedResourceState_AcceptedData.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueuedResourceState_AcceptedData>): QueuedResourceState_AcceptedData {
    const message = createBaseQueuedResourceState_AcceptedData();
    return message;
  },
};

function createBaseQueuedResourceState_ProvisioningData(): QueuedResourceState_ProvisioningData {
  return {};
}

export const QueuedResourceState_ProvisioningData: MessageFns<QueuedResourceState_ProvisioningData> = {
  encode(_: QueuedResourceState_ProvisioningData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResourceState_ProvisioningData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResourceState_ProvisioningData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueuedResourceState_ProvisioningData {
    return {};
  },

  toJSON(_: QueuedResourceState_ProvisioningData): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueuedResourceState_ProvisioningData>): QueuedResourceState_ProvisioningData {
    return QueuedResourceState_ProvisioningData.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueuedResourceState_ProvisioningData>): QueuedResourceState_ProvisioningData {
    const message = createBaseQueuedResourceState_ProvisioningData();
    return message;
  },
};

function createBaseQueuedResourceState_FailedData(): QueuedResourceState_FailedData {
  return { error: undefined };
}

export const QueuedResourceState_FailedData: MessageFns<QueuedResourceState_FailedData> = {
  encode(message: QueuedResourceState_FailedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResourceState_FailedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResourceState_FailedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueuedResourceState_FailedData {
    return { error: isSet(object.error) ? Status.fromJSON(object.error) : undefined };
  },

  toJSON(message: QueuedResourceState_FailedData): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<QueuedResourceState_FailedData>): QueuedResourceState_FailedData {
    return QueuedResourceState_FailedData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueuedResourceState_FailedData>): QueuedResourceState_FailedData {
    const message = createBaseQueuedResourceState_FailedData();
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseQueuedResourceState_DeletingData(): QueuedResourceState_DeletingData {
  return {};
}

export const QueuedResourceState_DeletingData: MessageFns<QueuedResourceState_DeletingData> = {
  encode(_: QueuedResourceState_DeletingData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResourceState_DeletingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResourceState_DeletingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueuedResourceState_DeletingData {
    return {};
  },

  toJSON(_: QueuedResourceState_DeletingData): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueuedResourceState_DeletingData>): QueuedResourceState_DeletingData {
    return QueuedResourceState_DeletingData.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueuedResourceState_DeletingData>): QueuedResourceState_DeletingData {
    const message = createBaseQueuedResourceState_DeletingData();
    return message;
  },
};

function createBaseQueuedResourceState_ActiveData(): QueuedResourceState_ActiveData {
  return {};
}

export const QueuedResourceState_ActiveData: MessageFns<QueuedResourceState_ActiveData> = {
  encode(_: QueuedResourceState_ActiveData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResourceState_ActiveData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResourceState_ActiveData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueuedResourceState_ActiveData {
    return {};
  },

  toJSON(_: QueuedResourceState_ActiveData): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueuedResourceState_ActiveData>): QueuedResourceState_ActiveData {
    return QueuedResourceState_ActiveData.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueuedResourceState_ActiveData>): QueuedResourceState_ActiveData {
    const message = createBaseQueuedResourceState_ActiveData();
    return message;
  },
};

function createBaseQueuedResourceState_SuspendingData(): QueuedResourceState_SuspendingData {
  return {};
}

export const QueuedResourceState_SuspendingData: MessageFns<QueuedResourceState_SuspendingData> = {
  encode(_: QueuedResourceState_SuspendingData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResourceState_SuspendingData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResourceState_SuspendingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueuedResourceState_SuspendingData {
    return {};
  },

  toJSON(_: QueuedResourceState_SuspendingData): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueuedResourceState_SuspendingData>): QueuedResourceState_SuspendingData {
    return QueuedResourceState_SuspendingData.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueuedResourceState_SuspendingData>): QueuedResourceState_SuspendingData {
    const message = createBaseQueuedResourceState_SuspendingData();
    return message;
  },
};

function createBaseQueuedResourceState_SuspendedData(): QueuedResourceState_SuspendedData {
  return {};
}

export const QueuedResourceState_SuspendedData: MessageFns<QueuedResourceState_SuspendedData> = {
  encode(_: QueuedResourceState_SuspendedData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueuedResourceState_SuspendedData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueuedResourceState_SuspendedData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueuedResourceState_SuspendedData {
    return {};
  },

  toJSON(_: QueuedResourceState_SuspendedData): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<QueuedResourceState_SuspendedData>): QueuedResourceState_SuspendedData {
    return QueuedResourceState_SuspendedData.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<QueuedResourceState_SuspendedData>): QueuedResourceState_SuspendedData {
    const message = createBaseQueuedResourceState_SuspendedData();
    return message;
  },
};

function createBaseListNodesRequest(): ListNodesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListNodesRequest: MessageFns<ListNodesRequest> = {
  encode(message: ListNodesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListNodesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodesRequest>): ListNodesRequest {
    return ListNodesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodesRequest>): ListNodesRequest {
    const message = createBaseListNodesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListNodesResponse(): ListNodesResponse {
  return { nodes: [], nextPageToken: "", unreachable: [] };
}

export const ListNodesResponse: MessageFns<ListNodesResponse> = {
  encode(message: ListNodesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      Node.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNodesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNodesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nodes.push(Node.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNodesResponse {
    return {
      nodes: globalThis.Array.isArray(object?.nodes) ? object.nodes.map((e: any) => Node.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListNodesResponse): unknown {
    const obj: any = {};
    if (message.nodes?.length) {
      obj.nodes = message.nodes.map((e) => Node.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNodesResponse>): ListNodesResponse {
    return ListNodesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNodesResponse>): ListNodesResponse {
    const message = createBaseListNodesResponse();
    message.nodes = object.nodes?.map((e) => Node.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetNodeRequest(): GetNodeRequest {
  return { name: "" };
}

export const GetNodeRequest: MessageFns<GetNodeRequest> = {
  encode(message: GetNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNodeRequest>): GetNodeRequest {
    return GetNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNodeRequest>): GetNodeRequest {
    const message = createBaseGetNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateNodeRequest(): CreateNodeRequest {
  return { parent: "", nodeId: "", node: undefined, requestId: "" };
}

export const CreateNodeRequest: MessageFns<CreateNodeRequest> = {
  encode(message: CreateNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.nodeId !== "") {
      writer.uint32(18).string(message.nodeId);
    }
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(50).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNodeRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateNodeRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateNodeRequest>): CreateNodeRequest {
    return CreateNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateNodeRequest>): CreateNodeRequest {
    const message = createBaseCreateNodeRequest();
    message.parent = object.parent ?? "";
    message.nodeId = object.nodeId ?? "";
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteNodeRequest(): DeleteNodeRequest {
  return { name: "", requestId: "" };
}

export const DeleteNodeRequest: MessageFns<DeleteNodeRequest> = {
  encode(message: DeleteNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNodeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteNodeRequest>): DeleteNodeRequest {
    return DeleteNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteNodeRequest>): DeleteNodeRequest {
    const message = createBaseDeleteNodeRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseStopNodeRequest(): StopNodeRequest {
  return { name: "" };
}

export const StopNodeRequest: MessageFns<StopNodeRequest> = {
  encode(message: StopNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: StopNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<StopNodeRequest>): StopNodeRequest {
    return StopNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopNodeRequest>): StopNodeRequest {
    const message = createBaseStopNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStartNodeRequest(): StartNodeRequest {
  return { name: "" };
}

export const StartNodeRequest: MessageFns<StartNodeRequest> = {
  encode(message: StartNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartNodeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: StartNodeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<StartNodeRequest>): StartNodeRequest {
    return StartNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartNodeRequest>): StartNodeRequest {
    const message = createBaseStartNodeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateNodeRequest(): UpdateNodeRequest {
  return { updateMask: undefined, node: undefined };
}

export const UpdateNodeRequest: MessageFns<UpdateNodeRequest> = {
  encode(message: UpdateNodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.node !== undefined) {
      Node.encode(message.node, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.node = Node.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNodeRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      node: isSet(object.node) ? Node.fromJSON(object.node) : undefined,
    };
  },

  toJSON(message: UpdateNodeRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.node !== undefined) {
      obj.node = Node.toJSON(message.node);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateNodeRequest>): UpdateNodeRequest {
    return UpdateNodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateNodeRequest>): UpdateNodeRequest {
    const message = createBaseUpdateNodeRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.node = (object.node !== undefined && object.node !== null) ? Node.fromPartial(object.node) : undefined;
    return message;
  },
};

function createBaseListQueuedResourcesRequest(): ListQueuedResourcesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListQueuedResourcesRequest: MessageFns<ListQueuedResourcesRequest> = {
  encode(message: ListQueuedResourcesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQueuedResourcesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQueuedResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQueuedResourcesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListQueuedResourcesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListQueuedResourcesRequest>): ListQueuedResourcesRequest {
    return ListQueuedResourcesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListQueuedResourcesRequest>): ListQueuedResourcesRequest {
    const message = createBaseListQueuedResourcesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListQueuedResourcesResponse(): ListQueuedResourcesResponse {
  return { queuedResources: [], nextPageToken: "", unreachable: [] };
}

export const ListQueuedResourcesResponse: MessageFns<ListQueuedResourcesResponse> = {
  encode(message: ListQueuedResourcesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.queuedResources) {
      QueuedResource.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListQueuedResourcesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListQueuedResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queuedResources.push(QueuedResource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListQueuedResourcesResponse {
    return {
      queuedResources: globalThis.Array.isArray(object?.queuedResources)
        ? object.queuedResources.map((e: any) => QueuedResource.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListQueuedResourcesResponse): unknown {
    const obj: any = {};
    if (message.queuedResources?.length) {
      obj.queuedResources = message.queuedResources.map((e) => QueuedResource.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListQueuedResourcesResponse>): ListQueuedResourcesResponse {
    return ListQueuedResourcesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListQueuedResourcesResponse>): ListQueuedResourcesResponse {
    const message = createBaseListQueuedResourcesResponse();
    message.queuedResources = object.queuedResources?.map((e) => QueuedResource.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetQueuedResourceRequest(): GetQueuedResourceRequest {
  return { name: "" };
}

export const GetQueuedResourceRequest: MessageFns<GetQueuedResourceRequest> = {
  encode(message: GetQueuedResourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQueuedResourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQueuedResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQueuedResourceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetQueuedResourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetQueuedResourceRequest>): GetQueuedResourceRequest {
    return GetQueuedResourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetQueuedResourceRequest>): GetQueuedResourceRequest {
    const message = createBaseGetQueuedResourceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateQueuedResourceRequest(): CreateQueuedResourceRequest {
  return { parent: "", queuedResourceId: "", queuedResource: undefined, requestId: "" };
}

export const CreateQueuedResourceRequest: MessageFns<CreateQueuedResourceRequest> = {
  encode(message: CreateQueuedResourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.queuedResourceId !== "") {
      writer.uint32(18).string(message.queuedResourceId);
    }
    if (message.queuedResource !== undefined) {
      QueuedResource.encode(message.queuedResource, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateQueuedResourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateQueuedResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queuedResourceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.queuedResource = QueuedResource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateQueuedResourceRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      queuedResourceId: isSet(object.queuedResourceId) ? globalThis.String(object.queuedResourceId) : "",
      queuedResource: isSet(object.queuedResource) ? QueuedResource.fromJSON(object.queuedResource) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateQueuedResourceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.queuedResourceId !== "") {
      obj.queuedResourceId = message.queuedResourceId;
    }
    if (message.queuedResource !== undefined) {
      obj.queuedResource = QueuedResource.toJSON(message.queuedResource);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateQueuedResourceRequest>): CreateQueuedResourceRequest {
    return CreateQueuedResourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateQueuedResourceRequest>): CreateQueuedResourceRequest {
    const message = createBaseCreateQueuedResourceRequest();
    message.parent = object.parent ?? "";
    message.queuedResourceId = object.queuedResourceId ?? "";
    message.queuedResource = (object.queuedResource !== undefined && object.queuedResource !== null)
      ? QueuedResource.fromPartial(object.queuedResource)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteQueuedResourceRequest(): DeleteQueuedResourceRequest {
  return { name: "", requestId: "", force: false };
}

export const DeleteQueuedResourceRequest: MessageFns<DeleteQueuedResourceRequest> = {
  encode(message: DeleteQueuedResourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteQueuedResourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteQueuedResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteQueuedResourceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteQueuedResourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteQueuedResourceRequest>): DeleteQueuedResourceRequest {
    return DeleteQueuedResourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteQueuedResourceRequest>): DeleteQueuedResourceRequest {
    const message = createBaseDeleteQueuedResourceRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseResetQueuedResourceRequest(): ResetQueuedResourceRequest {
  return { name: "" };
}

export const ResetQueuedResourceRequest: MessageFns<ResetQueuedResourceRequest> = {
  encode(message: ResetQueuedResourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetQueuedResourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetQueuedResourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetQueuedResourceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ResetQueuedResourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ResetQueuedResourceRequest>): ResetQueuedResourceRequest {
    return ResetQueuedResourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResetQueuedResourceRequest>): ResetQueuedResourceRequest {
    const message = createBaseResetQueuedResourceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseServiceIdentity(): ServiceIdentity {
  return { email: "" };
}

export const ServiceIdentity: MessageFns<ServiceIdentity> = {
  encode(message: ServiceIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceIdentity {
    return { email: isSet(object.email) ? globalThis.String(object.email) : "" };
  },

  toJSON(message: ServiceIdentity): unknown {
    const obj: any = {};
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceIdentity>): ServiceIdentity {
    return ServiceIdentity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceIdentity>): ServiceIdentity {
    const message = createBaseServiceIdentity();
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseGenerateServiceIdentityRequest(): GenerateServiceIdentityRequest {
  return { parent: "" };
}

export const GenerateServiceIdentityRequest: MessageFns<GenerateServiceIdentityRequest> = {
  encode(message: GenerateServiceIdentityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateServiceIdentityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateServiceIdentityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateServiceIdentityRequest {
    return { parent: isSet(object.parent) ? globalThis.String(object.parent) : "" };
  },

  toJSON(message: GenerateServiceIdentityRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateServiceIdentityRequest>): GenerateServiceIdentityRequest {
    return GenerateServiceIdentityRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateServiceIdentityRequest>): GenerateServiceIdentityRequest {
    const message = createBaseGenerateServiceIdentityRequest();
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseGenerateServiceIdentityResponse(): GenerateServiceIdentityResponse {
  return { identity: undefined };
}

export const GenerateServiceIdentityResponse: MessageFns<GenerateServiceIdentityResponse> = {
  encode(message: GenerateServiceIdentityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identity !== undefined) {
      ServiceIdentity.encode(message.identity, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateServiceIdentityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateServiceIdentityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.identity = ServiceIdentity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateServiceIdentityResponse {
    return { identity: isSet(object.identity) ? ServiceIdentity.fromJSON(object.identity) : undefined };
  },

  toJSON(message: GenerateServiceIdentityResponse): unknown {
    const obj: any = {};
    if (message.identity !== undefined) {
      obj.identity = ServiceIdentity.toJSON(message.identity);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerateServiceIdentityResponse>): GenerateServiceIdentityResponse {
    return GenerateServiceIdentityResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateServiceIdentityResponse>): GenerateServiceIdentityResponse {
    const message = createBaseGenerateServiceIdentityResponse();
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? ServiceIdentity.fromPartial(object.identity)
      : undefined;
    return message;
  },
};

function createBaseAcceleratorType(): AcceleratorType {
  return { name: "", type: "", acceleratorConfigs: [] };
}

export const AcceleratorType: MessageFns<AcceleratorType> = {
  encode(message: AcceleratorType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    for (const v of message.acceleratorConfigs) {
      AcceleratorConfig.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceleratorType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceleratorType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.acceleratorConfigs.push(AcceleratorConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceleratorType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      acceleratorConfigs: globalThis.Array.isArray(object?.acceleratorConfigs)
        ? object.acceleratorConfigs.map((e: any) => AcceleratorConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AcceleratorType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.acceleratorConfigs?.length) {
      obj.acceleratorConfigs = message.acceleratorConfigs.map((e) => AcceleratorConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AcceleratorType>): AcceleratorType {
    return AcceleratorType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcceleratorType>): AcceleratorType {
    const message = createBaseAcceleratorType();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.acceleratorConfigs = object.acceleratorConfigs?.map((e) => AcceleratorConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetAcceleratorTypeRequest(): GetAcceleratorTypeRequest {
  return { name: "" };
}

export const GetAcceleratorTypeRequest: MessageFns<GetAcceleratorTypeRequest> = {
  encode(message: GetAcceleratorTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAcceleratorTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAcceleratorTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAcceleratorTypeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAcceleratorTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAcceleratorTypeRequest>): GetAcceleratorTypeRequest {
    return GetAcceleratorTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAcceleratorTypeRequest>): GetAcceleratorTypeRequest {
    const message = createBaseGetAcceleratorTypeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListAcceleratorTypesRequest(): ListAcceleratorTypesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListAcceleratorTypesRequest: MessageFns<ListAcceleratorTypesRequest> = {
  encode(message: ListAcceleratorTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(50).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAcceleratorTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAcceleratorTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAcceleratorTypesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListAcceleratorTypesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAcceleratorTypesRequest>): ListAcceleratorTypesRequest {
    return ListAcceleratorTypesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAcceleratorTypesRequest>): ListAcceleratorTypesRequest {
    const message = createBaseListAcceleratorTypesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListAcceleratorTypesResponse(): ListAcceleratorTypesResponse {
  return { acceleratorTypes: [], nextPageToken: "", unreachable: [] };
}

export const ListAcceleratorTypesResponse: MessageFns<ListAcceleratorTypesResponse> = {
  encode(message: ListAcceleratorTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.acceleratorTypes) {
      AcceleratorType.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAcceleratorTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAcceleratorTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.acceleratorTypes.push(AcceleratorType.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAcceleratorTypesResponse {
    return {
      acceleratorTypes: globalThis.Array.isArray(object?.acceleratorTypes)
        ? object.acceleratorTypes.map((e: any) => AcceleratorType.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListAcceleratorTypesResponse): unknown {
    const obj: any = {};
    if (message.acceleratorTypes?.length) {
      obj.acceleratorTypes = message.acceleratorTypes.map((e) => AcceleratorType.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAcceleratorTypesResponse>): ListAcceleratorTypesResponse {
    return ListAcceleratorTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAcceleratorTypesResponse>): ListAcceleratorTypesResponse {
    const message = createBaseListAcceleratorTypesResponse();
    message.acceleratorTypes = object.acceleratorTypes?.map((e) => AcceleratorType.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseRuntimeVersion(): RuntimeVersion {
  return { name: "", version: "" };
}

export const RuntimeVersion: MessageFns<RuntimeVersion> = {
  encode(message: RuntimeVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeVersion {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: RuntimeVersion): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeVersion>): RuntimeVersion {
    return RuntimeVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeVersion>): RuntimeVersion {
    const message = createBaseRuntimeVersion();
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseGetRuntimeVersionRequest(): GetRuntimeVersionRequest {
  return { name: "" };
}

export const GetRuntimeVersionRequest: MessageFns<GetRuntimeVersionRequest> = {
  encode(message: GetRuntimeVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRuntimeVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRuntimeVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRuntimeVersionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRuntimeVersionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRuntimeVersionRequest>): GetRuntimeVersionRequest {
    return GetRuntimeVersionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRuntimeVersionRequest>): GetRuntimeVersionRequest {
    const message = createBaseGetRuntimeVersionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListRuntimeVersionsRequest(): ListRuntimeVersionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListRuntimeVersionsRequest: MessageFns<ListRuntimeVersionsRequest> = {
  encode(message: ListRuntimeVersionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(50).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuntimeVersionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuntimeVersionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuntimeVersionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListRuntimeVersionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuntimeVersionsRequest>): ListRuntimeVersionsRequest {
    return ListRuntimeVersionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuntimeVersionsRequest>): ListRuntimeVersionsRequest {
    const message = createBaseListRuntimeVersionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListRuntimeVersionsResponse(): ListRuntimeVersionsResponse {
  return { runtimeVersions: [], nextPageToken: "", unreachable: [] };
}

export const ListRuntimeVersionsResponse: MessageFns<ListRuntimeVersionsResponse> = {
  encode(message: ListRuntimeVersionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runtimeVersions) {
      RuntimeVersion.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuntimeVersionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuntimeVersionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.runtimeVersions.push(RuntimeVersion.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuntimeVersionsResponse {
    return {
      runtimeVersions: globalThis.Array.isArray(object?.runtimeVersions)
        ? object.runtimeVersions.map((e: any) => RuntimeVersion.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListRuntimeVersionsResponse): unknown {
    const obj: any = {};
    if (message.runtimeVersions?.length) {
      obj.runtimeVersions = message.runtimeVersions.map((e) => RuntimeVersion.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuntimeVersionsResponse>): ListRuntimeVersionsResponse {
    return ListRuntimeVersionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuntimeVersionsResponse>): ListRuntimeVersionsResponse {
    const message = createBaseListRuntimeVersionsResponse();
    message.runtimeVersions = object.runtimeVersions?.map((e) => RuntimeVersion.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusDetail: "",
    cancelRequested: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusDetail !== "") {
      writer.uint32(42).string(message.statusDetail);
    }
    if (message.cancelRequested !== false) {
      writer.uint32(48).bool(message.cancelRequested);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusDetail = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.cancelRequested = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusDetail: isSet(object.statusDetail) ? globalThis.String(object.statusDetail) : "",
      cancelRequested: isSet(object.cancelRequested) ? globalThis.Boolean(object.cancelRequested) : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusDetail !== "") {
      obj.statusDetail = message.statusDetail;
    }
    if (message.cancelRequested !== false) {
      obj.cancelRequested = message.cancelRequested;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusDetail = object.statusDetail ?? "";
    message.cancelRequested = object.cancelRequested ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseSymptom(): Symptom {
  return { createTime: undefined, symptomType: 0, details: "", workerId: "" };
}

export const Symptom: MessageFns<Symptom> = {
  encode(message: Symptom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.symptomType !== 0) {
      writer.uint32(16).int32(message.symptomType);
    }
    if (message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    if (message.workerId !== "") {
      writer.uint32(34).string(message.workerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Symptom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSymptom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.symptomType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workerId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Symptom {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      symptomType: isSet(object.symptomType) ? symptom_SymptomTypeFromJSON(object.symptomType) : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
    };
  },

  toJSON(message: Symptom): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.symptomType !== 0) {
      obj.symptomType = symptom_SymptomTypeToJSON(message.symptomType);
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    return obj;
  },

  create(base?: DeepPartial<Symptom>): Symptom {
    return Symptom.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Symptom>): Symptom {
    const message = createBaseSymptom();
    message.createTime = object.createTime ?? undefined;
    message.symptomType = object.symptomType ?? 0;
    message.details = object.details ?? "";
    message.workerId = object.workerId ?? "";
    return message;
  },
};

function createBaseGetGuestAttributesRequest(): GetGuestAttributesRequest {
  return { name: "", queryPath: "", workerIds: [] };
}

export const GetGuestAttributesRequest: MessageFns<GetGuestAttributesRequest> = {
  encode(message: GetGuestAttributesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.queryPath !== "") {
      writer.uint32(18).string(message.queryPath);
    }
    for (const v of message.workerIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGuestAttributesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGuestAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.queryPath = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.workerIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGuestAttributesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      queryPath: isSet(object.queryPath) ? globalThis.String(object.queryPath) : "",
      workerIds: globalThis.Array.isArray(object?.workerIds)
        ? object.workerIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetGuestAttributesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.queryPath !== "") {
      obj.queryPath = message.queryPath;
    }
    if (message.workerIds?.length) {
      obj.workerIds = message.workerIds;
    }
    return obj;
  },

  create(base?: DeepPartial<GetGuestAttributesRequest>): GetGuestAttributesRequest {
    return GetGuestAttributesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetGuestAttributesRequest>): GetGuestAttributesRequest {
    const message = createBaseGetGuestAttributesRequest();
    message.name = object.name ?? "";
    message.queryPath = object.queryPath ?? "";
    message.workerIds = object.workerIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetGuestAttributesResponse(): GetGuestAttributesResponse {
  return { guestAttributes: [] };
}

export const GetGuestAttributesResponse: MessageFns<GetGuestAttributesResponse> = {
  encode(message: GetGuestAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.guestAttributes) {
      GuestAttributes.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetGuestAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetGuestAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.guestAttributes.push(GuestAttributes.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetGuestAttributesResponse {
    return {
      guestAttributes: globalThis.Array.isArray(object?.guestAttributes)
        ? object.guestAttributes.map((e: any) => GuestAttributes.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetGuestAttributesResponse): unknown {
    const obj: any = {};
    if (message.guestAttributes?.length) {
      obj.guestAttributes = message.guestAttributes.map((e) => GuestAttributes.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetGuestAttributesResponse>): GetGuestAttributesResponse {
    return GetGuestAttributesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetGuestAttributesResponse>): GetGuestAttributesResponse {
    const message = createBaseGetGuestAttributesResponse();
    message.guestAttributes = object.guestAttributes?.map((e) => GuestAttributes.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSimulateMaintenanceEventRequest(): SimulateMaintenanceEventRequest {
  return { name: "", workerIds: [] };
}

export const SimulateMaintenanceEventRequest: MessageFns<SimulateMaintenanceEventRequest> = {
  encode(message: SimulateMaintenanceEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.workerIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimulateMaintenanceEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimulateMaintenanceEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workerIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimulateMaintenanceEventRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      workerIds: globalThis.Array.isArray(object?.workerIds)
        ? object.workerIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SimulateMaintenanceEventRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.workerIds?.length) {
      obj.workerIds = message.workerIds;
    }
    return obj;
  },

  create(base?: DeepPartial<SimulateMaintenanceEventRequest>): SimulateMaintenanceEventRequest {
    return SimulateMaintenanceEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SimulateMaintenanceEventRequest>): SimulateMaintenanceEventRequest {
    const message = createBaseSimulateMaintenanceEventRequest();
    message.name = object.name ?? "";
    message.workerIds = object.workerIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseAcceleratorConfig(): AcceleratorConfig {
  return { type: 0, topology: "" };
}

export const AcceleratorConfig: MessageFns<AcceleratorConfig> = {
  encode(message: AcceleratorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.topology !== "") {
      writer.uint32(18).string(message.topology);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceleratorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceleratorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topology = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceleratorConfig {
    return {
      type: isSet(object.type) ? acceleratorConfig_TypeFromJSON(object.type) : 0,
      topology: isSet(object.topology) ? globalThis.String(object.topology) : "",
    };
  },

  toJSON(message: AcceleratorConfig): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = acceleratorConfig_TypeToJSON(message.type);
    }
    if (message.topology !== "") {
      obj.topology = message.topology;
    }
    return obj;
  },

  create(base?: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    return AcceleratorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    const message = createBaseAcceleratorConfig();
    message.type = object.type ?? 0;
    message.topology = object.topology ?? "";
    return message;
  },
};

function createBaseShieldedInstanceConfig(): ShieldedInstanceConfig {
  return { enableSecureBoot: false };
}

export const ShieldedInstanceConfig: MessageFns<ShieldedInstanceConfig> = {
  encode(message: ShieldedInstanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableSecureBoot !== false) {
      writer.uint32(8).bool(message.enableSecureBoot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShieldedInstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShieldedInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableSecureBoot = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShieldedInstanceConfig {
    return { enableSecureBoot: isSet(object.enableSecureBoot) ? globalThis.Boolean(object.enableSecureBoot) : false };
  },

  toJSON(message: ShieldedInstanceConfig): unknown {
    const obj: any = {};
    if (message.enableSecureBoot !== false) {
      obj.enableSecureBoot = message.enableSecureBoot;
    }
    return obj;
  },

  create(base?: DeepPartial<ShieldedInstanceConfig>): ShieldedInstanceConfig {
    return ShieldedInstanceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShieldedInstanceConfig>): ShieldedInstanceConfig {
    const message = createBaseShieldedInstanceConfig();
    message.enableSecureBoot = object.enableSecureBoot ?? false;
    return message;
  },
};

function createBaseBootDiskConfig(): BootDiskConfig {
  return { customerEncryptionKey: undefined, enableConfidentialCompute: false };
}

export const BootDiskConfig: MessageFns<BootDiskConfig> = {
  encode(message: BootDiskConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerEncryptionKey !== undefined) {
      CustomerEncryptionKey.encode(message.customerEncryptionKey, writer.uint32(10).fork()).join();
    }
    if (message.enableConfidentialCompute !== false) {
      writer.uint32(16).bool(message.enableConfidentialCompute);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BootDiskConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBootDiskConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerEncryptionKey = CustomerEncryptionKey.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableConfidentialCompute = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BootDiskConfig {
    return {
      customerEncryptionKey: isSet(object.customerEncryptionKey)
        ? CustomerEncryptionKey.fromJSON(object.customerEncryptionKey)
        : undefined,
      enableConfidentialCompute: isSet(object.enableConfidentialCompute)
        ? globalThis.Boolean(object.enableConfidentialCompute)
        : false,
    };
  },

  toJSON(message: BootDiskConfig): unknown {
    const obj: any = {};
    if (message.customerEncryptionKey !== undefined) {
      obj.customerEncryptionKey = CustomerEncryptionKey.toJSON(message.customerEncryptionKey);
    }
    if (message.enableConfidentialCompute !== false) {
      obj.enableConfidentialCompute = message.enableConfidentialCompute;
    }
    return obj;
  },

  create(base?: DeepPartial<BootDiskConfig>): BootDiskConfig {
    return BootDiskConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BootDiskConfig>): BootDiskConfig {
    const message = createBaseBootDiskConfig();
    message.customerEncryptionKey =
      (object.customerEncryptionKey !== undefined && object.customerEncryptionKey !== null)
        ? CustomerEncryptionKey.fromPartial(object.customerEncryptionKey)
        : undefined;
    message.enableConfidentialCompute = object.enableConfidentialCompute ?? false;
    return message;
  },
};

function createBaseCustomerEncryptionKey(): CustomerEncryptionKey {
  return { kmsKeyName: undefined };
}

export const CustomerEncryptionKey: MessageFns<CustomerEncryptionKey> = {
  encode(message: CustomerEncryptionKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kmsKeyName !== undefined) {
      writer.uint32(58).string(message.kmsKeyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomerEncryptionKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerEncryptionKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 7:
          if (tag !== 58) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerEncryptionKey {
    return { kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : undefined };
  },

  toJSON(message: CustomerEncryptionKey): unknown {
    const obj: any = {};
    if (message.kmsKeyName !== undefined) {
      obj.kmsKeyName = message.kmsKeyName;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomerEncryptionKey>): CustomerEncryptionKey {
    return CustomerEncryptionKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomerEncryptionKey>): CustomerEncryptionKey {
    const message = createBaseCustomerEncryptionKey();
    message.kmsKeyName = object.kmsKeyName ?? undefined;
    return message;
  },
};

/**
 * Manages TPU nodes and other resources
 *
 * TPU API v2alpha1
 */
export type TpuDefinition = typeof TpuDefinition;
export const TpuDefinition = {
  name: "Tpu",
  fullName: "google.cloud.tpu.v2alpha1.Tpu",
  methods: {
    /** Lists nodes. */
    listNodes: {
      name: "ListNodes",
      requestType: ListNodesRequest,
      requestStream: false,
      responseType: ListNodesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a node. */
    getNode: {
      name: "GetNode",
      requestType: GetNodeRequest,
      requestStream: false,
      responseType: Node,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a node. */
    createNode: {
      name: "CreateNode",
      requestType: CreateNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              19,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              110,
              111,
              100,
              101,
              44,
              110,
              111,
              100,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              55,
              58,
              4,
              110,
              111,
              100,
              101,
              34,
              47,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              110,
              111,
              100,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a node. */
    deleteNode: {
      name: "DeleteNode",
      requestType: DeleteNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              42,
              47,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Stops a node. This operation is only available with single TPU nodes. */
    stopNode: {
      name: "StopNode",
      requestType: StopNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              57,
              58,
              1,
              42,
              34,
              52,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              111,
              112,
            ]),
          ],
        },
      },
    },
    /** Starts a node. */
    startNode: {
      name: "StartNode",
      requestType: StartNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              116,
              97,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /** Updates the configurations of a node. */
    updateNode: {
      name: "UpdateNode",
      requestType: UpdateNodeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([16, 110, 111, 100, 101, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              60,
              58,
              4,
              110,
              111,
              100,
              101,
              50,
              52,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              111,
              100,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists queued resources. */
    listQueuedResources: {
      name: "ListQueuedResources",
      requestType: ListQueuedResourcesRequest,
      requestStream: false,
      responseType: ListQueuedResourcesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              113,
              117,
              101,
              117,
              101,
              100,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets details of a queued resource. */
    getQueuedResource: {
      name: "GetQueuedResource",
      requestType: GetQueuedResourceRequest,
      requestStream: false,
      responseType: QueuedResource,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              100,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a QueuedResource TPU instance. */
    createQueuedResource: {
      name: "CreateQueuedResource",
      requestType: CreateQueuedResourceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              35,
              10,
              14,
              81,
              117,
              101,
              117,
              101,
              100,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              41,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              113,
              117,
              101,
              117,
              101,
              100,
              95,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              44,
              113,
              117,
              101,
              117,
              101,
              100,
              95,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              76,
              58,
              15,
              113,
              117,
              101,
              117,
              101,
              100,
              95,
              114,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              34,
              57,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              113,
              117,
              101,
              117,
              101,
              100,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a QueuedResource TPU instance. */
    deleteQueuedResource: {
      name: "DeleteQueuedResource",
      requestType: DeleteQueuedResourceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              35,
              10,
              14,
              81,
              117,
              101,
              117,
              101,
              100,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              42,
              57,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              100,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Resets a QueuedResource TPU instance */
    resetQueuedResource: {
      name: "ResetQueuedResource",
      requestType: ResetQueuedResourceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              35,
              10,
              14,
              81,
              117,
              101,
              117,
              101,
              100,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              68,
              58,
              1,
              42,
              34,
              63,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              113,
              117,
              101,
              117,
              101,
              100,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              101,
              116,
            ]),
          ],
        },
      },
    },
    /** Generates the Cloud TPU service identity for the project. */
    generateServiceIdentity: {
      name: "GenerateServiceIdentity",
      requestType: GenerateServiceIdentityRequest,
      requestStream: false,
      responseType: GenerateServiceIdentityResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              70,
              58,
              1,
              42,
              34,
              65,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              110,
              101,
              114,
              97,
              116,
              101,
              83,
              101,
              114,
              118,
              105,
              99,
              101,
              73,
              100,
              101,
              110,
              116,
              105,
              116,
              121,
            ]),
          ],
        },
      },
    },
    /** Lists accelerator types supported by this API. */
    listAcceleratorTypes: {
      name: "ListAcceleratorTypes",
      requestType: ListAcceleratorTypesRequest,
      requestStream: false,
      responseType: ListAcceleratorTypesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              99,
              99,
              101,
              108,
              101,
              114,
              97,
              116,
              111,
              114,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets AcceleratorType. */
    getAcceleratorType: {
      name: "GetAcceleratorType",
      requestType: GetAcceleratorTypeRequest,
      requestStream: false,
      responseType: AcceleratorType,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              108,
              101,
              114,
              97,
              116,
              111,
              114,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists runtime versions supported by this API. */
    listRuntimeVersions: {
      name: "ListRuntimeVersions",
      requestType: ListRuntimeVersionsRequest,
      requestStream: false,
      responseType: ListRuntimeVersionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              117,
              110,
              116,
              105,
              109,
              101,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a runtime version. */
    getRuntimeVersion: {
      name: "GetRuntimeVersion",
      requestType: GetRuntimeVersionRequest,
      requestStream: false,
      responseType: RuntimeVersion,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              117,
              110,
              116,
              105,
              109,
              101,
              86,
              101,
              114,
              115,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Retrieves the guest attributes for the node. */
    getGuestAttributes: {
      name: "GetGuestAttributes",
      requestType: GetGuestAttributesRequest,
      requestStream: false,
      responseType: GetGuestAttributesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              71,
              58,
              1,
              42,
              34,
              66,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
              58,
              103,
              101,
              116,
              71,
              117,
              101,
              115,
              116,
              65,
              116,
              116,
              114,
              105,
              98,
              117,
              116,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Simulates a maintenance event. */
    simulateMaintenanceEvent: {
      name: "SimulateMaintenanceEvent",
      requestType: SimulateMaintenanceEventRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              25,
              10,
              4,
              78,
              111,
              100,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              77,
              58,
              1,
              42,
              34,
              72,
              47,
              118,
              50,
              97,
              108,
              112,
              104,
              97,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              110,
              111,
              100,
              101,
              115,
              47,
              42,
              125,
              58,
              115,
              105,
              109,
              117,
              108,
              97,
              116,
              101,
              77,
              97,
              105,
              110,
              116,
              101,
              110,
              97,
              110,
              99,
              101,
              69,
              118,
              101,
              110,
              116,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TpuServiceImplementation<CallContextExt = {}> {
  /** Lists nodes. */
  listNodes(request: ListNodesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListNodesResponse>>;
  /** Gets the details of a node. */
  getNode(request: GetNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Node>>;
  /** Creates a node. */
  createNode(request: CreateNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a node. */
  deleteNode(request: DeleteNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Stops a node. This operation is only available with single TPU nodes. */
  stopNode(request: StopNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Starts a node. */
  startNode(request: StartNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the configurations of a node. */
  updateNode(request: UpdateNodeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Lists queued resources. */
  listQueuedResources(
    request: ListQueuedResourcesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListQueuedResourcesResponse>>;
  /** Gets details of a queued resource. */
  getQueuedResource(
    request: GetQueuedResourceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<QueuedResource>>;
  /** Creates a QueuedResource TPU instance. */
  createQueuedResource(
    request: CreateQueuedResourceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a QueuedResource TPU instance. */
  deleteQueuedResource(
    request: DeleteQueuedResourceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Resets a QueuedResource TPU instance */
  resetQueuedResource(
    request: ResetQueuedResourceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Generates the Cloud TPU service identity for the project. */
  generateServiceIdentity(
    request: GenerateServiceIdentityRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GenerateServiceIdentityResponse>>;
  /** Lists accelerator types supported by this API. */
  listAcceleratorTypes(
    request: ListAcceleratorTypesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAcceleratorTypesResponse>>;
  /** Gets AcceleratorType. */
  getAcceleratorType(
    request: GetAcceleratorTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AcceleratorType>>;
  /** Lists runtime versions supported by this API. */
  listRuntimeVersions(
    request: ListRuntimeVersionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRuntimeVersionsResponse>>;
  /** Gets a runtime version. */
  getRuntimeVersion(
    request: GetRuntimeVersionRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RuntimeVersion>>;
  /** Retrieves the guest attributes for the node. */
  getGuestAttributes(
    request: GetGuestAttributesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetGuestAttributesResponse>>;
  /** Simulates a maintenance event. */
  simulateMaintenanceEvent(
    request: SimulateMaintenanceEventRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface TpuClient<CallOptionsExt = {}> {
  /** Lists nodes. */
  listNodes(request: DeepPartial<ListNodesRequest>, options?: CallOptions & CallOptionsExt): Promise<ListNodesResponse>;
  /** Gets the details of a node. */
  getNode(request: DeepPartial<GetNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Node>;
  /** Creates a node. */
  createNode(request: DeepPartial<CreateNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a node. */
  deleteNode(request: DeepPartial<DeleteNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Stops a node. This operation is only available with single TPU nodes. */
  stopNode(request: DeepPartial<StopNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Starts a node. */
  startNode(request: DeepPartial<StartNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the configurations of a node. */
  updateNode(request: DeepPartial<UpdateNodeRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Lists queued resources. */
  listQueuedResources(
    request: DeepPartial<ListQueuedResourcesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListQueuedResourcesResponse>;
  /** Gets details of a queued resource. */
  getQueuedResource(
    request: DeepPartial<GetQueuedResourceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<QueuedResource>;
  /** Creates a QueuedResource TPU instance. */
  createQueuedResource(
    request: DeepPartial<CreateQueuedResourceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a QueuedResource TPU instance. */
  deleteQueuedResource(
    request: DeepPartial<DeleteQueuedResourceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Resets a QueuedResource TPU instance */
  resetQueuedResource(
    request: DeepPartial<ResetQueuedResourceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Generates the Cloud TPU service identity for the project. */
  generateServiceIdentity(
    request: DeepPartial<GenerateServiceIdentityRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GenerateServiceIdentityResponse>;
  /** Lists accelerator types supported by this API. */
  listAcceleratorTypes(
    request: DeepPartial<ListAcceleratorTypesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAcceleratorTypesResponse>;
  /** Gets AcceleratorType. */
  getAcceleratorType(
    request: DeepPartial<GetAcceleratorTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AcceleratorType>;
  /** Lists runtime versions supported by this API. */
  listRuntimeVersions(
    request: DeepPartial<ListRuntimeVersionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRuntimeVersionsResponse>;
  /** Gets a runtime version. */
  getRuntimeVersion(
    request: DeepPartial<GetRuntimeVersionRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RuntimeVersion>;
  /** Retrieves the guest attributes for the node. */
  getGuestAttributes(
    request: DeepPartial<GetGuestAttributesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetGuestAttributesResponse>;
  /** Simulates a maintenance event. */
  simulateMaintenanceEvent(
    request: DeepPartial<SimulateMaintenanceEventRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
