// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/integrations/v1alpha/task_config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Coordinate } from "./coordinate.js";
import { EventParameter } from "./event_parameter.js";
import { JsonValidationOption, jsonValidationOptionFromJSON, jsonValidationOptionToJSON } from "./json_validation.js";

export const protobufPackage = "google.cloud.integrations.v1alpha";

/**
 * The task configuration details. This is not the implementation of Task.
 * There might be multiple TaskConfigs for the same Task.
 */
export interface TaskConfig {
  /** Optional. The name for the task. */
  task: string;
  /**
   * Required. The identifier of this task within its parent event config,
   * specified by the client. This should be unique among all the tasks belong
   * to the same event config. We use this field as the identifier to
   * find next tasks (via field `next_tasks.task_id`).
   */
  taskId: string;
  /** Optional. The customized parameters the user can pass to this task. */
  parameters: { [key: string]: EventParameter };
  /**
   * Optional. Determines the number of times the
   * task will be retried on failure and with what retry strategy.
   * This is applicable for asynchronous calls to Eventbus alone (Post To
   * Queue, Schedule etc.).
   */
  failurePolicy:
    | FailurePolicy
    | undefined;
  /**
   * Optional. Determines the number of times the
   * task will be retried on failure and with what retry strategy.
   * This is applicable for synchronous calls to Eventbus alone (Post).
   */
  synchronousCallFailurePolicy:
    | FailurePolicy
    | undefined;
  /**
   * Optional. The set of tasks that are next in line to be executed as per the
   * execution graph defined for the parent event, specified by
   * `event_config_id`. Each of these next tasks are executed
   * only if the condition associated with them evaluates to true.
   */
  nextTasks: NextTask[];
  /**
   * Optional. The policy dictating the execution of the next set of tasks for
   * the current task.
   */
  nextTasksExecutionPolicy: TaskConfig_NextTasksExecutionPolicy;
  /** Optional. The policy dictating the execution strategy of this task. */
  taskExecutionStrategy: TaskConfig_TaskExecutionStrategy;
  /**
   * Optional. User-provided label that is attached to this TaskConfig in the
   * UI.
   */
  displayName: string;
  /** Optional. Determines what action to take upon successful task completion. */
  successPolicy:
    | SuccessPolicy
    | undefined;
  /**
   * Optional. If set, overrides the option configured in the Task
   * implementation class.
   */
  jsonValidationOption: JsonValidationOption;
  /**
   * Optional. User-provided description intended to give additional business
   * context about the task.
   */
  description: string;
  /**
   * Optional. Used to define task-template name if task is of type
   * task-template
   */
  taskTemplate: string;
  /**
   * Optional. Optional
   * Error catcher id of the error catch flow which will be executed when
   * execution error happens in the task
   */
  errorCatcherId: string;
  /** Optional. External task type of the task */
  externalTaskType: TaskConfig_ExternalTaskType;
  /**
   * Optional. Informs the front-end application where to draw this error
   * catcher config on the UI.
   */
  position: Coordinate | undefined;
}

/** Various policies for executing the next set of tasks. */
export enum TaskConfig_NextTasksExecutionPolicy {
  /** NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED - Default. */
  NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED = 0,
  /** RUN_ALL_MATCH - Execute all the tasks that satisfy their associated condition. */
  RUN_ALL_MATCH = 1,
  /** RUN_FIRST_MATCH - Execute the first task that satisfies the associated condition. */
  RUN_FIRST_MATCH = 2,
  UNRECOGNIZED = -1,
}

export function taskConfig_NextTasksExecutionPolicyFromJSON(object: any): TaskConfig_NextTasksExecutionPolicy {
  switch (object) {
    case 0:
    case "NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED":
      return TaskConfig_NextTasksExecutionPolicy.NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED;
    case 1:
    case "RUN_ALL_MATCH":
      return TaskConfig_NextTasksExecutionPolicy.RUN_ALL_MATCH;
    case 2:
    case "RUN_FIRST_MATCH":
      return TaskConfig_NextTasksExecutionPolicy.RUN_FIRST_MATCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskConfig_NextTasksExecutionPolicy.UNRECOGNIZED;
  }
}

export function taskConfig_NextTasksExecutionPolicyToJSON(object: TaskConfig_NextTasksExecutionPolicy): string {
  switch (object) {
    case TaskConfig_NextTasksExecutionPolicy.NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED:
      return "NEXT_TASKS_EXECUTION_POLICY_UNSPECIFIED";
    case TaskConfig_NextTasksExecutionPolicy.RUN_ALL_MATCH:
      return "RUN_ALL_MATCH";
    case TaskConfig_NextTasksExecutionPolicy.RUN_FIRST_MATCH:
      return "RUN_FIRST_MATCH";
    case TaskConfig_NextTasksExecutionPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Various policies to trigger the execution of this task. */
export enum TaskConfig_TaskExecutionStrategy {
  /**
   * TASK_EXECUTION_STRATEGY_UNSPECIFIED - Default. If the strategy is not set explicitly, it will default to
   * `WHEN_ALL_SUCCEED`.
   */
  TASK_EXECUTION_STRATEGY_UNSPECIFIED = 0,
  /**
   * WHEN_ALL_SUCCEED - Wait until all of its previous tasks finished execution, then verify at
   * least one of the edge conditions is met, and execute if possible. This
   * should be considered as WHEN_ALL_TASKS_SUCCEED.
   */
  WHEN_ALL_SUCCEED = 1,
  /**
   * WHEN_ANY_SUCCEED - Start execution as long as any of its previous tasks finished execution
   * and the corresponding edge condition is met (since we will execute if
   * only that succeeding edge condition is met).
   */
  WHEN_ANY_SUCCEED = 2,
  /**
   * WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED - Wait until all of its previous tasks finished execution, then verify
   * the all edge conditions are met and execute if possible.
   */
  WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED = 3,
  UNRECOGNIZED = -1,
}

export function taskConfig_TaskExecutionStrategyFromJSON(object: any): TaskConfig_TaskExecutionStrategy {
  switch (object) {
    case 0:
    case "TASK_EXECUTION_STRATEGY_UNSPECIFIED":
      return TaskConfig_TaskExecutionStrategy.TASK_EXECUTION_STRATEGY_UNSPECIFIED;
    case 1:
    case "WHEN_ALL_SUCCEED":
      return TaskConfig_TaskExecutionStrategy.WHEN_ALL_SUCCEED;
    case 2:
    case "WHEN_ANY_SUCCEED":
      return TaskConfig_TaskExecutionStrategy.WHEN_ANY_SUCCEED;
    case 3:
    case "WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED":
      return TaskConfig_TaskExecutionStrategy.WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskConfig_TaskExecutionStrategy.UNRECOGNIZED;
  }
}

export function taskConfig_TaskExecutionStrategyToJSON(object: TaskConfig_TaskExecutionStrategy): string {
  switch (object) {
    case TaskConfig_TaskExecutionStrategy.TASK_EXECUTION_STRATEGY_UNSPECIFIED:
      return "TASK_EXECUTION_STRATEGY_UNSPECIFIED";
    case TaskConfig_TaskExecutionStrategy.WHEN_ALL_SUCCEED:
      return "WHEN_ALL_SUCCEED";
    case TaskConfig_TaskExecutionStrategy.WHEN_ANY_SUCCEED:
      return "WHEN_ANY_SUCCEED";
    case TaskConfig_TaskExecutionStrategy.WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED:
      return "WHEN_ALL_TASKS_AND_CONDITIONS_SUCCEED";
    case TaskConfig_TaskExecutionStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines the type of the task for external customer */
export enum TaskConfig_ExternalTaskType {
  /** EXTERNAL_TASK_TYPE_UNSPECIFIED - Default value. External task type is not specified */
  EXTERNAL_TASK_TYPE_UNSPECIFIED = 0,
  /** NORMAL_TASK - Tasks belongs to the normal task flows */
  NORMAL_TASK = 1,
  /** ERROR_TASK - Task belongs to the error catch task flows */
  ERROR_TASK = 2,
  UNRECOGNIZED = -1,
}

export function taskConfig_ExternalTaskTypeFromJSON(object: any): TaskConfig_ExternalTaskType {
  switch (object) {
    case 0:
    case "EXTERNAL_TASK_TYPE_UNSPECIFIED":
      return TaskConfig_ExternalTaskType.EXTERNAL_TASK_TYPE_UNSPECIFIED;
    case 1:
    case "NORMAL_TASK":
      return TaskConfig_ExternalTaskType.NORMAL_TASK;
    case 2:
    case "ERROR_TASK":
      return TaskConfig_ExternalTaskType.ERROR_TASK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskConfig_ExternalTaskType.UNRECOGNIZED;
  }
}

export function taskConfig_ExternalTaskTypeToJSON(object: TaskConfig_ExternalTaskType): string {
  switch (object) {
    case TaskConfig_ExternalTaskType.EXTERNAL_TASK_TYPE_UNSPECIFIED:
      return "EXTERNAL_TASK_TYPE_UNSPECIFIED";
    case TaskConfig_ExternalTaskType.NORMAL_TASK:
      return "NORMAL_TASK";
    case TaskConfig_ExternalTaskType.ERROR_TASK:
      return "ERROR_TASK";
    case TaskConfig_ExternalTaskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TaskConfig_ParametersEntry {
  key: string;
  value: EventParameter | undefined;
}

/**
 * Policy that dictates the behavior for the task after it completes
 * successfully.
 */
export interface SuccessPolicy {
  /**
   * State to which the execution snapshot status will be set if the task
   * succeeds.
   */
  finalState: SuccessPolicy_FinalState;
}

/** The state of execution. */
export enum SuccessPolicy_FinalState {
  /** FINAL_STATE_UNSPECIFIED - UNSPECIFIED. */
  FINAL_STATE_UNSPECIFIED = 0,
  /** SUCCEEDED - The default behavior, where successful tasks will be marked as SUCCEEDED. */
  SUCCEEDED = 1,
  /**
   * SUSPENDED - Sets the state to SUSPENDED after executing.  This is required for
   * SuspensionTask; event execution will continue once the user calls
   * ResolveSuspensions with the event_execution_info_id and the task number.
   */
  SUSPENDED = 2,
  UNRECOGNIZED = -1,
}

export function successPolicy_FinalStateFromJSON(object: any): SuccessPolicy_FinalState {
  switch (object) {
    case 0:
    case "FINAL_STATE_UNSPECIFIED":
      return SuccessPolicy_FinalState.FINAL_STATE_UNSPECIFIED;
    case 1:
    case "SUCCEEDED":
      return SuccessPolicy_FinalState.SUCCEEDED;
    case 2:
    case "SUSPENDED":
      return SuccessPolicy_FinalState.SUSPENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SuccessPolicy_FinalState.UNRECOGNIZED;
  }
}

export function successPolicy_FinalStateToJSON(object: SuccessPolicy_FinalState): string {
  switch (object) {
    case SuccessPolicy_FinalState.FINAL_STATE_UNSPECIFIED:
      return "FINAL_STATE_UNSPECIFIED";
    case SuccessPolicy_FinalState.SUCCEEDED:
      return "SUCCEEDED";
    case SuccessPolicy_FinalState.SUSPENDED:
      return "SUSPENDED";
    case SuccessPolicy_FinalState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Policy that defines the task retry logic and failure type. If no
 * FailurePolicy is defined for a task, all its dependent tasks will not be
 * executed (i.e, a `retry_strategy` of NONE will be applied).
 */
export interface FailurePolicy {
  /** Defines what happens to the task upon failure. */
  retryStrategy: FailurePolicy_RetryStrategy;
  /**
   * Required if retry_strategy is FIXED_INTERVAL or
   * LINEAR/EXPONENTIAL_BACKOFF/RESTART_INTEGRATION_WITH_BACKOFF. Defines the
   * number of times the task will be retried if failed.
   */
  maxRetries: number;
  /**
   * Required if retry_strategy is FIXED_INTERVAL or
   * LINEAR/EXPONENTIAL_BACKOFF/RESTART_INTEGRATION_WITH_BACKOFF. Defines the
   * initial interval in seconds for backoff.
   */
  intervalTime: Date | undefined;
}

/** The behavior when the taks failed. */
export enum FailurePolicy_RetryStrategy {
  /** RETRY_STRATEGY_UNSPECIFIED - UNSPECIFIED. */
  RETRY_STRATEGY_UNSPECIFIED = 0,
  /**
   * IGNORE - Ignores the failure of this task. The rest of the integration will be
   * executed Assuming this task succeeded.
   */
  IGNORE = 1,
  /**
   * NONE - Causes a permanent failure of the task. However, if the last task(s)
   * of event was successfully completed despite the failure of this task,
   * it has no impact on the integration.
   */
  NONE = 2,
  /**
   * FATAL - Causes a permanent failure of the event. It is different from NONE
   * because this will mark the event as FAILED by shutting down the
   * event execution.
   */
  FATAL = 3,
  /**
   * FIXED_INTERVAL - The task will be retried from the failed task onwards after a fixed
   * delay. A max-retry count is required to be specified with this
   * strategy. A jitter is added to each exponential interval so that
   * concurrently failing tasks of the same type do not end up retrying
   * after the exact same exponential interval. max_retries and
   * interval_in_seconds must be specified.
   */
  FIXED_INTERVAL = 4,
  /**
   * LINEAR_BACKOFF - The task will be retried from the failed task onwards after a fixed
   * delay that linearly increases with each retry attempt. A jitter is
   * added to each exponential interval so that concurrently failing tasks
   * of the same type do not end up retrying after the exact same
   * exponential interval. A max-retry count is required to be specified
   * with this strategy. max_retries and interval_in_seconds must be
   * specified.
   */
  LINEAR_BACKOFF = 5,
  /**
   * EXPONENTIAL_BACKOFF - The task will be retried after an exponentially increasing period of
   * time with each failure. A jitter is added to each exponential interval
   * so that concurrently failing tasks of the same type do not end up
   * retrying after the exact same exponential interval. A max-retry count
   * is required to be specified with this strategy. `max_retries` and
   * `interval_in_seconds` must be specified.
   */
  EXPONENTIAL_BACKOFF = 6,
  /**
   * RESTART_INTEGRATION_WITH_BACKOFF - The entire integration will be restarted with the initial parameters that
   * were set when the event was fired. A max-retry count is required to be
   * specified with this strategy. `max_retries` and `interval_in_seconds`
   * must be specified.
   */
  RESTART_INTEGRATION_WITH_BACKOFF = 7,
  UNRECOGNIZED = -1,
}

export function failurePolicy_RetryStrategyFromJSON(object: any): FailurePolicy_RetryStrategy {
  switch (object) {
    case 0:
    case "RETRY_STRATEGY_UNSPECIFIED":
      return FailurePolicy_RetryStrategy.RETRY_STRATEGY_UNSPECIFIED;
    case 1:
    case "IGNORE":
      return FailurePolicy_RetryStrategy.IGNORE;
    case 2:
    case "NONE":
      return FailurePolicy_RetryStrategy.NONE;
    case 3:
    case "FATAL":
      return FailurePolicy_RetryStrategy.FATAL;
    case 4:
    case "FIXED_INTERVAL":
      return FailurePolicy_RetryStrategy.FIXED_INTERVAL;
    case 5:
    case "LINEAR_BACKOFF":
      return FailurePolicy_RetryStrategy.LINEAR_BACKOFF;
    case 6:
    case "EXPONENTIAL_BACKOFF":
      return FailurePolicy_RetryStrategy.EXPONENTIAL_BACKOFF;
    case 7:
    case "RESTART_INTEGRATION_WITH_BACKOFF":
      return FailurePolicy_RetryStrategy.RESTART_INTEGRATION_WITH_BACKOFF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FailurePolicy_RetryStrategy.UNRECOGNIZED;
  }
}

export function failurePolicy_RetryStrategyToJSON(object: FailurePolicy_RetryStrategy): string {
  switch (object) {
    case FailurePolicy_RetryStrategy.RETRY_STRATEGY_UNSPECIFIED:
      return "RETRY_STRATEGY_UNSPECIFIED";
    case FailurePolicy_RetryStrategy.IGNORE:
      return "IGNORE";
    case FailurePolicy_RetryStrategy.NONE:
      return "NONE";
    case FailurePolicy_RetryStrategy.FATAL:
      return "FATAL";
    case FailurePolicy_RetryStrategy.FIXED_INTERVAL:
      return "FIXED_INTERVAL";
    case FailurePolicy_RetryStrategy.LINEAR_BACKOFF:
      return "LINEAR_BACKOFF";
    case FailurePolicy_RetryStrategy.EXPONENTIAL_BACKOFF:
      return "EXPONENTIAL_BACKOFF";
    case FailurePolicy_RetryStrategy.RESTART_INTEGRATION_WITH_BACKOFF:
      return "RESTART_INTEGRATION_WITH_BACKOFF";
    case FailurePolicy_RetryStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The task that is next in line to be executed, if the
 * condition specified evaluated to true.
 */
export interface NextTask {
  /** ID of the next task. */
  taskConfigId: string;
  /** Task number of the next task. */
  taskId: string;
  /** Standard filter expression for this task to become an eligible next task. */
  condition: string;
  /** User-provided label that is attached to this edge in the UI. */
  displayName: string;
  /**
   * User-provided description intended to give additional business context
   * about the task.
   */
  description: string;
}

function createBaseTaskConfig(): TaskConfig {
  return {
    task: "",
    taskId: "",
    parameters: {},
    failurePolicy: undefined,
    synchronousCallFailurePolicy: undefined,
    nextTasks: [],
    nextTasksExecutionPolicy: 0,
    taskExecutionStrategy: 0,
    displayName: "",
    successPolicy: undefined,
    jsonValidationOption: 0,
    description: "",
    taskTemplate: "",
    errorCatcherId: "",
    externalTaskType: 0,
    position: undefined,
  };
}

export const TaskConfig: MessageFns<TaskConfig> = {
  encode(message: TaskConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.task !== "") {
      writer.uint32(10).string(message.task);
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      TaskConfig_ParametersEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.failurePolicy !== undefined) {
      FailurePolicy.encode(message.failurePolicy, writer.uint32(34).fork()).join();
    }
    if (message.synchronousCallFailurePolicy !== undefined) {
      FailurePolicy.encode(message.synchronousCallFailurePolicy, writer.uint32(42).fork()).join();
    }
    for (const v of message.nextTasks) {
      NextTask.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.nextTasksExecutionPolicy !== 0) {
      writer.uint32(56).int32(message.nextTasksExecutionPolicy);
    }
    if (message.taskExecutionStrategy !== 0) {
      writer.uint32(64).int32(message.taskExecutionStrategy);
    }
    if (message.displayName !== "") {
      writer.uint32(74).string(message.displayName);
    }
    if (message.successPolicy !== undefined) {
      SuccessPolicy.encode(message.successPolicy, writer.uint32(82).fork()).join();
    }
    if (message.jsonValidationOption !== 0) {
      writer.uint32(88).int32(message.jsonValidationOption);
    }
    if (message.description !== "") {
      writer.uint32(98).string(message.description);
    }
    if (message.taskTemplate !== "") {
      writer.uint32(106).string(message.taskTemplate);
    }
    if (message.errorCatcherId !== "") {
      writer.uint32(138).string(message.errorCatcherId);
    }
    if (message.externalTaskType !== 0) {
      writer.uint32(120).int32(message.externalTaskType);
    }
    if (message.position !== undefined) {
      Coordinate.encode(message.position, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.task = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = TaskConfig_ParametersEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.parameters[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.failurePolicy = FailurePolicy.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.synchronousCallFailurePolicy = FailurePolicy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nextTasks.push(NextTask.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.nextTasksExecutionPolicy = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.taskExecutionStrategy = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.successPolicy = SuccessPolicy.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.jsonValidationOption = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.description = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.taskTemplate = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.errorCatcherId = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.externalTaskType = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.position = Coordinate.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskConfig {
    return {
      task: isSet(object.task) ? globalThis.String(object.task) : "",
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: EventParameter }>((acc, [key, value]) => {
          acc[key] = EventParameter.fromJSON(value);
          return acc;
        }, {})
        : {},
      failurePolicy: isSet(object.failurePolicy) ? FailurePolicy.fromJSON(object.failurePolicy) : undefined,
      synchronousCallFailurePolicy: isSet(object.synchronousCallFailurePolicy)
        ? FailurePolicy.fromJSON(object.synchronousCallFailurePolicy)
        : undefined,
      nextTasks: globalThis.Array.isArray(object?.nextTasks)
        ? object.nextTasks.map((e: any) => NextTask.fromJSON(e))
        : [],
      nextTasksExecutionPolicy: isSet(object.nextTasksExecutionPolicy)
        ? taskConfig_NextTasksExecutionPolicyFromJSON(object.nextTasksExecutionPolicy)
        : 0,
      taskExecutionStrategy: isSet(object.taskExecutionStrategy)
        ? taskConfig_TaskExecutionStrategyFromJSON(object.taskExecutionStrategy)
        : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      successPolicy: isSet(object.successPolicy) ? SuccessPolicy.fromJSON(object.successPolicy) : undefined,
      jsonValidationOption: isSet(object.jsonValidationOption)
        ? jsonValidationOptionFromJSON(object.jsonValidationOption)
        : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      taskTemplate: isSet(object.taskTemplate) ? globalThis.String(object.taskTemplate) : "",
      errorCatcherId: isSet(object.errorCatcherId) ? globalThis.String(object.errorCatcherId) : "",
      externalTaskType: isSet(object.externalTaskType)
        ? taskConfig_ExternalTaskTypeFromJSON(object.externalTaskType)
        : 0,
      position: isSet(object.position) ? Coordinate.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: TaskConfig): unknown {
    const obj: any = {};
    if (message.task !== "") {
      obj.task = message.task;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = EventParameter.toJSON(v);
        });
      }
    }
    if (message.failurePolicy !== undefined) {
      obj.failurePolicy = FailurePolicy.toJSON(message.failurePolicy);
    }
    if (message.synchronousCallFailurePolicy !== undefined) {
      obj.synchronousCallFailurePolicy = FailurePolicy.toJSON(message.synchronousCallFailurePolicy);
    }
    if (message.nextTasks?.length) {
      obj.nextTasks = message.nextTasks.map((e) => NextTask.toJSON(e));
    }
    if (message.nextTasksExecutionPolicy !== 0) {
      obj.nextTasksExecutionPolicy = taskConfig_NextTasksExecutionPolicyToJSON(message.nextTasksExecutionPolicy);
    }
    if (message.taskExecutionStrategy !== 0) {
      obj.taskExecutionStrategy = taskConfig_TaskExecutionStrategyToJSON(message.taskExecutionStrategy);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.successPolicy !== undefined) {
      obj.successPolicy = SuccessPolicy.toJSON(message.successPolicy);
    }
    if (message.jsonValidationOption !== 0) {
      obj.jsonValidationOption = jsonValidationOptionToJSON(message.jsonValidationOption);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.taskTemplate !== "") {
      obj.taskTemplate = message.taskTemplate;
    }
    if (message.errorCatcherId !== "") {
      obj.errorCatcherId = message.errorCatcherId;
    }
    if (message.externalTaskType !== 0) {
      obj.externalTaskType = taskConfig_ExternalTaskTypeToJSON(message.externalTaskType);
    }
    if (message.position !== undefined) {
      obj.position = Coordinate.toJSON(message.position);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskConfig>): TaskConfig {
    return TaskConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskConfig>): TaskConfig {
    const message = createBaseTaskConfig();
    message.task = object.task ?? "";
    message.taskId = object.taskId ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: EventParameter }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = EventParameter.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.failurePolicy = (object.failurePolicy !== undefined && object.failurePolicy !== null)
      ? FailurePolicy.fromPartial(object.failurePolicy)
      : undefined;
    message.synchronousCallFailurePolicy =
      (object.synchronousCallFailurePolicy !== undefined && object.synchronousCallFailurePolicy !== null)
        ? FailurePolicy.fromPartial(object.synchronousCallFailurePolicy)
        : undefined;
    message.nextTasks = object.nextTasks?.map((e) => NextTask.fromPartial(e)) || [];
    message.nextTasksExecutionPolicy = object.nextTasksExecutionPolicy ?? 0;
    message.taskExecutionStrategy = object.taskExecutionStrategy ?? 0;
    message.displayName = object.displayName ?? "";
    message.successPolicy = (object.successPolicy !== undefined && object.successPolicy !== null)
      ? SuccessPolicy.fromPartial(object.successPolicy)
      : undefined;
    message.jsonValidationOption = object.jsonValidationOption ?? 0;
    message.description = object.description ?? "";
    message.taskTemplate = object.taskTemplate ?? "";
    message.errorCatcherId = object.errorCatcherId ?? "";
    message.externalTaskType = object.externalTaskType ?? 0;
    message.position = (object.position !== undefined && object.position !== null)
      ? Coordinate.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseTaskConfig_ParametersEntry(): TaskConfig_ParametersEntry {
  return { key: "", value: undefined };
}

export const TaskConfig_ParametersEntry: MessageFns<TaskConfig_ParametersEntry> = {
  encode(message: TaskConfig_ParametersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      EventParameter.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskConfig_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskConfig_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = EventParameter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskConfig_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? EventParameter.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: TaskConfig_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = EventParameter.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<TaskConfig_ParametersEntry>): TaskConfig_ParametersEntry {
    return TaskConfig_ParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskConfig_ParametersEntry>): TaskConfig_ParametersEntry {
    const message = createBaseTaskConfig_ParametersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? EventParameter.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSuccessPolicy(): SuccessPolicy {
  return { finalState: 0 };
}

export const SuccessPolicy: MessageFns<SuccessPolicy> = {
  encode(message: SuccessPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.finalState !== 0) {
      writer.uint32(8).int32(message.finalState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuccessPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuccessPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.finalState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuccessPolicy {
    return { finalState: isSet(object.finalState) ? successPolicy_FinalStateFromJSON(object.finalState) : 0 };
  },

  toJSON(message: SuccessPolicy): unknown {
    const obj: any = {};
    if (message.finalState !== 0) {
      obj.finalState = successPolicy_FinalStateToJSON(message.finalState);
    }
    return obj;
  },

  create(base?: DeepPartial<SuccessPolicy>): SuccessPolicy {
    return SuccessPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuccessPolicy>): SuccessPolicy {
    const message = createBaseSuccessPolicy();
    message.finalState = object.finalState ?? 0;
    return message;
  },
};

function createBaseFailurePolicy(): FailurePolicy {
  return { retryStrategy: 0, maxRetries: 0, intervalTime: undefined };
}

export const FailurePolicy: MessageFns<FailurePolicy> = {
  encode(message: FailurePolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retryStrategy !== 0) {
      writer.uint32(8).int32(message.retryStrategy);
    }
    if (message.maxRetries !== 0) {
      writer.uint32(16).int32(message.maxRetries);
    }
    if (message.intervalTime !== undefined) {
      Timestamp.encode(toTimestamp(message.intervalTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FailurePolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailurePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.retryStrategy = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxRetries = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intervalTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FailurePolicy {
    return {
      retryStrategy: isSet(object.retryStrategy) ? failurePolicy_RetryStrategyFromJSON(object.retryStrategy) : 0,
      maxRetries: isSet(object.maxRetries) ? globalThis.Number(object.maxRetries) : 0,
      intervalTime: isSet(object.intervalTime) ? fromJsonTimestamp(object.intervalTime) : undefined,
    };
  },

  toJSON(message: FailurePolicy): unknown {
    const obj: any = {};
    if (message.retryStrategy !== 0) {
      obj.retryStrategy = failurePolicy_RetryStrategyToJSON(message.retryStrategy);
    }
    if (message.maxRetries !== 0) {
      obj.maxRetries = Math.round(message.maxRetries);
    }
    if (message.intervalTime !== undefined) {
      obj.intervalTime = message.intervalTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<FailurePolicy>): FailurePolicy {
    return FailurePolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FailurePolicy>): FailurePolicy {
    const message = createBaseFailurePolicy();
    message.retryStrategy = object.retryStrategy ?? 0;
    message.maxRetries = object.maxRetries ?? 0;
    message.intervalTime = object.intervalTime ?? undefined;
    return message;
  },
};

function createBaseNextTask(): NextTask {
  return { taskConfigId: "", taskId: "", condition: "", displayName: "", description: "" };
}

export const NextTask: MessageFns<NextTask> = {
  encode(message: NextTask, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskConfigId !== "") {
      writer.uint32(10).string(message.taskConfigId);
    }
    if (message.taskId !== "") {
      writer.uint32(18).string(message.taskId);
    }
    if (message.condition !== "") {
      writer.uint32(26).string(message.condition);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NextTask {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNextTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskConfigId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NextTask {
    return {
      taskConfigId: isSet(object.taskConfigId) ? globalThis.String(object.taskConfigId) : "",
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: NextTask): unknown {
    const obj: any = {};
    if (message.taskConfigId !== "") {
      obj.taskConfigId = message.taskConfigId;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<NextTask>): NextTask {
    return NextTask.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NextTask>): NextTask {
    const message = createBaseNextTask();
    message.taskConfigId = object.taskConfigId ?? "";
    message.taskId = object.taskId ?? "";
    message.condition = object.condition ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
