// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/integrations/v1alpha/log_entries.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { CloudLoggingDetails } from "./cloud_logging_details.js";
import { EventParameter } from "./event_parameter.js";
import { IntegrationState, integrationStateFromJSON, integrationStateToJSON } from "./integration_state.js";
import { TaskConfig } from "./task_config.js";

export const protobufPackage = "google.cloud.integrations.v1alpha";

/**
 * Specifies whether this execution info corresponds to actual integration or
 * test case.
 */
export enum ExecutionType {
  /** EXECUTION_TYPE_UNSPECIFIED - Unspecified value. */
  EXECUTION_TYPE_UNSPECIFIED = 0,
  /** INTEGRATION_VERSION - Execution corresponds to run of an integration version. */
  INTEGRATION_VERSION = 1,
  /** TEST_CASE - Execution corresponds to run of a functional test case. */
  TEST_CASE = 2,
  UNRECOGNIZED = -1,
}

export function executionTypeFromJSON(object: any): ExecutionType {
  switch (object) {
    case 0:
    case "EXECUTION_TYPE_UNSPECIFIED":
      return ExecutionType.EXECUTION_TYPE_UNSPECIFIED;
    case 1:
    case "INTEGRATION_VERSION":
      return ExecutionType.INTEGRATION_VERSION;
    case 2:
    case "TEST_CASE":
      return ExecutionType.TEST_CASE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionType.UNRECOGNIZED;
  }
}

export function executionTypeToJSON(object: ExecutionType): string {
  switch (object) {
    case ExecutionType.EXECUTION_TYPE_UNSPECIFIED:
      return "EXECUTION_TYPE_UNSPECIFIED";
    case ExecutionType.INTEGRATION_VERSION:
      return "INTEGRATION_VERSION";
    case ExecutionType.TEST_CASE:
      return "TEST_CASE";
    case ExecutionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Log entry to log execution info for the monitored resource
 * `integrations.googleapis.com/IntegrationVersion`.
 */
export interface ExecutionInfo {
  /** Name of the integration. */
  integration: string;
  /** The customer's project number. */
  projectId: string;
  /**
   * The trigger id of the integration trigger config. If both trigger_id
   * and client_id is present, the integration is executed from the start tasks
   * provided by the matching trigger config otherwise it is executed from the
   * default start tasks.
   */
  triggerId: string;
  /** Execution parameters come in as part of the request. */
  requestParams: { [key: string]: EventParameter };
  /** Execution parameters come out as part of the response. */
  responseParams: { [key: string]: EventParameter };
  /**
   * Errors, warnings, and informationals associated with the workflow/task.
   * The order in which the errors were added by the workflow/task is
   * maintained.
   */
  errors: ErrorDetail[];
  /** The configuration details for a task. */
  taskConfigs: TaskConfig[];
  /** Pointer to the active version it is executing. */
  integrationVersionNumber: string;
  /** Auto-generated primary key. */
  executionId: string;
  /** Output only. State of the integration version */
  integrationVersionState: IntegrationState;
  /** Database persistence policy for execution info */
  enableDatabasePersistence: boolean;
  /** Cloud Logging details for execution info */
  cloudLoggingDetails:
    | CloudLoggingDetails
    | undefined;
  /** The details about this integration execution. */
  integrationExecutionDetails:
    | IntegrationExecutionDetails
    | undefined;
  /**
   * Specifies whether this execution info corresponds to actual integration or
   * test case.
   */
  executionType: ExecutionType;
  /** The ways user posts this event. */
  executionMethod: ExecutionInfo_ExecutionMethod;
  /**
   * An increasing sequence that is set when a new snapshot (Integration
   * Version) is created.
   */
  integrationSnapshotNumber: Long;
}

/** ExecutionMethod Enum */
export enum ExecutionInfo_ExecutionMethod {
  /** EXECUTION_METHOD_UNSPECIFIED - Default value. */
  EXECUTION_METHOD_UNSPECIFIED = 0,
  /** POST - Sync post. */
  POST = 1,
  /** SCHEDULE - Async post with schedule time. */
  SCHEDULE = 2,
  /** POST_TO_QUEUE - Async post. */
  POST_TO_QUEUE = 3,
  UNRECOGNIZED = -1,
}

export function executionInfo_ExecutionMethodFromJSON(object: any): ExecutionInfo_ExecutionMethod {
  switch (object) {
    case 0:
    case "EXECUTION_METHOD_UNSPECIFIED":
      return ExecutionInfo_ExecutionMethod.EXECUTION_METHOD_UNSPECIFIED;
    case 1:
    case "POST":
      return ExecutionInfo_ExecutionMethod.POST;
    case 2:
    case "SCHEDULE":
      return ExecutionInfo_ExecutionMethod.SCHEDULE;
    case 3:
    case "POST_TO_QUEUE":
      return ExecutionInfo_ExecutionMethod.POST_TO_QUEUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionInfo_ExecutionMethod.UNRECOGNIZED;
  }
}

export function executionInfo_ExecutionMethodToJSON(object: ExecutionInfo_ExecutionMethod): string {
  switch (object) {
    case ExecutionInfo_ExecutionMethod.EXECUTION_METHOD_UNSPECIFIED:
      return "EXECUTION_METHOD_UNSPECIFIED";
    case ExecutionInfo_ExecutionMethod.POST:
      return "POST";
    case ExecutionInfo_ExecutionMethod.SCHEDULE:
      return "SCHEDULE";
    case ExecutionInfo_ExecutionMethod.POST_TO_QUEUE:
      return "POST_TO_QUEUE";
    case ExecutionInfo_ExecutionMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ExecutionInfo_RequestParamsEntry {
  key: string;
  value: EventParameter | undefined;
}

export interface ExecutionInfo_ResponseParamsEntry {
  key: string;
  value: EventParameter | undefined;
}

/**
 * Contains the details of the execution info: this includes the tasks execution
 * details plus the integration execution statistics.
 */
export interface IntegrationExecutionDetails {
  /** Output only. The execution state of this Integration. */
  integrationExecutionState: IntegrationExecutionDetails_IntegrationExecutionState;
  /** Execution snapshot. */
  integrationExecutionSnapshot: IntegrationExecutionSnapshot[];
  /** Status for the current execution attempt. */
  executionAttemptStats: AttemptStats[];
  /**
   * Next scheduled execution time in case the execution status was
   * RETRY_ON_HOLD.
   */
  nextExecutionTime:
    | Date
    | undefined;
  /**
   * Indicates the number of times the execution has restarted from the
   * beginning.
   */
  executionRetriesCount: number;
}

/** Enum ExecutionState. */
export enum IntegrationExecutionDetails_IntegrationExecutionState {
  /** INTEGRATION_EXECUTION_STATE_UNSPECIFIED - Default value. */
  INTEGRATION_EXECUTION_STATE_UNSPECIFIED = 0,
  /**
   * ON_HOLD - Integration is received and waiting for the execution. This happens when
   * firing the Integration via "postToQueue" or "schedule".
   */
  ON_HOLD = 1,
  /** IN_PROCESS - Integration is under processing. */
  IN_PROCESS = 2,
  /**
   * SUCCEEDED - Integration execution successfully finished. There's no more change after
   * this state.
   */
  SUCCEEDED = 3,
  /** FAILED - Integration execution failed. There's no more change after this state. */
  FAILED = 4,
  /**
   * CANCELLED - Integration execution canceled by user. There's no more change after this
   * state.
   */
  CANCELLED = 5,
  /** RETRY_ON_HOLD - Integration execution failed and waiting for retry. */
  RETRY_ON_HOLD = 6,
  /** SUSPENDED - Integration execution suspended and waiting for manual intervention. */
  SUSPENDED = 7,
  UNRECOGNIZED = -1,
}

export function integrationExecutionDetails_IntegrationExecutionStateFromJSON(
  object: any,
): IntegrationExecutionDetails_IntegrationExecutionState {
  switch (object) {
    case 0:
    case "INTEGRATION_EXECUTION_STATE_UNSPECIFIED":
      return IntegrationExecutionDetails_IntegrationExecutionState.INTEGRATION_EXECUTION_STATE_UNSPECIFIED;
    case 1:
    case "ON_HOLD":
      return IntegrationExecutionDetails_IntegrationExecutionState.ON_HOLD;
    case 2:
    case "IN_PROCESS":
      return IntegrationExecutionDetails_IntegrationExecutionState.IN_PROCESS;
    case 3:
    case "SUCCEEDED":
      return IntegrationExecutionDetails_IntegrationExecutionState.SUCCEEDED;
    case 4:
    case "FAILED":
      return IntegrationExecutionDetails_IntegrationExecutionState.FAILED;
    case 5:
    case "CANCELLED":
      return IntegrationExecutionDetails_IntegrationExecutionState.CANCELLED;
    case 6:
    case "RETRY_ON_HOLD":
      return IntegrationExecutionDetails_IntegrationExecutionState.RETRY_ON_HOLD;
    case 7:
    case "SUSPENDED":
      return IntegrationExecutionDetails_IntegrationExecutionState.SUSPENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IntegrationExecutionDetails_IntegrationExecutionState.UNRECOGNIZED;
  }
}

export function integrationExecutionDetails_IntegrationExecutionStateToJSON(
  object: IntegrationExecutionDetails_IntegrationExecutionState,
): string {
  switch (object) {
    case IntegrationExecutionDetails_IntegrationExecutionState.INTEGRATION_EXECUTION_STATE_UNSPECIFIED:
      return "INTEGRATION_EXECUTION_STATE_UNSPECIFIED";
    case IntegrationExecutionDetails_IntegrationExecutionState.ON_HOLD:
      return "ON_HOLD";
    case IntegrationExecutionDetails_IntegrationExecutionState.IN_PROCESS:
      return "IN_PROCESS";
    case IntegrationExecutionDetails_IntegrationExecutionState.SUCCEEDED:
      return "SUCCEEDED";
    case IntegrationExecutionDetails_IntegrationExecutionState.FAILED:
      return "FAILED";
    case IntegrationExecutionDetails_IntegrationExecutionState.CANCELLED:
      return "CANCELLED";
    case IntegrationExecutionDetails_IntegrationExecutionState.RETRY_ON_HOLD:
      return "RETRY_ON_HOLD";
    case IntegrationExecutionDetails_IntegrationExecutionState.SUSPENDED:
      return "SUSPENDED";
    case IntegrationExecutionDetails_IntegrationExecutionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Contains the snapshot of the integration execution for a given checkpoint. */
export interface IntegrationExecutionSnapshot {
  /**
   * Indicates "right after which checkpoint task's execution" this snapshot
   * is taken.
   */
  checkpointTaskNumber: string;
  /** Indicates when this snapshot is taken. */
  snapshotTime:
    | Date
    | undefined;
  /** Snapshot metadata. */
  integrationExecutionSnapshotMetadata:
    | IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata
    | undefined;
  /** All of the task execution details at the given point of time. */
  taskExecutionDetails: TaskExecutionDetails[];
  /** All of the computed conditions that been calculated. */
  conditionResults: ConditionResult[];
  /** The parameters in Event object. */
  executionParams: { [key: string]: EventParameter };
}

/** Metadata for the integration/task retry. */
export interface IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata {
  /** The task number associated with this snapshot. Could be empty. */
  taskNumber: string;
  /** the task name associated with this snapshot. Could be empty. */
  task: string;
  /** the integration execution attempt number this snapshot belongs to. */
  integrationExecutionAttemptNum: number;
  /** the task attempt number this snapshot belongs to. Could be empty. */
  taskAttemptNum: number;
  /** the task label associated with this snapshot. Could be empty. */
  taskLabel: string;
  /**
   * Ancestor task number for the task(it will only be non-empty if the task
   * is under 'private workflow')
   */
  ancestorTaskNumbers: string[];
  /**
   * Ancestor iteration number for the task(it will only be non-empty if the
   * task is under 'private workflow')
   */
  ancestorIterationNumbers: string[];
  /** The direct integration which the event execution snapshots belongs to */
  integration: string;
}

export interface IntegrationExecutionSnapshot_ExecutionParamsEntry {
  key: string;
  value: EventParameter | undefined;
}

/** Contains the details of the execution of this task. */
export interface TaskExecutionDetails {
  /** Pointer to the task config it used for execution. */
  taskNumber: string;
  /** The execution state of this task. */
  taskExecutionState: TaskExecutionDetails_TaskExecutionState;
  /** Status for the current task execution attempt. */
  taskAttemptStats: AttemptStats[];
}

/** Enum TaskExecutionState. */
export enum TaskExecutionDetails_TaskExecutionState {
  /** TASK_EXECUTION_STATE_UNSPECIFIED - Default value. */
  TASK_EXECUTION_STATE_UNSPECIFIED = 0,
  /**
   * PENDING_EXECUTION - Task is waiting for its precondition tasks to finish to start the
   * execution.
   */
  PENDING_EXECUTION = 1,
  /** IN_PROCESS - Task is under processing. */
  IN_PROCESS = 2,
  /**
   * SUCCEED - Task execution successfully finished. There's no more change after
   * this state.
   */
  SUCCEED = 3,
  /** FAILED - Task execution failed. There's no more change after this state. */
  FAILED = 4,
  /**
   * FATAL - Task execution failed and cause the whole integration execution to fail
   * immediately. There's no more change after this state.
   */
  FATAL = 5,
  /** RETRY_ON_HOLD - Task execution failed and waiting for retry. */
  RETRY_ON_HOLD = 6,
  /**
   * SKIPPED - Task execution skipped. This happens when its precondition wasn't met,
   * or the integration execution been canceled before reach to the task.
   * There's no more changes after this state.
   */
  SKIPPED = 7,
  /**
   * CANCELLED - Task execution canceled when in progress. This happens when integration
   * execution been canceled or any other task fall in fatal state.
   */
  CANCELLED = 8,
  /**
   * PENDING_ROLLBACK - Task is waiting for its dependency tasks' rollback to finish to start
   * its rollback.
   */
  PENDING_ROLLBACK = 9,
  /** ROLLBACK_IN_PROCESS - Task is rolling back. */
  ROLLBACK_IN_PROCESS = 10,
  /**
   * ROLLEDBACK - Task is rolled back. This is the state we will set regardless of
   * rollback succeeding or failing.
   */
  ROLLEDBACK = 11,
  /**
   * SUSPENDED - Task is a SuspensionTask which has executed once, creating a pending
   * suspension.
   */
  SUSPENDED = 12,
  UNRECOGNIZED = -1,
}

export function taskExecutionDetails_TaskExecutionStateFromJSON(object: any): TaskExecutionDetails_TaskExecutionState {
  switch (object) {
    case 0:
    case "TASK_EXECUTION_STATE_UNSPECIFIED":
      return TaskExecutionDetails_TaskExecutionState.TASK_EXECUTION_STATE_UNSPECIFIED;
    case 1:
    case "PENDING_EXECUTION":
      return TaskExecutionDetails_TaskExecutionState.PENDING_EXECUTION;
    case 2:
    case "IN_PROCESS":
      return TaskExecutionDetails_TaskExecutionState.IN_PROCESS;
    case 3:
    case "SUCCEED":
      return TaskExecutionDetails_TaskExecutionState.SUCCEED;
    case 4:
    case "FAILED":
      return TaskExecutionDetails_TaskExecutionState.FAILED;
    case 5:
    case "FATAL":
      return TaskExecutionDetails_TaskExecutionState.FATAL;
    case 6:
    case "RETRY_ON_HOLD":
      return TaskExecutionDetails_TaskExecutionState.RETRY_ON_HOLD;
    case 7:
    case "SKIPPED":
      return TaskExecutionDetails_TaskExecutionState.SKIPPED;
    case 8:
    case "CANCELLED":
      return TaskExecutionDetails_TaskExecutionState.CANCELLED;
    case 9:
    case "PENDING_ROLLBACK":
      return TaskExecutionDetails_TaskExecutionState.PENDING_ROLLBACK;
    case 10:
    case "ROLLBACK_IN_PROCESS":
      return TaskExecutionDetails_TaskExecutionState.ROLLBACK_IN_PROCESS;
    case 11:
    case "ROLLEDBACK":
      return TaskExecutionDetails_TaskExecutionState.ROLLEDBACK;
    case 12:
    case "SUSPENDED":
      return TaskExecutionDetails_TaskExecutionState.SUSPENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskExecutionDetails_TaskExecutionState.UNRECOGNIZED;
  }
}

export function taskExecutionDetails_TaskExecutionStateToJSON(object: TaskExecutionDetails_TaskExecutionState): string {
  switch (object) {
    case TaskExecutionDetails_TaskExecutionState.TASK_EXECUTION_STATE_UNSPECIFIED:
      return "TASK_EXECUTION_STATE_UNSPECIFIED";
    case TaskExecutionDetails_TaskExecutionState.PENDING_EXECUTION:
      return "PENDING_EXECUTION";
    case TaskExecutionDetails_TaskExecutionState.IN_PROCESS:
      return "IN_PROCESS";
    case TaskExecutionDetails_TaskExecutionState.SUCCEED:
      return "SUCCEED";
    case TaskExecutionDetails_TaskExecutionState.FAILED:
      return "FAILED";
    case TaskExecutionDetails_TaskExecutionState.FATAL:
      return "FATAL";
    case TaskExecutionDetails_TaskExecutionState.RETRY_ON_HOLD:
      return "RETRY_ON_HOLD";
    case TaskExecutionDetails_TaskExecutionState.SKIPPED:
      return "SKIPPED";
    case TaskExecutionDetails_TaskExecutionState.CANCELLED:
      return "CANCELLED";
    case TaskExecutionDetails_TaskExecutionState.PENDING_ROLLBACK:
      return "PENDING_ROLLBACK";
    case TaskExecutionDetails_TaskExecutionState.ROLLBACK_IN_PROCESS:
      return "ROLLBACK_IN_PROCESS";
    case TaskExecutionDetails_TaskExecutionState.ROLLEDBACK:
      return "ROLLEDBACK";
    case TaskExecutionDetails_TaskExecutionState.SUSPENDED:
      return "SUSPENDED";
    case TaskExecutionDetails_TaskExecutionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Status for the execution attempt. */
export interface AttemptStats {
  /**
   * The start time of the integration execution for current attempt. This could
   * be in the future if it's been scheduled.
   */
  startTime:
    | Date
    | undefined;
  /** The end time of the integration execution for current attempt. */
  endTime: Date | undefined;
}

/** An error, warning, or information message associated with an integration. */
export interface ErrorDetail {
  /**
   * The full text of the error message, including any parameters that were
   * thrown along with the exception.
   */
  errorMessage: string;
  /**
   * The task try-number, in which, the error occurred.  If zero, the error
   * happened at the integration level.
   */
  taskNumber: number;
}

/** Contains the combined condition calculation results. */
export interface ConditionResult {
  /** the current task number. */
  currentTaskNumber: string;
  /** the next task number. */
  nextTaskNumber: string;
  /**
   * the result comes out after evaluate the combined condition. True if there's
   * no combined condition specified.
   */
  result: boolean;
}

function createBaseExecutionInfo(): ExecutionInfo {
  return {
    integration: "",
    projectId: "",
    triggerId: "",
    requestParams: {},
    responseParams: {},
    errors: [],
    taskConfigs: [],
    integrationVersionNumber: "",
    executionId: "",
    integrationVersionState: 0,
    enableDatabasePersistence: false,
    cloudLoggingDetails: undefined,
    integrationExecutionDetails: undefined,
    executionType: 0,
    executionMethod: 0,
    integrationSnapshotNumber: Long.ZERO,
  };
}

export const ExecutionInfo: MessageFns<ExecutionInfo> = {
  encode(message: ExecutionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.integration !== "") {
      writer.uint32(18).string(message.integration);
    }
    if (message.projectId !== "") {
      writer.uint32(34).string(message.projectId);
    }
    if (message.triggerId !== "") {
      writer.uint32(42).string(message.triggerId);
    }
    Object.entries(message.requestParams).forEach(([key, value]) => {
      ExecutionInfo_RequestParamsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    Object.entries(message.responseParams).forEach(([key, value]) => {
      ExecutionInfo_ResponseParamsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    for (const v of message.errors) {
      ErrorDetail.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.taskConfigs) {
      TaskConfig.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.integrationVersionNumber !== "") {
      writer.uint32(114).string(message.integrationVersionNumber);
    }
    if (message.executionId !== "") {
      writer.uint32(122).string(message.executionId);
    }
    if (message.integrationVersionState !== 0) {
      writer.uint32(128).int32(message.integrationVersionState);
    }
    if (message.enableDatabasePersistence !== false) {
      writer.uint32(136).bool(message.enableDatabasePersistence);
    }
    if (message.cloudLoggingDetails !== undefined) {
      CloudLoggingDetails.encode(message.cloudLoggingDetails, writer.uint32(146).fork()).join();
    }
    if (message.integrationExecutionDetails !== undefined) {
      IntegrationExecutionDetails.encode(message.integrationExecutionDetails, writer.uint32(154).fork()).join();
    }
    if (message.executionType !== 0) {
      writer.uint32(160).int32(message.executionType);
    }
    if (message.executionMethod !== 0) {
      writer.uint32(168).int32(message.executionMethod);
    }
    if (!message.integrationSnapshotNumber.equals(Long.ZERO)) {
      writer.uint32(176).int64(message.integrationSnapshotNumber.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.integration = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.triggerId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = ExecutionInfo_RequestParamsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.requestParams[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = ExecutionInfo_ResponseParamsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.responseParams[entry7.key] = entry7.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.errors.push(ErrorDetail.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.taskConfigs.push(TaskConfig.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.integrationVersionNumber = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.executionId = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.integrationVersionState = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.enableDatabasePersistence = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.cloudLoggingDetails = CloudLoggingDetails.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.integrationExecutionDetails = IntegrationExecutionDetails.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.executionType = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.executionMethod = reader.int32() as any;
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.integrationSnapshotNumber = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionInfo {
    return {
      integration: isSet(object.integration) ? globalThis.String(object.integration) : "",
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      triggerId: isSet(object.triggerId) ? globalThis.String(object.triggerId) : "",
      requestParams: isObject(object.requestParams)
        ? Object.entries(object.requestParams).reduce<{ [key: string]: EventParameter }>((acc, [key, value]) => {
          acc[key] = EventParameter.fromJSON(value);
          return acc;
        }, {})
        : {},
      responseParams: isObject(object.responseParams)
        ? Object.entries(object.responseParams).reduce<{ [key: string]: EventParameter }>((acc, [key, value]) => {
          acc[key] = EventParameter.fromJSON(value);
          return acc;
        }, {})
        : {},
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => ErrorDetail.fromJSON(e)) : [],
      taskConfigs: globalThis.Array.isArray(object?.taskConfigs)
        ? object.taskConfigs.map((e: any) => TaskConfig.fromJSON(e))
        : [],
      integrationVersionNumber: isSet(object.integrationVersionNumber)
        ? globalThis.String(object.integrationVersionNumber)
        : "",
      executionId: isSet(object.executionId) ? globalThis.String(object.executionId) : "",
      integrationVersionState: isSet(object.integrationVersionState)
        ? integrationStateFromJSON(object.integrationVersionState)
        : 0,
      enableDatabasePersistence: isSet(object.enableDatabasePersistence)
        ? globalThis.Boolean(object.enableDatabasePersistence)
        : false,
      cloudLoggingDetails: isSet(object.cloudLoggingDetails)
        ? CloudLoggingDetails.fromJSON(object.cloudLoggingDetails)
        : undefined,
      integrationExecutionDetails: isSet(object.integrationExecutionDetails)
        ? IntegrationExecutionDetails.fromJSON(object.integrationExecutionDetails)
        : undefined,
      executionType: isSet(object.executionType) ? executionTypeFromJSON(object.executionType) : 0,
      executionMethod: isSet(object.executionMethod)
        ? executionInfo_ExecutionMethodFromJSON(object.executionMethod)
        : 0,
      integrationSnapshotNumber: isSet(object.integrationSnapshotNumber)
        ? Long.fromValue(object.integrationSnapshotNumber)
        : Long.ZERO,
    };
  },

  toJSON(message: ExecutionInfo): unknown {
    const obj: any = {};
    if (message.integration !== "") {
      obj.integration = message.integration;
    }
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.triggerId !== "") {
      obj.triggerId = message.triggerId;
    }
    if (message.requestParams) {
      const entries = Object.entries(message.requestParams);
      if (entries.length > 0) {
        obj.requestParams = {};
        entries.forEach(([k, v]) => {
          obj.requestParams[k] = EventParameter.toJSON(v);
        });
      }
    }
    if (message.responseParams) {
      const entries = Object.entries(message.responseParams);
      if (entries.length > 0) {
        obj.responseParams = {};
        entries.forEach(([k, v]) => {
          obj.responseParams[k] = EventParameter.toJSON(v);
        });
      }
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => ErrorDetail.toJSON(e));
    }
    if (message.taskConfigs?.length) {
      obj.taskConfigs = message.taskConfigs.map((e) => TaskConfig.toJSON(e));
    }
    if (message.integrationVersionNumber !== "") {
      obj.integrationVersionNumber = message.integrationVersionNumber;
    }
    if (message.executionId !== "") {
      obj.executionId = message.executionId;
    }
    if (message.integrationVersionState !== 0) {
      obj.integrationVersionState = integrationStateToJSON(message.integrationVersionState);
    }
    if (message.enableDatabasePersistence !== false) {
      obj.enableDatabasePersistence = message.enableDatabasePersistence;
    }
    if (message.cloudLoggingDetails !== undefined) {
      obj.cloudLoggingDetails = CloudLoggingDetails.toJSON(message.cloudLoggingDetails);
    }
    if (message.integrationExecutionDetails !== undefined) {
      obj.integrationExecutionDetails = IntegrationExecutionDetails.toJSON(message.integrationExecutionDetails);
    }
    if (message.executionType !== 0) {
      obj.executionType = executionTypeToJSON(message.executionType);
    }
    if (message.executionMethod !== 0) {
      obj.executionMethod = executionInfo_ExecutionMethodToJSON(message.executionMethod);
    }
    if (!message.integrationSnapshotNumber.equals(Long.ZERO)) {
      obj.integrationSnapshotNumber = (message.integrationSnapshotNumber || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionInfo>): ExecutionInfo {
    return ExecutionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionInfo>): ExecutionInfo {
    const message = createBaseExecutionInfo();
    message.integration = object.integration ?? "";
    message.projectId = object.projectId ?? "";
    message.triggerId = object.triggerId ?? "";
    message.requestParams = Object.entries(object.requestParams ?? {}).reduce<{ [key: string]: EventParameter }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = EventParameter.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.responseParams = Object.entries(object.responseParams ?? {}).reduce<{ [key: string]: EventParameter }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = EventParameter.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.errors = object.errors?.map((e) => ErrorDetail.fromPartial(e)) || [];
    message.taskConfigs = object.taskConfigs?.map((e) => TaskConfig.fromPartial(e)) || [];
    message.integrationVersionNumber = object.integrationVersionNumber ?? "";
    message.executionId = object.executionId ?? "";
    message.integrationVersionState = object.integrationVersionState ?? 0;
    message.enableDatabasePersistence = object.enableDatabasePersistence ?? false;
    message.cloudLoggingDetails = (object.cloudLoggingDetails !== undefined && object.cloudLoggingDetails !== null)
      ? CloudLoggingDetails.fromPartial(object.cloudLoggingDetails)
      : undefined;
    message.integrationExecutionDetails =
      (object.integrationExecutionDetails !== undefined && object.integrationExecutionDetails !== null)
        ? IntegrationExecutionDetails.fromPartial(object.integrationExecutionDetails)
        : undefined;
    message.executionType = object.executionType ?? 0;
    message.executionMethod = object.executionMethod ?? 0;
    message.integrationSnapshotNumber =
      (object.integrationSnapshotNumber !== undefined && object.integrationSnapshotNumber !== null)
        ? Long.fromValue(object.integrationSnapshotNumber)
        : Long.ZERO;
    return message;
  },
};

function createBaseExecutionInfo_RequestParamsEntry(): ExecutionInfo_RequestParamsEntry {
  return { key: "", value: undefined };
}

export const ExecutionInfo_RequestParamsEntry: MessageFns<ExecutionInfo_RequestParamsEntry> = {
  encode(message: ExecutionInfo_RequestParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      EventParameter.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionInfo_RequestParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionInfo_RequestParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = EventParameter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionInfo_RequestParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? EventParameter.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ExecutionInfo_RequestParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = EventParameter.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionInfo_RequestParamsEntry>): ExecutionInfo_RequestParamsEntry {
    return ExecutionInfo_RequestParamsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionInfo_RequestParamsEntry>): ExecutionInfo_RequestParamsEntry {
    const message = createBaseExecutionInfo_RequestParamsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? EventParameter.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseExecutionInfo_ResponseParamsEntry(): ExecutionInfo_ResponseParamsEntry {
  return { key: "", value: undefined };
}

export const ExecutionInfo_ResponseParamsEntry: MessageFns<ExecutionInfo_ResponseParamsEntry> = {
  encode(message: ExecutionInfo_ResponseParamsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      EventParameter.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecutionInfo_ResponseParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecutionInfo_ResponseParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = EventParameter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecutionInfo_ResponseParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? EventParameter.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ExecutionInfo_ResponseParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = EventParameter.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ExecutionInfo_ResponseParamsEntry>): ExecutionInfo_ResponseParamsEntry {
    return ExecutionInfo_ResponseParamsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExecutionInfo_ResponseParamsEntry>): ExecutionInfo_ResponseParamsEntry {
    const message = createBaseExecutionInfo_ResponseParamsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? EventParameter.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseIntegrationExecutionDetails(): IntegrationExecutionDetails {
  return {
    integrationExecutionState: 0,
    integrationExecutionSnapshot: [],
    executionAttemptStats: [],
    nextExecutionTime: undefined,
    executionRetriesCount: 0,
  };
}

export const IntegrationExecutionDetails: MessageFns<IntegrationExecutionDetails> = {
  encode(message: IntegrationExecutionDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.integrationExecutionState !== 0) {
      writer.uint32(8).int32(message.integrationExecutionState);
    }
    for (const v of message.integrationExecutionSnapshot) {
      IntegrationExecutionSnapshot.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.executionAttemptStats) {
      AttemptStats.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.nextExecutionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.nextExecutionTime), writer.uint32(34).fork()).join();
    }
    if (message.executionRetriesCount !== 0) {
      writer.uint32(40).int32(message.executionRetriesCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegrationExecutionDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegrationExecutionDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.integrationExecutionState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.integrationExecutionSnapshot.push(IntegrationExecutionSnapshot.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.executionAttemptStats.push(AttemptStats.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nextExecutionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.executionRetriesCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegrationExecutionDetails {
    return {
      integrationExecutionState: isSet(object.integrationExecutionState)
        ? integrationExecutionDetails_IntegrationExecutionStateFromJSON(object.integrationExecutionState)
        : 0,
      integrationExecutionSnapshot: globalThis.Array.isArray(object?.integrationExecutionSnapshot)
        ? object.integrationExecutionSnapshot.map((e: any) => IntegrationExecutionSnapshot.fromJSON(e))
        : [],
      executionAttemptStats: globalThis.Array.isArray(object?.executionAttemptStats)
        ? object.executionAttemptStats.map((e: any) => AttemptStats.fromJSON(e))
        : [],
      nextExecutionTime: isSet(object.nextExecutionTime) ? fromJsonTimestamp(object.nextExecutionTime) : undefined,
      executionRetriesCount: isSet(object.executionRetriesCount) ? globalThis.Number(object.executionRetriesCount) : 0,
    };
  },

  toJSON(message: IntegrationExecutionDetails): unknown {
    const obj: any = {};
    if (message.integrationExecutionState !== 0) {
      obj.integrationExecutionState = integrationExecutionDetails_IntegrationExecutionStateToJSON(
        message.integrationExecutionState,
      );
    }
    if (message.integrationExecutionSnapshot?.length) {
      obj.integrationExecutionSnapshot = message.integrationExecutionSnapshot.map((e) =>
        IntegrationExecutionSnapshot.toJSON(e)
      );
    }
    if (message.executionAttemptStats?.length) {
      obj.executionAttemptStats = message.executionAttemptStats.map((e) => AttemptStats.toJSON(e));
    }
    if (message.nextExecutionTime !== undefined) {
      obj.nextExecutionTime = message.nextExecutionTime.toISOString();
    }
    if (message.executionRetriesCount !== 0) {
      obj.executionRetriesCount = Math.round(message.executionRetriesCount);
    }
    return obj;
  },

  create(base?: DeepPartial<IntegrationExecutionDetails>): IntegrationExecutionDetails {
    return IntegrationExecutionDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntegrationExecutionDetails>): IntegrationExecutionDetails {
    const message = createBaseIntegrationExecutionDetails();
    message.integrationExecutionState = object.integrationExecutionState ?? 0;
    message.integrationExecutionSnapshot =
      object.integrationExecutionSnapshot?.map((e) => IntegrationExecutionSnapshot.fromPartial(e)) || [];
    message.executionAttemptStats = object.executionAttemptStats?.map((e) => AttemptStats.fromPartial(e)) || [];
    message.nextExecutionTime = object.nextExecutionTime ?? undefined;
    message.executionRetriesCount = object.executionRetriesCount ?? 0;
    return message;
  },
};

function createBaseIntegrationExecutionSnapshot(): IntegrationExecutionSnapshot {
  return {
    checkpointTaskNumber: "",
    snapshotTime: undefined,
    integrationExecutionSnapshotMetadata: undefined,
    taskExecutionDetails: [],
    conditionResults: [],
    executionParams: {},
  };
}

export const IntegrationExecutionSnapshot: MessageFns<IntegrationExecutionSnapshot> = {
  encode(message: IntegrationExecutionSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.checkpointTaskNumber !== "") {
      writer.uint32(10).string(message.checkpointTaskNumber);
    }
    if (message.snapshotTime !== undefined) {
      Timestamp.encode(toTimestamp(message.snapshotTime), writer.uint32(18).fork()).join();
    }
    if (message.integrationExecutionSnapshotMetadata !== undefined) {
      IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata.encode(
        message.integrationExecutionSnapshotMetadata,
        writer.uint32(26).fork(),
      ).join();
    }
    for (const v of message.taskExecutionDetails) {
      TaskExecutionDetails.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.conditionResults) {
      ConditionResult.encode(v!, writer.uint32(42).fork()).join();
    }
    Object.entries(message.executionParams).forEach(([key, value]) => {
      IntegrationExecutionSnapshot_ExecutionParamsEntry.encode({ key: key as any, value }, writer.uint32(50).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegrationExecutionSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegrationExecutionSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.checkpointTaskNumber = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshotTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.integrationExecutionSnapshotMetadata =
            IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.taskExecutionDetails.push(TaskExecutionDetails.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.conditionResults.push(ConditionResult.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = IntegrationExecutionSnapshot_ExecutionParamsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.executionParams[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegrationExecutionSnapshot {
    return {
      checkpointTaskNumber: isSet(object.checkpointTaskNumber) ? globalThis.String(object.checkpointTaskNumber) : "",
      snapshotTime: isSet(object.snapshotTime) ? fromJsonTimestamp(object.snapshotTime) : undefined,
      integrationExecutionSnapshotMetadata: isSet(object.integrationExecutionSnapshotMetadata)
        ? IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata.fromJSON(
          object.integrationExecutionSnapshotMetadata,
        )
        : undefined,
      taskExecutionDetails: globalThis.Array.isArray(object?.taskExecutionDetails)
        ? object.taskExecutionDetails.map((e: any) => TaskExecutionDetails.fromJSON(e))
        : [],
      conditionResults: globalThis.Array.isArray(object?.conditionResults)
        ? object.conditionResults.map((e: any) => ConditionResult.fromJSON(e))
        : [],
      executionParams: isObject(object.executionParams)
        ? Object.entries(object.executionParams).reduce<{ [key: string]: EventParameter }>((acc, [key, value]) => {
          acc[key] = EventParameter.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: IntegrationExecutionSnapshot): unknown {
    const obj: any = {};
    if (message.checkpointTaskNumber !== "") {
      obj.checkpointTaskNumber = message.checkpointTaskNumber;
    }
    if (message.snapshotTime !== undefined) {
      obj.snapshotTime = message.snapshotTime.toISOString();
    }
    if (message.integrationExecutionSnapshotMetadata !== undefined) {
      obj.integrationExecutionSnapshotMetadata = IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata
        .toJSON(message.integrationExecutionSnapshotMetadata);
    }
    if (message.taskExecutionDetails?.length) {
      obj.taskExecutionDetails = message.taskExecutionDetails.map((e) => TaskExecutionDetails.toJSON(e));
    }
    if (message.conditionResults?.length) {
      obj.conditionResults = message.conditionResults.map((e) => ConditionResult.toJSON(e));
    }
    if (message.executionParams) {
      const entries = Object.entries(message.executionParams);
      if (entries.length > 0) {
        obj.executionParams = {};
        entries.forEach(([k, v]) => {
          obj.executionParams[k] = EventParameter.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<IntegrationExecutionSnapshot>): IntegrationExecutionSnapshot {
    return IntegrationExecutionSnapshot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntegrationExecutionSnapshot>): IntegrationExecutionSnapshot {
    const message = createBaseIntegrationExecutionSnapshot();
    message.checkpointTaskNumber = object.checkpointTaskNumber ?? "";
    message.snapshotTime = object.snapshotTime ?? undefined;
    message.integrationExecutionSnapshotMetadata =
      (object.integrationExecutionSnapshotMetadata !== undefined &&
          object.integrationExecutionSnapshotMetadata !== null)
        ? IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata.fromPartial(
          object.integrationExecutionSnapshotMetadata,
        )
        : undefined;
    message.taskExecutionDetails = object.taskExecutionDetails?.map((e) => TaskExecutionDetails.fromPartial(e)) || [];
    message.conditionResults = object.conditionResults?.map((e) => ConditionResult.fromPartial(e)) || [];
    message.executionParams = Object.entries(object.executionParams ?? {}).reduce<{ [key: string]: EventParameter }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = EventParameter.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseIntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata(): IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata {
  return {
    taskNumber: "",
    task: "",
    integrationExecutionAttemptNum: 0,
    taskAttemptNum: 0,
    taskLabel: "",
    ancestorTaskNumbers: [],
    ancestorIterationNumbers: [],
    integration: "",
  };
}

export const IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata: MessageFns<
  IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata
> = {
  encode(
    message: IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.taskNumber !== "") {
      writer.uint32(10).string(message.taskNumber);
    }
    if (message.task !== "") {
      writer.uint32(18).string(message.task);
    }
    if (message.integrationExecutionAttemptNum !== 0) {
      writer.uint32(24).int32(message.integrationExecutionAttemptNum);
    }
    if (message.taskAttemptNum !== 0) {
      writer.uint32(32).int32(message.taskAttemptNum);
    }
    if (message.taskLabel !== "") {
      writer.uint32(42).string(message.taskLabel);
    }
    for (const v of message.ancestorTaskNumbers) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.ancestorIterationNumbers) {
      writer.uint32(58).string(v!);
    }
    if (message.integration !== "") {
      writer.uint32(66).string(message.integration);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskNumber = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.task = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.integrationExecutionAttemptNum = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.taskAttemptNum = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.taskLabel = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.ancestorTaskNumbers.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ancestorIterationNumbers.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.integration = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata {
    return {
      taskNumber: isSet(object.taskNumber) ? globalThis.String(object.taskNumber) : "",
      task: isSet(object.task) ? globalThis.String(object.task) : "",
      integrationExecutionAttemptNum: isSet(object.integrationExecutionAttemptNum)
        ? globalThis.Number(object.integrationExecutionAttemptNum)
        : 0,
      taskAttemptNum: isSet(object.taskAttemptNum) ? globalThis.Number(object.taskAttemptNum) : 0,
      taskLabel: isSet(object.taskLabel) ? globalThis.String(object.taskLabel) : "",
      ancestorTaskNumbers: globalThis.Array.isArray(object?.ancestorTaskNumbers)
        ? object.ancestorTaskNumbers.map((e: any) => globalThis.String(e))
        : [],
      ancestorIterationNumbers: globalThis.Array.isArray(object?.ancestorIterationNumbers)
        ? object.ancestorIterationNumbers.map((e: any) => globalThis.String(e))
        : [],
      integration: isSet(object.integration) ? globalThis.String(object.integration) : "",
    };
  },

  toJSON(message: IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata): unknown {
    const obj: any = {};
    if (message.taskNumber !== "") {
      obj.taskNumber = message.taskNumber;
    }
    if (message.task !== "") {
      obj.task = message.task;
    }
    if (message.integrationExecutionAttemptNum !== 0) {
      obj.integrationExecutionAttemptNum = Math.round(message.integrationExecutionAttemptNum);
    }
    if (message.taskAttemptNum !== 0) {
      obj.taskAttemptNum = Math.round(message.taskAttemptNum);
    }
    if (message.taskLabel !== "") {
      obj.taskLabel = message.taskLabel;
    }
    if (message.ancestorTaskNumbers?.length) {
      obj.ancestorTaskNumbers = message.ancestorTaskNumbers;
    }
    if (message.ancestorIterationNumbers?.length) {
      obj.ancestorIterationNumbers = message.ancestorIterationNumbers;
    }
    if (message.integration !== "") {
      obj.integration = message.integration;
    }
    return obj;
  },

  create(
    base?: DeepPartial<IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata>,
  ): IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata {
    return IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata>,
  ): IntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata {
    const message = createBaseIntegrationExecutionSnapshot_IntegrationExecutionSnapshotMetadata();
    message.taskNumber = object.taskNumber ?? "";
    message.task = object.task ?? "";
    message.integrationExecutionAttemptNum = object.integrationExecutionAttemptNum ?? 0;
    message.taskAttemptNum = object.taskAttemptNum ?? 0;
    message.taskLabel = object.taskLabel ?? "";
    message.ancestorTaskNumbers = object.ancestorTaskNumbers?.map((e) => e) || [];
    message.ancestorIterationNumbers = object.ancestorIterationNumbers?.map((e) => e) || [];
    message.integration = object.integration ?? "";
    return message;
  },
};

function createBaseIntegrationExecutionSnapshot_ExecutionParamsEntry(): IntegrationExecutionSnapshot_ExecutionParamsEntry {
  return { key: "", value: undefined };
}

export const IntegrationExecutionSnapshot_ExecutionParamsEntry: MessageFns<
  IntegrationExecutionSnapshot_ExecutionParamsEntry
> = {
  encode(
    message: IntegrationExecutionSnapshot_ExecutionParamsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      EventParameter.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntegrationExecutionSnapshot_ExecutionParamsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntegrationExecutionSnapshot_ExecutionParamsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = EventParameter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntegrationExecutionSnapshot_ExecutionParamsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? EventParameter.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: IntegrationExecutionSnapshot_ExecutionParamsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = EventParameter.toJSON(message.value);
    }
    return obj;
  },

  create(
    base?: DeepPartial<IntegrationExecutionSnapshot_ExecutionParamsEntry>,
  ): IntegrationExecutionSnapshot_ExecutionParamsEntry {
    return IntegrationExecutionSnapshot_ExecutionParamsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<IntegrationExecutionSnapshot_ExecutionParamsEntry>,
  ): IntegrationExecutionSnapshot_ExecutionParamsEntry {
    const message = createBaseIntegrationExecutionSnapshot_ExecutionParamsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? EventParameter.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTaskExecutionDetails(): TaskExecutionDetails {
  return { taskNumber: "", taskExecutionState: 0, taskAttemptStats: [] };
}

export const TaskExecutionDetails: MessageFns<TaskExecutionDetails> = {
  encode(message: TaskExecutionDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskNumber !== "") {
      writer.uint32(10).string(message.taskNumber);
    }
    if (message.taskExecutionState !== 0) {
      writer.uint32(16).int32(message.taskExecutionState);
    }
    for (const v of message.taskAttemptStats) {
      AttemptStats.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TaskExecutionDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTaskExecutionDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskNumber = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.taskExecutionState = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.taskAttemptStats.push(AttemptStats.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TaskExecutionDetails {
    return {
      taskNumber: isSet(object.taskNumber) ? globalThis.String(object.taskNumber) : "",
      taskExecutionState: isSet(object.taskExecutionState)
        ? taskExecutionDetails_TaskExecutionStateFromJSON(object.taskExecutionState)
        : 0,
      taskAttemptStats: globalThis.Array.isArray(object?.taskAttemptStats)
        ? object.taskAttemptStats.map((e: any) => AttemptStats.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TaskExecutionDetails): unknown {
    const obj: any = {};
    if (message.taskNumber !== "") {
      obj.taskNumber = message.taskNumber;
    }
    if (message.taskExecutionState !== 0) {
      obj.taskExecutionState = taskExecutionDetails_TaskExecutionStateToJSON(message.taskExecutionState);
    }
    if (message.taskAttemptStats?.length) {
      obj.taskAttemptStats = message.taskAttemptStats.map((e) => AttemptStats.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TaskExecutionDetails>): TaskExecutionDetails {
    return TaskExecutionDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TaskExecutionDetails>): TaskExecutionDetails {
    const message = createBaseTaskExecutionDetails();
    message.taskNumber = object.taskNumber ?? "";
    message.taskExecutionState = object.taskExecutionState ?? 0;
    message.taskAttemptStats = object.taskAttemptStats?.map((e) => AttemptStats.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAttemptStats(): AttemptStats {
  return { startTime: undefined, endTime: undefined };
}

export const AttemptStats: MessageFns<AttemptStats> = {
  encode(message: AttemptStats, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttemptStats {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttemptStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttemptStats {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: AttemptStats): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AttemptStats>): AttemptStats {
    return AttemptStats.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttemptStats>): AttemptStats {
    const message = createBaseAttemptStats();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseErrorDetail(): ErrorDetail {
  return { errorMessage: "", taskNumber: 0 };
}

export const ErrorDetail: MessageFns<ErrorDetail> = {
  encode(message: ErrorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorMessage !== "") {
      writer.uint32(10).string(message.errorMessage);
    }
    if (message.taskNumber !== 0) {
      writer.uint32(16).int32(message.taskNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.taskNumber = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorDetail {
    return {
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      taskNumber: isSet(object.taskNumber) ? globalThis.Number(object.taskNumber) : 0,
    };
  },

  toJSON(message: ErrorDetail): unknown {
    const obj: any = {};
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.taskNumber !== 0) {
      obj.taskNumber = Math.round(message.taskNumber);
    }
    return obj;
  },

  create(base?: DeepPartial<ErrorDetail>): ErrorDetail {
    return ErrorDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorDetail>): ErrorDetail {
    const message = createBaseErrorDetail();
    message.errorMessage = object.errorMessage ?? "";
    message.taskNumber = object.taskNumber ?? 0;
    return message;
  },
};

function createBaseConditionResult(): ConditionResult {
  return { currentTaskNumber: "", nextTaskNumber: "", result: false };
}

export const ConditionResult: MessageFns<ConditionResult> = {
  encode(message: ConditionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentTaskNumber !== "") {
      writer.uint32(10).string(message.currentTaskNumber);
    }
    if (message.nextTaskNumber !== "") {
      writer.uint32(18).string(message.nextTaskNumber);
    }
    if (message.result !== false) {
      writer.uint32(24).bool(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.currentTaskNumber = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextTaskNumber = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.result = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionResult {
    return {
      currentTaskNumber: isSet(object.currentTaskNumber) ? globalThis.String(object.currentTaskNumber) : "",
      nextTaskNumber: isSet(object.nextTaskNumber) ? globalThis.String(object.nextTaskNumber) : "",
      result: isSet(object.result) ? globalThis.Boolean(object.result) : false,
    };
  },

  toJSON(message: ConditionResult): unknown {
    const obj: any = {};
    if (message.currentTaskNumber !== "") {
      obj.currentTaskNumber = message.currentTaskNumber;
    }
    if (message.nextTaskNumber !== "") {
      obj.nextTaskNumber = message.nextTaskNumber;
    }
    if (message.result !== false) {
      obj.result = message.result;
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionResult>): ConditionResult {
    return ConditionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionResult>): ConditionResult {
    const message = createBaseConditionResult();
    message.currentTaskNumber = object.currentTaskNumber ?? "";
    message.nextTaskNumber = object.nextTaskNumber ?? "";
    message.result = object.result ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
