// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/connectors/v1/ssl_config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ConfigVariable, ConfigVariableTemplate, Secret } from "./common.js";

export const protobufPackage = "google.cloud.connectors.v1";

/** Enum for controlling the SSL Type (TLS/MTLS) */
export enum SslType {
  /** SSL_TYPE_UNSPECIFIED - No SSL configuration required. */
  SSL_TYPE_UNSPECIFIED = 0,
  /** TLS - TLS Handshake */
  TLS = 1,
  /** MTLS - mutual TLS (MTLS) Handshake */
  MTLS = 2,
  UNRECOGNIZED = -1,
}

export function sslTypeFromJSON(object: any): SslType {
  switch (object) {
    case 0:
    case "SSL_TYPE_UNSPECIFIED":
      return SslType.SSL_TYPE_UNSPECIFIED;
    case 1:
    case "TLS":
      return SslType.TLS;
    case 2:
    case "MTLS":
      return SslType.MTLS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SslType.UNRECOGNIZED;
  }
}

export function sslTypeToJSON(object: SslType): string {
  switch (object) {
    case SslType.SSL_TYPE_UNSPECIFIED:
      return "SSL_TYPE_UNSPECIFIED";
    case SslType.TLS:
      return "TLS";
    case SslType.MTLS:
      return "MTLS";
    case SslType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enum for Cert Types */
export enum CertType {
  /** CERT_TYPE_UNSPECIFIED - Cert type unspecified. */
  CERT_TYPE_UNSPECIFIED = 0,
  /** PEM - Privacy Enhanced Mail (PEM) Type */
  PEM = 1,
  UNRECOGNIZED = -1,
}

export function certTypeFromJSON(object: any): CertType {
  switch (object) {
    case 0:
    case "CERT_TYPE_UNSPECIFIED":
      return CertType.CERT_TYPE_UNSPECIFIED;
    case 1:
    case "PEM":
      return CertType.PEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertType.UNRECOGNIZED;
  }
}

export function certTypeToJSON(object: CertType): string {
  switch (object) {
    case CertType.CERT_TYPE_UNSPECIFIED:
      return "CERT_TYPE_UNSPECIFIED";
    case CertType.PEM:
      return "PEM";
    case CertType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Ssl config details of a connector version */
export interface SslConfigTemplate {
  /** Controls the ssl type for the given connector version */
  sslType: SslType;
  /** Boolean for determining if the connector version mandates TLS. */
  isTlsMandatory: boolean;
  /** List of supported Server Cert Types */
  serverCertType: CertType[];
  /** List of supported Client Cert Types */
  clientCertType: CertType[];
  /** Any additional fields that need to be rendered */
  additionalVariables: ConfigVariableTemplate[];
}

/** SSL Configuration of a connection */
export interface SslConfig {
  /** Controls the ssl type for the given connector version. */
  type: SslType;
  /** Trust Model of the SSL connection */
  trustModel: SslConfig_TrustModel;
  /**
   * Private Server Certificate. Needs to be specified if trust model is
   * `PRIVATE`.
   */
  privateServerCertificate:
    | Secret
    | undefined;
  /** Client Certificate */
  clientCertificate:
    | Secret
    | undefined;
  /** Client Private Key */
  clientPrivateKey:
    | Secret
    | undefined;
  /** Secret containing the passphrase protecting the Client Private Key */
  clientPrivateKeyPass:
    | Secret
    | undefined;
  /** Type of Server Cert (PEM/JKS/.. etc.) */
  serverCertType: CertType;
  /** Type of Client Cert (PEM/JKS/.. etc.) */
  clientCertType: CertType;
  /** Bool for enabling SSL */
  useSsl: boolean;
  /** Additional SSL related field values */
  additionalVariables: ConfigVariable[];
}

/** Enum for Ttust Model */
export enum SslConfig_TrustModel {
  /** PUBLIC - Public Trust Model. Takes the Default Java trust store. */
  PUBLIC = 0,
  /** PRIVATE - Private Trust Model. Takes custom/private trust store. */
  PRIVATE = 1,
  /** INSECURE - Insecure Trust Model. Accept all certificates. */
  INSECURE = 2,
  UNRECOGNIZED = -1,
}

export function sslConfig_TrustModelFromJSON(object: any): SslConfig_TrustModel {
  switch (object) {
    case 0:
    case "PUBLIC":
      return SslConfig_TrustModel.PUBLIC;
    case 1:
    case "PRIVATE":
      return SslConfig_TrustModel.PRIVATE;
    case 2:
    case "INSECURE":
      return SslConfig_TrustModel.INSECURE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SslConfig_TrustModel.UNRECOGNIZED;
  }
}

export function sslConfig_TrustModelToJSON(object: SslConfig_TrustModel): string {
  switch (object) {
    case SslConfig_TrustModel.PUBLIC:
      return "PUBLIC";
    case SslConfig_TrustModel.PRIVATE:
      return "PRIVATE";
    case SslConfig_TrustModel.INSECURE:
      return "INSECURE";
    case SslConfig_TrustModel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseSslConfigTemplate(): SslConfigTemplate {
  return { sslType: 0, isTlsMandatory: false, serverCertType: [], clientCertType: [], additionalVariables: [] };
}

export const SslConfigTemplate: MessageFns<SslConfigTemplate> = {
  encode(message: SslConfigTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sslType !== 0) {
      writer.uint32(8).int32(message.sslType);
    }
    if (message.isTlsMandatory !== false) {
      writer.uint32(16).bool(message.isTlsMandatory);
    }
    writer.uint32(26).fork();
    for (const v of message.serverCertType) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.clientCertType) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.additionalVariables) {
      ConfigVariableTemplate.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SslConfigTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSslConfigTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.sslType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isTlsMandatory = reader.bool();
          continue;
        case 3:
          if (tag === 24) {
            message.serverCertType.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.serverCertType.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.clientCertType.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.clientCertType.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.additionalVariables.push(ConfigVariableTemplate.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SslConfigTemplate {
    return {
      sslType: isSet(object.sslType) ? sslTypeFromJSON(object.sslType) : 0,
      isTlsMandatory: isSet(object.isTlsMandatory) ? globalThis.Boolean(object.isTlsMandatory) : false,
      serverCertType: globalThis.Array.isArray(object?.serverCertType)
        ? object.serverCertType.map((e: any) => certTypeFromJSON(e))
        : [],
      clientCertType: globalThis.Array.isArray(object?.clientCertType)
        ? object.clientCertType.map((e: any) => certTypeFromJSON(e))
        : [],
      additionalVariables: globalThis.Array.isArray(object?.additionalVariables)
        ? object.additionalVariables.map((e: any) => ConfigVariableTemplate.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SslConfigTemplate): unknown {
    const obj: any = {};
    if (message.sslType !== 0) {
      obj.sslType = sslTypeToJSON(message.sslType);
    }
    if (message.isTlsMandatory !== false) {
      obj.isTlsMandatory = message.isTlsMandatory;
    }
    if (message.serverCertType?.length) {
      obj.serverCertType = message.serverCertType.map((e) => certTypeToJSON(e));
    }
    if (message.clientCertType?.length) {
      obj.clientCertType = message.clientCertType.map((e) => certTypeToJSON(e));
    }
    if (message.additionalVariables?.length) {
      obj.additionalVariables = message.additionalVariables.map((e) => ConfigVariableTemplate.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SslConfigTemplate>): SslConfigTemplate {
    return SslConfigTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SslConfigTemplate>): SslConfigTemplate {
    const message = createBaseSslConfigTemplate();
    message.sslType = object.sslType ?? 0;
    message.isTlsMandatory = object.isTlsMandatory ?? false;
    message.serverCertType = object.serverCertType?.map((e) => e) || [];
    message.clientCertType = object.clientCertType?.map((e) => e) || [];
    message.additionalVariables = object.additionalVariables?.map((e) => ConfigVariableTemplate.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSslConfig(): SslConfig {
  return {
    type: 0,
    trustModel: 0,
    privateServerCertificate: undefined,
    clientCertificate: undefined,
    clientPrivateKey: undefined,
    clientPrivateKeyPass: undefined,
    serverCertType: 0,
    clientCertType: 0,
    useSsl: false,
    additionalVariables: [],
  };
}

export const SslConfig: MessageFns<SslConfig> = {
  encode(message: SslConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.trustModel !== 0) {
      writer.uint32(16).int32(message.trustModel);
    }
    if (message.privateServerCertificate !== undefined) {
      Secret.encode(message.privateServerCertificate, writer.uint32(26).fork()).join();
    }
    if (message.clientCertificate !== undefined) {
      Secret.encode(message.clientCertificate, writer.uint32(34).fork()).join();
    }
    if (message.clientPrivateKey !== undefined) {
      Secret.encode(message.clientPrivateKey, writer.uint32(42).fork()).join();
    }
    if (message.clientPrivateKeyPass !== undefined) {
      Secret.encode(message.clientPrivateKeyPass, writer.uint32(50).fork()).join();
    }
    if (message.serverCertType !== 0) {
      writer.uint32(56).int32(message.serverCertType);
    }
    if (message.clientCertType !== 0) {
      writer.uint32(64).int32(message.clientCertType);
    }
    if (message.useSsl !== false) {
      writer.uint32(72).bool(message.useSsl);
    }
    for (const v of message.additionalVariables) {
      ConfigVariable.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SslConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSslConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.trustModel = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.privateServerCertificate = Secret.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.clientCertificate = Secret.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.clientPrivateKey = Secret.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clientPrivateKeyPass = Secret.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.serverCertType = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.clientCertType = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.useSsl = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.additionalVariables.push(ConfigVariable.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SslConfig {
    return {
      type: isSet(object.type) ? sslTypeFromJSON(object.type) : 0,
      trustModel: isSet(object.trustModel) ? sslConfig_TrustModelFromJSON(object.trustModel) : 0,
      privateServerCertificate: isSet(object.privateServerCertificate)
        ? Secret.fromJSON(object.privateServerCertificate)
        : undefined,
      clientCertificate: isSet(object.clientCertificate) ? Secret.fromJSON(object.clientCertificate) : undefined,
      clientPrivateKey: isSet(object.clientPrivateKey) ? Secret.fromJSON(object.clientPrivateKey) : undefined,
      clientPrivateKeyPass: isSet(object.clientPrivateKeyPass)
        ? Secret.fromJSON(object.clientPrivateKeyPass)
        : undefined,
      serverCertType: isSet(object.serverCertType) ? certTypeFromJSON(object.serverCertType) : 0,
      clientCertType: isSet(object.clientCertType) ? certTypeFromJSON(object.clientCertType) : 0,
      useSsl: isSet(object.useSsl) ? globalThis.Boolean(object.useSsl) : false,
      additionalVariables: globalThis.Array.isArray(object?.additionalVariables)
        ? object.additionalVariables.map((e: any) => ConfigVariable.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SslConfig): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = sslTypeToJSON(message.type);
    }
    if (message.trustModel !== 0) {
      obj.trustModel = sslConfig_TrustModelToJSON(message.trustModel);
    }
    if (message.privateServerCertificate !== undefined) {
      obj.privateServerCertificate = Secret.toJSON(message.privateServerCertificate);
    }
    if (message.clientCertificate !== undefined) {
      obj.clientCertificate = Secret.toJSON(message.clientCertificate);
    }
    if (message.clientPrivateKey !== undefined) {
      obj.clientPrivateKey = Secret.toJSON(message.clientPrivateKey);
    }
    if (message.clientPrivateKeyPass !== undefined) {
      obj.clientPrivateKeyPass = Secret.toJSON(message.clientPrivateKeyPass);
    }
    if (message.serverCertType !== 0) {
      obj.serverCertType = certTypeToJSON(message.serverCertType);
    }
    if (message.clientCertType !== 0) {
      obj.clientCertType = certTypeToJSON(message.clientCertType);
    }
    if (message.useSsl !== false) {
      obj.useSsl = message.useSsl;
    }
    if (message.additionalVariables?.length) {
      obj.additionalVariables = message.additionalVariables.map((e) => ConfigVariable.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SslConfig>): SslConfig {
    return SslConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SslConfig>): SslConfig {
    const message = createBaseSslConfig();
    message.type = object.type ?? 0;
    message.trustModel = object.trustModel ?? 0;
    message.privateServerCertificate =
      (object.privateServerCertificate !== undefined && object.privateServerCertificate !== null)
        ? Secret.fromPartial(object.privateServerCertificate)
        : undefined;
    message.clientCertificate = (object.clientCertificate !== undefined && object.clientCertificate !== null)
      ? Secret.fromPartial(object.clientCertificate)
      : undefined;
    message.clientPrivateKey = (object.clientPrivateKey !== undefined && object.clientPrivateKey !== null)
      ? Secret.fromPartial(object.clientPrivateKey)
      : undefined;
    message.clientPrivateKeyPass = (object.clientPrivateKeyPass !== undefined && object.clientPrivateKeyPass !== null)
      ? Secret.fromPartial(object.clientPrivateKeyPass)
      : undefined;
    message.serverCertType = object.serverCertType ?? 0;
    message.clientCertType = object.clientCertType ?? 0;
    message.useSsl = object.useSsl ?? false;
    message.additionalVariables = object.additionalVariables?.map((e) => ConfigVariable.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
