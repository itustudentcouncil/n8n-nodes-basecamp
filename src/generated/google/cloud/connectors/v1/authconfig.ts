// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/connectors/v1/authconfig.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { ConfigVariable, ConfigVariableTemplate, Secret } from "./common.js";

export const protobufPackage = "google.cloud.connectors.v1";

/** AuthType defines different authentication types. */
export enum AuthType {
  /** AUTH_TYPE_UNSPECIFIED - Authentication type not specified. */
  AUTH_TYPE_UNSPECIFIED = 0,
  /** USER_PASSWORD - Username and Password Authentication. */
  USER_PASSWORD = 1,
  /**
   * OAUTH2_JWT_BEARER - JSON Web Token (JWT) Profile for Oauth 2.0
   * Authorization Grant based authentication
   */
  OAUTH2_JWT_BEARER = 2,
  /** OAUTH2_CLIENT_CREDENTIALS - Oauth 2.0 Client Credentials Grant Authentication */
  OAUTH2_CLIENT_CREDENTIALS = 3,
  /** SSH_PUBLIC_KEY - SSH Public Key Authentication */
  SSH_PUBLIC_KEY = 4,
  /** OAUTH2_AUTH_CODE_FLOW - Oauth 2.0 Authorization Code Flow */
  OAUTH2_AUTH_CODE_FLOW = 5,
  UNRECOGNIZED = -1,
}

export function authTypeFromJSON(object: any): AuthType {
  switch (object) {
    case 0:
    case "AUTH_TYPE_UNSPECIFIED":
      return AuthType.AUTH_TYPE_UNSPECIFIED;
    case 1:
    case "USER_PASSWORD":
      return AuthType.USER_PASSWORD;
    case 2:
    case "OAUTH2_JWT_BEARER":
      return AuthType.OAUTH2_JWT_BEARER;
    case 3:
    case "OAUTH2_CLIENT_CREDENTIALS":
      return AuthType.OAUTH2_CLIENT_CREDENTIALS;
    case 4:
    case "SSH_PUBLIC_KEY":
      return AuthType.SSH_PUBLIC_KEY;
    case 5:
    case "OAUTH2_AUTH_CODE_FLOW":
      return AuthType.OAUTH2_AUTH_CODE_FLOW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuthType.UNRECOGNIZED;
  }
}

export function authTypeToJSON(object: AuthType): string {
  switch (object) {
    case AuthType.AUTH_TYPE_UNSPECIFIED:
      return "AUTH_TYPE_UNSPECIFIED";
    case AuthType.USER_PASSWORD:
      return "USER_PASSWORD";
    case AuthType.OAUTH2_JWT_BEARER:
      return "OAUTH2_JWT_BEARER";
    case AuthType.OAUTH2_CLIENT_CREDENTIALS:
      return "OAUTH2_CLIENT_CREDENTIALS";
    case AuthType.SSH_PUBLIC_KEY:
      return "SSH_PUBLIC_KEY";
    case AuthType.OAUTH2_AUTH_CODE_FLOW:
      return "OAUTH2_AUTH_CODE_FLOW";
    case AuthType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AuthConfig defines details of a authentication type. */
export interface AuthConfig {
  /** The type of authentication configured. */
  authType: AuthType;
  /** UserPassword. */
  userPassword?:
    | AuthConfig_UserPassword
    | undefined;
  /** Oauth2JwtBearer. */
  oauth2JwtBearer?:
    | AuthConfig_Oauth2JwtBearer
    | undefined;
  /** Oauth2ClientCredentials. */
  oauth2ClientCredentials?:
    | AuthConfig_Oauth2ClientCredentials
    | undefined;
  /** SSH Public Key. */
  sshPublicKey?:
    | AuthConfig_SshPublicKey
    | undefined;
  /** List containing additional auth configs. */
  additionalVariables: ConfigVariable[];
}

/** Parameters to support Username and Password Authentication. */
export interface AuthConfig_UserPassword {
  /** Username. */
  username: string;
  /** Secret version reference containing the password. */
  password: Secret | undefined;
}

/**
 * Parameters to support JSON Web Token (JWT) Profile for Oauth 2.0
 * Authorization Grant based authentication.
 * See https://tools.ietf.org/html/rfc7523 for more details.
 */
export interface AuthConfig_Oauth2JwtBearer {
  /**
   * Secret version reference containing a PKCS#8 PEM-encoded private
   * key associated with the Client Certificate. This private key will be
   * used to sign JWTs used for the jwt-bearer authorization grant.
   * Specified in the form as: `projects/* /secrets/* /versions/*`.
   */
  clientKey:
    | Secret
    | undefined;
  /** JwtClaims providers fields to generate the token. */
  jwtClaims: AuthConfig_Oauth2JwtBearer_JwtClaims | undefined;
}

/** JWT claims used for the jwt-bearer authorization grant. */
export interface AuthConfig_Oauth2JwtBearer_JwtClaims {
  /** Value for the "iss" claim. */
  issuer: string;
  /** Value for the "sub" claim. */
  subject: string;
  /** Value for the "aud" claim. */
  audience: string;
}

/**
 * Parameters to support Oauth 2.0 Client Credentials Grant Authentication.
 * See https://tools.ietf.org/html/rfc6749#section-1.3.4 for more details.
 */
export interface AuthConfig_Oauth2ClientCredentials {
  /** The client identifier. */
  clientId: string;
  /** Secret version reference containing the client secret. */
  clientSecret: Secret | undefined;
}

/** Parameters to support Ssh public key Authentication. */
export interface AuthConfig_SshPublicKey {
  /** The user account used to authenticate. */
  username: string;
  /** SSH Client Cert. It should contain both public and private key. */
  sshClientCert:
    | Secret
    | undefined;
  /** Format of SSH Client cert. */
  certType: string;
  /** Password (passphrase) for ssh client certificate if it has one. */
  sshClientCertPass: Secret | undefined;
}

/** AuthConfigTemplate defines required field over an authentication type. */
export interface AuthConfigTemplate {
  /** The type of authentication configured. */
  authType: AuthType;
  /** Config variables to describe an `AuthConfig` for a `Connection`. */
  configVariableTemplates: ConfigVariableTemplate[];
  /** Display name for authentication template. */
  displayName: string;
  /** Connector specific description for an authentication template. */
  description: string;
}

function createBaseAuthConfig(): AuthConfig {
  return {
    authType: 0,
    userPassword: undefined,
    oauth2JwtBearer: undefined,
    oauth2ClientCredentials: undefined,
    sshPublicKey: undefined,
    additionalVariables: [],
  };
}

export const AuthConfig: MessageFns<AuthConfig> = {
  encode(message: AuthConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authType !== 0) {
      writer.uint32(8).int32(message.authType);
    }
    if (message.userPassword !== undefined) {
      AuthConfig_UserPassword.encode(message.userPassword, writer.uint32(18).fork()).join();
    }
    if (message.oauth2JwtBearer !== undefined) {
      AuthConfig_Oauth2JwtBearer.encode(message.oauth2JwtBearer, writer.uint32(26).fork()).join();
    }
    if (message.oauth2ClientCredentials !== undefined) {
      AuthConfig_Oauth2ClientCredentials.encode(message.oauth2ClientCredentials, writer.uint32(34).fork()).join();
    }
    if (message.sshPublicKey !== undefined) {
      AuthConfig_SshPublicKey.encode(message.sshPublicKey, writer.uint32(50).fork()).join();
    }
    for (const v of message.additionalVariables) {
      ConfigVariable.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.authType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userPassword = AuthConfig_UserPassword.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.oauth2JwtBearer = AuthConfig_Oauth2JwtBearer.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.oauth2ClientCredentials = AuthConfig_Oauth2ClientCredentials.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sshPublicKey = AuthConfig_SshPublicKey.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.additionalVariables.push(ConfigVariable.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig {
    return {
      authType: isSet(object.authType) ? authTypeFromJSON(object.authType) : 0,
      userPassword: isSet(object.userPassword) ? AuthConfig_UserPassword.fromJSON(object.userPassword) : undefined,
      oauth2JwtBearer: isSet(object.oauth2JwtBearer)
        ? AuthConfig_Oauth2JwtBearer.fromJSON(object.oauth2JwtBearer)
        : undefined,
      oauth2ClientCredentials: isSet(object.oauth2ClientCredentials)
        ? AuthConfig_Oauth2ClientCredentials.fromJSON(object.oauth2ClientCredentials)
        : undefined,
      sshPublicKey: isSet(object.sshPublicKey) ? AuthConfig_SshPublicKey.fromJSON(object.sshPublicKey) : undefined,
      additionalVariables: globalThis.Array.isArray(object?.additionalVariables)
        ? object.additionalVariables.map((e: any) => ConfigVariable.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AuthConfig): unknown {
    const obj: any = {};
    if (message.authType !== 0) {
      obj.authType = authTypeToJSON(message.authType);
    }
    if (message.userPassword !== undefined) {
      obj.userPassword = AuthConfig_UserPassword.toJSON(message.userPassword);
    }
    if (message.oauth2JwtBearer !== undefined) {
      obj.oauth2JwtBearer = AuthConfig_Oauth2JwtBearer.toJSON(message.oauth2JwtBearer);
    }
    if (message.oauth2ClientCredentials !== undefined) {
      obj.oauth2ClientCredentials = AuthConfig_Oauth2ClientCredentials.toJSON(message.oauth2ClientCredentials);
    }
    if (message.sshPublicKey !== undefined) {
      obj.sshPublicKey = AuthConfig_SshPublicKey.toJSON(message.sshPublicKey);
    }
    if (message.additionalVariables?.length) {
      obj.additionalVariables = message.additionalVariables.map((e) => ConfigVariable.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AuthConfig>): AuthConfig {
    return AuthConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthConfig>): AuthConfig {
    const message = createBaseAuthConfig();
    message.authType = object.authType ?? 0;
    message.userPassword = (object.userPassword !== undefined && object.userPassword !== null)
      ? AuthConfig_UserPassword.fromPartial(object.userPassword)
      : undefined;
    message.oauth2JwtBearer = (object.oauth2JwtBearer !== undefined && object.oauth2JwtBearer !== null)
      ? AuthConfig_Oauth2JwtBearer.fromPartial(object.oauth2JwtBearer)
      : undefined;
    message.oauth2ClientCredentials =
      (object.oauth2ClientCredentials !== undefined && object.oauth2ClientCredentials !== null)
        ? AuthConfig_Oauth2ClientCredentials.fromPartial(object.oauth2ClientCredentials)
        : undefined;
    message.sshPublicKey = (object.sshPublicKey !== undefined && object.sshPublicKey !== null)
      ? AuthConfig_SshPublicKey.fromPartial(object.sshPublicKey)
      : undefined;
    message.additionalVariables = object.additionalVariables?.map((e) => ConfigVariable.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAuthConfig_UserPassword(): AuthConfig_UserPassword {
  return { username: "", password: undefined };
}

export const AuthConfig_UserPassword: MessageFns<AuthConfig_UserPassword> = {
  encode(message: AuthConfig_UserPassword, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== undefined) {
      Secret.encode(message.password, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig_UserPassword {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig_UserPassword();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = Secret.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig_UserPassword {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? Secret.fromJSON(object.password) : undefined,
    };
  },

  toJSON(message: AuthConfig_UserPassword): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== undefined) {
      obj.password = Secret.toJSON(message.password);
    }
    return obj;
  },

  create(base?: DeepPartial<AuthConfig_UserPassword>): AuthConfig_UserPassword {
    return AuthConfig_UserPassword.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthConfig_UserPassword>): AuthConfig_UserPassword {
    const message = createBaseAuthConfig_UserPassword();
    message.username = object.username ?? "";
    message.password = (object.password !== undefined && object.password !== null)
      ? Secret.fromPartial(object.password)
      : undefined;
    return message;
  },
};

function createBaseAuthConfig_Oauth2JwtBearer(): AuthConfig_Oauth2JwtBearer {
  return { clientKey: undefined, jwtClaims: undefined };
}

export const AuthConfig_Oauth2JwtBearer: MessageFns<AuthConfig_Oauth2JwtBearer> = {
  encode(message: AuthConfig_Oauth2JwtBearer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientKey !== undefined) {
      Secret.encode(message.clientKey, writer.uint32(10).fork()).join();
    }
    if (message.jwtClaims !== undefined) {
      AuthConfig_Oauth2JwtBearer_JwtClaims.encode(message.jwtClaims, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig_Oauth2JwtBearer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig_Oauth2JwtBearer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientKey = Secret.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.jwtClaims = AuthConfig_Oauth2JwtBearer_JwtClaims.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig_Oauth2JwtBearer {
    return {
      clientKey: isSet(object.clientKey) ? Secret.fromJSON(object.clientKey) : undefined,
      jwtClaims: isSet(object.jwtClaims) ? AuthConfig_Oauth2JwtBearer_JwtClaims.fromJSON(object.jwtClaims) : undefined,
    };
  },

  toJSON(message: AuthConfig_Oauth2JwtBearer): unknown {
    const obj: any = {};
    if (message.clientKey !== undefined) {
      obj.clientKey = Secret.toJSON(message.clientKey);
    }
    if (message.jwtClaims !== undefined) {
      obj.jwtClaims = AuthConfig_Oauth2JwtBearer_JwtClaims.toJSON(message.jwtClaims);
    }
    return obj;
  },

  create(base?: DeepPartial<AuthConfig_Oauth2JwtBearer>): AuthConfig_Oauth2JwtBearer {
    return AuthConfig_Oauth2JwtBearer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthConfig_Oauth2JwtBearer>): AuthConfig_Oauth2JwtBearer {
    const message = createBaseAuthConfig_Oauth2JwtBearer();
    message.clientKey = (object.clientKey !== undefined && object.clientKey !== null)
      ? Secret.fromPartial(object.clientKey)
      : undefined;
    message.jwtClaims = (object.jwtClaims !== undefined && object.jwtClaims !== null)
      ? AuthConfig_Oauth2JwtBearer_JwtClaims.fromPartial(object.jwtClaims)
      : undefined;
    return message;
  },
};

function createBaseAuthConfig_Oauth2JwtBearer_JwtClaims(): AuthConfig_Oauth2JwtBearer_JwtClaims {
  return { issuer: "", subject: "", audience: "" };
}

export const AuthConfig_Oauth2JwtBearer_JwtClaims: MessageFns<AuthConfig_Oauth2JwtBearer_JwtClaims> = {
  encode(message: AuthConfig_Oauth2JwtBearer_JwtClaims, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.issuer !== "") {
      writer.uint32(10).string(message.issuer);
    }
    if (message.subject !== "") {
      writer.uint32(18).string(message.subject);
    }
    if (message.audience !== "") {
      writer.uint32(26).string(message.audience);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig_Oauth2JwtBearer_JwtClaims {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig_Oauth2JwtBearer_JwtClaims();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issuer = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subject = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.audience = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig_Oauth2JwtBearer_JwtClaims {
    return {
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      audience: isSet(object.audience) ? globalThis.String(object.audience) : "",
    };
  },

  toJSON(message: AuthConfig_Oauth2JwtBearer_JwtClaims): unknown {
    const obj: any = {};
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.audience !== "") {
      obj.audience = message.audience;
    }
    return obj;
  },

  create(base?: DeepPartial<AuthConfig_Oauth2JwtBearer_JwtClaims>): AuthConfig_Oauth2JwtBearer_JwtClaims {
    return AuthConfig_Oauth2JwtBearer_JwtClaims.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthConfig_Oauth2JwtBearer_JwtClaims>): AuthConfig_Oauth2JwtBearer_JwtClaims {
    const message = createBaseAuthConfig_Oauth2JwtBearer_JwtClaims();
    message.issuer = object.issuer ?? "";
    message.subject = object.subject ?? "";
    message.audience = object.audience ?? "";
    return message;
  },
};

function createBaseAuthConfig_Oauth2ClientCredentials(): AuthConfig_Oauth2ClientCredentials {
  return { clientId: "", clientSecret: undefined };
}

export const AuthConfig_Oauth2ClientCredentials: MessageFns<AuthConfig_Oauth2ClientCredentials> = {
  encode(message: AuthConfig_Oauth2ClientCredentials, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.clientSecret !== undefined) {
      Secret.encode(message.clientSecret, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig_Oauth2ClientCredentials {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig_Oauth2ClientCredentials();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clientSecret = Secret.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig_Oauth2ClientCredentials {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      clientSecret: isSet(object.clientSecret) ? Secret.fromJSON(object.clientSecret) : undefined,
    };
  },

  toJSON(message: AuthConfig_Oauth2ClientCredentials): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.clientSecret !== undefined) {
      obj.clientSecret = Secret.toJSON(message.clientSecret);
    }
    return obj;
  },

  create(base?: DeepPartial<AuthConfig_Oauth2ClientCredentials>): AuthConfig_Oauth2ClientCredentials {
    return AuthConfig_Oauth2ClientCredentials.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthConfig_Oauth2ClientCredentials>): AuthConfig_Oauth2ClientCredentials {
    const message = createBaseAuthConfig_Oauth2ClientCredentials();
    message.clientId = object.clientId ?? "";
    message.clientSecret = (object.clientSecret !== undefined && object.clientSecret !== null)
      ? Secret.fromPartial(object.clientSecret)
      : undefined;
    return message;
  },
};

function createBaseAuthConfig_SshPublicKey(): AuthConfig_SshPublicKey {
  return { username: "", sshClientCert: undefined, certType: "", sshClientCertPass: undefined };
}

export const AuthConfig_SshPublicKey: MessageFns<AuthConfig_SshPublicKey> = {
  encode(message: AuthConfig_SshPublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.sshClientCert !== undefined) {
      Secret.encode(message.sshClientCert, writer.uint32(26).fork()).join();
    }
    if (message.certType !== "") {
      writer.uint32(34).string(message.certType);
    }
    if (message.sshClientCertPass !== undefined) {
      Secret.encode(message.sshClientCertPass, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig_SshPublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig_SshPublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sshClientCert = Secret.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.certType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.sshClientCertPass = Secret.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig_SshPublicKey {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      sshClientCert: isSet(object.sshClientCert) ? Secret.fromJSON(object.sshClientCert) : undefined,
      certType: isSet(object.certType) ? globalThis.String(object.certType) : "",
      sshClientCertPass: isSet(object.sshClientCertPass) ? Secret.fromJSON(object.sshClientCertPass) : undefined,
    };
  },

  toJSON(message: AuthConfig_SshPublicKey): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.sshClientCert !== undefined) {
      obj.sshClientCert = Secret.toJSON(message.sshClientCert);
    }
    if (message.certType !== "") {
      obj.certType = message.certType;
    }
    if (message.sshClientCertPass !== undefined) {
      obj.sshClientCertPass = Secret.toJSON(message.sshClientCertPass);
    }
    return obj;
  },

  create(base?: DeepPartial<AuthConfig_SshPublicKey>): AuthConfig_SshPublicKey {
    return AuthConfig_SshPublicKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthConfig_SshPublicKey>): AuthConfig_SshPublicKey {
    const message = createBaseAuthConfig_SshPublicKey();
    message.username = object.username ?? "";
    message.sshClientCert = (object.sshClientCert !== undefined && object.sshClientCert !== null)
      ? Secret.fromPartial(object.sshClientCert)
      : undefined;
    message.certType = object.certType ?? "";
    message.sshClientCertPass = (object.sshClientCertPass !== undefined && object.sshClientCertPass !== null)
      ? Secret.fromPartial(object.sshClientCertPass)
      : undefined;
    return message;
  },
};

function createBaseAuthConfigTemplate(): AuthConfigTemplate {
  return { authType: 0, configVariableTemplates: [], displayName: "", description: "" };
}

export const AuthConfigTemplate: MessageFns<AuthConfigTemplate> = {
  encode(message: AuthConfigTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authType !== 0) {
      writer.uint32(8).int32(message.authType);
    }
    for (const v of message.configVariableTemplates) {
      ConfigVariableTemplate.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfigTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfigTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.authType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.configVariableTemplates.push(ConfigVariableTemplate.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfigTemplate {
    return {
      authType: isSet(object.authType) ? authTypeFromJSON(object.authType) : 0,
      configVariableTemplates: globalThis.Array.isArray(object?.configVariableTemplates)
        ? object.configVariableTemplates.map((e: any) => ConfigVariableTemplate.fromJSON(e))
        : [],
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: AuthConfigTemplate): unknown {
    const obj: any = {};
    if (message.authType !== 0) {
      obj.authType = authTypeToJSON(message.authType);
    }
    if (message.configVariableTemplates?.length) {
      obj.configVariableTemplates = message.configVariableTemplates.map((e) => ConfigVariableTemplate.toJSON(e));
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<AuthConfigTemplate>): AuthConfigTemplate {
    return AuthConfigTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthConfigTemplate>): AuthConfigTemplate {
    const message = createBaseAuthConfigTemplate();
    message.authType = object.authType ?? 0;
    message.configVariableTemplates =
      object.configVariableTemplates?.map((e) => ConfigVariableTemplate.fromPartial(e)) || [];
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
