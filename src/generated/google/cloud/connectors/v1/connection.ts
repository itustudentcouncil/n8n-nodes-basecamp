// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/connectors/v1/connection.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Struct, Value } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { AuthConfig } from "./authconfig.js";
import { ConfigVariable } from "./common.js";
import { DestinationConfig } from "./destination_config.js";
import { SslConfig } from "./ssl_config.js";

export const protobufPackage = "google.cloud.connectors.v1";

/** All possible data types of a entity or action field. */
export enum DataType {
  /** DATA_TYPE_UNSPECIFIED - Data type is not specified. */
  DATA_TYPE_UNSPECIFIED = 0,
  /**
   * DATA_TYPE_INT - DEPRECATED! Use DATA_TYPE_INTEGER.
   *
   * @deprecated
   */
  DATA_TYPE_INT = 1,
  /** DATA_TYPE_SMALLINT - Short integer(int16) data type. */
  DATA_TYPE_SMALLINT = 2,
  /** DATA_TYPE_DOUBLE - Double data type. */
  DATA_TYPE_DOUBLE = 3,
  /** DATA_TYPE_DATE - Date data type. */
  DATA_TYPE_DATE = 4,
  /**
   * DATA_TYPE_DATETIME - DEPRECATED! Use DATA_TYPE_TIMESTAMP.
   *
   * @deprecated
   */
  DATA_TYPE_DATETIME = 5,
  /** DATA_TYPE_TIME - Time data type. */
  DATA_TYPE_TIME = 6,
  /**
   * DATA_TYPE_STRING - DEPRECATED! Use DATA_TYPE_VARCHAR.
   *
   * @deprecated
   */
  DATA_TYPE_STRING = 7,
  /**
   * DATA_TYPE_LONG - DEPRECATED! Use DATA_TYPE_BIGINT.
   *
   * @deprecated
   */
  DATA_TYPE_LONG = 8,
  /** DATA_TYPE_BOOLEAN - Boolean data type. */
  DATA_TYPE_BOOLEAN = 9,
  /** DATA_TYPE_DECIMAL - Decimal data type. */
  DATA_TYPE_DECIMAL = 10,
  /**
   * DATA_TYPE_UUID - DEPRECATED! Use DATA_TYPE_VARCHAR.
   *
   * @deprecated
   */
  DATA_TYPE_UUID = 11,
  /** DATA_TYPE_BLOB - UNSUPPORTED! Binary data type. */
  DATA_TYPE_BLOB = 12,
  /** DATA_TYPE_BIT - Bit data type. */
  DATA_TYPE_BIT = 13,
  /** DATA_TYPE_TINYINT - Small integer(int8) data type. */
  DATA_TYPE_TINYINT = 14,
  /** DATA_TYPE_INTEGER - Integer(int32) data type. */
  DATA_TYPE_INTEGER = 15,
  /** DATA_TYPE_BIGINT - Long integer(int64) data type. */
  DATA_TYPE_BIGINT = 16,
  /** DATA_TYPE_FLOAT - Float data type. */
  DATA_TYPE_FLOAT = 17,
  /** DATA_TYPE_REAL - Real data type. */
  DATA_TYPE_REAL = 18,
  /** DATA_TYPE_NUMERIC - Numeric data type. */
  DATA_TYPE_NUMERIC = 19,
  /** DATA_TYPE_CHAR - Char data type. */
  DATA_TYPE_CHAR = 20,
  /** DATA_TYPE_VARCHAR - Varchar data type. */
  DATA_TYPE_VARCHAR = 21,
  /** DATA_TYPE_LONGVARCHAR - Longvarchar data type. */
  DATA_TYPE_LONGVARCHAR = 22,
  /** DATA_TYPE_TIMESTAMP - Timestamp data type. */
  DATA_TYPE_TIMESTAMP = 23,
  /** DATA_TYPE_NCHAR - Nchar data type. */
  DATA_TYPE_NCHAR = 24,
  /** DATA_TYPE_NVARCHAR - Nvarchar data type. */
  DATA_TYPE_NVARCHAR = 25,
  /** DATA_TYPE_LONGNVARCHAR - Longnvarchar data type. */
  DATA_TYPE_LONGNVARCHAR = 26,
  /** DATA_TYPE_NULL - Null data type. */
  DATA_TYPE_NULL = 27,
  /** DATA_TYPE_OTHER - UNSUPPORTED! Binary data type. */
  DATA_TYPE_OTHER = 28,
  /** DATA_TYPE_JAVA_OBJECT - UNSUPPORTED! Binary data type. */
  DATA_TYPE_JAVA_OBJECT = 29,
  /** DATA_TYPE_DISTINCT - UNSUPPORTED! Binary data type. */
  DATA_TYPE_DISTINCT = 30,
  /** DATA_TYPE_STRUCT - UNSUPPORTED! Binary data type. */
  DATA_TYPE_STRUCT = 31,
  /** DATA_TYPE_ARRAY - UNSUPPORTED! Binary data type. */
  DATA_TYPE_ARRAY = 32,
  /** DATA_TYPE_CLOB - UNSUPPORTED! Binary data type. */
  DATA_TYPE_CLOB = 33,
  /** DATA_TYPE_REF - UNSUPPORTED! Binary data type. */
  DATA_TYPE_REF = 34,
  /** DATA_TYPE_DATALINK - UNSUPPORTED! Binary data type. */
  DATA_TYPE_DATALINK = 35,
  /** DATA_TYPE_ROWID - UNSUPPORTED! Row id data type. */
  DATA_TYPE_ROWID = 36,
  /** DATA_TYPE_BINARY - UNSUPPORTED! Binary data type. */
  DATA_TYPE_BINARY = 37,
  /** DATA_TYPE_VARBINARY - UNSUPPORTED! Variable binary data type. */
  DATA_TYPE_VARBINARY = 38,
  /** DATA_TYPE_LONGVARBINARY - UNSUPPORTED! Long variable binary data type. */
  DATA_TYPE_LONGVARBINARY = 39,
  /** DATA_TYPE_NCLOB - UNSUPPORTED! NCLOB data type. */
  DATA_TYPE_NCLOB = 40,
  /** DATA_TYPE_SQLXML - UNSUPPORTED! SQL XML data type is not supported. */
  DATA_TYPE_SQLXML = 41,
  /** DATA_TYPE_REF_CURSOR - UNSUPPORTED! Cursor reference type is not supported. */
  DATA_TYPE_REF_CURSOR = 42,
  /** DATA_TYPE_TIME_WITH_TIMEZONE - UNSUPPORTED! Use TIME or TIMESTAMP instead. */
  DATA_TYPE_TIME_WITH_TIMEZONE = 43,
  /** DATA_TYPE_TIMESTAMP_WITH_TIMEZONE - UNSUPPORTED! Use TIMESTAMP instead. */
  DATA_TYPE_TIMESTAMP_WITH_TIMEZONE = 44,
  UNRECOGNIZED = -1,
}

export function dataTypeFromJSON(object: any): DataType {
  switch (object) {
    case 0:
    case "DATA_TYPE_UNSPECIFIED":
      return DataType.DATA_TYPE_UNSPECIFIED;
    case 1:
    case "DATA_TYPE_INT":
      return DataType.DATA_TYPE_INT;
    case 2:
    case "DATA_TYPE_SMALLINT":
      return DataType.DATA_TYPE_SMALLINT;
    case 3:
    case "DATA_TYPE_DOUBLE":
      return DataType.DATA_TYPE_DOUBLE;
    case 4:
    case "DATA_TYPE_DATE":
      return DataType.DATA_TYPE_DATE;
    case 5:
    case "DATA_TYPE_DATETIME":
      return DataType.DATA_TYPE_DATETIME;
    case 6:
    case "DATA_TYPE_TIME":
      return DataType.DATA_TYPE_TIME;
    case 7:
    case "DATA_TYPE_STRING":
      return DataType.DATA_TYPE_STRING;
    case 8:
    case "DATA_TYPE_LONG":
      return DataType.DATA_TYPE_LONG;
    case 9:
    case "DATA_TYPE_BOOLEAN":
      return DataType.DATA_TYPE_BOOLEAN;
    case 10:
    case "DATA_TYPE_DECIMAL":
      return DataType.DATA_TYPE_DECIMAL;
    case 11:
    case "DATA_TYPE_UUID":
      return DataType.DATA_TYPE_UUID;
    case 12:
    case "DATA_TYPE_BLOB":
      return DataType.DATA_TYPE_BLOB;
    case 13:
    case "DATA_TYPE_BIT":
      return DataType.DATA_TYPE_BIT;
    case 14:
    case "DATA_TYPE_TINYINT":
      return DataType.DATA_TYPE_TINYINT;
    case 15:
    case "DATA_TYPE_INTEGER":
      return DataType.DATA_TYPE_INTEGER;
    case 16:
    case "DATA_TYPE_BIGINT":
      return DataType.DATA_TYPE_BIGINT;
    case 17:
    case "DATA_TYPE_FLOAT":
      return DataType.DATA_TYPE_FLOAT;
    case 18:
    case "DATA_TYPE_REAL":
      return DataType.DATA_TYPE_REAL;
    case 19:
    case "DATA_TYPE_NUMERIC":
      return DataType.DATA_TYPE_NUMERIC;
    case 20:
    case "DATA_TYPE_CHAR":
      return DataType.DATA_TYPE_CHAR;
    case 21:
    case "DATA_TYPE_VARCHAR":
      return DataType.DATA_TYPE_VARCHAR;
    case 22:
    case "DATA_TYPE_LONGVARCHAR":
      return DataType.DATA_TYPE_LONGVARCHAR;
    case 23:
    case "DATA_TYPE_TIMESTAMP":
      return DataType.DATA_TYPE_TIMESTAMP;
    case 24:
    case "DATA_TYPE_NCHAR":
      return DataType.DATA_TYPE_NCHAR;
    case 25:
    case "DATA_TYPE_NVARCHAR":
      return DataType.DATA_TYPE_NVARCHAR;
    case 26:
    case "DATA_TYPE_LONGNVARCHAR":
      return DataType.DATA_TYPE_LONGNVARCHAR;
    case 27:
    case "DATA_TYPE_NULL":
      return DataType.DATA_TYPE_NULL;
    case 28:
    case "DATA_TYPE_OTHER":
      return DataType.DATA_TYPE_OTHER;
    case 29:
    case "DATA_TYPE_JAVA_OBJECT":
      return DataType.DATA_TYPE_JAVA_OBJECT;
    case 30:
    case "DATA_TYPE_DISTINCT":
      return DataType.DATA_TYPE_DISTINCT;
    case 31:
    case "DATA_TYPE_STRUCT":
      return DataType.DATA_TYPE_STRUCT;
    case 32:
    case "DATA_TYPE_ARRAY":
      return DataType.DATA_TYPE_ARRAY;
    case 33:
    case "DATA_TYPE_CLOB":
      return DataType.DATA_TYPE_CLOB;
    case 34:
    case "DATA_TYPE_REF":
      return DataType.DATA_TYPE_REF;
    case 35:
    case "DATA_TYPE_DATALINK":
      return DataType.DATA_TYPE_DATALINK;
    case 36:
    case "DATA_TYPE_ROWID":
      return DataType.DATA_TYPE_ROWID;
    case 37:
    case "DATA_TYPE_BINARY":
      return DataType.DATA_TYPE_BINARY;
    case 38:
    case "DATA_TYPE_VARBINARY":
      return DataType.DATA_TYPE_VARBINARY;
    case 39:
    case "DATA_TYPE_LONGVARBINARY":
      return DataType.DATA_TYPE_LONGVARBINARY;
    case 40:
    case "DATA_TYPE_NCLOB":
      return DataType.DATA_TYPE_NCLOB;
    case 41:
    case "DATA_TYPE_SQLXML":
      return DataType.DATA_TYPE_SQLXML;
    case 42:
    case "DATA_TYPE_REF_CURSOR":
      return DataType.DATA_TYPE_REF_CURSOR;
    case 43:
    case "DATA_TYPE_TIME_WITH_TIMEZONE":
      return DataType.DATA_TYPE_TIME_WITH_TIMEZONE;
    case 44:
    case "DATA_TYPE_TIMESTAMP_WITH_TIMEZONE":
      return DataType.DATA_TYPE_TIMESTAMP_WITH_TIMEZONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataType.UNRECOGNIZED;
  }
}

export function dataTypeToJSON(object: DataType): string {
  switch (object) {
    case DataType.DATA_TYPE_UNSPECIFIED:
      return "DATA_TYPE_UNSPECIFIED";
    case DataType.DATA_TYPE_INT:
      return "DATA_TYPE_INT";
    case DataType.DATA_TYPE_SMALLINT:
      return "DATA_TYPE_SMALLINT";
    case DataType.DATA_TYPE_DOUBLE:
      return "DATA_TYPE_DOUBLE";
    case DataType.DATA_TYPE_DATE:
      return "DATA_TYPE_DATE";
    case DataType.DATA_TYPE_DATETIME:
      return "DATA_TYPE_DATETIME";
    case DataType.DATA_TYPE_TIME:
      return "DATA_TYPE_TIME";
    case DataType.DATA_TYPE_STRING:
      return "DATA_TYPE_STRING";
    case DataType.DATA_TYPE_LONG:
      return "DATA_TYPE_LONG";
    case DataType.DATA_TYPE_BOOLEAN:
      return "DATA_TYPE_BOOLEAN";
    case DataType.DATA_TYPE_DECIMAL:
      return "DATA_TYPE_DECIMAL";
    case DataType.DATA_TYPE_UUID:
      return "DATA_TYPE_UUID";
    case DataType.DATA_TYPE_BLOB:
      return "DATA_TYPE_BLOB";
    case DataType.DATA_TYPE_BIT:
      return "DATA_TYPE_BIT";
    case DataType.DATA_TYPE_TINYINT:
      return "DATA_TYPE_TINYINT";
    case DataType.DATA_TYPE_INTEGER:
      return "DATA_TYPE_INTEGER";
    case DataType.DATA_TYPE_BIGINT:
      return "DATA_TYPE_BIGINT";
    case DataType.DATA_TYPE_FLOAT:
      return "DATA_TYPE_FLOAT";
    case DataType.DATA_TYPE_REAL:
      return "DATA_TYPE_REAL";
    case DataType.DATA_TYPE_NUMERIC:
      return "DATA_TYPE_NUMERIC";
    case DataType.DATA_TYPE_CHAR:
      return "DATA_TYPE_CHAR";
    case DataType.DATA_TYPE_VARCHAR:
      return "DATA_TYPE_VARCHAR";
    case DataType.DATA_TYPE_LONGVARCHAR:
      return "DATA_TYPE_LONGVARCHAR";
    case DataType.DATA_TYPE_TIMESTAMP:
      return "DATA_TYPE_TIMESTAMP";
    case DataType.DATA_TYPE_NCHAR:
      return "DATA_TYPE_NCHAR";
    case DataType.DATA_TYPE_NVARCHAR:
      return "DATA_TYPE_NVARCHAR";
    case DataType.DATA_TYPE_LONGNVARCHAR:
      return "DATA_TYPE_LONGNVARCHAR";
    case DataType.DATA_TYPE_NULL:
      return "DATA_TYPE_NULL";
    case DataType.DATA_TYPE_OTHER:
      return "DATA_TYPE_OTHER";
    case DataType.DATA_TYPE_JAVA_OBJECT:
      return "DATA_TYPE_JAVA_OBJECT";
    case DataType.DATA_TYPE_DISTINCT:
      return "DATA_TYPE_DISTINCT";
    case DataType.DATA_TYPE_STRUCT:
      return "DATA_TYPE_STRUCT";
    case DataType.DATA_TYPE_ARRAY:
      return "DATA_TYPE_ARRAY";
    case DataType.DATA_TYPE_CLOB:
      return "DATA_TYPE_CLOB";
    case DataType.DATA_TYPE_REF:
      return "DATA_TYPE_REF";
    case DataType.DATA_TYPE_DATALINK:
      return "DATA_TYPE_DATALINK";
    case DataType.DATA_TYPE_ROWID:
      return "DATA_TYPE_ROWID";
    case DataType.DATA_TYPE_BINARY:
      return "DATA_TYPE_BINARY";
    case DataType.DATA_TYPE_VARBINARY:
      return "DATA_TYPE_VARBINARY";
    case DataType.DATA_TYPE_LONGVARBINARY:
      return "DATA_TYPE_LONGVARBINARY";
    case DataType.DATA_TYPE_NCLOB:
      return "DATA_TYPE_NCLOB";
    case DataType.DATA_TYPE_SQLXML:
      return "DATA_TYPE_SQLXML";
    case DataType.DATA_TYPE_REF_CURSOR:
      return "DATA_TYPE_REF_CURSOR";
    case DataType.DATA_TYPE_TIME_WITH_TIMEZONE:
      return "DATA_TYPE_TIME_WITH_TIMEZONE";
    case DataType.DATA_TYPE_TIMESTAMP_WITH_TIMEZONE:
      return "DATA_TYPE_TIMESTAMP_WITH_TIMEZONE";
    case DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enum to control which fields should be included in the response. */
export enum ConnectionView {
  /** CONNECTION_VIEW_UNSPECIFIED - CONNECTION_UNSPECIFIED. */
  CONNECTION_VIEW_UNSPECIFIED = 0,
  /** BASIC - Do not include runtime required configs. */
  BASIC = 1,
  /** FULL - Include runtime required configs. */
  FULL = 2,
  UNRECOGNIZED = -1,
}

export function connectionViewFromJSON(object: any): ConnectionView {
  switch (object) {
    case 0:
    case "CONNECTION_VIEW_UNSPECIFIED":
      return ConnectionView.CONNECTION_VIEW_UNSPECIFIED;
    case 1:
    case "BASIC":
      return ConnectionView.BASIC;
    case 2:
    case "FULL":
      return ConnectionView.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectionView.UNRECOGNIZED;
  }
}

export function connectionViewToJSON(object: ConnectionView): string {
  switch (object) {
    case ConnectionView.CONNECTION_VIEW_UNSPECIFIED:
      return "CONNECTION_VIEW_UNSPECIFIED";
    case ConnectionView.BASIC:
      return "BASIC";
    case ConnectionView.FULL:
      return "FULL";
    case ConnectionView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Connection represents an instance of connector. */
export interface Connection {
  /**
   * Output only. Resource name of the Connection.
   * Format: projects/{project}/locations/{location}/connections/{connection}
   */
  name: string;
  /** Output only. Created time. */
  createTime:
    | Date
    | undefined;
  /** Output only. Updated time. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. Resource labels to represent user-provided metadata.
   * Refer to cloud documentation on labels for more details.
   * https://cloud.google.com/compute/docs/labeling-resources
   */
  labels: { [key: string]: string };
  /** Optional. Description of the resource. */
  description: string;
  /**
   * Required. Connector version on which the connection is created.
   * The format is:
   * projects/* /locations/* /providers/* /connectors/* /versions/*
   * Only global location is supported for ConnectorVersion resource.
   */
  connectorVersion: string;
  /** Output only. Current status of the connection. */
  status:
    | ConnectionStatus
    | undefined;
  /**
   * Optional. Configuration for configuring the connection with an external
   * system.
   */
  configVariables: ConfigVariable[];
  /**
   * Optional. Configuration for establishing the connection's authentication
   * with an external system.
   */
  authConfig:
    | AuthConfig
    | undefined;
  /**
   * Optional. Configuration that indicates whether or not the Connection can be
   * edited.
   */
  lockConfig:
    | LockConfig
    | undefined;
  /**
   * Optional. Configuration of the Connector's destination. Only accepted for
   * Connectors that accepts user defined destination(s).
   */
  destinationConfigs: DestinationConfig[];
  /**
   * Output only. GCR location where the runtime image is stored.
   * formatted like: gcr.io/{bucketName}/{imageName}
   */
  imageLocation: string;
  /** Optional. Service account needed for runtime plane to access GCP resources. */
  serviceAccount: string;
  /**
   * Output only. The name of the Service Directory service name. Used for
   * Private Harpoon to resolve the ILB address.
   * e.g.
   * "projects/cloud-connectors-e2e-testing/locations/us-central1/namespaces/istio-system/services/istio-ingressgateway-connectors"
   */
  serviceDirectory: string;
  /**
   * Output only. GCR location where the envoy image is stored.
   * formatted like: gcr.io/{bucketName}/{imageName}
   */
  envoyImageLocation: string;
  /** Optional. Suspended indicates if a user has suspended a connection or not. */
  suspended: boolean;
  /** Optional. Node configuration for the connection. */
  nodeConfig:
    | NodeConfig
    | undefined;
  /** Optional. Ssl config of a connection */
  sslConfig: SslConfig | undefined;
}

export interface Connection_LabelsEntry {
  key: string;
  value: string;
}

/** Node configuration for the connection. */
export interface NodeConfig {
  /** Minimum number of nodes in the runtime nodes. */
  minNodeCount: number;
  /** Maximum number of nodes in the runtime nodes. */
  maxNodeCount: number;
}

/**
 * ConnectionSchemaMetadata is the singleton resource of each connection.
 * It includes the entity and action names of runtime resources exposed
 * by a connection backend.
 */
export interface ConnectionSchemaMetadata {
  /** Output only. List of entity names. */
  entities: string[];
  /** Output only. List of actions. */
  actions: string[];
  /**
   * Output only. Resource name.
   * Format:
   * projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata
   */
  name: string;
  /** Output only. Timestamp when the connection runtime schema was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Timestamp when the connection runtime schema refresh was
   * triggered.
   */
  refreshTime:
    | Date
    | undefined;
  /** Output only. The current state of runtime schema. */
  state: ConnectionSchemaMetadata_State;
}

/** State of connection runtime schema. */
export enum ConnectionSchemaMetadata_State {
  /** STATE_UNSPECIFIED - Default state. */
  STATE_UNSPECIFIED = 0,
  /** REFRESHING - Schema refresh is in progress. */
  REFRESHING = 1,
  /** UPDATED - Schema has been updated. */
  UPDATED = 2,
  UNRECOGNIZED = -1,
}

export function connectionSchemaMetadata_StateFromJSON(object: any): ConnectionSchemaMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ConnectionSchemaMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "REFRESHING":
      return ConnectionSchemaMetadata_State.REFRESHING;
    case 2:
    case "UPDATED":
      return ConnectionSchemaMetadata_State.UPDATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectionSchemaMetadata_State.UNRECOGNIZED;
  }
}

export function connectionSchemaMetadata_StateToJSON(object: ConnectionSchemaMetadata_State): string {
  switch (object) {
    case ConnectionSchemaMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ConnectionSchemaMetadata_State.REFRESHING:
      return "REFRESHING";
    case ConnectionSchemaMetadata_State.UPDATED:
      return "UPDATED";
    case ConnectionSchemaMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Schema of a runtime entity. */
export interface RuntimeEntitySchema {
  /** Output only. Name of the entity. */
  entity: string;
  /** Output only. List of fields in the entity. */
  fields: RuntimeEntitySchema_Field[];
}

/** Metadata of an entity field. */
export interface RuntimeEntitySchema_Field {
  /** Name of the Field. */
  field: string;
  /** A brief description of the Field. */
  description: string;
  /** The data type of the Field. */
  dataType: DataType;
  /**
   * The following boolean field specifies if the current Field acts
   * as a primary key or id if the parent is of type entity.
   */
  key: boolean;
  /** Specifies if the Field is readonly. */
  readonly: boolean;
  /** Specifies whether a null value is allowed. */
  nullable: boolean;
  /**
   * The following field specifies the default value of the Field provided
   * by the external system if a value is not provided.
   */
  defaultValue:
    | any
    | undefined;
  /**
   * The following map contains fields that are not explicitly mentioned
   * above,this give connectors the flexibility to add new metadata
   * fields.
   */
  additionalDetails: { [key: string]: any } | undefined;
}

/** Schema of a runtime action. */
export interface RuntimeActionSchema {
  /** Output only. Name of the action. */
  action: string;
  /** Output only. List of input parameter metadata for the action. */
  inputParameters: RuntimeActionSchema_InputParameter[];
  /** Output only. List of result field metadata. */
  resultMetadata: RuntimeActionSchema_ResultMetadata[];
}

/** Metadata of an input parameter. */
export interface RuntimeActionSchema_InputParameter {
  /** Name of the Parameter. */
  parameter: string;
  /** A brief description of the Parameter. */
  description: string;
  /** The data type of the Parameter. */
  dataType: DataType;
  /** Specifies whether a null value is allowed. */
  nullable: boolean;
  /**
   * The following field specifies the default value of the Parameter
   * provided by the external system if a value is not provided.
   */
  defaultValue: any | undefined;
}

/** Metadata of result field. */
export interface RuntimeActionSchema_ResultMetadata {
  /** Name of the result field. */
  field: string;
  /** A brief description of the field. */
  description: string;
  /** The data type of the field. */
  dataType: DataType;
}

/**
 * Determines whether or no a connection is locked. If locked, a reason must be
 * specified.
 */
export interface LockConfig {
  /** Indicates whether or not the connection is locked. */
  locked: boolean;
  /** Describes why a connection is locked. */
  reason: string;
}

/** Request message for ConnectorsService.ListConnections */
export interface ListConnectionsRequest {
  /**
   * Required. Parent resource of the Connection, of the form:
   * `projects/* /locations/*`
   */
  parent: string;
  /** Page size. */
  pageSize: number;
  /** Page token. */
  pageToken: string;
  /** Filter. */
  filter: string;
  /** Order by parameters. */
  orderBy: string;
  /**
   * Specifies which fields of the Connection are returned in the response.
   * Defaults to `BASIC` view.
   */
  view: ConnectionView;
}

/** Response message for ConnectorsService.ListConnections */
export interface ListConnectionsResponse {
  /** Connections. */
  connections: Connection[];
  /** Next page token. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for ConnectorsService.GetConnection */
export interface GetConnectionRequest {
  /**
   * Required. Resource name of the form:
   * `projects/* /locations/* /connections/*`
   */
  name: string;
  /**
   * Specifies which fields of the Connection are returned in the response.
   * Defaults to `BASIC` view.
   */
  view: ConnectionView;
}

/** Request message for ConnectorsService.CreateConnection */
export interface CreateConnectionRequest {
  /**
   * Required. Parent resource of the Connection, of the form:
   * `projects/* /locations/*`
   */
  parent: string;
  /**
   * Required. Identifier to assign to the Connection. Must be unique within
   * scope of the parent resource.
   */
  connectionId: string;
  /** Required. Connection resource. */
  connection: Connection | undefined;
}

/** Request message for ConnectorsService.UpdateConnection */
export interface UpdateConnectionRequest {
  /** Required. Connection resource. */
  connection:
    | Connection
    | undefined;
  /**
   * Required. You can modify only the fields listed below.
   *
   * To lock/unlock a connection:
   * * `lock_config`
   *
   * To suspend/resume a connection:
   * * `suspended`
   *
   * To update the connection details:
   * * `description`
   * * `labels`
   * * `connector_version`
   * * `config_variables`
   * * `auth_config`
   * * `destination_configs`
   * * `node_config`
   */
  updateMask: string[] | undefined;
}

/** Request message for ConnectorsService.DeleteConnection. */
export interface DeleteConnectionRequest {
  /**
   * Required. Resource name of the form:
   * `projects/* /locations/* /connections/*`
   */
  name: string;
}

/** Request message for ConnectorsService.GetConnectionSchemaMetadata. */
export interface GetConnectionSchemaMetadataRequest {
  /**
   * Required. Connection name
   * Format:
   * projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata
   */
  name: string;
}

/** Request message for ConnectorsService.RefreshConnectionSchemaMetadata. */
export interface RefreshConnectionSchemaMetadataRequest {
  /**
   * Required. Resource name.
   * Format:
   * projects/{project}/locations/{location}/connections/{connection}/connectionSchemaMetadata
   */
  name: string;
}

/**
 * Request message for ConnectorsService.ListRuntimeEntitySchemas.
 * For filter, only entity field is supported with literal equality operator.
 * Accepted filter example: entity="Order"
 * Wildcards are not supported in the filter currently.
 */
export interface ListRuntimeEntitySchemasRequest {
  /**
   * Required. Parent resource of RuntimeEntitySchema
   * Format:
   * projects/{project}/locations/{location}/connections/{connection}
   */
  parent: string;
  /** Page size. */
  pageSize: number;
  /** Page token. */
  pageToken: string;
  /**
   * Required. Filter
   * Format:
   * entity="{entityId}"
   * Only entity field is supported with literal equality operator.
   * Accepted filter example: entity="Order"
   * Wildcards are not supported in the filter currently.
   */
  filter: string;
}

/** Response message for ConnectorsService.ListRuntimeEntitySchemas. */
export interface ListRuntimeEntitySchemasResponse {
  /** Runtime entity schemas. */
  runtimeEntitySchemas: RuntimeEntitySchema[];
  /** Next page token. */
  nextPageToken: string;
}

/**
 * Request message for ConnectorsService.ListRuntimeActionSchemas.
 * For filter, only action field is supported with literal equality operator.
 * Accepted filter example: action="approveOrder"
 * Wildcards are not supported in the filter currently.
 */
export interface ListRuntimeActionSchemasRequest {
  /**
   * Required. Parent resource of RuntimeActionSchema
   * Format:
   * projects/{project}/locations/{location}/connections/{connection}
   */
  parent: string;
  /** Page size. */
  pageSize: number;
  /** Page token. */
  pageToken: string;
  /**
   * Required. Filter
   * Format:
   * action="{actionId}"
   * Only action field is supported with literal equality operator.
   * Accepted filter example: action="CancelOrder"
   * Wildcards are not supported in the filter currently.
   */
  filter: string;
}

/** Response message for ConnectorsService.ListRuntimeActionSchemas. */
export interface ListRuntimeActionSchemasResponse {
  /** Runtime action schemas. */
  runtimeActionSchemas: RuntimeActionSchema[];
  /** Next page token. */
  nextPageToken: string;
}

/** ConnectionStatus indicates the state of the connection. */
export interface ConnectionStatus {
  /** State. */
  state: ConnectionStatus_State;
  /** Description. */
  description: string;
  /** Status provides detailed information for the state. */
  status: string;
}

/** All the possible Connection State. */
export enum ConnectionStatus_State {
  /** STATE_UNSPECIFIED - Connection does not have a state yet. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - Connection is being created. */
  CREATING = 1,
  /** ACTIVE - Connection is running and ready for requests. */
  ACTIVE = 2,
  /** INACTIVE - Connection is stopped. */
  INACTIVE = 3,
  /** DELETING - Connection is being deleted. */
  DELETING = 4,
  /** UPDATING - Connection is being updated. */
  UPDATING = 5,
  /** ERROR - Connection is not running due to an error. */
  ERROR = 6,
  /**
   * AUTHORIZATION_REQUIRED - Connection is not running due to an auth error for the Oauth2 Auth Code
   * based connector.
   */
  AUTHORIZATION_REQUIRED = 7,
  UNRECOGNIZED = -1,
}

export function connectionStatus_StateFromJSON(object: any): ConnectionStatus_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ConnectionStatus_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return ConnectionStatus_State.CREATING;
    case 2:
    case "ACTIVE":
      return ConnectionStatus_State.ACTIVE;
    case 3:
    case "INACTIVE":
      return ConnectionStatus_State.INACTIVE;
    case 4:
    case "DELETING":
      return ConnectionStatus_State.DELETING;
    case 5:
    case "UPDATING":
      return ConnectionStatus_State.UPDATING;
    case 6:
    case "ERROR":
      return ConnectionStatus_State.ERROR;
    case 7:
    case "AUTHORIZATION_REQUIRED":
      return ConnectionStatus_State.AUTHORIZATION_REQUIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConnectionStatus_State.UNRECOGNIZED;
  }
}

export function connectionStatus_StateToJSON(object: ConnectionStatus_State): string {
  switch (object) {
    case ConnectionStatus_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ConnectionStatus_State.CREATING:
      return "CREATING";
    case ConnectionStatus_State.ACTIVE:
      return "ACTIVE";
    case ConnectionStatus_State.INACTIVE:
      return "INACTIVE";
    case ConnectionStatus_State.DELETING:
      return "DELETING";
    case ConnectionStatus_State.UPDATING:
      return "UPDATING";
    case ConnectionStatus_State.ERROR:
      return "ERROR";
    case ConnectionStatus_State.AUTHORIZATION_REQUIRED:
      return "AUTHORIZATION_REQUIRED";
    case ConnectionStatus_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseConnection(): Connection {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    connectorVersion: "",
    status: undefined,
    configVariables: [],
    authConfig: undefined,
    lockConfig: undefined,
    destinationConfigs: [],
    imageLocation: "",
    serviceAccount: "",
    serviceDirectory: "",
    envoyImageLocation: "",
    suspended: false,
    nodeConfig: undefined,
    sslConfig: undefined,
  };
}

export const Connection: MessageFns<Connection> = {
  encode(message: Connection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Connection_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.connectorVersion !== "") {
      writer.uint32(50).string(message.connectorVersion);
    }
    if (message.status !== undefined) {
      ConnectionStatus.encode(message.status, writer.uint32(58).fork()).join();
    }
    for (const v of message.configVariables) {
      ConfigVariable.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.authConfig !== undefined) {
      AuthConfig.encode(message.authConfig, writer.uint32(74).fork()).join();
    }
    if (message.lockConfig !== undefined) {
      LockConfig.encode(message.lockConfig, writer.uint32(82).fork()).join();
    }
    for (const v of message.destinationConfigs) {
      DestinationConfig.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.imageLocation !== "") {
      writer.uint32(90).string(message.imageLocation);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(98).string(message.serviceAccount);
    }
    if (message.serviceDirectory !== "") {
      writer.uint32(106).string(message.serviceDirectory);
    }
    if (message.envoyImageLocation !== "") {
      writer.uint32(122).string(message.envoyImageLocation);
    }
    if (message.suspended !== false) {
      writer.uint32(136).bool(message.suspended);
    }
    if (message.nodeConfig !== undefined) {
      NodeConfig.encode(message.nodeConfig, writer.uint32(154).fork()).join();
    }
    if (message.sslConfig !== undefined) {
      SslConfig.encode(message.sslConfig, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Connection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Connection_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.connectorVersion = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.status = ConnectionStatus.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.configVariables.push(ConfigVariable.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.authConfig = AuthConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.lockConfig = LockConfig.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.destinationConfigs.push(DestinationConfig.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.imageLocation = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.serviceDirectory = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.envoyImageLocation = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.suspended = reader.bool();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.nodeConfig = NodeConfig.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.sslConfig = SslConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Connection {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      connectorVersion: isSet(object.connectorVersion) ? globalThis.String(object.connectorVersion) : "",
      status: isSet(object.status) ? ConnectionStatus.fromJSON(object.status) : undefined,
      configVariables: globalThis.Array.isArray(object?.configVariables)
        ? object.configVariables.map((e: any) => ConfigVariable.fromJSON(e))
        : [],
      authConfig: isSet(object.authConfig) ? AuthConfig.fromJSON(object.authConfig) : undefined,
      lockConfig: isSet(object.lockConfig) ? LockConfig.fromJSON(object.lockConfig) : undefined,
      destinationConfigs: globalThis.Array.isArray(object?.destinationConfigs)
        ? object.destinationConfigs.map((e: any) => DestinationConfig.fromJSON(e))
        : [],
      imageLocation: isSet(object.imageLocation) ? globalThis.String(object.imageLocation) : "",
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      serviceDirectory: isSet(object.serviceDirectory) ? globalThis.String(object.serviceDirectory) : "",
      envoyImageLocation: isSet(object.envoyImageLocation) ? globalThis.String(object.envoyImageLocation) : "",
      suspended: isSet(object.suspended) ? globalThis.Boolean(object.suspended) : false,
      nodeConfig: isSet(object.nodeConfig) ? NodeConfig.fromJSON(object.nodeConfig) : undefined,
      sslConfig: isSet(object.sslConfig) ? SslConfig.fromJSON(object.sslConfig) : undefined,
    };
  },

  toJSON(message: Connection): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.connectorVersion !== "") {
      obj.connectorVersion = message.connectorVersion;
    }
    if (message.status !== undefined) {
      obj.status = ConnectionStatus.toJSON(message.status);
    }
    if (message.configVariables?.length) {
      obj.configVariables = message.configVariables.map((e) => ConfigVariable.toJSON(e));
    }
    if (message.authConfig !== undefined) {
      obj.authConfig = AuthConfig.toJSON(message.authConfig);
    }
    if (message.lockConfig !== undefined) {
      obj.lockConfig = LockConfig.toJSON(message.lockConfig);
    }
    if (message.destinationConfigs?.length) {
      obj.destinationConfigs = message.destinationConfigs.map((e) => DestinationConfig.toJSON(e));
    }
    if (message.imageLocation !== "") {
      obj.imageLocation = message.imageLocation;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.serviceDirectory !== "") {
      obj.serviceDirectory = message.serviceDirectory;
    }
    if (message.envoyImageLocation !== "") {
      obj.envoyImageLocation = message.envoyImageLocation;
    }
    if (message.suspended !== false) {
      obj.suspended = message.suspended;
    }
    if (message.nodeConfig !== undefined) {
      obj.nodeConfig = NodeConfig.toJSON(message.nodeConfig);
    }
    if (message.sslConfig !== undefined) {
      obj.sslConfig = SslConfig.toJSON(message.sslConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Connection>): Connection {
    return Connection.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Connection>): Connection {
    const message = createBaseConnection();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.connectorVersion = object.connectorVersion ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? ConnectionStatus.fromPartial(object.status)
      : undefined;
    message.configVariables = object.configVariables?.map((e) => ConfigVariable.fromPartial(e)) || [];
    message.authConfig = (object.authConfig !== undefined && object.authConfig !== null)
      ? AuthConfig.fromPartial(object.authConfig)
      : undefined;
    message.lockConfig = (object.lockConfig !== undefined && object.lockConfig !== null)
      ? LockConfig.fromPartial(object.lockConfig)
      : undefined;
    message.destinationConfigs = object.destinationConfigs?.map((e) => DestinationConfig.fromPartial(e)) || [];
    message.imageLocation = object.imageLocation ?? "";
    message.serviceAccount = object.serviceAccount ?? "";
    message.serviceDirectory = object.serviceDirectory ?? "";
    message.envoyImageLocation = object.envoyImageLocation ?? "";
    message.suspended = object.suspended ?? false;
    message.nodeConfig = (object.nodeConfig !== undefined && object.nodeConfig !== null)
      ? NodeConfig.fromPartial(object.nodeConfig)
      : undefined;
    message.sslConfig = (object.sslConfig !== undefined && object.sslConfig !== null)
      ? SslConfig.fromPartial(object.sslConfig)
      : undefined;
    return message;
  },
};

function createBaseConnection_LabelsEntry(): Connection_LabelsEntry {
  return { key: "", value: "" };
}

export const Connection_LabelsEntry: MessageFns<Connection_LabelsEntry> = {
  encode(message: Connection_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Connection_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnection_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Connection_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Connection_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Connection_LabelsEntry>): Connection_LabelsEntry {
    return Connection_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Connection_LabelsEntry>): Connection_LabelsEntry {
    const message = createBaseConnection_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNodeConfig(): NodeConfig {
  return { minNodeCount: 0, maxNodeCount: 0 };
}

export const NodeConfig: MessageFns<NodeConfig> = {
  encode(message: NodeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minNodeCount !== 0) {
      writer.uint32(8).int32(message.minNodeCount);
    }
    if (message.maxNodeCount !== 0) {
      writer.uint32(16).int32(message.maxNodeCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.minNodeCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxNodeCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeConfig {
    return {
      minNodeCount: isSet(object.minNodeCount) ? globalThis.Number(object.minNodeCount) : 0,
      maxNodeCount: isSet(object.maxNodeCount) ? globalThis.Number(object.maxNodeCount) : 0,
    };
  },

  toJSON(message: NodeConfig): unknown {
    const obj: any = {};
    if (message.minNodeCount !== 0) {
      obj.minNodeCount = Math.round(message.minNodeCount);
    }
    if (message.maxNodeCount !== 0) {
      obj.maxNodeCount = Math.round(message.maxNodeCount);
    }
    return obj;
  },

  create(base?: DeepPartial<NodeConfig>): NodeConfig {
    return NodeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NodeConfig>): NodeConfig {
    const message = createBaseNodeConfig();
    message.minNodeCount = object.minNodeCount ?? 0;
    message.maxNodeCount = object.maxNodeCount ?? 0;
    return message;
  },
};

function createBaseConnectionSchemaMetadata(): ConnectionSchemaMetadata {
  return { entities: [], actions: [], name: "", updateTime: undefined, refreshTime: undefined, state: 0 };
}

export const ConnectionSchemaMetadata: MessageFns<ConnectionSchemaMetadata> = {
  encode(message: ConnectionSchemaMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entities) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.actions) {
      writer.uint32(18).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.refreshTime !== undefined) {
      Timestamp.encode(toTimestamp(message.refreshTime), writer.uint32(42).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionSchemaMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionSchemaMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entities.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.refreshTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionSchemaMetadata {
    return {
      entities: globalThis.Array.isArray(object?.entities) ? object.entities.map((e: any) => globalThis.String(e)) : [],
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => globalThis.String(e)) : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      refreshTime: isSet(object.refreshTime) ? fromJsonTimestamp(object.refreshTime) : undefined,
      state: isSet(object.state) ? connectionSchemaMetadata_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: ConnectionSchemaMetadata): unknown {
    const obj: any = {};
    if (message.entities?.length) {
      obj.entities = message.entities;
    }
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.refreshTime !== undefined) {
      obj.refreshTime = message.refreshTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = connectionSchemaMetadata_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionSchemaMetadata>): ConnectionSchemaMetadata {
    return ConnectionSchemaMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionSchemaMetadata>): ConnectionSchemaMetadata {
    const message = createBaseConnectionSchemaMetadata();
    message.entities = object.entities?.map((e) => e) || [];
    message.actions = object.actions?.map((e) => e) || [];
    message.name = object.name ?? "";
    message.updateTime = object.updateTime ?? undefined;
    message.refreshTime = object.refreshTime ?? undefined;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseRuntimeEntitySchema(): RuntimeEntitySchema {
  return { entity: "", fields: [] };
}

export const RuntimeEntitySchema: MessageFns<RuntimeEntitySchema> = {
  encode(message: RuntimeEntitySchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entity !== "") {
      writer.uint32(10).string(message.entity);
    }
    for (const v of message.fields) {
      RuntimeEntitySchema_Field.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeEntitySchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeEntitySchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entity = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fields.push(RuntimeEntitySchema_Field.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeEntitySchema {
    return {
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => RuntimeEntitySchema_Field.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RuntimeEntitySchema): unknown {
    const obj: any = {};
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => RuntimeEntitySchema_Field.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeEntitySchema>): RuntimeEntitySchema {
    return RuntimeEntitySchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeEntitySchema>): RuntimeEntitySchema {
    const message = createBaseRuntimeEntitySchema();
    message.entity = object.entity ?? "";
    message.fields = object.fields?.map((e) => RuntimeEntitySchema_Field.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRuntimeEntitySchema_Field(): RuntimeEntitySchema_Field {
  return {
    field: "",
    description: "",
    dataType: 0,
    key: false,
    readonly: false,
    nullable: false,
    defaultValue: undefined,
    additionalDetails: undefined,
  };
}

export const RuntimeEntitySchema_Field: MessageFns<RuntimeEntitySchema_Field> = {
  encode(message: RuntimeEntitySchema_Field, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.dataType !== 0) {
      writer.uint32(24).int32(message.dataType);
    }
    if (message.key !== false) {
      writer.uint32(32).bool(message.key);
    }
    if (message.readonly !== false) {
      writer.uint32(40).bool(message.readonly);
    }
    if (message.nullable !== false) {
      writer.uint32(48).bool(message.nullable);
    }
    if (message.defaultValue !== undefined) {
      Value.encode(Value.wrap(message.defaultValue), writer.uint32(58).fork()).join();
    }
    if (message.additionalDetails !== undefined) {
      Struct.encode(Struct.wrap(message.additionalDetails), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeEntitySchema_Field {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeEntitySchema_Field();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.key = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.readonly = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.defaultValue = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.additionalDetails = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeEntitySchema_Field {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
      key: isSet(object.key) ? globalThis.Boolean(object.key) : false,
      readonly: isSet(object.readonly) ? globalThis.Boolean(object.readonly) : false,
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      defaultValue: isSet(object?.defaultValue) ? object.defaultValue : undefined,
      additionalDetails: isObject(object.additionalDetails) ? object.additionalDetails : undefined,
    };
  },

  toJSON(message: RuntimeEntitySchema_Field): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.dataType !== 0) {
      obj.dataType = dataTypeToJSON(message.dataType);
    }
    if (message.key !== false) {
      obj.key = message.key;
    }
    if (message.readonly !== false) {
      obj.readonly = message.readonly;
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = message.defaultValue;
    }
    if (message.additionalDetails !== undefined) {
      obj.additionalDetails = message.additionalDetails;
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeEntitySchema_Field>): RuntimeEntitySchema_Field {
    return RuntimeEntitySchema_Field.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeEntitySchema_Field>): RuntimeEntitySchema_Field {
    const message = createBaseRuntimeEntitySchema_Field();
    message.field = object.field ?? "";
    message.description = object.description ?? "";
    message.dataType = object.dataType ?? 0;
    message.key = object.key ?? false;
    message.readonly = object.readonly ?? false;
    message.nullable = object.nullable ?? false;
    message.defaultValue = object.defaultValue ?? undefined;
    message.additionalDetails = object.additionalDetails ?? undefined;
    return message;
  },
};

function createBaseRuntimeActionSchema(): RuntimeActionSchema {
  return { action: "", inputParameters: [], resultMetadata: [] };
}

export const RuntimeActionSchema: MessageFns<RuntimeActionSchema> = {
  encode(message: RuntimeActionSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    for (const v of message.inputParameters) {
      RuntimeActionSchema_InputParameter.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.resultMetadata) {
      RuntimeActionSchema_ResultMetadata.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeActionSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeActionSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputParameters.push(RuntimeActionSchema_InputParameter.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resultMetadata.push(RuntimeActionSchema_ResultMetadata.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeActionSchema {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      inputParameters: globalThis.Array.isArray(object?.inputParameters)
        ? object.inputParameters.map((e: any) => RuntimeActionSchema_InputParameter.fromJSON(e))
        : [],
      resultMetadata: globalThis.Array.isArray(object?.resultMetadata)
        ? object.resultMetadata.map((e: any) => RuntimeActionSchema_ResultMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RuntimeActionSchema): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.inputParameters?.length) {
      obj.inputParameters = message.inputParameters.map((e) => RuntimeActionSchema_InputParameter.toJSON(e));
    }
    if (message.resultMetadata?.length) {
      obj.resultMetadata = message.resultMetadata.map((e) => RuntimeActionSchema_ResultMetadata.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeActionSchema>): RuntimeActionSchema {
    return RuntimeActionSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeActionSchema>): RuntimeActionSchema {
    const message = createBaseRuntimeActionSchema();
    message.action = object.action ?? "";
    message.inputParameters = object.inputParameters?.map((e) => RuntimeActionSchema_InputParameter.fromPartial(e)) ||
      [];
    message.resultMetadata = object.resultMetadata?.map((e) => RuntimeActionSchema_ResultMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRuntimeActionSchema_InputParameter(): RuntimeActionSchema_InputParameter {
  return { parameter: "", description: "", dataType: 0, nullable: false, defaultValue: undefined };
}

export const RuntimeActionSchema_InputParameter: MessageFns<RuntimeActionSchema_InputParameter> = {
  encode(message: RuntimeActionSchema_InputParameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parameter !== "") {
      writer.uint32(10).string(message.parameter);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.dataType !== 0) {
      writer.uint32(24).int32(message.dataType);
    }
    if (message.nullable !== false) {
      writer.uint32(32).bool(message.nullable);
    }
    if (message.defaultValue !== undefined) {
      Value.encode(Value.wrap(message.defaultValue), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeActionSchema_InputParameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeActionSchema_InputParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parameter = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.defaultValue = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeActionSchema_InputParameter {
    return {
      parameter: isSet(object.parameter) ? globalThis.String(object.parameter) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
      nullable: isSet(object.nullable) ? globalThis.Boolean(object.nullable) : false,
      defaultValue: isSet(object?.defaultValue) ? object.defaultValue : undefined,
    };
  },

  toJSON(message: RuntimeActionSchema_InputParameter): unknown {
    const obj: any = {};
    if (message.parameter !== "") {
      obj.parameter = message.parameter;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.dataType !== 0) {
      obj.dataType = dataTypeToJSON(message.dataType);
    }
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.defaultValue !== undefined) {
      obj.defaultValue = message.defaultValue;
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeActionSchema_InputParameter>): RuntimeActionSchema_InputParameter {
    return RuntimeActionSchema_InputParameter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeActionSchema_InputParameter>): RuntimeActionSchema_InputParameter {
    const message = createBaseRuntimeActionSchema_InputParameter();
    message.parameter = object.parameter ?? "";
    message.description = object.description ?? "";
    message.dataType = object.dataType ?? 0;
    message.nullable = object.nullable ?? false;
    message.defaultValue = object.defaultValue ?? undefined;
    return message;
  },
};

function createBaseRuntimeActionSchema_ResultMetadata(): RuntimeActionSchema_ResultMetadata {
  return { field: "", description: "", dataType: 0 };
}

export const RuntimeActionSchema_ResultMetadata: MessageFns<RuntimeActionSchema_ResultMetadata> = {
  encode(message: RuntimeActionSchema_ResultMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.dataType !== 0) {
      writer.uint32(24).int32(message.dataType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuntimeActionSchema_ResultMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuntimeActionSchema_ResultMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuntimeActionSchema_ResultMetadata {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      dataType: isSet(object.dataType) ? dataTypeFromJSON(object.dataType) : 0,
    };
  },

  toJSON(message: RuntimeActionSchema_ResultMetadata): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.dataType !== 0) {
      obj.dataType = dataTypeToJSON(message.dataType);
    }
    return obj;
  },

  create(base?: DeepPartial<RuntimeActionSchema_ResultMetadata>): RuntimeActionSchema_ResultMetadata {
    return RuntimeActionSchema_ResultMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuntimeActionSchema_ResultMetadata>): RuntimeActionSchema_ResultMetadata {
    const message = createBaseRuntimeActionSchema_ResultMetadata();
    message.field = object.field ?? "";
    message.description = object.description ?? "";
    message.dataType = object.dataType ?? 0;
    return message;
  },
};

function createBaseLockConfig(): LockConfig {
  return { locked: false, reason: "" };
}

export const LockConfig: MessageFns<LockConfig> = {
  encode(message: LockConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locked !== false) {
      writer.uint32(8).bool(message.locked);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LockConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLockConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.locked = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LockConfig {
    return {
      locked: isSet(object.locked) ? globalThis.Boolean(object.locked) : false,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: LockConfig): unknown {
    const obj: any = {};
    if (message.locked !== false) {
      obj.locked = message.locked;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },

  create(base?: DeepPartial<LockConfig>): LockConfig {
    return LockConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LockConfig>): LockConfig {
    const message = createBaseLockConfig();
    message.locked = object.locked ?? false;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseListConnectionsRequest(): ListConnectionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "", view: 0 };
}

export const ListConnectionsRequest: MessageFns<ListConnectionsRequest> = {
  encode(message: ListConnectionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    if (message.view !== 0) {
      writer.uint32(48).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      view: isSet(object.view) ? connectionViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListConnectionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.view !== 0) {
      obj.view = connectionViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListConnectionsRequest>): ListConnectionsRequest {
    return ListConnectionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConnectionsRequest>): ListConnectionsRequest {
    const message = createBaseListConnectionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListConnectionsResponse(): ListConnectionsResponse {
  return { connections: [], nextPageToken: "", unreachable: [] };
}

export const ListConnectionsResponse: MessageFns<ListConnectionsResponse> = {
  encode(message: ListConnectionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.connections) {
      Connection.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConnectionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConnectionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connections.push(Connection.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConnectionsResponse {
    return {
      connections: globalThis.Array.isArray(object?.connections)
        ? object.connections.map((e: any) => Connection.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListConnectionsResponse): unknown {
    const obj: any = {};
    if (message.connections?.length) {
      obj.connections = message.connections.map((e) => Connection.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListConnectionsResponse>): ListConnectionsResponse {
    return ListConnectionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListConnectionsResponse>): ListConnectionsResponse {
    const message = createBaseListConnectionsResponse();
    message.connections = object.connections?.map((e) => Connection.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetConnectionRequest(): GetConnectionRequest {
  return { name: "", view: 0 };
}

export const GetConnectionRequest: MessageFns<GetConnectionRequest> = {
  encode(message: GetConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? connectionViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = connectionViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetConnectionRequest>): GetConnectionRequest {
    return GetConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectionRequest>): GetConnectionRequest {
    const message = createBaseGetConnectionRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseCreateConnectionRequest(): CreateConnectionRequest {
  return { parent: "", connectionId: "", connection: undefined };
}

export const CreateConnectionRequest: MessageFns<CreateConnectionRequest> = {
  encode(message: CreateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.connectionId !== "") {
      writer.uint32(18).string(message.connectionId);
    }
    if (message.connection !== undefined) {
      Connection.encode(message.connection, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.connection = Connection.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConnectionRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      connection: isSet(object.connection) ? Connection.fromJSON(object.connection) : undefined,
    };
  },

  toJSON(message: CreateConnectionRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.connection !== undefined) {
      obj.connection = Connection.toJSON(message.connection);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateConnectionRequest>): CreateConnectionRequest {
    return CreateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateConnectionRequest>): CreateConnectionRequest {
    const message = createBaseCreateConnectionRequest();
    message.parent = object.parent ?? "";
    message.connectionId = object.connectionId ?? "";
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? Connection.fromPartial(object.connection)
      : undefined;
    return message;
  },
};

function createBaseUpdateConnectionRequest(): UpdateConnectionRequest {
  return { connection: undefined, updateMask: undefined };
}

export const UpdateConnectionRequest: MessageFns<UpdateConnectionRequest> = {
  encode(message: UpdateConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connection !== undefined) {
      Connection.encode(message.connection, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connection = Connection.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateConnectionRequest {
    return {
      connection: isSet(object.connection) ? Connection.fromJSON(object.connection) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateConnectionRequest): unknown {
    const obj: any = {};
    if (message.connection !== undefined) {
      obj.connection = Connection.toJSON(message.connection);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateConnectionRequest>): UpdateConnectionRequest {
    return UpdateConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateConnectionRequest>): UpdateConnectionRequest {
    const message = createBaseUpdateConnectionRequest();
    message.connection = (object.connection !== undefined && object.connection !== null)
      ? Connection.fromPartial(object.connection)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteConnectionRequest(): DeleteConnectionRequest {
  return { name: "" };
}

export const DeleteConnectionRequest: MessageFns<DeleteConnectionRequest> = {
  encode(message: DeleteConnectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConnectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConnectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConnectionRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteConnectionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteConnectionRequest>): DeleteConnectionRequest {
    return DeleteConnectionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteConnectionRequest>): DeleteConnectionRequest {
    const message = createBaseDeleteConnectionRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetConnectionSchemaMetadataRequest(): GetConnectionSchemaMetadataRequest {
  return { name: "" };
}

export const GetConnectionSchemaMetadataRequest: MessageFns<GetConnectionSchemaMetadataRequest> = {
  encode(message: GetConnectionSchemaMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConnectionSchemaMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConnectionSchemaMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConnectionSchemaMetadataRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetConnectionSchemaMetadataRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetConnectionSchemaMetadataRequest>): GetConnectionSchemaMetadataRequest {
    return GetConnectionSchemaMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetConnectionSchemaMetadataRequest>): GetConnectionSchemaMetadataRequest {
    const message = createBaseGetConnectionSchemaMetadataRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRefreshConnectionSchemaMetadataRequest(): RefreshConnectionSchemaMetadataRequest {
  return { name: "" };
}

export const RefreshConnectionSchemaMetadataRequest: MessageFns<RefreshConnectionSchemaMetadataRequest> = {
  encode(message: RefreshConnectionSchemaMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RefreshConnectionSchemaMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshConnectionSchemaMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefreshConnectionSchemaMetadataRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: RefreshConnectionSchemaMetadataRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<RefreshConnectionSchemaMetadataRequest>): RefreshConnectionSchemaMetadataRequest {
    return RefreshConnectionSchemaMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RefreshConnectionSchemaMetadataRequest>): RefreshConnectionSchemaMetadataRequest {
    const message = createBaseRefreshConnectionSchemaMetadataRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListRuntimeEntitySchemasRequest(): ListRuntimeEntitySchemasRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListRuntimeEntitySchemasRequest: MessageFns<ListRuntimeEntitySchemasRequest> = {
  encode(message: ListRuntimeEntitySchemasRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuntimeEntitySchemasRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuntimeEntitySchemasRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuntimeEntitySchemasRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListRuntimeEntitySchemasRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuntimeEntitySchemasRequest>): ListRuntimeEntitySchemasRequest {
    return ListRuntimeEntitySchemasRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuntimeEntitySchemasRequest>): ListRuntimeEntitySchemasRequest {
    const message = createBaseListRuntimeEntitySchemasRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListRuntimeEntitySchemasResponse(): ListRuntimeEntitySchemasResponse {
  return { runtimeEntitySchemas: [], nextPageToken: "" };
}

export const ListRuntimeEntitySchemasResponse: MessageFns<ListRuntimeEntitySchemasResponse> = {
  encode(message: ListRuntimeEntitySchemasResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runtimeEntitySchemas) {
      RuntimeEntitySchema.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuntimeEntitySchemasResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuntimeEntitySchemasResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.runtimeEntitySchemas.push(RuntimeEntitySchema.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuntimeEntitySchemasResponse {
    return {
      runtimeEntitySchemas: globalThis.Array.isArray(object?.runtimeEntitySchemas)
        ? object.runtimeEntitySchemas.map((e: any) => RuntimeEntitySchema.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRuntimeEntitySchemasResponse): unknown {
    const obj: any = {};
    if (message.runtimeEntitySchemas?.length) {
      obj.runtimeEntitySchemas = message.runtimeEntitySchemas.map((e) => RuntimeEntitySchema.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuntimeEntitySchemasResponse>): ListRuntimeEntitySchemasResponse {
    return ListRuntimeEntitySchemasResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuntimeEntitySchemasResponse>): ListRuntimeEntitySchemasResponse {
    const message = createBaseListRuntimeEntitySchemasResponse();
    message.runtimeEntitySchemas = object.runtimeEntitySchemas?.map((e) => RuntimeEntitySchema.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListRuntimeActionSchemasRequest(): ListRuntimeActionSchemasRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListRuntimeActionSchemasRequest: MessageFns<ListRuntimeActionSchemasRequest> = {
  encode(message: ListRuntimeActionSchemasRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuntimeActionSchemasRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuntimeActionSchemasRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuntimeActionSchemasRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListRuntimeActionSchemasRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuntimeActionSchemasRequest>): ListRuntimeActionSchemasRequest {
    return ListRuntimeActionSchemasRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuntimeActionSchemasRequest>): ListRuntimeActionSchemasRequest {
    const message = createBaseListRuntimeActionSchemasRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListRuntimeActionSchemasResponse(): ListRuntimeActionSchemasResponse {
  return { runtimeActionSchemas: [], nextPageToken: "" };
}

export const ListRuntimeActionSchemasResponse: MessageFns<ListRuntimeActionSchemasResponse> = {
  encode(message: ListRuntimeActionSchemasResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runtimeActionSchemas) {
      RuntimeActionSchema.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuntimeActionSchemasResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuntimeActionSchemasResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.runtimeActionSchemas.push(RuntimeActionSchema.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuntimeActionSchemasResponse {
    return {
      runtimeActionSchemas: globalThis.Array.isArray(object?.runtimeActionSchemas)
        ? object.runtimeActionSchemas.map((e: any) => RuntimeActionSchema.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRuntimeActionSchemasResponse): unknown {
    const obj: any = {};
    if (message.runtimeActionSchemas?.length) {
      obj.runtimeActionSchemas = message.runtimeActionSchemas.map((e) => RuntimeActionSchema.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuntimeActionSchemasResponse>): ListRuntimeActionSchemasResponse {
    return ListRuntimeActionSchemasResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuntimeActionSchemasResponse>): ListRuntimeActionSchemasResponse {
    const message = createBaseListRuntimeActionSchemasResponse();
    message.runtimeActionSchemas = object.runtimeActionSchemas?.map((e) => RuntimeActionSchema.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseConnectionStatus(): ConnectionStatus {
  return { state: 0, description: "", status: "" };
}

export const ConnectionStatus: MessageFns<ConnectionStatus> = {
  encode(message: ConnectionStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionStatus {
    return {
      state: isSet(object.state) ? connectionStatus_StateFromJSON(object.state) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: ConnectionStatus): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = connectionStatus_StateToJSON(message.state);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionStatus>): ConnectionStatus {
    return ConnectionStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionStatus>): ConnectionStatus {
    const message = createBaseConnectionStatus();
    message.state = object.state ?? 0;
    message.description = object.description ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
