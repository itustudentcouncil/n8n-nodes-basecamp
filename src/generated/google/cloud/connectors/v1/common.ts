// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/connectors/v1/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.connectors.v1";

/**
 * LaunchStage is a enum to indicate launch stage:
 * PREVIEW, GA, DEPRECATED, PRIVATE_PREVIEW.
 */
export enum LaunchStage {
  /** LAUNCH_STAGE_UNSPECIFIED - LAUNCH_STAGE_UNSPECIFIED. */
  LAUNCH_STAGE_UNSPECIFIED = 0,
  /** PREVIEW - PREVIEW. */
  PREVIEW = 1,
  /** GA - GA. */
  GA = 2,
  /** DEPRECATED - DEPRECATED. */
  DEPRECATED = 3,
  /** PRIVATE_PREVIEW - PRIVATE_PREVIEW. */
  PRIVATE_PREVIEW = 5,
  UNRECOGNIZED = -1,
}

export function launchStageFromJSON(object: any): LaunchStage {
  switch (object) {
    case 0:
    case "LAUNCH_STAGE_UNSPECIFIED":
      return LaunchStage.LAUNCH_STAGE_UNSPECIFIED;
    case 1:
    case "PREVIEW":
      return LaunchStage.PREVIEW;
    case 2:
    case "GA":
      return LaunchStage.GA;
    case 3:
    case "DEPRECATED":
      return LaunchStage.DEPRECATED;
    case 5:
    case "PRIVATE_PREVIEW":
      return LaunchStage.PRIVATE_PREVIEW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchStage.UNRECOGNIZED;
  }
}

export function launchStageToJSON(object: LaunchStage): string {
  switch (object) {
    case LaunchStage.LAUNCH_STAGE_UNSPECIFIED:
      return "LAUNCH_STAGE_UNSPECIFIED";
    case LaunchStage.PREVIEW:
      return "PREVIEW";
    case LaunchStage.GA:
      return "GA";
    case LaunchStage.DEPRECATED:
      return "DEPRECATED";
    case LaunchStage.PRIVATE_PREVIEW:
      return "PRIVATE_PREVIEW";
    case LaunchStage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have successfully been cancelled
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

/**
 * ConfigVariableTemplate provides metadata about a `ConfigVariable` that is
 * used in a Connection.
 */
export interface ConfigVariableTemplate {
  /** Key of the config variable. */
  key: string;
  /**
   * Type of the parameter: string, int, bool etc.
   * consider custom type for the benefit for the validation.
   */
  valueType: ConfigVariableTemplate_ValueType;
  /** Display name of the parameter. */
  displayName: string;
  /** Description. */
  description: string;
  /**
   * Regular expression in RE2 syntax used for validating the `value` of a
   * `ConfigVariable`.
   */
  validationRegex: string;
  /**
   * Flag represents that this `ConfigVariable` must be provided for a
   * connection.
   */
  required: boolean;
  /** Role grant configuration for the config variable. */
  roleGrant:
    | RoleGrant
    | undefined;
  /** Enum options. To be populated if `ValueType` is `ENUM` */
  enumOptions: EnumOption[];
  /**
   * Authorization code link options. To be populated if `ValueType` is
   * `AUTHORIZATION_CODE`
   */
  authorizationCodeLink:
    | AuthorizationCodeLink
    | undefined;
  /** State of the config variable. */
  state: ConfigVariableTemplate_State;
  /** Indicates if current template is part of advanced settings */
  isAdvanced: boolean;
}

/** ValueType indicates the data type of the value. */
export enum ConfigVariableTemplate_ValueType {
  /** VALUE_TYPE_UNSPECIFIED - Value type is not specified. */
  VALUE_TYPE_UNSPECIFIED = 0,
  /** STRING - Value type is string. */
  STRING = 1,
  /** INT - Value type is integer. */
  INT = 2,
  /** BOOL - Value type is boolean. */
  BOOL = 3,
  /** SECRET - Value type is secret. */
  SECRET = 4,
  /** ENUM - Value type is enum. */
  ENUM = 5,
  /** AUTHORIZATION_CODE - Value type is authorization code. */
  AUTHORIZATION_CODE = 6,
  UNRECOGNIZED = -1,
}

export function configVariableTemplate_ValueTypeFromJSON(object: any): ConfigVariableTemplate_ValueType {
  switch (object) {
    case 0:
    case "VALUE_TYPE_UNSPECIFIED":
      return ConfigVariableTemplate_ValueType.VALUE_TYPE_UNSPECIFIED;
    case 1:
    case "STRING":
      return ConfigVariableTemplate_ValueType.STRING;
    case 2:
    case "INT":
      return ConfigVariableTemplate_ValueType.INT;
    case 3:
    case "BOOL":
      return ConfigVariableTemplate_ValueType.BOOL;
    case 4:
    case "SECRET":
      return ConfigVariableTemplate_ValueType.SECRET;
    case 5:
    case "ENUM":
      return ConfigVariableTemplate_ValueType.ENUM;
    case 6:
    case "AUTHORIZATION_CODE":
      return ConfigVariableTemplate_ValueType.AUTHORIZATION_CODE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConfigVariableTemplate_ValueType.UNRECOGNIZED;
  }
}

export function configVariableTemplate_ValueTypeToJSON(object: ConfigVariableTemplate_ValueType): string {
  switch (object) {
    case ConfigVariableTemplate_ValueType.VALUE_TYPE_UNSPECIFIED:
      return "VALUE_TYPE_UNSPECIFIED";
    case ConfigVariableTemplate_ValueType.STRING:
      return "STRING";
    case ConfigVariableTemplate_ValueType.INT:
      return "INT";
    case ConfigVariableTemplate_ValueType.BOOL:
      return "BOOL";
    case ConfigVariableTemplate_ValueType.SECRET:
      return "SECRET";
    case ConfigVariableTemplate_ValueType.ENUM:
      return "ENUM";
    case ConfigVariableTemplate_ValueType.AUTHORIZATION_CODE:
      return "AUTHORIZATION_CODE";
    case ConfigVariableTemplate_ValueType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Indicates the state of the config variable. */
export enum ConfigVariableTemplate_State {
  /** STATE_UNSPECIFIED - Status is unspecified. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - Config variable is active */
  ACTIVE = 1,
  /** DEPRECATED - Config variable is deprecated. */
  DEPRECATED = 2,
  UNRECOGNIZED = -1,
}

export function configVariableTemplate_StateFromJSON(object: any): ConfigVariableTemplate_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ConfigVariableTemplate_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return ConfigVariableTemplate_State.ACTIVE;
    case 2:
    case "DEPRECATED":
      return ConfigVariableTemplate_State.DEPRECATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConfigVariableTemplate_State.UNRECOGNIZED;
  }
}

export function configVariableTemplate_StateToJSON(object: ConfigVariableTemplate_State): string {
  switch (object) {
    case ConfigVariableTemplate_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ConfigVariableTemplate_State.ACTIVE:
      return "ACTIVE";
    case ConfigVariableTemplate_State.DEPRECATED:
      return "DEPRECATED";
    case ConfigVariableTemplate_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Secret provides a reference to entries in Secret Manager. */
export interface Secret {
  /**
   * The resource name of the secret version in the format,
   * format as: `projects/* /secrets/* /versions/*`.
   */
  secretVersion: string;
}

/** EnumOption definition */
export interface EnumOption {
  /** Id of the option. */
  id: string;
  /** Display name of the option. */
  displayName: string;
}

/**
 * ConfigVariable represents a configuration variable present in a Connection.
 * or AuthConfig.
 */
export interface ConfigVariable {
  /** Key of the config variable. */
  key: string;
  /** Value is an integer */
  intValue?:
    | Long
    | undefined;
  /** Value is a bool. */
  boolValue?:
    | boolean
    | undefined;
  /** Value is a string. */
  stringValue?:
    | string
    | undefined;
  /** Value is a secret. */
  secretValue?: Secret | undefined;
}

/**
 * This configuration defines all the Cloud IAM roles that needs to be granted
 * to a particular GCP resource for the selected prinicpal like service
 * account. These configurations will let UI display to customers what
 * IAM roles need to be granted by them. Or these configurations can be used
 * by the UI to render a 'grant' button to do the same on behalf of the user.
 */
export interface RoleGrant {
  /** Prinicipal/Identity for whom the role need to assigned. */
  principal: RoleGrant_Principal;
  /** List of roles that need to be granted. */
  roles: string[];
  /** Resource on which the roles needs to be granted for the principal. */
  resource:
    | RoleGrant_Resource
    | undefined;
  /** Template that UI can use to provide helper text to customers. */
  helperTextTemplate: string;
}

/** Supported Principal values. */
export enum RoleGrant_Principal {
  /** PRINCIPAL_UNSPECIFIED - Value type is not specified. */
  PRINCIPAL_UNSPECIFIED = 0,
  /**
   * CONNECTOR_SA - Service Account used for Connector workload identity
   * This is either the default service account if unspecified or Service
   * Account provided by Customers through BYOSA.
   */
  CONNECTOR_SA = 1,
  UNRECOGNIZED = -1,
}

export function roleGrant_PrincipalFromJSON(object: any): RoleGrant_Principal {
  switch (object) {
    case 0:
    case "PRINCIPAL_UNSPECIFIED":
      return RoleGrant_Principal.PRINCIPAL_UNSPECIFIED;
    case 1:
    case "CONNECTOR_SA":
      return RoleGrant_Principal.CONNECTOR_SA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RoleGrant_Principal.UNRECOGNIZED;
  }
}

export function roleGrant_PrincipalToJSON(object: RoleGrant_Principal): string {
  switch (object) {
    case RoleGrant_Principal.PRINCIPAL_UNSPECIFIED:
      return "PRINCIPAL_UNSPECIFIED";
    case RoleGrant_Principal.CONNECTOR_SA:
      return "CONNECTOR_SA";
    case RoleGrant_Principal.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Resource definition */
export interface RoleGrant_Resource {
  /** Different types of resource supported. */
  type: RoleGrant_Resource_Type;
  /**
   * Template to uniquely represent a GCP resource in a format IAM expects
   * This is a template that can have references to other values provided in
   * the config variable template.
   */
  pathTemplate: string;
}

/** Resource Type definition. */
export enum RoleGrant_Resource_Type {
  /** TYPE_UNSPECIFIED - Value type is not specified. */
  TYPE_UNSPECIFIED = 0,
  /** GCP_PROJECT - GCP Project Resource. */
  GCP_PROJECT = 1,
  /** GCP_RESOURCE - Any GCP Resource which is identified uniquely by IAM. */
  GCP_RESOURCE = 2,
  /** GCP_SECRETMANAGER_SECRET - GCP Secret Resource. */
  GCP_SECRETMANAGER_SECRET = 3,
  /** GCP_SECRETMANAGER_SECRET_VERSION - GCP Secret Version Resource. */
  GCP_SECRETMANAGER_SECRET_VERSION = 4,
  UNRECOGNIZED = -1,
}

export function roleGrant_Resource_TypeFromJSON(object: any): RoleGrant_Resource_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return RoleGrant_Resource_Type.TYPE_UNSPECIFIED;
    case 1:
    case "GCP_PROJECT":
      return RoleGrant_Resource_Type.GCP_PROJECT;
    case 2:
    case "GCP_RESOURCE":
      return RoleGrant_Resource_Type.GCP_RESOURCE;
    case 3:
    case "GCP_SECRETMANAGER_SECRET":
      return RoleGrant_Resource_Type.GCP_SECRETMANAGER_SECRET;
    case 4:
    case "GCP_SECRETMANAGER_SECRET_VERSION":
      return RoleGrant_Resource_Type.GCP_SECRETMANAGER_SECRET_VERSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RoleGrant_Resource_Type.UNRECOGNIZED;
  }
}

export function roleGrant_Resource_TypeToJSON(object: RoleGrant_Resource_Type): string {
  switch (object) {
    case RoleGrant_Resource_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case RoleGrant_Resource_Type.GCP_PROJECT:
      return "GCP_PROJECT";
    case RoleGrant_Resource_Type.GCP_RESOURCE:
      return "GCP_RESOURCE";
    case RoleGrant_Resource_Type.GCP_SECRETMANAGER_SECRET:
      return "GCP_SECRETMANAGER_SECRET";
    case RoleGrant_Resource_Type.GCP_SECRETMANAGER_SECRET_VERSION:
      return "GCP_SECRETMANAGER_SECRET_VERSION";
    case RoleGrant_Resource_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * This configuration captures the details required to render an authorization
 * link for the OAuth Authorization Code Flow.
 */
export interface AuthorizationCodeLink {
  /**
   * The base URI the user must click to trigger the authorization code login
   * flow.
   */
  uri: string;
  /**
   * The scopes for which the user will authorize GCP Connectors on the
   * connector data source.
   */
  scopes: string[];
  /**
   * The client ID assigned to the GCP Connectors OAuth app for the connector
   * data source.
   */
  clientId: string;
  /** Whether to enable PKCE for the auth code flow. */
  enablePkce: boolean;
}

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseConfigVariableTemplate(): ConfigVariableTemplate {
  return {
    key: "",
    valueType: 0,
    displayName: "",
    description: "",
    validationRegex: "",
    required: false,
    roleGrant: undefined,
    enumOptions: [],
    authorizationCodeLink: undefined,
    state: 0,
    isAdvanced: false,
  };
}

export const ConfigVariableTemplate: MessageFns<ConfigVariableTemplate> = {
  encode(message: ConfigVariableTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.valueType !== 0) {
      writer.uint32(16).int32(message.valueType);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.validationRegex !== "") {
      writer.uint32(42).string(message.validationRegex);
    }
    if (message.required !== false) {
      writer.uint32(48).bool(message.required);
    }
    if (message.roleGrant !== undefined) {
      RoleGrant.encode(message.roleGrant, writer.uint32(58).fork()).join();
    }
    for (const v of message.enumOptions) {
      EnumOption.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.authorizationCodeLink !== undefined) {
      AuthorizationCodeLink.encode(message.authorizationCodeLink, writer.uint32(74).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (message.isAdvanced !== false) {
      writer.uint32(88).bool(message.isAdvanced);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigVariableTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigVariableTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.valueType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.validationRegex = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.required = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.roleGrant = RoleGrant.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.enumOptions.push(EnumOption.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.authorizationCodeLink = AuthorizationCodeLink.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.isAdvanced = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigVariableTemplate {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      valueType: isSet(object.valueType) ? configVariableTemplate_ValueTypeFromJSON(object.valueType) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      validationRegex: isSet(object.validationRegex) ? globalThis.String(object.validationRegex) : "",
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
      roleGrant: isSet(object.roleGrant) ? RoleGrant.fromJSON(object.roleGrant) : undefined,
      enumOptions: globalThis.Array.isArray(object?.enumOptions)
        ? object.enumOptions.map((e: any) => EnumOption.fromJSON(e))
        : [],
      authorizationCodeLink: isSet(object.authorizationCodeLink)
        ? AuthorizationCodeLink.fromJSON(object.authorizationCodeLink)
        : undefined,
      state: isSet(object.state) ? configVariableTemplate_StateFromJSON(object.state) : 0,
      isAdvanced: isSet(object.isAdvanced) ? globalThis.Boolean(object.isAdvanced) : false,
    };
  },

  toJSON(message: ConfigVariableTemplate): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.valueType !== 0) {
      obj.valueType = configVariableTemplate_ValueTypeToJSON(message.valueType);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.validationRegex !== "") {
      obj.validationRegex = message.validationRegex;
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    if (message.roleGrant !== undefined) {
      obj.roleGrant = RoleGrant.toJSON(message.roleGrant);
    }
    if (message.enumOptions?.length) {
      obj.enumOptions = message.enumOptions.map((e) => EnumOption.toJSON(e));
    }
    if (message.authorizationCodeLink !== undefined) {
      obj.authorizationCodeLink = AuthorizationCodeLink.toJSON(message.authorizationCodeLink);
    }
    if (message.state !== 0) {
      obj.state = configVariableTemplate_StateToJSON(message.state);
    }
    if (message.isAdvanced !== false) {
      obj.isAdvanced = message.isAdvanced;
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigVariableTemplate>): ConfigVariableTemplate {
    return ConfigVariableTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigVariableTemplate>): ConfigVariableTemplate {
    const message = createBaseConfigVariableTemplate();
    message.key = object.key ?? "";
    message.valueType = object.valueType ?? 0;
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.validationRegex = object.validationRegex ?? "";
    message.required = object.required ?? false;
    message.roleGrant = (object.roleGrant !== undefined && object.roleGrant !== null)
      ? RoleGrant.fromPartial(object.roleGrant)
      : undefined;
    message.enumOptions = object.enumOptions?.map((e) => EnumOption.fromPartial(e)) || [];
    message.authorizationCodeLink =
      (object.authorizationCodeLink !== undefined && object.authorizationCodeLink !== null)
        ? AuthorizationCodeLink.fromPartial(object.authorizationCodeLink)
        : undefined;
    message.state = object.state ?? 0;
    message.isAdvanced = object.isAdvanced ?? false;
    return message;
  },
};

function createBaseSecret(): Secret {
  return { secretVersion: "" };
}

export const Secret: MessageFns<Secret> = {
  encode(message: Secret, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.secretVersion !== "") {
      writer.uint32(10).string(message.secretVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Secret {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSecret();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.secretVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Secret {
    return { secretVersion: isSet(object.secretVersion) ? globalThis.String(object.secretVersion) : "" };
  },

  toJSON(message: Secret): unknown {
    const obj: any = {};
    if (message.secretVersion !== "") {
      obj.secretVersion = message.secretVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Secret>): Secret {
    return Secret.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Secret>): Secret {
    const message = createBaseSecret();
    message.secretVersion = object.secretVersion ?? "";
    return message;
  },
};

function createBaseEnumOption(): EnumOption {
  return { id: "", displayName: "" };
}

export const EnumOption: MessageFns<EnumOption> = {
  encode(message: EnumOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumOption {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: EnumOption): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<EnumOption>): EnumOption {
    return EnumOption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnumOption>): EnumOption {
    const message = createBaseEnumOption();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseConfigVariable(): ConfigVariable {
  return { key: "", intValue: undefined, boolValue: undefined, stringValue: undefined, secretValue: undefined };
}

export const ConfigVariable: MessageFns<ConfigVariable> = {
  encode(message: ConfigVariable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.intValue !== undefined) {
      writer.uint32(16).int64(message.intValue.toString());
    }
    if (message.boolValue !== undefined) {
      writer.uint32(24).bool(message.boolValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(34).string(message.stringValue);
    }
    if (message.secretValue !== undefined) {
      Secret.encode(message.secretValue, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigVariable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intValue = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.secretValue = Secret.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigVariable {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      intValue: isSet(object.intValue) ? Long.fromValue(object.intValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      secretValue: isSet(object.secretValue) ? Secret.fromJSON(object.secretValue) : undefined,
    };
  },

  toJSON(message: ConfigVariable): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.intValue !== undefined) {
      obj.intValue = (message.intValue || Long.ZERO).toString();
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.secretValue !== undefined) {
      obj.secretValue = Secret.toJSON(message.secretValue);
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigVariable>): ConfigVariable {
    return ConfigVariable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigVariable>): ConfigVariable {
    const message = createBaseConfigVariable();
    message.key = object.key ?? "";
    message.intValue = (object.intValue !== undefined && object.intValue !== null)
      ? Long.fromValue(object.intValue)
      : undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.secretValue = (object.secretValue !== undefined && object.secretValue !== null)
      ? Secret.fromPartial(object.secretValue)
      : undefined;
    return message;
  },
};

function createBaseRoleGrant(): RoleGrant {
  return { principal: 0, roles: [], resource: undefined, helperTextTemplate: "" };
}

export const RoleGrant: MessageFns<RoleGrant> = {
  encode(message: RoleGrant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.principal !== 0) {
      writer.uint32(8).int32(message.principal);
    }
    for (const v of message.roles) {
      writer.uint32(18).string(v!);
    }
    if (message.resource !== undefined) {
      RoleGrant_Resource.encode(message.resource, writer.uint32(26).fork()).join();
    }
    if (message.helperTextTemplate !== "") {
      writer.uint32(34).string(message.helperTextTemplate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoleGrant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleGrant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.principal = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.roles.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = RoleGrant_Resource.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.helperTextTemplate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoleGrant {
    return {
      principal: isSet(object.principal) ? roleGrant_PrincipalFromJSON(object.principal) : 0,
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => globalThis.String(e)) : [],
      resource: isSet(object.resource) ? RoleGrant_Resource.fromJSON(object.resource) : undefined,
      helperTextTemplate: isSet(object.helperTextTemplate) ? globalThis.String(object.helperTextTemplate) : "",
    };
  },

  toJSON(message: RoleGrant): unknown {
    const obj: any = {};
    if (message.principal !== 0) {
      obj.principal = roleGrant_PrincipalToJSON(message.principal);
    }
    if (message.roles?.length) {
      obj.roles = message.roles;
    }
    if (message.resource !== undefined) {
      obj.resource = RoleGrant_Resource.toJSON(message.resource);
    }
    if (message.helperTextTemplate !== "") {
      obj.helperTextTemplate = message.helperTextTemplate;
    }
    return obj;
  },

  create(base?: DeepPartial<RoleGrant>): RoleGrant {
    return RoleGrant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoleGrant>): RoleGrant {
    const message = createBaseRoleGrant();
    message.principal = object.principal ?? 0;
    message.roles = object.roles?.map((e) => e) || [];
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? RoleGrant_Resource.fromPartial(object.resource)
      : undefined;
    message.helperTextTemplate = object.helperTextTemplate ?? "";
    return message;
  },
};

function createBaseRoleGrant_Resource(): RoleGrant_Resource {
  return { type: 0, pathTemplate: "" };
}

export const RoleGrant_Resource: MessageFns<RoleGrant_Resource> = {
  encode(message: RoleGrant_Resource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.pathTemplate !== "") {
      writer.uint32(26).string(message.pathTemplate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoleGrant_Resource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleGrant_Resource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pathTemplate = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoleGrant_Resource {
    return {
      type: isSet(object.type) ? roleGrant_Resource_TypeFromJSON(object.type) : 0,
      pathTemplate: isSet(object.pathTemplate) ? globalThis.String(object.pathTemplate) : "",
    };
  },

  toJSON(message: RoleGrant_Resource): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = roleGrant_Resource_TypeToJSON(message.type);
    }
    if (message.pathTemplate !== "") {
      obj.pathTemplate = message.pathTemplate;
    }
    return obj;
  },

  create(base?: DeepPartial<RoleGrant_Resource>): RoleGrant_Resource {
    return RoleGrant_Resource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoleGrant_Resource>): RoleGrant_Resource {
    const message = createBaseRoleGrant_Resource();
    message.type = object.type ?? 0;
    message.pathTemplate = object.pathTemplate ?? "";
    return message;
  },
};

function createBaseAuthorizationCodeLink(): AuthorizationCodeLink {
  return { uri: "", scopes: [], clientId: "", enablePkce: false };
}

export const AuthorizationCodeLink: MessageFns<AuthorizationCodeLink> = {
  encode(message: AuthorizationCodeLink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    for (const v of message.scopes) {
      writer.uint32(18).string(v!);
    }
    if (message.clientId !== "") {
      writer.uint32(26).string(message.clientId);
    }
    if (message.enablePkce !== false) {
      writer.uint32(32).bool(message.enablePkce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationCodeLink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationCodeLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.clientId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enablePkce = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizationCodeLink {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : "",
      enablePkce: isSet(object.enablePkce) ? globalThis.Boolean(object.enablePkce) : false,
    };
  },

  toJSON(message: AuthorizationCodeLink): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    if (message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.enablePkce !== false) {
      obj.enablePkce = message.enablePkce;
    }
    return obj;
  },

  create(base?: DeepPartial<AuthorizationCodeLink>): AuthorizationCodeLink {
    return AuthorizationCodeLink.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthorizationCodeLink>): AuthorizationCodeLink {
    const message = createBaseAuthorizationCodeLink();
    message.uri = object.uri ?? "";
    message.scopes = object.scopes?.map((e) => e) || [];
    message.clientId = object.clientId ?? "";
    message.enablePkce = object.enablePkce ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
