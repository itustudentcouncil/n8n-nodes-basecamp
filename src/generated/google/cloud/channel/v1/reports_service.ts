// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/channel/v1/reports_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DateMessage } from "../../../type/date.js";
import { DateTime } from "../../../type/datetime.js";
import { Decimal } from "../../../type/decimal.js";
import { Money } from "../../../type/money.js";

export const protobufPackage = "google.cloud.channel.v1";

/**
 * Request message for
 * [CloudChannelReportsService.RunReportJob][google.cloud.channel.v1.CloudChannelReportsService.RunReportJob].
 *
 * @deprecated
 */
export interface RunReportJobRequest {
  /**
   * Required. The report's resource name. Specifies the account and report used
   * to generate report data. The report_id identifier is a UID (for example,
   * `613bf59q`).
   * Name uses the format:
   * accounts/{account_id}/reports/{report_id}
   */
  name: string;
  /** Optional. The range of usage or invoice dates to include in the result. */
  dateRange:
    | DateRange
    | undefined;
  /**
   * Optional. A structured string that defines conditions on dimension columns
   * to restrict the report output.
   *
   * Filters support logical operators (AND, OR, NOT) and conditional operators
   * (=, !=, <, >, <=, and >=) using `column_id` as keys.
   *
   * For example:
   * `(customer:"accounts/C123abc/customers/S456def" OR
   * customer:"accounts/C123abc/customers/S789ghi") AND
   * invoice_start_date.year >= 2022`
   */
  filter: string;
  /**
   * Optional. The BCP-47 language code, such as "en-US".  If specified, the
   * response is localized to the corresponding language code if the
   * original data sources support it.
   * Default is "en-US".
   */
  languageCode: string;
}

/**
 * Response message for
 * [CloudChannelReportsService.RunReportJob][google.cloud.channel.v1.CloudChannelReportsService.RunReportJob].
 *
 * @deprecated
 */
export interface RunReportJobResponse {
  /**
   * Pass `report_job.name` to
   * [FetchReportResultsRequest.report_job][google.cloud.channel.v1.FetchReportResultsRequest.report_job]
   * to retrieve the report's results.
   */
  reportJob:
    | ReportJob
    | undefined;
  /**
   * The metadata for the report's results (display name, columns, row count,
   * and date range). If you view this before the operation finishes,
   * you may see incomplete data.
   */
  reportMetadata: ReportResultsMetadata | undefined;
}

/**
 * Request message for
 * [CloudChannelReportsService.FetchReportResults][google.cloud.channel.v1.CloudChannelReportsService.FetchReportResults].
 *
 * @deprecated
 */
export interface FetchReportResultsRequest {
  /**
   * Required. The report job created by
   * [CloudChannelReportsService.RunReportJob][google.cloud.channel.v1.CloudChannelReportsService.RunReportJob].
   * Report_job uses the format:
   * accounts/{account_id}/reportJobs/{report_job_id}
   */
  reportJob: string;
  /**
   * Optional. Requested page size of the report. The server may return fewer
   * results than requested. If you don't specify a page size, the server uses a
   * sensible default (may change over time).
   *
   * The maximum value is 30,000; the server will change larger values to
   * 30,000.
   */
  pageSize: number;
  /**
   * Optional. A token that specifies a page of results beyond the first page.
   * Obtained through
   * [FetchReportResultsResponse.next_page_token][google.cloud.channel.v1.FetchReportResultsResponse.next_page_token]
   * of the previous
   * [CloudChannelReportsService.FetchReportResults][google.cloud.channel.v1.CloudChannelReportsService.FetchReportResults]
   * call.
   */
  pageToken: string;
  /**
   * Optional. List of keys specifying which report partitions to return.
   * If empty, returns all partitions.
   */
  partitionKeys: string[];
}

/**
 * Response message for
 * [CloudChannelReportsService.FetchReportResults][google.cloud.channel.v1.CloudChannelReportsService.FetchReportResults].
 * Contains a tabular representation of the report results.
 *
 * @deprecated
 */
export interface FetchReportResultsResponse {
  /**
   * The metadata for the report results (display name, columns, row count, and
   * date ranges).
   */
  reportMetadata:
    | ReportResultsMetadata
    | undefined;
  /**
   * The report's lists of values. Each row follows the settings and ordering
   * of the columns from `report_metadata`.
   */
  rows: Row[];
  /**
   * Pass this token to
   * [FetchReportResultsRequest.page_token][google.cloud.channel.v1.FetchReportResultsRequest.page_token]
   * to retrieve the next page of results.
   */
  nextPageToken: string;
}

/**
 * Request message for
 * [CloudChannelReportsService.ListReports][google.cloud.channel.v1.CloudChannelReportsService.ListReports].
 *
 * @deprecated
 */
export interface ListReportsRequest {
  /**
   * Required. The resource name of the partner account to list available
   * reports for. Parent uses the format: accounts/{account_id}
   */
  parent: string;
  /**
   * Optional. Requested page size of the report. The server might return fewer
   * results than requested. If unspecified, returns 20 reports. The maximum
   * value is 100.
   */
  pageSize: number;
  /**
   * Optional. A token that specifies a page of results beyond the first page.
   * Obtained through
   * [ListReportsResponse.next_page_token][google.cloud.channel.v1.ListReportsResponse.next_page_token]
   * of the previous
   * [CloudChannelReportsService.ListReports][google.cloud.channel.v1.CloudChannelReportsService.ListReports]
   * call.
   */
  pageToken: string;
  /**
   * Optional. The BCP-47 language code, such as "en-US".  If specified, the
   * response is localized to the corresponding language code if the
   * original data sources support it.
   * Default is "en-US".
   */
  languageCode: string;
}

/**
 * Response message for
 * [CloudChannelReportsService.ListReports][google.cloud.channel.v1.CloudChannelReportsService.ListReports].
 *
 * @deprecated
 */
export interface ListReportsResponse {
  /** The reports available to the partner. */
  reports: Report[];
  /**
   * Pass this token to
   * [FetchReportResultsRequest.page_token][google.cloud.channel.v1.FetchReportResultsRequest.page_token]
   * to retrieve the next page of results.
   */
  nextPageToken: string;
}

/**
 * The result of a [RunReportJob][] operation. Contains the name to use in
 * [FetchReportResultsRequest.report_job][google.cloud.channel.v1.FetchReportResultsRequest.report_job]
 * and the status of the operation.
 *
 * @deprecated
 */
export interface ReportJob {
  /**
   * Required. The resource name of a report job.
   * Name uses the format:
   * `accounts/{account_id}/reportJobs/{report_job_id}`
   */
  name: string;
  /** The current status of report generation. */
  reportStatus: ReportStatus | undefined;
}

/**
 * The features describing the data. Returned by
 * [CloudChannelReportsService.RunReportJob][google.cloud.channel.v1.CloudChannelReportsService.RunReportJob]
 * and
 * [CloudChannelReportsService.FetchReportResults][google.cloud.channel.v1.CloudChannelReportsService.FetchReportResults].
 *
 * @deprecated
 */
export interface ReportResultsMetadata {
  /** Details of the completed report. */
  report:
    | Report
    | undefined;
  /** The total number of rows of data in the final report. */
  rowCount: Long;
  /** The date range of reported usage. */
  dateRange:
    | DateRange
    | undefined;
  /**
   * The usage dates immediately preceding `date_range` with the same duration.
   * Use this to calculate trending usage and costs. This is only populated if
   * you request trending data.
   *
   * For example, if `date_range` is July 1-15, `preceding_date_range` will be
   * June 16-30.
   */
  precedingDateRange: DateRange | undefined;
}

/**
 * The definition of a report column. Specifies the data properties
 * in the corresponding position of the report rows.
 *
 * @deprecated
 */
export interface Column {
  /**
   * The unique name of the column (for example, customer_domain,
   * channel_partner, customer_cost). You can use column IDs in
   * [RunReportJobRequest.filter][google.cloud.channel.v1.RunReportJobRequest.filter].
   * To see all reports and their columns, call
   * [CloudChannelReportsService.ListReports][google.cloud.channel.v1.CloudChannelReportsService.ListReports].
   */
  columnId: string;
  /** The column's display name. */
  displayName: string;
  /** The type of the values for this column. */
  dataType: Column_DataType;
}

/**
 * Available data types for columns. Corresponds to the fields in the
 * ReportValue `oneof` field.
 */
export enum Column_DataType {
  /** DATA_TYPE_UNSPECIFIED - Not used. */
  DATA_TYPE_UNSPECIFIED = 0,
  /** STRING - ReportValues for this column will use string_value. */
  STRING = 1,
  /** INT - ReportValues for this column will use int_value. */
  INT = 2,
  /** DECIMAL - ReportValues for this column will use decimal_value. */
  DECIMAL = 3,
  /** MONEY - ReportValues for this column will use money_value. */
  MONEY = 4,
  /** DATE - ReportValues for this column will use date_value. */
  DATE = 5,
  /** DATE_TIME - ReportValues for this column will use date_time_value. */
  DATE_TIME = 6,
  UNRECOGNIZED = -1,
}

export function column_DataTypeFromJSON(object: any): Column_DataType {
  switch (object) {
    case 0:
    case "DATA_TYPE_UNSPECIFIED":
      return Column_DataType.DATA_TYPE_UNSPECIFIED;
    case 1:
    case "STRING":
      return Column_DataType.STRING;
    case 2:
    case "INT":
      return Column_DataType.INT;
    case 3:
    case "DECIMAL":
      return Column_DataType.DECIMAL;
    case 4:
    case "MONEY":
      return Column_DataType.MONEY;
    case 5:
    case "DATE":
      return Column_DataType.DATE;
    case 6:
    case "DATE_TIME":
      return Column_DataType.DATE_TIME;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Column_DataType.UNRECOGNIZED;
  }
}

export function column_DataTypeToJSON(object: Column_DataType): string {
  switch (object) {
    case Column_DataType.DATA_TYPE_UNSPECIFIED:
      return "DATA_TYPE_UNSPECIFIED";
    case Column_DataType.STRING:
      return "STRING";
    case Column_DataType.INT:
      return "INT";
    case Column_DataType.DECIMAL:
      return "DECIMAL";
    case Column_DataType.MONEY:
      return "MONEY";
    case Column_DataType.DATE:
      return "DATE";
    case Column_DataType.DATE_TIME:
      return "DATE_TIME";
    case Column_DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A representation of usage or invoice date ranges.
 *
 * @deprecated
 */
export interface DateRange {
  /**
   * The earliest usage date time (inclusive).
   *
   * If you use time groupings (daily, weekly, etc), each group uses
   * midnight to midnight (Pacific time). The usage start date is
   * rounded down to include all usage from the specified date. We recommend
   * that clients pass `usage_start_date_time` in Pacific time.
   */
  usageStartDateTime:
    | DateTime
    | undefined;
  /**
   * The latest usage date time (exclusive).
   *
   * If you use time groupings (daily, weekly, etc), each group uses
   * midnight to midnight (Pacific time). The usage end date is
   * rounded down to include all usage from the specified date. We recommend
   * that clients pass `usage_start_date_time` in Pacific time.
   */
  usageEndDateTime:
    | DateTime
    | undefined;
  /**
   * The earliest invoice date (inclusive).
   *
   * If this value is not the first day of a month, this will move it back to
   * the first day of the given month.
   */
  invoiceStartDate:
    | DateMessage
    | undefined;
  /**
   * The latest invoice date (inclusive).
   *
   * If this value is not the last day of a month, this will move it forward to
   * the last day of the given month.
   */
  invoiceEndDate: DateMessage | undefined;
}

/**
 * A row of report values.
 *
 * @deprecated
 */
export interface Row {
  /** The list of values in the row. */
  values: ReportValue[];
  /**
   * The key for the partition this row belongs to. This field is empty
   * if the report is not partitioned.
   */
  partitionKey: string;
}

/**
 * A single report value.
 *
 * @deprecated
 */
export interface ReportValue {
  /** A value of type `string`. */
  stringValue?:
    | string
    | undefined;
  /** A value of type `int`. */
  intValue?:
    | Long
    | undefined;
  /**
   * A value of type `google.type.Decimal`, representing non-integer numeric
   * values.
   */
  decimalValue?:
    | Decimal
    | undefined;
  /**
   * A value of type `google.type.Money` (currency code, whole units, decimal
   * units).
   */
  moneyValue?:
    | Money
    | undefined;
  /** A value of type `google.type.Date` (year, month, day). */
  dateValue?:
    | DateMessage
    | undefined;
  /**
   * A value of type `google.type.DateTime` (year, month, day, hour, minute,
   * second, and UTC offset or timezone.)
   */
  dateTimeValue?: DateTime | undefined;
}

/**
 * Status of a report generation process.
 *
 * @deprecated
 */
export interface ReportStatus {
  /** The current state of the report generation process. */
  state: ReportStatus_State;
  /** The report generation's start time. */
  startTime:
    | Date
    | undefined;
  /** The report generation's completion time. */
  endTime: Date | undefined;
}

/** Available states of report generation. */
export enum ReportStatus_State {
  /** STATE_UNSPECIFIED - Not used. */
  STATE_UNSPECIFIED = 0,
  /** STARTED - Report processing started. */
  STARTED = 1,
  /** WRITING - Data generated from the report is being staged. */
  WRITING = 2,
  /** AVAILABLE - Report data is available for access. */
  AVAILABLE = 3,
  /** FAILED - Report failed. */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function reportStatus_StateFromJSON(object: any): ReportStatus_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ReportStatus_State.STATE_UNSPECIFIED;
    case 1:
    case "STARTED":
      return ReportStatus_State.STARTED;
    case 2:
    case "WRITING":
      return ReportStatus_State.WRITING;
    case 3:
    case "AVAILABLE":
      return ReportStatus_State.AVAILABLE;
    case 4:
    case "FAILED":
      return ReportStatus_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ReportStatus_State.UNRECOGNIZED;
  }
}

export function reportStatus_StateToJSON(object: ReportStatus_State): string {
  switch (object) {
    case ReportStatus_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ReportStatus_State.STARTED:
      return "STARTED";
    case ReportStatus_State.WRITING:
      return "WRITING";
    case ReportStatus_State.AVAILABLE:
      return "AVAILABLE";
    case ReportStatus_State.FAILED:
      return "FAILED";
    case ReportStatus_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The ID and description of a report that was used to generate report data.
 * For example, "Google Cloud Daily Spend", "Google Workspace License Activity",
 * etc.
 *
 * @deprecated
 */
export interface Report {
  /**
   * Required. The report's resource name. Specifies the account and report used
   * to generate report data. The report_id identifier is a UID (for example,
   * `613bf59q`).
   *
   * Name uses the format:
   * accounts/{account_id}/reports/{report_id}
   */
  name: string;
  /** A human-readable name for this report. */
  displayName: string;
  /**
   * The list of columns included in the report. This defines the schema of
   * the report results.
   */
  columns: Column[];
  /**
   * A description of other aspects of the report, such as the products
   * it supports.
   */
  description: string;
}

function createBaseRunReportJobRequest(): RunReportJobRequest {
  return { name: "", dateRange: undefined, filter: "", languageCode: "" };
}

export const RunReportJobRequest: MessageFns<RunReportJobRequest> = {
  encode(message: RunReportJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.dateRange !== undefined) {
      DateRange.encode(message.dateRange, writer.uint32(18).fork()).join();
    }
    if (message.filter !== "") {
      writer.uint32(26).string(message.filter);
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunReportJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunReportJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dateRange = DateRange.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunReportJobRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dateRange: isSet(object.dateRange) ? DateRange.fromJSON(object.dateRange) : undefined,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: RunReportJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dateRange !== undefined) {
      obj.dateRange = DateRange.toJSON(message.dateRange);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<RunReportJobRequest>): RunReportJobRequest {
    return RunReportJobRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunReportJobRequest>): RunReportJobRequest {
    const message = createBaseRunReportJobRequest();
    message.name = object.name ?? "";
    message.dateRange = (object.dateRange !== undefined && object.dateRange !== null)
      ? DateRange.fromPartial(object.dateRange)
      : undefined;
    message.filter = object.filter ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseRunReportJobResponse(): RunReportJobResponse {
  return { reportJob: undefined, reportMetadata: undefined };
}

export const RunReportJobResponse: MessageFns<RunReportJobResponse> = {
  encode(message: RunReportJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reportJob !== undefined) {
      ReportJob.encode(message.reportJob, writer.uint32(10).fork()).join();
    }
    if (message.reportMetadata !== undefined) {
      ReportResultsMetadata.encode(message.reportMetadata, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunReportJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunReportJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reportJob = ReportJob.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reportMetadata = ReportResultsMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunReportJobResponse {
    return {
      reportJob: isSet(object.reportJob) ? ReportJob.fromJSON(object.reportJob) : undefined,
      reportMetadata: isSet(object.reportMetadata) ? ReportResultsMetadata.fromJSON(object.reportMetadata) : undefined,
    };
  },

  toJSON(message: RunReportJobResponse): unknown {
    const obj: any = {};
    if (message.reportJob !== undefined) {
      obj.reportJob = ReportJob.toJSON(message.reportJob);
    }
    if (message.reportMetadata !== undefined) {
      obj.reportMetadata = ReportResultsMetadata.toJSON(message.reportMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<RunReportJobResponse>): RunReportJobResponse {
    return RunReportJobResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunReportJobResponse>): RunReportJobResponse {
    const message = createBaseRunReportJobResponse();
    message.reportJob = (object.reportJob !== undefined && object.reportJob !== null)
      ? ReportJob.fromPartial(object.reportJob)
      : undefined;
    message.reportMetadata = (object.reportMetadata !== undefined && object.reportMetadata !== null)
      ? ReportResultsMetadata.fromPartial(object.reportMetadata)
      : undefined;
    return message;
  },
};

function createBaseFetchReportResultsRequest(): FetchReportResultsRequest {
  return { reportJob: "", pageSize: 0, pageToken: "", partitionKeys: [] };
}

export const FetchReportResultsRequest: MessageFns<FetchReportResultsRequest> = {
  encode(message: FetchReportResultsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reportJob !== "") {
      writer.uint32(10).string(message.reportJob);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    for (const v of message.partitionKeys) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchReportResultsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchReportResultsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reportJob = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.partitionKeys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchReportResultsRequest {
    return {
      reportJob: isSet(object.reportJob) ? globalThis.String(object.reportJob) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      partitionKeys: globalThis.Array.isArray(object?.partitionKeys)
        ? object.partitionKeys.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FetchReportResultsRequest): unknown {
    const obj: any = {};
    if (message.reportJob !== "") {
      obj.reportJob = message.reportJob;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.partitionKeys?.length) {
      obj.partitionKeys = message.partitionKeys;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchReportResultsRequest>): FetchReportResultsRequest {
    return FetchReportResultsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchReportResultsRequest>): FetchReportResultsRequest {
    const message = createBaseFetchReportResultsRequest();
    message.reportJob = object.reportJob ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.partitionKeys = object.partitionKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseFetchReportResultsResponse(): FetchReportResultsResponse {
  return { reportMetadata: undefined, rows: [], nextPageToken: "" };
}

export const FetchReportResultsResponse: MessageFns<FetchReportResultsResponse> = {
  encode(message: FetchReportResultsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reportMetadata !== undefined) {
      ReportResultsMetadata.encode(message.reportMetadata, writer.uint32(10).fork()).join();
    }
    for (const v of message.rows) {
      Row.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchReportResultsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchReportResultsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reportMetadata = ReportResultsMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rows.push(Row.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchReportResultsResponse {
    return {
      reportMetadata: isSet(object.reportMetadata) ? ReportResultsMetadata.fromJSON(object.reportMetadata) : undefined,
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => Row.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: FetchReportResultsResponse): unknown {
    const obj: any = {};
    if (message.reportMetadata !== undefined) {
      obj.reportMetadata = ReportResultsMetadata.toJSON(message.reportMetadata);
    }
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => Row.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchReportResultsResponse>): FetchReportResultsResponse {
    return FetchReportResultsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchReportResultsResponse>): FetchReportResultsResponse {
    const message = createBaseFetchReportResultsResponse();
    message.reportMetadata = (object.reportMetadata !== undefined && object.reportMetadata !== null)
      ? ReportResultsMetadata.fromPartial(object.reportMetadata)
      : undefined;
    message.rows = object.rows?.map((e) => Row.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListReportsRequest(): ListReportsRequest {
  return { parent: "", pageSize: 0, pageToken: "", languageCode: "" };
}

export const ListReportsRequest: MessageFns<ListReportsRequest> = {
  encode(message: ListReportsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.languageCode !== "") {
      writer.uint32(34).string(message.languageCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReportsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReportsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.languageCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReportsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
    };
  },

  toJSON(message: ListReportsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReportsRequest>): ListReportsRequest {
    return ListReportsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReportsRequest>): ListReportsRequest {
    const message = createBaseListReportsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.languageCode = object.languageCode ?? "";
    return message;
  },
};

function createBaseListReportsResponse(): ListReportsResponse {
  return { reports: [], nextPageToken: "" };
}

export const ListReportsResponse: MessageFns<ListReportsResponse> = {
  encode(message: ListReportsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reports) {
      Report.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReportsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReportsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reports.push(Report.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReportsResponse {
    return {
      reports: globalThis.Array.isArray(object?.reports) ? object.reports.map((e: any) => Report.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListReportsResponse): unknown {
    const obj: any = {};
    if (message.reports?.length) {
      obj.reports = message.reports.map((e) => Report.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReportsResponse>): ListReportsResponse {
    return ListReportsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReportsResponse>): ListReportsResponse {
    const message = createBaseListReportsResponse();
    message.reports = object.reports?.map((e) => Report.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseReportJob(): ReportJob {
  return { name: "", reportStatus: undefined };
}

export const ReportJob: MessageFns<ReportJob> = {
  encode(message: ReportJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.reportStatus !== undefined) {
      ReportStatus.encode(message.reportStatus, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reportStatus = ReportStatus.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportJob {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      reportStatus: isSet(object.reportStatus) ? ReportStatus.fromJSON(object.reportStatus) : undefined,
    };
  },

  toJSON(message: ReportJob): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.reportStatus !== undefined) {
      obj.reportStatus = ReportStatus.toJSON(message.reportStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<ReportJob>): ReportJob {
    return ReportJob.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportJob>): ReportJob {
    const message = createBaseReportJob();
    message.name = object.name ?? "";
    message.reportStatus = (object.reportStatus !== undefined && object.reportStatus !== null)
      ? ReportStatus.fromPartial(object.reportStatus)
      : undefined;
    return message;
  },
};

function createBaseReportResultsMetadata(): ReportResultsMetadata {
  return { report: undefined, rowCount: Long.ZERO, dateRange: undefined, precedingDateRange: undefined };
}

export const ReportResultsMetadata: MessageFns<ReportResultsMetadata> = {
  encode(message: ReportResultsMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.report !== undefined) {
      Report.encode(message.report, writer.uint32(10).fork()).join();
    }
    if (!message.rowCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.rowCount.toString());
    }
    if (message.dateRange !== undefined) {
      DateRange.encode(message.dateRange, writer.uint32(26).fork()).join();
    }
    if (message.precedingDateRange !== undefined) {
      DateRange.encode(message.precedingDateRange, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportResultsMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportResultsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.report = Report.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.rowCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dateRange = DateRange.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.precedingDateRange = DateRange.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportResultsMetadata {
    return {
      report: isSet(object.report) ? Report.fromJSON(object.report) : undefined,
      rowCount: isSet(object.rowCount) ? Long.fromValue(object.rowCount) : Long.ZERO,
      dateRange: isSet(object.dateRange) ? DateRange.fromJSON(object.dateRange) : undefined,
      precedingDateRange: isSet(object.precedingDateRange) ? DateRange.fromJSON(object.precedingDateRange) : undefined,
    };
  },

  toJSON(message: ReportResultsMetadata): unknown {
    const obj: any = {};
    if (message.report !== undefined) {
      obj.report = Report.toJSON(message.report);
    }
    if (!message.rowCount.equals(Long.ZERO)) {
      obj.rowCount = (message.rowCount || Long.ZERO).toString();
    }
    if (message.dateRange !== undefined) {
      obj.dateRange = DateRange.toJSON(message.dateRange);
    }
    if (message.precedingDateRange !== undefined) {
      obj.precedingDateRange = DateRange.toJSON(message.precedingDateRange);
    }
    return obj;
  },

  create(base?: DeepPartial<ReportResultsMetadata>): ReportResultsMetadata {
    return ReportResultsMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportResultsMetadata>): ReportResultsMetadata {
    const message = createBaseReportResultsMetadata();
    message.report = (object.report !== undefined && object.report !== null)
      ? Report.fromPartial(object.report)
      : undefined;
    message.rowCount = (object.rowCount !== undefined && object.rowCount !== null)
      ? Long.fromValue(object.rowCount)
      : Long.ZERO;
    message.dateRange = (object.dateRange !== undefined && object.dateRange !== null)
      ? DateRange.fromPartial(object.dateRange)
      : undefined;
    message.precedingDateRange = (object.precedingDateRange !== undefined && object.precedingDateRange !== null)
      ? DateRange.fromPartial(object.precedingDateRange)
      : undefined;
    return message;
  },
};

function createBaseColumn(): Column {
  return { columnId: "", displayName: "", dataType: 0 };
}

export const Column: MessageFns<Column> = {
  encode(message: Column, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.columnId !== "") {
      writer.uint32(10).string(message.columnId);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.dataType !== 0) {
      writer.uint32(24).int32(message.dataType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Column {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columnId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Column {
    return {
      columnId: isSet(object.columnId) ? globalThis.String(object.columnId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      dataType: isSet(object.dataType) ? column_DataTypeFromJSON(object.dataType) : 0,
    };
  },

  toJSON(message: Column): unknown {
    const obj: any = {};
    if (message.columnId !== "") {
      obj.columnId = message.columnId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.dataType !== 0) {
      obj.dataType = column_DataTypeToJSON(message.dataType);
    }
    return obj;
  },

  create(base?: DeepPartial<Column>): Column {
    return Column.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Column>): Column {
    const message = createBaseColumn();
    message.columnId = object.columnId ?? "";
    message.displayName = object.displayName ?? "";
    message.dataType = object.dataType ?? 0;
    return message;
  },
};

function createBaseDateRange(): DateRange {
  return {
    usageStartDateTime: undefined,
    usageEndDateTime: undefined,
    invoiceStartDate: undefined,
    invoiceEndDate: undefined,
  };
}

export const DateRange: MessageFns<DateRange> = {
  encode(message: DateRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.usageStartDateTime !== undefined) {
      DateTime.encode(message.usageStartDateTime, writer.uint32(10).fork()).join();
    }
    if (message.usageEndDateTime !== undefined) {
      DateTime.encode(message.usageEndDateTime, writer.uint32(18).fork()).join();
    }
    if (message.invoiceStartDate !== undefined) {
      DateMessage.encode(message.invoiceStartDate, writer.uint32(26).fork()).join();
    }
    if (message.invoiceEndDate !== undefined) {
      DateMessage.encode(message.invoiceEndDate, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DateRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.usageStartDateTime = DateTime.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.usageEndDateTime = DateTime.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.invoiceStartDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.invoiceEndDate = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateRange {
    return {
      usageStartDateTime: isSet(object.usageStartDateTime) ? DateTime.fromJSON(object.usageStartDateTime) : undefined,
      usageEndDateTime: isSet(object.usageEndDateTime) ? DateTime.fromJSON(object.usageEndDateTime) : undefined,
      invoiceStartDate: isSet(object.invoiceStartDate) ? DateMessage.fromJSON(object.invoiceStartDate) : undefined,
      invoiceEndDate: isSet(object.invoiceEndDate) ? DateMessage.fromJSON(object.invoiceEndDate) : undefined,
    };
  },

  toJSON(message: DateRange): unknown {
    const obj: any = {};
    if (message.usageStartDateTime !== undefined) {
      obj.usageStartDateTime = DateTime.toJSON(message.usageStartDateTime);
    }
    if (message.usageEndDateTime !== undefined) {
      obj.usageEndDateTime = DateTime.toJSON(message.usageEndDateTime);
    }
    if (message.invoiceStartDate !== undefined) {
      obj.invoiceStartDate = DateMessage.toJSON(message.invoiceStartDate);
    }
    if (message.invoiceEndDate !== undefined) {
      obj.invoiceEndDate = DateMessage.toJSON(message.invoiceEndDate);
    }
    return obj;
  },

  create(base?: DeepPartial<DateRange>): DateRange {
    return DateRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateRange>): DateRange {
    const message = createBaseDateRange();
    message.usageStartDateTime = (object.usageStartDateTime !== undefined && object.usageStartDateTime !== null)
      ? DateTime.fromPartial(object.usageStartDateTime)
      : undefined;
    message.usageEndDateTime = (object.usageEndDateTime !== undefined && object.usageEndDateTime !== null)
      ? DateTime.fromPartial(object.usageEndDateTime)
      : undefined;
    message.invoiceStartDate = (object.invoiceStartDate !== undefined && object.invoiceStartDate !== null)
      ? DateMessage.fromPartial(object.invoiceStartDate)
      : undefined;
    message.invoiceEndDate = (object.invoiceEndDate !== undefined && object.invoiceEndDate !== null)
      ? DateMessage.fromPartial(object.invoiceEndDate)
      : undefined;
    return message;
  },
};

function createBaseRow(): Row {
  return { values: [], partitionKey: "" };
}

export const Row: MessageFns<Row> = {
  encode(message: Row, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      ReportValue.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.partitionKey !== "") {
      writer.uint32(18).string(message.partitionKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Row {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(ReportValue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partitionKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Row {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => ReportValue.fromJSON(e)) : [],
      partitionKey: isSet(object.partitionKey) ? globalThis.String(object.partitionKey) : "",
    };
  },

  toJSON(message: Row): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => ReportValue.toJSON(e));
    }
    if (message.partitionKey !== "") {
      obj.partitionKey = message.partitionKey;
    }
    return obj;
  },

  create(base?: DeepPartial<Row>): Row {
    return Row.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Row>): Row {
    const message = createBaseRow();
    message.values = object.values?.map((e) => ReportValue.fromPartial(e)) || [];
    message.partitionKey = object.partitionKey ?? "";
    return message;
  },
};

function createBaseReportValue(): ReportValue {
  return {
    stringValue: undefined,
    intValue: undefined,
    decimalValue: undefined,
    moneyValue: undefined,
    dateValue: undefined,
    dateTimeValue: undefined,
  };
}

export const ReportValue: MessageFns<ReportValue> = {
  encode(message: ReportValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stringValue !== undefined) {
      writer.uint32(10).string(message.stringValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(16).int64(message.intValue.toString());
    }
    if (message.decimalValue !== undefined) {
      Decimal.encode(message.decimalValue, writer.uint32(26).fork()).join();
    }
    if (message.moneyValue !== undefined) {
      Money.encode(message.moneyValue, writer.uint32(34).fork()).join();
    }
    if (message.dateValue !== undefined) {
      DateMessage.encode(message.dateValue, writer.uint32(42).fork()).join();
    }
    if (message.dateTimeValue !== undefined) {
      DateTime.encode(message.dateTimeValue, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intValue = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.decimalValue = Decimal.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.moneyValue = Money.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dateValue = DateMessage.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dateTimeValue = DateTime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportValue {
    return {
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      intValue: isSet(object.intValue) ? Long.fromValue(object.intValue) : undefined,
      decimalValue: isSet(object.decimalValue) ? Decimal.fromJSON(object.decimalValue) : undefined,
      moneyValue: isSet(object.moneyValue) ? Money.fromJSON(object.moneyValue) : undefined,
      dateValue: isSet(object.dateValue) ? DateMessage.fromJSON(object.dateValue) : undefined,
      dateTimeValue: isSet(object.dateTimeValue) ? DateTime.fromJSON(object.dateTimeValue) : undefined,
    };
  },

  toJSON(message: ReportValue): unknown {
    const obj: any = {};
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = (message.intValue || Long.ZERO).toString();
    }
    if (message.decimalValue !== undefined) {
      obj.decimalValue = Decimal.toJSON(message.decimalValue);
    }
    if (message.moneyValue !== undefined) {
      obj.moneyValue = Money.toJSON(message.moneyValue);
    }
    if (message.dateValue !== undefined) {
      obj.dateValue = DateMessage.toJSON(message.dateValue);
    }
    if (message.dateTimeValue !== undefined) {
      obj.dateTimeValue = DateTime.toJSON(message.dateTimeValue);
    }
    return obj;
  },

  create(base?: DeepPartial<ReportValue>): ReportValue {
    return ReportValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportValue>): ReportValue {
    const message = createBaseReportValue();
    message.stringValue = object.stringValue ?? undefined;
    message.intValue = (object.intValue !== undefined && object.intValue !== null)
      ? Long.fromValue(object.intValue)
      : undefined;
    message.decimalValue = (object.decimalValue !== undefined && object.decimalValue !== null)
      ? Decimal.fromPartial(object.decimalValue)
      : undefined;
    message.moneyValue = (object.moneyValue !== undefined && object.moneyValue !== null)
      ? Money.fromPartial(object.moneyValue)
      : undefined;
    message.dateValue = (object.dateValue !== undefined && object.dateValue !== null)
      ? DateMessage.fromPartial(object.dateValue)
      : undefined;
    message.dateTimeValue = (object.dateTimeValue !== undefined && object.dateTimeValue !== null)
      ? DateTime.fromPartial(object.dateTimeValue)
      : undefined;
    return message;
  },
};

function createBaseReportStatus(): ReportStatus {
  return { state: 0, startTime: undefined, endTime: undefined };
}

export const ReportStatus: MessageFns<ReportStatus> = {
  encode(message: ReportStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReportStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReportStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReportStatus {
    return {
      state: isSet(object.state) ? reportStatus_StateFromJSON(object.state) : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: ReportStatus): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = reportStatus_StateToJSON(message.state);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ReportStatus>): ReportStatus {
    return ReportStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReportStatus>): ReportStatus {
    const message = createBaseReportStatus();
    message.state = object.state ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseReport(): Report {
  return { name: "", displayName: "", columns: [], description: "" };
}

export const Report: MessageFns<Report> = {
  encode(message: Report, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.columns) {
      Column.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Report {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.columns.push(Column.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Report {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => Column.fromJSON(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Report): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.columns?.length) {
      obj.columns = message.columns.map((e) => Column.toJSON(e));
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<Report>): Report {
    return Report.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Report>): Report {
    const message = createBaseReport();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.columns = object.columns?.map((e) => Column.fromPartial(e)) || [];
    message.description = object.description ?? "";
    return message;
  },
};

/**
 * CloudChannelReportsService lets Google Cloud resellers and
 * distributors retrieve and combine a variety of data in Cloud Channel for
 * multiple products (Google Cloud, Google Voice, and Google Workspace.)
 *
 * Deprecated: This service is being deprecated. Please use [Export Channel
 * Services data to
 * BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
 * instead.
 *
 * @deprecated
 */
export type CloudChannelReportsServiceDefinition = typeof CloudChannelReportsServiceDefinition;
export const CloudChannelReportsServiceDefinition = {
  name: "CloudChannelReportsService",
  fullName: "google.cloud.channel.v1.CloudChannelReportsService",
  methods: {
    /**
     * Begins generation of data for a given report. The report
     * identifier is a UID (for example, `613bf59q`).
     *
     * Possible error codes:
     *
     * * PERMISSION_DENIED: The user doesn't have access to this report.
     * * INVALID_ARGUMENT: Required request parameters are missing
     *   or invalid.
     * * NOT_FOUND: The report identifier was not found.
     * * INTERNAL: Any non-user error related to a technical issue
     *   in the backend. Contact Cloud Channel support.
     * * UNKNOWN: Any non-user error related to a technical issue
     *   in the backend. Contact Cloud Channel support.
     *
     * Return value:
     * The ID of a long-running operation.
     *
     * To get the results of the operation, call the GetOperation method of
     * CloudChannelOperationsService. The Operation metadata contains an
     * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
     *
     * To get the results of report generation, call
     * [CloudChannelReportsService.FetchReportResults][google.cloud.channel.v1.CloudChannelReportsService.FetchReportResults]
     * with the
     * [RunReportJobResponse.report_job][google.cloud.channel.v1.RunReportJobResponse.report_job].
     *
     * Deprecated: Please use [Export Channel Services data to
     * BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
     * instead.
     *
     * @deprecated
     */
    runReportJob: {
      name: "RunReportJob",
      requestType: RunReportJobRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              41,
              10,
              20,
              82,
              117,
              110,
              82,
              101,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              40,
              58,
              1,
              42,
              34,
              35,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              115,
              47,
              42,
              125,
              58,
              114,
              117,
              110,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves data generated by
     * [CloudChannelReportsService.RunReportJob][google.cloud.channel.v1.CloudChannelReportsService.RunReportJob].
     *
     * Deprecated: Please use [Export Channel Services data to
     * BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
     * instead.
     *
     * @deprecated
     */
    fetchReportResults: {
      name: "FetchReportResults",
      requestType: FetchReportResultsRequest,
      requestStream: false,
      responseType: FetchReportResultsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 114, 101, 112, 111, 114, 116, 95, 106, 111, 98])],
          578365826: [
            Buffer.from([
              64,
              58,
              1,
              42,
              34,
              59,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              112,
              111,
              114,
              116,
              95,
              106,
              111,
              98,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              74,
              111,
              98,
              115,
              47,
              42,
              125,
              58,
              102,
              101,
              116,
              99,
              104,
              82,
              101,
              112,
              111,
              114,
              116,
              82,
              101,
              115,
              117,
              108,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the reports that RunReportJob can run. These reports include an ID,
     * a description, and the list of columns that will be in the result.
     *
     * Deprecated: Please use [Export Channel Services data to
     * BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
     * instead.
     *
     * @deprecated
     */
    listReports: {
      name: "ListReports",
      requestType: ListReportsRequest,
      requestStream: false,
      responseType: ListReportsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              33,
              18,
              31,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              112,
              111,
              114,
              116,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CloudChannelReportsServiceImplementation<CallContextExt = {}> {
  /**
   * Begins generation of data for a given report. The report
   * identifier is a UID (for example, `613bf59q`).
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The user doesn't have access to this report.
   * * INVALID_ARGUMENT: Required request parameters are missing
   *   or invalid.
   * * NOT_FOUND: The report identifier was not found.
   * * INTERNAL: Any non-user error related to a technical issue
   *   in the backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue
   *   in the backend. Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata contains an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   *
   * To get the results of report generation, call
   * [CloudChannelReportsService.FetchReportResults][google.cloud.channel.v1.CloudChannelReportsService.FetchReportResults]
   * with the
   * [RunReportJobResponse.report_job][google.cloud.channel.v1.RunReportJobResponse.report_job].
   *
   * Deprecated: Please use [Export Channel Services data to
   * BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
   * instead.
   *
   * @deprecated
   */
  runReportJob(request: RunReportJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /**
   * Retrieves data generated by
   * [CloudChannelReportsService.RunReportJob][google.cloud.channel.v1.CloudChannelReportsService.RunReportJob].
   *
   * Deprecated: Please use [Export Channel Services data to
   * BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
   * instead.
   *
   * @deprecated
   */
  fetchReportResults(
    request: FetchReportResultsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<FetchReportResultsResponse>>;
  /**
   * Lists the reports that RunReportJob can run. These reports include an ID,
   * a description, and the list of columns that will be in the result.
   *
   * Deprecated: Please use [Export Channel Services data to
   * BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
   * instead.
   *
   * @deprecated
   */
  listReports(
    request: ListReportsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReportsResponse>>;
}

export interface CloudChannelReportsServiceClient<CallOptionsExt = {}> {
  /**
   * Begins generation of data for a given report. The report
   * identifier is a UID (for example, `613bf59q`).
   *
   * Possible error codes:
   *
   * * PERMISSION_DENIED: The user doesn't have access to this report.
   * * INVALID_ARGUMENT: Required request parameters are missing
   *   or invalid.
   * * NOT_FOUND: The report identifier was not found.
   * * INTERNAL: Any non-user error related to a technical issue
   *   in the backend. Contact Cloud Channel support.
   * * UNKNOWN: Any non-user error related to a technical issue
   *   in the backend. Contact Cloud Channel support.
   *
   * Return value:
   * The ID of a long-running operation.
   *
   * To get the results of the operation, call the GetOperation method of
   * CloudChannelOperationsService. The Operation metadata contains an
   * instance of [OperationMetadata][google.cloud.channel.v1.OperationMetadata].
   *
   * To get the results of report generation, call
   * [CloudChannelReportsService.FetchReportResults][google.cloud.channel.v1.CloudChannelReportsService.FetchReportResults]
   * with the
   * [RunReportJobResponse.report_job][google.cloud.channel.v1.RunReportJobResponse.report_job].
   *
   * Deprecated: Please use [Export Channel Services data to
   * BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
   * instead.
   *
   * @deprecated
   */
  runReportJob(request: DeepPartial<RunReportJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /**
   * Retrieves data generated by
   * [CloudChannelReportsService.RunReportJob][google.cloud.channel.v1.CloudChannelReportsService.RunReportJob].
   *
   * Deprecated: Please use [Export Channel Services data to
   * BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
   * instead.
   *
   * @deprecated
   */
  fetchReportResults(
    request: DeepPartial<FetchReportResultsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<FetchReportResultsResponse>;
  /**
   * Lists the reports that RunReportJob can run. These reports include an ID,
   * a description, and the list of columns that will be in the result.
   *
   * Deprecated: Please use [Export Channel Services data to
   * BigQuery](https://cloud.google.com/channel/docs/rebilling/export-data-to-bigquery)
   * instead.
   *
   * @deprecated
   */
  listReports(
    request: DeepPartial<ListReportsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReportsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
