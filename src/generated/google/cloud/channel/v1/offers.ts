// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/channel/v1/offers.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Money } from "../../../type/money.js";
import {
  CloudIdentityInfo_CustomerType,
  cloudIdentityInfo_CustomerTypeFromJSON,
  cloudIdentityInfo_CustomerTypeToJSON,
  Value,
} from "./common.js";
import { MarketingInfo, Sku } from "./products.js";

export const protobufPackage = "google.cloud.channel.v1";

/** Constraints type for Promotional offers. */
export enum PromotionalOrderType {
  /** PROMOTIONAL_TYPE_UNSPECIFIED - Not used. */
  PROMOTIONAL_TYPE_UNSPECIFIED = 0,
  /** NEW_UPGRADE - Order used for new customers, trial conversions and upgrades. */
  NEW_UPGRADE = 1,
  /** TRANSFER - All orders for transferring an existing customer. */
  TRANSFER = 2,
  /** PROMOTION_SWITCH - Orders for modifying an existing customer's promotion on the same SKU. */
  PROMOTION_SWITCH = 3,
  UNRECOGNIZED = -1,
}

export function promotionalOrderTypeFromJSON(object: any): PromotionalOrderType {
  switch (object) {
    case 0:
    case "PROMOTIONAL_TYPE_UNSPECIFIED":
      return PromotionalOrderType.PROMOTIONAL_TYPE_UNSPECIFIED;
    case 1:
    case "NEW_UPGRADE":
      return PromotionalOrderType.NEW_UPGRADE;
    case 2:
    case "TRANSFER":
      return PromotionalOrderType.TRANSFER;
    case 3:
    case "PROMOTION_SWITCH":
      return PromotionalOrderType.PROMOTION_SWITCH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PromotionalOrderType.UNRECOGNIZED;
  }
}

export function promotionalOrderTypeToJSON(object: PromotionalOrderType): string {
  switch (object) {
    case PromotionalOrderType.PROMOTIONAL_TYPE_UNSPECIFIED:
      return "PROMOTIONAL_TYPE_UNSPECIFIED";
    case PromotionalOrderType.NEW_UPGRADE:
      return "NEW_UPGRADE";
    case PromotionalOrderType.TRANSFER:
      return "TRANSFER";
    case PromotionalOrderType.PROMOTION_SWITCH:
      return "PROMOTION_SWITCH";
    case PromotionalOrderType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes how the reseller will be billed. */
export enum PaymentPlan {
  /** PAYMENT_PLAN_UNSPECIFIED - Not used. */
  PAYMENT_PLAN_UNSPECIFIED = 0,
  /** COMMITMENT - Commitment. */
  COMMITMENT = 1,
  /** FLEXIBLE - No commitment. */
  FLEXIBLE = 2,
  /** FREE - Free. */
  FREE = 3,
  /** TRIAL - Trial. */
  TRIAL = 4,
  /** OFFLINE - Price and ordering not available through API. */
  OFFLINE = 5,
  UNRECOGNIZED = -1,
}

export function paymentPlanFromJSON(object: any): PaymentPlan {
  switch (object) {
    case 0:
    case "PAYMENT_PLAN_UNSPECIFIED":
      return PaymentPlan.PAYMENT_PLAN_UNSPECIFIED;
    case 1:
    case "COMMITMENT":
      return PaymentPlan.COMMITMENT;
    case 2:
    case "FLEXIBLE":
      return PaymentPlan.FLEXIBLE;
    case 3:
    case "FREE":
      return PaymentPlan.FREE;
    case 4:
    case "TRIAL":
      return PaymentPlan.TRIAL;
    case 5:
    case "OFFLINE":
      return PaymentPlan.OFFLINE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentPlan.UNRECOGNIZED;
  }
}

export function paymentPlanToJSON(object: PaymentPlan): string {
  switch (object) {
    case PaymentPlan.PAYMENT_PLAN_UNSPECIFIED:
      return "PAYMENT_PLAN_UNSPECIFIED";
    case PaymentPlan.COMMITMENT:
      return "COMMITMENT";
    case PaymentPlan.FLEXIBLE:
      return "FLEXIBLE";
    case PaymentPlan.FREE:
      return "FREE";
    case PaymentPlan.TRIAL:
      return "TRIAL";
    case PaymentPlan.OFFLINE:
      return "OFFLINE";
    case PaymentPlan.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies when the payment needs to happen. */
export enum PaymentType {
  /** PAYMENT_TYPE_UNSPECIFIED - Not used. */
  PAYMENT_TYPE_UNSPECIFIED = 0,
  /** PREPAY - Prepay. Amount has to be paid before service is rendered. */
  PREPAY = 1,
  /** POSTPAY - Postpay. Reseller is charged at the end of the Payment cycle. */
  POSTPAY = 2,
  UNRECOGNIZED = -1,
}

export function paymentTypeFromJSON(object: any): PaymentType {
  switch (object) {
    case 0:
    case "PAYMENT_TYPE_UNSPECIFIED":
      return PaymentType.PAYMENT_TYPE_UNSPECIFIED;
    case 1:
    case "PREPAY":
      return PaymentType.PREPAY;
    case 2:
    case "POSTPAY":
      return PaymentType.POSTPAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PaymentType.UNRECOGNIZED;
  }
}

export function paymentTypeToJSON(object: PaymentType): string {
  switch (object) {
    case PaymentType.PAYMENT_TYPE_UNSPECIFIED:
      return "PAYMENT_TYPE_UNSPECIFIED";
    case PaymentType.PREPAY:
      return "PREPAY";
    case PaymentType.POSTPAY:
      return "POSTPAY";
    case PaymentType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents the type for a monetizable resource(any entity on which billing
 * happens). For example, this could be MINUTES for Google Voice and GB for
 * Google Drive. One SKU can map to multiple monetizable resources.
 */
export enum ResourceType {
  /** RESOURCE_TYPE_UNSPECIFIED - Not used. */
  RESOURCE_TYPE_UNSPECIFIED = 0,
  /** SEAT - Seat. */
  SEAT = 1,
  /** MAU - Monthly active user. */
  MAU = 2,
  /** GB - GB (used for storage SKUs). */
  GB = 3,
  /** LICENSED_USER - Active licensed users(for Voice SKUs). */
  LICENSED_USER = 4,
  /** MINUTES - Voice usage. */
  MINUTES = 5,
  /**
   * IAAS_USAGE - For IaaS SKUs like Google Cloud, monetization is based on usage accrued on
   * your billing account irrespective of the type of monetizable resource. This
   * enum represents an aggregated resource/container for all usage SKUs on a
   * billing account. Currently, only applicable to Google Cloud.
   */
  IAAS_USAGE = 6,
  /** SUBSCRIPTION - For Google Cloud subscriptions like Anthos or SAP. */
  SUBSCRIPTION = 7,
  UNRECOGNIZED = -1,
}

export function resourceTypeFromJSON(object: any): ResourceType {
  switch (object) {
    case 0:
    case "RESOURCE_TYPE_UNSPECIFIED":
      return ResourceType.RESOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "SEAT":
      return ResourceType.SEAT;
    case 2:
    case "MAU":
      return ResourceType.MAU;
    case 3:
    case "GB":
      return ResourceType.GB;
    case 4:
    case "LICENSED_USER":
      return ResourceType.LICENSED_USER;
    case 5:
    case "MINUTES":
      return ResourceType.MINUTES;
    case 6:
    case "IAAS_USAGE":
      return ResourceType.IAAS_USAGE;
    case 7:
    case "SUBSCRIPTION":
      return ResourceType.SUBSCRIPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResourceType.UNRECOGNIZED;
  }
}

export function resourceTypeToJSON(object: ResourceType): string {
  switch (object) {
    case ResourceType.RESOURCE_TYPE_UNSPECIFIED:
      return "RESOURCE_TYPE_UNSPECIFIED";
    case ResourceType.SEAT:
      return "SEAT";
    case ResourceType.MAU:
      return "MAU";
    case ResourceType.GB:
      return "GB";
    case ResourceType.LICENSED_USER:
      return "LICENSED_USER";
    case ResourceType.MINUTES:
      return "MINUTES";
    case ResourceType.IAAS_USAGE:
      return "IAAS_USAGE";
    case ResourceType.SUBSCRIPTION:
      return "SUBSCRIPTION";
    case ResourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Period Type. */
export enum PeriodType {
  /** PERIOD_TYPE_UNSPECIFIED - Not used. */
  PERIOD_TYPE_UNSPECIFIED = 0,
  /** DAY - Day. */
  DAY = 1,
  /** MONTH - Month. */
  MONTH = 2,
  /** YEAR - Year. */
  YEAR = 3,
  UNRECOGNIZED = -1,
}

export function periodTypeFromJSON(object: any): PeriodType {
  switch (object) {
    case 0:
    case "PERIOD_TYPE_UNSPECIFIED":
      return PeriodType.PERIOD_TYPE_UNSPECIFIED;
    case 1:
    case "DAY":
      return PeriodType.DAY;
    case 2:
    case "MONTH":
      return PeriodType.MONTH;
    case 3:
    case "YEAR":
      return PeriodType.YEAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PeriodType.UNRECOGNIZED;
  }
}

export function periodTypeToJSON(object: PeriodType): string {
  switch (object) {
    case PeriodType.PERIOD_TYPE_UNSPECIFIED:
      return "PERIOD_TYPE_UNSPECIFIED";
    case PeriodType.DAY:
      return "DAY";
    case PeriodType.MONTH:
      return "MONTH";
    case PeriodType.YEAR:
      return "YEAR";
    case PeriodType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents an offer made to resellers for purchase.
 * An offer is associated with a [Sku][google.cloud.channel.v1.Sku], has a plan
 * for payment, a price, and defines the constraints for buying.
 */
export interface Offer {
  /**
   * Resource Name of the Offer.
   * Format: accounts/{account_id}/offers/{offer_id}
   */
  name: string;
  /** Marketing information for the Offer. */
  marketingInfo:
    | MarketingInfo
    | undefined;
  /** SKU the offer is associated with. */
  sku:
    | Sku
    | undefined;
  /** Describes the payment plan for the Offer. */
  plan:
    | Plan
    | undefined;
  /** Constraints on transacting the Offer. */
  constraints:
    | Constraints
    | undefined;
  /** Price for each monetizable resource type. */
  priceByResources: PriceByResource[];
  /** Start of the Offer validity time. */
  startTime:
    | Date
    | undefined;
  /** Output only. End of the Offer validity time. */
  endTime:
    | Date
    | undefined;
  /** Parameters required to use current Offer to purchase. */
  parameterDefinitions: ParameterDefinition[];
  /** The deal code of the offer to get a special promotion or discount. */
  dealCode: string;
}

/**
 * Parameter's definition. Specifies what parameter is required to use the
 * current Offer to purchase.
 */
export interface ParameterDefinition {
  /** Name of the parameter. */
  name: string;
  /**
   * Data type of the parameter. Minimal value, Maximum value and allowed values
   * will use specified data type here.
   */
  parameterType: ParameterDefinition_ParameterType;
  /**
   * Minimal value of the parameter, if applicable. Inclusive. For example,
   * minimal commitment when purchasing Anthos is 0.01.
   * Applicable to INT64 and DOUBLE parameter types.
   */
  minValue:
    | Value
    | undefined;
  /**
   * Maximum value of the parameter, if applicable. Inclusive. For example,
   * maximum seats when purchasing Google Workspace Business Standard.
   * Applicable to INT64 and DOUBLE parameter types.
   */
  maxValue:
    | Value
    | undefined;
  /**
   * If not empty, parameter values must be drawn from this list.
   * For example, [us-west1, us-west2, ...]
   * Applicable to STRING parameter type.
   */
  allowedValues: Value[];
  /** If set to true, parameter is optional to purchase this Offer. */
  optional: boolean;
}

/** Data type of the parameter. */
export enum ParameterDefinition_ParameterType {
  /** PARAMETER_TYPE_UNSPECIFIED - Not used. */
  PARAMETER_TYPE_UNSPECIFIED = 0,
  /** INT64 - Int64 type. */
  INT64 = 1,
  /** STRING - String type. */
  STRING = 2,
  /** DOUBLE - Double type. */
  DOUBLE = 3,
  /** BOOLEAN - Boolean type. */
  BOOLEAN = 4,
  UNRECOGNIZED = -1,
}

export function parameterDefinition_ParameterTypeFromJSON(object: any): ParameterDefinition_ParameterType {
  switch (object) {
    case 0:
    case "PARAMETER_TYPE_UNSPECIFIED":
      return ParameterDefinition_ParameterType.PARAMETER_TYPE_UNSPECIFIED;
    case 1:
    case "INT64":
      return ParameterDefinition_ParameterType.INT64;
    case 2:
    case "STRING":
      return ParameterDefinition_ParameterType.STRING;
    case 3:
    case "DOUBLE":
      return ParameterDefinition_ParameterType.DOUBLE;
    case 4:
    case "BOOLEAN":
      return ParameterDefinition_ParameterType.BOOLEAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ParameterDefinition_ParameterType.UNRECOGNIZED;
  }
}

export function parameterDefinition_ParameterTypeToJSON(object: ParameterDefinition_ParameterType): string {
  switch (object) {
    case ParameterDefinition_ParameterType.PARAMETER_TYPE_UNSPECIFIED:
      return "PARAMETER_TYPE_UNSPECIFIED";
    case ParameterDefinition_ParameterType.INT64:
      return "INT64";
    case ParameterDefinition_ParameterType.STRING:
      return "STRING";
    case ParameterDefinition_ParameterType.DOUBLE:
      return "DOUBLE";
    case ParameterDefinition_ParameterType.BOOLEAN:
      return "BOOLEAN";
    case ParameterDefinition_ParameterType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents the constraints for buying the Offer. */
export interface Constraints {
  /** Represents constraints required to purchase the Offer for a customer. */
  customerConstraints: CustomerConstraints | undefined;
}

/** Represents constraints required to purchase the Offer for a customer. */
export interface CustomerConstraints {
  /** Allowed geographical regions of the customer. */
  allowedRegions: string[];
  /** Allowed Customer Type. */
  allowedCustomerTypes: CloudIdentityInfo_CustomerType[];
  /** Allowed Promotional Order Type. Present for Promotional offers. */
  promotionalOrderTypes: PromotionalOrderType[];
}

/** The payment plan for the Offer. Describes how to make a payment. */
export interface Plan {
  /** Describes how a reseller will be billed. */
  paymentPlan: PaymentPlan;
  /** Specifies when the payment needs to happen. */
  paymentType: PaymentType;
  /**
   * Describes how frequently the reseller will be billed, such as
   * once per month.
   */
  paymentCycle:
    | Period
    | undefined;
  /**
   * Present for Offers with a trial period.
   * For trial-only Offers, a paid service needs to start before the trial
   * period ends for continued service.
   * For Regular Offers with a trial period, the regular pricing goes into
   * effect when trial period ends, or if paid service is started before the end
   * of the trial period.
   */
  trialPeriod:
    | Period
    | undefined;
  /**
   * Reseller Billing account to charge after an offer transaction.
   * Only present for Google Cloud offers.
   */
  billingAccount: string;
}

/** Represents price by resource type. */
export interface PriceByResource {
  /** Resource Type. Example: SEAT */
  resourceType: ResourceType;
  /** Price of the Offer. Present if there are no price phases. */
  price:
    | Price
    | undefined;
  /** Specifies the price by time range. */
  pricePhases: PricePhase[];
}

/** Represents the price of the Offer. */
export interface Price {
  /** Base price. */
  basePrice:
    | Money
    | undefined;
  /**
   * Discount percentage, represented as decimal.
   * For example, a 20% discount will be represent as 0.2.
   */
  discount: number;
  /** Effective Price after applying the discounts. */
  effectivePrice:
    | Money
    | undefined;
  /** Link to external price list, such as link to Google Voice rate card. */
  externalPriceUri: string;
}

/**
 * Specifies the price by the duration of months.
 * For example, a 20% discount for the first six months, then a 10% discount
 * starting on the seventh month.
 */
export interface PricePhase {
  /** Defines the phase period type. */
  periodType: PeriodType;
  /** Defines first period for the phase. */
  firstPeriod: number;
  /** Defines first period for the phase. */
  lastPeriod: number;
  /** Price of the phase. Present if there are no price tiers. */
  price:
    | Price
    | undefined;
  /** Price by the resource tiers. */
  priceTiers: PriceTier[];
}

/**
 * Defines price at resource tier level.
 * For example, an offer with following definition :
 *
 * * Tier 1: Provide 25% discount for all seats between 1 and 25.
 * * Tier 2: Provide 10% discount for all seats between 26 and 100.
 * * Tier 3: Provide flat 15% discount for all seats above 100.
 *
 * Each of these tiers is represented as a PriceTier.
 */
export interface PriceTier {
  /** First resource for which the tier price applies. */
  firstResource: number;
  /** Last resource for which the tier price applies. */
  lastResource: number;
  /** Price of the tier. */
  price: Price | undefined;
}

/** Represents period in days/months/years. */
export interface Period {
  /** Total duration of Period Type defined. */
  duration: number;
  /** Period Type. */
  periodType: PeriodType;
}

function createBaseOffer(): Offer {
  return {
    name: "",
    marketingInfo: undefined,
    sku: undefined,
    plan: undefined,
    constraints: undefined,
    priceByResources: [],
    startTime: undefined,
    endTime: undefined,
    parameterDefinitions: [],
    dealCode: "",
  };
}

export const Offer: MessageFns<Offer> = {
  encode(message: Offer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.marketingInfo !== undefined) {
      MarketingInfo.encode(message.marketingInfo, writer.uint32(18).fork()).join();
    }
    if (message.sku !== undefined) {
      Sku.encode(message.sku, writer.uint32(26).fork()).join();
    }
    if (message.plan !== undefined) {
      Plan.encode(message.plan, writer.uint32(34).fork()).join();
    }
    if (message.constraints !== undefined) {
      Constraints.encode(message.constraints, writer.uint32(42).fork()).join();
    }
    for (const v of message.priceByResources) {
      PriceByResource.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(58).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(66).fork()).join();
    }
    for (const v of message.parameterDefinitions) {
      ParameterDefinition.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.dealCode !== "") {
      writer.uint32(98).string(message.dealCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Offer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOffer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.marketingInfo = MarketingInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sku = Sku.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.plan = Plan.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.constraints = Constraints.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.priceByResources.push(PriceByResource.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.parameterDefinitions.push(ParameterDefinition.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.dealCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Offer {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      marketingInfo: isSet(object.marketingInfo) ? MarketingInfo.fromJSON(object.marketingInfo) : undefined,
      sku: isSet(object.sku) ? Sku.fromJSON(object.sku) : undefined,
      plan: isSet(object.plan) ? Plan.fromJSON(object.plan) : undefined,
      constraints: isSet(object.constraints) ? Constraints.fromJSON(object.constraints) : undefined,
      priceByResources: globalThis.Array.isArray(object?.priceByResources)
        ? object.priceByResources.map((e: any) => PriceByResource.fromJSON(e))
        : [],
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      parameterDefinitions: globalThis.Array.isArray(object?.parameterDefinitions)
        ? object.parameterDefinitions.map((e: any) => ParameterDefinition.fromJSON(e))
        : [],
      dealCode: isSet(object.dealCode) ? globalThis.String(object.dealCode) : "",
    };
  },

  toJSON(message: Offer): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.marketingInfo !== undefined) {
      obj.marketingInfo = MarketingInfo.toJSON(message.marketingInfo);
    }
    if (message.sku !== undefined) {
      obj.sku = Sku.toJSON(message.sku);
    }
    if (message.plan !== undefined) {
      obj.plan = Plan.toJSON(message.plan);
    }
    if (message.constraints !== undefined) {
      obj.constraints = Constraints.toJSON(message.constraints);
    }
    if (message.priceByResources?.length) {
      obj.priceByResources = message.priceByResources.map((e) => PriceByResource.toJSON(e));
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.parameterDefinitions?.length) {
      obj.parameterDefinitions = message.parameterDefinitions.map((e) => ParameterDefinition.toJSON(e));
    }
    if (message.dealCode !== "") {
      obj.dealCode = message.dealCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Offer>): Offer {
    return Offer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Offer>): Offer {
    const message = createBaseOffer();
    message.name = object.name ?? "";
    message.marketingInfo = (object.marketingInfo !== undefined && object.marketingInfo !== null)
      ? MarketingInfo.fromPartial(object.marketingInfo)
      : undefined;
    message.sku = (object.sku !== undefined && object.sku !== null) ? Sku.fromPartial(object.sku) : undefined;
    message.plan = (object.plan !== undefined && object.plan !== null) ? Plan.fromPartial(object.plan) : undefined;
    message.constraints = (object.constraints !== undefined && object.constraints !== null)
      ? Constraints.fromPartial(object.constraints)
      : undefined;
    message.priceByResources = object.priceByResources?.map((e) => PriceByResource.fromPartial(e)) || [];
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.parameterDefinitions = object.parameterDefinitions?.map((e) => ParameterDefinition.fromPartial(e)) || [];
    message.dealCode = object.dealCode ?? "";
    return message;
  },
};

function createBaseParameterDefinition(): ParameterDefinition {
  return { name: "", parameterType: 0, minValue: undefined, maxValue: undefined, allowedValues: [], optional: false };
}

export const ParameterDefinition: MessageFns<ParameterDefinition> = {
  encode(message: ParameterDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.parameterType !== 0) {
      writer.uint32(16).int32(message.parameterType);
    }
    if (message.minValue !== undefined) {
      Value.encode(message.minValue, writer.uint32(26).fork()).join();
    }
    if (message.maxValue !== undefined) {
      Value.encode(message.maxValue, writer.uint32(34).fork()).join();
    }
    for (const v of message.allowedValues) {
      Value.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.optional !== false) {
      writer.uint32(48).bool(message.optional);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParameterDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameterDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.parameterType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.minValue = Value.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.maxValue = Value.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.allowedValues.push(Value.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.optional = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParameterDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parameterType: isSet(object.parameterType) ? parameterDefinition_ParameterTypeFromJSON(object.parameterType) : 0,
      minValue: isSet(object.minValue) ? Value.fromJSON(object.minValue) : undefined,
      maxValue: isSet(object.maxValue) ? Value.fromJSON(object.maxValue) : undefined,
      allowedValues: globalThis.Array.isArray(object?.allowedValues)
        ? object.allowedValues.map((e: any) => Value.fromJSON(e))
        : [],
      optional: isSet(object.optional) ? globalThis.Boolean(object.optional) : false,
    };
  },

  toJSON(message: ParameterDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parameterType !== 0) {
      obj.parameterType = parameterDefinition_ParameterTypeToJSON(message.parameterType);
    }
    if (message.minValue !== undefined) {
      obj.minValue = Value.toJSON(message.minValue);
    }
    if (message.maxValue !== undefined) {
      obj.maxValue = Value.toJSON(message.maxValue);
    }
    if (message.allowedValues?.length) {
      obj.allowedValues = message.allowedValues.map((e) => Value.toJSON(e));
    }
    if (message.optional !== false) {
      obj.optional = message.optional;
    }
    return obj;
  },

  create(base?: DeepPartial<ParameterDefinition>): ParameterDefinition {
    return ParameterDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParameterDefinition>): ParameterDefinition {
    const message = createBaseParameterDefinition();
    message.name = object.name ?? "";
    message.parameterType = object.parameterType ?? 0;
    message.minValue = (object.minValue !== undefined && object.minValue !== null)
      ? Value.fromPartial(object.minValue)
      : undefined;
    message.maxValue = (object.maxValue !== undefined && object.maxValue !== null)
      ? Value.fromPartial(object.maxValue)
      : undefined;
    message.allowedValues = object.allowedValues?.map((e) => Value.fromPartial(e)) || [];
    message.optional = object.optional ?? false;
    return message;
  },
};

function createBaseConstraints(): Constraints {
  return { customerConstraints: undefined };
}

export const Constraints: MessageFns<Constraints> = {
  encode(message: Constraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerConstraints !== undefined) {
      CustomerConstraints.encode(message.customerConstraints, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Constraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customerConstraints = CustomerConstraints.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Constraints {
    return {
      customerConstraints: isSet(object.customerConstraints)
        ? CustomerConstraints.fromJSON(object.customerConstraints)
        : undefined,
    };
  },

  toJSON(message: Constraints): unknown {
    const obj: any = {};
    if (message.customerConstraints !== undefined) {
      obj.customerConstraints = CustomerConstraints.toJSON(message.customerConstraints);
    }
    return obj;
  },

  create(base?: DeepPartial<Constraints>): Constraints {
    return Constraints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Constraints>): Constraints {
    const message = createBaseConstraints();
    message.customerConstraints = (object.customerConstraints !== undefined && object.customerConstraints !== null)
      ? CustomerConstraints.fromPartial(object.customerConstraints)
      : undefined;
    return message;
  },
};

function createBaseCustomerConstraints(): CustomerConstraints {
  return { allowedRegions: [], allowedCustomerTypes: [], promotionalOrderTypes: [] };
}

export const CustomerConstraints: MessageFns<CustomerConstraints> = {
  encode(message: CustomerConstraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowedRegions) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.allowedCustomerTypes) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(26).fork();
    for (const v of message.promotionalOrderTypes) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomerConstraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedRegions.push(reader.string());
          continue;
        case 2:
          if (tag === 16) {
            message.allowedCustomerTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedCustomerTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 3:
          if (tag === 24) {
            message.promotionalOrderTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.promotionalOrderTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerConstraints {
    return {
      allowedRegions: globalThis.Array.isArray(object?.allowedRegions)
        ? object.allowedRegions.map((e: any) => globalThis.String(e))
        : [],
      allowedCustomerTypes: globalThis.Array.isArray(object?.allowedCustomerTypes)
        ? object.allowedCustomerTypes.map((e: any) => cloudIdentityInfo_CustomerTypeFromJSON(e))
        : [],
      promotionalOrderTypes: globalThis.Array.isArray(object?.promotionalOrderTypes)
        ? object.promotionalOrderTypes.map((e: any) => promotionalOrderTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: CustomerConstraints): unknown {
    const obj: any = {};
    if (message.allowedRegions?.length) {
      obj.allowedRegions = message.allowedRegions;
    }
    if (message.allowedCustomerTypes?.length) {
      obj.allowedCustomerTypes = message.allowedCustomerTypes.map((e) => cloudIdentityInfo_CustomerTypeToJSON(e));
    }
    if (message.promotionalOrderTypes?.length) {
      obj.promotionalOrderTypes = message.promotionalOrderTypes.map((e) => promotionalOrderTypeToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CustomerConstraints>): CustomerConstraints {
    return CustomerConstraints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomerConstraints>): CustomerConstraints {
    const message = createBaseCustomerConstraints();
    message.allowedRegions = object.allowedRegions?.map((e) => e) || [];
    message.allowedCustomerTypes = object.allowedCustomerTypes?.map((e) => e) || [];
    message.promotionalOrderTypes = object.promotionalOrderTypes?.map((e) => e) || [];
    return message;
  },
};

function createBasePlan(): Plan {
  return { paymentPlan: 0, paymentType: 0, paymentCycle: undefined, trialPeriod: undefined, billingAccount: "" };
}

export const Plan: MessageFns<Plan> = {
  encode(message: Plan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentPlan !== 0) {
      writer.uint32(8).int32(message.paymentPlan);
    }
    if (message.paymentType !== 0) {
      writer.uint32(16).int32(message.paymentType);
    }
    if (message.paymentCycle !== undefined) {
      Period.encode(message.paymentCycle, writer.uint32(26).fork()).join();
    }
    if (message.trialPeriod !== undefined) {
      Period.encode(message.trialPeriod, writer.uint32(34).fork()).join();
    }
    if (message.billingAccount !== "") {
      writer.uint32(42).string(message.billingAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Plan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.paymentPlan = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.paymentType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.paymentCycle = Period.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.trialPeriod = Period.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.billingAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Plan {
    return {
      paymentPlan: isSet(object.paymentPlan) ? paymentPlanFromJSON(object.paymentPlan) : 0,
      paymentType: isSet(object.paymentType) ? paymentTypeFromJSON(object.paymentType) : 0,
      paymentCycle: isSet(object.paymentCycle) ? Period.fromJSON(object.paymentCycle) : undefined,
      trialPeriod: isSet(object.trialPeriod) ? Period.fromJSON(object.trialPeriod) : undefined,
      billingAccount: isSet(object.billingAccount) ? globalThis.String(object.billingAccount) : "",
    };
  },

  toJSON(message: Plan): unknown {
    const obj: any = {};
    if (message.paymentPlan !== 0) {
      obj.paymentPlan = paymentPlanToJSON(message.paymentPlan);
    }
    if (message.paymentType !== 0) {
      obj.paymentType = paymentTypeToJSON(message.paymentType);
    }
    if (message.paymentCycle !== undefined) {
      obj.paymentCycle = Period.toJSON(message.paymentCycle);
    }
    if (message.trialPeriod !== undefined) {
      obj.trialPeriod = Period.toJSON(message.trialPeriod);
    }
    if (message.billingAccount !== "") {
      obj.billingAccount = message.billingAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<Plan>): Plan {
    return Plan.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Plan>): Plan {
    const message = createBasePlan();
    message.paymentPlan = object.paymentPlan ?? 0;
    message.paymentType = object.paymentType ?? 0;
    message.paymentCycle = (object.paymentCycle !== undefined && object.paymentCycle !== null)
      ? Period.fromPartial(object.paymentCycle)
      : undefined;
    message.trialPeriod = (object.trialPeriod !== undefined && object.trialPeriod !== null)
      ? Period.fromPartial(object.trialPeriod)
      : undefined;
    message.billingAccount = object.billingAccount ?? "";
    return message;
  },
};

function createBasePriceByResource(): PriceByResource {
  return { resourceType: 0, price: undefined, pricePhases: [] };
}

export const PriceByResource: MessageFns<PriceByResource> = {
  encode(message: PriceByResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceType !== 0) {
      writer.uint32(8).int32(message.resourceType);
    }
    if (message.price !== undefined) {
      Price.encode(message.price, writer.uint32(18).fork()).join();
    }
    for (const v of message.pricePhases) {
      PricePhase.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceByResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceByResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.resourceType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.price = Price.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pricePhases.push(PricePhase.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceByResource {
    return {
      resourceType: isSet(object.resourceType) ? resourceTypeFromJSON(object.resourceType) : 0,
      price: isSet(object.price) ? Price.fromJSON(object.price) : undefined,
      pricePhases: globalThis.Array.isArray(object?.pricePhases)
        ? object.pricePhases.map((e: any) => PricePhase.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PriceByResource): unknown {
    const obj: any = {};
    if (message.resourceType !== 0) {
      obj.resourceType = resourceTypeToJSON(message.resourceType);
    }
    if (message.price !== undefined) {
      obj.price = Price.toJSON(message.price);
    }
    if (message.pricePhases?.length) {
      obj.pricePhases = message.pricePhases.map((e) => PricePhase.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PriceByResource>): PriceByResource {
    return PriceByResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PriceByResource>): PriceByResource {
    const message = createBasePriceByResource();
    message.resourceType = object.resourceType ?? 0;
    message.price = (object.price !== undefined && object.price !== null) ? Price.fromPartial(object.price) : undefined;
    message.pricePhases = object.pricePhases?.map((e) => PricePhase.fromPartial(e)) || [];
    return message;
  },
};

function createBasePrice(): Price {
  return { basePrice: undefined, discount: 0, effectivePrice: undefined, externalPriceUri: "" };
}

export const Price: MessageFns<Price> = {
  encode(message: Price, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.basePrice !== undefined) {
      Money.encode(message.basePrice, writer.uint32(10).fork()).join();
    }
    if (message.discount !== 0) {
      writer.uint32(17).double(message.discount);
    }
    if (message.effectivePrice !== undefined) {
      Money.encode(message.effectivePrice, writer.uint32(26).fork()).join();
    }
    if (message.externalPriceUri !== "") {
      writer.uint32(34).string(message.externalPriceUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Price {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.basePrice = Money.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.discount = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.effectivePrice = Money.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.externalPriceUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Price {
    return {
      basePrice: isSet(object.basePrice) ? Money.fromJSON(object.basePrice) : undefined,
      discount: isSet(object.discount) ? globalThis.Number(object.discount) : 0,
      effectivePrice: isSet(object.effectivePrice) ? Money.fromJSON(object.effectivePrice) : undefined,
      externalPriceUri: isSet(object.externalPriceUri) ? globalThis.String(object.externalPriceUri) : "",
    };
  },

  toJSON(message: Price): unknown {
    const obj: any = {};
    if (message.basePrice !== undefined) {
      obj.basePrice = Money.toJSON(message.basePrice);
    }
    if (message.discount !== 0) {
      obj.discount = message.discount;
    }
    if (message.effectivePrice !== undefined) {
      obj.effectivePrice = Money.toJSON(message.effectivePrice);
    }
    if (message.externalPriceUri !== "") {
      obj.externalPriceUri = message.externalPriceUri;
    }
    return obj;
  },

  create(base?: DeepPartial<Price>): Price {
    return Price.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Price>): Price {
    const message = createBasePrice();
    message.basePrice = (object.basePrice !== undefined && object.basePrice !== null)
      ? Money.fromPartial(object.basePrice)
      : undefined;
    message.discount = object.discount ?? 0;
    message.effectivePrice = (object.effectivePrice !== undefined && object.effectivePrice !== null)
      ? Money.fromPartial(object.effectivePrice)
      : undefined;
    message.externalPriceUri = object.externalPriceUri ?? "";
    return message;
  },
};

function createBasePricePhase(): PricePhase {
  return { periodType: 0, firstPeriod: 0, lastPeriod: 0, price: undefined, priceTiers: [] };
}

export const PricePhase: MessageFns<PricePhase> = {
  encode(message: PricePhase, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.periodType !== 0) {
      writer.uint32(8).int32(message.periodType);
    }
    if (message.firstPeriod !== 0) {
      writer.uint32(16).int32(message.firstPeriod);
    }
    if (message.lastPeriod !== 0) {
      writer.uint32(24).int32(message.lastPeriod);
    }
    if (message.price !== undefined) {
      Price.encode(message.price, writer.uint32(34).fork()).join();
    }
    for (const v of message.priceTiers) {
      PriceTier.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricePhase {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricePhase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.periodType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.firstPeriod = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lastPeriod = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.price = Price.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.priceTiers.push(PriceTier.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PricePhase {
    return {
      periodType: isSet(object.periodType) ? periodTypeFromJSON(object.periodType) : 0,
      firstPeriod: isSet(object.firstPeriod) ? globalThis.Number(object.firstPeriod) : 0,
      lastPeriod: isSet(object.lastPeriod) ? globalThis.Number(object.lastPeriod) : 0,
      price: isSet(object.price) ? Price.fromJSON(object.price) : undefined,
      priceTiers: globalThis.Array.isArray(object?.priceTiers)
        ? object.priceTiers.map((e: any) => PriceTier.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PricePhase): unknown {
    const obj: any = {};
    if (message.periodType !== 0) {
      obj.periodType = periodTypeToJSON(message.periodType);
    }
    if (message.firstPeriod !== 0) {
      obj.firstPeriod = Math.round(message.firstPeriod);
    }
    if (message.lastPeriod !== 0) {
      obj.lastPeriod = Math.round(message.lastPeriod);
    }
    if (message.price !== undefined) {
      obj.price = Price.toJSON(message.price);
    }
    if (message.priceTiers?.length) {
      obj.priceTiers = message.priceTiers.map((e) => PriceTier.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<PricePhase>): PricePhase {
    return PricePhase.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PricePhase>): PricePhase {
    const message = createBasePricePhase();
    message.periodType = object.periodType ?? 0;
    message.firstPeriod = object.firstPeriod ?? 0;
    message.lastPeriod = object.lastPeriod ?? 0;
    message.price = (object.price !== undefined && object.price !== null) ? Price.fromPartial(object.price) : undefined;
    message.priceTiers = object.priceTiers?.map((e) => PriceTier.fromPartial(e)) || [];
    return message;
  },
};

function createBasePriceTier(): PriceTier {
  return { firstResource: 0, lastResource: 0, price: undefined };
}

export const PriceTier: MessageFns<PriceTier> = {
  encode(message: PriceTier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.firstResource !== 0) {
      writer.uint32(8).int32(message.firstResource);
    }
    if (message.lastResource !== 0) {
      writer.uint32(16).int32(message.lastResource);
    }
    if (message.price !== undefined) {
      Price.encode(message.price, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceTier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceTier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.firstResource = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lastResource = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.price = Price.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceTier {
    return {
      firstResource: isSet(object.firstResource) ? globalThis.Number(object.firstResource) : 0,
      lastResource: isSet(object.lastResource) ? globalThis.Number(object.lastResource) : 0,
      price: isSet(object.price) ? Price.fromJSON(object.price) : undefined,
    };
  },

  toJSON(message: PriceTier): unknown {
    const obj: any = {};
    if (message.firstResource !== 0) {
      obj.firstResource = Math.round(message.firstResource);
    }
    if (message.lastResource !== 0) {
      obj.lastResource = Math.round(message.lastResource);
    }
    if (message.price !== undefined) {
      obj.price = Price.toJSON(message.price);
    }
    return obj;
  },

  create(base?: DeepPartial<PriceTier>): PriceTier {
    return PriceTier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PriceTier>): PriceTier {
    const message = createBasePriceTier();
    message.firstResource = object.firstResource ?? 0;
    message.lastResource = object.lastResource ?? 0;
    message.price = (object.price !== undefined && object.price !== null) ? Price.fromPartial(object.price) : undefined;
    return message;
  },
};

function createBasePeriod(): Period {
  return { duration: 0, periodType: 0 };
}

export const Period: MessageFns<Period> = {
  encode(message: Period, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== 0) {
      writer.uint32(8).int32(message.duration);
    }
    if (message.periodType !== 0) {
      writer.uint32(16).int32(message.periodType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Period {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePeriod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.duration = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.periodType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Period {
    return {
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      periodType: isSet(object.periodType) ? periodTypeFromJSON(object.periodType) : 0,
    };
  },

  toJSON(message: Period): unknown {
    const obj: any = {};
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.periodType !== 0) {
      obj.periodType = periodTypeToJSON(message.periodType);
    }
    return obj;
  },

  create(base?: DeepPartial<Period>): Period {
    return Period.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Period>): Period {
    const message = createBasePeriod();
    message.duration = object.duration ?? 0;
    message.periodType = object.periodType ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
