// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/channel/v1/entitlements.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Value } from "./common.js";
import { PaymentPlan, paymentPlanFromJSON, paymentPlanToJSON, Period } from "./offers.js";
import { Sku } from "./products.js";

export const protobufPackage = "google.cloud.channel.v1";

/** An entitlement is a representation of a customer's ability to use a service. */
export interface Entitlement {
  /**
   * Output only. Resource name of an entitlement in the form:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}.
   */
  name: string;
  /** Output only. The time at which the entitlement is created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which the entitlement is updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Required. The offer resource name for which the entitlement is to be
   * created. Takes the form: accounts/{account_id}/offers/{offer_id}.
   */
  offer: string;
  /**
   * Commitment settings for a commitment-based Offer.
   * Required for commitment based offers.
   */
  commitmentSettings:
    | CommitmentSettings
    | undefined;
  /** Output only. Current provisioning state of the entitlement. */
  provisioningState: Entitlement_ProvisioningState;
  /** Output only. Service provisioning details for the entitlement. */
  provisionedService:
    | ProvisionedService
    | undefined;
  /**
   * Output only. Enumerable of all current suspension reasons for an
   * entitlement.
   */
  suspensionReasons: Entitlement_SuspensionReason[];
  /**
   * Optional. This purchase order (PO) information is for resellers to use for
   * their company tracking usage. If a purchaseOrderId value is given, it
   * appears in the API responses and shows up in the invoice. The property
   * accepts up to 80 plain text characters. This is only supported for Google
   * Workspace entitlements.
   */
  purchaseOrderId: string;
  /** Output only. Settings for trial offers. */
  trialSettings:
    | TrialSettings
    | undefined;
  /** Association information to other entitlements. */
  associationInfo:
    | AssociationInfo
    | undefined;
  /**
   * Extended entitlement parameters. When creating an entitlement, valid
   * parameter names and values are defined in the
   * [Offer.parameter_definitions][google.cloud.channel.v1.Offer.parameter_definitions].
   *
   * For Google Workspace, the following Parameters may be accepted as input:
   *
   * - max_units: The maximum assignable units for a flexible offer
   *
   * OR
   *
   * - num_units: The total commitment for commitment-based offers
   *
   * The response may additionally include the following output-only Parameters:
   *
   * - assigned_units: The number of licenses assigned to users.
   *
   * For Google Cloud billing subaccounts, the following Parameter may be
   * accepted as input:
   *
   * - display_name: The display name of the billing subaccount.
   */
  parameters: Parameter[];
  /**
   * Optional. The billing account resource name that is used to pay for this
   * entitlement.
   */
  billingAccount: string;
}

/** Indicates the current provisioning state of the entitlement. */
export enum Entitlement_ProvisioningState {
  /** PROVISIONING_STATE_UNSPECIFIED - Not used. */
  PROVISIONING_STATE_UNSPECIFIED = 0,
  /** ACTIVE - The entitlement is currently active. */
  ACTIVE = 1,
  /** SUSPENDED - The entitlement is currently suspended. */
  SUSPENDED = 5,
  UNRECOGNIZED = -1,
}

export function entitlement_ProvisioningStateFromJSON(object: any): Entitlement_ProvisioningState {
  switch (object) {
    case 0:
    case "PROVISIONING_STATE_UNSPECIFIED":
      return Entitlement_ProvisioningState.PROVISIONING_STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return Entitlement_ProvisioningState.ACTIVE;
    case 5:
    case "SUSPENDED":
      return Entitlement_ProvisioningState.SUSPENDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Entitlement_ProvisioningState.UNRECOGNIZED;
  }
}

export function entitlement_ProvisioningStateToJSON(object: Entitlement_ProvisioningState): string {
  switch (object) {
    case Entitlement_ProvisioningState.PROVISIONING_STATE_UNSPECIFIED:
      return "PROVISIONING_STATE_UNSPECIFIED";
    case Entitlement_ProvisioningState.ACTIVE:
      return "ACTIVE";
    case Entitlement_ProvisioningState.SUSPENDED:
      return "SUSPENDED";
    case Entitlement_ProvisioningState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Suspension reason for an entitlement if
 * [provisioning_state][google.cloud.channel.v1.Entitlement.provisioning_state]
 * = SUSPENDED.
 */
export enum Entitlement_SuspensionReason {
  /** SUSPENSION_REASON_UNSPECIFIED - Not used. */
  SUSPENSION_REASON_UNSPECIFIED = 0,
  /** RESELLER_INITIATED - Entitlement was manually suspended by the Reseller. */
  RESELLER_INITIATED = 1,
  /** TRIAL_ENDED - Trial ended. */
  TRIAL_ENDED = 2,
  /** RENEWAL_WITH_TYPE_CANCEL - Entitlement renewal was canceled. */
  RENEWAL_WITH_TYPE_CANCEL = 3,
  /**
   * PENDING_TOS_ACCEPTANCE - Entitlement was automatically suspended on creation for pending ToS
   * acceptance on customer.
   */
  PENDING_TOS_ACCEPTANCE = 4,
  /** OTHER - Other reasons (internal reasons, abuse, etc.). */
  OTHER = 100,
  UNRECOGNIZED = -1,
}

export function entitlement_SuspensionReasonFromJSON(object: any): Entitlement_SuspensionReason {
  switch (object) {
    case 0:
    case "SUSPENSION_REASON_UNSPECIFIED":
      return Entitlement_SuspensionReason.SUSPENSION_REASON_UNSPECIFIED;
    case 1:
    case "RESELLER_INITIATED":
      return Entitlement_SuspensionReason.RESELLER_INITIATED;
    case 2:
    case "TRIAL_ENDED":
      return Entitlement_SuspensionReason.TRIAL_ENDED;
    case 3:
    case "RENEWAL_WITH_TYPE_CANCEL":
      return Entitlement_SuspensionReason.RENEWAL_WITH_TYPE_CANCEL;
    case 4:
    case "PENDING_TOS_ACCEPTANCE":
      return Entitlement_SuspensionReason.PENDING_TOS_ACCEPTANCE;
    case 100:
    case "OTHER":
      return Entitlement_SuspensionReason.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Entitlement_SuspensionReason.UNRECOGNIZED;
  }
}

export function entitlement_SuspensionReasonToJSON(object: Entitlement_SuspensionReason): string {
  switch (object) {
    case Entitlement_SuspensionReason.SUSPENSION_REASON_UNSPECIFIED:
      return "SUSPENSION_REASON_UNSPECIFIED";
    case Entitlement_SuspensionReason.RESELLER_INITIATED:
      return "RESELLER_INITIATED";
    case Entitlement_SuspensionReason.TRIAL_ENDED:
      return "TRIAL_ENDED";
    case Entitlement_SuspensionReason.RENEWAL_WITH_TYPE_CANCEL:
      return "RENEWAL_WITH_TYPE_CANCEL";
    case Entitlement_SuspensionReason.PENDING_TOS_ACCEPTANCE:
      return "PENDING_TOS_ACCEPTANCE";
    case Entitlement_SuspensionReason.OTHER:
      return "OTHER";
    case Entitlement_SuspensionReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Definition for extended entitlement parameters. */
export interface Parameter {
  /** Name of the parameter. */
  name: string;
  /** Value of the parameter. */
  value:
    | Value
    | undefined;
  /**
   * Output only. Specifies whether this parameter is allowed to be changed. For
   * example, for a Google Workspace Business Starter entitlement in commitment
   * plan, num_units is editable when entitlement is active.
   */
  editable: boolean;
}

/** Association links that an entitlement has to other entitlements. */
export interface AssociationInfo {
  /** The name of the base entitlement, for which this entitlement is an add-on. */
  baseEntitlement: string;
}

/** Service provisioned for an entitlement. */
export interface ProvisionedService {
  /**
   * Output only. Provisioning ID of the entitlement. For Google Workspace, this
   * is the underlying Subscription ID. For Google Cloud, this is the Billing
   * Account ID of the billing subaccount.
   */
  provisioningId: string;
  /**
   * Output only. The product pertaining to the provisioning resource as
   * specified in the Offer.
   */
  productId: string;
  /**
   * Output only. The SKU pertaining to the provisioning resource as specified
   * in the Offer.
   */
  skuId: string;
}

/** Commitment settings for commitment-based offers. */
export interface CommitmentSettings {
  /** Output only. Commitment start timestamp. */
  startTime:
    | Date
    | undefined;
  /** Output only. Commitment end timestamp. */
  endTime:
    | Date
    | undefined;
  /** Optional. Renewal settings applicable for a commitment-based Offer. */
  renewalSettings: RenewalSettings | undefined;
}

/** Renewal settings for renewable Offers. */
export interface RenewalSettings {
  /** If false, the plan will be completed at the end date. */
  enableRenewal: boolean;
  /**
   * If true and enable_renewal = true, the unit (for example seats or licenses)
   * will be set to the number of active units at renewal time.
   */
  resizeUnitCount: boolean;
  /** Describes how a reseller will be billed. */
  paymentPlan: PaymentPlan;
  /**
   * Describes how frequently the reseller will be billed, such as
   * once per month.
   */
  paymentCycle: Period | undefined;
}

/** Settings for trial offers. */
export interface TrialSettings {
  /**
   * Determines if the entitlement is in a trial or not:
   *
   * * `true` - The entitlement is in trial.
   * * `false` - The entitlement is not in trial.
   */
  trial: boolean;
  /**
   * Date when the trial ends. The value is in milliseconds
   * using the UNIX Epoch format. See an example [Epoch
   * converter](https://www.epochconverter.com).
   */
  endTime: Date | undefined;
}

/**
 * TransferableSku represents information a reseller needs to view existing
 * provisioned services for a customer that they do not own.
 * Read-only.
 */
export interface TransferableSku {
  /** Describes the transfer eligibility of a SKU. */
  transferEligibility:
    | TransferEligibility
    | undefined;
  /** The SKU pertaining to the provisioning resource as specified in the Offer. */
  sku:
    | Sku
    | undefined;
  /**
   * Optional. The customer to transfer has an entitlement with the populated
   * legacy SKU.
   */
  legacySku: Sku | undefined;
}

/** Specifies transfer eligibility of a SKU. */
export interface TransferEligibility {
  /** Whether reseller is eligible to transfer the SKU. */
  isEligible: boolean;
  /** Localized description if reseller is not eligible to transfer the SKU. */
  description: string;
  /** Specified the reason for ineligibility. */
  ineligibilityReason: TransferEligibility_Reason;
}

/** Reason of ineligibility. */
export enum TransferEligibility_Reason {
  /** REASON_UNSPECIFIED - Not used. */
  REASON_UNSPECIFIED = 0,
  /** PENDING_TOS_ACCEPTANCE - Reseller needs to accept TOS before transferring the SKU. */
  PENDING_TOS_ACCEPTANCE = 1,
  /** SKU_NOT_ELIGIBLE - Reseller not eligible to sell the SKU. */
  SKU_NOT_ELIGIBLE = 2,
  /** SKU_SUSPENDED - SKU subscription is suspended */
  SKU_SUSPENDED = 3,
  /**
   * CHANNEL_PARTNER_NOT_AUTHORIZED_FOR_SKU - The reseller is not authorized to transact on this Product. See
   * https://support.google.com/channelservices/answer/9759265
   */
  CHANNEL_PARTNER_NOT_AUTHORIZED_FOR_SKU = 4,
  UNRECOGNIZED = -1,
}

export function transferEligibility_ReasonFromJSON(object: any): TransferEligibility_Reason {
  switch (object) {
    case 0:
    case "REASON_UNSPECIFIED":
      return TransferEligibility_Reason.REASON_UNSPECIFIED;
    case 1:
    case "PENDING_TOS_ACCEPTANCE":
      return TransferEligibility_Reason.PENDING_TOS_ACCEPTANCE;
    case 2:
    case "SKU_NOT_ELIGIBLE":
      return TransferEligibility_Reason.SKU_NOT_ELIGIBLE;
    case 3:
    case "SKU_SUSPENDED":
      return TransferEligibility_Reason.SKU_SUSPENDED;
    case 4:
    case "CHANNEL_PARTNER_NOT_AUTHORIZED_FOR_SKU":
      return TransferEligibility_Reason.CHANNEL_PARTNER_NOT_AUTHORIZED_FOR_SKU;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferEligibility_Reason.UNRECOGNIZED;
  }
}

export function transferEligibility_ReasonToJSON(object: TransferEligibility_Reason): string {
  switch (object) {
    case TransferEligibility_Reason.REASON_UNSPECIFIED:
      return "REASON_UNSPECIFIED";
    case TransferEligibility_Reason.PENDING_TOS_ACCEPTANCE:
      return "PENDING_TOS_ACCEPTANCE";
    case TransferEligibility_Reason.SKU_NOT_ELIGIBLE:
      return "SKU_NOT_ELIGIBLE";
    case TransferEligibility_Reason.SKU_SUSPENDED:
      return "SKU_SUSPENDED";
    case TransferEligibility_Reason.CHANNEL_PARTNER_NOT_AUTHORIZED_FOR_SKU:
      return "CHANNEL_PARTNER_NOT_AUTHORIZED_FOR_SKU";
    case TransferEligibility_Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseEntitlement(): Entitlement {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    offer: "",
    commitmentSettings: undefined,
    provisioningState: 0,
    provisionedService: undefined,
    suspensionReasons: [],
    purchaseOrderId: "",
    trialSettings: undefined,
    associationInfo: undefined,
    parameters: [],
    billingAccount: "",
  };
}

export const Entitlement: MessageFns<Entitlement> = {
  encode(message: Entitlement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.offer !== "") {
      writer.uint32(66).string(message.offer);
    }
    if (message.commitmentSettings !== undefined) {
      CommitmentSettings.encode(message.commitmentSettings, writer.uint32(98).fork()).join();
    }
    if (message.provisioningState !== 0) {
      writer.uint32(104).int32(message.provisioningState);
    }
    if (message.provisionedService !== undefined) {
      ProvisionedService.encode(message.provisionedService, writer.uint32(130).fork()).join();
    }
    writer.uint32(146).fork();
    for (const v of message.suspensionReasons) {
      writer.int32(v);
    }
    writer.join();
    if (message.purchaseOrderId !== "") {
      writer.uint32(154).string(message.purchaseOrderId);
    }
    if (message.trialSettings !== undefined) {
      TrialSettings.encode(message.trialSettings, writer.uint32(170).fork()).join();
    }
    if (message.associationInfo !== undefined) {
      AssociationInfo.encode(message.associationInfo, writer.uint32(186).fork()).join();
    }
    for (const v of message.parameters) {
      Parameter.encode(v!, writer.uint32(210).fork()).join();
    }
    if (message.billingAccount !== "") {
      writer.uint32(226).string(message.billingAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entitlement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntitlement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.offer = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.commitmentSettings = CommitmentSettings.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.provisioningState = reader.int32() as any;
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.provisionedService = ProvisionedService.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag === 144) {
            message.suspensionReasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 146) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.suspensionReasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.purchaseOrderId = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.trialSettings = TrialSettings.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.associationInfo = AssociationInfo.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.parameters.push(Parameter.decode(reader, reader.uint32()));
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.billingAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entitlement {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      offer: isSet(object.offer) ? globalThis.String(object.offer) : "",
      commitmentSettings: isSet(object.commitmentSettings)
        ? CommitmentSettings.fromJSON(object.commitmentSettings)
        : undefined,
      provisioningState: isSet(object.provisioningState)
        ? entitlement_ProvisioningStateFromJSON(object.provisioningState)
        : 0,
      provisionedService: isSet(object.provisionedService)
        ? ProvisionedService.fromJSON(object.provisionedService)
        : undefined,
      suspensionReasons: globalThis.Array.isArray(object?.suspensionReasons)
        ? object.suspensionReasons.map((e: any) => entitlement_SuspensionReasonFromJSON(e))
        : [],
      purchaseOrderId: isSet(object.purchaseOrderId) ? globalThis.String(object.purchaseOrderId) : "",
      trialSettings: isSet(object.trialSettings) ? TrialSettings.fromJSON(object.trialSettings) : undefined,
      associationInfo: isSet(object.associationInfo) ? AssociationInfo.fromJSON(object.associationInfo) : undefined,
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => Parameter.fromJSON(e))
        : [],
      billingAccount: isSet(object.billingAccount) ? globalThis.String(object.billingAccount) : "",
    };
  },

  toJSON(message: Entitlement): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.offer !== "") {
      obj.offer = message.offer;
    }
    if (message.commitmentSettings !== undefined) {
      obj.commitmentSettings = CommitmentSettings.toJSON(message.commitmentSettings);
    }
    if (message.provisioningState !== 0) {
      obj.provisioningState = entitlement_ProvisioningStateToJSON(message.provisioningState);
    }
    if (message.provisionedService !== undefined) {
      obj.provisionedService = ProvisionedService.toJSON(message.provisionedService);
    }
    if (message.suspensionReasons?.length) {
      obj.suspensionReasons = message.suspensionReasons.map((e) => entitlement_SuspensionReasonToJSON(e));
    }
    if (message.purchaseOrderId !== "") {
      obj.purchaseOrderId = message.purchaseOrderId;
    }
    if (message.trialSettings !== undefined) {
      obj.trialSettings = TrialSettings.toJSON(message.trialSettings);
    }
    if (message.associationInfo !== undefined) {
      obj.associationInfo = AssociationInfo.toJSON(message.associationInfo);
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => Parameter.toJSON(e));
    }
    if (message.billingAccount !== "") {
      obj.billingAccount = message.billingAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<Entitlement>): Entitlement {
    return Entitlement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entitlement>): Entitlement {
    const message = createBaseEntitlement();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.offer = object.offer ?? "";
    message.commitmentSettings = (object.commitmentSettings !== undefined && object.commitmentSettings !== null)
      ? CommitmentSettings.fromPartial(object.commitmentSettings)
      : undefined;
    message.provisioningState = object.provisioningState ?? 0;
    message.provisionedService = (object.provisionedService !== undefined && object.provisionedService !== null)
      ? ProvisionedService.fromPartial(object.provisionedService)
      : undefined;
    message.suspensionReasons = object.suspensionReasons?.map((e) => e) || [];
    message.purchaseOrderId = object.purchaseOrderId ?? "";
    message.trialSettings = (object.trialSettings !== undefined && object.trialSettings !== null)
      ? TrialSettings.fromPartial(object.trialSettings)
      : undefined;
    message.associationInfo = (object.associationInfo !== undefined && object.associationInfo !== null)
      ? AssociationInfo.fromPartial(object.associationInfo)
      : undefined;
    message.parameters = object.parameters?.map((e) => Parameter.fromPartial(e)) || [];
    message.billingAccount = object.billingAccount ?? "";
    return message;
  },
};

function createBaseParameter(): Parameter {
  return { name: "", value: undefined, editable: false };
}

export const Parameter: MessageFns<Parameter> = {
  encode(message: Parameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    if (message.editable !== false) {
      writer.uint32(24).bool(message.editable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Parameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.editable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Parameter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
      editable: isSet(object.editable) ? globalThis.Boolean(object.editable) : false,
    };
  },

  toJSON(message: Parameter): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    if (message.editable !== false) {
      obj.editable = message.editable;
    }
    return obj;
  },

  create(base?: DeepPartial<Parameter>): Parameter {
    return Parameter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Parameter>): Parameter {
    const message = createBaseParameter();
    message.name = object.name ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    message.editable = object.editable ?? false;
    return message;
  },
};

function createBaseAssociationInfo(): AssociationInfo {
  return { baseEntitlement: "" };
}

export const AssociationInfo: MessageFns<AssociationInfo> = {
  encode(message: AssociationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseEntitlement !== "") {
      writer.uint32(10).string(message.baseEntitlement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssociationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssociationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseEntitlement = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssociationInfo {
    return { baseEntitlement: isSet(object.baseEntitlement) ? globalThis.String(object.baseEntitlement) : "" };
  },

  toJSON(message: AssociationInfo): unknown {
    const obj: any = {};
    if (message.baseEntitlement !== "") {
      obj.baseEntitlement = message.baseEntitlement;
    }
    return obj;
  },

  create(base?: DeepPartial<AssociationInfo>): AssociationInfo {
    return AssociationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AssociationInfo>): AssociationInfo {
    const message = createBaseAssociationInfo();
    message.baseEntitlement = object.baseEntitlement ?? "";
    return message;
  },
};

function createBaseProvisionedService(): ProvisionedService {
  return { provisioningId: "", productId: "", skuId: "" };
}

export const ProvisionedService: MessageFns<ProvisionedService> = {
  encode(message: ProvisionedService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provisioningId !== "") {
      writer.uint32(10).string(message.provisioningId);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.skuId !== "") {
      writer.uint32(26).string(message.skuId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProvisionedService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvisionedService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provisioningId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.skuId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProvisionedService {
    return {
      provisioningId: isSet(object.provisioningId) ? globalThis.String(object.provisioningId) : "",
      productId: isSet(object.productId) ? globalThis.String(object.productId) : "",
      skuId: isSet(object.skuId) ? globalThis.String(object.skuId) : "",
    };
  },

  toJSON(message: ProvisionedService): unknown {
    const obj: any = {};
    if (message.provisioningId !== "") {
      obj.provisioningId = message.provisioningId;
    }
    if (message.productId !== "") {
      obj.productId = message.productId;
    }
    if (message.skuId !== "") {
      obj.skuId = message.skuId;
    }
    return obj;
  },

  create(base?: DeepPartial<ProvisionedService>): ProvisionedService {
    return ProvisionedService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProvisionedService>): ProvisionedService {
    const message = createBaseProvisionedService();
    message.provisioningId = object.provisioningId ?? "";
    message.productId = object.productId ?? "";
    message.skuId = object.skuId ?? "";
    return message;
  },
};

function createBaseCommitmentSettings(): CommitmentSettings {
  return { startTime: undefined, endTime: undefined, renewalSettings: undefined };
}

export const CommitmentSettings: MessageFns<CommitmentSettings> = {
  encode(message: CommitmentSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.renewalSettings !== undefined) {
      RenewalSettings.encode(message.renewalSettings, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitmentSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitmentSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.renewalSettings = RenewalSettings.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitmentSettings {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      renewalSettings: isSet(object.renewalSettings) ? RenewalSettings.fromJSON(object.renewalSettings) : undefined,
    };
  },

  toJSON(message: CommitmentSettings): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.renewalSettings !== undefined) {
      obj.renewalSettings = RenewalSettings.toJSON(message.renewalSettings);
    }
    return obj;
  },

  create(base?: DeepPartial<CommitmentSettings>): CommitmentSettings {
    return CommitmentSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CommitmentSettings>): CommitmentSettings {
    const message = createBaseCommitmentSettings();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.renewalSettings = (object.renewalSettings !== undefined && object.renewalSettings !== null)
      ? RenewalSettings.fromPartial(object.renewalSettings)
      : undefined;
    return message;
  },
};

function createBaseRenewalSettings(): RenewalSettings {
  return { enableRenewal: false, resizeUnitCount: false, paymentPlan: 0, paymentCycle: undefined };
}

export const RenewalSettings: MessageFns<RenewalSettings> = {
  encode(message: RenewalSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableRenewal !== false) {
      writer.uint32(8).bool(message.enableRenewal);
    }
    if (message.resizeUnitCount !== false) {
      writer.uint32(16).bool(message.resizeUnitCount);
    }
    if (message.paymentPlan !== 0) {
      writer.uint32(40).int32(message.paymentPlan);
    }
    if (message.paymentCycle !== undefined) {
      Period.encode(message.paymentCycle, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenewalSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenewalSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableRenewal = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.resizeUnitCount = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.paymentPlan = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.paymentCycle = Period.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenewalSettings {
    return {
      enableRenewal: isSet(object.enableRenewal) ? globalThis.Boolean(object.enableRenewal) : false,
      resizeUnitCount: isSet(object.resizeUnitCount) ? globalThis.Boolean(object.resizeUnitCount) : false,
      paymentPlan: isSet(object.paymentPlan) ? paymentPlanFromJSON(object.paymentPlan) : 0,
      paymentCycle: isSet(object.paymentCycle) ? Period.fromJSON(object.paymentCycle) : undefined,
    };
  },

  toJSON(message: RenewalSettings): unknown {
    const obj: any = {};
    if (message.enableRenewal !== false) {
      obj.enableRenewal = message.enableRenewal;
    }
    if (message.resizeUnitCount !== false) {
      obj.resizeUnitCount = message.resizeUnitCount;
    }
    if (message.paymentPlan !== 0) {
      obj.paymentPlan = paymentPlanToJSON(message.paymentPlan);
    }
    if (message.paymentCycle !== undefined) {
      obj.paymentCycle = Period.toJSON(message.paymentCycle);
    }
    return obj;
  },

  create(base?: DeepPartial<RenewalSettings>): RenewalSettings {
    return RenewalSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenewalSettings>): RenewalSettings {
    const message = createBaseRenewalSettings();
    message.enableRenewal = object.enableRenewal ?? false;
    message.resizeUnitCount = object.resizeUnitCount ?? false;
    message.paymentPlan = object.paymentPlan ?? 0;
    message.paymentCycle = (object.paymentCycle !== undefined && object.paymentCycle !== null)
      ? Period.fromPartial(object.paymentCycle)
      : undefined;
    return message;
  },
};

function createBaseTrialSettings(): TrialSettings {
  return { trial: false, endTime: undefined };
}

export const TrialSettings: MessageFns<TrialSettings> = {
  encode(message: TrialSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trial !== false) {
      writer.uint32(8).bool(message.trial);
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrialSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrialSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.trial = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrialSettings {
    return {
      trial: isSet(object.trial) ? globalThis.Boolean(object.trial) : false,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TrialSettings): unknown {
    const obj: any = {};
    if (message.trial !== false) {
      obj.trial = message.trial;
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TrialSettings>): TrialSettings {
    return TrialSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrialSettings>): TrialSettings {
    const message = createBaseTrialSettings();
    message.trial = object.trial ?? false;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseTransferableSku(): TransferableSku {
  return { transferEligibility: undefined, sku: undefined, legacySku: undefined };
}

export const TransferableSku: MessageFns<TransferableSku> = {
  encode(message: TransferableSku, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferEligibility !== undefined) {
      TransferEligibility.encode(message.transferEligibility, writer.uint32(74).fork()).join();
    }
    if (message.sku !== undefined) {
      Sku.encode(message.sku, writer.uint32(90).fork()).join();
    }
    if (message.legacySku !== undefined) {
      Sku.encode(message.legacySku, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferableSku {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferableSku();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 9:
          if (tag !== 74) {
            break;
          }

          message.transferEligibility = TransferEligibility.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.sku = Sku.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.legacySku = Sku.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferableSku {
    return {
      transferEligibility: isSet(object.transferEligibility)
        ? TransferEligibility.fromJSON(object.transferEligibility)
        : undefined,
      sku: isSet(object.sku) ? Sku.fromJSON(object.sku) : undefined,
      legacySku: isSet(object.legacySku) ? Sku.fromJSON(object.legacySku) : undefined,
    };
  },

  toJSON(message: TransferableSku): unknown {
    const obj: any = {};
    if (message.transferEligibility !== undefined) {
      obj.transferEligibility = TransferEligibility.toJSON(message.transferEligibility);
    }
    if (message.sku !== undefined) {
      obj.sku = Sku.toJSON(message.sku);
    }
    if (message.legacySku !== undefined) {
      obj.legacySku = Sku.toJSON(message.legacySku);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferableSku>): TransferableSku {
    return TransferableSku.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferableSku>): TransferableSku {
    const message = createBaseTransferableSku();
    message.transferEligibility = (object.transferEligibility !== undefined && object.transferEligibility !== null)
      ? TransferEligibility.fromPartial(object.transferEligibility)
      : undefined;
    message.sku = (object.sku !== undefined && object.sku !== null) ? Sku.fromPartial(object.sku) : undefined;
    message.legacySku = (object.legacySku !== undefined && object.legacySku !== null)
      ? Sku.fromPartial(object.legacySku)
      : undefined;
    return message;
  },
};

function createBaseTransferEligibility(): TransferEligibility {
  return { isEligible: false, description: "", ineligibilityReason: 0 };
}

export const TransferEligibility: MessageFns<TransferEligibility> = {
  encode(message: TransferEligibility, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isEligible !== false) {
      writer.uint32(8).bool(message.isEligible);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.ineligibilityReason !== 0) {
      writer.uint32(24).int32(message.ineligibilityReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferEligibility {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferEligibility();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.isEligible = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.ineligibilityReason = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferEligibility {
    return {
      isEligible: isSet(object.isEligible) ? globalThis.Boolean(object.isEligible) : false,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      ineligibilityReason: isSet(object.ineligibilityReason)
        ? transferEligibility_ReasonFromJSON(object.ineligibilityReason)
        : 0,
    };
  },

  toJSON(message: TransferEligibility): unknown {
    const obj: any = {};
    if (message.isEligible !== false) {
      obj.isEligible = message.isEligible;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.ineligibilityReason !== 0) {
      obj.ineligibilityReason = transferEligibility_ReasonToJSON(message.ineligibilityReason);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferEligibility>): TransferEligibility {
    return TransferEligibility.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferEligibility>): TransferEligibility {
    const message = createBaseTransferEligibility();
    message.isEligible = object.isEligible ?? false;
    message.description = object.description ?? "";
    message.ineligibilityReason = object.ineligibilityReason ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
