// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/channel/v1/repricing.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DateMessage } from "../../../type/date.js";
import { Decimal } from "../../../type/decimal.js";

export const protobufPackage = "google.cloud.channel.v1";

/** Specifies the different costs that the modified bill can be based on. */
export enum RebillingBasis {
  /** REBILLING_BASIS_UNSPECIFIED - Not used. */
  REBILLING_BASIS_UNSPECIFIED = 0,
  /** COST_AT_LIST - Use the list cost, also known as the MSRP. */
  COST_AT_LIST = 1,
  /**
   * DIRECT_CUSTOMER_COST - Pass through all discounts except the Reseller Program Discount. If this is
   * the default cost base and no adjustments are specified, the output cost
   * will be exactly what the customer would see if they viewed the bill in the
   * Google Cloud Console.
   */
  DIRECT_CUSTOMER_COST = 2,
  UNRECOGNIZED = -1,
}

export function rebillingBasisFromJSON(object: any): RebillingBasis {
  switch (object) {
    case 0:
    case "REBILLING_BASIS_UNSPECIFIED":
      return RebillingBasis.REBILLING_BASIS_UNSPECIFIED;
    case 1:
    case "COST_AT_LIST":
      return RebillingBasis.COST_AT_LIST;
    case 2:
    case "DIRECT_CUSTOMER_COST":
      return RebillingBasis.DIRECT_CUSTOMER_COST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RebillingBasis.UNRECOGNIZED;
  }
}

export function rebillingBasisToJSON(object: RebillingBasis): string {
  switch (object) {
    case RebillingBasis.REBILLING_BASIS_UNSPECIFIED:
      return "REBILLING_BASIS_UNSPECIFIED";
    case RebillingBasis.COST_AT_LIST:
      return "COST_AT_LIST";
    case RebillingBasis.DIRECT_CUSTOMER_COST:
      return "DIRECT_CUSTOMER_COST";
    case RebillingBasis.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration for how a reseller will reprice a Customer. */
export interface CustomerRepricingConfig {
  /**
   * Output only. Resource name of the CustomerRepricingConfig.
   * Format:
   * accounts/{account_id}/customers/{customer_id}/customerRepricingConfigs/{id}.
   */
  name: string;
  /**
   * Required. The configuration for bill modifications made by a reseller
   * before sending it to customers.
   */
  repricingConfig:
    | RepricingConfig
    | undefined;
  /**
   * Output only. Timestamp of an update to the repricing rule. If `update_time`
   * is after
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * then it indicates this was set mid-month.
   */
  updateTime: Date | undefined;
}

/**
 * Configuration for how a distributor will rebill a channel partner
 * (also known as a distributor-authorized reseller).
 */
export interface ChannelPartnerRepricingConfig {
  /**
   * Output only. Resource name of the ChannelPartnerRepricingConfig.
   * Format:
   * accounts/{account_id}/channelPartnerLinks/{channel_partner_id}/channelPartnerRepricingConfigs/{id}.
   */
  name: string;
  /**
   * Required. The configuration for bill modifications made by a reseller
   * before sending it to ChannelPartner.
   */
  repricingConfig:
    | RepricingConfig
    | undefined;
  /**
   * Output only. Timestamp of an update to the repricing rule. If `update_time`
   * is after
   * [RepricingConfig.effective_invoice_month][google.cloud.channel.v1.RepricingConfig.effective_invoice_month]
   * then it indicates this was set mid-month.
   */
  updateTime: Date | undefined;
}

/** Configuration for repricing a Google bill over a period of time. */
export interface RepricingConfig {
  /**
   * Applies the repricing configuration at the entitlement level.
   *
   * Note: If a
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * using
   * [RepricingConfig.EntitlementGranularity][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity]
   * becomes effective, then no existing or future
   * [RepricingConfig.ChannelPartnerGranularity][google.cloud.channel.v1.RepricingConfig.ChannelPartnerGranularity]
   * will apply to the
   * [RepricingConfig.EntitlementGranularity.entitlement][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity.entitlement].
   * This is the recommended value for both
   * [CustomerRepricingConfig][google.cloud.channel.v1.CustomerRepricingConfig]
   * and
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig].
   */
  entitlementGranularity?:
    | RepricingConfig_EntitlementGranularity
    | undefined;
  /**
   * Applies the repricing configuration at the channel partner level.
   * Only
   * [ChannelPartnerRepricingConfig][google.cloud.channel.v1.ChannelPartnerRepricingConfig]
   * supports this value. Deprecated: This is no longer supported. Use
   * [RepricingConfig.entitlement_granularity][google.cloud.channel.v1.RepricingConfig.entitlement_granularity]
   * instead.
   *
   * @deprecated
   */
  channelPartnerGranularity?:
    | RepricingConfig_ChannelPartnerGranularity
    | undefined;
  /**
   * Required. The YearMonth when these adjustments activate. The Day field
   * needs to be "0" since we only accept YearMonth repricing boundaries.
   */
  effectiveInvoiceMonth:
    | DateMessage
    | undefined;
  /** Required. Information about the adjustment. */
  adjustment:
    | RepricingAdjustment
    | undefined;
  /**
   * Required. The [RebillingBasis][google.cloud.channel.v1.RebillingBasis] to
   * use for this bill. Specifies the relative cost based on repricing costs you
   * will apply.
   */
  rebillingBasis: RebillingBasis;
  /**
   * The conditional overrides to apply for this configuration. If you list
   * multiple overrides, only the first valid override is used.  If you don't
   * list any overrides, the API uses the normal adjustment and rebilling basis.
   */
  conditionalOverrides: ConditionalOverride[];
}

/** Applies the repricing configuration at the entitlement level. */
export interface RepricingConfig_EntitlementGranularity {
  /**
   * Resource name of the entitlement.
   * Format:
   * accounts/{account_id}/customers/{customer_id}/entitlements/{entitlement_id}
   */
  entitlement: string;
}

/**
 * Applies the repricing configuration at the channel partner level.
 * The channel partner value is derived from the resource name. Takes an
 * empty json object.
 * Deprecated: This is no longer supported. Use
 * [RepricingConfig.EntitlementGranularity][google.cloud.channel.v1.RepricingConfig.EntitlementGranularity]
 * instead.
 *
 * @deprecated
 */
export interface RepricingConfig_ChannelPartnerGranularity {
}

/** A type that represents the various adjustments you can apply to a bill. */
export interface RepricingAdjustment {
  /** Flat markup or markdown on an entire bill. */
  percentageAdjustment?: PercentageAdjustment | undefined;
}

/** An adjustment that applies a flat markup or markdown to an entire bill. */
export interface PercentageAdjustment {
  /**
   * The percentage of the bill to adjust.
   * For example:
   * Mark down by 1% => "-1.00"
   * Mark up by 1%   => "1.00"
   * Pass-Through    => "0.00"
   */
  percentage: Decimal | undefined;
}

/** Specifies the override to conditionally apply. */
export interface ConditionalOverride {
  /** Required. Information about the applied override's adjustment. */
  adjustment:
    | RepricingAdjustment
    | undefined;
  /**
   * Required. The [RebillingBasis][google.cloud.channel.v1.RebillingBasis] to
   * use for the applied override. Shows the relative cost based on your
   * repricing costs.
   */
  rebillingBasis: RebillingBasis;
  /** Required. Specifies the condition which, if met, will apply the override. */
  repricingCondition: RepricingCondition | undefined;
}

/**
 * Represents the various repricing conditions you can use for a conditional
 * override.
 */
export interface RepricingCondition {
  /** SKU Group condition for override. */
  skuGroupCondition?: SkuGroupCondition | undefined;
}

/**
 * A condition that applies the override if a line item SKU is found in the SKU
 * group.
 */
export interface SkuGroupCondition {
  /**
   * Specifies a SKU group (https://cloud.google.com/skus/sku-groups).
   * Resource name of SKU group. Format:
   * accounts/{account}/skuGroups/{sku_group}.
   * Example:
   * "accounts/C01234/skuGroups/3d50fd57-3157-4577-a5a9-a219b8490041".
   */
  skuGroup: string;
}

function createBaseCustomerRepricingConfig(): CustomerRepricingConfig {
  return { name: "", repricingConfig: undefined, updateTime: undefined };
}

export const CustomerRepricingConfig: MessageFns<CustomerRepricingConfig> = {
  encode(message: CustomerRepricingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.repricingConfig !== undefined) {
      RepricingConfig.encode(message.repricingConfig, writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomerRepricingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerRepricingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.repricingConfig = RepricingConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerRepricingConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      repricingConfig: isSet(object.repricingConfig) ? RepricingConfig.fromJSON(object.repricingConfig) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: CustomerRepricingConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.repricingConfig !== undefined) {
      obj.repricingConfig = RepricingConfig.toJSON(message.repricingConfig);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CustomerRepricingConfig>): CustomerRepricingConfig {
    return CustomerRepricingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomerRepricingConfig>): CustomerRepricingConfig {
    const message = createBaseCustomerRepricingConfig();
    message.name = object.name ?? "";
    message.repricingConfig = (object.repricingConfig !== undefined && object.repricingConfig !== null)
      ? RepricingConfig.fromPartial(object.repricingConfig)
      : undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseChannelPartnerRepricingConfig(): ChannelPartnerRepricingConfig {
  return { name: "", repricingConfig: undefined, updateTime: undefined };
}

export const ChannelPartnerRepricingConfig: MessageFns<ChannelPartnerRepricingConfig> = {
  encode(message: ChannelPartnerRepricingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.repricingConfig !== undefined) {
      RepricingConfig.encode(message.repricingConfig, writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelPartnerRepricingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelPartnerRepricingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.repricingConfig = RepricingConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelPartnerRepricingConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      repricingConfig: isSet(object.repricingConfig) ? RepricingConfig.fromJSON(object.repricingConfig) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: ChannelPartnerRepricingConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.repricingConfig !== undefined) {
      obj.repricingConfig = RepricingConfig.toJSON(message.repricingConfig);
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ChannelPartnerRepricingConfig>): ChannelPartnerRepricingConfig {
    return ChannelPartnerRepricingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChannelPartnerRepricingConfig>): ChannelPartnerRepricingConfig {
    const message = createBaseChannelPartnerRepricingConfig();
    message.name = object.name ?? "";
    message.repricingConfig = (object.repricingConfig !== undefined && object.repricingConfig !== null)
      ? RepricingConfig.fromPartial(object.repricingConfig)
      : undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseRepricingConfig(): RepricingConfig {
  return {
    entitlementGranularity: undefined,
    channelPartnerGranularity: undefined,
    effectiveInvoiceMonth: undefined,
    adjustment: undefined,
    rebillingBasis: 0,
    conditionalOverrides: [],
  };
}

export const RepricingConfig: MessageFns<RepricingConfig> = {
  encode(message: RepricingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entitlementGranularity !== undefined) {
      RepricingConfig_EntitlementGranularity.encode(message.entitlementGranularity, writer.uint32(34).fork()).join();
    }
    if (message.channelPartnerGranularity !== undefined) {
      RepricingConfig_ChannelPartnerGranularity.encode(message.channelPartnerGranularity, writer.uint32(42).fork())
        .join();
    }
    if (message.effectiveInvoiceMonth !== undefined) {
      DateMessage.encode(message.effectiveInvoiceMonth, writer.uint32(10).fork()).join();
    }
    if (message.adjustment !== undefined) {
      RepricingAdjustment.encode(message.adjustment, writer.uint32(18).fork()).join();
    }
    if (message.rebillingBasis !== 0) {
      writer.uint32(24).int32(message.rebillingBasis);
    }
    for (const v of message.conditionalOverrides) {
      ConditionalOverride.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepricingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepricingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.entitlementGranularity = RepricingConfig_EntitlementGranularity.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.channelPartnerGranularity = RepricingConfig_ChannelPartnerGranularity.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.effectiveInvoiceMonth = DateMessage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.adjustment = RepricingAdjustment.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.rebillingBasis = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.conditionalOverrides.push(ConditionalOverride.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepricingConfig {
    return {
      entitlementGranularity: isSet(object.entitlementGranularity)
        ? RepricingConfig_EntitlementGranularity.fromJSON(object.entitlementGranularity)
        : undefined,
      channelPartnerGranularity: isSet(object.channelPartnerGranularity)
        ? RepricingConfig_ChannelPartnerGranularity.fromJSON(object.channelPartnerGranularity)
        : undefined,
      effectiveInvoiceMonth: isSet(object.effectiveInvoiceMonth)
        ? DateMessage.fromJSON(object.effectiveInvoiceMonth)
        : undefined,
      adjustment: isSet(object.adjustment) ? RepricingAdjustment.fromJSON(object.adjustment) : undefined,
      rebillingBasis: isSet(object.rebillingBasis) ? rebillingBasisFromJSON(object.rebillingBasis) : 0,
      conditionalOverrides: globalThis.Array.isArray(object?.conditionalOverrides)
        ? object.conditionalOverrides.map((e: any) => ConditionalOverride.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RepricingConfig): unknown {
    const obj: any = {};
    if (message.entitlementGranularity !== undefined) {
      obj.entitlementGranularity = RepricingConfig_EntitlementGranularity.toJSON(message.entitlementGranularity);
    }
    if (message.channelPartnerGranularity !== undefined) {
      obj.channelPartnerGranularity = RepricingConfig_ChannelPartnerGranularity.toJSON(
        message.channelPartnerGranularity,
      );
    }
    if (message.effectiveInvoiceMonth !== undefined) {
      obj.effectiveInvoiceMonth = DateMessage.toJSON(message.effectiveInvoiceMonth);
    }
    if (message.adjustment !== undefined) {
      obj.adjustment = RepricingAdjustment.toJSON(message.adjustment);
    }
    if (message.rebillingBasis !== 0) {
      obj.rebillingBasis = rebillingBasisToJSON(message.rebillingBasis);
    }
    if (message.conditionalOverrides?.length) {
      obj.conditionalOverrides = message.conditionalOverrides.map((e) => ConditionalOverride.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RepricingConfig>): RepricingConfig {
    return RepricingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepricingConfig>): RepricingConfig {
    const message = createBaseRepricingConfig();
    message.entitlementGranularity =
      (object.entitlementGranularity !== undefined && object.entitlementGranularity !== null)
        ? RepricingConfig_EntitlementGranularity.fromPartial(object.entitlementGranularity)
        : undefined;
    message.channelPartnerGranularity =
      (object.channelPartnerGranularity !== undefined && object.channelPartnerGranularity !== null)
        ? RepricingConfig_ChannelPartnerGranularity.fromPartial(object.channelPartnerGranularity)
        : undefined;
    message.effectiveInvoiceMonth =
      (object.effectiveInvoiceMonth !== undefined && object.effectiveInvoiceMonth !== null)
        ? DateMessage.fromPartial(object.effectiveInvoiceMonth)
        : undefined;
    message.adjustment = (object.adjustment !== undefined && object.adjustment !== null)
      ? RepricingAdjustment.fromPartial(object.adjustment)
      : undefined;
    message.rebillingBasis = object.rebillingBasis ?? 0;
    message.conditionalOverrides = object.conditionalOverrides?.map((e) => ConditionalOverride.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRepricingConfig_EntitlementGranularity(): RepricingConfig_EntitlementGranularity {
  return { entitlement: "" };
}

export const RepricingConfig_EntitlementGranularity: MessageFns<RepricingConfig_EntitlementGranularity> = {
  encode(message: RepricingConfig_EntitlementGranularity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entitlement !== "") {
      writer.uint32(10).string(message.entitlement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepricingConfig_EntitlementGranularity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepricingConfig_EntitlementGranularity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entitlement = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepricingConfig_EntitlementGranularity {
    return { entitlement: isSet(object.entitlement) ? globalThis.String(object.entitlement) : "" };
  },

  toJSON(message: RepricingConfig_EntitlementGranularity): unknown {
    const obj: any = {};
    if (message.entitlement !== "") {
      obj.entitlement = message.entitlement;
    }
    return obj;
  },

  create(base?: DeepPartial<RepricingConfig_EntitlementGranularity>): RepricingConfig_EntitlementGranularity {
    return RepricingConfig_EntitlementGranularity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepricingConfig_EntitlementGranularity>): RepricingConfig_EntitlementGranularity {
    const message = createBaseRepricingConfig_EntitlementGranularity();
    message.entitlement = object.entitlement ?? "";
    return message;
  },
};

function createBaseRepricingConfig_ChannelPartnerGranularity(): RepricingConfig_ChannelPartnerGranularity {
  return {};
}

export const RepricingConfig_ChannelPartnerGranularity: MessageFns<RepricingConfig_ChannelPartnerGranularity> = {
  encode(_: RepricingConfig_ChannelPartnerGranularity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepricingConfig_ChannelPartnerGranularity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepricingConfig_ChannelPartnerGranularity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RepricingConfig_ChannelPartnerGranularity {
    return {};
  },

  toJSON(_: RepricingConfig_ChannelPartnerGranularity): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RepricingConfig_ChannelPartnerGranularity>): RepricingConfig_ChannelPartnerGranularity {
    return RepricingConfig_ChannelPartnerGranularity.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RepricingConfig_ChannelPartnerGranularity>): RepricingConfig_ChannelPartnerGranularity {
    const message = createBaseRepricingConfig_ChannelPartnerGranularity();
    return message;
  },
};

function createBaseRepricingAdjustment(): RepricingAdjustment {
  return { percentageAdjustment: undefined };
}

export const RepricingAdjustment: MessageFns<RepricingAdjustment> = {
  encode(message: RepricingAdjustment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.percentageAdjustment !== undefined) {
      PercentageAdjustment.encode(message.percentageAdjustment, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepricingAdjustment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepricingAdjustment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.percentageAdjustment = PercentageAdjustment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepricingAdjustment {
    return {
      percentageAdjustment: isSet(object.percentageAdjustment)
        ? PercentageAdjustment.fromJSON(object.percentageAdjustment)
        : undefined,
    };
  },

  toJSON(message: RepricingAdjustment): unknown {
    const obj: any = {};
    if (message.percentageAdjustment !== undefined) {
      obj.percentageAdjustment = PercentageAdjustment.toJSON(message.percentageAdjustment);
    }
    return obj;
  },

  create(base?: DeepPartial<RepricingAdjustment>): RepricingAdjustment {
    return RepricingAdjustment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepricingAdjustment>): RepricingAdjustment {
    const message = createBaseRepricingAdjustment();
    message.percentageAdjustment = (object.percentageAdjustment !== undefined && object.percentageAdjustment !== null)
      ? PercentageAdjustment.fromPartial(object.percentageAdjustment)
      : undefined;
    return message;
  },
};

function createBasePercentageAdjustment(): PercentageAdjustment {
  return { percentage: undefined };
}

export const PercentageAdjustment: MessageFns<PercentageAdjustment> = {
  encode(message: PercentageAdjustment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.percentage !== undefined) {
      Decimal.encode(message.percentage, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PercentageAdjustment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePercentageAdjustment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.percentage = Decimal.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PercentageAdjustment {
    return { percentage: isSet(object.percentage) ? Decimal.fromJSON(object.percentage) : undefined };
  },

  toJSON(message: PercentageAdjustment): unknown {
    const obj: any = {};
    if (message.percentage !== undefined) {
      obj.percentage = Decimal.toJSON(message.percentage);
    }
    return obj;
  },

  create(base?: DeepPartial<PercentageAdjustment>): PercentageAdjustment {
    return PercentageAdjustment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PercentageAdjustment>): PercentageAdjustment {
    const message = createBasePercentageAdjustment();
    message.percentage = (object.percentage !== undefined && object.percentage !== null)
      ? Decimal.fromPartial(object.percentage)
      : undefined;
    return message;
  },
};

function createBaseConditionalOverride(): ConditionalOverride {
  return { adjustment: undefined, rebillingBasis: 0, repricingCondition: undefined };
}

export const ConditionalOverride: MessageFns<ConditionalOverride> = {
  encode(message: ConditionalOverride, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.adjustment !== undefined) {
      RepricingAdjustment.encode(message.adjustment, writer.uint32(10).fork()).join();
    }
    if (message.rebillingBasis !== 0) {
      writer.uint32(16).int32(message.rebillingBasis);
    }
    if (message.repricingCondition !== undefined) {
      RepricingCondition.encode(message.repricingCondition, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConditionalOverride {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConditionalOverride();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.adjustment = RepricingAdjustment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.rebillingBasis = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.repricingCondition = RepricingCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConditionalOverride {
    return {
      adjustment: isSet(object.adjustment) ? RepricingAdjustment.fromJSON(object.adjustment) : undefined,
      rebillingBasis: isSet(object.rebillingBasis) ? rebillingBasisFromJSON(object.rebillingBasis) : 0,
      repricingCondition: isSet(object.repricingCondition)
        ? RepricingCondition.fromJSON(object.repricingCondition)
        : undefined,
    };
  },

  toJSON(message: ConditionalOverride): unknown {
    const obj: any = {};
    if (message.adjustment !== undefined) {
      obj.adjustment = RepricingAdjustment.toJSON(message.adjustment);
    }
    if (message.rebillingBasis !== 0) {
      obj.rebillingBasis = rebillingBasisToJSON(message.rebillingBasis);
    }
    if (message.repricingCondition !== undefined) {
      obj.repricingCondition = RepricingCondition.toJSON(message.repricingCondition);
    }
    return obj;
  },

  create(base?: DeepPartial<ConditionalOverride>): ConditionalOverride {
    return ConditionalOverride.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConditionalOverride>): ConditionalOverride {
    const message = createBaseConditionalOverride();
    message.adjustment = (object.adjustment !== undefined && object.adjustment !== null)
      ? RepricingAdjustment.fromPartial(object.adjustment)
      : undefined;
    message.rebillingBasis = object.rebillingBasis ?? 0;
    message.repricingCondition = (object.repricingCondition !== undefined && object.repricingCondition !== null)
      ? RepricingCondition.fromPartial(object.repricingCondition)
      : undefined;
    return message;
  },
};

function createBaseRepricingCondition(): RepricingCondition {
  return { skuGroupCondition: undefined };
}

export const RepricingCondition: MessageFns<RepricingCondition> = {
  encode(message: RepricingCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.skuGroupCondition !== undefined) {
      SkuGroupCondition.encode(message.skuGroupCondition, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepricingCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepricingCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuGroupCondition = SkuGroupCondition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepricingCondition {
    return {
      skuGroupCondition: isSet(object.skuGroupCondition)
        ? SkuGroupCondition.fromJSON(object.skuGroupCondition)
        : undefined,
    };
  },

  toJSON(message: RepricingCondition): unknown {
    const obj: any = {};
    if (message.skuGroupCondition !== undefined) {
      obj.skuGroupCondition = SkuGroupCondition.toJSON(message.skuGroupCondition);
    }
    return obj;
  },

  create(base?: DeepPartial<RepricingCondition>): RepricingCondition {
    return RepricingCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RepricingCondition>): RepricingCondition {
    const message = createBaseRepricingCondition();
    message.skuGroupCondition = (object.skuGroupCondition !== undefined && object.skuGroupCondition !== null)
      ? SkuGroupCondition.fromPartial(object.skuGroupCondition)
      : undefined;
    return message;
  },
};

function createBaseSkuGroupCondition(): SkuGroupCondition {
  return { skuGroup: "" };
}

export const SkuGroupCondition: MessageFns<SkuGroupCondition> = {
  encode(message: SkuGroupCondition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.skuGroup !== "") {
      writer.uint32(10).string(message.skuGroup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkuGroupCondition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuGroupCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuGroup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkuGroupCondition {
    return { skuGroup: isSet(object.skuGroup) ? globalThis.String(object.skuGroup) : "" };
  },

  toJSON(message: SkuGroupCondition): unknown {
    const obj: any = {};
    if (message.skuGroup !== "") {
      obj.skuGroup = message.skuGroup;
    }
    return obj;
  },

  create(base?: DeepPartial<SkuGroupCondition>): SkuGroupCondition {
    return SkuGroupCondition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkuGroupCondition>): SkuGroupCondition {
    const message = createBaseSkuGroupCondition();
    message.skuGroup = object.skuGroup ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
