// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/gkebackup/logging/v1/logging.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { Status } from "../../../../rpc/status.js";
import { LoggedBackup } from "./logged_backup.js";
import { LoggedBackupPlan } from "./logged_backup_plan.js";
import { LoggedRestore } from "./logged_restore.js";
import { LoggedRestorePlan } from "./logged_restore_plan.js";

export const protobufPackage = "google.cloud.gkebackup.logging.v1";

/** The type of changes this log is about. */
export enum ChangeType {
  /** CHANGE_TYPE_UNSPECIFIED - Default value, not specified. */
  CHANGE_TYPE_UNSPECIFIED = 0,
  /** CREATION - The resource is created. */
  CREATION = 1,
  /** UPDATE - The resource is updated. */
  UPDATE = 2,
  /** DELETION - The resource is deleted. */
  DELETION = 3,
  UNRECOGNIZED = -1,
}

export function changeTypeFromJSON(object: any): ChangeType {
  switch (object) {
    case 0:
    case "CHANGE_TYPE_UNSPECIFIED":
      return ChangeType.CHANGE_TYPE_UNSPECIFIED;
    case 1:
    case "CREATION":
      return ChangeType.CREATION;
    case 2:
    case "UPDATE":
      return ChangeType.UPDATE;
    case 3:
    case "DELETION":
      return ChangeType.DELETION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChangeType.UNRECOGNIZED;
  }
}

export function changeTypeToJSON(object: ChangeType): string {
  switch (object) {
    case ChangeType.CHANGE_TYPE_UNSPECIFIED:
      return "CHANGE_TYPE_UNSPECIFIED";
    case ChangeType.CREATION:
      return "CREATION";
    case ChangeType.UPDATE:
      return "UPDATE";
    case ChangeType.DELETION:
      return "DELETION";
    case ChangeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * use case 1
 * A log entry when modification(creation, update, deletion) is made to a
 * BackupPlan
 */
export interface BackupPlanChange {
  /**
   * The full name of the old BackupPlan resource that is being modified.
   * Empty for creation.
   * Format: projects/{project}/locations/{location}/backupPlans/{backup_plan}
   */
  backupPlan: string;
  /** Type of the change is being made. */
  changeType: ChangeType;
  /** Modification details. */
  updateMask:
    | string[]
    | undefined;
  /**
   * The input BackupPlan resource with the updated fields populated to update
   * the source BackupPlan to.
   */
  inputBackupPlan:
    | LoggedBackupPlan
    | undefined;
  /** The error code and message. */
  error: Status | undefined;
}

/**
 * use case 2
 * A log entry when modification(creation, update, deletion) is made to a
 * Backup
 */
export interface BackupChange {
  /**
   * The full name of the Backup resource that is being modified.
   * Format:
   * projects/{project}/locations/{location}/backupPlans/{backup_plan}/backups/{backup}
   */
  backup: string;
  /** Type of the change is being made. */
  changeType: ChangeType;
  /** Whether the change is made manually or automatically. */
  scheduled: boolean;
  /** Modification details. */
  updateMask:
    | string[]
    | undefined;
  /**
   * The input Backup resource with the updated fields populated to update
   * the source Backup to, or the backup created automatically from retention
   * policy.
   */
  inputBackup:
    | LoggedBackup
    | undefined;
  /** The error code and message. */
  error: Status | undefined;
}

/**
 * use case 3
 * A log entry when modification(creation, update, deletion) is made to a
 * restorePlan.
 */
export interface RestorePlanChange {
  /**
   * The full name of the RestorePlan resource that is being modified.
   * Empty for creation.
   * Format: projects/* /locations/* /restorePlans/*
   */
  restorePlan: string;
  /** Type of the change is being made. */
  changeType: ChangeType;
  /** Modification details. */
  updateMask:
    | string[]
    | undefined;
  /**
   * The input RestorePlan resource with the updated fields populated to update
   * the source RestorePlan to.
   */
  inputRestorePlan:
    | LoggedRestorePlan
    | undefined;
  /** The error code and message. */
  error: Status | undefined;
}

/**
 * use case 4
 * A log entry when modification(creation, update, deletion) is made to a
 * restore.
 */
export interface RestoreChange {
  /**
   * The full name of the Restore resource that is being modified.
   * Empty for creation.
   * Format: projects/* /locations/* /restorePlans/* /restores/*
   */
  restore: string;
  /** Type of the change is being made. */
  changeType: ChangeType;
  /** Modification details. */
  updateMask:
    | string[]
    | undefined;
  /**
   * The input Restore resource with the updated fields populated to update
   * the source Restore to.
   */
  inputRestore:
    | LoggedRestore
    | undefined;
  /** The error code and message. */
  error: Status | undefined;
}

function createBaseBackupPlanChange(): BackupPlanChange {
  return { backupPlan: "", changeType: 0, updateMask: undefined, inputBackupPlan: undefined, error: undefined };
}

export const BackupPlanChange: MessageFns<BackupPlanChange> = {
  encode(message: BackupPlanChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backupPlan !== "") {
      writer.uint32(10).string(message.backupPlan);
    }
    if (message.changeType !== 0) {
      writer.uint32(16).int32(message.changeType);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    if (message.inputBackupPlan !== undefined) {
      LoggedBackupPlan.encode(message.inputBackupPlan, writer.uint32(34).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupPlanChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupPlanChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backupPlan = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.changeType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inputBackupPlan = LoggedBackupPlan.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupPlanChange {
    return {
      backupPlan: isSet(object.backupPlan) ? globalThis.String(object.backupPlan) : "",
      changeType: isSet(object.changeType) ? changeTypeFromJSON(object.changeType) : 0,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      inputBackupPlan: isSet(object.inputBackupPlan) ? LoggedBackupPlan.fromJSON(object.inputBackupPlan) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: BackupPlanChange): unknown {
    const obj: any = {};
    if (message.backupPlan !== "") {
      obj.backupPlan = message.backupPlan;
    }
    if (message.changeType !== 0) {
      obj.changeType = changeTypeToJSON(message.changeType);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.inputBackupPlan !== undefined) {
      obj.inputBackupPlan = LoggedBackupPlan.toJSON(message.inputBackupPlan);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<BackupPlanChange>): BackupPlanChange {
    return BackupPlanChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupPlanChange>): BackupPlanChange {
    const message = createBaseBackupPlanChange();
    message.backupPlan = object.backupPlan ?? "";
    message.changeType = object.changeType ?? 0;
    message.updateMask = object.updateMask ?? undefined;
    message.inputBackupPlan = (object.inputBackupPlan !== undefined && object.inputBackupPlan !== null)
      ? LoggedBackupPlan.fromPartial(object.inputBackupPlan)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseBackupChange(): BackupChange {
  return {
    backup: "",
    changeType: 0,
    scheduled: false,
    updateMask: undefined,
    inputBackup: undefined,
    error: undefined,
  };
}

export const BackupChange: MessageFns<BackupChange> = {
  encode(message: BackupChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backup !== "") {
      writer.uint32(10).string(message.backup);
    }
    if (message.changeType !== 0) {
      writer.uint32(16).int32(message.changeType);
    }
    if (message.scheduled !== false) {
      writer.uint32(24).bool(message.scheduled);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(34).fork()).join();
    }
    if (message.inputBackup !== undefined) {
      LoggedBackup.encode(message.inputBackup, writer.uint32(42).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backup = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.changeType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.scheduled = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.inputBackup = LoggedBackup.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupChange {
    return {
      backup: isSet(object.backup) ? globalThis.String(object.backup) : "",
      changeType: isSet(object.changeType) ? changeTypeFromJSON(object.changeType) : 0,
      scheduled: isSet(object.scheduled) ? globalThis.Boolean(object.scheduled) : false,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      inputBackup: isSet(object.inputBackup) ? LoggedBackup.fromJSON(object.inputBackup) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: BackupChange): unknown {
    const obj: any = {};
    if (message.backup !== "") {
      obj.backup = message.backup;
    }
    if (message.changeType !== 0) {
      obj.changeType = changeTypeToJSON(message.changeType);
    }
    if (message.scheduled !== false) {
      obj.scheduled = message.scheduled;
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.inputBackup !== undefined) {
      obj.inputBackup = LoggedBackup.toJSON(message.inputBackup);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<BackupChange>): BackupChange {
    return BackupChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupChange>): BackupChange {
    const message = createBaseBackupChange();
    message.backup = object.backup ?? "";
    message.changeType = object.changeType ?? 0;
    message.scheduled = object.scheduled ?? false;
    message.updateMask = object.updateMask ?? undefined;
    message.inputBackup = (object.inputBackup !== undefined && object.inputBackup !== null)
      ? LoggedBackup.fromPartial(object.inputBackup)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseRestorePlanChange(): RestorePlanChange {
  return { restorePlan: "", changeType: 0, updateMask: undefined, inputRestorePlan: undefined, error: undefined };
}

export const RestorePlanChange: MessageFns<RestorePlanChange> = {
  encode(message: RestorePlanChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.restorePlan !== "") {
      writer.uint32(10).string(message.restorePlan);
    }
    if (message.changeType !== 0) {
      writer.uint32(16).int32(message.changeType);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    if (message.inputRestorePlan !== undefined) {
      LoggedRestorePlan.encode(message.inputRestorePlan, writer.uint32(34).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestorePlanChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestorePlanChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.restorePlan = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.changeType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inputRestorePlan = LoggedRestorePlan.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestorePlanChange {
    return {
      restorePlan: isSet(object.restorePlan) ? globalThis.String(object.restorePlan) : "",
      changeType: isSet(object.changeType) ? changeTypeFromJSON(object.changeType) : 0,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      inputRestorePlan: isSet(object.inputRestorePlan)
        ? LoggedRestorePlan.fromJSON(object.inputRestorePlan)
        : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: RestorePlanChange): unknown {
    const obj: any = {};
    if (message.restorePlan !== "") {
      obj.restorePlan = message.restorePlan;
    }
    if (message.changeType !== 0) {
      obj.changeType = changeTypeToJSON(message.changeType);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.inputRestorePlan !== undefined) {
      obj.inputRestorePlan = LoggedRestorePlan.toJSON(message.inputRestorePlan);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<RestorePlanChange>): RestorePlanChange {
    return RestorePlanChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestorePlanChange>): RestorePlanChange {
    const message = createBaseRestorePlanChange();
    message.restorePlan = object.restorePlan ?? "";
    message.changeType = object.changeType ?? 0;
    message.updateMask = object.updateMask ?? undefined;
    message.inputRestorePlan = (object.inputRestorePlan !== undefined && object.inputRestorePlan !== null)
      ? LoggedRestorePlan.fromPartial(object.inputRestorePlan)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseRestoreChange(): RestoreChange {
  return { restore: "", changeType: 0, updateMask: undefined, inputRestore: undefined, error: undefined };
}

export const RestoreChange: MessageFns<RestoreChange> = {
  encode(message: RestoreChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.restore !== "") {
      writer.uint32(10).string(message.restore);
    }
    if (message.changeType !== 0) {
      writer.uint32(16).int32(message.changeType);
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    if (message.inputRestore !== undefined) {
      LoggedRestore.encode(message.inputRestore, writer.uint32(34).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.restore = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.changeType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.inputRestore = LoggedRestore.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreChange {
    return {
      restore: isSet(object.restore) ? globalThis.String(object.restore) : "",
      changeType: isSet(object.changeType) ? changeTypeFromJSON(object.changeType) : 0,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      inputRestore: isSet(object.inputRestore) ? LoggedRestore.fromJSON(object.inputRestore) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: RestoreChange): unknown {
    const obj: any = {};
    if (message.restore !== "") {
      obj.restore = message.restore;
    }
    if (message.changeType !== 0) {
      obj.changeType = changeTypeToJSON(message.changeType);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.inputRestore !== undefined) {
      obj.inputRestore = LoggedRestore.toJSON(message.inputRestore);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<RestoreChange>): RestoreChange {
    return RestoreChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestoreChange>): RestoreChange {
    const message = createBaseRestoreChange();
    message.restore = object.restore ?? "";
    message.changeType = object.changeType ?? 0;
    message.updateMask = object.updateMask ?? undefined;
    message.inputRestore = (object.inputRestore !== undefined && object.inputRestore !== null)
      ? LoggedRestore.fromPartial(object.inputRestore)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
