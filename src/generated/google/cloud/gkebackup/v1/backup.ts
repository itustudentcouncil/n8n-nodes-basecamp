// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/gkebackup/v1/backup.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { EncryptionKey, NamespacedNames, Namespaces } from "./common.js";

export const protobufPackage = "google.cloud.gkebackup.v1";

/**
 * Represents a request to perform a single point-in-time capture of
 * some portion of the state of a GKE cluster, the record of the backup
 * operation itself, and an anchor for the underlying artifacts that
 * comprise the Backup (the config backup and VolumeBackups).
 */
export interface Backup {
  /**
   * Output only. The fully qualified name of the Backup.
   * `projects/* /locations/* /backupPlans/* /backups/*`
   */
  name: string;
  /**
   * Output only. Server generated global unique identifier of
   * [UUID4](https://en.wikipedia.org/wiki/Universally_unique_identifier)
   */
  uid: string;
  /** Output only. The timestamp when this Backup resource was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when this Backup resource was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. This flag indicates whether this Backup resource was created
   * manually by a user or via a schedule in the BackupPlan. A value of True
   * means that the Backup was created manually.
   */
  manual: boolean;
  /** Optional. A set of custom labels supplied by user. */
  labels: { [key: string]: string };
  /**
   * Optional. Minimum age for this Backup (in days). If this field is set to a
   * non-zero value, the Backup will be "locked" against deletion (either manual
   * or automatic deletion) for the number of days provided (measured from the
   * creation time of the Backup).  MUST be an integer value between 0-90
   * (inclusive).
   *
   * Defaults to parent BackupPlan's
   * [backup_delete_lock_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_delete_lock_days]
   * setting and may only be increased
   * (either at creation time or in a subsequent update).
   */
  deleteLockDays: number;
  /**
   * Output only. The time at which an existing delete lock will expire for this
   * backup (calculated from create_time +
   * [delete_lock_days][google.cloud.gkebackup.v1.Backup.delete_lock_days]).
   */
  deleteLockExpireTime:
    | Date
    | undefined;
  /**
   * Optional. The age (in days) after which this Backup will be automatically
   * deleted. Must be an integer value >= 0:
   *
   * - If 0, no automatic deletion will occur for this Backup.
   * - If not 0, this must be >=
   * [delete_lock_days][google.cloud.gkebackup.v1.Backup.delete_lock_days] and
   * <= 365.
   *
   * Once a Backup is created, this value may only be increased.
   *
   * Defaults to the parent BackupPlan's
   * [backup_retain_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_retain_days]
   * value.
   */
  retainDays: number;
  /**
   * Output only. The time at which this Backup will be automatically deleted
   * (calculated from create_time +
   * [retain_days][google.cloud.gkebackup.v1.Backup.retain_days]).
   */
  retainExpireTime:
    | Date
    | undefined;
  /**
   * Output only. The customer managed encryption key that was used to encrypt
   * the Backup's artifacts.  Inherited from the parent BackupPlan's
   * [encryption_key][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.encryption_key]
   * value.
   */
  encryptionKey:
    | EncryptionKey
    | undefined;
  /** Output only. If True, all namespaces were included in the Backup. */
  allNamespaces?:
    | boolean
    | undefined;
  /**
   * Output only. If set, the list of namespaces that were included in the
   * Backup.
   */
  selectedNamespaces?:
    | Namespaces
    | undefined;
  /**
   * Output only. If set, the list of ProtectedApplications whose resources
   * were included in the Backup.
   */
  selectedApplications?:
    | NamespacedNames
    | undefined;
  /**
   * Output only. Whether or not the Backup contains volume data.  Controlled by
   * the parent BackupPlan's
   * [include_volume_data][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.include_volume_data]
   * value.
   */
  containsVolumeData: boolean;
  /**
   * Output only. Whether or not the Backup contains Kubernetes Secrets.
   * Controlled by the parent BackupPlan's
   * [include_secrets][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.include_secrets]
   * value.
   */
  containsSecrets: boolean;
  /**
   * Output only. Information about the GKE cluster from which this Backup was
   * created.
   */
  clusterMetadata:
    | Backup_ClusterMetadata
    | undefined;
  /** Output only. Current state of the Backup */
  state: Backup_State;
  /**
   * Output only. Human-readable description of why the backup is in the current
   * `state`.
   */
  stateReason: string;
  /** Output only. Completion time of the Backup */
  completeTime:
    | Date
    | undefined;
  /**
   * Output only. The total number of Kubernetes resources included in the
   * Backup.
   */
  resourceCount: number;
  /** Output only. The total number of volume backups contained in the Backup. */
  volumeCount: number;
  /**
   * Output only. The total size of the Backup in bytes = config backup size +
   * sum(volume backup sizes)
   */
  sizeBytes: Long;
  /**
   * Output only. `etag` is used for optimistic concurrency control as a way to
   * help prevent simultaneous updates of a backup from overwriting each other.
   * It is strongly suggested that systems make use of the `etag` in the
   * read-modify-write cycle to perform backup updates in order to avoid
   * race conditions: An `etag` is returned in the response to `GetBackup`,
   * and systems are expected to put that etag in the request to
   * `UpdateBackup` or `DeleteBackup` to ensure that their change will be
   * applied to the same version of the resource.
   */
  etag: string;
  /** Optional. User specified descriptive string for this Backup. */
  description: string;
  /** Output only. The total number of Kubernetes Pods contained in the Backup. */
  podCount: number;
  /** Output only. The size of the config backup in bytes. */
  configBackupSizeBytes: Long;
  /**
   * Output only. If false, Backup will fail when Backup for GKE detects
   * Kubernetes configuration that is non-standard or
   * requires additional setup to restore.
   *
   * Inherited from the parent BackupPlan's
   * [permissive_mode][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.permissive_mode]
   * value.
   */
  permissiveMode: boolean;
}

/** State */
export enum Backup_State {
  /** STATE_UNSPECIFIED - The Backup resource is in the process of being created. */
  STATE_UNSPECIFIED = 0,
  /**
   * CREATING - The Backup resource has been created and the associated BackupJob
   * Kubernetes resource has been injected into the source cluster.
   */
  CREATING = 1,
  /**
   * IN_PROGRESS - The gkebackup agent in the cluster has begun executing the backup
   * operation.
   */
  IN_PROGRESS = 2,
  /** SUCCEEDED - The backup operation has completed successfully. */
  SUCCEEDED = 3,
  /** FAILED - The backup operation has failed. */
  FAILED = 4,
  /**
   * DELETING - This Backup resource (and its associated artifacts) is in the process
   * of being deleted.
   */
  DELETING = 5,
  UNRECOGNIZED = -1,
}

export function backup_StateFromJSON(object: any): Backup_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Backup_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Backup_State.CREATING;
    case 2:
    case "IN_PROGRESS":
      return Backup_State.IN_PROGRESS;
    case 3:
    case "SUCCEEDED":
      return Backup_State.SUCCEEDED;
    case 4:
    case "FAILED":
      return Backup_State.FAILED;
    case 5:
    case "DELETING":
      return Backup_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Backup_State.UNRECOGNIZED;
  }
}

export function backup_StateToJSON(object: Backup_State): string {
  switch (object) {
    case Backup_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Backup_State.CREATING:
      return "CREATING";
    case Backup_State.IN_PROGRESS:
      return "IN_PROGRESS";
    case Backup_State.SUCCEEDED:
      return "SUCCEEDED";
    case Backup_State.FAILED:
      return "FAILED";
    case Backup_State.DELETING:
      return "DELETING";
    case Backup_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about the GKE cluster from which this Backup was created. */
export interface Backup_ClusterMetadata {
  /**
   * Output only. The source cluster from which this Backup was created.
   * Valid formats:
   *
   *   - `projects/* /locations/* /clusters/*`
   *   - `projects/* /zones/* /clusters/*`
   *
   * This is inherited from the parent BackupPlan's
   * [cluster][google.cloud.gkebackup.v1.BackupPlan.cluster] field.
   */
  cluster: string;
  /** Output only. The Kubernetes server version of the source cluster. */
  k8sVersion: string;
  /**
   * Output only. A list of the Backup for GKE CRD versions found in the
   * cluster.
   */
  backupCrdVersions: { [key: string]: string };
  /** Output only. GKE version */
  gkeVersion?:
    | string
    | undefined;
  /** Output only. Anthos version */
  anthosVersion?: string | undefined;
}

export interface Backup_ClusterMetadata_BackupCrdVersionsEntry {
  key: string;
  value: string;
}

export interface Backup_LabelsEntry {
  key: string;
  value: string;
}

function createBaseBackup(): Backup {
  return {
    name: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    manual: false,
    labels: {},
    deleteLockDays: 0,
    deleteLockExpireTime: undefined,
    retainDays: 0,
    retainExpireTime: undefined,
    encryptionKey: undefined,
    allNamespaces: undefined,
    selectedNamespaces: undefined,
    selectedApplications: undefined,
    containsVolumeData: false,
    containsSecrets: false,
    clusterMetadata: undefined,
    state: 0,
    stateReason: "",
    completeTime: undefined,
    resourceCount: 0,
    volumeCount: 0,
    sizeBytes: Long.ZERO,
    etag: "",
    description: "",
    podCount: 0,
    configBackupSizeBytes: Long.ZERO,
    permissiveMode: false,
  };
}

export const Backup: MessageFns<Backup> = {
  encode(message: Backup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.manual !== false) {
      writer.uint32(40).bool(message.manual);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Backup_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.deleteLockDays !== 0) {
      writer.uint32(56).int32(message.deleteLockDays);
    }
    if (message.deleteLockExpireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteLockExpireTime), writer.uint32(66).fork()).join();
    }
    if (message.retainDays !== 0) {
      writer.uint32(72).int32(message.retainDays);
    }
    if (message.retainExpireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.retainExpireTime), writer.uint32(82).fork()).join();
    }
    if (message.encryptionKey !== undefined) {
      EncryptionKey.encode(message.encryptionKey, writer.uint32(90).fork()).join();
    }
    if (message.allNamespaces !== undefined) {
      writer.uint32(96).bool(message.allNamespaces);
    }
    if (message.selectedNamespaces !== undefined) {
      Namespaces.encode(message.selectedNamespaces, writer.uint32(106).fork()).join();
    }
    if (message.selectedApplications !== undefined) {
      NamespacedNames.encode(message.selectedApplications, writer.uint32(114).fork()).join();
    }
    if (message.containsVolumeData !== false) {
      writer.uint32(120).bool(message.containsVolumeData);
    }
    if (message.containsSecrets !== false) {
      writer.uint32(128).bool(message.containsSecrets);
    }
    if (message.clusterMetadata !== undefined) {
      Backup_ClusterMetadata.encode(message.clusterMetadata, writer.uint32(138).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(144).int32(message.state);
    }
    if (message.stateReason !== "") {
      writer.uint32(154).string(message.stateReason);
    }
    if (message.completeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.completeTime), writer.uint32(162).fork()).join();
    }
    if (message.resourceCount !== 0) {
      writer.uint32(168).int32(message.resourceCount);
    }
    if (message.volumeCount !== 0) {
      writer.uint32(176).int32(message.volumeCount);
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      writer.uint32(184).int64(message.sizeBytes.toString());
    }
    if (message.etag !== "") {
      writer.uint32(194).string(message.etag);
    }
    if (message.description !== "") {
      writer.uint32(202).string(message.description);
    }
    if (message.podCount !== 0) {
      writer.uint32(208).int32(message.podCount);
    }
    if (!message.configBackupSizeBytes.equals(Long.ZERO)) {
      writer.uint32(216).int64(message.configBackupSizeBytes.toString());
    }
    if (message.permissiveMode !== false) {
      writer.uint32(224).bool(message.permissiveMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Backup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.manual = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = Backup_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.deleteLockDays = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.deleteLockExpireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.retainDays = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.retainExpireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.encryptionKey = EncryptionKey.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.allNamespaces = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.selectedNamespaces = Namespaces.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.selectedApplications = NamespacedNames.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.containsVolumeData = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.containsSecrets = reader.bool();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.clusterMetadata = Backup_ClusterMetadata.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.stateReason = reader.string();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.completeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.resourceCount = reader.int32();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.volumeCount = reader.int32();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.sizeBytes = Long.fromString(reader.int64().toString());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.description = reader.string();
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.podCount = reader.int32();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.configBackupSizeBytes = Long.fromString(reader.int64().toString());
          continue;
        case 28:
          if (tag !== 224) {
            break;
          }

          message.permissiveMode = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Backup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      manual: isSet(object.manual) ? globalThis.Boolean(object.manual) : false,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      deleteLockDays: isSet(object.deleteLockDays) ? globalThis.Number(object.deleteLockDays) : 0,
      deleteLockExpireTime: isSet(object.deleteLockExpireTime)
        ? fromJsonTimestamp(object.deleteLockExpireTime)
        : undefined,
      retainDays: isSet(object.retainDays) ? globalThis.Number(object.retainDays) : 0,
      retainExpireTime: isSet(object.retainExpireTime) ? fromJsonTimestamp(object.retainExpireTime) : undefined,
      encryptionKey: isSet(object.encryptionKey) ? EncryptionKey.fromJSON(object.encryptionKey) : undefined,
      allNamespaces: isSet(object.allNamespaces) ? globalThis.Boolean(object.allNamespaces) : undefined,
      selectedNamespaces: isSet(object.selectedNamespaces) ? Namespaces.fromJSON(object.selectedNamespaces) : undefined,
      selectedApplications: isSet(object.selectedApplications)
        ? NamespacedNames.fromJSON(object.selectedApplications)
        : undefined,
      containsVolumeData: isSet(object.containsVolumeData) ? globalThis.Boolean(object.containsVolumeData) : false,
      containsSecrets: isSet(object.containsSecrets) ? globalThis.Boolean(object.containsSecrets) : false,
      clusterMetadata: isSet(object.clusterMetadata)
        ? Backup_ClusterMetadata.fromJSON(object.clusterMetadata)
        : undefined,
      state: isSet(object.state) ? backup_StateFromJSON(object.state) : 0,
      stateReason: isSet(object.stateReason) ? globalThis.String(object.stateReason) : "",
      completeTime: isSet(object.completeTime) ? fromJsonTimestamp(object.completeTime) : undefined,
      resourceCount: isSet(object.resourceCount) ? globalThis.Number(object.resourceCount) : 0,
      volumeCount: isSet(object.volumeCount) ? globalThis.Number(object.volumeCount) : 0,
      sizeBytes: isSet(object.sizeBytes) ? Long.fromValue(object.sizeBytes) : Long.ZERO,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      podCount: isSet(object.podCount) ? globalThis.Number(object.podCount) : 0,
      configBackupSizeBytes: isSet(object.configBackupSizeBytes)
        ? Long.fromValue(object.configBackupSizeBytes)
        : Long.ZERO,
      permissiveMode: isSet(object.permissiveMode) ? globalThis.Boolean(object.permissiveMode) : false,
    };
  },

  toJSON(message: Backup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.manual !== false) {
      obj.manual = message.manual;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.deleteLockDays !== 0) {
      obj.deleteLockDays = Math.round(message.deleteLockDays);
    }
    if (message.deleteLockExpireTime !== undefined) {
      obj.deleteLockExpireTime = message.deleteLockExpireTime.toISOString();
    }
    if (message.retainDays !== 0) {
      obj.retainDays = Math.round(message.retainDays);
    }
    if (message.retainExpireTime !== undefined) {
      obj.retainExpireTime = message.retainExpireTime.toISOString();
    }
    if (message.encryptionKey !== undefined) {
      obj.encryptionKey = EncryptionKey.toJSON(message.encryptionKey);
    }
    if (message.allNamespaces !== undefined) {
      obj.allNamespaces = message.allNamespaces;
    }
    if (message.selectedNamespaces !== undefined) {
      obj.selectedNamespaces = Namespaces.toJSON(message.selectedNamespaces);
    }
    if (message.selectedApplications !== undefined) {
      obj.selectedApplications = NamespacedNames.toJSON(message.selectedApplications);
    }
    if (message.containsVolumeData !== false) {
      obj.containsVolumeData = message.containsVolumeData;
    }
    if (message.containsSecrets !== false) {
      obj.containsSecrets = message.containsSecrets;
    }
    if (message.clusterMetadata !== undefined) {
      obj.clusterMetadata = Backup_ClusterMetadata.toJSON(message.clusterMetadata);
    }
    if (message.state !== 0) {
      obj.state = backup_StateToJSON(message.state);
    }
    if (message.stateReason !== "") {
      obj.stateReason = message.stateReason;
    }
    if (message.completeTime !== undefined) {
      obj.completeTime = message.completeTime.toISOString();
    }
    if (message.resourceCount !== 0) {
      obj.resourceCount = Math.round(message.resourceCount);
    }
    if (message.volumeCount !== 0) {
      obj.volumeCount = Math.round(message.volumeCount);
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      obj.sizeBytes = (message.sizeBytes || Long.ZERO).toString();
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.podCount !== 0) {
      obj.podCount = Math.round(message.podCount);
    }
    if (!message.configBackupSizeBytes.equals(Long.ZERO)) {
      obj.configBackupSizeBytes = (message.configBackupSizeBytes || Long.ZERO).toString();
    }
    if (message.permissiveMode !== false) {
      obj.permissiveMode = message.permissiveMode;
    }
    return obj;
  },

  create(base?: DeepPartial<Backup>): Backup {
    return Backup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Backup>): Backup {
    const message = createBaseBackup();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.manual = object.manual ?? false;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.deleteLockDays = object.deleteLockDays ?? 0;
    message.deleteLockExpireTime = object.deleteLockExpireTime ?? undefined;
    message.retainDays = object.retainDays ?? 0;
    message.retainExpireTime = object.retainExpireTime ?? undefined;
    message.encryptionKey = (object.encryptionKey !== undefined && object.encryptionKey !== null)
      ? EncryptionKey.fromPartial(object.encryptionKey)
      : undefined;
    message.allNamespaces = object.allNamespaces ?? undefined;
    message.selectedNamespaces = (object.selectedNamespaces !== undefined && object.selectedNamespaces !== null)
      ? Namespaces.fromPartial(object.selectedNamespaces)
      : undefined;
    message.selectedApplications = (object.selectedApplications !== undefined && object.selectedApplications !== null)
      ? NamespacedNames.fromPartial(object.selectedApplications)
      : undefined;
    message.containsVolumeData = object.containsVolumeData ?? false;
    message.containsSecrets = object.containsSecrets ?? false;
    message.clusterMetadata = (object.clusterMetadata !== undefined && object.clusterMetadata !== null)
      ? Backup_ClusterMetadata.fromPartial(object.clusterMetadata)
      : undefined;
    message.state = object.state ?? 0;
    message.stateReason = object.stateReason ?? "";
    message.completeTime = object.completeTime ?? undefined;
    message.resourceCount = object.resourceCount ?? 0;
    message.volumeCount = object.volumeCount ?? 0;
    message.sizeBytes = (object.sizeBytes !== undefined && object.sizeBytes !== null)
      ? Long.fromValue(object.sizeBytes)
      : Long.ZERO;
    message.etag = object.etag ?? "";
    message.description = object.description ?? "";
    message.podCount = object.podCount ?? 0;
    message.configBackupSizeBytes =
      (object.configBackupSizeBytes !== undefined && object.configBackupSizeBytes !== null)
        ? Long.fromValue(object.configBackupSizeBytes)
        : Long.ZERO;
    message.permissiveMode = object.permissiveMode ?? false;
    return message;
  },
};

function createBaseBackup_ClusterMetadata(): Backup_ClusterMetadata {
  return { cluster: "", k8sVersion: "", backupCrdVersions: {}, gkeVersion: undefined, anthosVersion: undefined };
}

export const Backup_ClusterMetadata: MessageFns<Backup_ClusterMetadata> = {
  encode(message: Backup_ClusterMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== "") {
      writer.uint32(10).string(message.cluster);
    }
    if (message.k8sVersion !== "") {
      writer.uint32(18).string(message.k8sVersion);
    }
    Object.entries(message.backupCrdVersions).forEach(([key, value]) => {
      Backup_ClusterMetadata_BackupCrdVersionsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.gkeVersion !== undefined) {
      writer.uint32(34).string(message.gkeVersion);
    }
    if (message.anthosVersion !== undefined) {
      writer.uint32(42).string(message.anthosVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Backup_ClusterMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackup_ClusterMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cluster = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.k8sVersion = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Backup_ClusterMetadata_BackupCrdVersionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.backupCrdVersions[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gkeVersion = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.anthosVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Backup_ClusterMetadata {
    return {
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      k8sVersion: isSet(object.k8sVersion) ? globalThis.String(object.k8sVersion) : "",
      backupCrdVersions: isObject(object.backupCrdVersions)
        ? Object.entries(object.backupCrdVersions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      gkeVersion: isSet(object.gkeVersion) ? globalThis.String(object.gkeVersion) : undefined,
      anthosVersion: isSet(object.anthosVersion) ? globalThis.String(object.anthosVersion) : undefined,
    };
  },

  toJSON(message: Backup_ClusterMetadata): unknown {
    const obj: any = {};
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.k8sVersion !== "") {
      obj.k8sVersion = message.k8sVersion;
    }
    if (message.backupCrdVersions) {
      const entries = Object.entries(message.backupCrdVersions);
      if (entries.length > 0) {
        obj.backupCrdVersions = {};
        entries.forEach(([k, v]) => {
          obj.backupCrdVersions[k] = v;
        });
      }
    }
    if (message.gkeVersion !== undefined) {
      obj.gkeVersion = message.gkeVersion;
    }
    if (message.anthosVersion !== undefined) {
      obj.anthosVersion = message.anthosVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Backup_ClusterMetadata>): Backup_ClusterMetadata {
    return Backup_ClusterMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Backup_ClusterMetadata>): Backup_ClusterMetadata {
    const message = createBaseBackup_ClusterMetadata();
    message.cluster = object.cluster ?? "";
    message.k8sVersion = object.k8sVersion ?? "";
    message.backupCrdVersions = Object.entries(object.backupCrdVersions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.gkeVersion = object.gkeVersion ?? undefined;
    message.anthosVersion = object.anthosVersion ?? undefined;
    return message;
  },
};

function createBaseBackup_ClusterMetadata_BackupCrdVersionsEntry(): Backup_ClusterMetadata_BackupCrdVersionsEntry {
  return { key: "", value: "" };
}

export const Backup_ClusterMetadata_BackupCrdVersionsEntry: MessageFns<Backup_ClusterMetadata_BackupCrdVersionsEntry> =
  {
    encode(
      message: Backup_ClusterMetadata_BackupCrdVersionsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): Backup_ClusterMetadata_BackupCrdVersionsEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseBackup_ClusterMetadata_BackupCrdVersionsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): Backup_ClusterMetadata_BackupCrdVersionsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: Backup_ClusterMetadata_BackupCrdVersionsEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },

    create(
      base?: DeepPartial<Backup_ClusterMetadata_BackupCrdVersionsEntry>,
    ): Backup_ClusterMetadata_BackupCrdVersionsEntry {
      return Backup_ClusterMetadata_BackupCrdVersionsEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<Backup_ClusterMetadata_BackupCrdVersionsEntry>,
    ): Backup_ClusterMetadata_BackupCrdVersionsEntry {
      const message = createBaseBackup_ClusterMetadata_BackupCrdVersionsEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? "";
      return message;
    },
  };

function createBaseBackup_LabelsEntry(): Backup_LabelsEntry {
  return { key: "", value: "" };
}

export const Backup_LabelsEntry: MessageFns<Backup_LabelsEntry> = {
  encode(message: Backup_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Backup_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackup_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Backup_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Backup_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Backup_LabelsEntry>): Backup_LabelsEntry {
    return Backup_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Backup_LabelsEntry>): Backup_LabelsEntry {
    const message = createBaseBackup_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
