// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/gkebackup/v1/backup_plan.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DateMessage } from "../../../type/date.js";
import { DayOfWeek, dayOfWeekFromJSON, dayOfWeekToJSON } from "../../../type/dayofweek.js";
import { TimeOfDay } from "../../../type/timeofday.js";
import { EncryptionKey, NamespacedNames, Namespaces } from "./common.js";

export const protobufPackage = "google.cloud.gkebackup.v1";

/** Defines the configuration and scheduling for a "line" of Backups. */
export interface BackupPlan {
  /**
   * Output only. The full name of the BackupPlan resource.
   * Format: `projects/* /locations/* /backupPlans/*`
   */
  name: string;
  /**
   * Output only. Server generated global unique identifier of
   * [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
   */
  uid: string;
  /** Output only. The timestamp when this BackupPlan resource was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The timestamp when this BackupPlan resource was last
   * updated.
   */
  updateTime:
    | Date
    | undefined;
  /** Optional. User specified descriptive string for this BackupPlan. */
  description: string;
  /**
   * Required. Immutable. The source cluster from which Backups will be created
   * via this BackupPlan. Valid formats:
   *
   * - `projects/* /locations/* /clusters/*`
   * - `projects/* /zones/* /clusters/*`
   */
  cluster: string;
  /**
   * Optional. RetentionPolicy governs lifecycle of Backups created under this
   * plan.
   */
  retentionPolicy:
    | BackupPlan_RetentionPolicy
    | undefined;
  /** Optional. A set of custom labels supplied by user. */
  labels: { [key: string]: string };
  /**
   * Optional. Defines a schedule for automatic Backup creation via this
   * BackupPlan.
   */
  backupSchedule:
    | BackupPlan_Schedule
    | undefined;
  /**
   * Output only. `etag` is used for optimistic concurrency control as a way to
   * help prevent simultaneous updates of a backup plan from overwriting each
   * other. It is strongly suggested that systems make use of the 'etag' in the
   * read-modify-write cycle to perform BackupPlan updates in order to avoid
   * race conditions: An `etag` is returned in the response to `GetBackupPlan`,
   * and systems are expected to put that etag in the request to
   * `UpdateBackupPlan` or `DeleteBackupPlan` to ensure that their change
   * will be applied to the same version of the resource.
   */
  etag: string;
  /**
   * Optional. This flag indicates whether this BackupPlan has been deactivated.
   * Setting this field to True locks the BackupPlan such that no further
   * updates will be allowed (except deletes), including the deactivated field
   * itself. It also prevents any new Backups from being created via this
   * BackupPlan (including scheduled Backups).
   *
   * Default: False
   */
  deactivated: boolean;
  /** Optional. Defines the configuration of Backups created via this BackupPlan. */
  backupConfig:
    | BackupPlan_BackupConfig
    | undefined;
  /**
   * Output only. The number of Kubernetes Pods backed up in the
   * last successful Backup created via this BackupPlan.
   */
  protectedPodCount: number;
  /**
   * Output only. State of the BackupPlan. This State field reflects the
   * various stages a BackupPlan can be in
   * during the Create operation. It will be set to "DEACTIVATED"
   * if the BackupPlan is deactivated on an Update
   */
  state: BackupPlan_State;
  /**
   * Output only. Human-readable description of why BackupPlan is in the current
   * `state`
   */
  stateReason: string;
  /**
   * Output only. A number that represents the current risk level of this
   * BackupPlan from RPO perspective with 1 being no risk and 5 being highest
   * risk.
   */
  rpoRiskLevel: number;
  /**
   * Output only. Human-readable description of why the BackupPlan is in the
   * current rpo_risk_level and action items if any.
   */
  rpoRiskReason: string;
}

/** State */
export enum BackupPlan_State {
  /** STATE_UNSPECIFIED - Default first value for Enums. */
  STATE_UNSPECIFIED = 0,
  /** CLUSTER_PENDING - Waiting for cluster state to be RUNNING. */
  CLUSTER_PENDING = 1,
  /** PROVISIONING - The BackupPlan is in the process of being created. */
  PROVISIONING = 2,
  /** READY - The BackupPlan has successfully been created and is ready for Backups. */
  READY = 3,
  /** FAILED - BackupPlan creation has failed. */
  FAILED = 4,
  /** DEACTIVATED - The BackupPlan has been deactivated. */
  DEACTIVATED = 5,
  /** DELETING - The BackupPlan is in the process of being deleted. */
  DELETING = 6,
  UNRECOGNIZED = -1,
}

export function backupPlan_StateFromJSON(object: any): BackupPlan_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return BackupPlan_State.STATE_UNSPECIFIED;
    case 1:
    case "CLUSTER_PENDING":
      return BackupPlan_State.CLUSTER_PENDING;
    case 2:
    case "PROVISIONING":
      return BackupPlan_State.PROVISIONING;
    case 3:
    case "READY":
      return BackupPlan_State.READY;
    case 4:
    case "FAILED":
      return BackupPlan_State.FAILED;
    case 5:
    case "DEACTIVATED":
      return BackupPlan_State.DEACTIVATED;
    case 6:
    case "DELETING":
      return BackupPlan_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackupPlan_State.UNRECOGNIZED;
  }
}

export function backupPlan_StateToJSON(object: BackupPlan_State): string {
  switch (object) {
    case BackupPlan_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case BackupPlan_State.CLUSTER_PENDING:
      return "CLUSTER_PENDING";
    case BackupPlan_State.PROVISIONING:
      return "PROVISIONING";
    case BackupPlan_State.READY:
      return "READY";
    case BackupPlan_State.FAILED:
      return "FAILED";
    case BackupPlan_State.DEACTIVATED:
      return "DEACTIVATED";
    case BackupPlan_State.DELETING:
      return "DELETING";
    case BackupPlan_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** RetentionPolicy defines a Backup retention policy for a BackupPlan. */
export interface BackupPlan_RetentionPolicy {
  /**
   * Optional. Minimum age for Backups created via this BackupPlan (in days).
   * This field MUST be an integer value between 0-90 (inclusive).
   * A Backup created under this BackupPlan will NOT be deletable until it
   * reaches Backup's (create_time + backup_delete_lock_days).
   * Updating this field of a BackupPlan does NOT affect existing Backups
   * under it. Backups created AFTER a successful update will inherit
   * the new value.
   *
   * Default: 0 (no delete blocking)
   */
  backupDeleteLockDays: number;
  /**
   * Optional. The default maximum age of a Backup created via this
   * BackupPlan. This field MUST be an integer value >= 0 and <= 365. If
   * specified, a Backup created under this BackupPlan will be automatically
   * deleted after its age reaches (create_time + backup_retain_days). If not
   * specified, Backups created under this BackupPlan will NOT be subject to
   * automatic deletion. Updating this field does NOT affect existing Backups
   * under it. Backups created AFTER a successful update will automatically
   * pick up the new value. NOTE: backup_retain_days must be >=
   * [backup_delete_lock_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_delete_lock_days].
   * If
   * [cron_schedule][google.cloud.gkebackup.v1.BackupPlan.Schedule.cron_schedule]
   * is defined, then this must be
   * <= 360 * the creation interval. If
   * [rpo_config][google.cloud.gkebackup.v1.BackupPlan.Schedule.rpo_config] is
   * defined, then this must be
   * <= 360 * [target_rpo_minutes][Schedule.rpo_config.target_rpo_minutes] /
   * (1440minutes/day).
   *
   * Default: 0 (no automatic deletion)
   */
  backupRetainDays: number;
  /**
   * Optional. This flag denotes whether the retention policy of this
   * BackupPlan is locked.  If set to True, no further update is allowed on
   * this policy, including the `locked` field itself.
   *
   * Default: False
   */
  locked: boolean;
}

/**
 * Defines scheduling parameters for automatically creating Backups
 * via this BackupPlan.
 */
export interface BackupPlan_Schedule {
  /**
   * Optional. A standard [cron](https://wikipedia.com/wiki/cron) string that
   * defines a repeating schedule for creating Backups via this BackupPlan.
   * This is mutually exclusive with the
   * [rpo_config][google.cloud.gkebackup.v1.BackupPlan.Schedule.rpo_config]
   * field since at most one schedule can be defined for a BackupPlan. If this
   * is defined, then
   * [backup_retain_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_retain_days]
   * must also be defined.
   *
   * Default (empty): no automatic backup creation will occur.
   */
  cronSchedule: string;
  /**
   * Optional. This flag denotes whether automatic Backup creation is paused
   * for this BackupPlan.
   *
   * Default: False
   */
  paused: boolean;
  /**
   * Optional. Defines the RPO schedule configuration for this BackupPlan.
   * This is mutually exclusive with the
   * [cron_schedule][google.cloud.gkebackup.v1.BackupPlan.Schedule.cron_schedule]
   * field since at most one schedule can be defined for a BackupPLan. If this
   * is defined, then
   * [backup_retain_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_retain_days]
   * must also be defined.
   *
   * Default (empty): no automatic backup creation will occur.
   */
  rpoConfig:
    | RpoConfig
    | undefined;
  /**
   * Output only. Start time of next scheduled backup under this BackupPlan by
   * either cron_schedule or rpo config.
   */
  nextScheduledBackupTime: Date | undefined;
}

/**
 * BackupConfig defines the configuration of Backups created via this
 * BackupPlan.
 */
export interface BackupPlan_BackupConfig {
  /** If True, include all namespaced resources */
  allNamespaces?:
    | boolean
    | undefined;
  /** If set, include just the resources in the listed namespaces. */
  selectedNamespaces?:
    | Namespaces
    | undefined;
  /**
   * If set, include just the resources referenced by the listed
   * ProtectedApplications.
   */
  selectedApplications?:
    | NamespacedNames
    | undefined;
  /**
   * Optional. This flag specifies whether volume data should be backed up
   * when PVCs are included in the scope of a Backup.
   *
   * Default: False
   */
  includeVolumeData: boolean;
  /**
   * Optional. This flag specifies whether Kubernetes Secret resources should
   * be included when they fall into the scope of Backups.
   *
   * Default: False
   */
  includeSecrets: boolean;
  /**
   * Optional. This defines a customer managed encryption key that will be
   * used to encrypt the "config" portion (the Kubernetes resources) of
   * Backups created via this plan.
   *
   * Default (empty): Config backup artifacts will not be encrypted.
   */
  encryptionKey:
    | EncryptionKey
    | undefined;
  /**
   * Optional. If false, Backups will fail when Backup for GKE detects
   * Kubernetes configuration that is non-standard or
   * requires additional setup to restore.
   *
   * Default: False
   */
  permissiveMode: boolean;
}

export interface BackupPlan_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Defines RPO scheduling configuration for automatically creating
 * Backups via this BackupPlan.
 */
export interface RpoConfig {
  /**
   * Required. Defines the target RPO for the BackupPlan in minutes, which means
   * the target maximum data loss in time that is acceptable for this
   * BackupPlan. This must be at least 60, i.e., 1 hour, and at most 86400,
   * i.e., 60 days.
   */
  targetRpoMinutes: number;
  /**
   * Optional. User specified time windows during which backup can NOT happen
   * for this BackupPlan - backups should start and finish outside of any given
   * exclusion window. Note: backup jobs will be scheduled to start and
   * finish outside the duration of the window as much as possible, but
   * running jobs will not get canceled when it runs into the window.
   * All the time and date values in exclusion_windows entry in the API are in
   * UTC.
   * We only allow <=1 recurrence (daily or weekly) exclusion window for a
   * BackupPlan while no restriction on number of single occurrence
   * windows.
   */
  exclusionWindows: ExclusionWindow[];
}

/**
 * Defines a time window during which no backup should
 * happen. All time and date are in UTC.
 */
export interface ExclusionWindow {
  /**
   * Required. Specifies the start time of the window using time of the day in
   * UTC.
   */
  startTime:
    | TimeOfDay
    | undefined;
  /**
   * Required. Specifies duration of the window.
   * Duration must be >= 5 minutes and < (target RPO - 20 minutes).
   * Additional restrictions based on the recurrence type to allow some time for
   * backup to happen:
   * - single_occurrence_date:  no restriction, but UI may warn about this when
   * duration >= target RPO
   * - daily window: duration < 24 hours
   * - weekly window:
   *   - days of week includes all seven days of a week: duration < 24 hours
   *   - all other weekly window: duration < 168 hours (i.e., 24 * 7 hours)
   */
  duration:
    | Duration
    | undefined;
  /**
   * No recurrence. The exclusion window occurs only once and on this
   * date in UTC.
   */
  singleOccurrenceDate?:
    | DateMessage
    | undefined;
  /**
   * The exclusion window occurs every day if set to "True".
   * Specifying this field to "False" is an error.
   */
  daily?:
    | boolean
    | undefined;
  /** The exclusion window occurs on these days of each week in UTC. */
  daysOfWeek?: ExclusionWindow_DayOfWeekList | undefined;
}

/** Holds repeated DaysOfWeek values as a container. */
export interface ExclusionWindow_DayOfWeekList {
  /** Optional. A list of days of week. */
  daysOfWeek: DayOfWeek[];
}

function createBaseBackupPlan(): BackupPlan {
  return {
    name: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    description: "",
    cluster: "",
    retentionPolicy: undefined,
    labels: {},
    backupSchedule: undefined,
    etag: "",
    deactivated: false,
    backupConfig: undefined,
    protectedPodCount: 0,
    state: 0,
    stateReason: "",
    rpoRiskLevel: 0,
    rpoRiskReason: "",
  };
}

export const BackupPlan: MessageFns<BackupPlan> = {
  encode(message: BackupPlan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.cluster !== "") {
      writer.uint32(50).string(message.cluster);
    }
    if (message.retentionPolicy !== undefined) {
      BackupPlan_RetentionPolicy.encode(message.retentionPolicy, writer.uint32(58).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      BackupPlan_LabelsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.backupSchedule !== undefined) {
      BackupPlan_Schedule.encode(message.backupSchedule, writer.uint32(74).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(82).string(message.etag);
    }
    if (message.deactivated !== false) {
      writer.uint32(88).bool(message.deactivated);
    }
    if (message.backupConfig !== undefined) {
      BackupPlan_BackupConfig.encode(message.backupConfig, writer.uint32(98).fork()).join();
    }
    if (message.protectedPodCount !== 0) {
      writer.uint32(104).int32(message.protectedPodCount);
    }
    if (message.state !== 0) {
      writer.uint32(112).int32(message.state);
    }
    if (message.stateReason !== "") {
      writer.uint32(122).string(message.stateReason);
    }
    if (message.rpoRiskLevel !== 0) {
      writer.uint32(128).int32(message.rpoRiskLevel);
    }
    if (message.rpoRiskReason !== "") {
      writer.uint32(138).string(message.rpoRiskReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupPlan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupPlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cluster = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.retentionPolicy = BackupPlan_RetentionPolicy.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = BackupPlan_LabelsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.labels[entry8.key] = entry8.value;
          }
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.backupSchedule = BackupPlan_Schedule.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.deactivated = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.backupConfig = BackupPlan_BackupConfig.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.protectedPodCount = reader.int32();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.stateReason = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.rpoRiskLevel = reader.int32();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.rpoRiskReason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupPlan {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      cluster: isSet(object.cluster) ? globalThis.String(object.cluster) : "",
      retentionPolicy: isSet(object.retentionPolicy)
        ? BackupPlan_RetentionPolicy.fromJSON(object.retentionPolicy)
        : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      backupSchedule: isSet(object.backupSchedule) ? BackupPlan_Schedule.fromJSON(object.backupSchedule) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      deactivated: isSet(object.deactivated) ? globalThis.Boolean(object.deactivated) : false,
      backupConfig: isSet(object.backupConfig) ? BackupPlan_BackupConfig.fromJSON(object.backupConfig) : undefined,
      protectedPodCount: isSet(object.protectedPodCount) ? globalThis.Number(object.protectedPodCount) : 0,
      state: isSet(object.state) ? backupPlan_StateFromJSON(object.state) : 0,
      stateReason: isSet(object.stateReason) ? globalThis.String(object.stateReason) : "",
      rpoRiskLevel: isSet(object.rpoRiskLevel) ? globalThis.Number(object.rpoRiskLevel) : 0,
      rpoRiskReason: isSet(object.rpoRiskReason) ? globalThis.String(object.rpoRiskReason) : "",
    };
  },

  toJSON(message: BackupPlan): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.cluster !== "") {
      obj.cluster = message.cluster;
    }
    if (message.retentionPolicy !== undefined) {
      obj.retentionPolicy = BackupPlan_RetentionPolicy.toJSON(message.retentionPolicy);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.backupSchedule !== undefined) {
      obj.backupSchedule = BackupPlan_Schedule.toJSON(message.backupSchedule);
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.deactivated !== false) {
      obj.deactivated = message.deactivated;
    }
    if (message.backupConfig !== undefined) {
      obj.backupConfig = BackupPlan_BackupConfig.toJSON(message.backupConfig);
    }
    if (message.protectedPodCount !== 0) {
      obj.protectedPodCount = Math.round(message.protectedPodCount);
    }
    if (message.state !== 0) {
      obj.state = backupPlan_StateToJSON(message.state);
    }
    if (message.stateReason !== "") {
      obj.stateReason = message.stateReason;
    }
    if (message.rpoRiskLevel !== 0) {
      obj.rpoRiskLevel = Math.round(message.rpoRiskLevel);
    }
    if (message.rpoRiskReason !== "") {
      obj.rpoRiskReason = message.rpoRiskReason;
    }
    return obj;
  },

  create(base?: DeepPartial<BackupPlan>): BackupPlan {
    return BackupPlan.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupPlan>): BackupPlan {
    const message = createBaseBackupPlan();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.description = object.description ?? "";
    message.cluster = object.cluster ?? "";
    message.retentionPolicy = (object.retentionPolicy !== undefined && object.retentionPolicy !== null)
      ? BackupPlan_RetentionPolicy.fromPartial(object.retentionPolicy)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.backupSchedule = (object.backupSchedule !== undefined && object.backupSchedule !== null)
      ? BackupPlan_Schedule.fromPartial(object.backupSchedule)
      : undefined;
    message.etag = object.etag ?? "";
    message.deactivated = object.deactivated ?? false;
    message.backupConfig = (object.backupConfig !== undefined && object.backupConfig !== null)
      ? BackupPlan_BackupConfig.fromPartial(object.backupConfig)
      : undefined;
    message.protectedPodCount = object.protectedPodCount ?? 0;
    message.state = object.state ?? 0;
    message.stateReason = object.stateReason ?? "";
    message.rpoRiskLevel = object.rpoRiskLevel ?? 0;
    message.rpoRiskReason = object.rpoRiskReason ?? "";
    return message;
  },
};

function createBaseBackupPlan_RetentionPolicy(): BackupPlan_RetentionPolicy {
  return { backupDeleteLockDays: 0, backupRetainDays: 0, locked: false };
}

export const BackupPlan_RetentionPolicy: MessageFns<BackupPlan_RetentionPolicy> = {
  encode(message: BackupPlan_RetentionPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backupDeleteLockDays !== 0) {
      writer.uint32(8).int32(message.backupDeleteLockDays);
    }
    if (message.backupRetainDays !== 0) {
      writer.uint32(16).int32(message.backupRetainDays);
    }
    if (message.locked !== false) {
      writer.uint32(24).bool(message.locked);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupPlan_RetentionPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupPlan_RetentionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.backupDeleteLockDays = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.backupRetainDays = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.locked = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupPlan_RetentionPolicy {
    return {
      backupDeleteLockDays: isSet(object.backupDeleteLockDays) ? globalThis.Number(object.backupDeleteLockDays) : 0,
      backupRetainDays: isSet(object.backupRetainDays) ? globalThis.Number(object.backupRetainDays) : 0,
      locked: isSet(object.locked) ? globalThis.Boolean(object.locked) : false,
    };
  },

  toJSON(message: BackupPlan_RetentionPolicy): unknown {
    const obj: any = {};
    if (message.backupDeleteLockDays !== 0) {
      obj.backupDeleteLockDays = Math.round(message.backupDeleteLockDays);
    }
    if (message.backupRetainDays !== 0) {
      obj.backupRetainDays = Math.round(message.backupRetainDays);
    }
    if (message.locked !== false) {
      obj.locked = message.locked;
    }
    return obj;
  },

  create(base?: DeepPartial<BackupPlan_RetentionPolicy>): BackupPlan_RetentionPolicy {
    return BackupPlan_RetentionPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupPlan_RetentionPolicy>): BackupPlan_RetentionPolicy {
    const message = createBaseBackupPlan_RetentionPolicy();
    message.backupDeleteLockDays = object.backupDeleteLockDays ?? 0;
    message.backupRetainDays = object.backupRetainDays ?? 0;
    message.locked = object.locked ?? false;
    return message;
  },
};

function createBaseBackupPlan_Schedule(): BackupPlan_Schedule {
  return { cronSchedule: "", paused: false, rpoConfig: undefined, nextScheduledBackupTime: undefined };
}

export const BackupPlan_Schedule: MessageFns<BackupPlan_Schedule> = {
  encode(message: BackupPlan_Schedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cronSchedule !== "") {
      writer.uint32(10).string(message.cronSchedule);
    }
    if (message.paused !== false) {
      writer.uint32(16).bool(message.paused);
    }
    if (message.rpoConfig !== undefined) {
      RpoConfig.encode(message.rpoConfig, writer.uint32(26).fork()).join();
    }
    if (message.nextScheduledBackupTime !== undefined) {
      Timestamp.encode(toTimestamp(message.nextScheduledBackupTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupPlan_Schedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupPlan_Schedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cronSchedule = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.paused = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rpoConfig = RpoConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nextScheduledBackupTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupPlan_Schedule {
    return {
      cronSchedule: isSet(object.cronSchedule) ? globalThis.String(object.cronSchedule) : "",
      paused: isSet(object.paused) ? globalThis.Boolean(object.paused) : false,
      rpoConfig: isSet(object.rpoConfig) ? RpoConfig.fromJSON(object.rpoConfig) : undefined,
      nextScheduledBackupTime: isSet(object.nextScheduledBackupTime)
        ? fromJsonTimestamp(object.nextScheduledBackupTime)
        : undefined,
    };
  },

  toJSON(message: BackupPlan_Schedule): unknown {
    const obj: any = {};
    if (message.cronSchedule !== "") {
      obj.cronSchedule = message.cronSchedule;
    }
    if (message.paused !== false) {
      obj.paused = message.paused;
    }
    if (message.rpoConfig !== undefined) {
      obj.rpoConfig = RpoConfig.toJSON(message.rpoConfig);
    }
    if (message.nextScheduledBackupTime !== undefined) {
      obj.nextScheduledBackupTime = message.nextScheduledBackupTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<BackupPlan_Schedule>): BackupPlan_Schedule {
    return BackupPlan_Schedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupPlan_Schedule>): BackupPlan_Schedule {
    const message = createBaseBackupPlan_Schedule();
    message.cronSchedule = object.cronSchedule ?? "";
    message.paused = object.paused ?? false;
    message.rpoConfig = (object.rpoConfig !== undefined && object.rpoConfig !== null)
      ? RpoConfig.fromPartial(object.rpoConfig)
      : undefined;
    message.nextScheduledBackupTime = object.nextScheduledBackupTime ?? undefined;
    return message;
  },
};

function createBaseBackupPlan_BackupConfig(): BackupPlan_BackupConfig {
  return {
    allNamespaces: undefined,
    selectedNamespaces: undefined,
    selectedApplications: undefined,
    includeVolumeData: false,
    includeSecrets: false,
    encryptionKey: undefined,
    permissiveMode: false,
  };
}

export const BackupPlan_BackupConfig: MessageFns<BackupPlan_BackupConfig> = {
  encode(message: BackupPlan_BackupConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allNamespaces !== undefined) {
      writer.uint32(8).bool(message.allNamespaces);
    }
    if (message.selectedNamespaces !== undefined) {
      Namespaces.encode(message.selectedNamespaces, writer.uint32(18).fork()).join();
    }
    if (message.selectedApplications !== undefined) {
      NamespacedNames.encode(message.selectedApplications, writer.uint32(26).fork()).join();
    }
    if (message.includeVolumeData !== false) {
      writer.uint32(32).bool(message.includeVolumeData);
    }
    if (message.includeSecrets !== false) {
      writer.uint32(40).bool(message.includeSecrets);
    }
    if (message.encryptionKey !== undefined) {
      EncryptionKey.encode(message.encryptionKey, writer.uint32(50).fork()).join();
    }
    if (message.permissiveMode !== false) {
      writer.uint32(56).bool(message.permissiveMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupPlan_BackupConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupPlan_BackupConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.allNamespaces = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.selectedNamespaces = Namespaces.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.selectedApplications = NamespacedNames.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.includeVolumeData = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.includeSecrets = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.encryptionKey = EncryptionKey.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.permissiveMode = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupPlan_BackupConfig {
    return {
      allNamespaces: isSet(object.allNamespaces) ? globalThis.Boolean(object.allNamespaces) : undefined,
      selectedNamespaces: isSet(object.selectedNamespaces) ? Namespaces.fromJSON(object.selectedNamespaces) : undefined,
      selectedApplications: isSet(object.selectedApplications)
        ? NamespacedNames.fromJSON(object.selectedApplications)
        : undefined,
      includeVolumeData: isSet(object.includeVolumeData) ? globalThis.Boolean(object.includeVolumeData) : false,
      includeSecrets: isSet(object.includeSecrets) ? globalThis.Boolean(object.includeSecrets) : false,
      encryptionKey: isSet(object.encryptionKey) ? EncryptionKey.fromJSON(object.encryptionKey) : undefined,
      permissiveMode: isSet(object.permissiveMode) ? globalThis.Boolean(object.permissiveMode) : false,
    };
  },

  toJSON(message: BackupPlan_BackupConfig): unknown {
    const obj: any = {};
    if (message.allNamespaces !== undefined) {
      obj.allNamespaces = message.allNamespaces;
    }
    if (message.selectedNamespaces !== undefined) {
      obj.selectedNamespaces = Namespaces.toJSON(message.selectedNamespaces);
    }
    if (message.selectedApplications !== undefined) {
      obj.selectedApplications = NamespacedNames.toJSON(message.selectedApplications);
    }
    if (message.includeVolumeData !== false) {
      obj.includeVolumeData = message.includeVolumeData;
    }
    if (message.includeSecrets !== false) {
      obj.includeSecrets = message.includeSecrets;
    }
    if (message.encryptionKey !== undefined) {
      obj.encryptionKey = EncryptionKey.toJSON(message.encryptionKey);
    }
    if (message.permissiveMode !== false) {
      obj.permissiveMode = message.permissiveMode;
    }
    return obj;
  },

  create(base?: DeepPartial<BackupPlan_BackupConfig>): BackupPlan_BackupConfig {
    return BackupPlan_BackupConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupPlan_BackupConfig>): BackupPlan_BackupConfig {
    const message = createBaseBackupPlan_BackupConfig();
    message.allNamespaces = object.allNamespaces ?? undefined;
    message.selectedNamespaces = (object.selectedNamespaces !== undefined && object.selectedNamespaces !== null)
      ? Namespaces.fromPartial(object.selectedNamespaces)
      : undefined;
    message.selectedApplications = (object.selectedApplications !== undefined && object.selectedApplications !== null)
      ? NamespacedNames.fromPartial(object.selectedApplications)
      : undefined;
    message.includeVolumeData = object.includeVolumeData ?? false;
    message.includeSecrets = object.includeSecrets ?? false;
    message.encryptionKey = (object.encryptionKey !== undefined && object.encryptionKey !== null)
      ? EncryptionKey.fromPartial(object.encryptionKey)
      : undefined;
    message.permissiveMode = object.permissiveMode ?? false;
    return message;
  },
};

function createBaseBackupPlan_LabelsEntry(): BackupPlan_LabelsEntry {
  return { key: "", value: "" };
}

export const BackupPlan_LabelsEntry: MessageFns<BackupPlan_LabelsEntry> = {
  encode(message: BackupPlan_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupPlan_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupPlan_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupPlan_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BackupPlan_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BackupPlan_LabelsEntry>): BackupPlan_LabelsEntry {
    return BackupPlan_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupPlan_LabelsEntry>): BackupPlan_LabelsEntry {
    const message = createBaseBackupPlan_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRpoConfig(): RpoConfig {
  return { targetRpoMinutes: 0, exclusionWindows: [] };
}

export const RpoConfig: MessageFns<RpoConfig> = {
  encode(message: RpoConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetRpoMinutes !== 0) {
      writer.uint32(8).int32(message.targetRpoMinutes);
    }
    for (const v of message.exclusionWindows) {
      ExclusionWindow.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RpoConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRpoConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.targetRpoMinutes = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exclusionWindows.push(ExclusionWindow.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RpoConfig {
    return {
      targetRpoMinutes: isSet(object.targetRpoMinutes) ? globalThis.Number(object.targetRpoMinutes) : 0,
      exclusionWindows: globalThis.Array.isArray(object?.exclusionWindows)
        ? object.exclusionWindows.map((e: any) => ExclusionWindow.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RpoConfig): unknown {
    const obj: any = {};
    if (message.targetRpoMinutes !== 0) {
      obj.targetRpoMinutes = Math.round(message.targetRpoMinutes);
    }
    if (message.exclusionWindows?.length) {
      obj.exclusionWindows = message.exclusionWindows.map((e) => ExclusionWindow.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RpoConfig>): RpoConfig {
    return RpoConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RpoConfig>): RpoConfig {
    const message = createBaseRpoConfig();
    message.targetRpoMinutes = object.targetRpoMinutes ?? 0;
    message.exclusionWindows = object.exclusionWindows?.map((e) => ExclusionWindow.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExclusionWindow(): ExclusionWindow {
  return {
    startTime: undefined,
    duration: undefined,
    singleOccurrenceDate: undefined,
    daily: undefined,
    daysOfWeek: undefined,
  };
}

export const ExclusionWindow: MessageFns<ExclusionWindow> = {
  encode(message: ExclusionWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      TimeOfDay.encode(message.startTime, writer.uint32(10).fork()).join();
    }
    if (message.duration !== undefined) {
      Duration.encode(message.duration, writer.uint32(18).fork()).join();
    }
    if (message.singleOccurrenceDate !== undefined) {
      DateMessage.encode(message.singleOccurrenceDate, writer.uint32(26).fork()).join();
    }
    if (message.daily !== undefined) {
      writer.uint32(32).bool(message.daily);
    }
    if (message.daysOfWeek !== undefined) {
      ExclusionWindow_DayOfWeekList.encode(message.daysOfWeek, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExclusionWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExclusionWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = TimeOfDay.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.duration = Duration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.singleOccurrenceDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.daily = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.daysOfWeek = ExclusionWindow_DayOfWeekList.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExclusionWindow {
    return {
      startTime: isSet(object.startTime) ? TimeOfDay.fromJSON(object.startTime) : undefined,
      duration: isSet(object.duration) ? Duration.fromJSON(object.duration) : undefined,
      singleOccurrenceDate: isSet(object.singleOccurrenceDate)
        ? DateMessage.fromJSON(object.singleOccurrenceDate)
        : undefined,
      daily: isSet(object.daily) ? globalThis.Boolean(object.daily) : undefined,
      daysOfWeek: isSet(object.daysOfWeek) ? ExclusionWindow_DayOfWeekList.fromJSON(object.daysOfWeek) : undefined,
    };
  },

  toJSON(message: ExclusionWindow): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = TimeOfDay.toJSON(message.startTime);
    }
    if (message.duration !== undefined) {
      obj.duration = Duration.toJSON(message.duration);
    }
    if (message.singleOccurrenceDate !== undefined) {
      obj.singleOccurrenceDate = DateMessage.toJSON(message.singleOccurrenceDate);
    }
    if (message.daily !== undefined) {
      obj.daily = message.daily;
    }
    if (message.daysOfWeek !== undefined) {
      obj.daysOfWeek = ExclusionWindow_DayOfWeekList.toJSON(message.daysOfWeek);
    }
    return obj;
  },

  create(base?: DeepPartial<ExclusionWindow>): ExclusionWindow {
    return ExclusionWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExclusionWindow>): ExclusionWindow {
    const message = createBaseExclusionWindow();
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? TimeOfDay.fromPartial(object.startTime)
      : undefined;
    message.duration = (object.duration !== undefined && object.duration !== null)
      ? Duration.fromPartial(object.duration)
      : undefined;
    message.singleOccurrenceDate = (object.singleOccurrenceDate !== undefined && object.singleOccurrenceDate !== null)
      ? DateMessage.fromPartial(object.singleOccurrenceDate)
      : undefined;
    message.daily = object.daily ?? undefined;
    message.daysOfWeek = (object.daysOfWeek !== undefined && object.daysOfWeek !== null)
      ? ExclusionWindow_DayOfWeekList.fromPartial(object.daysOfWeek)
      : undefined;
    return message;
  },
};

function createBaseExclusionWindow_DayOfWeekList(): ExclusionWindow_DayOfWeekList {
  return { daysOfWeek: [] };
}

export const ExclusionWindow_DayOfWeekList: MessageFns<ExclusionWindow_DayOfWeekList> = {
  encode(message: ExclusionWindow_DayOfWeekList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.daysOfWeek) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExclusionWindow_DayOfWeekList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExclusionWindow_DayOfWeekList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.daysOfWeek.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.daysOfWeek.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExclusionWindow_DayOfWeekList {
    return {
      daysOfWeek: globalThis.Array.isArray(object?.daysOfWeek)
        ? object.daysOfWeek.map((e: any) => dayOfWeekFromJSON(e))
        : [],
    };
  },

  toJSON(message: ExclusionWindow_DayOfWeekList): unknown {
    const obj: any = {};
    if (message.daysOfWeek?.length) {
      obj.daysOfWeek = message.daysOfWeek.map((e) => dayOfWeekToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ExclusionWindow_DayOfWeekList>): ExclusionWindow_DayOfWeekList {
    return ExclusionWindow_DayOfWeekList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExclusionWindow_DayOfWeekList>): ExclusionWindow_DayOfWeekList {
    const message = createBaseExclusionWindow_DayOfWeekList();
    message.daysOfWeek = object.daysOfWeek?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
