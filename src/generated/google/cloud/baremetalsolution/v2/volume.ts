// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/baremetalsolution/v2/volume.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { VolumePerformanceTier, volumePerformanceTierFromJSON, volumePerformanceTierToJSON } from "./common.js";

export const protobufPackage = "google.cloud.baremetalsolution.v2";

/** A storage volume. */
export interface Volume {
  /**
   * Output only. The resource name of this `Volume`.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * Format:
   * `projects/{project}/locations/{location}/volumes/{volume}`
   */
  name: string;
  /** An identifier for the `Volume`, generated by the backend. */
  id: string;
  /** The storage type for this volume. */
  storageType: Volume_StorageType;
  /** The state of this storage volume. */
  state: Volume_State;
  /** The requested size of this storage volume, in GiB. */
  requestedSizeGib: Long;
  /** Originally requested size, in GiB. */
  originallyRequestedSizeGib: Long;
  /**
   * The current size of this storage volume, in GiB, including space reserved
   * for snapshots. This size might be different than the requested size if the
   * storage volume has been configured with auto grow or auto shrink.
   */
  currentSizeGib: Long;
  /**
   * Additional emergency size that was requested for this Volume, in GiB.
   * current_size_gib includes this value.
   */
  emergencySizeGib: Long;
  /** Maximum size volume can be expanded to in case of evergency, in GiB. */
  maxSizeGib: Long;
  /**
   * The size, in GiB, that this storage volume has expanded as a result of an
   * auto grow policy. In the absence of auto-grow, the value is 0.
   */
  autoGrownSizeGib: Long;
  /**
   * The space remaining in the storage volume for new LUNs, in GiB, excluding
   * space reserved for snapshots.
   */
  remainingSpaceGib: Long;
  /** Details about snapshot space reservation and usage on the storage volume. */
  snapshotReservationDetail:
    | Volume_SnapshotReservationDetail
    | undefined;
  /** The behavior to use when snapshot reserved space is full. */
  snapshotAutoDeleteBehavior: Volume_SnapshotAutoDeleteBehavior;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Whether snapshots are enabled. */
  snapshotEnabled: boolean;
  /** Immutable. Pod name. */
  pod: string;
  /** Output only. Storage protocol for the Volume. */
  protocol: Volume_Protocol;
  /**
   * Output only. Whether this volume is a boot volume. A boot volume is one
   * which contains a boot LUN.
   */
  bootVolume: boolean;
  /**
   * Immutable. Performance tier of the Volume.
   * Default is SHARED.
   */
  performanceTier: VolumePerformanceTier;
  /**
   * Input only. User-specified notes for new Volume.
   * Used to provision Volumes that require manual intervention.
   */
  notes: string;
  /** The workload profile for the volume. */
  workloadProfile: Volume_WorkloadProfile;
  /**
   * Output only. Time after which volume will be fully deleted.
   * It is filled only for volumes in COOLOFF state.
   */
  expireTime:
    | Date
    | undefined;
  /**
   * Output only. Instances this Volume is attached to.
   * This field is set only in Get requests.
   */
  instances: string[];
  /**
   * Output only. Is the Volume attached at at least one instance.
   * This field is a lightweight counterpart of `instances` field.
   * It is filled in List responses as well.
   */
  attached: boolean;
}

/** The storage type for a volume. */
export enum Volume_StorageType {
  /** STORAGE_TYPE_UNSPECIFIED - The storage type for this volume is unknown. */
  STORAGE_TYPE_UNSPECIFIED = 0,
  /** SSD - The storage type for this volume is SSD. */
  SSD = 1,
  /** HDD - This storage type for this volume is HDD. */
  HDD = 2,
  UNRECOGNIZED = -1,
}

export function volume_StorageTypeFromJSON(object: any): Volume_StorageType {
  switch (object) {
    case 0:
    case "STORAGE_TYPE_UNSPECIFIED":
      return Volume_StorageType.STORAGE_TYPE_UNSPECIFIED;
    case 1:
    case "SSD":
      return Volume_StorageType.SSD;
    case 2:
    case "HDD":
      return Volume_StorageType.HDD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Volume_StorageType.UNRECOGNIZED;
  }
}

export function volume_StorageTypeToJSON(object: Volume_StorageType): string {
  switch (object) {
    case Volume_StorageType.STORAGE_TYPE_UNSPECIFIED:
      return "STORAGE_TYPE_UNSPECIFIED";
    case Volume_StorageType.SSD:
      return "SSD";
    case Volume_StorageType.HDD:
      return "HDD";
    case Volume_StorageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The possible states for a storage volume. */
export enum Volume_State {
  /** STATE_UNSPECIFIED - The storage volume is in an unknown state. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The storage volume is being created. */
  CREATING = 1,
  /** READY - The storage volume is ready for use. */
  READY = 2,
  /** DELETING - The storage volume has been requested to be deleted. */
  DELETING = 3,
  /** UPDATING - The storage volume is being updated. */
  UPDATING = 4,
  /**
   * COOL_OFF - The storage volume is in cool off state. It will be deleted after
   * `expire_time`.
   */
  COOL_OFF = 5,
  UNRECOGNIZED = -1,
}

export function volume_StateFromJSON(object: any): Volume_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Volume_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Volume_State.CREATING;
    case 2:
    case "READY":
      return Volume_State.READY;
    case 3:
    case "DELETING":
      return Volume_State.DELETING;
    case 4:
    case "UPDATING":
      return Volume_State.UPDATING;
    case 5:
    case "COOL_OFF":
      return Volume_State.COOL_OFF;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Volume_State.UNRECOGNIZED;
  }
}

export function volume_StateToJSON(object: Volume_State): string {
  switch (object) {
    case Volume_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Volume_State.CREATING:
      return "CREATING";
    case Volume_State.READY:
      return "READY";
    case Volume_State.DELETING:
      return "DELETING";
    case Volume_State.UPDATING:
      return "UPDATING";
    case Volume_State.COOL_OFF:
      return "COOL_OFF";
    case Volume_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The kinds of auto delete behavior to use when snapshot reserved space is
 * full.
 */
export enum Volume_SnapshotAutoDeleteBehavior {
  /** SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED - The unspecified behavior. */
  SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED = 0,
  /**
   * DISABLED - Don't delete any snapshots. This disables new snapshot creation, as
   * long as the snapshot reserved space is full.
   */
  DISABLED = 1,
  /** OLDEST_FIRST - Delete the oldest snapshots first. */
  OLDEST_FIRST = 2,
  /** NEWEST_FIRST - Delete the newest snapshots first. */
  NEWEST_FIRST = 3,
  UNRECOGNIZED = -1,
}

export function volume_SnapshotAutoDeleteBehaviorFromJSON(object: any): Volume_SnapshotAutoDeleteBehavior {
  switch (object) {
    case 0:
    case "SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED":
      return Volume_SnapshotAutoDeleteBehavior.SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return Volume_SnapshotAutoDeleteBehavior.DISABLED;
    case 2:
    case "OLDEST_FIRST":
      return Volume_SnapshotAutoDeleteBehavior.OLDEST_FIRST;
    case 3:
    case "NEWEST_FIRST":
      return Volume_SnapshotAutoDeleteBehavior.NEWEST_FIRST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Volume_SnapshotAutoDeleteBehavior.UNRECOGNIZED;
  }
}

export function volume_SnapshotAutoDeleteBehaviorToJSON(object: Volume_SnapshotAutoDeleteBehavior): string {
  switch (object) {
    case Volume_SnapshotAutoDeleteBehavior.SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED:
      return "SNAPSHOT_AUTO_DELETE_BEHAVIOR_UNSPECIFIED";
    case Volume_SnapshotAutoDeleteBehavior.DISABLED:
      return "DISABLED";
    case Volume_SnapshotAutoDeleteBehavior.OLDEST_FIRST:
      return "OLDEST_FIRST";
    case Volume_SnapshotAutoDeleteBehavior.NEWEST_FIRST:
      return "NEWEST_FIRST";
    case Volume_SnapshotAutoDeleteBehavior.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Storage protocol. */
export enum Volume_Protocol {
  /** PROTOCOL_UNSPECIFIED - Value is not specified. */
  PROTOCOL_UNSPECIFIED = 0,
  /** FIBRE_CHANNEL - Fibre Channel protocol. */
  FIBRE_CHANNEL = 1,
  /**
   * NFS - NFS protocol means Volume is a NFS Share volume.
   * Such volumes cannot be manipulated via Volumes API.
   */
  NFS = 2,
  UNRECOGNIZED = -1,
}

export function volume_ProtocolFromJSON(object: any): Volume_Protocol {
  switch (object) {
    case 0:
    case "PROTOCOL_UNSPECIFIED":
      return Volume_Protocol.PROTOCOL_UNSPECIFIED;
    case 1:
    case "FIBRE_CHANNEL":
      return Volume_Protocol.FIBRE_CHANNEL;
    case 2:
    case "NFS":
      return Volume_Protocol.NFS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Volume_Protocol.UNRECOGNIZED;
  }
}

export function volume_ProtocolToJSON(object: Volume_Protocol): string {
  switch (object) {
    case Volume_Protocol.PROTOCOL_UNSPECIFIED:
      return "PROTOCOL_UNSPECIFIED";
    case Volume_Protocol.FIBRE_CHANNEL:
      return "FIBRE_CHANNEL";
    case Volume_Protocol.NFS:
      return "NFS";
    case Volume_Protocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The possible values for a workload profile. */
export enum Volume_WorkloadProfile {
  /** WORKLOAD_PROFILE_UNSPECIFIED - The workload profile is in an unknown state. */
  WORKLOAD_PROFILE_UNSPECIFIED = 0,
  /** GENERIC - The workload profile is generic. */
  GENERIC = 1,
  /** HANA - The workload profile is hana. */
  HANA = 2,
  UNRECOGNIZED = -1,
}

export function volume_WorkloadProfileFromJSON(object: any): Volume_WorkloadProfile {
  switch (object) {
    case 0:
    case "WORKLOAD_PROFILE_UNSPECIFIED":
      return Volume_WorkloadProfile.WORKLOAD_PROFILE_UNSPECIFIED;
    case 1:
    case "GENERIC":
      return Volume_WorkloadProfile.GENERIC;
    case 2:
    case "HANA":
      return Volume_WorkloadProfile.HANA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Volume_WorkloadProfile.UNRECOGNIZED;
  }
}

export function volume_WorkloadProfileToJSON(object: Volume_WorkloadProfile): string {
  switch (object) {
    case Volume_WorkloadProfile.WORKLOAD_PROFILE_UNSPECIFIED:
      return "WORKLOAD_PROFILE_UNSPECIFIED";
    case Volume_WorkloadProfile.GENERIC:
      return "GENERIC";
    case Volume_WorkloadProfile.HANA:
      return "HANA";
    case Volume_WorkloadProfile.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Details about snapshot space reservation and usage on the storage volume. */
export interface Volume_SnapshotReservationDetail {
  /** The space on this storage volume reserved for snapshots, shown in GiB. */
  reservedSpaceGib: Long;
  /**
   * The percent of snapshot space on this storage volume actually being used
   * by the snapshot copies. This value might be higher than 100% if the
   * snapshot copies have overflowed into the data portion of the storage
   * volume.
   */
  reservedSpaceUsedPercent: number;
  /**
   * The amount, in GiB, of available space in this storage volume's reserved
   * snapshot space.
   */
  reservedSpaceRemainingGib: Long;
  /**
   * Percent of the total Volume size reserved for snapshot copies.
   * Enabling snapshots requires reserving 20% or more of
   * the storage volume space for snapshots. Maximum reserved space for
   * snapshots is 40%.
   * Setting this field will effectively set snapshot_enabled to true.
   */
  reservedSpacePercent: number;
}

export interface Volume_LabelsEntry {
  key: string;
  value: string;
}

/** Message for requesting storage volume information. */
export interface GetVolumeRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Message for requesting a list of storage volumes. */
export interface ListVolumesRequest {
  /** Required. Parent value for ListVolumesRequest. */
  parent: string;
  /**
   * Requested page size. The server might return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results from the server. */
  pageToken: string;
  /** List filter. */
  filter: string;
}

/** Response message containing the list of storage volumes. */
export interface ListVolumesResponse {
  /** The list of storage volumes. */
  volumes: Volume[];
  /** A token identifying a page of results from the server. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message for updating a volume. */
export interface UpdateVolumeRequest {
  /**
   * Required. The volume to update.
   *
   * The `name` field is used to identify the volume to update.
   * Format: projects/{project}/locations/{location}/volumes/{volume}
   */
  volume:
    | Volume
    | undefined;
  /**
   * The list of fields to update.
   * The only currently supported fields are:
   *   'labels'
   */
  updateMask: string[] | undefined;
}

/** Message requesting rename of a server. */
export interface RenameVolumeRequest {
  /**
   * Required. The `name` field is used to identify the volume.
   * Format: projects/{project}/locations/{location}/volumes/{volume}
   */
  name: string;
  /** Required. The new `id` of the volume. */
  newVolumeId: string;
}

/** Request for skip volume cooloff and delete it. */
export interface EvictVolumeRequest {
  /** Required. The name of the Volume. */
  name: string;
}

/** Request for emergency resize Volume. */
export interface ResizeVolumeRequest {
  /** Required. Volume to resize. */
  volume: string;
  /** New Volume size, in GiB. */
  sizeGib: Long;
}

function createBaseVolume(): Volume {
  return {
    name: "",
    id: "",
    storageType: 0,
    state: 0,
    requestedSizeGib: Long.ZERO,
    originallyRequestedSizeGib: Long.ZERO,
    currentSizeGib: Long.ZERO,
    emergencySizeGib: Long.ZERO,
    maxSizeGib: Long.ZERO,
    autoGrownSizeGib: Long.ZERO,
    remainingSpaceGib: Long.ZERO,
    snapshotReservationDetail: undefined,
    snapshotAutoDeleteBehavior: 0,
    labels: {},
    snapshotEnabled: false,
    pod: "",
    protocol: 0,
    bootVolume: false,
    performanceTier: 0,
    notes: "",
    workloadProfile: 0,
    expireTime: undefined,
    instances: [],
    attached: false,
  };
}

export const Volume: MessageFns<Volume> = {
  encode(message: Volume, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(90).string(message.id);
    }
    if (message.storageType !== 0) {
      writer.uint32(16).int32(message.storageType);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (!message.requestedSizeGib.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.requestedSizeGib.toString());
    }
    if (!message.originallyRequestedSizeGib.equals(Long.ZERO)) {
      writer.uint32(128).int64(message.originallyRequestedSizeGib.toString());
    }
    if (!message.currentSizeGib.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.currentSizeGib.toString());
    }
    if (!message.emergencySizeGib.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.emergencySizeGib.toString());
    }
    if (!message.maxSizeGib.equals(Long.ZERO)) {
      writer.uint32(136).int64(message.maxSizeGib.toString());
    }
    if (!message.autoGrownSizeGib.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.autoGrownSizeGib.toString());
    }
    if (!message.remainingSpaceGib.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.remainingSpaceGib.toString());
    }
    if (message.snapshotReservationDetail !== undefined) {
      Volume_SnapshotReservationDetail.encode(message.snapshotReservationDetail, writer.uint32(66).fork()).join();
    }
    if (message.snapshotAutoDeleteBehavior !== 0) {
      writer.uint32(72).int32(message.snapshotAutoDeleteBehavior);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Volume_LabelsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    if (message.snapshotEnabled !== false) {
      writer.uint32(104).bool(message.snapshotEnabled);
    }
    if (message.pod !== "") {
      writer.uint32(122).string(message.pod);
    }
    if (message.protocol !== 0) {
      writer.uint32(144).int32(message.protocol);
    }
    if (message.bootVolume !== false) {
      writer.uint32(152).bool(message.bootVolume);
    }
    if (message.performanceTier !== 0) {
      writer.uint32(160).int32(message.performanceTier);
    }
    if (message.notes !== "") {
      writer.uint32(170).string(message.notes);
    }
    if (message.workloadProfile !== 0) {
      writer.uint32(176).int32(message.workloadProfile);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(194).fork()).join();
    }
    for (const v of message.instances) {
      writer.uint32(202).string(v!);
    }
    if (message.attached !== false) {
      writer.uint32(208).bool(message.attached);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Volume {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.storageType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.requestedSizeGib = Long.fromString(reader.int64().toString());
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.originallyRequestedSizeGib = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.currentSizeGib = Long.fromString(reader.int64().toString());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.emergencySizeGib = Long.fromString(reader.int64().toString());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.maxSizeGib = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.autoGrownSizeGib = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.remainingSpaceGib = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.snapshotReservationDetail = Volume_SnapshotReservationDetail.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.snapshotAutoDeleteBehavior = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = Volume_LabelsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.labels[entry12.key] = entry12.value;
          }
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.snapshotEnabled = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.pod = reader.string();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.protocol = reader.int32() as any;
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.bootVolume = reader.bool();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.performanceTier = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.workloadProfile = reader.int32() as any;
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.instances.push(reader.string());
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.attached = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Volume {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      storageType: isSet(object.storageType) ? volume_StorageTypeFromJSON(object.storageType) : 0,
      state: isSet(object.state) ? volume_StateFromJSON(object.state) : 0,
      requestedSizeGib: isSet(object.requestedSizeGib) ? Long.fromValue(object.requestedSizeGib) : Long.ZERO,
      originallyRequestedSizeGib: isSet(object.originallyRequestedSizeGib)
        ? Long.fromValue(object.originallyRequestedSizeGib)
        : Long.ZERO,
      currentSizeGib: isSet(object.currentSizeGib) ? Long.fromValue(object.currentSizeGib) : Long.ZERO,
      emergencySizeGib: isSet(object.emergencySizeGib) ? Long.fromValue(object.emergencySizeGib) : Long.ZERO,
      maxSizeGib: isSet(object.maxSizeGib) ? Long.fromValue(object.maxSizeGib) : Long.ZERO,
      autoGrownSizeGib: isSet(object.autoGrownSizeGib) ? Long.fromValue(object.autoGrownSizeGib) : Long.ZERO,
      remainingSpaceGib: isSet(object.remainingSpaceGib) ? Long.fromValue(object.remainingSpaceGib) : Long.ZERO,
      snapshotReservationDetail: isSet(object.snapshotReservationDetail)
        ? Volume_SnapshotReservationDetail.fromJSON(object.snapshotReservationDetail)
        : undefined,
      snapshotAutoDeleteBehavior: isSet(object.snapshotAutoDeleteBehavior)
        ? volume_SnapshotAutoDeleteBehaviorFromJSON(object.snapshotAutoDeleteBehavior)
        : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      snapshotEnabled: isSet(object.snapshotEnabled) ? globalThis.Boolean(object.snapshotEnabled) : false,
      pod: isSet(object.pod) ? globalThis.String(object.pod) : "",
      protocol: isSet(object.protocol) ? volume_ProtocolFromJSON(object.protocol) : 0,
      bootVolume: isSet(object.bootVolume) ? globalThis.Boolean(object.bootVolume) : false,
      performanceTier: isSet(object.performanceTier) ? volumePerformanceTierFromJSON(object.performanceTier) : 0,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      workloadProfile: isSet(object.workloadProfile) ? volume_WorkloadProfileFromJSON(object.workloadProfile) : 0,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => globalThis.String(e))
        : [],
      attached: isSet(object.attached) ? globalThis.Boolean(object.attached) : false,
    };
  },

  toJSON(message: Volume): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.storageType !== 0) {
      obj.storageType = volume_StorageTypeToJSON(message.storageType);
    }
    if (message.state !== 0) {
      obj.state = volume_StateToJSON(message.state);
    }
    if (!message.requestedSizeGib.equals(Long.ZERO)) {
      obj.requestedSizeGib = (message.requestedSizeGib || Long.ZERO).toString();
    }
    if (!message.originallyRequestedSizeGib.equals(Long.ZERO)) {
      obj.originallyRequestedSizeGib = (message.originallyRequestedSizeGib || Long.ZERO).toString();
    }
    if (!message.currentSizeGib.equals(Long.ZERO)) {
      obj.currentSizeGib = (message.currentSizeGib || Long.ZERO).toString();
    }
    if (!message.emergencySizeGib.equals(Long.ZERO)) {
      obj.emergencySizeGib = (message.emergencySizeGib || Long.ZERO).toString();
    }
    if (!message.maxSizeGib.equals(Long.ZERO)) {
      obj.maxSizeGib = (message.maxSizeGib || Long.ZERO).toString();
    }
    if (!message.autoGrownSizeGib.equals(Long.ZERO)) {
      obj.autoGrownSizeGib = (message.autoGrownSizeGib || Long.ZERO).toString();
    }
    if (!message.remainingSpaceGib.equals(Long.ZERO)) {
      obj.remainingSpaceGib = (message.remainingSpaceGib || Long.ZERO).toString();
    }
    if (message.snapshotReservationDetail !== undefined) {
      obj.snapshotReservationDetail = Volume_SnapshotReservationDetail.toJSON(message.snapshotReservationDetail);
    }
    if (message.snapshotAutoDeleteBehavior !== 0) {
      obj.snapshotAutoDeleteBehavior = volume_SnapshotAutoDeleteBehaviorToJSON(message.snapshotAutoDeleteBehavior);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.snapshotEnabled !== false) {
      obj.snapshotEnabled = message.snapshotEnabled;
    }
    if (message.pod !== "") {
      obj.pod = message.pod;
    }
    if (message.protocol !== 0) {
      obj.protocol = volume_ProtocolToJSON(message.protocol);
    }
    if (message.bootVolume !== false) {
      obj.bootVolume = message.bootVolume;
    }
    if (message.performanceTier !== 0) {
      obj.performanceTier = volumePerformanceTierToJSON(message.performanceTier);
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.workloadProfile !== 0) {
      obj.workloadProfile = volume_WorkloadProfileToJSON(message.workloadProfile);
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.instances?.length) {
      obj.instances = message.instances;
    }
    if (message.attached !== false) {
      obj.attached = message.attached;
    }
    return obj;
  },

  create(base?: DeepPartial<Volume>): Volume {
    return Volume.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Volume>): Volume {
    const message = createBaseVolume();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.storageType = object.storageType ?? 0;
    message.state = object.state ?? 0;
    message.requestedSizeGib = (object.requestedSizeGib !== undefined && object.requestedSizeGib !== null)
      ? Long.fromValue(object.requestedSizeGib)
      : Long.ZERO;
    message.originallyRequestedSizeGib =
      (object.originallyRequestedSizeGib !== undefined && object.originallyRequestedSizeGib !== null)
        ? Long.fromValue(object.originallyRequestedSizeGib)
        : Long.ZERO;
    message.currentSizeGib = (object.currentSizeGib !== undefined && object.currentSizeGib !== null)
      ? Long.fromValue(object.currentSizeGib)
      : Long.ZERO;
    message.emergencySizeGib = (object.emergencySizeGib !== undefined && object.emergencySizeGib !== null)
      ? Long.fromValue(object.emergencySizeGib)
      : Long.ZERO;
    message.maxSizeGib = (object.maxSizeGib !== undefined && object.maxSizeGib !== null)
      ? Long.fromValue(object.maxSizeGib)
      : Long.ZERO;
    message.autoGrownSizeGib = (object.autoGrownSizeGib !== undefined && object.autoGrownSizeGib !== null)
      ? Long.fromValue(object.autoGrownSizeGib)
      : Long.ZERO;
    message.remainingSpaceGib = (object.remainingSpaceGib !== undefined && object.remainingSpaceGib !== null)
      ? Long.fromValue(object.remainingSpaceGib)
      : Long.ZERO;
    message.snapshotReservationDetail =
      (object.snapshotReservationDetail !== undefined && object.snapshotReservationDetail !== null)
        ? Volume_SnapshotReservationDetail.fromPartial(object.snapshotReservationDetail)
        : undefined;
    message.snapshotAutoDeleteBehavior = object.snapshotAutoDeleteBehavior ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.snapshotEnabled = object.snapshotEnabled ?? false;
    message.pod = object.pod ?? "";
    message.protocol = object.protocol ?? 0;
    message.bootVolume = object.bootVolume ?? false;
    message.performanceTier = object.performanceTier ?? 0;
    message.notes = object.notes ?? "";
    message.workloadProfile = object.workloadProfile ?? 0;
    message.expireTime = object.expireTime ?? undefined;
    message.instances = object.instances?.map((e) => e) || [];
    message.attached = object.attached ?? false;
    return message;
  },
};

function createBaseVolume_SnapshotReservationDetail(): Volume_SnapshotReservationDetail {
  return {
    reservedSpaceGib: Long.ZERO,
    reservedSpaceUsedPercent: 0,
    reservedSpaceRemainingGib: Long.ZERO,
    reservedSpacePercent: 0,
  };
}

export const Volume_SnapshotReservationDetail: MessageFns<Volume_SnapshotReservationDetail> = {
  encode(message: Volume_SnapshotReservationDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.reservedSpaceGib.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.reservedSpaceGib.toString());
    }
    if (message.reservedSpaceUsedPercent !== 0) {
      writer.uint32(16).int32(message.reservedSpaceUsedPercent);
    }
    if (!message.reservedSpaceRemainingGib.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.reservedSpaceRemainingGib.toString());
    }
    if (message.reservedSpacePercent !== 0) {
      writer.uint32(32).int32(message.reservedSpacePercent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Volume_SnapshotReservationDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolume_SnapshotReservationDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.reservedSpaceGib = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.reservedSpaceUsedPercent = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.reservedSpaceRemainingGib = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.reservedSpacePercent = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Volume_SnapshotReservationDetail {
    return {
      reservedSpaceGib: isSet(object.reservedSpaceGib) ? Long.fromValue(object.reservedSpaceGib) : Long.ZERO,
      reservedSpaceUsedPercent: isSet(object.reservedSpaceUsedPercent)
        ? globalThis.Number(object.reservedSpaceUsedPercent)
        : 0,
      reservedSpaceRemainingGib: isSet(object.reservedSpaceRemainingGib)
        ? Long.fromValue(object.reservedSpaceRemainingGib)
        : Long.ZERO,
      reservedSpacePercent: isSet(object.reservedSpacePercent) ? globalThis.Number(object.reservedSpacePercent) : 0,
    };
  },

  toJSON(message: Volume_SnapshotReservationDetail): unknown {
    const obj: any = {};
    if (!message.reservedSpaceGib.equals(Long.ZERO)) {
      obj.reservedSpaceGib = (message.reservedSpaceGib || Long.ZERO).toString();
    }
    if (message.reservedSpaceUsedPercent !== 0) {
      obj.reservedSpaceUsedPercent = Math.round(message.reservedSpaceUsedPercent);
    }
    if (!message.reservedSpaceRemainingGib.equals(Long.ZERO)) {
      obj.reservedSpaceRemainingGib = (message.reservedSpaceRemainingGib || Long.ZERO).toString();
    }
    if (message.reservedSpacePercent !== 0) {
      obj.reservedSpacePercent = Math.round(message.reservedSpacePercent);
    }
    return obj;
  },

  create(base?: DeepPartial<Volume_SnapshotReservationDetail>): Volume_SnapshotReservationDetail {
    return Volume_SnapshotReservationDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Volume_SnapshotReservationDetail>): Volume_SnapshotReservationDetail {
    const message = createBaseVolume_SnapshotReservationDetail();
    message.reservedSpaceGib = (object.reservedSpaceGib !== undefined && object.reservedSpaceGib !== null)
      ? Long.fromValue(object.reservedSpaceGib)
      : Long.ZERO;
    message.reservedSpaceUsedPercent = object.reservedSpaceUsedPercent ?? 0;
    message.reservedSpaceRemainingGib =
      (object.reservedSpaceRemainingGib !== undefined && object.reservedSpaceRemainingGib !== null)
        ? Long.fromValue(object.reservedSpaceRemainingGib)
        : Long.ZERO;
    message.reservedSpacePercent = object.reservedSpacePercent ?? 0;
    return message;
  },
};

function createBaseVolume_LabelsEntry(): Volume_LabelsEntry {
  return { key: "", value: "" };
}

export const Volume_LabelsEntry: MessageFns<Volume_LabelsEntry> = {
  encode(message: Volume_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Volume_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolume_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Volume_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Volume_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Volume_LabelsEntry>): Volume_LabelsEntry {
    return Volume_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Volume_LabelsEntry>): Volume_LabelsEntry {
    const message = createBaseVolume_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetVolumeRequest(): GetVolumeRequest {
  return { name: "" };
}

export const GetVolumeRequest: MessageFns<GetVolumeRequest> = {
  encode(message: GetVolumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetVolumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetVolumeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetVolumeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetVolumeRequest>): GetVolumeRequest {
    return GetVolumeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetVolumeRequest>): GetVolumeRequest {
    const message = createBaseGetVolumeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListVolumesRequest(): ListVolumesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListVolumesRequest: MessageFns<ListVolumesRequest> = {
  encode(message: ListVolumesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVolumesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVolumesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVolumesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListVolumesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVolumesRequest>): ListVolumesRequest {
    return ListVolumesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVolumesRequest>): ListVolumesRequest {
    const message = createBaseListVolumesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListVolumesResponse(): ListVolumesResponse {
  return { volumes: [], nextPageToken: "", unreachable: [] };
}

export const ListVolumesResponse: MessageFns<ListVolumesResponse> = {
  encode(message: ListVolumesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.volumes) {
      Volume.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListVolumesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListVolumesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.volumes.push(Volume.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListVolumesResponse {
    return {
      volumes: globalThis.Array.isArray(object?.volumes) ? object.volumes.map((e: any) => Volume.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListVolumesResponse): unknown {
    const obj: any = {};
    if (message.volumes?.length) {
      obj.volumes = message.volumes.map((e) => Volume.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListVolumesResponse>): ListVolumesResponse {
    return ListVolumesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListVolumesResponse>): ListVolumesResponse {
    const message = createBaseListVolumesResponse();
    message.volumes = object.volumes?.map((e) => Volume.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateVolumeRequest(): UpdateVolumeRequest {
  return { volume: undefined, updateMask: undefined };
}

export const UpdateVolumeRequest: MessageFns<UpdateVolumeRequest> = {
  encode(message: UpdateVolumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.volume !== undefined) {
      Volume.encode(message.volume, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVolumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.volume = Volume.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateVolumeRequest {
    return {
      volume: isSet(object.volume) ? Volume.fromJSON(object.volume) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateVolumeRequest): unknown {
    const obj: any = {};
    if (message.volume !== undefined) {
      obj.volume = Volume.toJSON(message.volume);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateVolumeRequest>): UpdateVolumeRequest {
    return UpdateVolumeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateVolumeRequest>): UpdateVolumeRequest {
    const message = createBaseUpdateVolumeRequest();
    message.volume = (object.volume !== undefined && object.volume !== null)
      ? Volume.fromPartial(object.volume)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseRenameVolumeRequest(): RenameVolumeRequest {
  return { name: "", newVolumeId: "" };
}

export const RenameVolumeRequest: MessageFns<RenameVolumeRequest> = {
  encode(message: RenameVolumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.newVolumeId !== "") {
      writer.uint32(18).string(message.newVolumeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenameVolumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newVolumeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenameVolumeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      newVolumeId: isSet(object.newVolumeId) ? globalThis.String(object.newVolumeId) : "",
    };
  },

  toJSON(message: RenameVolumeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.newVolumeId !== "") {
      obj.newVolumeId = message.newVolumeId;
    }
    return obj;
  },

  create(base?: DeepPartial<RenameVolumeRequest>): RenameVolumeRequest {
    return RenameVolumeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenameVolumeRequest>): RenameVolumeRequest {
    const message = createBaseRenameVolumeRequest();
    message.name = object.name ?? "";
    message.newVolumeId = object.newVolumeId ?? "";
    return message;
  },
};

function createBaseEvictVolumeRequest(): EvictVolumeRequest {
  return { name: "" };
}

export const EvictVolumeRequest: MessageFns<EvictVolumeRequest> = {
  encode(message: EvictVolumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvictVolumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvictVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvictVolumeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: EvictVolumeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<EvictVolumeRequest>): EvictVolumeRequest {
    return EvictVolumeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvictVolumeRequest>): EvictVolumeRequest {
    const message = createBaseEvictVolumeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseResizeVolumeRequest(): ResizeVolumeRequest {
  return { volume: "", sizeGib: Long.ZERO };
}

export const ResizeVolumeRequest: MessageFns<ResizeVolumeRequest> = {
  encode(message: ResizeVolumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.volume !== "") {
      writer.uint32(10).string(message.volume);
    }
    if (!message.sizeGib.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.sizeGib.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResizeVolumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResizeVolumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.volume = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sizeGib = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResizeVolumeRequest {
    return {
      volume: isSet(object.volume) ? globalThis.String(object.volume) : "",
      sizeGib: isSet(object.sizeGib) ? Long.fromValue(object.sizeGib) : Long.ZERO,
    };
  },

  toJSON(message: ResizeVolumeRequest): unknown {
    const obj: any = {};
    if (message.volume !== "") {
      obj.volume = message.volume;
    }
    if (!message.sizeGib.equals(Long.ZERO)) {
      obj.sizeGib = (message.sizeGib || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ResizeVolumeRequest>): ResizeVolumeRequest {
    return ResizeVolumeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResizeVolumeRequest>): ResizeVolumeRequest {
    const message = createBaseResizeVolumeRequest();
    message.volume = object.volume ?? "";
    message.sizeGib = (object.sizeGib !== undefined && object.sizeGib !== null)
      ? Long.fromValue(object.sizeGib)
      : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
