// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/baremetalsolution/v2/provisioning.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { VolumePerformanceTier, volumePerformanceTierFromJSON, volumePerformanceTierToJSON } from "./common.js";
import { LogicalInterface } from "./network.js";

export const protobufPackage = "google.cloud.baremetalsolution.v2";

/** A provisioning configuration. */
export interface ProvisioningConfig {
  /**
   * Output only. The system-generated name of the provisioning config. This
   * follows the UUID format.
   */
  name: string;
  /** Instances to be created. */
  instances: InstanceConfig[];
  /** Networks to be created. */
  networks: NetworkConfig[];
  /** Volumes to be created. */
  volumes: VolumeConfig[];
  /** A generated ticket id to track provisioning request. */
  ticketId: string;
  /**
   * A service account to enable customers to access instance credentials upon
   * handover.
   */
  handoverServiceAccount: string;
  /**
   * Email provided to send a confirmation with provisioning config to.
   * Deprecated in favour of email field in request messages.
   *
   * @deprecated
   */
  email: string;
  /** Output only. State of ProvisioningConfig. */
  state: ProvisioningConfig_State;
  /**
   * Optional. Location name of this ProvisioningConfig.
   * It is optional only for Intake UI transition period.
   */
  location: string;
  /** Output only. Last update timestamp. */
  updateTime:
    | Date
    | undefined;
  /** Output only. URI to Cloud Console UI view of this provisioning config. */
  cloudConsoleUri: string;
  /** If true, VPC SC is enabled for the cluster. */
  vpcScEnabled: boolean;
  /** Optional status messages associated with the FAILED state. */
  statusMessage: string;
  /** Optional. The user-defined identifier of the provisioning config. */
  customId: string;
}

/** The possible states for this ProvisioningConfig. */
export enum ProvisioningConfig_State {
  /** STATE_UNSPECIFIED - State wasn't specified. */
  STATE_UNSPECIFIED = 0,
  /** DRAFT - ProvisioningConfig is a draft and can be freely modified. */
  DRAFT = 1,
  /** SUBMITTED - ProvisioningConfig was already submitted and cannot be modified. */
  SUBMITTED = 2,
  /**
   * PROVISIONING - ProvisioningConfig was in the provisioning state.  Initially this state
   * comes from the work order table in big query when SNOW is used.  Later
   * this field can be set by the work order API.
   */
  PROVISIONING = 3,
  /** PROVISIONED - ProvisioningConfig was provisioned, meaning the resources exist. */
  PROVISIONED = 4,
  /**
   * VALIDATED - ProvisioningConfig was validated.  A validation tool will be run to
   * set this state.
   */
  VALIDATED = 5,
  /** CANCELLED - ProvisioningConfig was canceled. */
  CANCELLED = 6,
  /** FAILED - The request is submitted for provisioning, with error return. */
  FAILED = 7,
  UNRECOGNIZED = -1,
}

export function provisioningConfig_StateFromJSON(object: any): ProvisioningConfig_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ProvisioningConfig_State.STATE_UNSPECIFIED;
    case 1:
    case "DRAFT":
      return ProvisioningConfig_State.DRAFT;
    case 2:
    case "SUBMITTED":
      return ProvisioningConfig_State.SUBMITTED;
    case 3:
    case "PROVISIONING":
      return ProvisioningConfig_State.PROVISIONING;
    case 4:
    case "PROVISIONED":
      return ProvisioningConfig_State.PROVISIONED;
    case 5:
    case "VALIDATED":
      return ProvisioningConfig_State.VALIDATED;
    case 6:
    case "CANCELLED":
      return ProvisioningConfig_State.CANCELLED;
    case 7:
    case "FAILED":
      return ProvisioningConfig_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProvisioningConfig_State.UNRECOGNIZED;
  }
}

export function provisioningConfig_StateToJSON(object: ProvisioningConfig_State): string {
  switch (object) {
    case ProvisioningConfig_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ProvisioningConfig_State.DRAFT:
      return "DRAFT";
    case ProvisioningConfig_State.SUBMITTED:
      return "SUBMITTED";
    case ProvisioningConfig_State.PROVISIONING:
      return "PROVISIONING";
    case ProvisioningConfig_State.PROVISIONED:
      return "PROVISIONED";
    case ProvisioningConfig_State.VALIDATED:
      return "VALIDATED";
    case ProvisioningConfig_State.CANCELLED:
      return "CANCELLED";
    case ProvisioningConfig_State.FAILED:
      return "FAILED";
    case ProvisioningConfig_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request for SubmitProvisioningConfig. */
export interface SubmitProvisioningConfigRequest {
  /**
   * Required. The parent project and location containing the
   * ProvisioningConfig.
   */
  parent: string;
  /** Required. The ProvisioningConfig to create. */
  provisioningConfig:
    | ProvisioningConfig
    | undefined;
  /**
   * Optional. Email provided to send a confirmation with provisioning config
   * to.
   */
  email: string;
}

/** Response for SubmitProvisioningConfig. */
export interface SubmitProvisioningConfigResponse {
  /** The submitted provisioning config. */
  provisioningConfig: ProvisioningConfig | undefined;
}

/** A provisioning quota for a given project. */
export interface ProvisioningQuota {
  /** Output only. The name of the provisioning quota. */
  name: string;
  /** The asset type of this provisioning quota. */
  assetType: ProvisioningQuota_AssetType;
  /** The gcp service of the provisioning quota. */
  gcpService: string;
  /** The specific location of the provisioining quota. */
  location: string;
  /** The available count of the provisioning quota. */
  availableCount: number;
  /** Instance quota. */
  instanceQuota?:
    | InstanceQuota
    | undefined;
  /** Server count. */
  serverCount?:
    | Long
    | undefined;
  /** Network bandwidth, Gbps */
  networkBandwidth?:
    | Long
    | undefined;
  /** Storage size (GB). */
  storageGib?: Long | undefined;
}

/** The available asset types for intake. */
export enum ProvisioningQuota_AssetType {
  /** ASSET_TYPE_UNSPECIFIED - The unspecified type. */
  ASSET_TYPE_UNSPECIFIED = 0,
  /** ASSET_TYPE_SERVER - The server asset type. */
  ASSET_TYPE_SERVER = 1,
  /** ASSET_TYPE_STORAGE - The storage asset type. */
  ASSET_TYPE_STORAGE = 2,
  /** ASSET_TYPE_NETWORK - The network asset type. */
  ASSET_TYPE_NETWORK = 3,
  UNRECOGNIZED = -1,
}

export function provisioningQuota_AssetTypeFromJSON(object: any): ProvisioningQuota_AssetType {
  switch (object) {
    case 0:
    case "ASSET_TYPE_UNSPECIFIED":
      return ProvisioningQuota_AssetType.ASSET_TYPE_UNSPECIFIED;
    case 1:
    case "ASSET_TYPE_SERVER":
      return ProvisioningQuota_AssetType.ASSET_TYPE_SERVER;
    case 2:
    case "ASSET_TYPE_STORAGE":
      return ProvisioningQuota_AssetType.ASSET_TYPE_STORAGE;
    case 3:
    case "ASSET_TYPE_NETWORK":
      return ProvisioningQuota_AssetType.ASSET_TYPE_NETWORK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProvisioningQuota_AssetType.UNRECOGNIZED;
  }
}

export function provisioningQuota_AssetTypeToJSON(object: ProvisioningQuota_AssetType): string {
  switch (object) {
    case ProvisioningQuota_AssetType.ASSET_TYPE_UNSPECIFIED:
      return "ASSET_TYPE_UNSPECIFIED";
    case ProvisioningQuota_AssetType.ASSET_TYPE_SERVER:
      return "ASSET_TYPE_SERVER";
    case ProvisioningQuota_AssetType.ASSET_TYPE_STORAGE:
      return "ASSET_TYPE_STORAGE";
    case ProvisioningQuota_AssetType.ASSET_TYPE_NETWORK:
      return "ASSET_TYPE_NETWORK";
    case ProvisioningQuota_AssetType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message for requesting the list of provisioning quotas. */
export interface ListProvisioningQuotasRequest {
  /** Required. Parent value for ListProvisioningQuotasRequest. */
  parent: string;
  /**
   * Requested page size. The server might return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   * Notice that page_size field is not supported and won't be respected in
   * the API request for now, will be updated when pagination is supported.
   */
  pageSize: number;
  /** A token identifying a page of results from the server. */
  pageToken: string;
}

/** Response message for the list of provisioning quotas. */
export interface ListProvisioningQuotasResponse {
  /** The provisioning quotas registered in this project. */
  provisioningQuotas: ProvisioningQuota[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
}

/** Configuration parameters for a new instance. */
export interface InstanceConfig {
  /** Output only. The name of the instance config. */
  name: string;
  /**
   * A transient unique identifier to idenfity an instance within an
   * ProvisioningConfig request.
   */
  id: string;
  /**
   * Instance type.
   * [Available
   * types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
   */
  instanceType: string;
  /** Whether the instance should be provisioned with Hyperthreading enabled. */
  hyperthreading: boolean;
  /**
   * OS image to initialize the instance.
   * [Available
   * images](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
   */
  osImage: string;
  /**
   * Client network address. Filled if InstanceConfig.multivlan_config is false.
   *
   * @deprecated
   */
  clientNetwork:
    | InstanceConfig_NetworkAddress
    | undefined;
  /**
   * Private network address, if any. Filled if InstanceConfig.multivlan_config
   * is false.
   *
   * @deprecated
   */
  privateNetwork:
    | InstanceConfig_NetworkAddress
    | undefined;
  /**
   * User note field, it can be used by customers to add additional information
   * for the BMS Ops team .
   */
  userNote: string;
  /** If true networks can be from different projects of the same vendor account. */
  accountNetworksEnabled: boolean;
  /** The type of network configuration on the instance. */
  networkConfig: InstanceConfig_NetworkConfig;
  /**
   * Server network template name. Filled if InstanceConfig.multivlan_config is
   * true.
   */
  networkTemplate: string;
  /**
   * List of logical interfaces for the instance. The number of logical
   * interfaces will be the same as number of hardware bond/nic on the chosen
   * network template. Filled if InstanceConfig.multivlan_config is true.
   */
  logicalInterfaces: LogicalInterface[];
  /** List of names of ssh keys used to provision the instance. */
  sshKeyNames: string[];
}

/** The network configuration of the instance. */
export enum InstanceConfig_NetworkConfig {
  /** NETWORKCONFIG_UNSPECIFIED - The unspecified network configuration. */
  NETWORKCONFIG_UNSPECIFIED = 0,
  /** SINGLE_VLAN - Instance part of single client network and single private network. */
  SINGLE_VLAN = 1,
  /**
   * MULTI_VLAN - Instance part of multiple (or single) client networks and private
   * networks.
   */
  MULTI_VLAN = 2,
  UNRECOGNIZED = -1,
}

export function instanceConfig_NetworkConfigFromJSON(object: any): InstanceConfig_NetworkConfig {
  switch (object) {
    case 0:
    case "NETWORKCONFIG_UNSPECIFIED":
      return InstanceConfig_NetworkConfig.NETWORKCONFIG_UNSPECIFIED;
    case 1:
    case "SINGLE_VLAN":
      return InstanceConfig_NetworkConfig.SINGLE_VLAN;
    case 2:
    case "MULTI_VLAN":
      return InstanceConfig_NetworkConfig.MULTI_VLAN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstanceConfig_NetworkConfig.UNRECOGNIZED;
  }
}

export function instanceConfig_NetworkConfigToJSON(object: InstanceConfig_NetworkConfig): string {
  switch (object) {
    case InstanceConfig_NetworkConfig.NETWORKCONFIG_UNSPECIFIED:
      return "NETWORKCONFIG_UNSPECIFIED";
    case InstanceConfig_NetworkConfig.SINGLE_VLAN:
      return "SINGLE_VLAN";
    case InstanceConfig_NetworkConfig.MULTI_VLAN:
      return "MULTI_VLAN";
    case InstanceConfig_NetworkConfig.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A network. */
export interface InstanceConfig_NetworkAddress {
  /** Id of the network to use, within the same ProvisioningConfig request. */
  networkId: string;
  /** IPv4 address to be assigned to the server. */
  address: string;
  /** Name of the existing network to use. */
  existingNetworkId: string;
}

/** Configuration parameters for a new volume. */
export interface VolumeConfig {
  /** Output only. The name of the volume config. */
  name: string;
  /**
   * A transient unique identifier to identify a volume within an
   * ProvisioningConfig request.
   */
  id: string;
  /** Whether snapshots should be enabled. */
  snapshotsEnabled: boolean;
  /** The type of this Volume. */
  type: VolumeConfig_Type;
  /** Volume protocol. */
  protocol: VolumeConfig_Protocol;
  /** The requested size of this volume, in GB. */
  sizeGb: number;
  /** LUN ranges to be configured. Set only when protocol is PROTOCOL_FC. */
  lunRanges: VolumeConfig_LunRange[];
  /**
   * Machine ids connected to this volume. Set only when protocol is
   * PROTOCOL_FC.
   */
  machineIds: string[];
  /** NFS exports. Set only when protocol is PROTOCOL_NFS. */
  nfsExports: VolumeConfig_NfsExport[];
  /**
   * User note field, it can be used by customers to add additional information
   * for the BMS Ops team .
   */
  userNote: string;
  /**
   * The GCP service of the storage volume. Available gcp_service are in
   * https://cloud.google.com/bare-metal/docs/bms-planning.
   */
  gcpService: string;
  /**
   * Performance tier of the Volume.
   * Default is SHARED.
   */
  performanceTier: VolumePerformanceTier;
}

/** The types of Volumes. */
export enum VolumeConfig_Type {
  /** TYPE_UNSPECIFIED - The unspecified type. */
  TYPE_UNSPECIFIED = 0,
  /** FLASH - This Volume is on flash. */
  FLASH = 1,
  /** DISK - This Volume is on disk. */
  DISK = 2,
  UNRECOGNIZED = -1,
}

export function volumeConfig_TypeFromJSON(object: any): VolumeConfig_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return VolumeConfig_Type.TYPE_UNSPECIFIED;
    case 1:
    case "FLASH":
      return VolumeConfig_Type.FLASH;
    case 2:
    case "DISK":
      return VolumeConfig_Type.DISK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VolumeConfig_Type.UNRECOGNIZED;
  }
}

export function volumeConfig_TypeToJSON(object: VolumeConfig_Type): string {
  switch (object) {
    case VolumeConfig_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case VolumeConfig_Type.FLASH:
      return "FLASH";
    case VolumeConfig_Type.DISK:
      return "DISK";
    case VolumeConfig_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The protocol used to access the volume. */
export enum VolumeConfig_Protocol {
  /** PROTOCOL_UNSPECIFIED - Unspecified value. */
  PROTOCOL_UNSPECIFIED = 0,
  /** PROTOCOL_FC - Fibre channel. */
  PROTOCOL_FC = 1,
  /** PROTOCOL_NFS - Network file system. */
  PROTOCOL_NFS = 2,
  UNRECOGNIZED = -1,
}

export function volumeConfig_ProtocolFromJSON(object: any): VolumeConfig_Protocol {
  switch (object) {
    case 0:
    case "PROTOCOL_UNSPECIFIED":
      return VolumeConfig_Protocol.PROTOCOL_UNSPECIFIED;
    case 1:
    case "PROTOCOL_FC":
      return VolumeConfig_Protocol.PROTOCOL_FC;
    case 2:
    case "PROTOCOL_NFS":
      return VolumeConfig_Protocol.PROTOCOL_NFS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VolumeConfig_Protocol.UNRECOGNIZED;
  }
}

export function volumeConfig_ProtocolToJSON(object: VolumeConfig_Protocol): string {
  switch (object) {
    case VolumeConfig_Protocol.PROTOCOL_UNSPECIFIED:
      return "PROTOCOL_UNSPECIFIED";
    case VolumeConfig_Protocol.PROTOCOL_FC:
      return "PROTOCOL_FC";
    case VolumeConfig_Protocol.PROTOCOL_NFS:
      return "PROTOCOL_NFS";
    case VolumeConfig_Protocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A LUN(Logical Unit Number) range. */
export interface VolumeConfig_LunRange {
  /** Number of LUNs to create. */
  quantity: number;
  /** The requested size of each LUN, in GB. */
  sizeGb: number;
}

/** A NFS export entry. */
export interface VolumeConfig_NfsExport {
  /** Network to use to publish the export. */
  networkId: string;
  /**
   * Either a single machine, identified by an ID, or a comma-separated
   * list of machine IDs.
   */
  machineId?:
    | string
    | undefined;
  /** A CIDR range. */
  cidr?:
    | string
    | undefined;
  /** Export permissions. */
  permissions: VolumeConfig_NfsExport_Permissions;
  /**
   * Disable root squashing, which is a feature of NFS.
   * Root squash is a special mapping of the remote superuser (root) identity
   * when using identity authentication.
   */
  noRootSquash: boolean;
  /** Allow the setuid flag. */
  allowSuid: boolean;
  /** Allow dev flag in NfsShare AllowedClientsRequest. */
  allowDev: boolean;
}

/** Permissions that can granted for an export. */
export enum VolumeConfig_NfsExport_Permissions {
  /** PERMISSIONS_UNSPECIFIED - Unspecified value. */
  PERMISSIONS_UNSPECIFIED = 0,
  /** READ_ONLY - Read-only permission. */
  READ_ONLY = 1,
  /** READ_WRITE - Read-write permission. */
  READ_WRITE = 2,
  UNRECOGNIZED = -1,
}

export function volumeConfig_NfsExport_PermissionsFromJSON(object: any): VolumeConfig_NfsExport_Permissions {
  switch (object) {
    case 0:
    case "PERMISSIONS_UNSPECIFIED":
      return VolumeConfig_NfsExport_Permissions.PERMISSIONS_UNSPECIFIED;
    case 1:
    case "READ_ONLY":
      return VolumeConfig_NfsExport_Permissions.READ_ONLY;
    case 2:
    case "READ_WRITE":
      return VolumeConfig_NfsExport_Permissions.READ_WRITE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VolumeConfig_NfsExport_Permissions.UNRECOGNIZED;
  }
}

export function volumeConfig_NfsExport_PermissionsToJSON(object: VolumeConfig_NfsExport_Permissions): string {
  switch (object) {
    case VolumeConfig_NfsExport_Permissions.PERMISSIONS_UNSPECIFIED:
      return "PERMISSIONS_UNSPECIFIED";
    case VolumeConfig_NfsExport_Permissions.READ_ONLY:
      return "READ_ONLY";
    case VolumeConfig_NfsExport_Permissions.READ_WRITE:
      return "READ_WRITE";
    case VolumeConfig_NfsExport_Permissions.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration parameters for a new network. */
export interface NetworkConfig {
  /** Output only. The name of the network config. */
  name: string;
  /**
   * A transient unique identifier to identify a volume within an
   * ProvisioningConfig request.
   */
  id: string;
  /** The type of this network, either Client or Private. */
  type: NetworkConfig_Type;
  /** Interconnect bandwidth. Set only when type is CLIENT. */
  bandwidth: NetworkConfig_Bandwidth;
  /**
   * List of VLAN attachments. As of now there are always 2 attachments, but it
   * is going to change in  the future (multi vlan).
   */
  vlanAttachments: NetworkConfig_IntakeVlanAttachment[];
  /** CIDR range of the network. */
  cidr: string;
  /** Service CIDR, if any. */
  serviceCidr: NetworkConfig_ServiceCidr;
  /**
   * User note field, it can be used by customers to add additional information
   * for the BMS Ops team .
   */
  userNote: string;
  /**
   * The GCP service of the network. Available gcp_service are in
   * https://cloud.google.com/bare-metal/docs/bms-planning.
   */
  gcpService: string;
  /** Whether the VLAN attachment pair is located in the same project. */
  vlanSameProject: boolean;
  /** The JumboFramesEnabled option for customer to set. */
  jumboFramesEnabled: boolean;
}

/** Network type. */
export enum NetworkConfig_Type {
  /** TYPE_UNSPECIFIED - Unspecified value. */
  TYPE_UNSPECIFIED = 0,
  /** CLIENT - Client network, that is a network peered to a GCP VPC. */
  CLIENT = 1,
  /** PRIVATE - Private network, that is a network local to the BMS POD. */
  PRIVATE = 2,
  UNRECOGNIZED = -1,
}

export function networkConfig_TypeFromJSON(object: any): NetworkConfig_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return NetworkConfig_Type.TYPE_UNSPECIFIED;
    case 1:
    case "CLIENT":
      return NetworkConfig_Type.CLIENT;
    case 2:
    case "PRIVATE":
      return NetworkConfig_Type.PRIVATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkConfig_Type.UNRECOGNIZED;
  }
}

export function networkConfig_TypeToJSON(object: NetworkConfig_Type): string {
  switch (object) {
    case NetworkConfig_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case NetworkConfig_Type.CLIENT:
      return "CLIENT";
    case NetworkConfig_Type.PRIVATE:
      return "PRIVATE";
    case NetworkConfig_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Interconnect bandwidth. */
export enum NetworkConfig_Bandwidth {
  /** BANDWIDTH_UNSPECIFIED - Unspecified value. */
  BANDWIDTH_UNSPECIFIED = 0,
  /** BW_1_GBPS - 1 Gbps. */
  BW_1_GBPS = 1,
  /** BW_2_GBPS - 2 Gbps. */
  BW_2_GBPS = 2,
  /** BW_5_GBPS - 5 Gbps. */
  BW_5_GBPS = 3,
  /** BW_10_GBPS - 10 Gbps. */
  BW_10_GBPS = 4,
  UNRECOGNIZED = -1,
}

export function networkConfig_BandwidthFromJSON(object: any): NetworkConfig_Bandwidth {
  switch (object) {
    case 0:
    case "BANDWIDTH_UNSPECIFIED":
      return NetworkConfig_Bandwidth.BANDWIDTH_UNSPECIFIED;
    case 1:
    case "BW_1_GBPS":
      return NetworkConfig_Bandwidth.BW_1_GBPS;
    case 2:
    case "BW_2_GBPS":
      return NetworkConfig_Bandwidth.BW_2_GBPS;
    case 3:
    case "BW_5_GBPS":
      return NetworkConfig_Bandwidth.BW_5_GBPS;
    case 4:
    case "BW_10_GBPS":
      return NetworkConfig_Bandwidth.BW_10_GBPS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkConfig_Bandwidth.UNRECOGNIZED;
  }
}

export function networkConfig_BandwidthToJSON(object: NetworkConfig_Bandwidth): string {
  switch (object) {
    case NetworkConfig_Bandwidth.BANDWIDTH_UNSPECIFIED:
      return "BANDWIDTH_UNSPECIFIED";
    case NetworkConfig_Bandwidth.BW_1_GBPS:
      return "BW_1_GBPS";
    case NetworkConfig_Bandwidth.BW_2_GBPS:
      return "BW_2_GBPS";
    case NetworkConfig_Bandwidth.BW_5_GBPS:
      return "BW_5_GBPS";
    case NetworkConfig_Bandwidth.BW_10_GBPS:
      return "BW_10_GBPS";
    case NetworkConfig_Bandwidth.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Service network block. */
export enum NetworkConfig_ServiceCidr {
  /** SERVICE_CIDR_UNSPECIFIED - Unspecified value. */
  SERVICE_CIDR_UNSPECIFIED = 0,
  /** DISABLED - Services are disabled for the given network. */
  DISABLED = 1,
  /** HIGH_26 - Use the highest /26 block of the network to host services. */
  HIGH_26 = 2,
  /** HIGH_27 - Use the highest /27 block of the network to host services. */
  HIGH_27 = 3,
  /** HIGH_28 - Use the highest /28 block of the network to host services. */
  HIGH_28 = 4,
  UNRECOGNIZED = -1,
}

export function networkConfig_ServiceCidrFromJSON(object: any): NetworkConfig_ServiceCidr {
  switch (object) {
    case 0:
    case "SERVICE_CIDR_UNSPECIFIED":
      return NetworkConfig_ServiceCidr.SERVICE_CIDR_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return NetworkConfig_ServiceCidr.DISABLED;
    case 2:
    case "HIGH_26":
      return NetworkConfig_ServiceCidr.HIGH_26;
    case 3:
    case "HIGH_27":
      return NetworkConfig_ServiceCidr.HIGH_27;
    case 4:
    case "HIGH_28":
      return NetworkConfig_ServiceCidr.HIGH_28;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkConfig_ServiceCidr.UNRECOGNIZED;
  }
}

export function networkConfig_ServiceCidrToJSON(object: NetworkConfig_ServiceCidr): string {
  switch (object) {
    case NetworkConfig_ServiceCidr.SERVICE_CIDR_UNSPECIFIED:
      return "SERVICE_CIDR_UNSPECIFIED";
    case NetworkConfig_ServiceCidr.DISABLED:
      return "DISABLED";
    case NetworkConfig_ServiceCidr.HIGH_26:
      return "HIGH_26";
    case NetworkConfig_ServiceCidr.HIGH_27:
      return "HIGH_27";
    case NetworkConfig_ServiceCidr.HIGH_28:
      return "HIGH_28";
    case NetworkConfig_ServiceCidr.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A GCP vlan attachment. */
export interface NetworkConfig_IntakeVlanAttachment {
  /** Identifier of the VLAN attachment. */
  id: string;
  /** Attachment pairing key. */
  pairingKey: string;
}

/** A resource budget. */
export interface InstanceQuota {
  /** Output only. The name of the instance quota. */
  name: string;
  /**
   * Instance type.
   * Deprecated: use gcp_service.
   *
   * @deprecated
   */
  instanceType: string;
  /** The gcp service of the provisioning quota. */
  gcpService: string;
  /** Location where the quota applies. */
  location: string;
  /**
   * Number of machines than can be created for the given location and
   * instance_type.
   */
  availableMachineCount: number;
}

/** Request for GetProvisioningConfig. */
export interface GetProvisioningConfigRequest {
  /** Required. Name of the ProvisioningConfig. */
  name: string;
}

/** Request for CreateProvisioningConfig. */
export interface CreateProvisioningConfigRequest {
  /**
   * Required. The parent project and location containing the
   * ProvisioningConfig.
   */
  parent: string;
  /** Required. The ProvisioningConfig to create. */
  provisioningConfig:
    | ProvisioningConfig
    | undefined;
  /**
   * Optional. Email provided to send a confirmation with provisioning config
   * to.
   */
  email: string;
}

/** Message for updating a ProvisioningConfig. */
export interface UpdateProvisioningConfigRequest {
  /** Required. The ProvisioningConfig to update. */
  provisioningConfig:
    | ProvisioningConfig
    | undefined;
  /** Required. The list of fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. Email provided to send a confirmation with provisioning config
   * to.
   */
  email: string;
}

function createBaseProvisioningConfig(): ProvisioningConfig {
  return {
    name: "",
    instances: [],
    networks: [],
    volumes: [],
    ticketId: "",
    handoverServiceAccount: "",
    email: "",
    state: 0,
    location: "",
    updateTime: undefined,
    cloudConsoleUri: "",
    vpcScEnabled: false,
    statusMessage: "",
    customId: "",
  };
}

export const ProvisioningConfig: MessageFns<ProvisioningConfig> = {
  encode(message: ProvisioningConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.instances) {
      InstanceConfig.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.networks) {
      NetworkConfig.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.volumes) {
      VolumeConfig.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.ticketId !== "") {
      writer.uint32(42).string(message.ticketId);
    }
    if (message.handoverServiceAccount !== "") {
      writer.uint32(50).string(message.handoverServiceAccount);
    }
    if (message.email !== "") {
      writer.uint32(58).string(message.email);
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.location !== "") {
      writer.uint32(74).string(message.location);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.cloudConsoleUri !== "") {
      writer.uint32(90).string(message.cloudConsoleUri);
    }
    if (message.vpcScEnabled !== false) {
      writer.uint32(96).bool(message.vpcScEnabled);
    }
    if (message.statusMessage !== "") {
      writer.uint32(106).string(message.statusMessage);
    }
    if (message.customId !== "") {
      writer.uint32(114).string(message.customId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProvisioningConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvisioningConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instances.push(InstanceConfig.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.networks.push(NetworkConfig.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.volumes.push(VolumeConfig.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ticketId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.handoverServiceAccount = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.email = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.location = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.cloudConsoleUri = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.vpcScEnabled = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.customId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProvisioningConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => InstanceConfig.fromJSON(e))
        : [],
      networks: globalThis.Array.isArray(object?.networks)
        ? object.networks.map((e: any) => NetworkConfig.fromJSON(e))
        : [],
      volumes: globalThis.Array.isArray(object?.volumes)
        ? object.volumes.map((e: any) => VolumeConfig.fromJSON(e))
        : [],
      ticketId: isSet(object.ticketId) ? globalThis.String(object.ticketId) : "",
      handoverServiceAccount: isSet(object.handoverServiceAccount)
        ? globalThis.String(object.handoverServiceAccount)
        : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      state: isSet(object.state) ? provisioningConfig_StateFromJSON(object.state) : 0,
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      cloudConsoleUri: isSet(object.cloudConsoleUri) ? globalThis.String(object.cloudConsoleUri) : "",
      vpcScEnabled: isSet(object.vpcScEnabled) ? globalThis.Boolean(object.vpcScEnabled) : false,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      customId: isSet(object.customId) ? globalThis.String(object.customId) : "",
    };
  },

  toJSON(message: ProvisioningConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => InstanceConfig.toJSON(e));
    }
    if (message.networks?.length) {
      obj.networks = message.networks.map((e) => NetworkConfig.toJSON(e));
    }
    if (message.volumes?.length) {
      obj.volumes = message.volumes.map((e) => VolumeConfig.toJSON(e));
    }
    if (message.ticketId !== "") {
      obj.ticketId = message.ticketId;
    }
    if (message.handoverServiceAccount !== "") {
      obj.handoverServiceAccount = message.handoverServiceAccount;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.state !== 0) {
      obj.state = provisioningConfig_StateToJSON(message.state);
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.cloudConsoleUri !== "") {
      obj.cloudConsoleUri = message.cloudConsoleUri;
    }
    if (message.vpcScEnabled !== false) {
      obj.vpcScEnabled = message.vpcScEnabled;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.customId !== "") {
      obj.customId = message.customId;
    }
    return obj;
  },

  create(base?: DeepPartial<ProvisioningConfig>): ProvisioningConfig {
    return ProvisioningConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProvisioningConfig>): ProvisioningConfig {
    const message = createBaseProvisioningConfig();
    message.name = object.name ?? "";
    message.instances = object.instances?.map((e) => InstanceConfig.fromPartial(e)) || [];
    message.networks = object.networks?.map((e) => NetworkConfig.fromPartial(e)) || [];
    message.volumes = object.volumes?.map((e) => VolumeConfig.fromPartial(e)) || [];
    message.ticketId = object.ticketId ?? "";
    message.handoverServiceAccount = object.handoverServiceAccount ?? "";
    message.email = object.email ?? "";
    message.state = object.state ?? 0;
    message.location = object.location ?? "";
    message.updateTime = object.updateTime ?? undefined;
    message.cloudConsoleUri = object.cloudConsoleUri ?? "";
    message.vpcScEnabled = object.vpcScEnabled ?? false;
    message.statusMessage = object.statusMessage ?? "";
    message.customId = object.customId ?? "";
    return message;
  },
};

function createBaseSubmitProvisioningConfigRequest(): SubmitProvisioningConfigRequest {
  return { parent: "", provisioningConfig: undefined, email: "" };
}

export const SubmitProvisioningConfigRequest: MessageFns<SubmitProvisioningConfigRequest> = {
  encode(message: SubmitProvisioningConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.provisioningConfig !== undefined) {
      ProvisioningConfig.encode(message.provisioningConfig, writer.uint32(18).fork()).join();
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitProvisioningConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitProvisioningConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.provisioningConfig = ProvisioningConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitProvisioningConfigRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      provisioningConfig: isSet(object.provisioningConfig)
        ? ProvisioningConfig.fromJSON(object.provisioningConfig)
        : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: SubmitProvisioningConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.provisioningConfig !== undefined) {
      obj.provisioningConfig = ProvisioningConfig.toJSON(message.provisioningConfig);
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<SubmitProvisioningConfigRequest>): SubmitProvisioningConfigRequest {
    return SubmitProvisioningConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitProvisioningConfigRequest>): SubmitProvisioningConfigRequest {
    const message = createBaseSubmitProvisioningConfigRequest();
    message.parent = object.parent ?? "";
    message.provisioningConfig = (object.provisioningConfig !== undefined && object.provisioningConfig !== null)
      ? ProvisioningConfig.fromPartial(object.provisioningConfig)
      : undefined;
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseSubmitProvisioningConfigResponse(): SubmitProvisioningConfigResponse {
  return { provisioningConfig: undefined };
}

export const SubmitProvisioningConfigResponse: MessageFns<SubmitProvisioningConfigResponse> = {
  encode(message: SubmitProvisioningConfigResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provisioningConfig !== undefined) {
      ProvisioningConfig.encode(message.provisioningConfig, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitProvisioningConfigResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitProvisioningConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provisioningConfig = ProvisioningConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitProvisioningConfigResponse {
    return {
      provisioningConfig: isSet(object.provisioningConfig)
        ? ProvisioningConfig.fromJSON(object.provisioningConfig)
        : undefined,
    };
  },

  toJSON(message: SubmitProvisioningConfigResponse): unknown {
    const obj: any = {};
    if (message.provisioningConfig !== undefined) {
      obj.provisioningConfig = ProvisioningConfig.toJSON(message.provisioningConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<SubmitProvisioningConfigResponse>): SubmitProvisioningConfigResponse {
    return SubmitProvisioningConfigResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubmitProvisioningConfigResponse>): SubmitProvisioningConfigResponse {
    const message = createBaseSubmitProvisioningConfigResponse();
    message.provisioningConfig = (object.provisioningConfig !== undefined && object.provisioningConfig !== null)
      ? ProvisioningConfig.fromPartial(object.provisioningConfig)
      : undefined;
    return message;
  },
};

function createBaseProvisioningQuota(): ProvisioningQuota {
  return {
    name: "",
    assetType: 0,
    gcpService: "",
    location: "",
    availableCount: 0,
    instanceQuota: undefined,
    serverCount: undefined,
    networkBandwidth: undefined,
    storageGib: undefined,
  };
}

export const ProvisioningQuota: MessageFns<ProvisioningQuota> = {
  encode(message: ProvisioningQuota, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.assetType !== 0) {
      writer.uint32(16).int32(message.assetType);
    }
    if (message.gcpService !== "") {
      writer.uint32(26).string(message.gcpService);
    }
    if (message.location !== "") {
      writer.uint32(34).string(message.location);
    }
    if (message.availableCount !== 0) {
      writer.uint32(40).int32(message.availableCount);
    }
    if (message.instanceQuota !== undefined) {
      InstanceQuota.encode(message.instanceQuota, writer.uint32(50).fork()).join();
    }
    if (message.serverCount !== undefined) {
      writer.uint32(56).int64(message.serverCount.toString());
    }
    if (message.networkBandwidth !== undefined) {
      writer.uint32(64).int64(message.networkBandwidth.toString());
    }
    if (message.storageGib !== undefined) {
      writer.uint32(72).int64(message.storageGib.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProvisioningQuota {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProvisioningQuota();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.assetType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.gcpService = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.location = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.availableCount = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.instanceQuota = InstanceQuota.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.serverCount = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.networkBandwidth = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.storageGib = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProvisioningQuota {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      assetType: isSet(object.assetType) ? provisioningQuota_AssetTypeFromJSON(object.assetType) : 0,
      gcpService: isSet(object.gcpService) ? globalThis.String(object.gcpService) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      availableCount: isSet(object.availableCount) ? globalThis.Number(object.availableCount) : 0,
      instanceQuota: isSet(object.instanceQuota) ? InstanceQuota.fromJSON(object.instanceQuota) : undefined,
      serverCount: isSet(object.serverCount) ? Long.fromValue(object.serverCount) : undefined,
      networkBandwidth: isSet(object.networkBandwidth) ? Long.fromValue(object.networkBandwidth) : undefined,
      storageGib: isSet(object.storageGib) ? Long.fromValue(object.storageGib) : undefined,
    };
  },

  toJSON(message: ProvisioningQuota): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.assetType !== 0) {
      obj.assetType = provisioningQuota_AssetTypeToJSON(message.assetType);
    }
    if (message.gcpService !== "") {
      obj.gcpService = message.gcpService;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.availableCount !== 0) {
      obj.availableCount = Math.round(message.availableCount);
    }
    if (message.instanceQuota !== undefined) {
      obj.instanceQuota = InstanceQuota.toJSON(message.instanceQuota);
    }
    if (message.serverCount !== undefined) {
      obj.serverCount = (message.serverCount || Long.ZERO).toString();
    }
    if (message.networkBandwidth !== undefined) {
      obj.networkBandwidth = (message.networkBandwidth || Long.ZERO).toString();
    }
    if (message.storageGib !== undefined) {
      obj.storageGib = (message.storageGib || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ProvisioningQuota>): ProvisioningQuota {
    return ProvisioningQuota.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProvisioningQuota>): ProvisioningQuota {
    const message = createBaseProvisioningQuota();
    message.name = object.name ?? "";
    message.assetType = object.assetType ?? 0;
    message.gcpService = object.gcpService ?? "";
    message.location = object.location ?? "";
    message.availableCount = object.availableCount ?? 0;
    message.instanceQuota = (object.instanceQuota !== undefined && object.instanceQuota !== null)
      ? InstanceQuota.fromPartial(object.instanceQuota)
      : undefined;
    message.serverCount = (object.serverCount !== undefined && object.serverCount !== null)
      ? Long.fromValue(object.serverCount)
      : undefined;
    message.networkBandwidth = (object.networkBandwidth !== undefined && object.networkBandwidth !== null)
      ? Long.fromValue(object.networkBandwidth)
      : undefined;
    message.storageGib = (object.storageGib !== undefined && object.storageGib !== null)
      ? Long.fromValue(object.storageGib)
      : undefined;
    return message;
  },
};

function createBaseListProvisioningQuotasRequest(): ListProvisioningQuotasRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListProvisioningQuotasRequest: MessageFns<ListProvisioningQuotasRequest> = {
  encode(message: ListProvisioningQuotasRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProvisioningQuotasRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProvisioningQuotasRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProvisioningQuotasRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListProvisioningQuotasRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProvisioningQuotasRequest>): ListProvisioningQuotasRequest {
    return ListProvisioningQuotasRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProvisioningQuotasRequest>): ListProvisioningQuotasRequest {
    const message = createBaseListProvisioningQuotasRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListProvisioningQuotasResponse(): ListProvisioningQuotasResponse {
  return { provisioningQuotas: [], nextPageToken: "" };
}

export const ListProvisioningQuotasResponse: MessageFns<ListProvisioningQuotasResponse> = {
  encode(message: ListProvisioningQuotasResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.provisioningQuotas) {
      ProvisioningQuota.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProvisioningQuotasResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProvisioningQuotasResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provisioningQuotas.push(ProvisioningQuota.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProvisioningQuotasResponse {
    return {
      provisioningQuotas: globalThis.Array.isArray(object?.provisioningQuotas)
        ? object.provisioningQuotas.map((e: any) => ProvisioningQuota.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListProvisioningQuotasResponse): unknown {
    const obj: any = {};
    if (message.provisioningQuotas?.length) {
      obj.provisioningQuotas = message.provisioningQuotas.map((e) => ProvisioningQuota.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListProvisioningQuotasResponse>): ListProvisioningQuotasResponse {
    return ListProvisioningQuotasResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListProvisioningQuotasResponse>): ListProvisioningQuotasResponse {
    const message = createBaseListProvisioningQuotasResponse();
    message.provisioningQuotas = object.provisioningQuotas?.map((e) => ProvisioningQuota.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseInstanceConfig(): InstanceConfig {
  return {
    name: "",
    id: "",
    instanceType: "",
    hyperthreading: false,
    osImage: "",
    clientNetwork: undefined,
    privateNetwork: undefined,
    userNote: "",
    accountNetworksEnabled: false,
    networkConfig: 0,
    networkTemplate: "",
    logicalInterfaces: [],
    sshKeyNames: [],
  };
}

export const InstanceConfig: MessageFns<InstanceConfig> = {
  encode(message: InstanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.instanceType !== "") {
      writer.uint32(26).string(message.instanceType);
    }
    if (message.hyperthreading !== false) {
      writer.uint32(32).bool(message.hyperthreading);
    }
    if (message.osImage !== "") {
      writer.uint32(42).string(message.osImage);
    }
    if (message.clientNetwork !== undefined) {
      InstanceConfig_NetworkAddress.encode(message.clientNetwork, writer.uint32(50).fork()).join();
    }
    if (message.privateNetwork !== undefined) {
      InstanceConfig_NetworkAddress.encode(message.privateNetwork, writer.uint32(58).fork()).join();
    }
    if (message.userNote !== "") {
      writer.uint32(66).string(message.userNote);
    }
    if (message.accountNetworksEnabled !== false) {
      writer.uint32(72).bool(message.accountNetworksEnabled);
    }
    if (message.networkConfig !== 0) {
      writer.uint32(80).int32(message.networkConfig);
    }
    if (message.networkTemplate !== "") {
      writer.uint32(90).string(message.networkTemplate);
    }
    for (const v of message.logicalInterfaces) {
      LogicalInterface.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.sshKeyNames) {
      writer.uint32(106).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instanceType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.hyperthreading = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.osImage = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.clientNetwork = InstanceConfig_NetworkAddress.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.privateNetwork = InstanceConfig_NetworkAddress.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.userNote = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.accountNetworksEnabled = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.networkConfig = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.networkTemplate = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.logicalInterfaces.push(LogicalInterface.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.sshKeyNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      instanceType: isSet(object.instanceType) ? globalThis.String(object.instanceType) : "",
      hyperthreading: isSet(object.hyperthreading) ? globalThis.Boolean(object.hyperthreading) : false,
      osImage: isSet(object.osImage) ? globalThis.String(object.osImage) : "",
      clientNetwork: isSet(object.clientNetwork)
        ? InstanceConfig_NetworkAddress.fromJSON(object.clientNetwork)
        : undefined,
      privateNetwork: isSet(object.privateNetwork)
        ? InstanceConfig_NetworkAddress.fromJSON(object.privateNetwork)
        : undefined,
      userNote: isSet(object.userNote) ? globalThis.String(object.userNote) : "",
      accountNetworksEnabled: isSet(object.accountNetworksEnabled)
        ? globalThis.Boolean(object.accountNetworksEnabled)
        : false,
      networkConfig: isSet(object.networkConfig) ? instanceConfig_NetworkConfigFromJSON(object.networkConfig) : 0,
      networkTemplate: isSet(object.networkTemplate) ? globalThis.String(object.networkTemplate) : "",
      logicalInterfaces: globalThis.Array.isArray(object?.logicalInterfaces)
        ? object.logicalInterfaces.map((e: any) => LogicalInterface.fromJSON(e))
        : [],
      sshKeyNames: globalThis.Array.isArray(object?.sshKeyNames)
        ? object.sshKeyNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: InstanceConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.instanceType !== "") {
      obj.instanceType = message.instanceType;
    }
    if (message.hyperthreading !== false) {
      obj.hyperthreading = message.hyperthreading;
    }
    if (message.osImage !== "") {
      obj.osImage = message.osImage;
    }
    if (message.clientNetwork !== undefined) {
      obj.clientNetwork = InstanceConfig_NetworkAddress.toJSON(message.clientNetwork);
    }
    if (message.privateNetwork !== undefined) {
      obj.privateNetwork = InstanceConfig_NetworkAddress.toJSON(message.privateNetwork);
    }
    if (message.userNote !== "") {
      obj.userNote = message.userNote;
    }
    if (message.accountNetworksEnabled !== false) {
      obj.accountNetworksEnabled = message.accountNetworksEnabled;
    }
    if (message.networkConfig !== 0) {
      obj.networkConfig = instanceConfig_NetworkConfigToJSON(message.networkConfig);
    }
    if (message.networkTemplate !== "") {
      obj.networkTemplate = message.networkTemplate;
    }
    if (message.logicalInterfaces?.length) {
      obj.logicalInterfaces = message.logicalInterfaces.map((e) => LogicalInterface.toJSON(e));
    }
    if (message.sshKeyNames?.length) {
      obj.sshKeyNames = message.sshKeyNames;
    }
    return obj;
  },

  create(base?: DeepPartial<InstanceConfig>): InstanceConfig {
    return InstanceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstanceConfig>): InstanceConfig {
    const message = createBaseInstanceConfig();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.instanceType = object.instanceType ?? "";
    message.hyperthreading = object.hyperthreading ?? false;
    message.osImage = object.osImage ?? "";
    message.clientNetwork = (object.clientNetwork !== undefined && object.clientNetwork !== null)
      ? InstanceConfig_NetworkAddress.fromPartial(object.clientNetwork)
      : undefined;
    message.privateNetwork = (object.privateNetwork !== undefined && object.privateNetwork !== null)
      ? InstanceConfig_NetworkAddress.fromPartial(object.privateNetwork)
      : undefined;
    message.userNote = object.userNote ?? "";
    message.accountNetworksEnabled = object.accountNetworksEnabled ?? false;
    message.networkConfig = object.networkConfig ?? 0;
    message.networkTemplate = object.networkTemplate ?? "";
    message.logicalInterfaces = object.logicalInterfaces?.map((e) => LogicalInterface.fromPartial(e)) || [];
    message.sshKeyNames = object.sshKeyNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseInstanceConfig_NetworkAddress(): InstanceConfig_NetworkAddress {
  return { networkId: "", address: "", existingNetworkId: "" };
}

export const InstanceConfig_NetworkAddress: MessageFns<InstanceConfig_NetworkAddress> = {
  encode(message: InstanceConfig_NetworkAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkId !== "") {
      writer.uint32(10).string(message.networkId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.existingNetworkId !== "") {
      writer.uint32(26).string(message.existingNetworkId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceConfig_NetworkAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceConfig_NetworkAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networkId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.existingNetworkId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceConfig_NetworkAddress {
    return {
      networkId: isSet(object.networkId) ? globalThis.String(object.networkId) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      existingNetworkId: isSet(object.existingNetworkId) ? globalThis.String(object.existingNetworkId) : "",
    };
  },

  toJSON(message: InstanceConfig_NetworkAddress): unknown {
    const obj: any = {};
    if (message.networkId !== "") {
      obj.networkId = message.networkId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.existingNetworkId !== "") {
      obj.existingNetworkId = message.existingNetworkId;
    }
    return obj;
  },

  create(base?: DeepPartial<InstanceConfig_NetworkAddress>): InstanceConfig_NetworkAddress {
    return InstanceConfig_NetworkAddress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstanceConfig_NetworkAddress>): InstanceConfig_NetworkAddress {
    const message = createBaseInstanceConfig_NetworkAddress();
    message.networkId = object.networkId ?? "";
    message.address = object.address ?? "";
    message.existingNetworkId = object.existingNetworkId ?? "";
    return message;
  },
};

function createBaseVolumeConfig(): VolumeConfig {
  return {
    name: "",
    id: "",
    snapshotsEnabled: false,
    type: 0,
    protocol: 0,
    sizeGb: 0,
    lunRanges: [],
    machineIds: [],
    nfsExports: [],
    userNote: "",
    gcpService: "",
    performanceTier: 0,
  };
}

export const VolumeConfig: MessageFns<VolumeConfig> = {
  encode(message: VolumeConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.snapshotsEnabled !== false) {
      writer.uint32(24).bool(message.snapshotsEnabled);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.protocol !== 0) {
      writer.uint32(40).int32(message.protocol);
    }
    if (message.sizeGb !== 0) {
      writer.uint32(48).int32(message.sizeGb);
    }
    for (const v of message.lunRanges) {
      VolumeConfig_LunRange.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.machineIds) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.nfsExports) {
      VolumeConfig_NfsExport.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.userNote !== "") {
      writer.uint32(82).string(message.userNote);
    }
    if (message.gcpService !== "") {
      writer.uint32(90).string(message.gcpService);
    }
    if (message.performanceTier !== 0) {
      writer.uint32(96).int32(message.performanceTier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VolumeConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolumeConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.snapshotsEnabled = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.protocol = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sizeGb = reader.int32();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lunRanges.push(VolumeConfig_LunRange.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.machineIds.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.nfsExports.push(VolumeConfig_NfsExport.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.userNote = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.gcpService = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.performanceTier = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VolumeConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      snapshotsEnabled: isSet(object.snapshotsEnabled) ? globalThis.Boolean(object.snapshotsEnabled) : false,
      type: isSet(object.type) ? volumeConfig_TypeFromJSON(object.type) : 0,
      protocol: isSet(object.protocol) ? volumeConfig_ProtocolFromJSON(object.protocol) : 0,
      sizeGb: isSet(object.sizeGb) ? globalThis.Number(object.sizeGb) : 0,
      lunRanges: globalThis.Array.isArray(object?.lunRanges)
        ? object.lunRanges.map((e: any) => VolumeConfig_LunRange.fromJSON(e))
        : [],
      machineIds: globalThis.Array.isArray(object?.machineIds)
        ? object.machineIds.map((e: any) => globalThis.String(e))
        : [],
      nfsExports: globalThis.Array.isArray(object?.nfsExports)
        ? object.nfsExports.map((e: any) => VolumeConfig_NfsExport.fromJSON(e))
        : [],
      userNote: isSet(object.userNote) ? globalThis.String(object.userNote) : "",
      gcpService: isSet(object.gcpService) ? globalThis.String(object.gcpService) : "",
      performanceTier: isSet(object.performanceTier) ? volumePerformanceTierFromJSON(object.performanceTier) : 0,
    };
  },

  toJSON(message: VolumeConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.snapshotsEnabled !== false) {
      obj.snapshotsEnabled = message.snapshotsEnabled;
    }
    if (message.type !== 0) {
      obj.type = volumeConfig_TypeToJSON(message.type);
    }
    if (message.protocol !== 0) {
      obj.protocol = volumeConfig_ProtocolToJSON(message.protocol);
    }
    if (message.sizeGb !== 0) {
      obj.sizeGb = Math.round(message.sizeGb);
    }
    if (message.lunRanges?.length) {
      obj.lunRanges = message.lunRanges.map((e) => VolumeConfig_LunRange.toJSON(e));
    }
    if (message.machineIds?.length) {
      obj.machineIds = message.machineIds;
    }
    if (message.nfsExports?.length) {
      obj.nfsExports = message.nfsExports.map((e) => VolumeConfig_NfsExport.toJSON(e));
    }
    if (message.userNote !== "") {
      obj.userNote = message.userNote;
    }
    if (message.gcpService !== "") {
      obj.gcpService = message.gcpService;
    }
    if (message.performanceTier !== 0) {
      obj.performanceTier = volumePerformanceTierToJSON(message.performanceTier);
    }
    return obj;
  },

  create(base?: DeepPartial<VolumeConfig>): VolumeConfig {
    return VolumeConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VolumeConfig>): VolumeConfig {
    const message = createBaseVolumeConfig();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.snapshotsEnabled = object.snapshotsEnabled ?? false;
    message.type = object.type ?? 0;
    message.protocol = object.protocol ?? 0;
    message.sizeGb = object.sizeGb ?? 0;
    message.lunRanges = object.lunRanges?.map((e) => VolumeConfig_LunRange.fromPartial(e)) || [];
    message.machineIds = object.machineIds?.map((e) => e) || [];
    message.nfsExports = object.nfsExports?.map((e) => VolumeConfig_NfsExport.fromPartial(e)) || [];
    message.userNote = object.userNote ?? "";
    message.gcpService = object.gcpService ?? "";
    message.performanceTier = object.performanceTier ?? 0;
    return message;
  },
};

function createBaseVolumeConfig_LunRange(): VolumeConfig_LunRange {
  return { quantity: 0, sizeGb: 0 };
}

export const VolumeConfig_LunRange: MessageFns<VolumeConfig_LunRange> = {
  encode(message: VolumeConfig_LunRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quantity !== 0) {
      writer.uint32(8).int32(message.quantity);
    }
    if (message.sizeGb !== 0) {
      writer.uint32(16).int32(message.sizeGb);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VolumeConfig_LunRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolumeConfig_LunRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sizeGb = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VolumeConfig_LunRange {
    return {
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      sizeGb: isSet(object.sizeGb) ? globalThis.Number(object.sizeGb) : 0,
    };
  },

  toJSON(message: VolumeConfig_LunRange): unknown {
    const obj: any = {};
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.sizeGb !== 0) {
      obj.sizeGb = Math.round(message.sizeGb);
    }
    return obj;
  },

  create(base?: DeepPartial<VolumeConfig_LunRange>): VolumeConfig_LunRange {
    return VolumeConfig_LunRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VolumeConfig_LunRange>): VolumeConfig_LunRange {
    const message = createBaseVolumeConfig_LunRange();
    message.quantity = object.quantity ?? 0;
    message.sizeGb = object.sizeGb ?? 0;
    return message;
  },
};

function createBaseVolumeConfig_NfsExport(): VolumeConfig_NfsExport {
  return {
    networkId: "",
    machineId: undefined,
    cidr: undefined,
    permissions: 0,
    noRootSquash: false,
    allowSuid: false,
    allowDev: false,
  };
}

export const VolumeConfig_NfsExport: MessageFns<VolumeConfig_NfsExport> = {
  encode(message: VolumeConfig_NfsExport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.networkId !== "") {
      writer.uint32(10).string(message.networkId);
    }
    if (message.machineId !== undefined) {
      writer.uint32(18).string(message.machineId);
    }
    if (message.cidr !== undefined) {
      writer.uint32(26).string(message.cidr);
    }
    if (message.permissions !== 0) {
      writer.uint32(32).int32(message.permissions);
    }
    if (message.noRootSquash !== false) {
      writer.uint32(40).bool(message.noRootSquash);
    }
    if (message.allowSuid !== false) {
      writer.uint32(48).bool(message.allowSuid);
    }
    if (message.allowDev !== false) {
      writer.uint32(56).bool(message.allowDev);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VolumeConfig_NfsExport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolumeConfig_NfsExport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networkId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.machineId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.cidr = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.permissions = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.noRootSquash = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.allowSuid = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.allowDev = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VolumeConfig_NfsExport {
    return {
      networkId: isSet(object.networkId) ? globalThis.String(object.networkId) : "",
      machineId: isSet(object.machineId) ? globalThis.String(object.machineId) : undefined,
      cidr: isSet(object.cidr) ? globalThis.String(object.cidr) : undefined,
      permissions: isSet(object.permissions) ? volumeConfig_NfsExport_PermissionsFromJSON(object.permissions) : 0,
      noRootSquash: isSet(object.noRootSquash) ? globalThis.Boolean(object.noRootSquash) : false,
      allowSuid: isSet(object.allowSuid) ? globalThis.Boolean(object.allowSuid) : false,
      allowDev: isSet(object.allowDev) ? globalThis.Boolean(object.allowDev) : false,
    };
  },

  toJSON(message: VolumeConfig_NfsExport): unknown {
    const obj: any = {};
    if (message.networkId !== "") {
      obj.networkId = message.networkId;
    }
    if (message.machineId !== undefined) {
      obj.machineId = message.machineId;
    }
    if (message.cidr !== undefined) {
      obj.cidr = message.cidr;
    }
    if (message.permissions !== 0) {
      obj.permissions = volumeConfig_NfsExport_PermissionsToJSON(message.permissions);
    }
    if (message.noRootSquash !== false) {
      obj.noRootSquash = message.noRootSquash;
    }
    if (message.allowSuid !== false) {
      obj.allowSuid = message.allowSuid;
    }
    if (message.allowDev !== false) {
      obj.allowDev = message.allowDev;
    }
    return obj;
  },

  create(base?: DeepPartial<VolumeConfig_NfsExport>): VolumeConfig_NfsExport {
    return VolumeConfig_NfsExport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VolumeConfig_NfsExport>): VolumeConfig_NfsExport {
    const message = createBaseVolumeConfig_NfsExport();
    message.networkId = object.networkId ?? "";
    message.machineId = object.machineId ?? undefined;
    message.cidr = object.cidr ?? undefined;
    message.permissions = object.permissions ?? 0;
    message.noRootSquash = object.noRootSquash ?? false;
    message.allowSuid = object.allowSuid ?? false;
    message.allowDev = object.allowDev ?? false;
    return message;
  },
};

function createBaseNetworkConfig(): NetworkConfig {
  return {
    name: "",
    id: "",
    type: 0,
    bandwidth: 0,
    vlanAttachments: [],
    cidr: "",
    serviceCidr: 0,
    userNote: "",
    gcpService: "",
    vlanSameProject: false,
    jumboFramesEnabled: false,
  };
}

export const NetworkConfig: MessageFns<NetworkConfig> = {
  encode(message: NetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.bandwidth !== 0) {
      writer.uint32(32).int32(message.bandwidth);
    }
    for (const v of message.vlanAttachments) {
      NetworkConfig_IntakeVlanAttachment.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.cidr !== "") {
      writer.uint32(50).string(message.cidr);
    }
    if (message.serviceCidr !== 0) {
      writer.uint32(56).int32(message.serviceCidr);
    }
    if (message.userNote !== "") {
      writer.uint32(66).string(message.userNote);
    }
    if (message.gcpService !== "") {
      writer.uint32(74).string(message.gcpService);
    }
    if (message.vlanSameProject !== false) {
      writer.uint32(80).bool(message.vlanSameProject);
    }
    if (message.jumboFramesEnabled !== false) {
      writer.uint32(88).bool(message.jumboFramesEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.bandwidth = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.vlanAttachments.push(NetworkConfig_IntakeVlanAttachment.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.cidr = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.serviceCidr = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.userNote = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.gcpService = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.vlanSameProject = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.jumboFramesEnabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? networkConfig_TypeFromJSON(object.type) : 0,
      bandwidth: isSet(object.bandwidth) ? networkConfig_BandwidthFromJSON(object.bandwidth) : 0,
      vlanAttachments: globalThis.Array.isArray(object?.vlanAttachments)
        ? object.vlanAttachments.map((e: any) => NetworkConfig_IntakeVlanAttachment.fromJSON(e))
        : [],
      cidr: isSet(object.cidr) ? globalThis.String(object.cidr) : "",
      serviceCidr: isSet(object.serviceCidr) ? networkConfig_ServiceCidrFromJSON(object.serviceCidr) : 0,
      userNote: isSet(object.userNote) ? globalThis.String(object.userNote) : "",
      gcpService: isSet(object.gcpService) ? globalThis.String(object.gcpService) : "",
      vlanSameProject: isSet(object.vlanSameProject) ? globalThis.Boolean(object.vlanSameProject) : false,
      jumboFramesEnabled: isSet(object.jumboFramesEnabled) ? globalThis.Boolean(object.jumboFramesEnabled) : false,
    };
  },

  toJSON(message: NetworkConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = networkConfig_TypeToJSON(message.type);
    }
    if (message.bandwidth !== 0) {
      obj.bandwidth = networkConfig_BandwidthToJSON(message.bandwidth);
    }
    if (message.vlanAttachments?.length) {
      obj.vlanAttachments = message.vlanAttachments.map((e) => NetworkConfig_IntakeVlanAttachment.toJSON(e));
    }
    if (message.cidr !== "") {
      obj.cidr = message.cidr;
    }
    if (message.serviceCidr !== 0) {
      obj.serviceCidr = networkConfig_ServiceCidrToJSON(message.serviceCidr);
    }
    if (message.userNote !== "") {
      obj.userNote = message.userNote;
    }
    if (message.gcpService !== "") {
      obj.gcpService = message.gcpService;
    }
    if (message.vlanSameProject !== false) {
      obj.vlanSameProject = message.vlanSameProject;
    }
    if (message.jumboFramesEnabled !== false) {
      obj.jumboFramesEnabled = message.jumboFramesEnabled;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkConfig>): NetworkConfig {
    return NetworkConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkConfig>): NetworkConfig {
    const message = createBaseNetworkConfig();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.bandwidth = object.bandwidth ?? 0;
    message.vlanAttachments = object.vlanAttachments?.map((e) => NetworkConfig_IntakeVlanAttachment.fromPartial(e)) ||
      [];
    message.cidr = object.cidr ?? "";
    message.serviceCidr = object.serviceCidr ?? 0;
    message.userNote = object.userNote ?? "";
    message.gcpService = object.gcpService ?? "";
    message.vlanSameProject = object.vlanSameProject ?? false;
    message.jumboFramesEnabled = object.jumboFramesEnabled ?? false;
    return message;
  },
};

function createBaseNetworkConfig_IntakeVlanAttachment(): NetworkConfig_IntakeVlanAttachment {
  return { id: "", pairingKey: "" };
}

export const NetworkConfig_IntakeVlanAttachment: MessageFns<NetworkConfig_IntakeVlanAttachment> = {
  encode(message: NetworkConfig_IntakeVlanAttachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pairingKey !== "") {
      writer.uint32(18).string(message.pairingKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConfig_IntakeVlanAttachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConfig_IntakeVlanAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pairingKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConfig_IntakeVlanAttachment {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pairingKey: isSet(object.pairingKey) ? globalThis.String(object.pairingKey) : "",
    };
  },

  toJSON(message: NetworkConfig_IntakeVlanAttachment): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pairingKey !== "") {
      obj.pairingKey = message.pairingKey;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkConfig_IntakeVlanAttachment>): NetworkConfig_IntakeVlanAttachment {
    return NetworkConfig_IntakeVlanAttachment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkConfig_IntakeVlanAttachment>): NetworkConfig_IntakeVlanAttachment {
    const message = createBaseNetworkConfig_IntakeVlanAttachment();
    message.id = object.id ?? "";
    message.pairingKey = object.pairingKey ?? "";
    return message;
  },
};

function createBaseInstanceQuota(): InstanceQuota {
  return { name: "", instanceType: "", gcpService: "", location: "", availableMachineCount: 0 };
}

export const InstanceQuota: MessageFns<InstanceQuota> = {
  encode(message: InstanceQuota, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.instanceType !== "") {
      writer.uint32(18).string(message.instanceType);
    }
    if (message.gcpService !== "") {
      writer.uint32(42).string(message.gcpService);
    }
    if (message.location !== "") {
      writer.uint32(26).string(message.location);
    }
    if (message.availableMachineCount !== 0) {
      writer.uint32(32).int32(message.availableMachineCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceQuota {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceQuota();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.gcpService = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.location = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.availableMachineCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceQuota {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      instanceType: isSet(object.instanceType) ? globalThis.String(object.instanceType) : "",
      gcpService: isSet(object.gcpService) ? globalThis.String(object.gcpService) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      availableMachineCount: isSet(object.availableMachineCount) ? globalThis.Number(object.availableMachineCount) : 0,
    };
  },

  toJSON(message: InstanceQuota): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.instanceType !== "") {
      obj.instanceType = message.instanceType;
    }
    if (message.gcpService !== "") {
      obj.gcpService = message.gcpService;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.availableMachineCount !== 0) {
      obj.availableMachineCount = Math.round(message.availableMachineCount);
    }
    return obj;
  },

  create(base?: DeepPartial<InstanceQuota>): InstanceQuota {
    return InstanceQuota.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstanceQuota>): InstanceQuota {
    const message = createBaseInstanceQuota();
    message.name = object.name ?? "";
    message.instanceType = object.instanceType ?? "";
    message.gcpService = object.gcpService ?? "";
    message.location = object.location ?? "";
    message.availableMachineCount = object.availableMachineCount ?? 0;
    return message;
  },
};

function createBaseGetProvisioningConfigRequest(): GetProvisioningConfigRequest {
  return { name: "" };
}

export const GetProvisioningConfigRequest: MessageFns<GetProvisioningConfigRequest> = {
  encode(message: GetProvisioningConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProvisioningConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProvisioningConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProvisioningConfigRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetProvisioningConfigRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetProvisioningConfigRequest>): GetProvisioningConfigRequest {
    return GetProvisioningConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetProvisioningConfigRequest>): GetProvisioningConfigRequest {
    const message = createBaseGetProvisioningConfigRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateProvisioningConfigRequest(): CreateProvisioningConfigRequest {
  return { parent: "", provisioningConfig: undefined, email: "" };
}

export const CreateProvisioningConfigRequest: MessageFns<CreateProvisioningConfigRequest> = {
  encode(message: CreateProvisioningConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.provisioningConfig !== undefined) {
      ProvisioningConfig.encode(message.provisioningConfig, writer.uint32(18).fork()).join();
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProvisioningConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProvisioningConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.provisioningConfig = ProvisioningConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProvisioningConfigRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      provisioningConfig: isSet(object.provisioningConfig)
        ? ProvisioningConfig.fromJSON(object.provisioningConfig)
        : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: CreateProvisioningConfigRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.provisioningConfig !== undefined) {
      obj.provisioningConfig = ProvisioningConfig.toJSON(message.provisioningConfig);
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateProvisioningConfigRequest>): CreateProvisioningConfigRequest {
    return CreateProvisioningConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateProvisioningConfigRequest>): CreateProvisioningConfigRequest {
    const message = createBaseCreateProvisioningConfigRequest();
    message.parent = object.parent ?? "";
    message.provisioningConfig = (object.provisioningConfig !== undefined && object.provisioningConfig !== null)
      ? ProvisioningConfig.fromPartial(object.provisioningConfig)
      : undefined;
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseUpdateProvisioningConfigRequest(): UpdateProvisioningConfigRequest {
  return { provisioningConfig: undefined, updateMask: undefined, email: "" };
}

export const UpdateProvisioningConfigRequest: MessageFns<UpdateProvisioningConfigRequest> = {
  encode(message: UpdateProvisioningConfigRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provisioningConfig !== undefined) {
      ProvisioningConfig.encode(message.provisioningConfig, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateProvisioningConfigRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProvisioningConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.provisioningConfig = ProvisioningConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateProvisioningConfigRequest {
    return {
      provisioningConfig: isSet(object.provisioningConfig)
        ? ProvisioningConfig.fromJSON(object.provisioningConfig)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: UpdateProvisioningConfigRequest): unknown {
    const obj: any = {};
    if (message.provisioningConfig !== undefined) {
      obj.provisioningConfig = ProvisioningConfig.toJSON(message.provisioningConfig);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateProvisioningConfigRequest>): UpdateProvisioningConfigRequest {
    return UpdateProvisioningConfigRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateProvisioningConfigRequest>): UpdateProvisioningConfigRequest {
    const message = createBaseUpdateProvisioningConfigRequest();
    message.provisioningConfig = (object.provisioningConfig !== undefined && object.provisioningConfig !== null)
      ? ProvisioningConfig.fromPartial(object.provisioningConfig)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.email = object.email ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
