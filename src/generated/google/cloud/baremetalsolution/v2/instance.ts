// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/baremetalsolution/v2/instance.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { WorkloadProfile, workloadProfileFromJSON, workloadProfileToJSON } from "./common.js";
import { Lun } from "./lun.js";
import { LogicalInterface, Network } from "./network.js";
import { Volume } from "./volume.js";

export const protobufPackage = "google.cloud.baremetalsolution.v2";

/** A server. */
export interface Instance {
  /**
   * Immutable. The resource name of this `Instance`.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * Format:
   * `projects/{project}/locations/{location}/instances/{instance}`
   */
  name: string;
  /** Output only. An identifier for the `Instance`, generated by the backend. */
  id: string;
  /** Output only. Create a time stamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Update a time stamp. */
  updateTime:
    | Date
    | undefined;
  /**
   * Immutable. The server type.
   * [Available server
   * types](https://cloud.google.com/bare-metal/docs/bms-planning#server_configurations)
   */
  machineType: string;
  /** Output only. The state of the server. */
  state: Instance_State;
  /**
   * True if you enable hyperthreading for the server, otherwise false.
   * The default value is false.
   */
  hyperthreadingEnabled: boolean;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** Immutable. List of LUNs associated with this server. */
  luns: Lun[];
  /**
   * Input only. List of Volumes to attach to this Instance on creation.
   * This field won't be populated in Get/List responses.
   */
  volumes: Volume[];
  /** Output only. List of networks associated with this server. */
  networks: Network[];
  /**
   * Output only. True if the interactive serial console feature is enabled for
   * the instance, false otherwise. The default value is false.
   */
  interactiveSerialConsoleEnabled: boolean;
  /** The OS image currently installed on the server. */
  osImage: string;
  /**
   * Immutable. Pod name.
   * Pod is an independent part of infrastructure.
   * Instance can be connected to the assets (networks, volumes) allocated
   * in the same pod only.
   */
  pod: string;
  /**
   * Instance network template name. For eg, bondaa-bondaa, bondab-nic, etc.
   * Generally, the template name follows the syntax of
   * "bond<bond_mode>" or "nic".
   */
  networkTemplate: string;
  /**
   * List of logical interfaces for the instance. The number of logical
   * interfaces will be the same as number of hardware bond/nic on the chosen
   * network template. For the non-multivlan configurations (for eg, existing
   * servers) that use existing default network template (bondaa-bondaa), both
   * the Instance.networks field and the Instance.logical_interfaces fields will
   * be filled to ensure backward compatibility. For the others, only
   * Instance.logical_interfaces will be filled.
   */
  logicalInterfaces: LogicalInterface[];
  /** Output only. Text field about info for logging in. */
  loginInfo: string;
  /** The workload profile for the instance. */
  workloadProfile: WorkloadProfile;
  /** Output only. The firmware version for the instance. */
  firmwareVersion: string;
}

/** The possible states for this server. */
export enum Instance_State {
  /** STATE_UNSPECIFIED - The server is in an unknown state. */
  STATE_UNSPECIFIED = 0,
  /** PROVISIONING - The server is being provisioned. */
  PROVISIONING = 1,
  /** RUNNING - The server is running. */
  RUNNING = 2,
  /** DELETED - The server has been deleted. */
  DELETED = 3,
  /** UPDATING - The server is being updated. */
  UPDATING = 4,
  /** STARTING - The server is starting. */
  STARTING = 5,
  /** STOPPING - The server is stopping. */
  STOPPING = 6,
  /** SHUTDOWN - The server is shutdown. */
  SHUTDOWN = 7,
  UNRECOGNIZED = -1,
}

export function instance_StateFromJSON(object: any): Instance_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Instance_State.STATE_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return Instance_State.PROVISIONING;
    case 2:
    case "RUNNING":
      return Instance_State.RUNNING;
    case 3:
    case "DELETED":
      return Instance_State.DELETED;
    case 4:
    case "UPDATING":
      return Instance_State.UPDATING;
    case 5:
    case "STARTING":
      return Instance_State.STARTING;
    case 6:
    case "STOPPING":
      return Instance_State.STOPPING;
    case 7:
    case "SHUTDOWN":
      return Instance_State.SHUTDOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_State.UNRECOGNIZED;
  }
}

export function instance_StateToJSON(object: Instance_State): string {
  switch (object) {
    case Instance_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Instance_State.PROVISIONING:
      return "PROVISIONING";
    case Instance_State.RUNNING:
      return "RUNNING";
    case Instance_State.DELETED:
      return "DELETED";
    case Instance_State.UPDATING:
      return "UPDATING";
    case Instance_State.STARTING:
      return "STARTING";
    case Instance_State.STOPPING:
      return "STOPPING";
    case Instance_State.SHUTDOWN:
      return "SHUTDOWN";
    case Instance_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Instance_LabelsEntry {
  key: string;
  value: string;
}

/** Message for requesting server information. */
export interface GetInstanceRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Message for requesting the list of servers. */
export interface ListInstancesRequest {
  /** Required. Parent value for ListInstancesRequest. */
  parent: string;
  /**
   * Requested page size. Server may return fewer items than requested.
   * If unspecified, the server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results from the server. */
  pageToken: string;
  /** List filter. */
  filter: string;
}

/** Response message for the list of servers. */
export interface ListInstancesResponse {
  /** The list of servers. */
  instances: Instance[];
  /** A token identifying a page of results from the server. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message requesting to updating a server. */
export interface UpdateInstanceRequest {
  /**
   * Required. The server to update.
   *
   * The `name` field is used to identify the instance to update.
   * Format: projects/{project}/locations/{location}/instances/{instance}
   */
  instance:
    | Instance
    | undefined;
  /**
   * The list of fields to update.
   * The currently supported fields are:
   *   `labels`
   *   `hyperthreading_enabled`
   *   `os_image`
   */
  updateMask: string[] | undefined;
}

/** Message requesting rename of a server. */
export interface RenameInstanceRequest {
  /**
   * Required. The `name` field is used to identify the instance.
   * Format: projects/{project}/locations/{location}/instances/{instance}
   */
  name: string;
  /** Required. The new `id` of the instance. */
  newInstanceId: string;
}

/** Message requesting to reset a server. */
export interface ResetInstanceRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Message requesting to start a server. */
export interface StartInstanceRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Response message from starting a server. */
export interface StartInstanceResponse {
}

/** Message requesting to stop a server. */
export interface StopInstanceRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Response message from stopping a server. */
export interface StopInstanceResponse {
}

/** Message for enabling the interactive serial console on an instance. */
export interface EnableInteractiveSerialConsoleRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Message for response of EnableInteractiveSerialConsole. */
export interface EnableInteractiveSerialConsoleResponse {
}

/** Message for disabling the interactive serial console on an instance. */
export interface DisableInteractiveSerialConsoleRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Message for response of DisableInteractiveSerialConsole. */
export interface DisableInteractiveSerialConsoleResponse {
}

/** Message for detach specific LUN from an Instance. */
export interface DetachLunRequest {
  /** Required. Name of the instance. */
  instance: string;
  /** Required. Name of the Lun to detach. */
  lun: string;
  /** If true, performs lun unmapping without instance reboot. */
  skipReboot: boolean;
}

/** Network template. */
export interface ServerNetworkTemplate {
  /**
   * Output only. Template's unique name. The full resource name follows the
   * pattern:
   * `projects/{project}/locations/{location}/serverNetworkTemplate/{server_network_template}`
   * Generally, the {server_network_template} follows the syntax of
   * "bond<interface_type_index><bond_mode>" or "nic<interface_type_index>".
   */
  name: string;
  /** Instance types this template is applicable to. */
  applicableInstanceTypes: string[];
  /** Logical interfaces. */
  logicalInterfaces: ServerNetworkTemplate_LogicalInterface[];
}

/** Logical interface. */
export interface ServerNetworkTemplate_LogicalInterface {
  /**
   * Interface name.
   * This is not a globally unique identifier.
   * Name is unique only inside the ServerNetworkTemplate. This is of syntax
   * <bond><interface_type_index><bond_mode> or <nic><interface_type_index>
   * and forms part of the network template name.
   */
  name: string;
  /** Interface type. */
  type: ServerNetworkTemplate_LogicalInterface_InterfaceType;
  /** If true, interface must have network connected. */
  required: boolean;
}

/** Interface type. */
export enum ServerNetworkTemplate_LogicalInterface_InterfaceType {
  /** INTERFACE_TYPE_UNSPECIFIED - Unspecified value. */
  INTERFACE_TYPE_UNSPECIFIED = 0,
  /** BOND - Bond interface type. */
  BOND = 1,
  /** NIC - NIC interface type. */
  NIC = 2,
  UNRECOGNIZED = -1,
}

export function serverNetworkTemplate_LogicalInterface_InterfaceTypeFromJSON(
  object: any,
): ServerNetworkTemplate_LogicalInterface_InterfaceType {
  switch (object) {
    case 0:
    case "INTERFACE_TYPE_UNSPECIFIED":
      return ServerNetworkTemplate_LogicalInterface_InterfaceType.INTERFACE_TYPE_UNSPECIFIED;
    case 1:
    case "BOND":
      return ServerNetworkTemplate_LogicalInterface_InterfaceType.BOND;
    case 2:
    case "NIC":
      return ServerNetworkTemplate_LogicalInterface_InterfaceType.NIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ServerNetworkTemplate_LogicalInterface_InterfaceType.UNRECOGNIZED;
  }
}

export function serverNetworkTemplate_LogicalInterface_InterfaceTypeToJSON(
  object: ServerNetworkTemplate_LogicalInterface_InterfaceType,
): string {
  switch (object) {
    case ServerNetworkTemplate_LogicalInterface_InterfaceType.INTERFACE_TYPE_UNSPECIFIED:
      return "INTERFACE_TYPE_UNSPECIFIED";
    case ServerNetworkTemplate_LogicalInterface_InterfaceType.BOND:
      return "BOND";
    case ServerNetworkTemplate_LogicalInterface_InterfaceType.NIC:
      return "NIC";
    case ServerNetworkTemplate_LogicalInterface_InterfaceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseInstance(): Instance {
  return {
    name: "",
    id: "",
    createTime: undefined,
    updateTime: undefined,
    machineType: "",
    state: 0,
    hyperthreadingEnabled: false,
    labels: {},
    luns: [],
    volumes: [],
    networks: [],
    interactiveSerialConsoleEnabled: false,
    osImage: "",
    pod: "",
    networkTemplate: "",
    logicalInterfaces: [],
    loginInfo: "",
    workloadProfile: 0,
    firmwareVersion: "",
  };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(90).string(message.id);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.machineType !== "") {
      writer.uint32(34).string(message.machineType);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.hyperthreadingEnabled !== false) {
      writer.uint32(48).bool(message.hyperthreadingEnabled);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Instance_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    for (const v of message.luns) {
      Lun.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.volumes) {
      Volume.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.networks) {
      Network.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.interactiveSerialConsoleEnabled !== false) {
      writer.uint32(80).bool(message.interactiveSerialConsoleEnabled);
    }
    if (message.osImage !== "") {
      writer.uint32(98).string(message.osImage);
    }
    if (message.pod !== "") {
      writer.uint32(106).string(message.pod);
    }
    if (message.networkTemplate !== "") {
      writer.uint32(114).string(message.networkTemplate);
    }
    for (const v of message.logicalInterfaces) {
      LogicalInterface.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.loginInfo !== "") {
      writer.uint32(138).string(message.loginInfo);
    }
    if (message.workloadProfile !== 0) {
      writer.uint32(144).int32(message.workloadProfile);
    }
    if (message.firmwareVersion !== "") {
      writer.uint32(154).string(message.firmwareVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.hyperthreadingEnabled = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Instance_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.luns.push(Lun.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.volumes.push(Volume.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.networks.push(Network.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.interactiveSerialConsoleEnabled = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.osImage = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.pod = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.networkTemplate = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.logicalInterfaces.push(LogicalInterface.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.loginInfo = reader.string();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.workloadProfile = reader.int32() as any;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.firmwareVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      state: isSet(object.state) ? instance_StateFromJSON(object.state) : 0,
      hyperthreadingEnabled: isSet(object.hyperthreadingEnabled)
        ? globalThis.Boolean(object.hyperthreadingEnabled)
        : false,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      luns: globalThis.Array.isArray(object?.luns) ? object.luns.map((e: any) => Lun.fromJSON(e)) : [],
      volumes: globalThis.Array.isArray(object?.volumes) ? object.volumes.map((e: any) => Volume.fromJSON(e)) : [],
      networks: globalThis.Array.isArray(object?.networks) ? object.networks.map((e: any) => Network.fromJSON(e)) : [],
      interactiveSerialConsoleEnabled: isSet(object.interactiveSerialConsoleEnabled)
        ? globalThis.Boolean(object.interactiveSerialConsoleEnabled)
        : false,
      osImage: isSet(object.osImage) ? globalThis.String(object.osImage) : "",
      pod: isSet(object.pod) ? globalThis.String(object.pod) : "",
      networkTemplate: isSet(object.networkTemplate) ? globalThis.String(object.networkTemplate) : "",
      logicalInterfaces: globalThis.Array.isArray(object?.logicalInterfaces)
        ? object.logicalInterfaces.map((e: any) => LogicalInterface.fromJSON(e))
        : [],
      loginInfo: isSet(object.loginInfo) ? globalThis.String(object.loginInfo) : "",
      workloadProfile: isSet(object.workloadProfile) ? workloadProfileFromJSON(object.workloadProfile) : 0,
      firmwareVersion: isSet(object.firmwareVersion) ? globalThis.String(object.firmwareVersion) : "",
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (message.state !== 0) {
      obj.state = instance_StateToJSON(message.state);
    }
    if (message.hyperthreadingEnabled !== false) {
      obj.hyperthreadingEnabled = message.hyperthreadingEnabled;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.luns?.length) {
      obj.luns = message.luns.map((e) => Lun.toJSON(e));
    }
    if (message.volumes?.length) {
      obj.volumes = message.volumes.map((e) => Volume.toJSON(e));
    }
    if (message.networks?.length) {
      obj.networks = message.networks.map((e) => Network.toJSON(e));
    }
    if (message.interactiveSerialConsoleEnabled !== false) {
      obj.interactiveSerialConsoleEnabled = message.interactiveSerialConsoleEnabled;
    }
    if (message.osImage !== "") {
      obj.osImage = message.osImage;
    }
    if (message.pod !== "") {
      obj.pod = message.pod;
    }
    if (message.networkTemplate !== "") {
      obj.networkTemplate = message.networkTemplate;
    }
    if (message.logicalInterfaces?.length) {
      obj.logicalInterfaces = message.logicalInterfaces.map((e) => LogicalInterface.toJSON(e));
    }
    if (message.loginInfo !== "") {
      obj.loginInfo = message.loginInfo;
    }
    if (message.workloadProfile !== 0) {
      obj.workloadProfile = workloadProfileToJSON(message.workloadProfile);
    }
    if (message.firmwareVersion !== "") {
      obj.firmwareVersion = message.firmwareVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance>): Instance {
    return Instance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance>): Instance {
    const message = createBaseInstance();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.machineType = object.machineType ?? "";
    message.state = object.state ?? 0;
    message.hyperthreadingEnabled = object.hyperthreadingEnabled ?? false;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.luns = object.luns?.map((e) => Lun.fromPartial(e)) || [];
    message.volumes = object.volumes?.map((e) => Volume.fromPartial(e)) || [];
    message.networks = object.networks?.map((e) => Network.fromPartial(e)) || [];
    message.interactiveSerialConsoleEnabled = object.interactiveSerialConsoleEnabled ?? false;
    message.osImage = object.osImage ?? "";
    message.pod = object.pod ?? "";
    message.networkTemplate = object.networkTemplate ?? "";
    message.logicalInterfaces = object.logicalInterfaces?.map((e) => LogicalInterface.fromPartial(e)) || [];
    message.loginInfo = object.loginInfo ?? "";
    message.workloadProfile = object.workloadProfile ?? 0;
    message.firmwareVersion = object.firmwareVersion ?? "";
    return message;
  },
};

function createBaseInstance_LabelsEntry(): Instance_LabelsEntry {
  return { key: "", value: "" };
}

export const Instance_LabelsEntry: MessageFns<Instance_LabelsEntry> = {
  encode(message: Instance_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    return Instance_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    const message = createBaseInstance_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetInstanceRequest(): GetInstanceRequest {
  return { name: "" };
}

export const GetInstanceRequest: MessageFns<GetInstanceRequest> = {
  encode(message: GetInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    return GetInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    const message = createBaseGetInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListInstancesRequest(): ListInstancesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListInstancesRequest: MessageFns<ListInstancesRequest> = {
  encode(message: ListInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListInstancesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    return ListInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    const message = createBaseListInstancesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListInstancesResponse(): ListInstancesResponse {
  return { instances: [], nextPageToken: "", unreachable: [] };
}

export const ListInstancesResponse: MessageFns<ListInstancesResponse> = {
  encode(message: ListInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instances) {
      Instance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instances.push(Instance.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesResponse {
    return {
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => Instance.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListInstancesResponse): unknown {
    const obj: any = {};
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => Instance.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    return ListInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    const message = createBaseListInstancesResponse();
    message.instances = object.instances?.map((e) => Instance.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateInstanceRequest(): UpdateInstanceRequest {
  return { instance: undefined, updateMask: undefined };
}

export const UpdateInstanceRequest: MessageFns<UpdateInstanceRequest> = {
  encode(message: UpdateInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInstanceRequest {
    return {
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateInstanceRequest): unknown {
    const obj: any = {};
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInstanceRequest>): UpdateInstanceRequest {
    return UpdateInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInstanceRequest>): UpdateInstanceRequest {
    const message = createBaseUpdateInstanceRequest();
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseRenameInstanceRequest(): RenameInstanceRequest {
  return { name: "", newInstanceId: "" };
}

export const RenameInstanceRequest: MessageFns<RenameInstanceRequest> = {
  encode(message: RenameInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.newInstanceId !== "") {
      writer.uint32(18).string(message.newInstanceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenameInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newInstanceId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenameInstanceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      newInstanceId: isSet(object.newInstanceId) ? globalThis.String(object.newInstanceId) : "",
    };
  },

  toJSON(message: RenameInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.newInstanceId !== "") {
      obj.newInstanceId = message.newInstanceId;
    }
    return obj;
  },

  create(base?: DeepPartial<RenameInstanceRequest>): RenameInstanceRequest {
    return RenameInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenameInstanceRequest>): RenameInstanceRequest {
    const message = createBaseRenameInstanceRequest();
    message.name = object.name ?? "";
    message.newInstanceId = object.newInstanceId ?? "";
    return message;
  },
};

function createBaseResetInstanceRequest(): ResetInstanceRequest {
  return { name: "" };
}

export const ResetInstanceRequest: MessageFns<ResetInstanceRequest> = {
  encode(message: ResetInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ResetInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ResetInstanceRequest>): ResetInstanceRequest {
    return ResetInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResetInstanceRequest>): ResetInstanceRequest {
    const message = createBaseResetInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStartInstanceRequest(): StartInstanceRequest {
  return { name: "" };
}

export const StartInstanceRequest: MessageFns<StartInstanceRequest> = {
  encode(message: StartInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: StartInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<StartInstanceRequest>): StartInstanceRequest {
    return StartInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StartInstanceRequest>): StartInstanceRequest {
    const message = createBaseStartInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStartInstanceResponse(): StartInstanceResponse {
  return {};
}

export const StartInstanceResponse: MessageFns<StartInstanceResponse> = {
  encode(_: StartInstanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartInstanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartInstanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StartInstanceResponse {
    return {};
  },

  toJSON(_: StartInstanceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<StartInstanceResponse>): StartInstanceResponse {
    return StartInstanceResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<StartInstanceResponse>): StartInstanceResponse {
    const message = createBaseStartInstanceResponse();
    return message;
  },
};

function createBaseStopInstanceRequest(): StopInstanceRequest {
  return { name: "" };
}

export const StopInstanceRequest: MessageFns<StopInstanceRequest> = {
  encode(message: StopInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: StopInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<StopInstanceRequest>): StopInstanceRequest {
    return StopInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StopInstanceRequest>): StopInstanceRequest {
    const message = createBaseStopInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseStopInstanceResponse(): StopInstanceResponse {
  return {};
}

export const StopInstanceResponse: MessageFns<StopInstanceResponse> = {
  encode(_: StopInstanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopInstanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopInstanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): StopInstanceResponse {
    return {};
  },

  toJSON(_: StopInstanceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<StopInstanceResponse>): StopInstanceResponse {
    return StopInstanceResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<StopInstanceResponse>): StopInstanceResponse {
    const message = createBaseStopInstanceResponse();
    return message;
  },
};

function createBaseEnableInteractiveSerialConsoleRequest(): EnableInteractiveSerialConsoleRequest {
  return { name: "" };
}

export const EnableInteractiveSerialConsoleRequest: MessageFns<EnableInteractiveSerialConsoleRequest> = {
  encode(message: EnableInteractiveSerialConsoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnableInteractiveSerialConsoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnableInteractiveSerialConsoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnableInteractiveSerialConsoleRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: EnableInteractiveSerialConsoleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<EnableInteractiveSerialConsoleRequest>): EnableInteractiveSerialConsoleRequest {
    return EnableInteractiveSerialConsoleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnableInteractiveSerialConsoleRequest>): EnableInteractiveSerialConsoleRequest {
    const message = createBaseEnableInteractiveSerialConsoleRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseEnableInteractiveSerialConsoleResponse(): EnableInteractiveSerialConsoleResponse {
  return {};
}

export const EnableInteractiveSerialConsoleResponse: MessageFns<EnableInteractiveSerialConsoleResponse> = {
  encode(_: EnableInteractiveSerialConsoleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnableInteractiveSerialConsoleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnableInteractiveSerialConsoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EnableInteractiveSerialConsoleResponse {
    return {};
  },

  toJSON(_: EnableInteractiveSerialConsoleResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<EnableInteractiveSerialConsoleResponse>): EnableInteractiveSerialConsoleResponse {
    return EnableInteractiveSerialConsoleResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<EnableInteractiveSerialConsoleResponse>): EnableInteractiveSerialConsoleResponse {
    const message = createBaseEnableInteractiveSerialConsoleResponse();
    return message;
  },
};

function createBaseDisableInteractiveSerialConsoleRequest(): DisableInteractiveSerialConsoleRequest {
  return { name: "" };
}

export const DisableInteractiveSerialConsoleRequest: MessageFns<DisableInteractiveSerialConsoleRequest> = {
  encode(message: DisableInteractiveSerialConsoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisableInteractiveSerialConsoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisableInteractiveSerialConsoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisableInteractiveSerialConsoleRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DisableInteractiveSerialConsoleRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DisableInteractiveSerialConsoleRequest>): DisableInteractiveSerialConsoleRequest {
    return DisableInteractiveSerialConsoleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DisableInteractiveSerialConsoleRequest>): DisableInteractiveSerialConsoleRequest {
    const message = createBaseDisableInteractiveSerialConsoleRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDisableInteractiveSerialConsoleResponse(): DisableInteractiveSerialConsoleResponse {
  return {};
}

export const DisableInteractiveSerialConsoleResponse: MessageFns<DisableInteractiveSerialConsoleResponse> = {
  encode(_: DisableInteractiveSerialConsoleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisableInteractiveSerialConsoleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisableInteractiveSerialConsoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DisableInteractiveSerialConsoleResponse {
    return {};
  },

  toJSON(_: DisableInteractiveSerialConsoleResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DisableInteractiveSerialConsoleResponse>): DisableInteractiveSerialConsoleResponse {
    return DisableInteractiveSerialConsoleResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DisableInteractiveSerialConsoleResponse>): DisableInteractiveSerialConsoleResponse {
    const message = createBaseDisableInteractiveSerialConsoleResponse();
    return message;
  },
};

function createBaseDetachLunRequest(): DetachLunRequest {
  return { instance: "", lun: "", skipReboot: false };
}

export const DetachLunRequest: MessageFns<DetachLunRequest> = {
  encode(message: DetachLunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== "") {
      writer.uint32(10).string(message.instance);
    }
    if (message.lun !== "") {
      writer.uint32(18).string(message.lun);
    }
    if (message.skipReboot !== false) {
      writer.uint32(24).bool(message.skipReboot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DetachLunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDetachLunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lun = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.skipReboot = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DetachLunRequest {
    return {
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      lun: isSet(object.lun) ? globalThis.String(object.lun) : "",
      skipReboot: isSet(object.skipReboot) ? globalThis.Boolean(object.skipReboot) : false,
    };
  },

  toJSON(message: DetachLunRequest): unknown {
    const obj: any = {};
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.lun !== "") {
      obj.lun = message.lun;
    }
    if (message.skipReboot !== false) {
      obj.skipReboot = message.skipReboot;
    }
    return obj;
  },

  create(base?: DeepPartial<DetachLunRequest>): DetachLunRequest {
    return DetachLunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DetachLunRequest>): DetachLunRequest {
    const message = createBaseDetachLunRequest();
    message.instance = object.instance ?? "";
    message.lun = object.lun ?? "";
    message.skipReboot = object.skipReboot ?? false;
    return message;
  },
};

function createBaseServerNetworkTemplate(): ServerNetworkTemplate {
  return { name: "", applicableInstanceTypes: [], logicalInterfaces: [] };
}

export const ServerNetworkTemplate: MessageFns<ServerNetworkTemplate> = {
  encode(message: ServerNetworkTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.applicableInstanceTypes) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.logicalInterfaces) {
      ServerNetworkTemplate_LogicalInterface.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerNetworkTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerNetworkTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.applicableInstanceTypes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.logicalInterfaces.push(ServerNetworkTemplate_LogicalInterface.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerNetworkTemplate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      applicableInstanceTypes: globalThis.Array.isArray(object?.applicableInstanceTypes)
        ? object.applicableInstanceTypes.map((e: any) => globalThis.String(e))
        : [],
      logicalInterfaces: globalThis.Array.isArray(object?.logicalInterfaces)
        ? object.logicalInterfaces.map((e: any) => ServerNetworkTemplate_LogicalInterface.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ServerNetworkTemplate): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.applicableInstanceTypes?.length) {
      obj.applicableInstanceTypes = message.applicableInstanceTypes;
    }
    if (message.logicalInterfaces?.length) {
      obj.logicalInterfaces = message.logicalInterfaces.map((e) => ServerNetworkTemplate_LogicalInterface.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ServerNetworkTemplate>): ServerNetworkTemplate {
    return ServerNetworkTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServerNetworkTemplate>): ServerNetworkTemplate {
    const message = createBaseServerNetworkTemplate();
    message.name = object.name ?? "";
    message.applicableInstanceTypes = object.applicableInstanceTypes?.map((e) => e) || [];
    message.logicalInterfaces =
      object.logicalInterfaces?.map((e) => ServerNetworkTemplate_LogicalInterface.fromPartial(e)) || [];
    return message;
  },
};

function createBaseServerNetworkTemplate_LogicalInterface(): ServerNetworkTemplate_LogicalInterface {
  return { name: "", type: 0, required: false };
}

export const ServerNetworkTemplate_LogicalInterface: MessageFns<ServerNetworkTemplate_LogicalInterface> = {
  encode(message: ServerNetworkTemplate_LogicalInterface, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.required !== false) {
      writer.uint32(24).bool(message.required);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerNetworkTemplate_LogicalInterface {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerNetworkTemplate_LogicalInterface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.required = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerNetworkTemplate_LogicalInterface {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? serverNetworkTemplate_LogicalInterface_InterfaceTypeFromJSON(object.type) : 0,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
    };
  },

  toJSON(message: ServerNetworkTemplate_LogicalInterface): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = serverNetworkTemplate_LogicalInterface_InterfaceTypeToJSON(message.type);
    }
    if (message.required !== false) {
      obj.required = message.required;
    }
    return obj;
  },

  create(base?: DeepPartial<ServerNetworkTemplate_LogicalInterface>): ServerNetworkTemplate_LogicalInterface {
    return ServerNetworkTemplate_LogicalInterface.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServerNetworkTemplate_LogicalInterface>): ServerNetworkTemplate_LogicalInterface {
    const message = createBaseServerNetworkTemplate_LogicalInterface();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.required = object.required ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
