// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/baremetalsolution/v2/network.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { FieldMask } from "../../../protobuf/field_mask.js";

export const protobufPackage = "google.cloud.baremetalsolution.v2";

/** A Network. */
export interface Network {
  /**
   * Output only. The resource name of this `Network`.
   * Resource names are schemeless URIs that follow the conventions in
   * https://cloud.google.com/apis/design/resource_names.
   * Format:
   * `projects/{project}/locations/{location}/networks/{network}`
   */
  name: string;
  /** An identifier for the `Network`, generated by the backend. */
  id: string;
  /** The type of this network. */
  type: Network_Type;
  /** IP address configured. */
  ipAddress: string;
  /** List of physical interfaces. */
  macAddress: string[];
  /** The Network state. */
  state: Network_State;
  /** The vlan id of the Network. */
  vlanId: string;
  /** The cidr of the Network. */
  cidr: string;
  /** The vrf for the Network. */
  vrf:
    | VRF
    | undefined;
  /** Labels as key value pairs. */
  labels: { [key: string]: string };
  /** IP range for reserved for services (e.g. NFS). */
  servicesCidr: string;
  /**
   * List of IP address reservations in this network.
   * When updating this field, an error will be generated if a reservation
   * conflicts with an IP address already allocated to a physical server.
   */
  reservations: NetworkAddressReservation[];
  /** Output only. Pod name. */
  pod: string;
  /** Input only. List of mount points to attach the network to. */
  mountPoints: NetworkMountPoint[];
  /** Whether network uses standard frames or jumbo ones. */
  jumboFramesEnabled: boolean;
  /** Output only. Gateway ip address. */
  gatewayIp: string;
}

/** Network type. */
export enum Network_Type {
  /** TYPE_UNSPECIFIED - Unspecified value. */
  TYPE_UNSPECIFIED = 0,
  /** CLIENT - Client network, a network peered to a Google Cloud VPC. */
  CLIENT = 1,
  /** PRIVATE - Private network, a network local to the Bare Metal Solution environment. */
  PRIVATE = 2,
  UNRECOGNIZED = -1,
}

export function network_TypeFromJSON(object: any): Network_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Network_Type.TYPE_UNSPECIFIED;
    case 1:
    case "CLIENT":
      return Network_Type.CLIENT;
    case 2:
    case "PRIVATE":
      return Network_Type.PRIVATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Network_Type.UNRECOGNIZED;
  }
}

export function network_TypeToJSON(object: Network_Type): string {
  switch (object) {
    case Network_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Network_Type.CLIENT:
      return "CLIENT";
    case Network_Type.PRIVATE:
      return "PRIVATE";
    case Network_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The possible states for this Network. */
export enum Network_State {
  /** STATE_UNSPECIFIED - The Network is in an unknown state. */
  STATE_UNSPECIFIED = 0,
  /** PROVISIONING - The Network is provisioning. */
  PROVISIONING = 1,
  /** PROVISIONED - The Network has been provisioned. */
  PROVISIONED = 2,
  /** DEPROVISIONING - The Network is being deprovisioned. */
  DEPROVISIONING = 3,
  /** UPDATING - The Network is being updated. */
  UPDATING = 4,
  UNRECOGNIZED = -1,
}

export function network_StateFromJSON(object: any): Network_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Network_State.STATE_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return Network_State.PROVISIONING;
    case 2:
    case "PROVISIONED":
      return Network_State.PROVISIONED;
    case 3:
    case "DEPROVISIONING":
      return Network_State.DEPROVISIONING;
    case 4:
    case "UPDATING":
      return Network_State.UPDATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Network_State.UNRECOGNIZED;
  }
}

export function network_StateToJSON(object: Network_State): string {
  switch (object) {
    case Network_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Network_State.PROVISIONING:
      return "PROVISIONING";
    case Network_State.PROVISIONED:
      return "PROVISIONED";
    case Network_State.DEPROVISIONING:
      return "DEPROVISIONING";
    case Network_State.UPDATING:
      return "UPDATING";
    case Network_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Network_LabelsEntry {
  key: string;
  value: string;
}

/** A reservation of one or more addresses in a network. */
export interface NetworkAddressReservation {
  /**
   * The first address of this reservation block.
   * Must be specified as a single IPv4 address, e.g. 10.1.2.2.
   */
  startAddress: string;
  /**
   * The last address of this reservation block, inclusive. I.e., for cases when
   * reservations are only single addresses, end_address and start_address will
   * be the same.
   * Must be specified as a single IPv4 address, e.g. 10.1.2.2.
   */
  endAddress: string;
  /** A note about this reservation, intended for human consumption. */
  note: string;
}

/** A network VRF. */
export interface VRF {
  /** The name of the VRF. */
  name: string;
  /** The possible state of VRF. */
  state: VRF_State;
  /**
   * The QOS policy applied to this VRF.
   * The value is only meaningful when all the vlan attachments have the same
   * QoS. This field should not be used for new integrations, use vlan
   * attachment level qos instead. The field is left for backward-compatibility.
   */
  qosPolicy:
    | VRF_QosPolicy
    | undefined;
  /** The list of VLAN attachments for the VRF. */
  vlanAttachments: VRF_VlanAttachment[];
}

/** The possible states for this VRF. */
export enum VRF_State {
  /** STATE_UNSPECIFIED - The unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** PROVISIONING - The vrf is provisioning. */
  PROVISIONING = 1,
  /** PROVISIONED - The vrf is provisioned. */
  PROVISIONED = 2,
  UNRECOGNIZED = -1,
}

export function vRF_StateFromJSON(object: any): VRF_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return VRF_State.STATE_UNSPECIFIED;
    case 1:
    case "PROVISIONING":
      return VRF_State.PROVISIONING;
    case 2:
    case "PROVISIONED":
      return VRF_State.PROVISIONED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VRF_State.UNRECOGNIZED;
  }
}

export function vRF_StateToJSON(object: VRF_State): string {
  switch (object) {
    case VRF_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case VRF_State.PROVISIONING:
      return "PROVISIONING";
    case VRF_State.PROVISIONED:
      return "PROVISIONED";
    case VRF_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** QOS policy parameters. */
export interface VRF_QosPolicy {
  /** The bandwidth permitted by the QOS policy, in gbps. */
  bandwidthGbps: number;
}

/** VLAN attachment details. */
export interface VRF_VlanAttachment {
  /** The peer vlan ID of the attachment. */
  peerVlanId: Long;
  /** The peer IP of the attachment. */
  peerIp: string;
  /** The router IP of the attachment. */
  routerIp: string;
  /** Input only. Pairing key. */
  pairingKey: string;
  /**
   * The QOS policy applied to this VLAN attachment.
   * This value should be preferred to using qos at vrf level.
   */
  qosPolicy:
    | VRF_QosPolicy
    | undefined;
  /** Immutable. The identifier of the attachment within vrf. */
  id: string;
  /**
   * Optional. The name of the vlan attachment within vrf. This is of the form
   * projects/{project_number}/regions/{region}/interconnectAttachments/{interconnect_attachment}
   */
  interconnectAttachment: string;
}

/**
 * Each logical interface represents a logical abstraction of the underlying
 * physical interface (for eg. bond, nic) of the instance. Each logical
 * interface can effectively map to multiple network-IP pairs and still be
 * mapped to one underlying physical interface.
 */
export interface LogicalInterface {
  /** List of logical network interfaces within a logical interface. */
  logicalNetworkInterfaces: LogicalInterface_LogicalNetworkInterface[];
  /**
   * Interface name. This is of syntax <bond><bond_mode> or <nic> and
   * forms part of the network template name.
   */
  name: string;
  /**
   * The index of the logical interface mapping to the index of the hardware
   * bond or nic on the chosen network template. This field is deprecated.
   *
   * @deprecated
   */
  interfaceIndex: number;
}

/** Each logical network interface is effectively a network and IP pair. */
export interface LogicalInterface_LogicalNetworkInterface {
  /** Name of the network */
  network: string;
  /** IP address in the network */
  ipAddress: string;
  /**
   * Whether this interface is the default gateway for the instance. Only
   * one interface can be the default gateway for the instance.
   */
  defaultGateway: boolean;
  /** Type of network. */
  networkType: Network_Type;
  /** An identifier for the `Network`, generated by the backend. */
  id: string;
}

/** Message for requesting network information. */
export interface GetNetworkRequest {
  /** Required. Name of the resource. */
  name: string;
}

/** Message for requesting a list of networks. */
export interface ListNetworksRequest {
  /** Required. Parent value for ListNetworksRequest. */
  parent: string;
  /**
   * Requested page size. The server might return fewer items than requested.
   * If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** A token identifying a page of results from the server. */
  pageToken: string;
  /** List filter. */
  filter: string;
}

/** Response message containing the list of networks. */
export interface ListNetworksResponse {
  /** The list of networks. */
  networks: Network[];
  /** A token identifying a page of results from the server. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Message requesting to updating a network. */
export interface UpdateNetworkRequest {
  /**
   * Required. The network to update.
   *
   * The `name` field is used to identify the instance to update.
   * Format: projects/{project}/locations/{location}/networks/{network}
   */
  network:
    | Network
    | undefined;
  /**
   * The list of fields to update.
   * The only currently supported fields are:
   *   `labels`, `reservations`, `vrf.vlan_attachments`
   */
  updateMask: string[] | undefined;
}

/** Network with all used IP addresses. */
export interface NetworkUsage {
  /** Network. */
  network:
    | Network
    | undefined;
  /** All used IP addresses in this network. */
  usedIps: string[];
}

/** Request to get networks with IPs. */
export interface ListNetworkUsageRequest {
  /** Required. Parent value (project and location). */
  location: string;
}

/** Response with Networks with IPs */
export interface ListNetworkUsageResponse {
  /** Networks with IPs. */
  networks: NetworkUsage[];
}

/** Mount point for a network. */
export interface NetworkMountPoint {
  /** Instance to attach network to. */
  instance: string;
  /** Logical interface to detach from. */
  logicalInterface: string;
  /** Network should be a default gateway. */
  defaultGateway: boolean;
  /** Ip address of the server. */
  ipAddress: string;
}

/** Message requesting rename of a server. */
export interface RenameNetworkRequest {
  /**
   * Required. The `name` field is used to identify the network.
   * Format: projects/{project}/locations/{location}/networks/{network}
   */
  name: string;
  /** Required. The new `id` of the network. */
  newNetworkId: string;
}

function createBaseNetwork(): Network {
  return {
    name: "",
    id: "",
    type: 0,
    ipAddress: "",
    macAddress: [],
    state: 0,
    vlanId: "",
    cidr: "",
    vrf: undefined,
    labels: {},
    servicesCidr: "",
    reservations: [],
    pod: "",
    mountPoints: [],
    jumboFramesEnabled: false,
    gatewayIp: "",
  };
}

export const Network: MessageFns<Network> = {
  encode(message: Network, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(82).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.ipAddress !== "") {
      writer.uint32(26).string(message.ipAddress);
    }
    for (const v of message.macAddress) {
      writer.uint32(34).string(v!);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.vlanId !== "") {
      writer.uint32(58).string(message.vlanId);
    }
    if (message.cidr !== "") {
      writer.uint32(66).string(message.cidr);
    }
    if (message.vrf !== undefined) {
      VRF.encode(message.vrf, writer.uint32(74).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Network_LabelsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.servicesCidr !== "") {
      writer.uint32(98).string(message.servicesCidr);
    }
    for (const v of message.reservations) {
      NetworkAddressReservation.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.pod !== "") {
      writer.uint32(114).string(message.pod);
    }
    for (const v of message.mountPoints) {
      NetworkMountPoint.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.jumboFramesEnabled !== false) {
      writer.uint32(128).bool(message.jumboFramesEnabled);
    }
    if (message.gatewayIp !== "") {
      writer.uint32(138).string(message.gatewayIp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Network {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetwork();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 5:
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.macAddress.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.vlanId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.cidr = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.vrf = VRF.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = Network_LabelsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.labels[entry11.key] = entry11.value;
          }
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.servicesCidr = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.reservations.push(NetworkAddressReservation.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.pod = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.mountPoints.push(NetworkMountPoint.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.jumboFramesEnabled = reader.bool();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.gatewayIp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Network {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? network_TypeFromJSON(object.type) : 0,
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      macAddress: globalThis.Array.isArray(object?.macAddress)
        ? object.macAddress.map((e: any) => globalThis.String(e))
        : [],
      state: isSet(object.state) ? network_StateFromJSON(object.state) : 0,
      vlanId: isSet(object.vlanId) ? globalThis.String(object.vlanId) : "",
      cidr: isSet(object.cidr) ? globalThis.String(object.cidr) : "",
      vrf: isSet(object.vrf) ? VRF.fromJSON(object.vrf) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      servicesCidr: isSet(object.servicesCidr) ? globalThis.String(object.servicesCidr) : "",
      reservations: globalThis.Array.isArray(object?.reservations)
        ? object.reservations.map((e: any) => NetworkAddressReservation.fromJSON(e))
        : [],
      pod: isSet(object.pod) ? globalThis.String(object.pod) : "",
      mountPoints: globalThis.Array.isArray(object?.mountPoints)
        ? object.mountPoints.map((e: any) => NetworkMountPoint.fromJSON(e))
        : [],
      jumboFramesEnabled: isSet(object.jumboFramesEnabled) ? globalThis.Boolean(object.jumboFramesEnabled) : false,
      gatewayIp: isSet(object.gatewayIp) ? globalThis.String(object.gatewayIp) : "",
    };
  },

  toJSON(message: Network): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = network_TypeToJSON(message.type);
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.macAddress?.length) {
      obj.macAddress = message.macAddress;
    }
    if (message.state !== 0) {
      obj.state = network_StateToJSON(message.state);
    }
    if (message.vlanId !== "") {
      obj.vlanId = message.vlanId;
    }
    if (message.cidr !== "") {
      obj.cidr = message.cidr;
    }
    if (message.vrf !== undefined) {
      obj.vrf = VRF.toJSON(message.vrf);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.servicesCidr !== "") {
      obj.servicesCidr = message.servicesCidr;
    }
    if (message.reservations?.length) {
      obj.reservations = message.reservations.map((e) => NetworkAddressReservation.toJSON(e));
    }
    if (message.pod !== "") {
      obj.pod = message.pod;
    }
    if (message.mountPoints?.length) {
      obj.mountPoints = message.mountPoints.map((e) => NetworkMountPoint.toJSON(e));
    }
    if (message.jumboFramesEnabled !== false) {
      obj.jumboFramesEnabled = message.jumboFramesEnabled;
    }
    if (message.gatewayIp !== "") {
      obj.gatewayIp = message.gatewayIp;
    }
    return obj;
  },

  create(base?: DeepPartial<Network>): Network {
    return Network.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Network>): Network {
    const message = createBaseNetwork();
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.ipAddress = object.ipAddress ?? "";
    message.macAddress = object.macAddress?.map((e) => e) || [];
    message.state = object.state ?? 0;
    message.vlanId = object.vlanId ?? "";
    message.cidr = object.cidr ?? "";
    message.vrf = (object.vrf !== undefined && object.vrf !== null) ? VRF.fromPartial(object.vrf) : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.servicesCidr = object.servicesCidr ?? "";
    message.reservations = object.reservations?.map((e) => NetworkAddressReservation.fromPartial(e)) || [];
    message.pod = object.pod ?? "";
    message.mountPoints = object.mountPoints?.map((e) => NetworkMountPoint.fromPartial(e)) || [];
    message.jumboFramesEnabled = object.jumboFramesEnabled ?? false;
    message.gatewayIp = object.gatewayIp ?? "";
    return message;
  },
};

function createBaseNetwork_LabelsEntry(): Network_LabelsEntry {
  return { key: "", value: "" };
}

export const Network_LabelsEntry: MessageFns<Network_LabelsEntry> = {
  encode(message: Network_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Network_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetwork_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Network_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Network_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Network_LabelsEntry>): Network_LabelsEntry {
    return Network_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Network_LabelsEntry>): Network_LabelsEntry {
    const message = createBaseNetwork_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNetworkAddressReservation(): NetworkAddressReservation {
  return { startAddress: "", endAddress: "", note: "" };
}

export const NetworkAddressReservation: MessageFns<NetworkAddressReservation> = {
  encode(message: NetworkAddressReservation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startAddress !== "") {
      writer.uint32(10).string(message.startAddress);
    }
    if (message.endAddress !== "") {
      writer.uint32(18).string(message.endAddress);
    }
    if (message.note !== "") {
      writer.uint32(26).string(message.note);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkAddressReservation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkAddressReservation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.note = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkAddressReservation {
    return {
      startAddress: isSet(object.startAddress) ? globalThis.String(object.startAddress) : "",
      endAddress: isSet(object.endAddress) ? globalThis.String(object.endAddress) : "",
      note: isSet(object.note) ? globalThis.String(object.note) : "",
    };
  },

  toJSON(message: NetworkAddressReservation): unknown {
    const obj: any = {};
    if (message.startAddress !== "") {
      obj.startAddress = message.startAddress;
    }
    if (message.endAddress !== "") {
      obj.endAddress = message.endAddress;
    }
    if (message.note !== "") {
      obj.note = message.note;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkAddressReservation>): NetworkAddressReservation {
    return NetworkAddressReservation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkAddressReservation>): NetworkAddressReservation {
    const message = createBaseNetworkAddressReservation();
    message.startAddress = object.startAddress ?? "";
    message.endAddress = object.endAddress ?? "";
    message.note = object.note ?? "";
    return message;
  },
};

function createBaseVRF(): VRF {
  return { name: "", state: 0, qosPolicy: undefined, vlanAttachments: [] };
}

export const VRF: MessageFns<VRF> = {
  encode(message: VRF, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.qosPolicy !== undefined) {
      VRF_QosPolicy.encode(message.qosPolicy, writer.uint32(50).fork()).join();
    }
    for (const v of message.vlanAttachments) {
      VRF_VlanAttachment.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VRF {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVRF();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.qosPolicy = VRF_QosPolicy.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.vlanAttachments.push(VRF_VlanAttachment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VRF {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? vRF_StateFromJSON(object.state) : 0,
      qosPolicy: isSet(object.qosPolicy) ? VRF_QosPolicy.fromJSON(object.qosPolicy) : undefined,
      vlanAttachments: globalThis.Array.isArray(object?.vlanAttachments)
        ? object.vlanAttachments.map((e: any) => VRF_VlanAttachment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VRF): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = vRF_StateToJSON(message.state);
    }
    if (message.qosPolicy !== undefined) {
      obj.qosPolicy = VRF_QosPolicy.toJSON(message.qosPolicy);
    }
    if (message.vlanAttachments?.length) {
      obj.vlanAttachments = message.vlanAttachments.map((e) => VRF_VlanAttachment.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VRF>): VRF {
    return VRF.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VRF>): VRF {
    const message = createBaseVRF();
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.qosPolicy = (object.qosPolicy !== undefined && object.qosPolicy !== null)
      ? VRF_QosPolicy.fromPartial(object.qosPolicy)
      : undefined;
    message.vlanAttachments = object.vlanAttachments?.map((e) => VRF_VlanAttachment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVRF_QosPolicy(): VRF_QosPolicy {
  return { bandwidthGbps: 0 };
}

export const VRF_QosPolicy: MessageFns<VRF_QosPolicy> = {
  encode(message: VRF_QosPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bandwidthGbps !== 0) {
      writer.uint32(9).double(message.bandwidthGbps);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VRF_QosPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVRF_QosPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.bandwidthGbps = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VRF_QosPolicy {
    return { bandwidthGbps: isSet(object.bandwidthGbps) ? globalThis.Number(object.bandwidthGbps) : 0 };
  },

  toJSON(message: VRF_QosPolicy): unknown {
    const obj: any = {};
    if (message.bandwidthGbps !== 0) {
      obj.bandwidthGbps = message.bandwidthGbps;
    }
    return obj;
  },

  create(base?: DeepPartial<VRF_QosPolicy>): VRF_QosPolicy {
    return VRF_QosPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VRF_QosPolicy>): VRF_QosPolicy {
    const message = createBaseVRF_QosPolicy();
    message.bandwidthGbps = object.bandwidthGbps ?? 0;
    return message;
  },
};

function createBaseVRF_VlanAttachment(): VRF_VlanAttachment {
  return {
    peerVlanId: Long.ZERO,
    peerIp: "",
    routerIp: "",
    pairingKey: "",
    qosPolicy: undefined,
    id: "",
    interconnectAttachment: "",
  };
}

export const VRF_VlanAttachment: MessageFns<VRF_VlanAttachment> = {
  encode(message: VRF_VlanAttachment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.peerVlanId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.peerVlanId.toString());
    }
    if (message.peerIp !== "") {
      writer.uint32(18).string(message.peerIp);
    }
    if (message.routerIp !== "") {
      writer.uint32(26).string(message.routerIp);
    }
    if (message.pairingKey !== "") {
      writer.uint32(34).string(message.pairingKey);
    }
    if (message.qosPolicy !== undefined) {
      VRF_QosPolicy.encode(message.qosPolicy, writer.uint32(42).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }
    if (message.interconnectAttachment !== "") {
      writer.uint32(58).string(message.interconnectAttachment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VRF_VlanAttachment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVRF_VlanAttachment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.peerVlanId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.peerIp = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.routerIp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pairingKey = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.qosPolicy = VRF_QosPolicy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.id = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.interconnectAttachment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VRF_VlanAttachment {
    return {
      peerVlanId: isSet(object.peerVlanId) ? Long.fromValue(object.peerVlanId) : Long.ZERO,
      peerIp: isSet(object.peerIp) ? globalThis.String(object.peerIp) : "",
      routerIp: isSet(object.routerIp) ? globalThis.String(object.routerIp) : "",
      pairingKey: isSet(object.pairingKey) ? globalThis.String(object.pairingKey) : "",
      qosPolicy: isSet(object.qosPolicy) ? VRF_QosPolicy.fromJSON(object.qosPolicy) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      interconnectAttachment: isSet(object.interconnectAttachment)
        ? globalThis.String(object.interconnectAttachment)
        : "",
    };
  },

  toJSON(message: VRF_VlanAttachment): unknown {
    const obj: any = {};
    if (!message.peerVlanId.equals(Long.ZERO)) {
      obj.peerVlanId = (message.peerVlanId || Long.ZERO).toString();
    }
    if (message.peerIp !== "") {
      obj.peerIp = message.peerIp;
    }
    if (message.routerIp !== "") {
      obj.routerIp = message.routerIp;
    }
    if (message.pairingKey !== "") {
      obj.pairingKey = message.pairingKey;
    }
    if (message.qosPolicy !== undefined) {
      obj.qosPolicy = VRF_QosPolicy.toJSON(message.qosPolicy);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.interconnectAttachment !== "") {
      obj.interconnectAttachment = message.interconnectAttachment;
    }
    return obj;
  },

  create(base?: DeepPartial<VRF_VlanAttachment>): VRF_VlanAttachment {
    return VRF_VlanAttachment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VRF_VlanAttachment>): VRF_VlanAttachment {
    const message = createBaseVRF_VlanAttachment();
    message.peerVlanId = (object.peerVlanId !== undefined && object.peerVlanId !== null)
      ? Long.fromValue(object.peerVlanId)
      : Long.ZERO;
    message.peerIp = object.peerIp ?? "";
    message.routerIp = object.routerIp ?? "";
    message.pairingKey = object.pairingKey ?? "";
    message.qosPolicy = (object.qosPolicy !== undefined && object.qosPolicy !== null)
      ? VRF_QosPolicy.fromPartial(object.qosPolicy)
      : undefined;
    message.id = object.id ?? "";
    message.interconnectAttachment = object.interconnectAttachment ?? "";
    return message;
  },
};

function createBaseLogicalInterface(): LogicalInterface {
  return { logicalNetworkInterfaces: [], name: "", interfaceIndex: 0 };
}

export const LogicalInterface: MessageFns<LogicalInterface> = {
  encode(message: LogicalInterface, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logicalNetworkInterfaces) {
      LogicalInterface_LogicalNetworkInterface.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.interfaceIndex !== 0) {
      writer.uint32(24).int32(message.interfaceIndex);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogicalInterface {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogicalInterface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.logicalNetworkInterfaces.push(
            LogicalInterface_LogicalNetworkInterface.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.interfaceIndex = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogicalInterface {
    return {
      logicalNetworkInterfaces: globalThis.Array.isArray(object?.logicalNetworkInterfaces)
        ? object.logicalNetworkInterfaces.map((e: any) => LogicalInterface_LogicalNetworkInterface.fromJSON(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      interfaceIndex: isSet(object.interfaceIndex) ? globalThis.Number(object.interfaceIndex) : 0,
    };
  },

  toJSON(message: LogicalInterface): unknown {
    const obj: any = {};
    if (message.logicalNetworkInterfaces?.length) {
      obj.logicalNetworkInterfaces = message.logicalNetworkInterfaces.map((e) =>
        LogicalInterface_LogicalNetworkInterface.toJSON(e)
      );
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.interfaceIndex !== 0) {
      obj.interfaceIndex = Math.round(message.interfaceIndex);
    }
    return obj;
  },

  create(base?: DeepPartial<LogicalInterface>): LogicalInterface {
    return LogicalInterface.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogicalInterface>): LogicalInterface {
    const message = createBaseLogicalInterface();
    message.logicalNetworkInterfaces =
      object.logicalNetworkInterfaces?.map((e) => LogicalInterface_LogicalNetworkInterface.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.interfaceIndex = object.interfaceIndex ?? 0;
    return message;
  },
};

function createBaseLogicalInterface_LogicalNetworkInterface(): LogicalInterface_LogicalNetworkInterface {
  return { network: "", ipAddress: "", defaultGateway: false, networkType: 0, id: "" };
}

export const LogicalInterface_LogicalNetworkInterface: MessageFns<LogicalInterface_LogicalNetworkInterface> = {
  encode(message: LogicalInterface_LogicalNetworkInterface, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.ipAddress !== "") {
      writer.uint32(18).string(message.ipAddress);
    }
    if (message.defaultGateway !== false) {
      writer.uint32(24).bool(message.defaultGateway);
    }
    if (message.networkType !== 0) {
      writer.uint32(32).int32(message.networkType);
    }
    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogicalInterface_LogicalNetworkInterface {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogicalInterface_LogicalNetworkInterface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.defaultGateway = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.networkType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogicalInterface_LogicalNetworkInterface {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      defaultGateway: isSet(object.defaultGateway) ? globalThis.Boolean(object.defaultGateway) : false,
      networkType: isSet(object.networkType) ? network_TypeFromJSON(object.networkType) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: LogicalInterface_LogicalNetworkInterface): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.defaultGateway !== false) {
      obj.defaultGateway = message.defaultGateway;
    }
    if (message.networkType !== 0) {
      obj.networkType = network_TypeToJSON(message.networkType);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<LogicalInterface_LogicalNetworkInterface>): LogicalInterface_LogicalNetworkInterface {
    return LogicalInterface_LogicalNetworkInterface.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogicalInterface_LogicalNetworkInterface>): LogicalInterface_LogicalNetworkInterface {
    const message = createBaseLogicalInterface_LogicalNetworkInterface();
    message.network = object.network ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.defaultGateway = object.defaultGateway ?? false;
    message.networkType = object.networkType ?? 0;
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGetNetworkRequest(): GetNetworkRequest {
  return { name: "" };
}

export const GetNetworkRequest: MessageFns<GetNetworkRequest> = {
  encode(message: GetNetworkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNetworkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNetworkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNetworkRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNetworkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetNetworkRequest>): GetNetworkRequest {
    return GetNetworkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetNetworkRequest>): GetNetworkRequest {
    const message = createBaseGetNetworkRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListNetworksRequest(): ListNetworksRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListNetworksRequest: MessageFns<ListNetworksRequest> = {
  encode(message: ListNetworksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNetworksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNetworksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNetworksRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListNetworksRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNetworksRequest>): ListNetworksRequest {
    return ListNetworksRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNetworksRequest>): ListNetworksRequest {
    const message = createBaseListNetworksRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListNetworksResponse(): ListNetworksResponse {
  return { networks: [], nextPageToken: "", unreachable: [] };
}

export const ListNetworksResponse: MessageFns<ListNetworksResponse> = {
  encode(message: ListNetworksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.networks) {
      Network.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNetworksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNetworksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networks.push(Network.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNetworksResponse {
    return {
      networks: globalThis.Array.isArray(object?.networks) ? object.networks.map((e: any) => Network.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListNetworksResponse): unknown {
    const obj: any = {};
    if (message.networks?.length) {
      obj.networks = message.networks.map((e) => Network.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNetworksResponse>): ListNetworksResponse {
    return ListNetworksResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNetworksResponse>): ListNetworksResponse {
    const message = createBaseListNetworksResponse();
    message.networks = object.networks?.map((e) => Network.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateNetworkRequest(): UpdateNetworkRequest {
  return { network: undefined, updateMask: undefined };
}

export const UpdateNetworkRequest: MessageFns<UpdateNetworkRequest> = {
  encode(message: UpdateNetworkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateNetworkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateNetworkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateNetworkRequest {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateNetworkRequest): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateNetworkRequest>): UpdateNetworkRequest {
    return UpdateNetworkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateNetworkRequest>): UpdateNetworkRequest {
    const message = createBaseUpdateNetworkRequest();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseNetworkUsage(): NetworkUsage {
  return { network: undefined, usedIps: [] };
}

export const NetworkUsage: MessageFns<NetworkUsage> = {
  encode(message: NetworkUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      Network.encode(message.network, writer.uint32(10).fork()).join();
    }
    for (const v of message.usedIps) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = Network.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.usedIps.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkUsage {
    return {
      network: isSet(object.network) ? Network.fromJSON(object.network) : undefined,
      usedIps: globalThis.Array.isArray(object?.usedIps) ? object.usedIps.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: NetworkUsage): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = Network.toJSON(message.network);
    }
    if (message.usedIps?.length) {
      obj.usedIps = message.usedIps;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkUsage>): NetworkUsage {
    return NetworkUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkUsage>): NetworkUsage {
    const message = createBaseNetworkUsage();
    message.network = (object.network !== undefined && object.network !== null)
      ? Network.fromPartial(object.network)
      : undefined;
    message.usedIps = object.usedIps?.map((e) => e) || [];
    return message;
  },
};

function createBaseListNetworkUsageRequest(): ListNetworkUsageRequest {
  return { location: "" };
}

export const ListNetworkUsageRequest: MessageFns<ListNetworkUsageRequest> = {
  encode(message: ListNetworkUsageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== "") {
      writer.uint32(10).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNetworkUsageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNetworkUsageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNetworkUsageRequest {
    return { location: isSet(object.location) ? globalThis.String(object.location) : "" };
  },

  toJSON(message: ListNetworkUsageRequest): unknown {
    const obj: any = {};
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<ListNetworkUsageRequest>): ListNetworkUsageRequest {
    return ListNetworkUsageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNetworkUsageRequest>): ListNetworkUsageRequest {
    const message = createBaseListNetworkUsageRequest();
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseListNetworkUsageResponse(): ListNetworkUsageResponse {
  return { networks: [] };
}

export const ListNetworkUsageResponse: MessageFns<ListNetworkUsageResponse> = {
  encode(message: ListNetworkUsageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.networks) {
      NetworkUsage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNetworkUsageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNetworkUsageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.networks.push(NetworkUsage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNetworkUsageResponse {
    return {
      networks: globalThis.Array.isArray(object?.networks)
        ? object.networks.map((e: any) => NetworkUsage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListNetworkUsageResponse): unknown {
    const obj: any = {};
    if (message.networks?.length) {
      obj.networks = message.networks.map((e) => NetworkUsage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListNetworkUsageResponse>): ListNetworkUsageResponse {
    return ListNetworkUsageResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListNetworkUsageResponse>): ListNetworkUsageResponse {
    const message = createBaseListNetworkUsageResponse();
    message.networks = object.networks?.map((e) => NetworkUsage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNetworkMountPoint(): NetworkMountPoint {
  return { instance: "", logicalInterface: "", defaultGateway: false, ipAddress: "" };
}

export const NetworkMountPoint: MessageFns<NetworkMountPoint> = {
  encode(message: NetworkMountPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instance !== "") {
      writer.uint32(10).string(message.instance);
    }
    if (message.logicalInterface !== "") {
      writer.uint32(18).string(message.logicalInterface);
    }
    if (message.defaultGateway !== false) {
      writer.uint32(24).bool(message.defaultGateway);
    }
    if (message.ipAddress !== "") {
      writer.uint32(34).string(message.ipAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkMountPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkMountPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instance = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.logicalInterface = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.defaultGateway = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkMountPoint {
    return {
      instance: isSet(object.instance) ? globalThis.String(object.instance) : "",
      logicalInterface: isSet(object.logicalInterface) ? globalThis.String(object.logicalInterface) : "",
      defaultGateway: isSet(object.defaultGateway) ? globalThis.Boolean(object.defaultGateway) : false,
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
    };
  },

  toJSON(message: NetworkMountPoint): unknown {
    const obj: any = {};
    if (message.instance !== "") {
      obj.instance = message.instance;
    }
    if (message.logicalInterface !== "") {
      obj.logicalInterface = message.logicalInterface;
    }
    if (message.defaultGateway !== false) {
      obj.defaultGateway = message.defaultGateway;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkMountPoint>): NetworkMountPoint {
    return NetworkMountPoint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkMountPoint>): NetworkMountPoint {
    const message = createBaseNetworkMountPoint();
    message.instance = object.instance ?? "";
    message.logicalInterface = object.logicalInterface ?? "";
    message.defaultGateway = object.defaultGateway ?? false;
    message.ipAddress = object.ipAddress ?? "";
    return message;
  },
};

function createBaseRenameNetworkRequest(): RenameNetworkRequest {
  return { name: "", newNetworkId: "" };
}

export const RenameNetworkRequest: MessageFns<RenameNetworkRequest> = {
  encode(message: RenameNetworkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.newNetworkId !== "") {
      writer.uint32(18).string(message.newNetworkId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenameNetworkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameNetworkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newNetworkId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenameNetworkRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      newNetworkId: isSet(object.newNetworkId) ? globalThis.String(object.newNetworkId) : "",
    };
  },

  toJSON(message: RenameNetworkRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.newNetworkId !== "") {
      obj.newNetworkId = message.newNetworkId;
    }
    return obj;
  },

  create(base?: DeepPartial<RenameNetworkRequest>): RenameNetworkRequest {
    return RenameNetworkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RenameNetworkRequest>): RenameNetworkRequest {
    const message = createBaseRenameNetworkRequest();
    message.name = object.name ?? "";
    message.newNetworkId = object.newNetworkId ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
