// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/filestore/v1/cloud_filestore_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { BoolValue } from "../../../protobuf/wrappers.js";

export const protobufPackage = "google.cloud.filestore.v1";

/** Network configuration for the instance. */
export interface NetworkConfig {
  /**
   * The name of the Google Compute Engine
   * [VPC network](https://cloud.google.com/vpc/docs/vpc) to which the
   * instance is connected.
   */
  network: string;
  /**
   * Internet protocol versions for which the instance has IP addresses
   * assigned. For this version, only MODE_IPV4 is supported.
   */
  modes: NetworkConfig_AddressMode[];
  /**
   * Optional, reserved_ip_range can have one of the following two types of
   * values.
   *
   * * CIDR range value when using DIRECT_PEERING connect mode.
   * * [Allocated IP address
   * range](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-internal-ip-address)
   * when using PRIVATE_SERVICE_ACCESS connect mode.
   *
   * When the name of an allocated IP address range is specified, it must be one
   * of the ranges associated with the private service access connection.
   * When specified as a direct CIDR value, it must be a /29 CIDR block for
   * Basic tier, a /24 CIDR block for High Scale tier, or a /26 CIDR block for
   * Enterprise tier in one of the [internal IP address
   * ranges](https://www.arin.net/reference/research/statistics/address_filters/)
   * that identifies the range of IP addresses reserved for this instance. For
   * example, 10.0.0.0/29, 192.168.0.0/24 or 192.168.0.0/26, respectively. The
   * range you specify can't overlap with either existing subnets or assigned IP
   * address ranges for other Filestore instances in the selected VPC
   * network.
   */
  reservedIpRange: string;
  /**
   * Output only. IPv4 addresses in the format
   * `{octet1}.{octet2}.{octet3}.{octet4}` or IPv6 addresses in the format
   * `{block1}:{block2}:{block3}:{block4}:{block5}:{block6}:{block7}:{block8}`.
   */
  ipAddresses: string[];
  /**
   * The network connect mode of the Filestore instance.
   * If not provided, the connect mode defaults to DIRECT_PEERING.
   */
  connectMode: NetworkConfig_ConnectMode;
}

/** Internet protocol versions supported by Filestore. */
export enum NetworkConfig_AddressMode {
  /** ADDRESS_MODE_UNSPECIFIED - Internet protocol not set. */
  ADDRESS_MODE_UNSPECIFIED = 0,
  /** MODE_IPV4 - Use the IPv4 internet protocol. */
  MODE_IPV4 = 1,
  UNRECOGNIZED = -1,
}

export function networkConfig_AddressModeFromJSON(object: any): NetworkConfig_AddressMode {
  switch (object) {
    case 0:
    case "ADDRESS_MODE_UNSPECIFIED":
      return NetworkConfig_AddressMode.ADDRESS_MODE_UNSPECIFIED;
    case 1:
    case "MODE_IPV4":
      return NetworkConfig_AddressMode.MODE_IPV4;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkConfig_AddressMode.UNRECOGNIZED;
  }
}

export function networkConfig_AddressModeToJSON(object: NetworkConfig_AddressMode): string {
  switch (object) {
    case NetworkConfig_AddressMode.ADDRESS_MODE_UNSPECIFIED:
      return "ADDRESS_MODE_UNSPECIFIED";
    case NetworkConfig_AddressMode.MODE_IPV4:
      return "MODE_IPV4";
    case NetworkConfig_AddressMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Available connection modes. */
export enum NetworkConfig_ConnectMode {
  /** CONNECT_MODE_UNSPECIFIED - Not set. */
  CONNECT_MODE_UNSPECIFIED = 0,
  /** DIRECT_PEERING - Connect via direct peering to the Filestore service. */
  DIRECT_PEERING = 1,
  /**
   * PRIVATE_SERVICE_ACCESS - Connect to your Filestore instance using Private Service
   * Access. Private services access provides an IP address range for multiple
   * Google Cloud services, including Filestore.
   */
  PRIVATE_SERVICE_ACCESS = 2,
  UNRECOGNIZED = -1,
}

export function networkConfig_ConnectModeFromJSON(object: any): NetworkConfig_ConnectMode {
  switch (object) {
    case 0:
    case "CONNECT_MODE_UNSPECIFIED":
      return NetworkConfig_ConnectMode.CONNECT_MODE_UNSPECIFIED;
    case 1:
    case "DIRECT_PEERING":
      return NetworkConfig_ConnectMode.DIRECT_PEERING;
    case 2:
    case "PRIVATE_SERVICE_ACCESS":
      return NetworkConfig_ConnectMode.PRIVATE_SERVICE_ACCESS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkConfig_ConnectMode.UNRECOGNIZED;
  }
}

export function networkConfig_ConnectModeToJSON(object: NetworkConfig_ConnectMode): string {
  switch (object) {
    case NetworkConfig_ConnectMode.CONNECT_MODE_UNSPECIFIED:
      return "CONNECT_MODE_UNSPECIFIED";
    case NetworkConfig_ConnectMode.DIRECT_PEERING:
      return "DIRECT_PEERING";
    case NetworkConfig_ConnectMode.PRIVATE_SERVICE_ACCESS:
      return "PRIVATE_SERVICE_ACCESS";
    case NetworkConfig_ConnectMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** File share configuration for the instance. */
export interface FileShareConfig {
  /**
   * Required. The name of the file share. Must use 1-16 characters for the
   * basic service tier and 1-63 characters for all other service tiers.
   * Must use lowercase letters, numbers, or underscores `[a-z0-9_]`. Must
   * start with a letter. Immutable.
   */
  name: string;
  /**
   * File share capacity in gigabytes (GB).
   * Filestore defines 1 GB as 1024^3 bytes.
   */
  capacityGb: Long;
  /**
   * The resource name of the backup, in the format
   * `projects/{project_number}/locations/{location_id}/backups/{backup_id}`,
   * that this file share has been restored from.
   */
  sourceBackup?:
    | string
    | undefined;
  /**
   * Nfs Export Options.
   * There is a limit of 10 export options per file share.
   */
  nfsExportOptions: NfsExportOptions[];
}

/** NFS export options specifications. */
export interface NfsExportOptions {
  /**
   * List of either an IPv4 addresses in the format
   * `{octet1}.{octet2}.{octet3}.{octet4}` or CIDR ranges in the format
   * `{octet1}.{octet2}.{octet3}.{octet4}/{mask size}` which may mount the
   * file share.
   * Overlapping IP ranges are not allowed, both within and across
   * NfsExportOptions. An error will be returned.
   * The limit is 64 IP ranges/addresses for each FileShareConfig among all
   * NfsExportOptions.
   */
  ipRanges: string[];
  /**
   * Either READ_ONLY, for allowing only read requests on the exported
   * directory, or READ_WRITE, for allowing both read and write requests.
   * The default is READ_WRITE.
   */
  accessMode: NfsExportOptions_AccessMode;
  /**
   * Either NO_ROOT_SQUASH, for allowing root access on the exported directory,
   * or ROOT_SQUASH, for not allowing root access. The default is
   * NO_ROOT_SQUASH.
   */
  squashMode: NfsExportOptions_SquashMode;
  /**
   * An integer representing the anonymous user id with a default value of
   * 65534.
   * Anon_uid may only be set with squash_mode of ROOT_SQUASH.  An error will be
   * returned if this field is specified for other squash_mode settings.
   */
  anonUid: Long;
  /**
   * An integer representing the anonymous group id with a default value of
   * 65534.
   * Anon_gid may only be set with squash_mode of ROOT_SQUASH.  An error will be
   * returned if this field is specified for other squash_mode settings.
   */
  anonGid: Long;
}

/** The access mode. */
export enum NfsExportOptions_AccessMode {
  /** ACCESS_MODE_UNSPECIFIED - AccessMode not set. */
  ACCESS_MODE_UNSPECIFIED = 0,
  /** READ_ONLY - The client can only read the file share. */
  READ_ONLY = 1,
  /** READ_WRITE - The client can read and write the file share (default). */
  READ_WRITE = 2,
  UNRECOGNIZED = -1,
}

export function nfsExportOptions_AccessModeFromJSON(object: any): NfsExportOptions_AccessMode {
  switch (object) {
    case 0:
    case "ACCESS_MODE_UNSPECIFIED":
      return NfsExportOptions_AccessMode.ACCESS_MODE_UNSPECIFIED;
    case 1:
    case "READ_ONLY":
      return NfsExportOptions_AccessMode.READ_ONLY;
    case 2:
    case "READ_WRITE":
      return NfsExportOptions_AccessMode.READ_WRITE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NfsExportOptions_AccessMode.UNRECOGNIZED;
  }
}

export function nfsExportOptions_AccessModeToJSON(object: NfsExportOptions_AccessMode): string {
  switch (object) {
    case NfsExportOptions_AccessMode.ACCESS_MODE_UNSPECIFIED:
      return "ACCESS_MODE_UNSPECIFIED";
    case NfsExportOptions_AccessMode.READ_ONLY:
      return "READ_ONLY";
    case NfsExportOptions_AccessMode.READ_WRITE:
      return "READ_WRITE";
    case NfsExportOptions_AccessMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The squash mode. */
export enum NfsExportOptions_SquashMode {
  /** SQUASH_MODE_UNSPECIFIED - SquashMode not set. */
  SQUASH_MODE_UNSPECIFIED = 0,
  /** NO_ROOT_SQUASH - The Root user has root access to the file share (default). */
  NO_ROOT_SQUASH = 1,
  /** ROOT_SQUASH - The Root user has squashed access to the anonymous uid/gid. */
  ROOT_SQUASH = 2,
  UNRECOGNIZED = -1,
}

export function nfsExportOptions_SquashModeFromJSON(object: any): NfsExportOptions_SquashMode {
  switch (object) {
    case 0:
    case "SQUASH_MODE_UNSPECIFIED":
      return NfsExportOptions_SquashMode.SQUASH_MODE_UNSPECIFIED;
    case 1:
    case "NO_ROOT_SQUASH":
      return NfsExportOptions_SquashMode.NO_ROOT_SQUASH;
    case 2:
    case "ROOT_SQUASH":
      return NfsExportOptions_SquashMode.ROOT_SQUASH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NfsExportOptions_SquashMode.UNRECOGNIZED;
  }
}

export function nfsExportOptions_SquashModeToJSON(object: NfsExportOptions_SquashMode): string {
  switch (object) {
    case NfsExportOptions_SquashMode.SQUASH_MODE_UNSPECIFIED:
      return "SQUASH_MODE_UNSPECIFIED";
    case NfsExportOptions_SquashMode.NO_ROOT_SQUASH:
      return "NO_ROOT_SQUASH";
    case NfsExportOptions_SquashMode.ROOT_SQUASH:
      return "ROOT_SQUASH";
    case NfsExportOptions_SquashMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A Filestore instance. */
export interface Instance {
  /**
   * Output only. The resource name of the instance, in the format
   * `projects/{project}/locations/{location}/instances/{instance}`.
   */
  name: string;
  /** The description of the instance (2048 characters or less). */
  description: string;
  /** Output only. The instance state. */
  state: Instance_State;
  /** Output only. Additional information about the instance state, if available. */
  statusMessage: string;
  /** Output only. The time when the instance was created. */
  createTime:
    | Date
    | undefined;
  /** The service tier of the instance. */
  tier: Instance_Tier;
  /** Resource labels to represent user provided metadata. */
  labels: { [key: string]: string };
  /**
   * File system shares on the instance.
   * For this version, only a single file share is supported.
   */
  fileShares: FileShareConfig[];
  /**
   * VPC networks to which the instance is connected.
   * For this version, only a single network is supported.
   */
  networks: NetworkConfig[];
  /**
   * Server-specified ETag for the instance resource to prevent simultaneous
   * updates from overwriting each other.
   */
  etag: string;
  /** Output only. Reserved for future use. */
  satisfiesPzs:
    | boolean
    | undefined;
  /** Output only. Reserved for future use. */
  satisfiesPzi: boolean;
  /** KMS key name used for data encryption. */
  kmsKeyName: string;
  /**
   * Output only. Field indicates all the reasons the instance is in "SUSPENDED"
   * state.
   */
  suspensionReasons: Instance_SuspensionReason[];
}

/** The instance state. */
export enum Instance_State {
  /** STATE_UNSPECIFIED - State not set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The instance is being created. */
  CREATING = 1,
  /** READY - The instance is available for use. */
  READY = 2,
  /**
   * REPAIRING - Work is being done on the instance. You can get further details from the
   * `statusMessage` field of the `Instance` resource.
   */
  REPAIRING = 3,
  /** DELETING - The instance is shutting down. */
  DELETING = 4,
  /**
   * ERROR - The instance is experiencing an issue and might be unusable. You can get
   * further details from the `statusMessage` field of the `Instance`
   * resource.
   */
  ERROR = 6,
  /**
   * RESTORING - The instance is restoring a backup to an existing file share and may be
   * unusable during this time.
   */
  RESTORING = 7,
  /**
   * SUSPENDED - The instance is suspended. You can get further details from
   * the `suspension_reasons` field of the `Instance` resource.
   */
  SUSPENDED = 8,
  /** SUSPENDING - The instance is in the process of becoming suspended. */
  SUSPENDING = 9,
  /** RESUMING - The instance is in the process of becoming active. */
  RESUMING = 10,
  /** REVERTING - The instance is reverting to a snapshot. */
  REVERTING = 12,
  UNRECOGNIZED = -1,
}

export function instance_StateFromJSON(object: any): Instance_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Instance_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Instance_State.CREATING;
    case 2:
    case "READY":
      return Instance_State.READY;
    case 3:
    case "REPAIRING":
      return Instance_State.REPAIRING;
    case 4:
    case "DELETING":
      return Instance_State.DELETING;
    case 6:
    case "ERROR":
      return Instance_State.ERROR;
    case 7:
    case "RESTORING":
      return Instance_State.RESTORING;
    case 8:
    case "SUSPENDED":
      return Instance_State.SUSPENDED;
    case 9:
    case "SUSPENDING":
      return Instance_State.SUSPENDING;
    case 10:
    case "RESUMING":
      return Instance_State.RESUMING;
    case 12:
    case "REVERTING":
      return Instance_State.REVERTING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_State.UNRECOGNIZED;
  }
}

export function instance_StateToJSON(object: Instance_State): string {
  switch (object) {
    case Instance_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Instance_State.CREATING:
      return "CREATING";
    case Instance_State.READY:
      return "READY";
    case Instance_State.REPAIRING:
      return "REPAIRING";
    case Instance_State.DELETING:
      return "DELETING";
    case Instance_State.ERROR:
      return "ERROR";
    case Instance_State.RESTORING:
      return "RESTORING";
    case Instance_State.SUSPENDED:
      return "SUSPENDED";
    case Instance_State.SUSPENDING:
      return "SUSPENDING";
    case Instance_State.RESUMING:
      return "RESUMING";
    case Instance_State.REVERTING:
      return "REVERTING";
    case Instance_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Available service tiers. */
export enum Instance_Tier {
  /** TIER_UNSPECIFIED - Not set. */
  TIER_UNSPECIFIED = 0,
  /** STANDARD - STANDARD tier. BASIC_HDD is the preferred term for this tier. */
  STANDARD = 1,
  /** PREMIUM - PREMIUM tier. BASIC_SSD is the preferred term for this tier. */
  PREMIUM = 2,
  /**
   * BASIC_HDD - BASIC instances offer a maximum capacity of 63.9 TB.
   * BASIC_HDD is an alias for STANDARD Tier, offering economical
   * performance backed by HDD.
   */
  BASIC_HDD = 3,
  /**
   * BASIC_SSD - BASIC instances offer a maximum capacity of 63.9 TB.
   * BASIC_SSD is an alias for PREMIUM Tier, and offers improved
   * performance backed by SSD.
   */
  BASIC_SSD = 4,
  /**
   * HIGH_SCALE_SSD - HIGH_SCALE instances offer expanded capacity and performance scaling
   * capabilities.
   */
  HIGH_SCALE_SSD = 5,
  /**
   * ENTERPRISE - ENTERPRISE instances offer the features and availability needed for
   * mission-critical workloads.
   */
  ENTERPRISE = 6,
  /**
   * ZONAL - ZONAL instances offer expanded capacity and performance scaling
   * capabilities.
   */
  ZONAL = 7,
  /**
   * REGIONAL - REGIONAL instances offer the features and availability needed for
   * mission-critical workloads.
   */
  REGIONAL = 8,
  UNRECOGNIZED = -1,
}

export function instance_TierFromJSON(object: any): Instance_Tier {
  switch (object) {
    case 0:
    case "TIER_UNSPECIFIED":
      return Instance_Tier.TIER_UNSPECIFIED;
    case 1:
    case "STANDARD":
      return Instance_Tier.STANDARD;
    case 2:
    case "PREMIUM":
      return Instance_Tier.PREMIUM;
    case 3:
    case "BASIC_HDD":
      return Instance_Tier.BASIC_HDD;
    case 4:
    case "BASIC_SSD":
      return Instance_Tier.BASIC_SSD;
    case 5:
    case "HIGH_SCALE_SSD":
      return Instance_Tier.HIGH_SCALE_SSD;
    case 6:
    case "ENTERPRISE":
      return Instance_Tier.ENTERPRISE;
    case 7:
    case "ZONAL":
      return Instance_Tier.ZONAL;
    case 8:
    case "REGIONAL":
      return Instance_Tier.REGIONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_Tier.UNRECOGNIZED;
  }
}

export function instance_TierToJSON(object: Instance_Tier): string {
  switch (object) {
    case Instance_Tier.TIER_UNSPECIFIED:
      return "TIER_UNSPECIFIED";
    case Instance_Tier.STANDARD:
      return "STANDARD";
    case Instance_Tier.PREMIUM:
      return "PREMIUM";
    case Instance_Tier.BASIC_HDD:
      return "BASIC_HDD";
    case Instance_Tier.BASIC_SSD:
      return "BASIC_SSD";
    case Instance_Tier.HIGH_SCALE_SSD:
      return "HIGH_SCALE_SSD";
    case Instance_Tier.ENTERPRISE:
      return "ENTERPRISE";
    case Instance_Tier.ZONAL:
      return "ZONAL";
    case Instance_Tier.REGIONAL:
      return "REGIONAL";
    case Instance_Tier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** SuspensionReason contains the possible reasons for a suspension. */
export enum Instance_SuspensionReason {
  /** SUSPENSION_REASON_UNSPECIFIED - Not set. */
  SUSPENSION_REASON_UNSPECIFIED = 0,
  /** KMS_KEY_ISSUE - The KMS key used by the instance is either revoked or denied access to. */
  KMS_KEY_ISSUE = 1,
  UNRECOGNIZED = -1,
}

export function instance_SuspensionReasonFromJSON(object: any): Instance_SuspensionReason {
  switch (object) {
    case 0:
    case "SUSPENSION_REASON_UNSPECIFIED":
      return Instance_SuspensionReason.SUSPENSION_REASON_UNSPECIFIED;
    case 1:
    case "KMS_KEY_ISSUE":
      return Instance_SuspensionReason.KMS_KEY_ISSUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Instance_SuspensionReason.UNRECOGNIZED;
  }
}

export function instance_SuspensionReasonToJSON(object: Instance_SuspensionReason): string {
  switch (object) {
    case Instance_SuspensionReason.SUSPENSION_REASON_UNSPECIFIED:
      return "SUSPENSION_REASON_UNSPECIFIED";
    case Instance_SuspensionReason.KMS_KEY_ISSUE:
      return "KMS_KEY_ISSUE";
    case Instance_SuspensionReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Instance_LabelsEntry {
  key: string;
  value: string;
}

/** CreateInstanceRequest creates an instance. */
export interface CreateInstanceRequest {
  /**
   * Required. The instance's project and location, in the format
   * `projects/{project_id}/locations/{location}`. In Filestore,
   * locations map to Google Cloud zones, for example **us-west1-b**.
   */
  parent: string;
  /**
   * Required. The name of the instance to create.
   * The name must be unique for the specified project and location.
   */
  instanceId: string;
  /** Required. An [instance resource][google.cloud.filestore.v1.Instance] */
  instance: Instance | undefined;
}

/** GetInstanceRequest gets the state of an instance. */
export interface GetInstanceRequest {
  /**
   * Required. The instance resource name, in the format
   * `projects/{project_id}/locations/{location}/instances/{instance_id}`.
   */
  name: string;
}

/** UpdateInstanceRequest updates the settings of an instance. */
export interface UpdateInstanceRequest {
  /**
   * Mask of fields to update.  At least one path must be supplied in this
   * field.  The elements of the repeated paths field may only include these
   * fields:
   *
   * * "description"
   * * "file_shares"
   * * "labels"
   */
  updateMask:
    | string[]
    | undefined;
  /** Only fields specified in update_mask are updated. */
  instance: Instance | undefined;
}

/**
 * RestoreInstanceRequest restores an existing instance's file share from a
 * backup.
 */
export interface RestoreInstanceRequest {
  /**
   * Required. The resource name of the instance, in the format
   * `projects/{project_number}/locations/{location_id}/instances/{instance_id}`.
   */
  name: string;
  /**
   * Required. Name of the file share in the Filestore instance that the backup
   * is being restored to.
   */
  fileShare: string;
  /**
   * The resource name of the backup, in the format
   * `projects/{project_number}/locations/{location_id}/backups/{backup_id}`.
   */
  sourceBackup?: string | undefined;
}

/**
 * RevertInstanceRequest reverts the given instance's file share to the
 * specified snapshot.
 */
export interface RevertInstanceRequest {
  /**
   * Required.
   * `projects/{project_id}/locations/{location_id}/instances/{instance_id}`.
   * The resource name of the instance, in the format
   */
  name: string;
  /**
   * Required. The snapshot resource ID, in the format 'my-snapshot', where the
   * specified ID is the {snapshot_id} of the fully qualified name like
   * `projects/{project_id}/locations/{location_id}/instances/{instance_id}/snapshots/{snapshot_id}`
   */
  targetSnapshotId: string;
}

/** DeleteInstanceRequest deletes an instance. */
export interface DeleteInstanceRequest {
  /**
   * Required. The instance resource name, in the format
   * `projects/{project_id}/locations/{location}/instances/{instance_id}`
   */
  name: string;
  /**
   * If set to true, all snapshots of the instance will also be deleted.
   * (Otherwise, the request will only work if the instance has no snapshots.)
   */
  force: boolean;
}

/** ListInstancesRequest lists instances. */
export interface ListInstancesRequest {
  /**
   * Required. The project and location for which to retrieve instance
   * information, in the format `projects/{project_id}/locations/{location}`. In
   * Cloud Filestore, locations map to Google Cloud zones, for example
   * **us-west1-b**. To retrieve instance information for all locations, use "-"
   * for the
   * `{location}` value.
   */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /**
   * The next_page_token value to use if there are additional
   * results to retrieve for this list request.
   */
  pageToken: string;
  /** Sort results. Supported values are "name", "name desc" or "" (unsorted). */
  orderBy: string;
  /** List filter. */
  filter: string;
}

/** ListInstancesResponse is the result of ListInstancesRequest. */
export interface ListInstancesResponse {
  /**
   * A list of instances in the project for the specified location.
   *
   * If the `{location}` value in the request is "-", the response contains a
   * list of instances from all locations. If any location is unreachable, the
   * response will only return instances in reachable locations and the
   * "unreachable" field will be populated with a list of unreachable locations.
   */
  instances: Instance[];
  /**
   * The token you can use to retrieve the next page of results. Not returned
   * if there are no more results in the list.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** A Filestore snapshot. */
export interface Snapshot {
  /**
   * Output only. The resource name of the snapshot, in the format
   * `projects/{project_id}/locations/{location_id}/instances/{instance_id}/snapshots/{snapshot_id}`.
   */
  name: string;
  /**
   * A description of the snapshot with 2048 characters or less.
   * Requests with longer descriptions will be rejected.
   */
  description: string;
  /** Output only. The snapshot state. */
  state: Snapshot_State;
  /** Output only. The time when the snapshot was created. */
  createTime:
    | Date
    | undefined;
  /** Resource labels to represent user provided metadata. */
  labels: { [key: string]: string };
  /**
   * Output only. The amount of bytes needed to allocate a full copy of the
   * snapshot content
   */
  filesystemUsedBytes: Long;
}

/** The snapshot state. */
export enum Snapshot_State {
  /** STATE_UNSPECIFIED - State not set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - Snapshot is being created. */
  CREATING = 1,
  /** READY - Snapshot is available for use. */
  READY = 2,
  /** DELETING - Snapshot is being deleted. */
  DELETING = 3,
  UNRECOGNIZED = -1,
}

export function snapshot_StateFromJSON(object: any): Snapshot_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Snapshot_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Snapshot_State.CREATING;
    case 2:
    case "READY":
      return Snapshot_State.READY;
    case 3:
    case "DELETING":
      return Snapshot_State.DELETING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Snapshot_State.UNRECOGNIZED;
  }
}

export function snapshot_StateToJSON(object: Snapshot_State): string {
  switch (object) {
    case Snapshot_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Snapshot_State.CREATING:
      return "CREATING";
    case Snapshot_State.READY:
      return "READY";
    case Snapshot_State.DELETING:
      return "DELETING";
    case Snapshot_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Snapshot_LabelsEntry {
  key: string;
  value: string;
}

/** CreateSnapshotRequest creates a snapshot. */
export interface CreateSnapshotRequest {
  /**
   * Required. The Filestore Instance to create the snapshots of, in the format
   * `projects/{project_id}/locations/{location}/instances/{instance_id}`
   */
  parent: string;
  /**
   * Required. The ID to use for the snapshot.
   * The ID must be unique within the specified instance.
   *
   * This value must start with a lowercase letter followed by up to 62
   * lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
   */
  snapshotId: string;
  /** Required. A snapshot resource. */
  snapshot: Snapshot | undefined;
}

/** GetSnapshotRequest gets the state of a snapshot. */
export interface GetSnapshotRequest {
  /**
   * Required. The snapshot resource name, in the format
   * `projects/{project_id}/locations/{location}/instances/{instance_id}/snapshots/{snapshot_id}`
   */
  name: string;
}

/** DeleteSnapshotRequest deletes a snapshot. */
export interface DeleteSnapshotRequest {
  /**
   * Required. The snapshot resource name, in the format
   * `projects/{project_id}/locations/{location}/instances/{instance_id}/snapshots/{snapshot_id}`
   */
  name: string;
}

/** UpdateSnapshotRequest updates description and/or labels for a snapshot. */
export interface UpdateSnapshotRequest {
  /**
   * Required. Mask of fields to update. At least one path must be supplied in
   * this field.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. A snapshot resource. */
  snapshot: Snapshot | undefined;
}

/** ListSnapshotsRequest lists snapshots. */
export interface ListSnapshotsRequest {
  /**
   * Required. The instance for which to retrieve snapshot information,
   * in the format
   * `projects/{project_id}/locations/{location}/instances/{instance_id}`.
   */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /**
   * The next_page_token value to use if there are additional
   * results to retrieve for this list request.
   */
  pageToken: string;
  /** Sort results. Supported values are "name", "name desc" or "" (unsorted). */
  orderBy: string;
  /** List filter. */
  filter: string;
}

/** ListSnapshotsResponse is the result of ListSnapshotsRequest. */
export interface ListSnapshotsResponse {
  /** A list of snapshots in the project for the specified instance. */
  snapshots: Snapshot[];
  /**
   * The token you can use to retrieve the next page of results. Not returned
   * if there are no more results in the list.
   */
  nextPageToken: string;
}

/** A Filestore backup. */
export interface Backup {
  /**
   * Output only. The resource name of the backup, in the format
   * `projects/{project_number}/locations/{location_id}/backups/{backup_id}`.
   */
  name: string;
  /**
   * A description of the backup with 2048 characters or less.
   * Requests with longer descriptions will be rejected.
   */
  description: string;
  /** Output only. The backup state. */
  state: Backup_State;
  /** Output only. The time when the backup was created. */
  createTime:
    | Date
    | undefined;
  /** Resource labels to represent user provided metadata. */
  labels: { [key: string]: string };
  /** Output only. Capacity of the source file share when the backup was created. */
  capacityGb: Long;
  /**
   * Output only. The size of the storage used by the backup. As backups share
   * storage, this number is expected to change with backup creation/deletion.
   */
  storageBytes: Long;
  /**
   * The resource name of the source Filestore instance, in the format
   * `projects/{project_number}/locations/{location_id}/instances/{instance_id}`,
   * used to create this backup.
   */
  sourceInstance: string;
  /**
   * Name of the file share in the source Filestore instance that the
   * backup is created from.
   */
  sourceFileShare: string;
  /**
   * Output only. The service tier of the source Filestore instance that this
   * backup is created from.
   */
  sourceInstanceTier: Instance_Tier;
  /**
   * Output only. Amount of bytes that will be downloaded if the backup is
   * restored. This may be different than storage bytes, since sequential
   * backups of the same disk will share storage.
   */
  downloadBytes: Long;
  /** Output only. Reserved for future use. */
  satisfiesPzs:
    | boolean
    | undefined;
  /** Output only. Reserved for future use. */
  satisfiesPzi: boolean;
  /** Immutable. KMS key name used for data encryption. */
  kmsKey: string;
}

/** The backup state. */
export enum Backup_State {
  /** STATE_UNSPECIFIED - State not set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - Backup is being created. */
  CREATING = 1,
  /**
   * FINALIZING - Backup has been taken and the operation is being finalized. At this
   * point, changes to the file share will not be reflected in the backup.
   */
  FINALIZING = 2,
  /** READY - Backup is available for use. */
  READY = 3,
  /** DELETING - Backup is being deleted. */
  DELETING = 4,
  /**
   * INVALID - Backup is not valid and cannot be used for creating new instances or
   * restoring existing instances.
   */
  INVALID = 5,
  UNRECOGNIZED = -1,
}

export function backup_StateFromJSON(object: any): Backup_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Backup_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Backup_State.CREATING;
    case 2:
    case "FINALIZING":
      return Backup_State.FINALIZING;
    case 3:
    case "READY":
      return Backup_State.READY;
    case 4:
    case "DELETING":
      return Backup_State.DELETING;
    case 5:
    case "INVALID":
      return Backup_State.INVALID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Backup_State.UNRECOGNIZED;
  }
}

export function backup_StateToJSON(object: Backup_State): string {
  switch (object) {
    case Backup_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Backup_State.CREATING:
      return "CREATING";
    case Backup_State.FINALIZING:
      return "FINALIZING";
    case Backup_State.READY:
      return "READY";
    case Backup_State.DELETING:
      return "DELETING";
    case Backup_State.INVALID:
      return "INVALID";
    case Backup_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Backup_LabelsEntry {
  key: string;
  value: string;
}

/** CreateBackupRequest creates a backup. */
export interface CreateBackupRequest {
  /**
   * Required. The backup's project and location, in the format
   * `projects/{project_number}/locations/{location}`. In Filestore,
   * backup locations map to Google Cloud regions, for example **us-west1**.
   */
  parent: string;
  /** Required. A [backup resource][google.cloud.filestore.v1.Backup] */
  backup:
    | Backup
    | undefined;
  /**
   * Required. The ID to use for the backup.
   * The ID must be unique within the specified project and location.
   *
   * This value must start with a lowercase letter followed by up to 62
   * lowercase letters, numbers, or hyphens, and cannot end with a hyphen.
   * Values that do not match this pattern will trigger an INVALID_ARGUMENT
   * error.
   */
  backupId: string;
}

/** DeleteBackupRequest deletes a backup. */
export interface DeleteBackupRequest {
  /**
   * Required. The backup resource name, in the format
   * `projects/{project_number}/locations/{location}/backups/{backup_id}`
   */
  name: string;
}

/** UpdateBackupRequest updates description and/or labels for a backup. */
export interface UpdateBackupRequest {
  /** Required. A [backup resource][google.cloud.filestore.v1.Backup] */
  backup:
    | Backup
    | undefined;
  /**
   * Required. Mask of fields to update.  At least one path must be supplied in
   * this field.
   */
  updateMask: string[] | undefined;
}

/** GetBackupRequest gets the state of a backup. */
export interface GetBackupRequest {
  /**
   * Required. The backup resource name, in the format
   * `projects/{project_number}/locations/{location}/backups/{backup_id}`.
   */
  name: string;
}

/** ListBackupsRequest lists backups. */
export interface ListBackupsRequest {
  /**
   * Required. The project and location for which to retrieve backup
   * information, in the format
   * `projects/{project_number}/locations/{location}`. In Filestore, backup
   * locations map to Google Cloud regions, for example **us-west1**. To
   * retrieve backup information for all locations, use "-" for the
   * `{location}` value.
   */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /**
   * The next_page_token value to use if there are additional
   * results to retrieve for this list request.
   */
  pageToken: string;
  /** Sort results. Supported values are "name", "name desc" or "" (unsorted). */
  orderBy: string;
  /** List filter. */
  filter: string;
}

/** ListBackupsResponse is the result of ListBackupsRequest. */
export interface ListBackupsResponse {
  /**
   * A list of backups in the project for the specified location.
   *
   * If the `{location}` value in the request is "-", the response contains a
   * list of backups from all locations. If any location is unreachable, the
   * response will only return backups in reachable locations and the
   * "unreachable" field will be populated with a list of unreachable
   * locations.
   */
  backups: Backup[];
  /**
   * The token you can use to retrieve the next page of results. Not returned
   * if there are no more results in the list.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

function createBaseNetworkConfig(): NetworkConfig {
  return { network: "", modes: [], reservedIpRange: "", ipAddresses: [], connectMode: 0 };
}

export const NetworkConfig: MessageFns<NetworkConfig> = {
  encode(message: NetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    writer.uint32(26).fork();
    for (const v of message.modes) {
      writer.int32(v);
    }
    writer.join();
    if (message.reservedIpRange !== "") {
      writer.uint32(34).string(message.reservedIpRange);
    }
    for (const v of message.ipAddresses) {
      writer.uint32(42).string(v!);
    }
    if (message.connectMode !== 0) {
      writer.uint32(48).int32(message.connectMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 3:
          if (tag === 24) {
            message.modes.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.modes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.reservedIpRange = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ipAddresses.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.connectMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkConfig {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      modes: globalThis.Array.isArray(object?.modes)
        ? object.modes.map((e: any) => networkConfig_AddressModeFromJSON(e))
        : [],
      reservedIpRange: isSet(object.reservedIpRange) ? globalThis.String(object.reservedIpRange) : "",
      ipAddresses: globalThis.Array.isArray(object?.ipAddresses)
        ? object.ipAddresses.map((e: any) => globalThis.String(e))
        : [],
      connectMode: isSet(object.connectMode) ? networkConfig_ConnectModeFromJSON(object.connectMode) : 0,
    };
  },

  toJSON(message: NetworkConfig): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.modes?.length) {
      obj.modes = message.modes.map((e) => networkConfig_AddressModeToJSON(e));
    }
    if (message.reservedIpRange !== "") {
      obj.reservedIpRange = message.reservedIpRange;
    }
    if (message.ipAddresses?.length) {
      obj.ipAddresses = message.ipAddresses;
    }
    if (message.connectMode !== 0) {
      obj.connectMode = networkConfig_ConnectModeToJSON(message.connectMode);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkConfig>): NetworkConfig {
    return NetworkConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkConfig>): NetworkConfig {
    const message = createBaseNetworkConfig();
    message.network = object.network ?? "";
    message.modes = object.modes?.map((e) => e) || [];
    message.reservedIpRange = object.reservedIpRange ?? "";
    message.ipAddresses = object.ipAddresses?.map((e) => e) || [];
    message.connectMode = object.connectMode ?? 0;
    return message;
  },
};

function createBaseFileShareConfig(): FileShareConfig {
  return { name: "", capacityGb: Long.ZERO, sourceBackup: undefined, nfsExportOptions: [] };
}

export const FileShareConfig: MessageFns<FileShareConfig> = {
  encode(message: FileShareConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.capacityGb.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.capacityGb.toString());
    }
    if (message.sourceBackup !== undefined) {
      writer.uint32(66).string(message.sourceBackup);
    }
    for (const v of message.nfsExportOptions) {
      NfsExportOptions.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileShareConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileShareConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.capacityGb = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.sourceBackup = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.nfsExportOptions.push(NfsExportOptions.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileShareConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      capacityGb: isSet(object.capacityGb) ? Long.fromValue(object.capacityGb) : Long.ZERO,
      sourceBackup: isSet(object.sourceBackup) ? globalThis.String(object.sourceBackup) : undefined,
      nfsExportOptions: globalThis.Array.isArray(object?.nfsExportOptions)
        ? object.nfsExportOptions.map((e: any) => NfsExportOptions.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FileShareConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.capacityGb.equals(Long.ZERO)) {
      obj.capacityGb = (message.capacityGb || Long.ZERO).toString();
    }
    if (message.sourceBackup !== undefined) {
      obj.sourceBackup = message.sourceBackup;
    }
    if (message.nfsExportOptions?.length) {
      obj.nfsExportOptions = message.nfsExportOptions.map((e) => NfsExportOptions.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<FileShareConfig>): FileShareConfig {
    return FileShareConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileShareConfig>): FileShareConfig {
    const message = createBaseFileShareConfig();
    message.name = object.name ?? "";
    message.capacityGb = (object.capacityGb !== undefined && object.capacityGb !== null)
      ? Long.fromValue(object.capacityGb)
      : Long.ZERO;
    message.sourceBackup = object.sourceBackup ?? undefined;
    message.nfsExportOptions = object.nfsExportOptions?.map((e) => NfsExportOptions.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNfsExportOptions(): NfsExportOptions {
  return { ipRanges: [], accessMode: 0, squashMode: 0, anonUid: Long.ZERO, anonGid: Long.ZERO };
}

export const NfsExportOptions: MessageFns<NfsExportOptions> = {
  encode(message: NfsExportOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ipRanges) {
      writer.uint32(10).string(v!);
    }
    if (message.accessMode !== 0) {
      writer.uint32(16).int32(message.accessMode);
    }
    if (message.squashMode !== 0) {
      writer.uint32(24).int32(message.squashMode);
    }
    if (!message.anonUid.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.anonUid.toString());
    }
    if (!message.anonGid.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.anonGid.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NfsExportOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNfsExportOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipRanges.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.accessMode = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.squashMode = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.anonUid = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.anonGid = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NfsExportOptions {
    return {
      ipRanges: globalThis.Array.isArray(object?.ipRanges) ? object.ipRanges.map((e: any) => globalThis.String(e)) : [],
      accessMode: isSet(object.accessMode) ? nfsExportOptions_AccessModeFromJSON(object.accessMode) : 0,
      squashMode: isSet(object.squashMode) ? nfsExportOptions_SquashModeFromJSON(object.squashMode) : 0,
      anonUid: isSet(object.anonUid) ? Long.fromValue(object.anonUid) : Long.ZERO,
      anonGid: isSet(object.anonGid) ? Long.fromValue(object.anonGid) : Long.ZERO,
    };
  },

  toJSON(message: NfsExportOptions): unknown {
    const obj: any = {};
    if (message.ipRanges?.length) {
      obj.ipRanges = message.ipRanges;
    }
    if (message.accessMode !== 0) {
      obj.accessMode = nfsExportOptions_AccessModeToJSON(message.accessMode);
    }
    if (message.squashMode !== 0) {
      obj.squashMode = nfsExportOptions_SquashModeToJSON(message.squashMode);
    }
    if (!message.anonUid.equals(Long.ZERO)) {
      obj.anonUid = (message.anonUid || Long.ZERO).toString();
    }
    if (!message.anonGid.equals(Long.ZERO)) {
      obj.anonGid = (message.anonGid || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<NfsExportOptions>): NfsExportOptions {
    return NfsExportOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NfsExportOptions>): NfsExportOptions {
    const message = createBaseNfsExportOptions();
    message.ipRanges = object.ipRanges?.map((e) => e) || [];
    message.accessMode = object.accessMode ?? 0;
    message.squashMode = object.squashMode ?? 0;
    message.anonUid = (object.anonUid !== undefined && object.anonUid !== null)
      ? Long.fromValue(object.anonUid)
      : Long.ZERO;
    message.anonGid = (object.anonGid !== undefined && object.anonGid !== null)
      ? Long.fromValue(object.anonGid)
      : Long.ZERO;
    return message;
  },
};

function createBaseInstance(): Instance {
  return {
    name: "",
    description: "",
    state: 0,
    statusMessage: "",
    createTime: undefined,
    tier: 0,
    labels: {},
    fileShares: [],
    networks: [],
    etag: "",
    satisfiesPzs: undefined,
    satisfiesPzi: false,
    kmsKeyName: "",
    suspensionReasons: [],
  };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.statusMessage !== "") {
      writer.uint32(50).string(message.statusMessage);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.tier !== 0) {
      writer.uint32(64).int32(message.tier);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Instance_LabelsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    for (const v of message.fileShares) {
      FileShareConfig.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.networks) {
      NetworkConfig.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.etag !== "") {
      writer.uint32(98).string(message.etag);
    }
    if (message.satisfiesPzs !== undefined) {
      BoolValue.encode({ value: message.satisfiesPzs! }, writer.uint32(106).fork()).join();
    }
    if (message.satisfiesPzi !== false) {
      writer.uint32(144).bool(message.satisfiesPzi);
    }
    if (message.kmsKeyName !== "") {
      writer.uint32(114).string(message.kmsKeyName);
    }
    writer.uint32(122).fork();
    for (const v of message.suspensionReasons) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = Instance_LabelsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.labels[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.fileShares.push(FileShareConfig.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.networks.push(NetworkConfig.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.satisfiesPzs = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
        case 15:
          if (tag === 120) {
            message.suspensionReasons.push(reader.int32() as any);

            continue;
          }

          if (tag === 122) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.suspensionReasons.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? instance_StateFromJSON(object.state) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      tier: isSet(object.tier) ? instance_TierFromJSON(object.tier) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      fileShares: globalThis.Array.isArray(object?.fileShares)
        ? object.fileShares.map((e: any) => FileShareConfig.fromJSON(e))
        : [],
      networks: globalThis.Array.isArray(object?.networks)
        ? object.networks.map((e: any) => NetworkConfig.fromJSON(e))
        : [],
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      satisfiesPzs: isSet(object.satisfiesPzs) ? Boolean(object.satisfiesPzs) : undefined,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : false,
      kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : "",
      suspensionReasons: globalThis.Array.isArray(object?.suspensionReasons)
        ? object.suspensionReasons.map((e: any) => instance_SuspensionReasonFromJSON(e))
        : [],
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = instance_StateToJSON(message.state);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.tier !== 0) {
      obj.tier = instance_TierToJSON(message.tier);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.fileShares?.length) {
      obj.fileShares = message.fileShares.map((e) => FileShareConfig.toJSON(e));
    }
    if (message.networks?.length) {
      obj.networks = message.networks.map((e) => NetworkConfig.toJSON(e));
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.satisfiesPzs !== undefined) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== false) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    if (message.kmsKeyName !== "") {
      obj.kmsKeyName = message.kmsKeyName;
    }
    if (message.suspensionReasons?.length) {
      obj.suspensionReasons = message.suspensionReasons.map((e) => instance_SuspensionReasonToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Instance>): Instance {
    return Instance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance>): Instance {
    const message = createBaseInstance();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    message.createTime = object.createTime ?? undefined;
    message.tier = object.tier ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.fileShares = object.fileShares?.map((e) => FileShareConfig.fromPartial(e)) || [];
    message.networks = object.networks?.map((e) => NetworkConfig.fromPartial(e)) || [];
    message.etag = object.etag ?? "";
    message.satisfiesPzs = object.satisfiesPzs ?? undefined;
    message.satisfiesPzi = object.satisfiesPzi ?? false;
    message.kmsKeyName = object.kmsKeyName ?? "";
    message.suspensionReasons = object.suspensionReasons?.map((e) => e) || [];
    return message;
  },
};

function createBaseInstance_LabelsEntry(): Instance_LabelsEntry {
  return { key: "", value: "" };
}

export const Instance_LabelsEntry: MessageFns<Instance_LabelsEntry> = {
  encode(message: Instance_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Instance_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    return Instance_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Instance_LabelsEntry>): Instance_LabelsEntry {
    const message = createBaseInstance_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateInstanceRequest(): CreateInstanceRequest {
  return { parent: "", instanceId: "", instance: undefined };
}

export const CreateInstanceRequest: MessageFns<CreateInstanceRequest> = {
  encode(message: CreateInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateInstanceRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: CreateInstanceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateInstanceRequest>): CreateInstanceRequest {
    return CreateInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateInstanceRequest>): CreateInstanceRequest {
    const message = createBaseCreateInstanceRequest();
    message.parent = object.parent ?? "";
    message.instanceId = object.instanceId ?? "";
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseGetInstanceRequest(): GetInstanceRequest {
  return { name: "" };
}

export const GetInstanceRequest: MessageFns<GetInstanceRequest> = {
  encode(message: GetInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetInstanceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    return GetInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetInstanceRequest>): GetInstanceRequest {
    const message = createBaseGetInstanceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateInstanceRequest(): UpdateInstanceRequest {
  return { updateMask: undefined, instance: undefined };
}

export const UpdateInstanceRequest: MessageFns<UpdateInstanceRequest> = {
  encode(message: UpdateInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.instance !== undefined) {
      Instance.encode(message.instance, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.instance = Instance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateInstanceRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      instance: isSet(object.instance) ? Instance.fromJSON(object.instance) : undefined,
    };
  },

  toJSON(message: UpdateInstanceRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.instance !== undefined) {
      obj.instance = Instance.toJSON(message.instance);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateInstanceRequest>): UpdateInstanceRequest {
    return UpdateInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateInstanceRequest>): UpdateInstanceRequest {
    const message = createBaseUpdateInstanceRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.instance = (object.instance !== undefined && object.instance !== null)
      ? Instance.fromPartial(object.instance)
      : undefined;
    return message;
  },
};

function createBaseRestoreInstanceRequest(): RestoreInstanceRequest {
  return { name: "", fileShare: "", sourceBackup: undefined };
}

export const RestoreInstanceRequest: MessageFns<RestoreInstanceRequest> = {
  encode(message: RestoreInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fileShare !== "") {
      writer.uint32(18).string(message.fileShare);
    }
    if (message.sourceBackup !== undefined) {
      writer.uint32(26).string(message.sourceBackup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fileShare = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sourceBackup = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreInstanceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fileShare: isSet(object.fileShare) ? globalThis.String(object.fileShare) : "",
      sourceBackup: isSet(object.sourceBackup) ? globalThis.String(object.sourceBackup) : undefined,
    };
  },

  toJSON(message: RestoreInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fileShare !== "") {
      obj.fileShare = message.fileShare;
    }
    if (message.sourceBackup !== undefined) {
      obj.sourceBackup = message.sourceBackup;
    }
    return obj;
  },

  create(base?: DeepPartial<RestoreInstanceRequest>): RestoreInstanceRequest {
    return RestoreInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestoreInstanceRequest>): RestoreInstanceRequest {
    const message = createBaseRestoreInstanceRequest();
    message.name = object.name ?? "";
    message.fileShare = object.fileShare ?? "";
    message.sourceBackup = object.sourceBackup ?? undefined;
    return message;
  },
};

function createBaseRevertInstanceRequest(): RevertInstanceRequest {
  return { name: "", targetSnapshotId: "" };
}

export const RevertInstanceRequest: MessageFns<RevertInstanceRequest> = {
  encode(message: RevertInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.targetSnapshotId !== "") {
      writer.uint32(18).string(message.targetSnapshotId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevertInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevertInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.targetSnapshotId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevertInstanceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      targetSnapshotId: isSet(object.targetSnapshotId) ? globalThis.String(object.targetSnapshotId) : "",
    };
  },

  toJSON(message: RevertInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.targetSnapshotId !== "") {
      obj.targetSnapshotId = message.targetSnapshotId;
    }
    return obj;
  },

  create(base?: DeepPartial<RevertInstanceRequest>): RevertInstanceRequest {
    return RevertInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RevertInstanceRequest>): RevertInstanceRequest {
    const message = createBaseRevertInstanceRequest();
    message.name = object.name ?? "";
    message.targetSnapshotId = object.targetSnapshotId ?? "";
    return message;
  },
};

function createBaseDeleteInstanceRequest(): DeleteInstanceRequest {
  return { name: "", force: false };
}

export const DeleteInstanceRequest: MessageFns<DeleteInstanceRequest> = {
  encode(message: DeleteInstanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteInstanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInstanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteInstanceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteInstanceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteInstanceRequest>): DeleteInstanceRequest {
    return DeleteInstanceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteInstanceRequest>): DeleteInstanceRequest {
    const message = createBaseDeleteInstanceRequest();
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseListInstancesRequest(): ListInstancesRequest {
  return { parent: "", pageSize: 0, pageToken: "", orderBy: "", filter: "" };
}

export const ListInstancesRequest: MessageFns<ListInstancesRequest> = {
  encode(message: ListInstancesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListInstancesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    return ListInstancesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesRequest>): ListInstancesRequest {
    const message = createBaseListInstancesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.orderBy = object.orderBy ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListInstancesResponse(): ListInstancesResponse {
  return { instances: [], nextPageToken: "", unreachable: [] };
}

export const ListInstancesResponse: MessageFns<ListInstancesResponse> = {
  encode(message: ListInstancesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instances) {
      Instance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListInstancesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListInstancesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instances.push(Instance.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListInstancesResponse {
    return {
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => Instance.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListInstancesResponse): unknown {
    const obj: any = {};
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => Instance.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    return ListInstancesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListInstancesResponse>): ListInstancesResponse {
    const message = createBaseListInstancesResponse();
    message.instances = object.instances?.map((e) => Instance.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseSnapshot(): Snapshot {
  return { name: "", description: "", state: 0, createTime: undefined, labels: {}, filesystemUsedBytes: Long.ZERO };
}

export const Snapshot: MessageFns<Snapshot> = {
  encode(message: Snapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Snapshot_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (!message.filesystemUsedBytes.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.filesystemUsedBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Snapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Snapshot_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.filesystemUsedBytes = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Snapshot {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? snapshot_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      filesystemUsedBytes: isSet(object.filesystemUsedBytes) ? Long.fromValue(object.filesystemUsedBytes) : Long.ZERO,
    };
  },

  toJSON(message: Snapshot): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = snapshot_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (!message.filesystemUsedBytes.equals(Long.ZERO)) {
      obj.filesystemUsedBytes = (message.filesystemUsedBytes || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Snapshot>): Snapshot {
    return Snapshot.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Snapshot>): Snapshot {
    const message = createBaseSnapshot();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.filesystemUsedBytes = (object.filesystemUsedBytes !== undefined && object.filesystemUsedBytes !== null)
      ? Long.fromValue(object.filesystemUsedBytes)
      : Long.ZERO;
    return message;
  },
};

function createBaseSnapshot_LabelsEntry(): Snapshot_LabelsEntry {
  return { key: "", value: "" };
}

export const Snapshot_LabelsEntry: MessageFns<Snapshot_LabelsEntry> = {
  encode(message: Snapshot_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Snapshot_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapshot_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Snapshot_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Snapshot_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Snapshot_LabelsEntry>): Snapshot_LabelsEntry {
    return Snapshot_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Snapshot_LabelsEntry>): Snapshot_LabelsEntry {
    const message = createBaseSnapshot_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateSnapshotRequest(): CreateSnapshotRequest {
  return { parent: "", snapshotId: "", snapshot: undefined };
}

export const CreateSnapshotRequest: MessageFns<CreateSnapshotRequest> = {
  encode(message: CreateSnapshotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.snapshotId !== "") {
      writer.uint32(18).string(message.snapshotId);
    }
    if (message.snapshot !== undefined) {
      Snapshot.encode(message.snapshot, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSnapshotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshotId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.snapshot = Snapshot.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSnapshotRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      snapshotId: isSet(object.snapshotId) ? globalThis.String(object.snapshotId) : "",
      snapshot: isSet(object.snapshot) ? Snapshot.fromJSON(object.snapshot) : undefined,
    };
  },

  toJSON(message: CreateSnapshotRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    if (message.snapshot !== undefined) {
      obj.snapshot = Snapshot.toJSON(message.snapshot);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSnapshotRequest>): CreateSnapshotRequest {
    return CreateSnapshotRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSnapshotRequest>): CreateSnapshotRequest {
    const message = createBaseCreateSnapshotRequest();
    message.parent = object.parent ?? "";
    message.snapshotId = object.snapshotId ?? "";
    message.snapshot = (object.snapshot !== undefined && object.snapshot !== null)
      ? Snapshot.fromPartial(object.snapshot)
      : undefined;
    return message;
  },
};

function createBaseGetSnapshotRequest(): GetSnapshotRequest {
  return { name: "" };
}

export const GetSnapshotRequest: MessageFns<GetSnapshotRequest> = {
  encode(message: GetSnapshotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSnapshotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSnapshotRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetSnapshotRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSnapshotRequest>): GetSnapshotRequest {
    return GetSnapshotRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSnapshotRequest>): GetSnapshotRequest {
    const message = createBaseGetSnapshotRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteSnapshotRequest(): DeleteSnapshotRequest {
  return { name: "" };
}

export const DeleteSnapshotRequest: MessageFns<DeleteSnapshotRequest> = {
  encode(message: DeleteSnapshotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSnapshotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSnapshotRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteSnapshotRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSnapshotRequest>): DeleteSnapshotRequest {
    return DeleteSnapshotRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSnapshotRequest>): DeleteSnapshotRequest {
    const message = createBaseDeleteSnapshotRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateSnapshotRequest(): UpdateSnapshotRequest {
  return { updateMask: undefined, snapshot: undefined };
}

export const UpdateSnapshotRequest: MessageFns<UpdateSnapshotRequest> = {
  encode(message: UpdateSnapshotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.snapshot !== undefined) {
      Snapshot.encode(message.snapshot, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSnapshotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshot = Snapshot.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSnapshotRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      snapshot: isSet(object.snapshot) ? Snapshot.fromJSON(object.snapshot) : undefined,
    };
  },

  toJSON(message: UpdateSnapshotRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.snapshot !== undefined) {
      obj.snapshot = Snapshot.toJSON(message.snapshot);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSnapshotRequest>): UpdateSnapshotRequest {
    return UpdateSnapshotRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSnapshotRequest>): UpdateSnapshotRequest {
    const message = createBaseUpdateSnapshotRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.snapshot = (object.snapshot !== undefined && object.snapshot !== null)
      ? Snapshot.fromPartial(object.snapshot)
      : undefined;
    return message;
  },
};

function createBaseListSnapshotsRequest(): ListSnapshotsRequest {
  return { parent: "", pageSize: 0, pageToken: "", orderBy: "", filter: "" };
}

export const ListSnapshotsRequest: MessageFns<ListSnapshotsRequest> = {
  encode(message: ListSnapshotsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSnapshotsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSnapshotsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSnapshotsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListSnapshotsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSnapshotsRequest>): ListSnapshotsRequest {
    return ListSnapshotsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSnapshotsRequest>): ListSnapshotsRequest {
    const message = createBaseListSnapshotsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.orderBy = object.orderBy ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListSnapshotsResponse(): ListSnapshotsResponse {
  return { snapshots: [], nextPageToken: "" };
}

export const ListSnapshotsResponse: MessageFns<ListSnapshotsResponse> = {
  encode(message: ListSnapshotsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.snapshots) {
      Snapshot.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSnapshotsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSnapshotsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.snapshots.push(Snapshot.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSnapshotsResponse {
    return {
      snapshots: globalThis.Array.isArray(object?.snapshots)
        ? object.snapshots.map((e: any) => Snapshot.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSnapshotsResponse): unknown {
    const obj: any = {};
    if (message.snapshots?.length) {
      obj.snapshots = message.snapshots.map((e) => Snapshot.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSnapshotsResponse>): ListSnapshotsResponse {
    return ListSnapshotsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSnapshotsResponse>): ListSnapshotsResponse {
    const message = createBaseListSnapshotsResponse();
    message.snapshots = object.snapshots?.map((e) => Snapshot.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseBackup(): Backup {
  return {
    name: "",
    description: "",
    state: 0,
    createTime: undefined,
    labels: {},
    capacityGb: Long.ZERO,
    storageBytes: Long.ZERO,
    sourceInstance: "",
    sourceFileShare: "",
    sourceInstanceTier: 0,
    downloadBytes: Long.ZERO,
    satisfiesPzs: undefined,
    satisfiesPzi: false,
    kmsKey: "",
  };
}

export const Backup: MessageFns<Backup> = {
  encode(message: Backup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Backup_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (!message.capacityGb.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.capacityGb.toString());
    }
    if (!message.storageBytes.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.storageBytes.toString());
    }
    if (message.sourceInstance !== "") {
      writer.uint32(66).string(message.sourceInstance);
    }
    if (message.sourceFileShare !== "") {
      writer.uint32(74).string(message.sourceFileShare);
    }
    if (message.sourceInstanceTier !== 0) {
      writer.uint32(80).int32(message.sourceInstanceTier);
    }
    if (!message.downloadBytes.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.downloadBytes.toString());
    }
    if (message.satisfiesPzs !== undefined) {
      BoolValue.encode({ value: message.satisfiesPzs! }, writer.uint32(98).fork()).join();
    }
    if (message.satisfiesPzi !== false) {
      writer.uint32(112).bool(message.satisfiesPzi);
    }
    if (message.kmsKey !== "") {
      writer.uint32(106).string(message.kmsKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Backup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Backup_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.capacityGb = Long.fromString(reader.int64().toString());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.storageBytes = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.sourceInstance = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.sourceFileShare = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.sourceInstanceTier = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.downloadBytes = Long.fromString(reader.int64().toString());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.satisfiesPzs = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.satisfiesPzi = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.kmsKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Backup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? backup_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      capacityGb: isSet(object.capacityGb) ? Long.fromValue(object.capacityGb) : Long.ZERO,
      storageBytes: isSet(object.storageBytes) ? Long.fromValue(object.storageBytes) : Long.ZERO,
      sourceInstance: isSet(object.sourceInstance) ? globalThis.String(object.sourceInstance) : "",
      sourceFileShare: isSet(object.sourceFileShare) ? globalThis.String(object.sourceFileShare) : "",
      sourceInstanceTier: isSet(object.sourceInstanceTier) ? instance_TierFromJSON(object.sourceInstanceTier) : 0,
      downloadBytes: isSet(object.downloadBytes) ? Long.fromValue(object.downloadBytes) : Long.ZERO,
      satisfiesPzs: isSet(object.satisfiesPzs) ? Boolean(object.satisfiesPzs) : undefined,
      satisfiesPzi: isSet(object.satisfiesPzi) ? globalThis.Boolean(object.satisfiesPzi) : false,
      kmsKey: isSet(object.kmsKey) ? globalThis.String(object.kmsKey) : "",
    };
  },

  toJSON(message: Backup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = backup_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (!message.capacityGb.equals(Long.ZERO)) {
      obj.capacityGb = (message.capacityGb || Long.ZERO).toString();
    }
    if (!message.storageBytes.equals(Long.ZERO)) {
      obj.storageBytes = (message.storageBytes || Long.ZERO).toString();
    }
    if (message.sourceInstance !== "") {
      obj.sourceInstance = message.sourceInstance;
    }
    if (message.sourceFileShare !== "") {
      obj.sourceFileShare = message.sourceFileShare;
    }
    if (message.sourceInstanceTier !== 0) {
      obj.sourceInstanceTier = instance_TierToJSON(message.sourceInstanceTier);
    }
    if (!message.downloadBytes.equals(Long.ZERO)) {
      obj.downloadBytes = (message.downloadBytes || Long.ZERO).toString();
    }
    if (message.satisfiesPzs !== undefined) {
      obj.satisfiesPzs = message.satisfiesPzs;
    }
    if (message.satisfiesPzi !== false) {
      obj.satisfiesPzi = message.satisfiesPzi;
    }
    if (message.kmsKey !== "") {
      obj.kmsKey = message.kmsKey;
    }
    return obj;
  },

  create(base?: DeepPartial<Backup>): Backup {
    return Backup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Backup>): Backup {
    const message = createBaseBackup();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.capacityGb = (object.capacityGb !== undefined && object.capacityGb !== null)
      ? Long.fromValue(object.capacityGb)
      : Long.ZERO;
    message.storageBytes = (object.storageBytes !== undefined && object.storageBytes !== null)
      ? Long.fromValue(object.storageBytes)
      : Long.ZERO;
    message.sourceInstance = object.sourceInstance ?? "";
    message.sourceFileShare = object.sourceFileShare ?? "";
    message.sourceInstanceTier = object.sourceInstanceTier ?? 0;
    message.downloadBytes = (object.downloadBytes !== undefined && object.downloadBytes !== null)
      ? Long.fromValue(object.downloadBytes)
      : Long.ZERO;
    message.satisfiesPzs = object.satisfiesPzs ?? undefined;
    message.satisfiesPzi = object.satisfiesPzi ?? false;
    message.kmsKey = object.kmsKey ?? "";
    return message;
  },
};

function createBaseBackup_LabelsEntry(): Backup_LabelsEntry {
  return { key: "", value: "" };
}

export const Backup_LabelsEntry: MessageFns<Backup_LabelsEntry> = {
  encode(message: Backup_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Backup_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackup_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Backup_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Backup_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Backup_LabelsEntry>): Backup_LabelsEntry {
    return Backup_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Backup_LabelsEntry>): Backup_LabelsEntry {
    const message = createBaseBackup_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateBackupRequest(): CreateBackupRequest {
  return { parent: "", backup: undefined, backupId: "" };
}

export const CreateBackupRequest: MessageFns<CreateBackupRequest> = {
  encode(message: CreateBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.backup !== undefined) {
      Backup.encode(message.backup, writer.uint32(18).fork()).join();
    }
    if (message.backupId !== "") {
      writer.uint32(26).string(message.backupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backup = Backup.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBackupRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      backup: isSet(object.backup) ? Backup.fromJSON(object.backup) : undefined,
      backupId: isSet(object.backupId) ? globalThis.String(object.backupId) : "",
    };
  },

  toJSON(message: CreateBackupRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.backup !== undefined) {
      obj.backup = Backup.toJSON(message.backup);
    }
    if (message.backupId !== "") {
      obj.backupId = message.backupId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBackupRequest>): CreateBackupRequest {
    return CreateBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBackupRequest>): CreateBackupRequest {
    const message = createBaseCreateBackupRequest();
    message.parent = object.parent ?? "";
    message.backup = (object.backup !== undefined && object.backup !== null)
      ? Backup.fromPartial(object.backup)
      : undefined;
    message.backupId = object.backupId ?? "";
    return message;
  },
};

function createBaseDeleteBackupRequest(): DeleteBackupRequest {
  return { name: "" };
}

export const DeleteBackupRequest: MessageFns<DeleteBackupRequest> = {
  encode(message: DeleteBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteBackupRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteBackupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteBackupRequest>): DeleteBackupRequest {
    return DeleteBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteBackupRequest>): DeleteBackupRequest {
    const message = createBaseDeleteBackupRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateBackupRequest(): UpdateBackupRequest {
  return { backup: undefined, updateMask: undefined };
}

export const UpdateBackupRequest: MessageFns<UpdateBackupRequest> = {
  encode(message: UpdateBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backup !== undefined) {
      Backup.encode(message.backup, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backup = Backup.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBackupRequest {
    return {
      backup: isSet(object.backup) ? Backup.fromJSON(object.backup) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateBackupRequest): unknown {
    const obj: any = {};
    if (message.backup !== undefined) {
      obj.backup = Backup.toJSON(message.backup);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateBackupRequest>): UpdateBackupRequest {
    return UpdateBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateBackupRequest>): UpdateBackupRequest {
    const message = createBaseUpdateBackupRequest();
    message.backup = (object.backup !== undefined && object.backup !== null)
      ? Backup.fromPartial(object.backup)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseGetBackupRequest(): GetBackupRequest {
  return { name: "" };
}

export const GetBackupRequest: MessageFns<GetBackupRequest> = {
  encode(message: GetBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBackupRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetBackupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBackupRequest>): GetBackupRequest {
    return GetBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBackupRequest>): GetBackupRequest {
    const message = createBaseGetBackupRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListBackupsRequest(): ListBackupsRequest {
  return { parent: "", pageSize: 0, pageToken: "", orderBy: "", filter: "" };
}

export const ListBackupsRequest: MessageFns<ListBackupsRequest> = {
  encode(message: ListBackupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBackupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBackupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBackupsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListBackupsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBackupsRequest>): ListBackupsRequest {
    return ListBackupsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBackupsRequest>): ListBackupsRequest {
    const message = createBaseListBackupsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.orderBy = object.orderBy ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListBackupsResponse(): ListBackupsResponse {
  return { backups: [], nextPageToken: "", unreachable: [] };
}

export const ListBackupsResponse: MessageFns<ListBackupsResponse> = {
  encode(message: ListBackupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.backups) {
      Backup.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBackupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBackupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backups.push(Backup.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBackupsResponse {
    return {
      backups: globalThis.Array.isArray(object?.backups) ? object.backups.map((e: any) => Backup.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListBackupsResponse): unknown {
    const obj: any = {};
    if (message.backups?.length) {
      obj.backups = message.backups.map((e) => Backup.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBackupsResponse>): ListBackupsResponse {
    return ListBackupsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBackupsResponse>): ListBackupsResponse {
    const message = createBaseListBackupsResponse();
    message.backups = object.backups?.map((e) => Backup.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

/**
 * Configures and manages Filestore resources.
 *
 * Filestore Manager v1.
 *
 * The `file.googleapis.com` service implements the Filestore API and
 * defines the following resource model for managing instances:
 * * The service works with a collection of cloud projects, named: `/projects/*`
 * * Each project has a collection of available locations, named: `/locations/*`
 * * Each location has a collection of instances and backups, named:
 * `/instances/*` and `/backups/*` respectively.
 * * As such, Filestore instances are resources of the form:
 *   `/projects/{project_number}/locations/{location_id}/instances/{instance_id}`
 *   and backups are resources of the form:
 *   `/projects/{project_number}/locations/{location_id}/backup/{backup_id}`
 *
 * Note that location_id must be a Google Cloud `zone` for instances, but
 * a Google Cloud `region` for backups; for example:
 * * `projects/12345/locations/us-central1-c/instances/my-filestore`
 * * `projects/12345/locations/us-central1/backups/my-backup`
 */
export type CloudFilestoreManagerDefinition = typeof CloudFilestoreManagerDefinition;
export const CloudFilestoreManagerDefinition = {
  name: "CloudFilestoreManager",
  fullName: "google.cloud.filestore.v1.CloudFilestoreManager",
  methods: {
    /**
     * Lists all instances in a project for either a specified location
     * or for all locations.
     */
    listInstances: {
      name: "ListInstances",
      requestType: ListInstancesRequest,
      requestStream: false,
      responseType: ListInstancesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a specific instance. */
    getInstance: {
      name: "GetInstance",
      requestType: GetInstanceRequest,
      requestStream: false,
      responseType: Instance,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an instance.
     * When creating from a backup, the capacity of the new instance needs to be
     * equal to or larger than the capacity of the backup (and also equal to or
     * larger than the minimum capacity of the tier).
     */
    createInstance: {
      name: "CreateInstance",
      requestType: CreateInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              8,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              18,
              37,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              99,
              111,
              109,
              109,
              111,
              110,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              27,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              44,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              57,
              58,
              8,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              34,
              45,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates the settings of a specific instance. */
    updateInstance: {
      name: "UpdateInstance",
      requestType: UpdateInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              8,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              18,
              37,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              99,
              111,
              109,
              109,
              111,
              110,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              20,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              8,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              50,
              54,
              47,
              118,
              49,
              47,
              123,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Restores an existing instance's file share from a backup.
     *
     * The capacity of the instance needs to be equal to or larger than the
     * capacity of the backup (and also equal to or larger than the minimum
     * capacity of the tier).
     */
    restoreInstance: {
      name: "RestoreInstance",
      requestType: RestoreInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              8,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              18,
              37,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              99,
              111,
              109,
              109,
              111,
              110,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              116,
              111,
              114,
              101,
            ]),
          ],
        },
      },
    },
    /** Revert an existing instance's file system to a specified snapshot. */
    revertInstance: {
      name: "RevertInstance",
      requestType: RevertInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              8,
              73,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              18,
              37,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              99,
              111,
              109,
              109,
              111,
              110,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              57,
              58,
              1,
              42,
              34,
              52,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              118,
              101,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /** Deletes an instance. */
    deleteInstance: {
      name: "DeleteInstance",
      requestType: DeleteInstanceRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              62,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              37,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              99,
              111,
              109,
              109,
              111,
              110,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              47,
              42,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists all snapshots in a project for either a specified location
     * or for all locations.
     */
    listSnapshots: {
      name: "ListSnapshots",
      requestType: ListSnapshotsRequest,
      requestStream: false,
      responseType: ListSnapshotsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              115,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a specific snapshot. */
    getSnapshot: {
      name: "GetSnapshot",
      requestType: GetSnapshotRequest,
      requestStream: false,
      responseType: Snapshot,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              115,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a snapshot. */
    createSnapshot: {
      name: "CreateSnapshot",
      requestType: CreateSnapshotRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              8,
              83,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              18,
              37,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              99,
              111,
              109,
              109,
              111,
              110,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              27,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              115,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              44,
              115,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              8,
              115,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              115,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a snapshot. */
    deleteSnapshot: {
      name: "DeleteSnapshot",
      requestType: DeleteSnapshotRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              62,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              37,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              99,
              111,
              109,
              109,
              111,
              110,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              59,
              42,
              57,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              115,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the settings of a specific snapshot. */
    updateSnapshot: {
      name: "UpdateSnapshot",
      requestType: UpdateSnapshotRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              49,
              10,
              8,
              83,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              18,
              37,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              99,
              111,
              109,
              109,
              111,
              110,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              20,
              115,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              78,
              58,
              8,
              115,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              50,
              66,
              47,
              118,
              49,
              47,
              123,
              115,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              105,
              110,
              115,
              116,
              97,
              110,
              99,
              101,
              115,
              47,
              42,
              47,
              115,
              110,
              97,
              112,
              115,
              104,
              111,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists all backups in a project for either a specified location or for all
     * locations.
     */
    listBackups: {
      name: "ListBackups",
      requestType: ListBackupsRequest,
      requestStream: false,
      responseType: ListBackupsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              98,
              97,
              99,
              107,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a specific backup. */
    getBackup: {
      name: "GetBackup",
      requestType: GetBackupRequest,
      requestStream: false,
      responseType: Backup,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              98,
              97,
              99,
              107,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a backup. */
    createBackup: {
      name: "CreateBackup",
      requestType: CreateBackupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              47,
              10,
              6,
              66,
              97,
              99,
              107,
              117,
              112,
              18,
              37,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              99,
              111,
              109,
              109,
              111,
              110,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              98,
              97,
              99,
              107,
              117,
              112,
              44,
              98,
              97,
              99,
              107,
              117,
              112,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              53,
              58,
              6,
              98,
              97,
              99,
              107,
              117,
              112,
              34,
              43,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              98,
              97,
              99,
              107,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Deletes a backup. */
    deleteBackup: {
      name: "DeleteBackup",
      requestType: DeleteBackupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              62,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              37,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              99,
              111,
              109,
              109,
              111,
              110,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              45,
              42,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              98,
              97,
              99,
              107,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates the settings of a specific backup. */
    updateBackup: {
      name: "UpdateBackup",
      requestType: UpdateBackupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              47,
              10,
              6,
              66,
              97,
              99,
              107,
              117,
              112,
              18,
              37,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              99,
              108,
              111,
              117,
              100,
              46,
              99,
              111,
              109,
              109,
              111,
              110,
              46,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([18, 98, 97, 99, 107, 117, 112, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              60,
              58,
              6,
              98,
              97,
              99,
              107,
              117,
              112,
              50,
              50,
              47,
              118,
              49,
              47,
              123,
              98,
              97,
              99,
              107,
              117,
              112,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              98,
              97,
              99,
              107,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CloudFilestoreManagerServiceImplementation<CallContextExt = {}> {
  /**
   * Lists all instances in a project for either a specified location
   * or for all locations.
   */
  listInstances(
    request: ListInstancesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListInstancesResponse>>;
  /** Gets the details of a specific instance. */
  getInstance(request: GetInstanceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Instance>>;
  /**
   * Creates an instance.
   * When creating from a backup, the capacity of the new instance needs to be
   * equal to or larger than the capacity of the backup (and also equal to or
   * larger than the minimum capacity of the tier).
   */
  createInstance(
    request: CreateInstanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates the settings of a specific instance. */
  updateInstance(
    request: UpdateInstanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Restores an existing instance's file share from a backup.
   *
   * The capacity of the instance needs to be equal to or larger than the
   * capacity of the backup (and also equal to or larger than the minimum
   * capacity of the tier).
   */
  restoreInstance(
    request: RestoreInstanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Revert an existing instance's file system to a specified snapshot. */
  revertInstance(
    request: RevertInstanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes an instance. */
  deleteInstance(
    request: DeleteInstanceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Lists all snapshots in a project for either a specified location
   * or for all locations.
   */
  listSnapshots(
    request: ListSnapshotsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSnapshotsResponse>>;
  /** Gets the details of a specific snapshot. */
  getSnapshot(request: GetSnapshotRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Snapshot>>;
  /** Creates a snapshot. */
  createSnapshot(
    request: CreateSnapshotRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a snapshot. */
  deleteSnapshot(
    request: DeleteSnapshotRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates the settings of a specific snapshot. */
  updateSnapshot(
    request: UpdateSnapshotRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Lists all backups in a project for either a specified location or for all
   * locations.
   */
  listBackups(
    request: ListBackupsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListBackupsResponse>>;
  /** Gets the details of a specific backup. */
  getBackup(request: GetBackupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Backup>>;
  /** Creates a backup. */
  createBackup(request: CreateBackupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Deletes a backup. */
  deleteBackup(request: DeleteBackupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
  /** Updates the settings of a specific backup. */
  updateBackup(request: UpdateBackupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Operation>>;
}

export interface CloudFilestoreManagerClient<CallOptionsExt = {}> {
  /**
   * Lists all instances in a project for either a specified location
   * or for all locations.
   */
  listInstances(
    request: DeepPartial<ListInstancesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListInstancesResponse>;
  /** Gets the details of a specific instance. */
  getInstance(request: DeepPartial<GetInstanceRequest>, options?: CallOptions & CallOptionsExt): Promise<Instance>;
  /**
   * Creates an instance.
   * When creating from a backup, the capacity of the new instance needs to be
   * equal to or larger than the capacity of the backup (and also equal to or
   * larger than the minimum capacity of the tier).
   */
  createInstance(
    request: DeepPartial<CreateInstanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates the settings of a specific instance. */
  updateInstance(
    request: DeepPartial<UpdateInstanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Restores an existing instance's file share from a backup.
   *
   * The capacity of the instance needs to be equal to or larger than the
   * capacity of the backup (and also equal to or larger than the minimum
   * capacity of the tier).
   */
  restoreInstance(
    request: DeepPartial<RestoreInstanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Revert an existing instance's file system to a specified snapshot. */
  revertInstance(
    request: DeepPartial<RevertInstanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes an instance. */
  deleteInstance(
    request: DeepPartial<DeleteInstanceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Lists all snapshots in a project for either a specified location
   * or for all locations.
   */
  listSnapshots(
    request: DeepPartial<ListSnapshotsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSnapshotsResponse>;
  /** Gets the details of a specific snapshot. */
  getSnapshot(request: DeepPartial<GetSnapshotRequest>, options?: CallOptions & CallOptionsExt): Promise<Snapshot>;
  /** Creates a snapshot. */
  createSnapshot(
    request: DeepPartial<CreateSnapshotRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a snapshot. */
  deleteSnapshot(
    request: DeepPartial<DeleteSnapshotRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates the settings of a specific snapshot. */
  updateSnapshot(
    request: DeepPartial<UpdateSnapshotRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Lists all backups in a project for either a specified location or for all
   * locations.
   */
  listBackups(
    request: DeepPartial<ListBackupsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListBackupsResponse>;
  /** Gets the details of a specific backup. */
  getBackup(request: DeepPartial<GetBackupRequest>, options?: CallOptions & CallOptionsExt): Promise<Backup>;
  /** Creates a backup. */
  createBackup(request: DeepPartial<CreateBackupRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Deletes a backup. */
  deleteBackup(request: DeepPartial<DeleteBackupRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
  /** Updates the settings of a specific backup. */
  updateBackup(request: DeepPartial<UpdateBackupRequest>, options?: CallOptions & CallOptionsExt): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
