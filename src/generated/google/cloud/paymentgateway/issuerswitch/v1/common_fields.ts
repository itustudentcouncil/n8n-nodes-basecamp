// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/paymentgateway/issuerswitch/v1/common_fields.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { LatLng } from "../../../../type/latlng.js";
import { Money } from "../../../../type/money.js";

export const protobufPackage = "google.cloud.paymentgateway.issuerswitch.v1";

/**
 * The API type for a transaction. Every transaction processed by the issuer
 * switch will be one of these API types.
 */
export enum ApiType {
  /** API_TYPE_UNSPECIFIED - Unspecified API type. */
  API_TYPE_UNSPECIFIED = 0,
  /**
   * BALANCE - Balance API. Maps to UPI's `BalEnq` API. This is a metadata
   * transaction API.
   */
  BALANCE = 1,
  /**
   * CHECK_STATUS - Check transaction status API. Maps to UPI's `ChkTxn` API. This is a
   * metadata transaction API.
   */
  CHECK_STATUS = 2,
  /**
   * COMPLAINT - Complaint API. Maps to UPI's `Complaint` API. This is a dispute and issue
   * resolution API.
   */
  COMPLAINT = 3,
  /**
   * HEART_BEAT - Heart beat API. Maps to UPI's `Hbt` API. This is a metadata transaction
   * API.
   */
  HEART_BEAT = 4,
  /**
   * INITIATE_REGISTRATION - Initiate registration API. Maps to UPI's `Otp` API. This is a metadata
   * transaction API.
   */
  INITIATE_REGISTRATION = 5,
  /**
   * LIST_ACCOUNTS - List accounts API. Maps to UPI's `ListAccount` API. This is a metadata
   * transaction API.
   */
  LIST_ACCOUNTS = 6,
  /**
   * MANDATE - Mandate API. Maps to UPI's `Mandate` API. This is a metadata transaction
   * API.
   */
  MANDATE = 7,
  /**
   * MANDATE_CONFIRMATION - Mandate confirmation API. Maps to UPI's `MandateConfirmation` API. This is
   * a metadata transaction API.
   */
  MANDATE_CONFIRMATION = 8,
  /**
   * SETTLE_PAYMENT - Payment settlement API. Maps to UPI's `Pay` API. This is a financial
   * transaction API.
   */
  SETTLE_PAYMENT = 9,
  /**
   * UPDATE_CREDENTIALS - Update credentials API. Maps to UPI's `SetCre` API. This is a metadata
   * transaction API.
   */
  UPDATE_CREDENTIALS = 10,
  /**
   * VALIDATE_REGISTRATION - Validate registration API. Maps to UPI's `RegMob` API. This is a metadata
   * transaction API.
   */
  VALIDATE_REGISTRATION = 11,
  /**
   * VALIDATE_CUSTOMER - Validate customer API. Maps to UPI's `ValCust` API. This is a validation
   * API.
   */
  VALIDATE_CUSTOMER = 12,
  /** VOUCHER - Voucher API. Maps to UPI's `Voucher` API. */
  VOUCHER = 13,
  /** VOUCHER_CONFIRMATION - Voucher confirmation API. Maps to UPI's `VoucherConfirmation` API. */
  VOUCHER_CONFIRMATION = 14,
  /** ACTIVATION - Activation API. Maps to UPI's `Activation` API. */
  ACTIVATION = 15,
  UNRECOGNIZED = -1,
}

export function apiTypeFromJSON(object: any): ApiType {
  switch (object) {
    case 0:
    case "API_TYPE_UNSPECIFIED":
      return ApiType.API_TYPE_UNSPECIFIED;
    case 1:
    case "BALANCE":
      return ApiType.BALANCE;
    case 2:
    case "CHECK_STATUS":
      return ApiType.CHECK_STATUS;
    case 3:
    case "COMPLAINT":
      return ApiType.COMPLAINT;
    case 4:
    case "HEART_BEAT":
      return ApiType.HEART_BEAT;
    case 5:
    case "INITIATE_REGISTRATION":
      return ApiType.INITIATE_REGISTRATION;
    case 6:
    case "LIST_ACCOUNTS":
      return ApiType.LIST_ACCOUNTS;
    case 7:
    case "MANDATE":
      return ApiType.MANDATE;
    case 8:
    case "MANDATE_CONFIRMATION":
      return ApiType.MANDATE_CONFIRMATION;
    case 9:
    case "SETTLE_PAYMENT":
      return ApiType.SETTLE_PAYMENT;
    case 10:
    case "UPDATE_CREDENTIALS":
      return ApiType.UPDATE_CREDENTIALS;
    case 11:
    case "VALIDATE_REGISTRATION":
      return ApiType.VALIDATE_REGISTRATION;
    case 12:
    case "VALIDATE_CUSTOMER":
      return ApiType.VALIDATE_CUSTOMER;
    case 13:
    case "VOUCHER":
      return ApiType.VOUCHER;
    case 14:
    case "VOUCHER_CONFIRMATION":
      return ApiType.VOUCHER_CONFIRMATION;
    case 15:
    case "ACTIVATION":
      return ApiType.ACTIVATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ApiType.UNRECOGNIZED;
  }
}

export function apiTypeToJSON(object: ApiType): string {
  switch (object) {
    case ApiType.API_TYPE_UNSPECIFIED:
      return "API_TYPE_UNSPECIFIED";
    case ApiType.BALANCE:
      return "BALANCE";
    case ApiType.CHECK_STATUS:
      return "CHECK_STATUS";
    case ApiType.COMPLAINT:
      return "COMPLAINT";
    case ApiType.HEART_BEAT:
      return "HEART_BEAT";
    case ApiType.INITIATE_REGISTRATION:
      return "INITIATE_REGISTRATION";
    case ApiType.LIST_ACCOUNTS:
      return "LIST_ACCOUNTS";
    case ApiType.MANDATE:
      return "MANDATE";
    case ApiType.MANDATE_CONFIRMATION:
      return "MANDATE_CONFIRMATION";
    case ApiType.SETTLE_PAYMENT:
      return "SETTLE_PAYMENT";
    case ApiType.UPDATE_CREDENTIALS:
      return "UPDATE_CREDENTIALS";
    case ApiType.VALIDATE_REGISTRATION:
      return "VALIDATE_REGISTRATION";
    case ApiType.VALIDATE_CUSTOMER:
      return "VALIDATE_CUSTOMER";
    case ApiType.VOUCHER:
      return "VOUCHER";
    case ApiType.VOUCHER_CONFIRMATION:
      return "VOUCHER_CONFIRMATION";
    case ApiType.ACTIVATION:
      return "ACTIVATION";
    case ApiType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The type of a transaction. Every transaction processed by the issuer switch
 * will be one of these transaction types. Transaction types are associated with
 * a particular API type. This associated is documented with each value.
 */
export enum TransactionType {
  /** TRANSACTION_TYPE_UNSPECIFIED - Unspecified transaction type. */
  TRANSACTION_TYPE_UNSPECIFIED = 0,
  /**
   * TRANSACTION_TYPE_AUTOUPDATE - Autoupdate transaction type. This is associated with the `CHECK_STATUS`
   * API type. Maps to UPI's `AUTOUPDATE` type.
   */
  TRANSACTION_TYPE_AUTOUPDATE = 1,
  /**
   * TRANSACTION_TYPE_BALANCE_CHECK - Balance check transaction type. This is associated with the
   * `BALANCE_ENQUIRY` API type. Maps to UPI's `BalChk` type.
   */
  TRANSACTION_TYPE_BALANCE_CHECK = 2,
  /**
   * TRANSACTION_TYPE_BALANCE_ENQUIRY - Balance enquiry transaction type. This is associated with the
   * `BALANCE_ENQUIRY` API type. Maps to UPI's `BalEnq` type.
   */
  TRANSACTION_TYPE_BALANCE_ENQUIRY = 3,
  /**
   * TRANSACTION_TYPE_CHECK_STATUS - Check status transaction type. This is associated with the `COMPLAINT` API
   * type. Maps to UPI's `CHECKSTATUS` type.
   */
  TRANSACTION_TYPE_CHECK_STATUS = 4,
  /**
   * TRANSACTION_TYPE_CHECK_TRANSACTION - Check transaction type. This is associated with the `CHECK_STATUS` API
   * type. Maps to UPI's `ChkTxn` type.
   */
  TRANSACTION_TYPE_CHECK_TRANSACTION = 5,
  /**
   * TRANSACTION_TYPE_COMPLAINT - Complaint transaction type. This is associated with the `COMPLAINT` API
   * type. Maps to UPI's `COMPLAINT` type.
   */
  TRANSACTION_TYPE_COMPLAINT = 6,
  /**
   * TRANSACTION_TYPE_CREATE - Create transaction type. This is associated with the `MANDATE` API type.
   * Maps to UPI's `CREATE` type.
   */
  TRANSACTION_TYPE_CREATE = 7,
  /**
   * TRANSACTION_TYPE_CREDIT - Credit transaction type. This is associated with the `SETTLE_PAYMENT` API
   * type. Maps to UPI's `CREDIT` type.
   */
  TRANSACTION_TYPE_CREDIT = 8,
  /**
   * TRANSACTION_TYPE_DEBIT - Debit transaction type. This is associated with the `SETTLE_PAYMENT` API
   * type. Maps to UPI's `DEBIT` type.
   */
  TRANSACTION_TYPE_DEBIT = 9,
  /**
   * TRANSACTION_TYPE_DISPUTE - Dispute transaction type. This is associated with the `COMPLAINT` API
   * type. Maps to UPI's `DISPUTE` type.
   */
  TRANSACTION_TYPE_DISPUTE = 10,
  /**
   * TRANSACTION_TYPE_HEART_BEAT - Heart beat transaction type. This is associated with `HEART_BEAT` API type.
   * Maps to UPI's `Hbt` type.
   */
  TRANSACTION_TYPE_HEART_BEAT = 11,
  /**
   * TRANSACTION_TYPE_LIST_ACCOUNTS - List accounts transaction type. This is associated with `LIST_ACCOUNTS` API
   * type. Maps to UPI's `ListAccount` type.
   */
  TRANSACTION_TYPE_LIST_ACCOUNTS = 12,
  /**
   * TRANSACTION_TYPE_MANDATE_NOTIFICATION - Mandate notification transaction type. This is associated with the
   * `VALIDATE_CUSTOMER` API type. Maps to UPI's `MandateNotification` type.
   */
  TRANSACTION_TYPE_MANDATE_NOTIFICATION = 13,
  /**
   * TRANSACTION_TYPE_OTP - OTP transaction type. This is associated with the `INITIATE_REGISTRATION`
   * API type. Maps to UPI's `Otp` type.
   */
  TRANSACTION_TYPE_OTP = 14,
  /**
   * TRANSACTION_TYPE_PAUSE - Pause transaction type. This is associated with the `MANDATE` API type.
   * Maps to UPI's `PAUSE` type.
   */
  TRANSACTION_TYPE_PAUSE = 15,
  /**
   * TRANSACTION_TYPE_REDEEM - Redeem transaction type. This is associated with the `VOUCHER_CONFIRMATION`
   * API type. Maps to UPI's `REDEEM` type.
   */
  TRANSACTION_TYPE_REDEEM = 16,
  /**
   * TRANSACTION_TYPE_REFUND - Refund transaction type. This is associated with the `COMPLAINT` API
   * type. Maps to UPI's `REFUND` type.
   */
  TRANSACTION_TYPE_REFUND = 17,
  /**
   * TRANSACTION_TYPE_REGISTER_MOBILE - Register mobile transaction type. This is associated with the
   * `VALIDATE_REGISTRATION` API type. Maps to UPI's `RegMob` type.
   */
  TRANSACTION_TYPE_REGISTER_MOBILE = 18,
  /**
   * TRANSACTION_TYPE_REVERSAL - Reversal transaction type. This is associated with the `SETTLE_PAYMENT` and
   * `COMPLAINT` API types. Maps to UPI's `REVERSAL` type.
   */
  TRANSACTION_TYPE_REVERSAL = 19,
  /**
   * TRANSACTION_TYPE_REVOKE - Revoke transaction type. This is associated with the `MANDATE` API type.
   * Maps to UPI's `REVOKE` type.
   */
  TRANSACTION_TYPE_REVOKE = 20,
  /**
   * TRANSACTION_TYPE_STATUS_UPDATE - Status update transaction type. This is associated with the `COMPLAINT` API
   * type. Maps to UPI's `STATUSUPDATE` type.
   */
  TRANSACTION_TYPE_STATUS_UPDATE = 21,
  /**
   * TRANSACTION_TYPE_UNPAUSE - Update transaction type. This is associated with the `MANDATE` API type.
   * Maps to UPI's `UNPAUSE` type.
   */
  TRANSACTION_TYPE_UNPAUSE = 22,
  /**
   * TRANSACTION_TYPE_UPDATE - Update transaction type. This is associated with the `MANDATE` API type.
   * Maps to UPI's `UPDATE` type.
   */
  TRANSACTION_TYPE_UPDATE = 23,
  /**
   * TRANSACTION_TYPE_UPDATE_CREDENTIALS - Update credentials transaction type. This is associated with
   * `UPDATE_CREDENTIALS` API type. Maps to UPI's `SetCre` type.
   */
  TRANSACTION_TYPE_UPDATE_CREDENTIALS = 24,
  /**
   * TRANSACTION_TYPE_VALIDATE_CUSTOMER - Validate customer transaction type. This is associated with
   * `VALIDATE_CUSTOMER` API type. Maps to UPI's `ValCust` type.
   */
  TRANSACTION_TYPE_VALIDATE_CUSTOMER = 25,
  /**
   * TRANSACTION_TYPE_ACTIVATION_INTERNATIONAL - Activation international transaction type. This is associated with
   * 'ACTIVATION' API type. Maps to UPI's `International` type.
   */
  TRANSACTION_TYPE_ACTIVATION_INTERNATIONAL = 26,
  /**
   * TRANSACTION_TYPE_ACTIVATION_UPI_SERVICES - Activation UPI services transaction type. This is associated with
   * 'ACTIVATION' API type. Maps to UPI's `UPI Services` type.
   */
  TRANSACTION_TYPE_ACTIVATION_UPI_SERVICES = 27,
  UNRECOGNIZED = -1,
}

export function transactionTypeFromJSON(object: any): TransactionType {
  switch (object) {
    case 0:
    case "TRANSACTION_TYPE_UNSPECIFIED":
      return TransactionType.TRANSACTION_TYPE_UNSPECIFIED;
    case 1:
    case "TRANSACTION_TYPE_AUTOUPDATE":
      return TransactionType.TRANSACTION_TYPE_AUTOUPDATE;
    case 2:
    case "TRANSACTION_TYPE_BALANCE_CHECK":
      return TransactionType.TRANSACTION_TYPE_BALANCE_CHECK;
    case 3:
    case "TRANSACTION_TYPE_BALANCE_ENQUIRY":
      return TransactionType.TRANSACTION_TYPE_BALANCE_ENQUIRY;
    case 4:
    case "TRANSACTION_TYPE_CHECK_STATUS":
      return TransactionType.TRANSACTION_TYPE_CHECK_STATUS;
    case 5:
    case "TRANSACTION_TYPE_CHECK_TRANSACTION":
      return TransactionType.TRANSACTION_TYPE_CHECK_TRANSACTION;
    case 6:
    case "TRANSACTION_TYPE_COMPLAINT":
      return TransactionType.TRANSACTION_TYPE_COMPLAINT;
    case 7:
    case "TRANSACTION_TYPE_CREATE":
      return TransactionType.TRANSACTION_TYPE_CREATE;
    case 8:
    case "TRANSACTION_TYPE_CREDIT":
      return TransactionType.TRANSACTION_TYPE_CREDIT;
    case 9:
    case "TRANSACTION_TYPE_DEBIT":
      return TransactionType.TRANSACTION_TYPE_DEBIT;
    case 10:
    case "TRANSACTION_TYPE_DISPUTE":
      return TransactionType.TRANSACTION_TYPE_DISPUTE;
    case 11:
    case "TRANSACTION_TYPE_HEART_BEAT":
      return TransactionType.TRANSACTION_TYPE_HEART_BEAT;
    case 12:
    case "TRANSACTION_TYPE_LIST_ACCOUNTS":
      return TransactionType.TRANSACTION_TYPE_LIST_ACCOUNTS;
    case 13:
    case "TRANSACTION_TYPE_MANDATE_NOTIFICATION":
      return TransactionType.TRANSACTION_TYPE_MANDATE_NOTIFICATION;
    case 14:
    case "TRANSACTION_TYPE_OTP":
      return TransactionType.TRANSACTION_TYPE_OTP;
    case 15:
    case "TRANSACTION_TYPE_PAUSE":
      return TransactionType.TRANSACTION_TYPE_PAUSE;
    case 16:
    case "TRANSACTION_TYPE_REDEEM":
      return TransactionType.TRANSACTION_TYPE_REDEEM;
    case 17:
    case "TRANSACTION_TYPE_REFUND":
      return TransactionType.TRANSACTION_TYPE_REFUND;
    case 18:
    case "TRANSACTION_TYPE_REGISTER_MOBILE":
      return TransactionType.TRANSACTION_TYPE_REGISTER_MOBILE;
    case 19:
    case "TRANSACTION_TYPE_REVERSAL":
      return TransactionType.TRANSACTION_TYPE_REVERSAL;
    case 20:
    case "TRANSACTION_TYPE_REVOKE":
      return TransactionType.TRANSACTION_TYPE_REVOKE;
    case 21:
    case "TRANSACTION_TYPE_STATUS_UPDATE":
      return TransactionType.TRANSACTION_TYPE_STATUS_UPDATE;
    case 22:
    case "TRANSACTION_TYPE_UNPAUSE":
      return TransactionType.TRANSACTION_TYPE_UNPAUSE;
    case 23:
    case "TRANSACTION_TYPE_UPDATE":
      return TransactionType.TRANSACTION_TYPE_UPDATE;
    case 24:
    case "TRANSACTION_TYPE_UPDATE_CREDENTIALS":
      return TransactionType.TRANSACTION_TYPE_UPDATE_CREDENTIALS;
    case 25:
    case "TRANSACTION_TYPE_VALIDATE_CUSTOMER":
      return TransactionType.TRANSACTION_TYPE_VALIDATE_CUSTOMER;
    case 26:
    case "TRANSACTION_TYPE_ACTIVATION_INTERNATIONAL":
      return TransactionType.TRANSACTION_TYPE_ACTIVATION_INTERNATIONAL;
    case 27:
    case "TRANSACTION_TYPE_ACTIVATION_UPI_SERVICES":
      return TransactionType.TRANSACTION_TYPE_ACTIVATION_UPI_SERVICES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransactionType.UNRECOGNIZED;
  }
}

export function transactionTypeToJSON(object: TransactionType): string {
  switch (object) {
    case TransactionType.TRANSACTION_TYPE_UNSPECIFIED:
      return "TRANSACTION_TYPE_UNSPECIFIED";
    case TransactionType.TRANSACTION_TYPE_AUTOUPDATE:
      return "TRANSACTION_TYPE_AUTOUPDATE";
    case TransactionType.TRANSACTION_TYPE_BALANCE_CHECK:
      return "TRANSACTION_TYPE_BALANCE_CHECK";
    case TransactionType.TRANSACTION_TYPE_BALANCE_ENQUIRY:
      return "TRANSACTION_TYPE_BALANCE_ENQUIRY";
    case TransactionType.TRANSACTION_TYPE_CHECK_STATUS:
      return "TRANSACTION_TYPE_CHECK_STATUS";
    case TransactionType.TRANSACTION_TYPE_CHECK_TRANSACTION:
      return "TRANSACTION_TYPE_CHECK_TRANSACTION";
    case TransactionType.TRANSACTION_TYPE_COMPLAINT:
      return "TRANSACTION_TYPE_COMPLAINT";
    case TransactionType.TRANSACTION_TYPE_CREATE:
      return "TRANSACTION_TYPE_CREATE";
    case TransactionType.TRANSACTION_TYPE_CREDIT:
      return "TRANSACTION_TYPE_CREDIT";
    case TransactionType.TRANSACTION_TYPE_DEBIT:
      return "TRANSACTION_TYPE_DEBIT";
    case TransactionType.TRANSACTION_TYPE_DISPUTE:
      return "TRANSACTION_TYPE_DISPUTE";
    case TransactionType.TRANSACTION_TYPE_HEART_BEAT:
      return "TRANSACTION_TYPE_HEART_BEAT";
    case TransactionType.TRANSACTION_TYPE_LIST_ACCOUNTS:
      return "TRANSACTION_TYPE_LIST_ACCOUNTS";
    case TransactionType.TRANSACTION_TYPE_MANDATE_NOTIFICATION:
      return "TRANSACTION_TYPE_MANDATE_NOTIFICATION";
    case TransactionType.TRANSACTION_TYPE_OTP:
      return "TRANSACTION_TYPE_OTP";
    case TransactionType.TRANSACTION_TYPE_PAUSE:
      return "TRANSACTION_TYPE_PAUSE";
    case TransactionType.TRANSACTION_TYPE_REDEEM:
      return "TRANSACTION_TYPE_REDEEM";
    case TransactionType.TRANSACTION_TYPE_REFUND:
      return "TRANSACTION_TYPE_REFUND";
    case TransactionType.TRANSACTION_TYPE_REGISTER_MOBILE:
      return "TRANSACTION_TYPE_REGISTER_MOBILE";
    case TransactionType.TRANSACTION_TYPE_REVERSAL:
      return "TRANSACTION_TYPE_REVERSAL";
    case TransactionType.TRANSACTION_TYPE_REVOKE:
      return "TRANSACTION_TYPE_REVOKE";
    case TransactionType.TRANSACTION_TYPE_STATUS_UPDATE:
      return "TRANSACTION_TYPE_STATUS_UPDATE";
    case TransactionType.TRANSACTION_TYPE_UNPAUSE:
      return "TRANSACTION_TYPE_UNPAUSE";
    case TransactionType.TRANSACTION_TYPE_UPDATE:
      return "TRANSACTION_TYPE_UPDATE";
    case TransactionType.TRANSACTION_TYPE_UPDATE_CREDENTIALS:
      return "TRANSACTION_TYPE_UPDATE_CREDENTIALS";
    case TransactionType.TRANSACTION_TYPE_VALIDATE_CUSTOMER:
      return "TRANSACTION_TYPE_VALIDATE_CUSTOMER";
    case TransactionType.TRANSACTION_TYPE_ACTIVATION_INTERNATIONAL:
      return "TRANSACTION_TYPE_ACTIVATION_INTERNATIONAL";
    case TransactionType.TRANSACTION_TYPE_ACTIVATION_UPI_SERVICES:
      return "TRANSACTION_TYPE_ACTIVATION_UPI_SERVICES";
    case TransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * XmlApiType specifies the API type of the request or response as specified in
 * the XML payload.
 */
export enum XmlApiType {
  /** XML_API_TYPE_UNSPECIFIED - Unspecified API type. */
  XML_API_TYPE_UNSPECIFIED = 0,
  /** REQ_BAL_ENQ - Balance enquiry request API type. Maps to UPI's `ReqBalEnq` API. */
  REQ_BAL_ENQ = 1,
  /** REQ_CHK_TXN - Check transaction request API type. Maps to UPI's `ReqChkTxn` API. */
  REQ_CHK_TXN = 2,
  /** REQ_COMPLAINT - Complaint request API type. Maps to UPI's `ReqComplaint` API. */
  REQ_COMPLAINT = 3,
  /** REQ_HBT - Heart beat request API type. Maps to UPI's `ReqHbt` API. */
  REQ_HBT = 4,
  /** REQ_LIST_ACCOUNT - List accounts request API type. Maps to UPI's `ReqListAccount` API. */
  REQ_LIST_ACCOUNT = 5,
  /** REQ_MANDATE - Mandate request  API. Maps to UPI's `ReqMandate` API. */
  REQ_MANDATE = 6,
  /**
   * REQ_MANDATE_CONFIRMATION - Mandate confirmation request API type. Maps to UPI's
   * `ReqMandateConfirmation` API.
   */
  REQ_MANDATE_CONFIRMATION = 7,
  /** REQ_OTP - OTP request API. Maps to UPI's `ReqOtp` API. */
  REQ_OTP = 8,
  /** REQ_PAY - Payment settlement request API type. Maps to UPI's `ReqPay` API. */
  REQ_PAY = 9,
  /** REQ_REG_MOB - Register mobile request API type. Maps to UPI's `ReqRegMob` API. */
  REQ_REG_MOB = 10,
  /** REQ_SET_CRE - Update credentials request API type. Maps to UPI's `ReqSetCre` API. */
  REQ_SET_CRE = 11,
  /** REQ_VAL_CUST - Validate customer request API type. Maps to UPI's `ReqValCust`. */
  REQ_VAL_CUST = 12,
  /** REQ_VOUCHER - Create voucher request API type. Maps to UPI's `ReqVoucher`. */
  REQ_VOUCHER = 13,
  /**
   * REQ_VOUCHER_CONFIRMATION - Voucher confirmation request API type. Maps to UPI's
   * `ReqVoucherConfirmation` API.
   */
  REQ_VOUCHER_CONFIRMATION = 14,
  /**
   * REQ_TXN_CONFIRMATION - Transaction confirmation request API type. Maps to UPI's
   * `ReqTxnConfirmation` API.
   */
  REQ_TXN_CONFIRMATION = 15,
  /** RESP_BAL_ENQ - Balance enquiry response API type. Maps to UPI's `RespBalEnq` API. */
  RESP_BAL_ENQ = 16,
  /** RESP_CHK_TXN - Check transaction response API type. Maps to UPI's `RespChkTxn` API. */
  RESP_CHK_TXN = 17,
  /** RESP_COMPLAINT - Complaint response API type. Maps to UPI's `RespComplaint` API. */
  RESP_COMPLAINT = 18,
  /** RESP_HBT - Heart beat response API type. Maps to UPI's `RespHbt` API. */
  RESP_HBT = 19,
  /** RESP_LIST_ACCOUNT - List accounts response API type. Maps to UPI's `RespListAccount` API. */
  RESP_LIST_ACCOUNT = 20,
  /** RESP_MANDATE - Mandate response API type. Maps to UPI's `RespMandate` API. */
  RESP_MANDATE = 21,
  /**
   * RESP_MANDATE_CONFIRMATION - Mandate confirmation response API type. Maps to UPI's
   * `RespMandateConfirmation` API.
   */
  RESP_MANDATE_CONFIRMATION = 22,
  /** RESP_OTP - OTP response API. Maps to UPI's `RespOtp` API. */
  RESP_OTP = 23,
  /** RESP_PAY - Payment settlement response API type. Maps to UPI's `RespPay` API. */
  RESP_PAY = 24,
  /** RESP_REG_MOB - Register mobile response API type. Maps to UPI's `RespRegMob` API. */
  RESP_REG_MOB = 25,
  /** RESP_SET_CRE - Update credentials response API type. Maps to UPI's `RespSetCre` API. */
  RESP_SET_CRE = 26,
  /** RESP_VAL_CUST - Validate customer response API type. Maps to UPI's `RespValCust`. */
  RESP_VAL_CUST = 27,
  /** RESP_VOUCHER - Create voucher response API type. Maps to UPI's `RespVoucher`. */
  RESP_VOUCHER = 28,
  /**
   * RESP_VOUCHER_CONFIRMATION - Voucher confirmation responseAPI type. Maps to UPI's
   * `RespVoucherConfirmation` API.
   */
  RESP_VOUCHER_CONFIRMATION = 29,
  /**
   * RESP_TXN_CONFIRMATION - Transaction confirmation response API type. Maps to UPI's
   * `RespTxnConfirmation` API.
   */
  RESP_TXN_CONFIRMATION = 30,
  /** REQ_ACTIVATION - Activation request API type. Maps to UPI's `ReqActivation` API. */
  REQ_ACTIVATION = 31,
  /** RESP_ACTIVATION - Activation response API type. Maps to UPI's `RespActivation` API. */
  RESP_ACTIVATION = 32,
  UNRECOGNIZED = -1,
}

export function xmlApiTypeFromJSON(object: any): XmlApiType {
  switch (object) {
    case 0:
    case "XML_API_TYPE_UNSPECIFIED":
      return XmlApiType.XML_API_TYPE_UNSPECIFIED;
    case 1:
    case "REQ_BAL_ENQ":
      return XmlApiType.REQ_BAL_ENQ;
    case 2:
    case "REQ_CHK_TXN":
      return XmlApiType.REQ_CHK_TXN;
    case 3:
    case "REQ_COMPLAINT":
      return XmlApiType.REQ_COMPLAINT;
    case 4:
    case "REQ_HBT":
      return XmlApiType.REQ_HBT;
    case 5:
    case "REQ_LIST_ACCOUNT":
      return XmlApiType.REQ_LIST_ACCOUNT;
    case 6:
    case "REQ_MANDATE":
      return XmlApiType.REQ_MANDATE;
    case 7:
    case "REQ_MANDATE_CONFIRMATION":
      return XmlApiType.REQ_MANDATE_CONFIRMATION;
    case 8:
    case "REQ_OTP":
      return XmlApiType.REQ_OTP;
    case 9:
    case "REQ_PAY":
      return XmlApiType.REQ_PAY;
    case 10:
    case "REQ_REG_MOB":
      return XmlApiType.REQ_REG_MOB;
    case 11:
    case "REQ_SET_CRE":
      return XmlApiType.REQ_SET_CRE;
    case 12:
    case "REQ_VAL_CUST":
      return XmlApiType.REQ_VAL_CUST;
    case 13:
    case "REQ_VOUCHER":
      return XmlApiType.REQ_VOUCHER;
    case 14:
    case "REQ_VOUCHER_CONFIRMATION":
      return XmlApiType.REQ_VOUCHER_CONFIRMATION;
    case 15:
    case "REQ_TXN_CONFIRMATION":
      return XmlApiType.REQ_TXN_CONFIRMATION;
    case 16:
    case "RESP_BAL_ENQ":
      return XmlApiType.RESP_BAL_ENQ;
    case 17:
    case "RESP_CHK_TXN":
      return XmlApiType.RESP_CHK_TXN;
    case 18:
    case "RESP_COMPLAINT":
      return XmlApiType.RESP_COMPLAINT;
    case 19:
    case "RESP_HBT":
      return XmlApiType.RESP_HBT;
    case 20:
    case "RESP_LIST_ACCOUNT":
      return XmlApiType.RESP_LIST_ACCOUNT;
    case 21:
    case "RESP_MANDATE":
      return XmlApiType.RESP_MANDATE;
    case 22:
    case "RESP_MANDATE_CONFIRMATION":
      return XmlApiType.RESP_MANDATE_CONFIRMATION;
    case 23:
    case "RESP_OTP":
      return XmlApiType.RESP_OTP;
    case 24:
    case "RESP_PAY":
      return XmlApiType.RESP_PAY;
    case 25:
    case "RESP_REG_MOB":
      return XmlApiType.RESP_REG_MOB;
    case 26:
    case "RESP_SET_CRE":
      return XmlApiType.RESP_SET_CRE;
    case 27:
    case "RESP_VAL_CUST":
      return XmlApiType.RESP_VAL_CUST;
    case 28:
    case "RESP_VOUCHER":
      return XmlApiType.RESP_VOUCHER;
    case 29:
    case "RESP_VOUCHER_CONFIRMATION":
      return XmlApiType.RESP_VOUCHER_CONFIRMATION;
    case 30:
    case "RESP_TXN_CONFIRMATION":
      return XmlApiType.RESP_TXN_CONFIRMATION;
    case 31:
    case "REQ_ACTIVATION":
      return XmlApiType.REQ_ACTIVATION;
    case 32:
    case "RESP_ACTIVATION":
      return XmlApiType.RESP_ACTIVATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return XmlApiType.UNRECOGNIZED;
  }
}

export function xmlApiTypeToJSON(object: XmlApiType): string {
  switch (object) {
    case XmlApiType.XML_API_TYPE_UNSPECIFIED:
      return "XML_API_TYPE_UNSPECIFIED";
    case XmlApiType.REQ_BAL_ENQ:
      return "REQ_BAL_ENQ";
    case XmlApiType.REQ_CHK_TXN:
      return "REQ_CHK_TXN";
    case XmlApiType.REQ_COMPLAINT:
      return "REQ_COMPLAINT";
    case XmlApiType.REQ_HBT:
      return "REQ_HBT";
    case XmlApiType.REQ_LIST_ACCOUNT:
      return "REQ_LIST_ACCOUNT";
    case XmlApiType.REQ_MANDATE:
      return "REQ_MANDATE";
    case XmlApiType.REQ_MANDATE_CONFIRMATION:
      return "REQ_MANDATE_CONFIRMATION";
    case XmlApiType.REQ_OTP:
      return "REQ_OTP";
    case XmlApiType.REQ_PAY:
      return "REQ_PAY";
    case XmlApiType.REQ_REG_MOB:
      return "REQ_REG_MOB";
    case XmlApiType.REQ_SET_CRE:
      return "REQ_SET_CRE";
    case XmlApiType.REQ_VAL_CUST:
      return "REQ_VAL_CUST";
    case XmlApiType.REQ_VOUCHER:
      return "REQ_VOUCHER";
    case XmlApiType.REQ_VOUCHER_CONFIRMATION:
      return "REQ_VOUCHER_CONFIRMATION";
    case XmlApiType.REQ_TXN_CONFIRMATION:
      return "REQ_TXN_CONFIRMATION";
    case XmlApiType.RESP_BAL_ENQ:
      return "RESP_BAL_ENQ";
    case XmlApiType.RESP_CHK_TXN:
      return "RESP_CHK_TXN";
    case XmlApiType.RESP_COMPLAINT:
      return "RESP_COMPLAINT";
    case XmlApiType.RESP_HBT:
      return "RESP_HBT";
    case XmlApiType.RESP_LIST_ACCOUNT:
      return "RESP_LIST_ACCOUNT";
    case XmlApiType.RESP_MANDATE:
      return "RESP_MANDATE";
    case XmlApiType.RESP_MANDATE_CONFIRMATION:
      return "RESP_MANDATE_CONFIRMATION";
    case XmlApiType.RESP_OTP:
      return "RESP_OTP";
    case XmlApiType.RESP_PAY:
      return "RESP_PAY";
    case XmlApiType.RESP_REG_MOB:
      return "RESP_REG_MOB";
    case XmlApiType.RESP_SET_CRE:
      return "RESP_SET_CRE";
    case XmlApiType.RESP_VAL_CUST:
      return "RESP_VAL_CUST";
    case XmlApiType.RESP_VOUCHER:
      return "RESP_VOUCHER";
    case XmlApiType.RESP_VOUCHER_CONFIRMATION:
      return "RESP_VOUCHER_CONFIRMATION";
    case XmlApiType.RESP_TXN_CONFIRMATION:
      return "RESP_TXN_CONFIRMATION";
    case XmlApiType.REQ_ACTIVATION:
      return "REQ_ACTIVATION";
    case XmlApiType.RESP_ACTIVATION:
      return "RESP_ACTIVATION";
    case XmlApiType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A reference to uniquely identify an account according to India's UPI
 * standards.
 */
export interface AccountReference {
  /** IFSC of the account's bank branch. */
  ifsc: string;
  /** Output only. Type of account. Examples include SAVINGS, CURRENT, etc. */
  accountType: string;
  /** Unique number for an account in a bank and branch. */
  accountNumber: string;
}

/**
 * A participant in a payment settlement transaction processed by the issuer
 * switch. The participant could either be the payer or the payee in the
 * transaction.
 */
export interface SettlementParticipant {
  /** The participant information. */
  participant:
    | Participant
    | undefined;
  /**
   * Information about a merchant who is a participant in the payment. This
   * field will be specified only if the participant is a merchant.
   */
  merchantInfo:
    | MerchantInfo
    | undefined;
  /**
   * Output only. The mobile number of the participant.
   *
   * @deprecated
   */
  mobile: string;
  /**
   * Output only. Additional details about the payment settlement. Values will
   * be populated depending on whether the settlement transaction succeeded or
   * failed.
   */
  details: SettlementParticipant_SettlementDetails | undefined;
}

/** Details about a payment settlement. */
export interface SettlementParticipant_SettlementDetails {
  /**
   * Output only. The id for the settlement in the bank's backend system. In
   * UPI, this maps to the approval reference number. This value will be
   * present only if this API transaction's state is SUCCEEDED.
   */
  backendSettlementId: string;
  /**
   * Output only. A code indicating additional details about the settlement.
   * In UPI, this maps to the response code.
   */
  code: string;
  /**
   * Output only. A code indicating additional details about the reversal of a
   * settlement. In UPI, this maps to the reversal response code.
   */
  reversalCode: string;
  /**
   * Output only. The amount settled as part of this API transaction. If the
   * settlement had failed, then this value will be 0.00.
   */
  settledAmount: Money | undefined;
}

/** A participant's device tags */
export interface DeviceDetails {
  /** The payment application on the device. */
  paymentApp: string;
  /** The capability of the device. */
  capability: string;
  /** The geo-code of the device. */
  geoCode:
    | LatLng
    | undefined;
  /** The device's ID. */
  id: string;
  /** The device's IP address. */
  ipAddress: string;
  /** The coarse location of the device. */
  location: string;
  /** The operating system on the device. */
  operatingSystem: string;
  /** The device's telecom provider. */
  telecomProvider: string;
  /** The type of device. */
  type: string;
}

/** A participant in a transaction processed by the issuer switch. */
export interface Participant {
  /**
   * The payment address of the participant. In the UPI system, this will be the
   * virtual payment address (VPA) of the participant.
   */
  paymentAddress: string;
  /** The persona of the participant. */
  persona: Participant_Persona;
  /** The name of the participant. */
  user: string;
  /**
   * Output only. Unique identification of an account according to India's UPI
   * standards.
   */
  account:
    | AccountReference
    | undefined;
  /** Output only. The device info of the participant. */
  deviceDetails:
    | DeviceDetails
    | undefined;
  /** Output only. The mobile number of the participant. */
  mobileNumber: string;
}

/** The type of the participant. */
export enum Participant_Persona {
  /** PERSONA_UNSPECIFIED - Unspecified persona. */
  PERSONA_UNSPECIFIED = 0,
  /** ENTITY - Participant is an entity. */
  ENTITY = 1,
  /** PERSON - Participant is a person. */
  PERSON = 2,
  UNRECOGNIZED = -1,
}

export function participant_PersonaFromJSON(object: any): Participant_Persona {
  switch (object) {
    case 0:
    case "PERSONA_UNSPECIFIED":
      return Participant_Persona.PERSONA_UNSPECIFIED;
    case 1:
    case "ENTITY":
      return Participant_Persona.ENTITY;
    case 2:
    case "PERSON":
      return Participant_Persona.PERSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Participant_Persona.UNRECOGNIZED;
  }
}

export function participant_PersonaToJSON(object: Participant_Persona): string {
  switch (object) {
    case Participant_Persona.PERSONA_UNSPECIFIED:
      return "PERSONA_UNSPECIFIED";
    case Participant_Persona.ENTITY:
      return "ENTITY";
    case Participant_Persona.PERSON:
      return "PERSON";
    case Participant_Persona.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A merchant entity participating in a payment settlement transaction. */
export interface MerchantInfo {
  /** A unique identifier for the merchant. */
  id: string;
  /**
   * The name of the merchant who is a party in the payment. Includes multiple
   * possible names for the merchant.
   */
  merchant:
    | MerchantName
    | undefined;
  /** Additional information about the merchant. */
  additionalInfo: MerchantAdditionalInfo | undefined;
}

/**
 * The name of a merchant who is a participant in a payment settlement
 * transaction. Includes multiple possible names for the merchant.
 */
export interface MerchantName {
  /** The brand name of the merchant. */
  brand: string;
  /** The merchant's legal name. */
  legal: string;
  /** The franchise name under which the merchant operates. */
  franchise: string;
}

/** Additional merchant information specific to India's UPI requirements. */
export interface MerchantAdditionalInfo {
  /**
   * Merchant Category Code (MCC) as specified by UPI. This is a four-digit
   * number listed in ISO 18245 for retail financial services.
   */
  categoryCode: string;
  /**
   * A unique identifier for the merchant store where the payment settlement
   * transaction occurred.
   */
  storeId: string;
  /**
   * A unique identifier for the POS terminal in the store where the payment
   * settlement transaction occurred.
   */
  terminalId: string;
  /** Indicates the type of merchant. */
  type: MerchantAdditionalInfo_Type;
  /** Indicates the genre of the merchant. */
  genre: MerchantAdditionalInfo_Genre;
  /** Indicates the merchant's onboarding type. */
  onboardingType: MerchantAdditionalInfo_OnboardingType;
  /** Indicates the merchant's owner type. */
  ownershipType: MerchantAdditionalInfo_OwnershipType;
}

/** Indicates the merchant's type as a small or large merchant. */
export enum MerchantAdditionalInfo_Type {
  /** TYPE_UNSPECIFIED - Unspecified merchant type. */
  TYPE_UNSPECIFIED = 0,
  /** LARGE - Large merchant. */
  LARGE = 1,
  /** SMALL - Small merchant. */
  SMALL = 2,
  UNRECOGNIZED = -1,
}

export function merchantAdditionalInfo_TypeFromJSON(object: any): MerchantAdditionalInfo_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return MerchantAdditionalInfo_Type.TYPE_UNSPECIFIED;
    case 1:
    case "LARGE":
      return MerchantAdditionalInfo_Type.LARGE;
    case 2:
    case "SMALL":
      return MerchantAdditionalInfo_Type.SMALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MerchantAdditionalInfo_Type.UNRECOGNIZED;
  }
}

export function merchantAdditionalInfo_TypeToJSON(object: MerchantAdditionalInfo_Type): string {
  switch (object) {
    case MerchantAdditionalInfo_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case MerchantAdditionalInfo_Type.LARGE:
      return "LARGE";
    case MerchantAdditionalInfo_Type.SMALL:
      return "SMALL";
    case MerchantAdditionalInfo_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Indicates whether the merchant is an online or offline merchant. */
export enum MerchantAdditionalInfo_Genre {
  /** GENRE_UNSPECIFIED - Unspecified merchant genre. */
  GENRE_UNSPECIFIED = 0,
  /** OFFLINE - Offline merchant */
  OFFLINE = 1,
  /** ONLINE - Online merchant. */
  ONLINE = 2,
  UNRECOGNIZED = -1,
}

export function merchantAdditionalInfo_GenreFromJSON(object: any): MerchantAdditionalInfo_Genre {
  switch (object) {
    case 0:
    case "GENRE_UNSPECIFIED":
      return MerchantAdditionalInfo_Genre.GENRE_UNSPECIFIED;
    case 1:
    case "OFFLINE":
      return MerchantAdditionalInfo_Genre.OFFLINE;
    case 2:
    case "ONLINE":
      return MerchantAdditionalInfo_Genre.ONLINE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MerchantAdditionalInfo_Genre.UNRECOGNIZED;
  }
}

export function merchantAdditionalInfo_GenreToJSON(object: MerchantAdditionalInfo_Genre): string {
  switch (object) {
    case MerchantAdditionalInfo_Genre.GENRE_UNSPECIFIED:
      return "GENRE_UNSPECIFIED";
    case MerchantAdditionalInfo_Genre.OFFLINE:
      return "OFFLINE";
    case MerchantAdditionalInfo_Genre.ONLINE:
      return "ONLINE";
    case MerchantAdditionalInfo_Genre.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Indicates whether the merchant has been onboarded by a bank or an
 * aggregator.
 */
export enum MerchantAdditionalInfo_OnboardingType {
  /** ONBOARDING_TYPE_UNSPECIFIED - Unspecified merchant onboarding type. */
  ONBOARDING_TYPE_UNSPECIFIED = 0,
  /** AGGREGATOR - Onboarded by aggreagator. */
  AGGREGATOR = 1,
  /** BANK - Onboarded by bank. */
  BANK = 2,
  /** NETWORK - Onboarded by the UPI network. */
  NETWORK = 3,
  /** TPAP - Onboarded by the TPAP. */
  TPAP = 4,
  UNRECOGNIZED = -1,
}

export function merchantAdditionalInfo_OnboardingTypeFromJSON(object: any): MerchantAdditionalInfo_OnboardingType {
  switch (object) {
    case 0:
    case "ONBOARDING_TYPE_UNSPECIFIED":
      return MerchantAdditionalInfo_OnboardingType.ONBOARDING_TYPE_UNSPECIFIED;
    case 1:
    case "AGGREGATOR":
      return MerchantAdditionalInfo_OnboardingType.AGGREGATOR;
    case 2:
    case "BANK":
      return MerchantAdditionalInfo_OnboardingType.BANK;
    case 3:
    case "NETWORK":
      return MerchantAdditionalInfo_OnboardingType.NETWORK;
    case 4:
    case "TPAP":
      return MerchantAdditionalInfo_OnboardingType.TPAP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MerchantAdditionalInfo_OnboardingType.UNRECOGNIZED;
  }
}

export function merchantAdditionalInfo_OnboardingTypeToJSON(object: MerchantAdditionalInfo_OnboardingType): string {
  switch (object) {
    case MerchantAdditionalInfo_OnboardingType.ONBOARDING_TYPE_UNSPECIFIED:
      return "ONBOARDING_TYPE_UNSPECIFIED";
    case MerchantAdditionalInfo_OnboardingType.AGGREGATOR:
      return "AGGREGATOR";
    case MerchantAdditionalInfo_OnboardingType.BANK:
      return "BANK";
    case MerchantAdditionalInfo_OnboardingType.NETWORK:
      return "NETWORK";
    case MerchantAdditionalInfo_OnboardingType.TPAP:
      return "TPAP";
    case MerchantAdditionalInfo_OnboardingType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Indicates the ownership type of the merchant. */
export enum MerchantAdditionalInfo_OwnershipType {
  /** OWNERSHIP_TYPE_UNSPECIFIED - Unspecified merchant ownership type. */
  OWNERSHIP_TYPE_UNSPECIFIED = 0,
  /** PROPRIETARY - Properietary ownership. */
  PROPRIETARY = 1,
  /** PARTNERSHIP - Partnership ownership. */
  PARTNERSHIP = 2,
  /** PUBLIC - Public ownership. */
  PUBLIC = 3,
  /** PRIVATE - Private ownership. */
  PRIVATE = 4,
  /** OTHERS - Other ownership model. */
  OTHERS = 5,
  UNRECOGNIZED = -1,
}

export function merchantAdditionalInfo_OwnershipTypeFromJSON(object: any): MerchantAdditionalInfo_OwnershipType {
  switch (object) {
    case 0:
    case "OWNERSHIP_TYPE_UNSPECIFIED":
      return MerchantAdditionalInfo_OwnershipType.OWNERSHIP_TYPE_UNSPECIFIED;
    case 1:
    case "PROPRIETARY":
      return MerchantAdditionalInfo_OwnershipType.PROPRIETARY;
    case 2:
    case "PARTNERSHIP":
      return MerchantAdditionalInfo_OwnershipType.PARTNERSHIP;
    case 3:
    case "PUBLIC":
      return MerchantAdditionalInfo_OwnershipType.PUBLIC;
    case 4:
    case "PRIVATE":
      return MerchantAdditionalInfo_OwnershipType.PRIVATE;
    case 5:
    case "OTHERS":
      return MerchantAdditionalInfo_OwnershipType.OTHERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MerchantAdditionalInfo_OwnershipType.UNRECOGNIZED;
  }
}

export function merchantAdditionalInfo_OwnershipTypeToJSON(object: MerchantAdditionalInfo_OwnershipType): string {
  switch (object) {
    case MerchantAdditionalInfo_OwnershipType.OWNERSHIP_TYPE_UNSPECIFIED:
      return "OWNERSHIP_TYPE_UNSPECIFIED";
    case MerchantAdditionalInfo_OwnershipType.PROPRIETARY:
      return "PROPRIETARY";
    case MerchantAdditionalInfo_OwnershipType.PARTNERSHIP:
      return "PARTNERSHIP";
    case MerchantAdditionalInfo_OwnershipType.PUBLIC:
      return "PUBLIC";
    case MerchantAdditionalInfo_OwnershipType.PRIVATE:
      return "PRIVATE";
    case MerchantAdditionalInfo_OwnershipType.OTHERS:
      return "OTHERS";
    case MerchantAdditionalInfo_OwnershipType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseAccountReference(): AccountReference {
  return { ifsc: "", accountType: "", accountNumber: "" };
}

export const AccountReference: MessageFns<AccountReference> = {
  encode(message: AccountReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ifsc !== "") {
      writer.uint32(10).string(message.ifsc);
    }
    if (message.accountType !== "") {
      writer.uint32(18).string(message.accountType);
    }
    if (message.accountNumber !== "") {
      writer.uint32(26).string(message.accountNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ifsc = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountNumber = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountReference {
    return {
      ifsc: isSet(object.ifsc) ? globalThis.String(object.ifsc) : "",
      accountType: isSet(object.accountType) ? globalThis.String(object.accountType) : "",
      accountNumber: isSet(object.accountNumber) ? globalThis.String(object.accountNumber) : "",
    };
  },

  toJSON(message: AccountReference): unknown {
    const obj: any = {};
    if (message.ifsc !== "") {
      obj.ifsc = message.ifsc;
    }
    if (message.accountType !== "") {
      obj.accountType = message.accountType;
    }
    if (message.accountNumber !== "") {
      obj.accountNumber = message.accountNumber;
    }
    return obj;
  },

  create(base?: DeepPartial<AccountReference>): AccountReference {
    return AccountReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountReference>): AccountReference {
    const message = createBaseAccountReference();
    message.ifsc = object.ifsc ?? "";
    message.accountType = object.accountType ?? "";
    message.accountNumber = object.accountNumber ?? "";
    return message;
  },
};

function createBaseSettlementParticipant(): SettlementParticipant {
  return { participant: undefined, merchantInfo: undefined, mobile: "", details: undefined };
}

export const SettlementParticipant: MessageFns<SettlementParticipant> = {
  encode(message: SettlementParticipant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participant !== undefined) {
      Participant.encode(message.participant, writer.uint32(10).fork()).join();
    }
    if (message.merchantInfo !== undefined) {
      MerchantInfo.encode(message.merchantInfo, writer.uint32(18).fork()).join();
    }
    if (message.mobile !== "") {
      writer.uint32(26).string(message.mobile);
    }
    if (message.details !== undefined) {
      SettlementParticipant_SettlementDetails.encode(message.details, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SettlementParticipant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettlementParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participant = Participant.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.merchantInfo = MerchantInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mobile = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.details = SettlementParticipant_SettlementDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SettlementParticipant {
    return {
      participant: isSet(object.participant) ? Participant.fromJSON(object.participant) : undefined,
      merchantInfo: isSet(object.merchantInfo) ? MerchantInfo.fromJSON(object.merchantInfo) : undefined,
      mobile: isSet(object.mobile) ? globalThis.String(object.mobile) : "",
      details: isSet(object.details) ? SettlementParticipant_SettlementDetails.fromJSON(object.details) : undefined,
    };
  },

  toJSON(message: SettlementParticipant): unknown {
    const obj: any = {};
    if (message.participant !== undefined) {
      obj.participant = Participant.toJSON(message.participant);
    }
    if (message.merchantInfo !== undefined) {
      obj.merchantInfo = MerchantInfo.toJSON(message.merchantInfo);
    }
    if (message.mobile !== "") {
      obj.mobile = message.mobile;
    }
    if (message.details !== undefined) {
      obj.details = SettlementParticipant_SettlementDetails.toJSON(message.details);
    }
    return obj;
  },

  create(base?: DeepPartial<SettlementParticipant>): SettlementParticipant {
    return SettlementParticipant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SettlementParticipant>): SettlementParticipant {
    const message = createBaseSettlementParticipant();
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? Participant.fromPartial(object.participant)
      : undefined;
    message.merchantInfo = (object.merchantInfo !== undefined && object.merchantInfo !== null)
      ? MerchantInfo.fromPartial(object.merchantInfo)
      : undefined;
    message.mobile = object.mobile ?? "";
    message.details = (object.details !== undefined && object.details !== null)
      ? SettlementParticipant_SettlementDetails.fromPartial(object.details)
      : undefined;
    return message;
  },
};

function createBaseSettlementParticipant_SettlementDetails(): SettlementParticipant_SettlementDetails {
  return { backendSettlementId: "", code: "", reversalCode: "", settledAmount: undefined };
}

export const SettlementParticipant_SettlementDetails: MessageFns<SettlementParticipant_SettlementDetails> = {
  encode(message: SettlementParticipant_SettlementDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backendSettlementId !== "") {
      writer.uint32(10).string(message.backendSettlementId);
    }
    if (message.code !== "") {
      writer.uint32(18).string(message.code);
    }
    if (message.reversalCode !== "") {
      writer.uint32(26).string(message.reversalCode);
    }
    if (message.settledAmount !== undefined) {
      Money.encode(message.settledAmount, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SettlementParticipant_SettlementDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettlementParticipant_SettlementDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backendSettlementId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.code = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reversalCode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.settledAmount = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SettlementParticipant_SettlementDetails {
    return {
      backendSettlementId: isSet(object.backendSettlementId) ? globalThis.String(object.backendSettlementId) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      reversalCode: isSet(object.reversalCode) ? globalThis.String(object.reversalCode) : "",
      settledAmount: isSet(object.settledAmount) ? Money.fromJSON(object.settledAmount) : undefined,
    };
  },

  toJSON(message: SettlementParticipant_SettlementDetails): unknown {
    const obj: any = {};
    if (message.backendSettlementId !== "") {
      obj.backendSettlementId = message.backendSettlementId;
    }
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.reversalCode !== "") {
      obj.reversalCode = message.reversalCode;
    }
    if (message.settledAmount !== undefined) {
      obj.settledAmount = Money.toJSON(message.settledAmount);
    }
    return obj;
  },

  create(base?: DeepPartial<SettlementParticipant_SettlementDetails>): SettlementParticipant_SettlementDetails {
    return SettlementParticipant_SettlementDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SettlementParticipant_SettlementDetails>): SettlementParticipant_SettlementDetails {
    const message = createBaseSettlementParticipant_SettlementDetails();
    message.backendSettlementId = object.backendSettlementId ?? "";
    message.code = object.code ?? "";
    message.reversalCode = object.reversalCode ?? "";
    message.settledAmount = (object.settledAmount !== undefined && object.settledAmount !== null)
      ? Money.fromPartial(object.settledAmount)
      : undefined;
    return message;
  },
};

function createBaseDeviceDetails(): DeviceDetails {
  return {
    paymentApp: "",
    capability: "",
    geoCode: undefined,
    id: "",
    ipAddress: "",
    location: "",
    operatingSystem: "",
    telecomProvider: "",
    type: "",
  };
}

export const DeviceDetails: MessageFns<DeviceDetails> = {
  encode(message: DeviceDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentApp !== "") {
      writer.uint32(10).string(message.paymentApp);
    }
    if (message.capability !== "") {
      writer.uint32(18).string(message.capability);
    }
    if (message.geoCode !== undefined) {
      LatLng.encode(message.geoCode, writer.uint32(26).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    if (message.ipAddress !== "") {
      writer.uint32(42).string(message.ipAddress);
    }
    if (message.location !== "") {
      writer.uint32(50).string(message.location);
    }
    if (message.operatingSystem !== "") {
      writer.uint32(58).string(message.operatingSystem);
    }
    if (message.telecomProvider !== "") {
      writer.uint32(66).string(message.telecomProvider);
    }
    if (message.type !== "") {
      writer.uint32(74).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.paymentApp = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.capability = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.geoCode = LatLng.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.location = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.operatingSystem = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.telecomProvider = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceDetails {
    return {
      paymentApp: isSet(object.paymentApp) ? globalThis.String(object.paymentApp) : "",
      capability: isSet(object.capability) ? globalThis.String(object.capability) : "",
      geoCode: isSet(object.geoCode) ? LatLng.fromJSON(object.geoCode) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      operatingSystem: isSet(object.operatingSystem) ? globalThis.String(object.operatingSystem) : "",
      telecomProvider: isSet(object.telecomProvider) ? globalThis.String(object.telecomProvider) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: DeviceDetails): unknown {
    const obj: any = {};
    if (message.paymentApp !== "") {
      obj.paymentApp = message.paymentApp;
    }
    if (message.capability !== "") {
      obj.capability = message.capability;
    }
    if (message.geoCode !== undefined) {
      obj.geoCode = LatLng.toJSON(message.geoCode);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.operatingSystem !== "") {
      obj.operatingSystem = message.operatingSystem;
    }
    if (message.telecomProvider !== "") {
      obj.telecomProvider = message.telecomProvider;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<DeviceDetails>): DeviceDetails {
    return DeviceDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeviceDetails>): DeviceDetails {
    const message = createBaseDeviceDetails();
    message.paymentApp = object.paymentApp ?? "";
    message.capability = object.capability ?? "";
    message.geoCode = (object.geoCode !== undefined && object.geoCode !== null)
      ? LatLng.fromPartial(object.geoCode)
      : undefined;
    message.id = object.id ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.location = object.location ?? "";
    message.operatingSystem = object.operatingSystem ?? "";
    message.telecomProvider = object.telecomProvider ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseParticipant(): Participant {
  return { paymentAddress: "", persona: 0, user: "", account: undefined, deviceDetails: undefined, mobileNumber: "" };
}

export const Participant: MessageFns<Participant> = {
  encode(message: Participant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentAddress !== "") {
      writer.uint32(10).string(message.paymentAddress);
    }
    if (message.persona !== 0) {
      writer.uint32(16).int32(message.persona);
    }
    if (message.user !== "") {
      writer.uint32(26).string(message.user);
    }
    if (message.account !== undefined) {
      AccountReference.encode(message.account, writer.uint32(34).fork()).join();
    }
    if (message.deviceDetails !== undefined) {
      DeviceDetails.encode(message.deviceDetails, writer.uint32(42).fork()).join();
    }
    if (message.mobileNumber !== "") {
      writer.uint32(50).string(message.mobileNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Participant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.paymentAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.persona = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.user = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.account = AccountReference.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.deviceDetails = DeviceDetails.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.mobileNumber = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Participant {
    return {
      paymentAddress: isSet(object.paymentAddress) ? globalThis.String(object.paymentAddress) : "",
      persona: isSet(object.persona) ? participant_PersonaFromJSON(object.persona) : 0,
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      account: isSet(object.account) ? AccountReference.fromJSON(object.account) : undefined,
      deviceDetails: isSet(object.deviceDetails) ? DeviceDetails.fromJSON(object.deviceDetails) : undefined,
      mobileNumber: isSet(object.mobileNumber) ? globalThis.String(object.mobileNumber) : "",
    };
  },

  toJSON(message: Participant): unknown {
    const obj: any = {};
    if (message.paymentAddress !== "") {
      obj.paymentAddress = message.paymentAddress;
    }
    if (message.persona !== 0) {
      obj.persona = participant_PersonaToJSON(message.persona);
    }
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.account !== undefined) {
      obj.account = AccountReference.toJSON(message.account);
    }
    if (message.deviceDetails !== undefined) {
      obj.deviceDetails = DeviceDetails.toJSON(message.deviceDetails);
    }
    if (message.mobileNumber !== "") {
      obj.mobileNumber = message.mobileNumber;
    }
    return obj;
  },

  create(base?: DeepPartial<Participant>): Participant {
    return Participant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Participant>): Participant {
    const message = createBaseParticipant();
    message.paymentAddress = object.paymentAddress ?? "";
    message.persona = object.persona ?? 0;
    message.user = object.user ?? "";
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountReference.fromPartial(object.account)
      : undefined;
    message.deviceDetails = (object.deviceDetails !== undefined && object.deviceDetails !== null)
      ? DeviceDetails.fromPartial(object.deviceDetails)
      : undefined;
    message.mobileNumber = object.mobileNumber ?? "";
    return message;
  },
};

function createBaseMerchantInfo(): MerchantInfo {
  return { id: "", merchant: undefined, additionalInfo: undefined };
}

export const MerchantInfo: MessageFns<MerchantInfo> = {
  encode(message: MerchantInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.merchant !== undefined) {
      MerchantName.encode(message.merchant, writer.uint32(18).fork()).join();
    }
    if (message.additionalInfo !== undefined) {
      MerchantAdditionalInfo.encode(message.additionalInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MerchantInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMerchantInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.merchant = MerchantName.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.additionalInfo = MerchantAdditionalInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MerchantInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      merchant: isSet(object.merchant) ? MerchantName.fromJSON(object.merchant) : undefined,
      additionalInfo: isSet(object.additionalInfo) ? MerchantAdditionalInfo.fromJSON(object.additionalInfo) : undefined,
    };
  },

  toJSON(message: MerchantInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.merchant !== undefined) {
      obj.merchant = MerchantName.toJSON(message.merchant);
    }
    if (message.additionalInfo !== undefined) {
      obj.additionalInfo = MerchantAdditionalInfo.toJSON(message.additionalInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<MerchantInfo>): MerchantInfo {
    return MerchantInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MerchantInfo>): MerchantInfo {
    const message = createBaseMerchantInfo();
    message.id = object.id ?? "";
    message.merchant = (object.merchant !== undefined && object.merchant !== null)
      ? MerchantName.fromPartial(object.merchant)
      : undefined;
    message.additionalInfo = (object.additionalInfo !== undefined && object.additionalInfo !== null)
      ? MerchantAdditionalInfo.fromPartial(object.additionalInfo)
      : undefined;
    return message;
  },
};

function createBaseMerchantName(): MerchantName {
  return { brand: "", legal: "", franchise: "" };
}

export const MerchantName: MessageFns<MerchantName> = {
  encode(message: MerchantName, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.brand !== "") {
      writer.uint32(10).string(message.brand);
    }
    if (message.legal !== "") {
      writer.uint32(18).string(message.legal);
    }
    if (message.franchise !== "") {
      writer.uint32(26).string(message.franchise);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MerchantName {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMerchantName();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.brand = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.legal = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.franchise = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MerchantName {
    return {
      brand: isSet(object.brand) ? globalThis.String(object.brand) : "",
      legal: isSet(object.legal) ? globalThis.String(object.legal) : "",
      franchise: isSet(object.franchise) ? globalThis.String(object.franchise) : "",
    };
  },

  toJSON(message: MerchantName): unknown {
    const obj: any = {};
    if (message.brand !== "") {
      obj.brand = message.brand;
    }
    if (message.legal !== "") {
      obj.legal = message.legal;
    }
    if (message.franchise !== "") {
      obj.franchise = message.franchise;
    }
    return obj;
  },

  create(base?: DeepPartial<MerchantName>): MerchantName {
    return MerchantName.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MerchantName>): MerchantName {
    const message = createBaseMerchantName();
    message.brand = object.brand ?? "";
    message.legal = object.legal ?? "";
    message.franchise = object.franchise ?? "";
    return message;
  },
};

function createBaseMerchantAdditionalInfo(): MerchantAdditionalInfo {
  return { categoryCode: "", storeId: "", terminalId: "", type: 0, genre: 0, onboardingType: 0, ownershipType: 0 };
}

export const MerchantAdditionalInfo: MessageFns<MerchantAdditionalInfo> = {
  encode(message: MerchantAdditionalInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.categoryCode !== "") {
      writer.uint32(10).string(message.categoryCode);
    }
    if (message.storeId !== "") {
      writer.uint32(18).string(message.storeId);
    }
    if (message.terminalId !== "") {
      writer.uint32(26).string(message.terminalId);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.genre !== 0) {
      writer.uint32(40).int32(message.genre);
    }
    if (message.onboardingType !== 0) {
      writer.uint32(48).int32(message.onboardingType);
    }
    if (message.ownershipType !== 0) {
      writer.uint32(56).int32(message.ownershipType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MerchantAdditionalInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMerchantAdditionalInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.categoryCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.storeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.terminalId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.genre = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.onboardingType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.ownershipType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MerchantAdditionalInfo {
    return {
      categoryCode: isSet(object.categoryCode) ? globalThis.String(object.categoryCode) : "",
      storeId: isSet(object.storeId) ? globalThis.String(object.storeId) : "",
      terminalId: isSet(object.terminalId) ? globalThis.String(object.terminalId) : "",
      type: isSet(object.type) ? merchantAdditionalInfo_TypeFromJSON(object.type) : 0,
      genre: isSet(object.genre) ? merchantAdditionalInfo_GenreFromJSON(object.genre) : 0,
      onboardingType: isSet(object.onboardingType)
        ? merchantAdditionalInfo_OnboardingTypeFromJSON(object.onboardingType)
        : 0,
      ownershipType: isSet(object.ownershipType)
        ? merchantAdditionalInfo_OwnershipTypeFromJSON(object.ownershipType)
        : 0,
    };
  },

  toJSON(message: MerchantAdditionalInfo): unknown {
    const obj: any = {};
    if (message.categoryCode !== "") {
      obj.categoryCode = message.categoryCode;
    }
    if (message.storeId !== "") {
      obj.storeId = message.storeId;
    }
    if (message.terminalId !== "") {
      obj.terminalId = message.terminalId;
    }
    if (message.type !== 0) {
      obj.type = merchantAdditionalInfo_TypeToJSON(message.type);
    }
    if (message.genre !== 0) {
      obj.genre = merchantAdditionalInfo_GenreToJSON(message.genre);
    }
    if (message.onboardingType !== 0) {
      obj.onboardingType = merchantAdditionalInfo_OnboardingTypeToJSON(message.onboardingType);
    }
    if (message.ownershipType !== 0) {
      obj.ownershipType = merchantAdditionalInfo_OwnershipTypeToJSON(message.ownershipType);
    }
    return obj;
  },

  create(base?: DeepPartial<MerchantAdditionalInfo>): MerchantAdditionalInfo {
    return MerchantAdditionalInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MerchantAdditionalInfo>): MerchantAdditionalInfo {
    const message = createBaseMerchantAdditionalInfo();
    message.categoryCode = object.categoryCode ?? "";
    message.storeId = object.storeId ?? "";
    message.terminalId = object.terminalId ?? "";
    message.type = object.type ?? 0;
    message.genre = object.genre ?? 0;
    message.onboardingType = object.onboardingType ?? 0;
    message.ownershipType = object.ownershipType ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
