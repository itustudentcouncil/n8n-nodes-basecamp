// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/paymentgateway/issuerswitch/v1/rules.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../../protobuf/empty.js";
import {
  AccountReference,
  ApiType,
  apiTypeFromJSON,
  apiTypeToJSON,
  TransactionType,
  transactionTypeFromJSON,
  transactionTypeToJSON,
} from "./common_fields.js";

export const protobufPackage = "google.cloud.paymentgateway.issuerswitch.v1";

/**
 * A rule that is executed by the issuer switch while processing an
 * API transaction.
 */
export interface Rule {
  /**
   * The unique identifier for this resource.
   * Format: projects/{project}/rules/{rule}
   */
  name: string;
  /** The description of the rule. */
  ruleDescription: string;
  /**
   * The API Type for which this rule gets executed. A value of
   * `API_TYPE_UNSPECIFIED` indicates that the rule is executed for all API
   * transactions.
   */
  apiType: ApiType;
  /**
   * The transaction type for which this rule gets executed. A value of
   * `TRANSACTION_TYPE_UNSPECIFIED` indicates that the rule is executed for
   * all transaction types.
   */
  transactionType: TransactionType;
}

/**
 * The metadata associated with a rule. This defines data that are used by the
 * rule during execution.
 */
export interface RuleMetadata {
  /**
   * The unique identifier for this resource.
   * Format: projects/{project}/rules/{rule}/metadata/{metadata}
   */
  name: string;
  /** The description of the rule metadata. */
  description: string;
  /** Type of rule metadata. */
  type: RuleMetadata_Type;
}

/** The type of metadata. */
export enum RuleMetadata_Type {
  /** TYPE_UNSPECIFIED - Unspecified type. */
  TYPE_UNSPECIFIED = 0,
  /**
   * LIST - List type. Indicates that the metadata contains a list of values which
   * the rule requires for execution.
   */
  LIST = 1,
  UNRECOGNIZED = -1,
}

export function ruleMetadata_TypeFromJSON(object: any): RuleMetadata_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return RuleMetadata_Type.TYPE_UNSPECIFIED;
    case 1:
    case "LIST":
      return RuleMetadata_Type.LIST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuleMetadata_Type.UNRECOGNIZED;
  }
}

export function ruleMetadata_TypeToJSON(object: RuleMetadata_Type): string {
  switch (object) {
    case RuleMetadata_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case RuleMetadata_Type.LIST:
      return "LIST";
    case RuleMetadata_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represent a single value in a rule's metadata. */
export interface RuleMetadataValue {
  /**
   * Output only. The unique identifier for this resource.
   * Format: projects/{project}/rules/{rule}/metadata/{metadata}/values/{value}
   */
  name: string;
  /** The value for string metadata. */
  id?:
    | string
    | undefined;
  /** The value for account reference metadata. */
  accountReference?: AccountReference | undefined;
}

/** Request body for the `ListRules` method. */
export interface ListRulesRequest {
  /** Required. The parent resource must have the format of `projects/{project}`. */
  parent: string;
  /**
   * The maximum number of rules to return. The service may return fewer
   * than this value. If unspecified or if the specified value is less than 50,
   * at most 50 rules will be returned. The maximum value is 1000; values above
   * 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListRulesRequest` call.
   * Specify this parameter to retrieve the next page of rules.
   */
  pageToken: string;
}

/** Response body for the `ListRules` method. */
export interface ListRulesResponse {
  /** List of rules satisfying the specified filter criteria. */
  rules: Rule[];
  /**
   * Pass this token in a subsequent `ListRulesRequest` call to continue to list
   * results. If all results have been returned, this field is an empty string
   * or not present in the response.
   */
  nextPageToken: string;
  /** Total number of rules matching request criteria across all pages. */
  totalSize: Long;
}

/** Request body for the `ListRuleMetadata` method. */
export interface ListRuleMetadataRequest {
  /**
   * Required. The parent resource. The format is
   * `projects/{project}/rules/{rule}`.
   */
  parent: string;
  /**
   * The maximum number of rule metadata to return. The service may return fewer
   * than this value. If unspecified or if the specified value is less than 50,
   * at most 50 rule metadata will be returned. The maximum value is 1000;
   * values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token, received from a previous `ListRuleMetadataRequest` call.
   * Specify this parameter to retrieve the next page of rule metadata.
   */
  pageToken: string;
}

/** Response body for the `ListRuleMetadata` method. */
export interface ListRuleMetadataResponse {
  /** List of rule metadata associated with the rule. */
  ruleMetadata: RuleMetadata[];
  /**
   * Pass this token in a subsequent `ListRuleMetadataRequest` call to continue
   * to list results. If all results have been returned, this field is an empty
   * string or not present in the response.
   */
  nextPageToken: string;
  /** Total number of rule metadata matching request criteria across all pages. */
  totalSize: Long;
}

/** Request body for the `ListRuleMetadataValues` method. */
export interface ListRuleMetadataValuesRequest {
  /**
   * Required. The parent resource. The format is
   * `projects/{project}/rules/{rule}/metadata/{metadata}`.
   */
  parent: string;
  /**
   * The maximum number of metadata values to return. The service may return
   * fewer than this value. If unspecified or if the specified value is less
   * than 1, at most 50 rule metadata values will be returned. The maximum
   * value is 1000; values above 1000 will be coerced to 1000.
   */
  pageSize: number;
  /**
   * A page token received from a previous `ListRuleMetadataValuesRequest`
   * call. Specify this parameter to retrieve the next page of rule metadata
   * values.
   */
  pageToken: string;
}

/**
 * Response body for ListRuleMetadataValues. Contains a List of values for a
 * given rule metadata resource.
 */
export interface ListRuleMetadataValuesResponse {
  /** List of values for a given rule metadata resource identifier. */
  ruleMetadataValues: RuleMetadataValue[];
  /**
   * Pass this token in a subsequent `ListRuleMetadataValuesRequest` call to
   * continue to list results. If all results have been returned, this field is
   * an empty string or not present in the response.
   */
  nextPageToken: string;
}

/** Request body for the `BatchCreateRuleMetadataValues` method. */
export interface BatchCreateRuleMetadataValuesRequest {
  /**
   * The parent resource shared by all ruleMetadataValue being created. The
   * format is `projects/{project}/rules/{rule}/metadata/{metadata}`. The
   * [CreateRuleMetadataValueRequest.parent][google.cloud.paymentgateway.issuerswitch.v1.CreateRuleMetadataValueRequest.parent]
   * field in the
   * [CreateRuleMetadataValueRequest][google.cloud.paymentgateway.issuerswitch.v1.CreateRuleMetadataValueRequest]
   * messages contained in this request must match this field.
   */
  parent: string;
  /**
   * Required. The request message specifying the resources to create.
   * A maximum of 1000 RuleMetadataValues can be created in a batch.
   */
  requests: CreateRuleMetadataValueRequest[];
}

/** Response body for the `BatchCreateRuleMetadataValues` method. */
export interface BatchCreateRuleMetadataValuesResponse {
  /** List of RuleMetadataValue created. */
  ruleMetadataValue: RuleMetadataValue[];
}

/** Request for creating a single `RuleMetadataValue`. */
export interface CreateRuleMetadataValueRequest {
  /**
   * Required. The parent resource where this RuleMetadataValue will be created.
   * The format is `projects/{project}/rules/{rule}/metadata/{metadata}`.
   */
  parent: string;
  /** Required. The rule metadata value to create or add to a list. */
  ruleMetadataValue: RuleMetadataValue | undefined;
}

/** Request body for the `BatchDeleteRuleMetadataValues` method. */
export interface BatchDeleteRuleMetadataValuesRequest {
  /**
   * The parent resource shared by all RuleMetadataValues being deleted. The
   * format is `projects/{project}/rules/{rule}/metadata/{metadata}`. If this is
   * set, the parent of all of the RuleMetadataValues specified in the
   * list of names must match this field.
   */
  parent: string;
  /**
   * Required. The names of the rule metadata values to delete.
   * A maximum of 1000 RuleMetadataValue can be deleted in a batch.
   * Format: projects/{project}/rules/{rule}/metadata/{metadata}/values/{value}
   */
  names: string[];
}

function createBaseRule(): Rule {
  return { name: "", ruleDescription: "", apiType: 0, transactionType: 0 };
}

export const Rule: MessageFns<Rule> = {
  encode(message: Rule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ruleDescription !== "") {
      writer.uint32(18).string(message.ruleDescription);
    }
    if (message.apiType !== 0) {
      writer.uint32(24).int32(message.apiType);
    }
    if (message.transactionType !== 0) {
      writer.uint32(32).int32(message.transactionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Rule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ruleDescription = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.apiType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ruleDescription: isSet(object.ruleDescription) ? globalThis.String(object.ruleDescription) : "",
      apiType: isSet(object.apiType) ? apiTypeFromJSON(object.apiType) : 0,
      transactionType: isSet(object.transactionType) ? transactionTypeFromJSON(object.transactionType) : 0,
    };
  },

  toJSON(message: Rule): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ruleDescription !== "") {
      obj.ruleDescription = message.ruleDescription;
    }
    if (message.apiType !== 0) {
      obj.apiType = apiTypeToJSON(message.apiType);
    }
    if (message.transactionType !== 0) {
      obj.transactionType = transactionTypeToJSON(message.transactionType);
    }
    return obj;
  },

  create(base?: DeepPartial<Rule>): Rule {
    return Rule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rule>): Rule {
    const message = createBaseRule();
    message.name = object.name ?? "";
    message.ruleDescription = object.ruleDescription ?? "";
    message.apiType = object.apiType ?? 0;
    message.transactionType = object.transactionType ?? 0;
    return message;
  },
};

function createBaseRuleMetadata(): RuleMetadata {
  return { name: "", description: "", type: 0 };
}

export const RuleMetadata: MessageFns<RuleMetadata> = {
  encode(message: RuleMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuleMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleMetadata {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? ruleMetadata_TypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: RuleMetadata): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = ruleMetadata_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleMetadata>): RuleMetadata {
    return RuleMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleMetadata>): RuleMetadata {
    const message = createBaseRuleMetadata();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseRuleMetadataValue(): RuleMetadataValue {
  return { name: "", id: undefined, accountReference: undefined };
}

export const RuleMetadataValue: MessageFns<RuleMetadataValue> = {
  encode(message: RuleMetadataValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== undefined) {
      writer.uint32(18).string(message.id);
    }
    if (message.accountReference !== undefined) {
      AccountReference.encode(message.accountReference, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuleMetadataValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleMetadataValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.accountReference = AccountReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleMetadataValue {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      accountReference: isSet(object.accountReference) ? AccountReference.fromJSON(object.accountReference) : undefined,
    };
  },

  toJSON(message: RuleMetadataValue): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.accountReference !== undefined) {
      obj.accountReference = AccountReference.toJSON(message.accountReference);
    }
    return obj;
  },

  create(base?: DeepPartial<RuleMetadataValue>): RuleMetadataValue {
    return RuleMetadataValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleMetadataValue>): RuleMetadataValue {
    const message = createBaseRuleMetadataValue();
    message.name = object.name ?? "";
    message.id = object.id ?? undefined;
    message.accountReference = (object.accountReference !== undefined && object.accountReference !== null)
      ? AccountReference.fromPartial(object.accountReference)
      : undefined;
    return message;
  },
};

function createBaseListRulesRequest(): ListRulesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListRulesRequest: MessageFns<ListRulesRequest> = {
  encode(message: ListRulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRulesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListRulesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRulesRequest>): ListRulesRequest {
    return ListRulesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRulesRequest>): ListRulesRequest {
    const message = createBaseListRulesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListRulesResponse(): ListRulesResponse {
  return { rules: [], nextPageToken: "", totalSize: Long.ZERO };
}

export const ListRulesResponse: MessageFns<ListRulesResponse> = {
  encode(message: ListRulesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rules) {
      Rule.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (!message.totalSize.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.totalSize.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRulesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rules.push(Rule.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRulesResponse {
    return {
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => Rule.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? Long.fromValue(object.totalSize) : Long.ZERO,
    };
  },

  toJSON(message: ListRulesResponse): unknown {
    const obj: any = {};
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => Rule.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (!message.totalSize.equals(Long.ZERO)) {
      obj.totalSize = (message.totalSize || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListRulesResponse>): ListRulesResponse {
    return ListRulesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRulesResponse>): ListRulesResponse {
    const message = createBaseListRulesResponse();
    message.rules = object.rules?.map((e) => Rule.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = (object.totalSize !== undefined && object.totalSize !== null)
      ? Long.fromValue(object.totalSize)
      : Long.ZERO;
    return message;
  },
};

function createBaseListRuleMetadataRequest(): ListRuleMetadataRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListRuleMetadataRequest: MessageFns<ListRuleMetadataRequest> = {
  encode(message: ListRuleMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuleMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuleMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuleMetadataRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListRuleMetadataRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuleMetadataRequest>): ListRuleMetadataRequest {
    return ListRuleMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuleMetadataRequest>): ListRuleMetadataRequest {
    const message = createBaseListRuleMetadataRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListRuleMetadataResponse(): ListRuleMetadataResponse {
  return { ruleMetadata: [], nextPageToken: "", totalSize: Long.ZERO };
}

export const ListRuleMetadataResponse: MessageFns<ListRuleMetadataResponse> = {
  encode(message: ListRuleMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ruleMetadata) {
      RuleMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (!message.totalSize.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.totalSize.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuleMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuleMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ruleMetadata.push(RuleMetadata.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuleMetadataResponse {
    return {
      ruleMetadata: globalThis.Array.isArray(object?.ruleMetadata)
        ? object.ruleMetadata.map((e: any) => RuleMetadata.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      totalSize: isSet(object.totalSize) ? Long.fromValue(object.totalSize) : Long.ZERO,
    };
  },

  toJSON(message: ListRuleMetadataResponse): unknown {
    const obj: any = {};
    if (message.ruleMetadata?.length) {
      obj.ruleMetadata = message.ruleMetadata.map((e) => RuleMetadata.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (!message.totalSize.equals(Long.ZERO)) {
      obj.totalSize = (message.totalSize || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuleMetadataResponse>): ListRuleMetadataResponse {
    return ListRuleMetadataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuleMetadataResponse>): ListRuleMetadataResponse {
    const message = createBaseListRuleMetadataResponse();
    message.ruleMetadata = object.ruleMetadata?.map((e) => RuleMetadata.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.totalSize = (object.totalSize !== undefined && object.totalSize !== null)
      ? Long.fromValue(object.totalSize)
      : Long.ZERO;
    return message;
  },
};

function createBaseListRuleMetadataValuesRequest(): ListRuleMetadataValuesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListRuleMetadataValuesRequest: MessageFns<ListRuleMetadataValuesRequest> = {
  encode(message: ListRuleMetadataValuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuleMetadataValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuleMetadataValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuleMetadataValuesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListRuleMetadataValuesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuleMetadataValuesRequest>): ListRuleMetadataValuesRequest {
    return ListRuleMetadataValuesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuleMetadataValuesRequest>): ListRuleMetadataValuesRequest {
    const message = createBaseListRuleMetadataValuesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListRuleMetadataValuesResponse(): ListRuleMetadataValuesResponse {
  return { ruleMetadataValues: [], nextPageToken: "" };
}

export const ListRuleMetadataValuesResponse: MessageFns<ListRuleMetadataValuesResponse> = {
  encode(message: ListRuleMetadataValuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ruleMetadataValues) {
      RuleMetadataValue.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRuleMetadataValuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRuleMetadataValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ruleMetadataValues.push(RuleMetadataValue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRuleMetadataValuesResponse {
    return {
      ruleMetadataValues: globalThis.Array.isArray(object?.ruleMetadataValues)
        ? object.ruleMetadataValues.map((e: any) => RuleMetadataValue.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRuleMetadataValuesResponse): unknown {
    const obj: any = {};
    if (message.ruleMetadataValues?.length) {
      obj.ruleMetadataValues = message.ruleMetadataValues.map((e) => RuleMetadataValue.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRuleMetadataValuesResponse>): ListRuleMetadataValuesResponse {
    return ListRuleMetadataValuesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRuleMetadataValuesResponse>): ListRuleMetadataValuesResponse {
    const message = createBaseListRuleMetadataValuesResponse();
    message.ruleMetadataValues = object.ruleMetadataValues?.map((e) => RuleMetadataValue.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseBatchCreateRuleMetadataValuesRequest(): BatchCreateRuleMetadataValuesRequest {
  return { parent: "", requests: [] };
}

export const BatchCreateRuleMetadataValuesRequest: MessageFns<BatchCreateRuleMetadataValuesRequest> = {
  encode(message: BatchCreateRuleMetadataValuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.requests) {
      CreateRuleMetadataValueRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateRuleMetadataValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateRuleMetadataValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(CreateRuleMetadataValueRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateRuleMetadataValuesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => CreateRuleMetadataValueRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateRuleMetadataValuesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => CreateRuleMetadataValueRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateRuleMetadataValuesRequest>): BatchCreateRuleMetadataValuesRequest {
    return BatchCreateRuleMetadataValuesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateRuleMetadataValuesRequest>): BatchCreateRuleMetadataValuesRequest {
    const message = createBaseBatchCreateRuleMetadataValuesRequest();
    message.parent = object.parent ?? "";
    message.requests = object.requests?.map((e) => CreateRuleMetadataValueRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchCreateRuleMetadataValuesResponse(): BatchCreateRuleMetadataValuesResponse {
  return { ruleMetadataValue: [] };
}

export const BatchCreateRuleMetadataValuesResponse: MessageFns<BatchCreateRuleMetadataValuesResponse> = {
  encode(message: BatchCreateRuleMetadataValuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ruleMetadataValue) {
      RuleMetadataValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchCreateRuleMetadataValuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchCreateRuleMetadataValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ruleMetadataValue.push(RuleMetadataValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchCreateRuleMetadataValuesResponse {
    return {
      ruleMetadataValue: globalThis.Array.isArray(object?.ruleMetadataValue)
        ? object.ruleMetadataValue.map((e: any) => RuleMetadataValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchCreateRuleMetadataValuesResponse): unknown {
    const obj: any = {};
    if (message.ruleMetadataValue?.length) {
      obj.ruleMetadataValue = message.ruleMetadataValue.map((e) => RuleMetadataValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchCreateRuleMetadataValuesResponse>): BatchCreateRuleMetadataValuesResponse {
    return BatchCreateRuleMetadataValuesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchCreateRuleMetadataValuesResponse>): BatchCreateRuleMetadataValuesResponse {
    const message = createBaseBatchCreateRuleMetadataValuesResponse();
    message.ruleMetadataValue = object.ruleMetadataValue?.map((e) => RuleMetadataValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateRuleMetadataValueRequest(): CreateRuleMetadataValueRequest {
  return { parent: "", ruleMetadataValue: undefined };
}

export const CreateRuleMetadataValueRequest: MessageFns<CreateRuleMetadataValueRequest> = {
  encode(message: CreateRuleMetadataValueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.ruleMetadataValue !== undefined) {
      RuleMetadataValue.encode(message.ruleMetadataValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRuleMetadataValueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRuleMetadataValueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ruleMetadataValue = RuleMetadataValue.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRuleMetadataValueRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      ruleMetadataValue: isSet(object.ruleMetadataValue)
        ? RuleMetadataValue.fromJSON(object.ruleMetadataValue)
        : undefined,
    };
  },

  toJSON(message: CreateRuleMetadataValueRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.ruleMetadataValue !== undefined) {
      obj.ruleMetadataValue = RuleMetadataValue.toJSON(message.ruleMetadataValue);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRuleMetadataValueRequest>): CreateRuleMetadataValueRequest {
    return CreateRuleMetadataValueRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRuleMetadataValueRequest>): CreateRuleMetadataValueRequest {
    const message = createBaseCreateRuleMetadataValueRequest();
    message.parent = object.parent ?? "";
    message.ruleMetadataValue = (object.ruleMetadataValue !== undefined && object.ruleMetadataValue !== null)
      ? RuleMetadataValue.fromPartial(object.ruleMetadataValue)
      : undefined;
    return message;
  },
};

function createBaseBatchDeleteRuleMetadataValuesRequest(): BatchDeleteRuleMetadataValuesRequest {
  return { parent: "", names: [] };
}

export const BatchDeleteRuleMetadataValuesRequest: MessageFns<BatchDeleteRuleMetadataValuesRequest> = {
  encode(message: BatchDeleteRuleMetadataValuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.names) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchDeleteRuleMetadataValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteRuleMetadataValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.names.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteRuleMetadataValuesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: BatchDeleteRuleMetadataValuesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteRuleMetadataValuesRequest>): BatchDeleteRuleMetadataValuesRequest {
    return BatchDeleteRuleMetadataValuesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteRuleMetadataValuesRequest>): BatchDeleteRuleMetadataValuesRequest {
    const message = createBaseBatchDeleteRuleMetadataValuesRequest();
    message.parent = object.parent ?? "";
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

/** Manages rules used by the issuer switch's rules engine. */
export type IssuerSwitchRulesDefinition = typeof IssuerSwitchRulesDefinition;
export const IssuerSwitchRulesDefinition = {
  name: "IssuerSwitchRules",
  fullName: "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchRules",
  methods: {
    /**
     * List all rules that are applied on transactions by the issuer switch. Rules
     * can be filtered on API type and transaction type.
     */
    listRules: {
      name: "ListRules",
      requestType: ListRulesRequest,
      requestStream: false,
      responseType: ListRulesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              31,
              18,
              29,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              114,
              117,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** List all rule metadata for a given rule identifier. */
    listRuleMetadata: {
      name: "ListRuleMetadata",
      requestType: ListRuleMetadataRequest,
      requestStream: false,
      responseType: ListRuleMetadataResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              42,
              18,
              40,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              117,
              108,
              101,
              115,
              47,
              42,
              125,
              47,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
        },
      },
    },
    /** List all metadata values for a rule metadata identifier. */
    listRuleMetadataValues: {
      name: "ListRuleMetadataValues",
      requestType: ListRuleMetadataValuesRequest,
      requestStream: false,
      responseType: ListRuleMetadataValuesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              51,
              18,
              49,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              117,
              108,
              101,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              47,
              42,
              125,
              47,
              118,
              97,
              108,
              117,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Create (add) multiple values to the list of values under the specified rule
     * metadata resource.
     */
    batchCreateRuleMetadataValues: {
      name: "BatchCreateRuleMetadataValues",
      requestType: BatchCreateRuleMetadataValuesRequest,
      requestStream: false,
      responseType: BatchCreateRuleMetadataValuesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              117,
              108,
              101,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              47,
              42,
              125,
              47,
              118,
              97,
              108,
              117,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              67,
              114,
              101,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Delete (remove) multiple values from the list of values under the specified
     * rules metadata resource.
     */
    batchDeleteRuleMetadataValues: {
      name: "BatchDeleteRuleMetadataValues",
      requestType: BatchDeleteRuleMetadataValuesRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              114,
              117,
              108,
              101,
              115,
              47,
              42,
              47,
              109,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
              47,
              42,
              125,
              47,
              118,
              97,
              108,
              117,
              101,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              68,
              101,
              108,
              101,
              116,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface IssuerSwitchRulesServiceImplementation<CallContextExt = {}> {
  /**
   * List all rules that are applied on transactions by the issuer switch. Rules
   * can be filtered on API type and transaction type.
   */
  listRules(request: ListRulesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListRulesResponse>>;
  /** List all rule metadata for a given rule identifier. */
  listRuleMetadata(
    request: ListRuleMetadataRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRuleMetadataResponse>>;
  /** List all metadata values for a rule metadata identifier. */
  listRuleMetadataValues(
    request: ListRuleMetadataValuesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRuleMetadataValuesResponse>>;
  /**
   * Create (add) multiple values to the list of values under the specified rule
   * metadata resource.
   */
  batchCreateRuleMetadataValues(
    request: BatchCreateRuleMetadataValuesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchCreateRuleMetadataValuesResponse>>;
  /**
   * Delete (remove) multiple values from the list of values under the specified
   * rules metadata resource.
   */
  batchDeleteRuleMetadataValues(
    request: BatchDeleteRuleMetadataValuesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
}

export interface IssuerSwitchRulesClient<CallOptionsExt = {}> {
  /**
   * List all rules that are applied on transactions by the issuer switch. Rules
   * can be filtered on API type and transaction type.
   */
  listRules(request: DeepPartial<ListRulesRequest>, options?: CallOptions & CallOptionsExt): Promise<ListRulesResponse>;
  /** List all rule metadata for a given rule identifier. */
  listRuleMetadata(
    request: DeepPartial<ListRuleMetadataRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRuleMetadataResponse>;
  /** List all metadata values for a rule metadata identifier. */
  listRuleMetadataValues(
    request: DeepPartial<ListRuleMetadataValuesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRuleMetadataValuesResponse>;
  /**
   * Create (add) multiple values to the list of values under the specified rule
   * metadata resource.
   */
  batchCreateRuleMetadataValues(
    request: DeepPartial<BatchCreateRuleMetadataValuesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchCreateRuleMetadataValuesResponse>;
  /**
   * Delete (remove) multiple values from the list of values under the specified
   * rules metadata resource.
   */
  batchDeleteRuleMetadataValues(
    request: DeepPartial<BatchDeleteRuleMetadataValuesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
