// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/paymentgateway/issuerswitch/accountmanager/v1/account_manager_transactions.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../../../longrunning/operations.js";
import { Timestamp } from "../../../../../protobuf/timestamp.js";
import { Money } from "../../../../../type/money.js";
import { AccountReference } from "../../v1/common_fields.js";

export const protobufPackage = "google.cloud.paymentgateway.issuerswitch.accountmanager.v1";

/**
 * The type of a account manager transaction. Every transaction processed by the
 * account manager will be one of these transaction types.
 */
export enum AccountManagerTransactionType {
  /** ACCOUNT_MANAGER_TRANSACTION_TYPE_UNSPECIFIED - Unspecified transaction type. */
  ACCOUNT_MANAGER_TRANSACTION_TYPE_UNSPECIFIED = 0,
  /** CREDIT - Credit transaction type. */
  CREDIT = 1,
  /** CREDIT_REVERSAL - Credit reversal transaction type. */
  CREDIT_REVERSAL = 2,
  /** DEBIT - Debit transaction type. */
  DEBIT = 3,
  /** DEBIT_REVERSAL - Debit reversal transaction type. */
  DEBIT_REVERSAL = 4,
  UNRECOGNIZED = -1,
}

export function accountManagerTransactionTypeFromJSON(object: any): AccountManagerTransactionType {
  switch (object) {
    case 0:
    case "ACCOUNT_MANAGER_TRANSACTION_TYPE_UNSPECIFIED":
      return AccountManagerTransactionType.ACCOUNT_MANAGER_TRANSACTION_TYPE_UNSPECIFIED;
    case 1:
    case "CREDIT":
      return AccountManagerTransactionType.CREDIT;
    case 2:
    case "CREDIT_REVERSAL":
      return AccountManagerTransactionType.CREDIT_REVERSAL;
    case 3:
    case "DEBIT":
      return AccountManagerTransactionType.DEBIT;
    case 4:
    case "DEBIT_REVERSAL":
      return AccountManagerTransactionType.DEBIT_REVERSAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountManagerTransactionType.UNRECOGNIZED;
  }
}

export function accountManagerTransactionTypeToJSON(object: AccountManagerTransactionType): string {
  switch (object) {
    case AccountManagerTransactionType.ACCOUNT_MANAGER_TRANSACTION_TYPE_UNSPECIFIED:
      return "ACCOUNT_MANAGER_TRANSACTION_TYPE_UNSPECIFIED";
    case AccountManagerTransactionType.CREDIT:
      return "CREDIT";
    case AccountManagerTransactionType.CREDIT_REVERSAL:
      return "CREDIT_REVERSAL";
    case AccountManagerTransactionType.DEBIT:
      return "DEBIT";
    case AccountManagerTransactionType.DEBIT_REVERSAL:
      return "DEBIT_REVERSAL";
    case AccountManagerTransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A transaction processed by the account manager. */
export interface AccountManagerTransaction {
  /**
   * The name of the transaction. This uniquely identifies the
   * transaction. Format of name is
   * projects/{project}/accountManagers/{account_manager}/transactions/{transaction}.
   */
  name: string;
  /** The account ID for which the transaction was processed. */
  accountId: string;
  /** Information about the transaction. */
  info:
    | AccountManagerTransactionInfo
    | undefined;
  /** The payer in the transaction. */
  payer:
    | AccountManagerSettlementParticipant
    | undefined;
  /** The payee in the transaction. */
  payee:
    | AccountManagerSettlementParticipant
    | undefined;
  /** Reconciliation information for the transaction. */
  reconciliationInfo:
    | AccountManagerTransactionReconciliationInfo
    | undefined;
  /** The amount for payment settlement in the transaction. */
  amount: Money | undefined;
}

/** Information about a transaction processed by the account manager. */
export interface AccountManagerTransactionInfo {
  /**
   * An identifier that is mandatorily present in every transaction processed
   * via account manager.
   */
  id: string;
  /** The transaction type. */
  transactionType: AccountManagerTransactionType;
  /** Output only. The transaction's state. */
  state: AccountManagerTransactionInfo_State;
  /** Metadata about the transaction. */
  metadata:
    | AccountManagerTransactionInfo_AccountManagerTransactionMetadata
    | undefined;
  /**
   * Output only. Any error details for the current transaction, if the state is
   * `FAILED`.
   */
  errorDetails: AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails | undefined;
}

/** Specifies the current state of the transaction. */
export enum AccountManagerTransactionInfo_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** SUCCEEDED - The transaction has successfully completed. */
  SUCCEEDED = 1,
  /** FAILED - The transaction has failed. */
  FAILED = 2,
  UNRECOGNIZED = -1,
}

export function accountManagerTransactionInfo_StateFromJSON(object: any): AccountManagerTransactionInfo_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return AccountManagerTransactionInfo_State.STATE_UNSPECIFIED;
    case 1:
    case "SUCCEEDED":
      return AccountManagerTransactionInfo_State.SUCCEEDED;
    case 2:
    case "FAILED":
      return AccountManagerTransactionInfo_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountManagerTransactionInfo_State.UNRECOGNIZED;
  }
}

export function accountManagerTransactionInfo_StateToJSON(object: AccountManagerTransactionInfo_State): string {
  switch (object) {
    case AccountManagerTransactionInfo_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case AccountManagerTransactionInfo_State.SUCCEEDED:
      return "SUCCEEDED";
    case AccountManagerTransactionInfo_State.FAILED:
      return "FAILED";
    case AccountManagerTransactionInfo_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Common metadata about a transaction. */
export interface AccountManagerTransactionInfo_AccountManagerTransactionMetadata {
  /** The time at which the transaction took place. */
  transactionTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which the transaction resource was created by
   * the account manager.
   */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which the transaction resource was last updated
   * by the account manager.
   */
  updateTime:
    | Date
    | undefined;
  /** Retrieval reference number (RRN) for the transaction. */
  retrievalReferenceNumber: string;
  /** The initiation mode of this transaction. */
  initiationMode: string;
  /** The purpose code of this transaction. */
  purposeCode: string;
}

/** All details about any error in the processing of a transaction. */
export interface AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails {
  /** Output only. Error code of the failed transaction. */
  errorCode: string;
  /** Output only. Error description for the failed transaction. */
  errorMessage: string;
}

/**
 * A participant in a payment settlement transaction processed by the
 * account manager. The participant could either be the payer or the payee
 * in the transaction.
 */
export interface AccountManagerSettlementParticipant {
  /** The participant information. */
  participant:
    | AccountManagerParticipant
    | undefined;
  /**
   * Information about a merchant who is a participant in the payment. This
   * field will be specified only if the participant is a merchant.
   */
  merchantInfo: AccountManagerMerchantInfo | undefined;
}

/** A participant in a transaction processed by the account manager. */
export interface AccountManagerParticipant {
  /**
   * The payment address of the participant. In the UPI system, this will be the
   * virtual payment address (VPA) of the participant.
   */
  paymentAddress: string;
  /** The persona of the participant. */
  persona: AccountManagerParticipant_Persona;
  /** Unique identification of an account. */
  account: AccountReference | undefined;
}

/** The type of the participant. */
export enum AccountManagerParticipant_Persona {
  /** PERSONA_UNSPECIFIED - Unspecified persona. */
  PERSONA_UNSPECIFIED = 0,
  /** ENTITY - Participant is an entity. */
  ENTITY = 1,
  /** PERSON - Participant is a person. */
  PERSON = 2,
  UNRECOGNIZED = -1,
}

export function accountManagerParticipant_PersonaFromJSON(object: any): AccountManagerParticipant_Persona {
  switch (object) {
    case 0:
    case "PERSONA_UNSPECIFIED":
      return AccountManagerParticipant_Persona.PERSONA_UNSPECIFIED;
    case 1:
    case "ENTITY":
      return AccountManagerParticipant_Persona.ENTITY;
    case 2:
    case "PERSON":
      return AccountManagerParticipant_Persona.PERSON;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountManagerParticipant_Persona.UNRECOGNIZED;
  }
}

export function accountManagerParticipant_PersonaToJSON(object: AccountManagerParticipant_Persona): string {
  switch (object) {
    case AccountManagerParticipant_Persona.PERSONA_UNSPECIFIED:
      return "PERSONA_UNSPECIFIED";
    case AccountManagerParticipant_Persona.ENTITY:
      return "ENTITY";
    case AccountManagerParticipant_Persona.PERSON:
      return "PERSON";
    case AccountManagerParticipant_Persona.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A merchant in a transaction processed by the account manager. */
export interface AccountManagerMerchantInfo {
  /**
   * Merchant Category Code (MCC) as specified by UPI. This is a four-digit
   * number listed in ISO 18245 for retail financial services.
   */
  categoryCode: string;
  /** ID of the merchant. */
  id: string;
}

/** Reconciliation information for a transaction processed by account manager. */
export interface AccountManagerTransactionReconciliationInfo {
  /** Output only. State of reconciliation. */
  state: AccountManagerTransactionReconciliationInfo_ReconciliationState;
  /** Time at which reconciliation was performed for the transaction. */
  reconciliationTime: Date | undefined;
}

/** State of transaction reconciliation. */
export enum AccountManagerTransactionReconciliationInfo_ReconciliationState {
  /** RECONCILIATION_STATE_UNSPECIFIED - Unspecified state. */
  RECONCILIATION_STATE_UNSPECIFIED = 0,
  /** SUCCEEDED - Reconciliation was successful. */
  SUCCEEDED = 1,
  /** FAILED - Reconciliation failed. */
  FAILED = 2,
  UNRECOGNIZED = -1,
}

export function accountManagerTransactionReconciliationInfo_ReconciliationStateFromJSON(
  object: any,
): AccountManagerTransactionReconciliationInfo_ReconciliationState {
  switch (object) {
    case 0:
    case "RECONCILIATION_STATE_UNSPECIFIED":
      return AccountManagerTransactionReconciliationInfo_ReconciliationState.RECONCILIATION_STATE_UNSPECIFIED;
    case 1:
    case "SUCCEEDED":
      return AccountManagerTransactionReconciliationInfo_ReconciliationState.SUCCEEDED;
    case 2:
    case "FAILED":
      return AccountManagerTransactionReconciliationInfo_ReconciliationState.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountManagerTransactionReconciliationInfo_ReconciliationState.UNRECOGNIZED;
  }
}

export function accountManagerTransactionReconciliationInfo_ReconciliationStateToJSON(
  object: AccountManagerTransactionReconciliationInfo_ReconciliationState,
): string {
  switch (object) {
    case AccountManagerTransactionReconciliationInfo_ReconciliationState.RECONCILIATION_STATE_UNSPECIFIED:
      return "RECONCILIATION_STATE_UNSPECIFIED";
    case AccountManagerTransactionReconciliationInfo_ReconciliationState.SUCCEEDED:
      return "SUCCEEDED";
    case AccountManagerTransactionReconciliationInfo_ReconciliationState.FAILED:
      return "FAILED";
    case AccountManagerTransactionReconciliationInfo_ReconciliationState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request for the `ExportAccountManagerTransactions` method. */
export interface ExportAccountManagerTransactionsRequest {
  /**
   * Required. The parent resource for the transactions. The format is
   * `projects/{project}/accountManagers/{account_manager}`.
   */
  parent: string;
  /**
   * Optional. Transaction type of an account manager transaction. The possible
   * values for transaction type are
   *
   * * CREDIT
   * * CREDIT_REVERSAL
   * * DEBIT
   * * DEBIT_REVERSAL
   *
   * If no transaction type is specified, records of all the above transaction
   * types will be exported.
   */
  transactionType: AccountManagerTransactionType;
  /** Optional. The start time for the query. */
  startTime:
    | Date
    | undefined;
  /** Optional. The end time for the query. */
  endTime: Date | undefined;
}

/**
 * Request for the `ListAccountManagerTransactions` method. Callers can request
 * for transactions to be filtered by the given filter criteria and specified
 * pagination parameters.
 */
export interface ListAccountManagerTransactionsRequest {
  /**
   * Required. The parent resource. The format is
   * `projects/{project}/accountManagers/{account_manager}`.
   */
  parent: string;
  /**
   * Optional. The maximum number of transactions to return. The service may
   * return fewer than this value. If unspecified or if the specified value is
   * less than 1, at most 50 transactions will be returned. The maximum value is
   * 1000; values above 1000 will be coerced to 1000. While paginating, you can
   * specify a new page size parameter for each page of transactions to be
   * listed.
   */
  pageSize: number;
  /**
   * Optional. A page token, received from a previous
   * `ListAccountManagerTransactions` call. Specify this parameter to retrieve
   * the next page of transactions.
   *
   * When paginating, you must specify only the `page_token` parameter. The
   * filter that was specified in the initial call to the
   * `ListAccountManagerTransactions` method that returned the page token will
   * be reused for all further calls where the page token parameter is
   * specified.
   */
  pageToken: string;
  /**
   * Optional. An expression that filters the list of transactions.
   *
   * A filter expression consists of a field name, a comparison operator, and
   * a value for filtering. The value must be a string, a number, or a
   * boolean. The comparison operator must be one of: `<`, `>`, or `=`.
   * Filters are not case sensitive.
   *
   * The following fields in the `Transaction` are eligible for filtering:
   *
   *   * `accountID` - The account ID. Allowed comparison operators: `=`. When
   *   account manager is used for managing UPI Lite transactions, accountID
   *   should be the Lite Reference Number (LRN).
   *   * `accountNumber` - Bank account number associated with the
   *   account. Allowed comparison operators: `=`.
   *   * `IFSC` - Bank IFSC code associated with the account.
   *   Allowed comparison operators: `=`.
   *   * `RRN` - The retrieval reference number of the transaction. Allowed
   *   comparison operators: `=`.
   *   * `transactionTime` - The timestamp (in UTC) at which the transaction
   *   took place. The value should be in the format `YYYY-MM-DDTHH:MM:SSZ`.
   *   Allowed comparison operators: `>`, `<`.
   *
   * You can combine multiple expressions by enclosing each expression in
   * parentheses. Expressions are combined with AND logic. No other logical
   * operators are supported.
   *
   * Here are a few examples:
   *
   *   * `rrn = 123456789123` - The RRN is _123456789123_.
   *   * `(accountID = 12345678) AND (transactionTime < "2021-08-15T14:50:00Z")`
   *   - The accountID is 12345678 and the transaction was received
   *   before _2021-08-15 14:50:00 UTC_.
   *   * `transactionTime > "2021-08-15T14:50:00Z" AND transactionTime <
   *   "2021-08-16T14:50:00Z"` - The transaction was received between
   *   _2021-08-15 14:50:00 UTC_ and _2021-08-16 14:50:00 UTC_.
   */
  filter: string;
}

/** Response for the `ListAccountManagerTransactions` method. */
export interface ListAccountManagerTransactionsResponse {
  /** List of account manager transactions satisfying the filtered request. */
  accountManagerTransactions: AccountManagerTransaction[];
  /**
   * Pass this token in the ListAccountManagerTransactionsRequest to continue to
   * list results. If all results have been returned, this field is an empty
   * string or not present in the response.
   */
  nextPageToken: string;
}

/** Reconciliation request for an account manager transaction. */
export interface ReconcileAccountManagerTransactionsRequest {
  /** Required. The transaction that will be reconciled. */
  transaction: AccountManagerTransaction | undefined;
}

/** Request for the `BatchReconcileAccountManagerTransactions` method. */
export interface BatchReconcileAccountManagerTransactionsRequest {
  /**
   * Required. The parent resource. The format is
   * `projects/{project}/accountManagers/{account_manager}`.
   */
  parent: string;
  /**
   * Required. The request message specifying the transaction to reconcile.
   * A maximum of 200 transactions can be reconciled in a batch.
   */
  requests: ReconcileAccountManagerTransactionsRequest[];
}

/** Response for the `BatchReconcileAccountManagerTransactions` method. */
export interface BatchReconcileAccountManagerTransactionsResponse {
  /** List of transactions reconciled. */
  accountManagerTransactions: AccountManagerTransaction[];
}

function createBaseAccountManagerTransaction(): AccountManagerTransaction {
  return {
    name: "",
    accountId: "",
    info: undefined,
    payer: undefined,
    payee: undefined,
    reconciliationInfo: undefined,
    amount: undefined,
  };
}

export const AccountManagerTransaction: MessageFns<AccountManagerTransaction> = {
  encode(message: AccountManagerTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.accountId !== "") {
      writer.uint32(18).string(message.accountId);
    }
    if (message.info !== undefined) {
      AccountManagerTransactionInfo.encode(message.info, writer.uint32(26).fork()).join();
    }
    if (message.payer !== undefined) {
      AccountManagerSettlementParticipant.encode(message.payer, writer.uint32(34).fork()).join();
    }
    if (message.payee !== undefined) {
      AccountManagerSettlementParticipant.encode(message.payee, writer.uint32(42).fork()).join();
    }
    if (message.reconciliationInfo !== undefined) {
      AccountManagerTransactionReconciliationInfo.encode(message.reconciliationInfo, writer.uint32(50).fork()).join();
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountManagerTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountManagerTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.info = AccountManagerTransactionInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.payer = AccountManagerSettlementParticipant.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.payee = AccountManagerSettlementParticipant.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.reconciliationInfo = AccountManagerTransactionReconciliationInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountManagerTransaction {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      accountId: isSet(object.accountId) ? globalThis.String(object.accountId) : "",
      info: isSet(object.info) ? AccountManagerTransactionInfo.fromJSON(object.info) : undefined,
      payer: isSet(object.payer) ? AccountManagerSettlementParticipant.fromJSON(object.payer) : undefined,
      payee: isSet(object.payee) ? AccountManagerSettlementParticipant.fromJSON(object.payee) : undefined,
      reconciliationInfo: isSet(object.reconciliationInfo)
        ? AccountManagerTransactionReconciliationInfo.fromJSON(object.reconciliationInfo)
        : undefined,
      amount: isSet(object.amount) ? Money.fromJSON(object.amount) : undefined,
    };
  },

  toJSON(message: AccountManagerTransaction): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.accountId !== "") {
      obj.accountId = message.accountId;
    }
    if (message.info !== undefined) {
      obj.info = AccountManagerTransactionInfo.toJSON(message.info);
    }
    if (message.payer !== undefined) {
      obj.payer = AccountManagerSettlementParticipant.toJSON(message.payer);
    }
    if (message.payee !== undefined) {
      obj.payee = AccountManagerSettlementParticipant.toJSON(message.payee);
    }
    if (message.reconciliationInfo !== undefined) {
      obj.reconciliationInfo = AccountManagerTransactionReconciliationInfo.toJSON(message.reconciliationInfo);
    }
    if (message.amount !== undefined) {
      obj.amount = Money.toJSON(message.amount);
    }
    return obj;
  },

  create(base?: DeepPartial<AccountManagerTransaction>): AccountManagerTransaction {
    return AccountManagerTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountManagerTransaction>): AccountManagerTransaction {
    const message = createBaseAccountManagerTransaction();
    message.name = object.name ?? "";
    message.accountId = object.accountId ?? "";
    message.info = (object.info !== undefined && object.info !== null)
      ? AccountManagerTransactionInfo.fromPartial(object.info)
      : undefined;
    message.payer = (object.payer !== undefined && object.payer !== null)
      ? AccountManagerSettlementParticipant.fromPartial(object.payer)
      : undefined;
    message.payee = (object.payee !== undefined && object.payee !== null)
      ? AccountManagerSettlementParticipant.fromPartial(object.payee)
      : undefined;
    message.reconciliationInfo = (object.reconciliationInfo !== undefined && object.reconciliationInfo !== null)
      ? AccountManagerTransactionReconciliationInfo.fromPartial(object.reconciliationInfo)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Money.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseAccountManagerTransactionInfo(): AccountManagerTransactionInfo {
  return { id: "", transactionType: 0, state: 0, metadata: undefined, errorDetails: undefined };
}

export const AccountManagerTransactionInfo: MessageFns<AccountManagerTransactionInfo> = {
  encode(message: AccountManagerTransactionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.transactionType !== 0) {
      writer.uint32(24).int32(message.transactionType);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.metadata !== undefined) {
      AccountManagerTransactionInfo_AccountManagerTransactionMetadata.encode(message.metadata, writer.uint32(50).fork())
        .join();
    }
    if (message.errorDetails !== undefined) {
      AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails.encode(
        message.errorDetails,
        writer.uint32(58).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountManagerTransactionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountManagerTransactionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.metadata = AccountManagerTransactionInfo_AccountManagerTransactionMetadata.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.errorDetails = AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountManagerTransactionInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      transactionType: isSet(object.transactionType)
        ? accountManagerTransactionTypeFromJSON(object.transactionType)
        : 0,
      state: isSet(object.state) ? accountManagerTransactionInfo_StateFromJSON(object.state) : 0,
      metadata: isSet(object.metadata)
        ? AccountManagerTransactionInfo_AccountManagerTransactionMetadata.fromJSON(object.metadata)
        : undefined,
      errorDetails: isSet(object.errorDetails)
        ? AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails.fromJSON(object.errorDetails)
        : undefined,
    };
  },

  toJSON(message: AccountManagerTransactionInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.transactionType !== 0) {
      obj.transactionType = accountManagerTransactionTypeToJSON(message.transactionType);
    }
    if (message.state !== 0) {
      obj.state = accountManagerTransactionInfo_StateToJSON(message.state);
    }
    if (message.metadata !== undefined) {
      obj.metadata = AccountManagerTransactionInfo_AccountManagerTransactionMetadata.toJSON(message.metadata);
    }
    if (message.errorDetails !== undefined) {
      obj.errorDetails = AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails.toJSON(
        message.errorDetails,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AccountManagerTransactionInfo>): AccountManagerTransactionInfo {
    return AccountManagerTransactionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountManagerTransactionInfo>): AccountManagerTransactionInfo {
    const message = createBaseAccountManagerTransactionInfo();
    message.id = object.id ?? "";
    message.transactionType = object.transactionType ?? 0;
    message.state = object.state ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? AccountManagerTransactionInfo_AccountManagerTransactionMetadata.fromPartial(object.metadata)
      : undefined;
    message.errorDetails = (object.errorDetails !== undefined && object.errorDetails !== null)
      ? AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails.fromPartial(object.errorDetails)
      : undefined;
    return message;
  },
};

function createBaseAccountManagerTransactionInfo_AccountManagerTransactionMetadata(): AccountManagerTransactionInfo_AccountManagerTransactionMetadata {
  return {
    transactionTime: undefined,
    createTime: undefined,
    updateTime: undefined,
    retrievalReferenceNumber: "",
    initiationMode: "",
    purposeCode: "",
  };
}

export const AccountManagerTransactionInfo_AccountManagerTransactionMetadata: MessageFns<
  AccountManagerTransactionInfo_AccountManagerTransactionMetadata
> = {
  encode(
    message: AccountManagerTransactionInfo_AccountManagerTransactionMetadata,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.transactionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.transactionTime), writer.uint32(10).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.retrievalReferenceNumber !== "") {
      writer.uint32(34).string(message.retrievalReferenceNumber);
    }
    if (message.initiationMode !== "") {
      writer.uint32(42).string(message.initiationMode);
    }
    if (message.purposeCode !== "") {
      writer.uint32(50).string(message.purposeCode);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AccountManagerTransactionInfo_AccountManagerTransactionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountManagerTransactionInfo_AccountManagerTransactionMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transactionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.retrievalReferenceNumber = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.initiationMode = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.purposeCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountManagerTransactionInfo_AccountManagerTransactionMetadata {
    return {
      transactionTime: isSet(object.transactionTime) ? fromJsonTimestamp(object.transactionTime) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      retrievalReferenceNumber: isSet(object.retrievalReferenceNumber)
        ? globalThis.String(object.retrievalReferenceNumber)
        : "",
      initiationMode: isSet(object.initiationMode) ? globalThis.String(object.initiationMode) : "",
      purposeCode: isSet(object.purposeCode) ? globalThis.String(object.purposeCode) : "",
    };
  },

  toJSON(message: AccountManagerTransactionInfo_AccountManagerTransactionMetadata): unknown {
    const obj: any = {};
    if (message.transactionTime !== undefined) {
      obj.transactionTime = message.transactionTime.toISOString();
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.retrievalReferenceNumber !== "") {
      obj.retrievalReferenceNumber = message.retrievalReferenceNumber;
    }
    if (message.initiationMode !== "") {
      obj.initiationMode = message.initiationMode;
    }
    if (message.purposeCode !== "") {
      obj.purposeCode = message.purposeCode;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AccountManagerTransactionInfo_AccountManagerTransactionMetadata>,
  ): AccountManagerTransactionInfo_AccountManagerTransactionMetadata {
    return AccountManagerTransactionInfo_AccountManagerTransactionMetadata.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AccountManagerTransactionInfo_AccountManagerTransactionMetadata>,
  ): AccountManagerTransactionInfo_AccountManagerTransactionMetadata {
    const message = createBaseAccountManagerTransactionInfo_AccountManagerTransactionMetadata();
    message.transactionTime = object.transactionTime ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.retrievalReferenceNumber = object.retrievalReferenceNumber ?? "";
    message.initiationMode = object.initiationMode ?? "";
    message.purposeCode = object.purposeCode ?? "";
    return message;
  },
};

function createBaseAccountManagerTransactionInfo_AccountManagerTransactionErrorDetails(): AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails {
  return { errorCode: "", errorMessage: "" };
}

export const AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails: MessageFns<
  AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails
> = {
  encode(
    message: AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.errorCode !== "") {
      writer.uint32(10).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountManagerTransactionInfo_AccountManagerTransactionErrorDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails {
    return {
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails): unknown {
    const obj: any = {};
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails>,
  ): AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails {
    return AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails>,
  ): AccountManagerTransactionInfo_AccountManagerTransactionErrorDetails {
    const message = createBaseAccountManagerTransactionInfo_AccountManagerTransactionErrorDetails();
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

function createBaseAccountManagerSettlementParticipant(): AccountManagerSettlementParticipant {
  return { participant: undefined, merchantInfo: undefined };
}

export const AccountManagerSettlementParticipant: MessageFns<AccountManagerSettlementParticipant> = {
  encode(message: AccountManagerSettlementParticipant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participant !== undefined) {
      AccountManagerParticipant.encode(message.participant, writer.uint32(10).fork()).join();
    }
    if (message.merchantInfo !== undefined) {
      AccountManagerMerchantInfo.encode(message.merchantInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountManagerSettlementParticipant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountManagerSettlementParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.participant = AccountManagerParticipant.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.merchantInfo = AccountManagerMerchantInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountManagerSettlementParticipant {
    return {
      participant: isSet(object.participant) ? AccountManagerParticipant.fromJSON(object.participant) : undefined,
      merchantInfo: isSet(object.merchantInfo) ? AccountManagerMerchantInfo.fromJSON(object.merchantInfo) : undefined,
    };
  },

  toJSON(message: AccountManagerSettlementParticipant): unknown {
    const obj: any = {};
    if (message.participant !== undefined) {
      obj.participant = AccountManagerParticipant.toJSON(message.participant);
    }
    if (message.merchantInfo !== undefined) {
      obj.merchantInfo = AccountManagerMerchantInfo.toJSON(message.merchantInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<AccountManagerSettlementParticipant>): AccountManagerSettlementParticipant {
    return AccountManagerSettlementParticipant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountManagerSettlementParticipant>): AccountManagerSettlementParticipant {
    const message = createBaseAccountManagerSettlementParticipant();
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? AccountManagerParticipant.fromPartial(object.participant)
      : undefined;
    message.merchantInfo = (object.merchantInfo !== undefined && object.merchantInfo !== null)
      ? AccountManagerMerchantInfo.fromPartial(object.merchantInfo)
      : undefined;
    return message;
  },
};

function createBaseAccountManagerParticipant(): AccountManagerParticipant {
  return { paymentAddress: "", persona: 0, account: undefined };
}

export const AccountManagerParticipant: MessageFns<AccountManagerParticipant> = {
  encode(message: AccountManagerParticipant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paymentAddress !== "") {
      writer.uint32(10).string(message.paymentAddress);
    }
    if (message.persona !== 0) {
      writer.uint32(16).int32(message.persona);
    }
    if (message.account !== undefined) {
      AccountReference.encode(message.account, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountManagerParticipant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountManagerParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.paymentAddress = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.persona = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.account = AccountReference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountManagerParticipant {
    return {
      paymentAddress: isSet(object.paymentAddress) ? globalThis.String(object.paymentAddress) : "",
      persona: isSet(object.persona) ? accountManagerParticipant_PersonaFromJSON(object.persona) : 0,
      account: isSet(object.account) ? AccountReference.fromJSON(object.account) : undefined,
    };
  },

  toJSON(message: AccountManagerParticipant): unknown {
    const obj: any = {};
    if (message.paymentAddress !== "") {
      obj.paymentAddress = message.paymentAddress;
    }
    if (message.persona !== 0) {
      obj.persona = accountManagerParticipant_PersonaToJSON(message.persona);
    }
    if (message.account !== undefined) {
      obj.account = AccountReference.toJSON(message.account);
    }
    return obj;
  },

  create(base?: DeepPartial<AccountManagerParticipant>): AccountManagerParticipant {
    return AccountManagerParticipant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountManagerParticipant>): AccountManagerParticipant {
    const message = createBaseAccountManagerParticipant();
    message.paymentAddress = object.paymentAddress ?? "";
    message.persona = object.persona ?? 0;
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountReference.fromPartial(object.account)
      : undefined;
    return message;
  },
};

function createBaseAccountManagerMerchantInfo(): AccountManagerMerchantInfo {
  return { categoryCode: "", id: "" };
}

export const AccountManagerMerchantInfo: MessageFns<AccountManagerMerchantInfo> = {
  encode(message: AccountManagerMerchantInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.categoryCode !== "") {
      writer.uint32(10).string(message.categoryCode);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountManagerMerchantInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountManagerMerchantInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.categoryCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountManagerMerchantInfo {
    return {
      categoryCode: isSet(object.categoryCode) ? globalThis.String(object.categoryCode) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
    };
  },

  toJSON(message: AccountManagerMerchantInfo): unknown {
    const obj: any = {};
    if (message.categoryCode !== "") {
      obj.categoryCode = message.categoryCode;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create(base?: DeepPartial<AccountManagerMerchantInfo>): AccountManagerMerchantInfo {
    return AccountManagerMerchantInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountManagerMerchantInfo>): AccountManagerMerchantInfo {
    const message = createBaseAccountManagerMerchantInfo();
    message.categoryCode = object.categoryCode ?? "";
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseAccountManagerTransactionReconciliationInfo(): AccountManagerTransactionReconciliationInfo {
  return { state: 0, reconciliationTime: undefined };
}

export const AccountManagerTransactionReconciliationInfo: MessageFns<AccountManagerTransactionReconciliationInfo> = {
  encode(
    message: AccountManagerTransactionReconciliationInfo,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.reconciliationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.reconciliationTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountManagerTransactionReconciliationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountManagerTransactionReconciliationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reconciliationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountManagerTransactionReconciliationInfo {
    return {
      state: isSet(object.state)
        ? accountManagerTransactionReconciliationInfo_ReconciliationStateFromJSON(object.state)
        : 0,
      reconciliationTime: isSet(object.reconciliationTime) ? fromJsonTimestamp(object.reconciliationTime) : undefined,
    };
  },

  toJSON(message: AccountManagerTransactionReconciliationInfo): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = accountManagerTransactionReconciliationInfo_ReconciliationStateToJSON(message.state);
    }
    if (message.reconciliationTime !== undefined) {
      obj.reconciliationTime = message.reconciliationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AccountManagerTransactionReconciliationInfo>): AccountManagerTransactionReconciliationInfo {
    return AccountManagerTransactionReconciliationInfo.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AccountManagerTransactionReconciliationInfo>,
  ): AccountManagerTransactionReconciliationInfo {
    const message = createBaseAccountManagerTransactionReconciliationInfo();
    message.state = object.state ?? 0;
    message.reconciliationTime = object.reconciliationTime ?? undefined;
    return message;
  },
};

function createBaseExportAccountManagerTransactionsRequest(): ExportAccountManagerTransactionsRequest {
  return { parent: "", transactionType: 0, startTime: undefined, endTime: undefined };
}

export const ExportAccountManagerTransactionsRequest: MessageFns<ExportAccountManagerTransactionsRequest> = {
  encode(message: ExportAccountManagerTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.transactionType !== 0) {
      writer.uint32(24).int32(message.transactionType);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportAccountManagerTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportAccountManagerTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportAccountManagerTransactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      transactionType: isSet(object.transactionType)
        ? accountManagerTransactionTypeFromJSON(object.transactionType)
        : 0,
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: ExportAccountManagerTransactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.transactionType !== 0) {
      obj.transactionType = accountManagerTransactionTypeToJSON(message.transactionType);
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExportAccountManagerTransactionsRequest>): ExportAccountManagerTransactionsRequest {
    return ExportAccountManagerTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportAccountManagerTransactionsRequest>): ExportAccountManagerTransactionsRequest {
    const message = createBaseExportAccountManagerTransactionsRequest();
    message.parent = object.parent ?? "";
    message.transactionType = object.transactionType ?? 0;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseListAccountManagerTransactionsRequest(): ListAccountManagerTransactionsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListAccountManagerTransactionsRequest: MessageFns<ListAccountManagerTransactionsRequest> = {
  encode(message: ListAccountManagerTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAccountManagerTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAccountManagerTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAccountManagerTransactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListAccountManagerTransactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAccountManagerTransactionsRequest>): ListAccountManagerTransactionsRequest {
    return ListAccountManagerTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAccountManagerTransactionsRequest>): ListAccountManagerTransactionsRequest {
    const message = createBaseListAccountManagerTransactionsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListAccountManagerTransactionsResponse(): ListAccountManagerTransactionsResponse {
  return { accountManagerTransactions: [], nextPageToken: "" };
}

export const ListAccountManagerTransactionsResponse: MessageFns<ListAccountManagerTransactionsResponse> = {
  encode(message: ListAccountManagerTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accountManagerTransactions) {
      AccountManagerTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAccountManagerTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAccountManagerTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountManagerTransactions.push(AccountManagerTransaction.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAccountManagerTransactionsResponse {
    return {
      accountManagerTransactions: globalThis.Array.isArray(object?.accountManagerTransactions)
        ? object.accountManagerTransactions.map((e: any) => AccountManagerTransaction.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAccountManagerTransactionsResponse): unknown {
    const obj: any = {};
    if (message.accountManagerTransactions?.length) {
      obj.accountManagerTransactions = message.accountManagerTransactions.map((e) =>
        AccountManagerTransaction.toJSON(e)
      );
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAccountManagerTransactionsResponse>): ListAccountManagerTransactionsResponse {
    return ListAccountManagerTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAccountManagerTransactionsResponse>): ListAccountManagerTransactionsResponse {
    const message = createBaseListAccountManagerTransactionsResponse();
    message.accountManagerTransactions =
      object.accountManagerTransactions?.map((e) => AccountManagerTransaction.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseReconcileAccountManagerTransactionsRequest(): ReconcileAccountManagerTransactionsRequest {
  return { transaction: undefined };
}

export const ReconcileAccountManagerTransactionsRequest: MessageFns<ReconcileAccountManagerTransactionsRequest> = {
  encode(message: ReconcileAccountManagerTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transaction !== undefined) {
      AccountManagerTransaction.encode(message.transaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconcileAccountManagerTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconcileAccountManagerTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transaction = AccountManagerTransaction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconcileAccountManagerTransactionsRequest {
    return {
      transaction: isSet(object.transaction) ? AccountManagerTransaction.fromJSON(object.transaction) : undefined,
    };
  },

  toJSON(message: ReconcileAccountManagerTransactionsRequest): unknown {
    const obj: any = {};
    if (message.transaction !== undefined) {
      obj.transaction = AccountManagerTransaction.toJSON(message.transaction);
    }
    return obj;
  },

  create(base?: DeepPartial<ReconcileAccountManagerTransactionsRequest>): ReconcileAccountManagerTransactionsRequest {
    return ReconcileAccountManagerTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ReconcileAccountManagerTransactionsRequest>,
  ): ReconcileAccountManagerTransactionsRequest {
    const message = createBaseReconcileAccountManagerTransactionsRequest();
    message.transaction = (object.transaction !== undefined && object.transaction !== null)
      ? AccountManagerTransaction.fromPartial(object.transaction)
      : undefined;
    return message;
  },
};

function createBaseBatchReconcileAccountManagerTransactionsRequest(): BatchReconcileAccountManagerTransactionsRequest {
  return { parent: "", requests: [] };
}

export const BatchReconcileAccountManagerTransactionsRequest: MessageFns<
  BatchReconcileAccountManagerTransactionsRequest
> = {
  encode(
    message: BatchReconcileAccountManagerTransactionsRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.requests) {
      ReconcileAccountManagerTransactionsRequest.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchReconcileAccountManagerTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchReconcileAccountManagerTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requests.push(ReconcileAccountManagerTransactionsRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchReconcileAccountManagerTransactionsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => ReconcileAccountManagerTransactionsRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchReconcileAccountManagerTransactionsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => ReconcileAccountManagerTransactionsRequest.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<BatchReconcileAccountManagerTransactionsRequest>,
  ): BatchReconcileAccountManagerTransactionsRequest {
    return BatchReconcileAccountManagerTransactionsRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BatchReconcileAccountManagerTransactionsRequest>,
  ): BatchReconcileAccountManagerTransactionsRequest {
    const message = createBaseBatchReconcileAccountManagerTransactionsRequest();
    message.parent = object.parent ?? "";
    message.requests = object.requests?.map((e) => ReconcileAccountManagerTransactionsRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchReconcileAccountManagerTransactionsResponse(): BatchReconcileAccountManagerTransactionsResponse {
  return { accountManagerTransactions: [] };
}

export const BatchReconcileAccountManagerTransactionsResponse: MessageFns<
  BatchReconcileAccountManagerTransactionsResponse
> = {
  encode(
    message: BatchReconcileAccountManagerTransactionsResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.accountManagerTransactions) {
      AccountManagerTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchReconcileAccountManagerTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchReconcileAccountManagerTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accountManagerTransactions.push(AccountManagerTransaction.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchReconcileAccountManagerTransactionsResponse {
    return {
      accountManagerTransactions: globalThis.Array.isArray(object?.accountManagerTransactions)
        ? object.accountManagerTransactions.map((e: any) => AccountManagerTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchReconcileAccountManagerTransactionsResponse): unknown {
    const obj: any = {};
    if (message.accountManagerTransactions?.length) {
      obj.accountManagerTransactions = message.accountManagerTransactions.map((e) =>
        AccountManagerTransaction.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<BatchReconcileAccountManagerTransactionsResponse>,
  ): BatchReconcileAccountManagerTransactionsResponse {
    return BatchReconcileAccountManagerTransactionsResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<BatchReconcileAccountManagerTransactionsResponse>,
  ): BatchReconcileAccountManagerTransactionsResponse {
    const message = createBaseBatchReconcileAccountManagerTransactionsResponse();
    message.accountManagerTransactions =
      object.accountManagerTransactions?.map((e) => AccountManagerTransaction.fromPartial(e)) || [];
    return message;
  },
};

/** Lists and exports transactions processed by the account manager. */
export type AccountManagerTransactionsDefinition = typeof AccountManagerTransactionsDefinition;
export const AccountManagerTransactionsDefinition = {
  name: "AccountManagerTransactions",
  fullName: "google.cloud.paymentgateway.issuerswitch.accountmanager.v1.AccountManagerTransactions",
  methods: {
    /**
     * Export transactions received within the specified time range as a
     * file into a configured target location. The returned `Operation` type has
     * the following method-specific fields:
     *
     * - `metadata`:
     * [ExportAccountManagerTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.accountmanager.v1.ExportAccountManagerTransactionsMetadata]
     * - `response`:
     * [ExportAccountManagerTransactionsResponse][google.cloud.paymentgateway.issuerswitch.accountmanager.v1.ExportAccountManagerTransactionsResponse]
     *
     * The exported file will be in the standard CSV format where each row in the
     * file represents a transaction. The file has the following fields in order:
     *
     * 1. `TransactionID`
     *     * **Min Length** - 35 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - Account manager transaction ID.
     * 1. `TransactionType`
     *     * **Min Length** - 22 characters
     *     * **Max Length** - 25 characters
     *     * **Description** - Type of the transaction. This will be one of
     *     `TRANSACTION_TYPE_CREDIT`, `TRANSACTION_TYPE_CREDIT_REVERSAL`,
     *     `TRANSACTION_TYPE_DEBIT` or `TRANSACTION_TYPE_DEBIT_REVERSAL`. When
     *     account manager is used for managing UPI Lite transactions, the CREDIT
     *     transactions would be for Lite account top-ups and DEBIT transactions
     *     could be either for a Lite account disablement where balance is
     *     transferred back the underlying bank account or for a Lite account
     *     financial transaction which happened offline.
     * 1. `AccountID`
     *     * **Min Length** - 35 characters
     *     * **Max Length** - 35 characters
     *     * **Description** - Account ID. When account manager is used for
     *     managing UPI Lite transactions, this column will contain the Lite
     *     Reference Number (LRN) of the UPI Lite account.
     * 1. `State`
     *     * **Min Length** - 6 characters
     *     * **Max Length** - 12 characters
     *     * **Description** - State of the transaction. This will be one of
     *     `SUCCEEDED` or `FAILED`.
     * 1. `RRN`
     *     * **Min Length** - 12 characters
     *     * **Max Length** - 12 characters
     *     * **Description** - Retrieval reference number associated with the
     *     transaction.
     * 1. `PayerVPA`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Virtual Payment Address (VPA) of the payer.
     * 1. `PayerIFSC`
     *     * **Min Length** - 11 characters
     *     * **Max Length** - 11 characters
     *     * **Description** - IFSC of the payer's bank account.
     * 1. `PayerAccountNumber`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 30 characters
     *     * **Description** - Payer's bank account number.
     * 1. `PayeeVPA`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 255 characters
     *     * **Description** - Virtual Payment Address (VPA) of the payee.
     * 1. `PayeeIFSC`
     *     * **Min Length** - 11 characters
     *     * **Max Length** - 11 characters
     *     * **Description** - IFSC of the payee's bank account.
     * 1. `PayeeAccountNumber`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 30 characters
     *     * **Description** - Payee's bank account number.
     * 1. `PayeeMCC`
     *     * **Min Length** - 4 characters
     *     * **Max Length** - 4 characters
     *     * **Description** - Payee's Merchant Category Code (MCC), only if the
     *     payee is a merchant.
     * 1. `PayeeMerchantID`
     *     * **Min Length** - 4 characters
     *     * **Max Length** - 4 characters
     *     * **Description** - Payee's merchant ID, only if the payee is a
     *     merchant.
     * 1. `Currency`
     *     * **Min Length** - 3 characters
     *     * **Max Length** - 3 characters
     *     * **Description** - Currency of the amount involved in the transaction.
     *     The currency codes are defined in ISO 4217.
     * 1. `Amount`
     *     * **Description** - Amount involved in the transaction.
     * 1. `Purpose`
     *     * **Min Length** - 1 characters
     *     * **Max Length** - 4 characters
     *     * **Description** - Purpose code associated with the transaction. When
     *     account manager is used for managing UPI Lite transactions, this column
     *     will contain one of the values from `41` (Lite account creation with
     *     initial topup), `42` (Lite account topup), `43` (Lite account
     *     disablement with balance transfer) or `44` (Lite account online
     *     transaction).
     * 1. `TransactionTime`
     *     * **Min Length** - 20 characters
     *     * **Max Length** - 20 characters
     *     * **Description** - Timestamp (in UTC) indicating the timestamp at
     *     which the transaction took place. The format will be as per RFC-3339.
     *     Example : 2022-11-22T23:00:05Z
     */
    exportAccountManagerTransactions: {
      name: "ExportAccountManagerTransactions",
      requestType: ExportAccountManagerTransactionsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              84,
              10,
              40,
              69,
              120,
              112,
              111,
              114,
              116,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              77,
              97,
              110,
              97,
              103,
              101,
              114,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              40,
              69,
              120,
              112,
              111,
              114,
              116,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              77,
              97,
              110,
              97,
              103,
              101,
              114,
              84,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              77,
              97,
              110,
              97,
              103,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              116,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /** List account manager transactions that satisfy specified filter criteria. */
    listAccountManagerTransactions: {
      name: "ListAccountManagerTransactions",
      requestType: ListAccountManagerTransactionsRequest,
      requestStream: false,
      responseType: ListAccountManagerTransactionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              56,
              18,
              54,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              77,
              97,
              110,
              97,
              103,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              116,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Batch reconcile account manager transactions and return status for each
     * transaction.
     */
    batchReconcileAccountManagerTransactions: {
      name: "BatchReconcileAccountManagerTransactions",
      requestType: BatchReconcileAccountManagerTransactionsRequest,
      requestStream: false,
      responseType: BatchReconcileAccountManagerTransactionsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 112, 97, 114, 101, 110, 116, 44, 114, 101, 113, 117, 101, 115, 116, 115])],
          578365826: [
            Buffer.from([
              74,
              58,
              1,
              42,
              34,
              69,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              111,
              117,
              110,
              116,
              77,
              97,
              110,
              97,
              103,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              116,
              114,
              97,
              110,
              115,
              97,
              99,
              116,
              105,
              111,
              110,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              82,
              101,
              99,
              111,
              110,
              99,
              105,
              108,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AccountManagerTransactionsServiceImplementation<CallContextExt = {}> {
  /**
   * Export transactions received within the specified time range as a
   * file into a configured target location. The returned `Operation` type has
   * the following method-specific fields:
   *
   * - `metadata`:
   * [ExportAccountManagerTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.accountmanager.v1.ExportAccountManagerTransactionsMetadata]
   * - `response`:
   * [ExportAccountManagerTransactionsResponse][google.cloud.paymentgateway.issuerswitch.accountmanager.v1.ExportAccountManagerTransactionsResponse]
   *
   * The exported file will be in the standard CSV format where each row in the
   * file represents a transaction. The file has the following fields in order:
   *
   * 1. `TransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Account manager transaction ID.
   * 1. `TransactionType`
   *     * **Min Length** - 22 characters
   *     * **Max Length** - 25 characters
   *     * **Description** - Type of the transaction. This will be one of
   *     `TRANSACTION_TYPE_CREDIT`, `TRANSACTION_TYPE_CREDIT_REVERSAL`,
   *     `TRANSACTION_TYPE_DEBIT` or `TRANSACTION_TYPE_DEBIT_REVERSAL`. When
   *     account manager is used for managing UPI Lite transactions, the CREDIT
   *     transactions would be for Lite account top-ups and DEBIT transactions
   *     could be either for a Lite account disablement where balance is
   *     transferred back the underlying bank account or for a Lite account
   *     financial transaction which happened offline.
   * 1. `AccountID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Account ID. When account manager is used for
   *     managing UPI Lite transactions, this column will contain the Lite
   *     Reference Number (LRN) of the UPI Lite account.
   * 1. `State`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - State of the transaction. This will be one of
   *     `SUCCEEDED` or `FAILED`.
   * 1. `RRN`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Retrieval reference number associated with the
   *     transaction.
   * 1. `PayerVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payer.
   * 1. `PayerIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payer's bank account.
   * 1. `PayerAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payer's bank account number.
   * 1. `PayeeVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payee.
   * 1. `PayeeIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payee's bank account.
   * 1. `PayeeAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payee's bank account number.
   * 1. `PayeeMCC`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 4 characters
   *     * **Description** - Payee's Merchant Category Code (MCC), only if the
   *     payee is a merchant.
   * 1. `PayeeMerchantID`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 4 characters
   *     * **Description** - Payee's merchant ID, only if the payee is a
   *     merchant.
   * 1. `Currency`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Currency of the amount involved in the transaction.
   *     The currency codes are defined in ISO 4217.
   * 1. `Amount`
   *     * **Description** - Amount involved in the transaction.
   * 1. `Purpose`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 4 characters
   *     * **Description** - Purpose code associated with the transaction. When
   *     account manager is used for managing UPI Lite transactions, this column
   *     will contain one of the values from `41` (Lite account creation with
   *     initial topup), `42` (Lite account topup), `43` (Lite account
   *     disablement with balance transfer) or `44` (Lite account online
   *     transaction).
   * 1. `TransactionTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating the timestamp at
   *     which the transaction took place. The format will be as per RFC-3339.
   *     Example : 2022-11-22T23:00:05Z
   */
  exportAccountManagerTransactions(
    request: ExportAccountManagerTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** List account manager transactions that satisfy specified filter criteria. */
  listAccountManagerTransactions(
    request: ListAccountManagerTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAccountManagerTransactionsResponse>>;
  /**
   * Batch reconcile account manager transactions and return status for each
   * transaction.
   */
  batchReconcileAccountManagerTransactions(
    request: BatchReconcileAccountManagerTransactionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchReconcileAccountManagerTransactionsResponse>>;
}

export interface AccountManagerTransactionsClient<CallOptionsExt = {}> {
  /**
   * Export transactions received within the specified time range as a
   * file into a configured target location. The returned `Operation` type has
   * the following method-specific fields:
   *
   * - `metadata`:
   * [ExportAccountManagerTransactionsMetadata][google.cloud.paymentgateway.issuerswitch.accountmanager.v1.ExportAccountManagerTransactionsMetadata]
   * - `response`:
   * [ExportAccountManagerTransactionsResponse][google.cloud.paymentgateway.issuerswitch.accountmanager.v1.ExportAccountManagerTransactionsResponse]
   *
   * The exported file will be in the standard CSV format where each row in the
   * file represents a transaction. The file has the following fields in order:
   *
   * 1. `TransactionID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Account manager transaction ID.
   * 1. `TransactionType`
   *     * **Min Length** - 22 characters
   *     * **Max Length** - 25 characters
   *     * **Description** - Type of the transaction. This will be one of
   *     `TRANSACTION_TYPE_CREDIT`, `TRANSACTION_TYPE_CREDIT_REVERSAL`,
   *     `TRANSACTION_TYPE_DEBIT` or `TRANSACTION_TYPE_DEBIT_REVERSAL`. When
   *     account manager is used for managing UPI Lite transactions, the CREDIT
   *     transactions would be for Lite account top-ups and DEBIT transactions
   *     could be either for a Lite account disablement where balance is
   *     transferred back the underlying bank account or for a Lite account
   *     financial transaction which happened offline.
   * 1. `AccountID`
   *     * **Min Length** - 35 characters
   *     * **Max Length** - 35 characters
   *     * **Description** - Account ID. When account manager is used for
   *     managing UPI Lite transactions, this column will contain the Lite
   *     Reference Number (LRN) of the UPI Lite account.
   * 1. `State`
   *     * **Min Length** - 6 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - State of the transaction. This will be one of
   *     `SUCCEEDED` or `FAILED`.
   * 1. `RRN`
   *     * **Min Length** - 12 characters
   *     * **Max Length** - 12 characters
   *     * **Description** - Retrieval reference number associated with the
   *     transaction.
   * 1. `PayerVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payer.
   * 1. `PayerIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payer's bank account.
   * 1. `PayerAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payer's bank account number.
   * 1. `PayeeVPA`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 255 characters
   *     * **Description** - Virtual Payment Address (VPA) of the payee.
   * 1. `PayeeIFSC`
   *     * **Min Length** - 11 characters
   *     * **Max Length** - 11 characters
   *     * **Description** - IFSC of the payee's bank account.
   * 1. `PayeeAccountNumber`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 30 characters
   *     * **Description** - Payee's bank account number.
   * 1. `PayeeMCC`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 4 characters
   *     * **Description** - Payee's Merchant Category Code (MCC), only if the
   *     payee is a merchant.
   * 1. `PayeeMerchantID`
   *     * **Min Length** - 4 characters
   *     * **Max Length** - 4 characters
   *     * **Description** - Payee's merchant ID, only if the payee is a
   *     merchant.
   * 1. `Currency`
   *     * **Min Length** - 3 characters
   *     * **Max Length** - 3 characters
   *     * **Description** - Currency of the amount involved in the transaction.
   *     The currency codes are defined in ISO 4217.
   * 1. `Amount`
   *     * **Description** - Amount involved in the transaction.
   * 1. `Purpose`
   *     * **Min Length** - 1 characters
   *     * **Max Length** - 4 characters
   *     * **Description** - Purpose code associated with the transaction. When
   *     account manager is used for managing UPI Lite transactions, this column
   *     will contain one of the values from `41` (Lite account creation with
   *     initial topup), `42` (Lite account topup), `43` (Lite account
   *     disablement with balance transfer) or `44` (Lite account online
   *     transaction).
   * 1. `TransactionTime`
   *     * **Min Length** - 20 characters
   *     * **Max Length** - 20 characters
   *     * **Description** - Timestamp (in UTC) indicating the timestamp at
   *     which the transaction took place. The format will be as per RFC-3339.
   *     Example : 2022-11-22T23:00:05Z
   */
  exportAccountManagerTransactions(
    request: DeepPartial<ExportAccountManagerTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** List account manager transactions that satisfy specified filter criteria. */
  listAccountManagerTransactions(
    request: DeepPartial<ListAccountManagerTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAccountManagerTransactionsResponse>;
  /**
   * Batch reconcile account manager transactions and return status for each
   * transaction.
   */
  batchReconcileAccountManagerTransactions(
    request: DeepPartial<BatchReconcileAccountManagerTransactionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchReconcileAccountManagerTransactionsResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
