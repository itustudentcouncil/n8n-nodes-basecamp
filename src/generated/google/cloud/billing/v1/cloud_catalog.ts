// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/billing/v1/cloud_catalog.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Money } from "../../../type/money.js";

export const protobufPackage = "google.cloud.billing.v1";

/** Encapsulates a single service in Google Cloud Platform. */
export interface Service {
  /**
   * The resource name for the service.
   * Example: "services/6F81-5844-456A"
   */
  name: string;
  /**
   * The identifier for the service.
   * Example: "6F81-5844-456A"
   */
  serviceId: string;
  /** A human readable display name for this service. */
  displayName: string;
  /**
   * The business under which the service is offered.
   * Ex. "businessEntities/GCP", "businessEntities/Maps"
   */
  businessEntityName: string;
}

/** Encapsulates a single SKU in Google Cloud */
export interface Sku {
  /**
   * The resource name for the SKU.
   * Example: "services/6F81-5844-456A/skus/D041-B8A1-6E0B"
   */
  name: string;
  /**
   * The identifier for the SKU.
   * Example: "D041-B8A1-6E0B"
   */
  skuId: string;
  /**
   * A human readable description of the SKU, has a maximum length of 256
   * characters.
   */
  description: string;
  /** The category hierarchy of this SKU, purely for organizational purpose. */
  category:
    | Category
    | undefined;
  /**
   * List of service regions this SKU is offered at.
   * Example: "asia-east1"
   * Service regions can be found at https://cloud.google.com/about/locations/
   */
  serviceRegions: string[];
  /** A timeline of pricing info for this SKU in chronological order. */
  pricingInfo: PricingInfo[];
  /**
   * Identifies the service provider.
   * This is 'Google' for first party services in Google Cloud Platform.
   */
  serviceProviderName: string;
  /** The geographic taxonomy for this sku. */
  geoTaxonomy: GeoTaxonomy | undefined;
}

/** Represents the category hierarchy of a SKU. */
export interface Category {
  /** The display name of the service this SKU belongs to. */
  serviceDisplayName: string;
  /**
   * The type of product the SKU refers to.
   * Example: "Compute", "Storage", "Network", "ApplicationServices" etc.
   */
  resourceFamily: string;
  /**
   * A group classification for related SKUs.
   * Example: "RAM", "GPU", "Prediction", "Ops", "GoogleEgress" etc.
   */
  resourceGroup: string;
  /**
   * Represents how the SKU is consumed.
   * Example: "OnDemand", "Preemptible", "Commit1Mo", "Commit1Yr" etc.
   */
  usageType: string;
}

/** Represents the pricing information for a SKU at a single point of time. */
export interface PricingInfo {
  /**
   * The timestamp from which this pricing was effective within the requested
   * time range. This is guaranteed to be greater than or equal to the
   * start_time field in the request and less than the end_time field in the
   * request. If a time range was not specified in the request this field will
   * be equivalent to a time within the last 12 hours, indicating the latest
   * pricing info.
   */
  effectiveTime:
    | Date
    | undefined;
  /**
   * An optional human readable summary of the pricing information, has a
   * maximum length of 256 characters.
   */
  summary: string;
  /** Expresses the pricing formula. See `PricingExpression` for an example. */
  pricingExpression:
    | PricingExpression
    | undefined;
  /**
   * Aggregation Info. This can be left unspecified if the pricing expression
   * doesn't require aggregation.
   */
  aggregationInfo:
    | AggregationInfo
    | undefined;
  /**
   * Conversion rate used for currency conversion, from USD to the currency
   * specified in the request. This includes any surcharge collected for billing
   * in non USD currency. If a currency is not specified in the request this
   * defaults to 1.0.
   * Example: USD * currency_conversion_rate = JPY
   */
  currencyConversionRate: number;
}

/**
 * Expresses a mathematical pricing formula. For Example:-
 *
 * `usage_unit: GBy`
 * `tiered_rates:`
 *    `[start_usage_amount: 20, unit_price: $10]`
 *    `[start_usage_amount: 100, unit_price: $5]`
 *
 * The above expresses a pricing formula where the first 20GB is free, the
 * next 80GB is priced at $10 per GB followed by $5 per GB for additional
 * usage.
 */
export interface PricingExpression {
  /**
   * The short hand for unit of usage this pricing is specified in.
   * Example: usage_unit of "GiBy" means that usage is specified in "Gibi Byte".
   */
  usageUnit: string;
  /**
   * The recommended quantity of units for displaying pricing info. When
   * displaying pricing info it is recommended to display:
   * (unit_price * display_quantity) per display_quantity usage_unit.
   * This field does not affect the pricing formula and is for display purposes
   * only.
   * Example: If the unit_price is "0.0001 USD", the usage_unit is "GB" and
   * the display_quantity is "1000" then the recommended way of displaying the
   * pricing info is "0.10 USD per 1000 GB"
   */
  displayQuantity: number;
  /**
   * The list of tiered rates for this pricing. The total cost is computed by
   * applying each of the tiered rates on usage. This repeated list is sorted
   * by ascending order of start_usage_amount.
   */
  tieredRates: PricingExpression_TierRate[];
  /**
   * The unit of usage in human readable form.
   * Example: "gibi byte".
   */
  usageUnitDescription: string;
  /**
   * The base unit for the SKU which is the unit used in usage exports.
   * Example: "By"
   */
  baseUnit: string;
  /**
   * The base unit in human readable form.
   * Example: "byte".
   */
  baseUnitDescription: string;
  /**
   * Conversion factor for converting from price per usage_unit to price per
   * base_unit, and start_usage_amount to start_usage_amount in base_unit.
   * unit_price / base_unit_conversion_factor = price per base_unit.
   * start_usage_amount * base_unit_conversion_factor = start_usage_amount in
   * base_unit.
   */
  baseUnitConversionFactor: number;
}

/** The price rate indicating starting usage and its corresponding price. */
export interface PricingExpression_TierRate {
  /**
   * Usage is priced at this rate only after this amount.
   * Example: start_usage_amount of 10 indicates that the usage will be priced
   * at the unit_price after the first 10 usage_units.
   */
  startUsageAmount: number;
  /**
   * The price per unit of usage.
   * Example: unit_price of amount $10 indicates that each unit will cost $10.
   */
  unitPrice: Money | undefined;
}

/** Represents the aggregation level and interval for pricing of a single SKU. */
export interface AggregationInfo {
  aggregationLevel: AggregationInfo_AggregationLevel;
  aggregationInterval: AggregationInfo_AggregationInterval;
  /**
   * The number of intervals to aggregate over.
   * Example: If aggregation_level is "DAILY" and aggregation_count is 14,
   * aggregation will be over 14 days.
   */
  aggregationCount: number;
}

/**
 * The level at which usage is aggregated to compute cost.
 * Example: "ACCOUNT" aggregation level indicates that usage for tiered
 * pricing is aggregated across all projects in a single account.
 */
export enum AggregationInfo_AggregationLevel {
  AGGREGATION_LEVEL_UNSPECIFIED = 0,
  ACCOUNT = 1,
  PROJECT = 2,
  UNRECOGNIZED = -1,
}

export function aggregationInfo_AggregationLevelFromJSON(object: any): AggregationInfo_AggregationLevel {
  switch (object) {
    case 0:
    case "AGGREGATION_LEVEL_UNSPECIFIED":
      return AggregationInfo_AggregationLevel.AGGREGATION_LEVEL_UNSPECIFIED;
    case 1:
    case "ACCOUNT":
      return AggregationInfo_AggregationLevel.ACCOUNT;
    case 2:
    case "PROJECT":
      return AggregationInfo_AggregationLevel.PROJECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AggregationInfo_AggregationLevel.UNRECOGNIZED;
  }
}

export function aggregationInfo_AggregationLevelToJSON(object: AggregationInfo_AggregationLevel): string {
  switch (object) {
    case AggregationInfo_AggregationLevel.AGGREGATION_LEVEL_UNSPECIFIED:
      return "AGGREGATION_LEVEL_UNSPECIFIED";
    case AggregationInfo_AggregationLevel.ACCOUNT:
      return "ACCOUNT";
    case AggregationInfo_AggregationLevel.PROJECT:
      return "PROJECT";
    case AggregationInfo_AggregationLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The interval at which usage is aggregated to compute cost.
 * Example: "MONTHLY" aggregation interval indicates that usage for tiered
 * pricing is aggregated every month.
 */
export enum AggregationInfo_AggregationInterval {
  AGGREGATION_INTERVAL_UNSPECIFIED = 0,
  DAILY = 1,
  MONTHLY = 2,
  UNRECOGNIZED = -1,
}

export function aggregationInfo_AggregationIntervalFromJSON(object: any): AggregationInfo_AggregationInterval {
  switch (object) {
    case 0:
    case "AGGREGATION_INTERVAL_UNSPECIFIED":
      return AggregationInfo_AggregationInterval.AGGREGATION_INTERVAL_UNSPECIFIED;
    case 1:
    case "DAILY":
      return AggregationInfo_AggregationInterval.DAILY;
    case 2:
    case "MONTHLY":
      return AggregationInfo_AggregationInterval.MONTHLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AggregationInfo_AggregationInterval.UNRECOGNIZED;
  }
}

export function aggregationInfo_AggregationIntervalToJSON(object: AggregationInfo_AggregationInterval): string {
  switch (object) {
    case AggregationInfo_AggregationInterval.AGGREGATION_INTERVAL_UNSPECIFIED:
      return "AGGREGATION_INTERVAL_UNSPECIFIED";
    case AggregationInfo_AggregationInterval.DAILY:
      return "DAILY";
    case AggregationInfo_AggregationInterval.MONTHLY:
      return "MONTHLY";
    case AggregationInfo_AggregationInterval.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Encapsulates the geographic taxonomy data for a sku. */
export interface GeoTaxonomy {
  /** The type of Geo Taxonomy: GLOBAL, REGIONAL, or MULTI_REGIONAL. */
  type: GeoTaxonomy_Type;
  /**
   * The list of regions associated with a sku. Empty for Global skus, which are
   * associated with all Google Cloud regions.
   */
  regions: string[];
}

/** The type of Geo Taxonomy: GLOBAL, REGIONAL, or MULTI_REGIONAL. */
export enum GeoTaxonomy_Type {
  /** TYPE_UNSPECIFIED - The type is not specified. */
  TYPE_UNSPECIFIED = 0,
  /**
   * GLOBAL - The sku is global in nature, e.g. a license sku. Global skus are
   * available in all regions, and so have an empty region list.
   */
  GLOBAL = 1,
  /** REGIONAL - The sku is available in a specific region, e.g. "us-west2". */
  REGIONAL = 2,
  /**
   * MULTI_REGIONAL - The sku is associated with multiple regions, e.g. "us-west2" and
   * "us-east1".
   */
  MULTI_REGIONAL = 3,
  UNRECOGNIZED = -1,
}

export function geoTaxonomy_TypeFromJSON(object: any): GeoTaxonomy_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return GeoTaxonomy_Type.TYPE_UNSPECIFIED;
    case 1:
    case "GLOBAL":
      return GeoTaxonomy_Type.GLOBAL;
    case 2:
    case "REGIONAL":
      return GeoTaxonomy_Type.REGIONAL;
    case 3:
    case "MULTI_REGIONAL":
      return GeoTaxonomy_Type.MULTI_REGIONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GeoTaxonomy_Type.UNRECOGNIZED;
  }
}

export function geoTaxonomy_TypeToJSON(object: GeoTaxonomy_Type): string {
  switch (object) {
    case GeoTaxonomy_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case GeoTaxonomy_Type.GLOBAL:
      return "GLOBAL";
    case GeoTaxonomy_Type.REGIONAL:
      return "REGIONAL";
    case GeoTaxonomy_Type.MULTI_REGIONAL:
      return "MULTI_REGIONAL";
    case GeoTaxonomy_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for `ListServices`. */
export interface ListServicesRequest {
  /** Requested page size. Defaults to 5000. */
  pageSize: number;
  /**
   * A token identifying a page of results to return. This should be a
   * `next_page_token` value returned from a previous `ListServices`
   * call. If unspecified, the first page of results is returned.
   */
  pageToken: string;
}

/** Response message for `ListServices`. */
export interface ListServicesResponse {
  /** A list of services. */
  services: Service[];
  /**
   * A token to retrieve the next page of results. To retrieve the next page,
   * call `ListServices` again with the `page_token` field set to this
   * value. This field is empty if there are no more results to retrieve.
   */
  nextPageToken: string;
}

/** Request message for `ListSkus`. */
export interface ListSkusRequest {
  /**
   * Required. The name of the service.
   * Example: "services/6F81-5844-456A"
   */
  parent: string;
  /**
   * Optional inclusive start time of the time range for which the pricing
   * versions will be returned. Timestamps in the future are not allowed.
   * The time range has to be within a single calendar month in
   * America/Los_Angeles timezone. Time range as a whole is optional. If not
   * specified, the latest pricing will be returned (up to 12 hours old at
   * most).
   */
  startTime:
    | Date
    | undefined;
  /**
   * Optional exclusive end time of the time range for which the pricing
   * versions will be returned. Timestamps in the future are not allowed.
   * The time range has to be within a single calendar month in
   * America/Los_Angeles timezone. Time range as a whole is optional. If not
   * specified, the latest pricing will be returned (up to 12 hours old at
   * most).
   */
  endTime:
    | Date
    | undefined;
  /**
   * The ISO 4217 currency code for the pricing info in the response proto.
   * Will use the conversion rate as of start_time.
   * Optional. If not specified USD will be used.
   */
  currencyCode: string;
  /** Requested page size. Defaults to 5000. */
  pageSize: number;
  /**
   * A token identifying a page of results to return. This should be a
   * `next_page_token` value returned from a previous `ListSkus`
   * call. If unspecified, the first page of results is returned.
   */
  pageToken: string;
}

/** Response message for `ListSkus`. */
export interface ListSkusResponse {
  /** The list of public SKUs of the given service. */
  skus: Sku[];
  /**
   * A token to retrieve the next page of results. To retrieve the next page,
   * call `ListSkus` again with the `page_token` field set to this
   * value. This field is empty if there are no more results to retrieve.
   */
  nextPageToken: string;
}

function createBaseService(): Service {
  return { name: "", serviceId: "", displayName: "", businessEntityName: "" };
}

export const Service: MessageFns<Service> = {
  encode(message: Service, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.serviceId !== "") {
      writer.uint32(18).string(message.serviceId);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.businessEntityName !== "") {
      writer.uint32(34).string(message.businessEntityName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.serviceId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.businessEntityName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      serviceId: isSet(object.serviceId) ? globalThis.String(object.serviceId) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      businessEntityName: isSet(object.businessEntityName) ? globalThis.String(object.businessEntityName) : "",
    };
  },

  toJSON(message: Service): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.serviceId !== "") {
      obj.serviceId = message.serviceId;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.businessEntityName !== "") {
      obj.businessEntityName = message.businessEntityName;
    }
    return obj;
  },

  create(base?: DeepPartial<Service>): Service {
    return Service.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Service>): Service {
    const message = createBaseService();
    message.name = object.name ?? "";
    message.serviceId = object.serviceId ?? "";
    message.displayName = object.displayName ?? "";
    message.businessEntityName = object.businessEntityName ?? "";
    return message;
  },
};

function createBaseSku(): Sku {
  return {
    name: "",
    skuId: "",
    description: "",
    category: undefined,
    serviceRegions: [],
    pricingInfo: [],
    serviceProviderName: "",
    geoTaxonomy: undefined,
  };
}

export const Sku: MessageFns<Sku> = {
  encode(message: Sku, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.skuId !== "") {
      writer.uint32(18).string(message.skuId);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.category !== undefined) {
      Category.encode(message.category, writer.uint32(34).fork()).join();
    }
    for (const v of message.serviceRegions) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.pricingInfo) {
      PricingInfo.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.serviceProviderName !== "") {
      writer.uint32(58).string(message.serviceProviderName);
    }
    if (message.geoTaxonomy !== undefined) {
      GeoTaxonomy.encode(message.geoTaxonomy, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Sku {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSku();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skuId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.category = Category.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.serviceRegions.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pricingInfo.push(PricingInfo.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.serviceProviderName = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.geoTaxonomy = GeoTaxonomy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Sku {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      skuId: isSet(object.skuId) ? globalThis.String(object.skuId) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      category: isSet(object.category) ? Category.fromJSON(object.category) : undefined,
      serviceRegions: globalThis.Array.isArray(object?.serviceRegions)
        ? object.serviceRegions.map((e: any) => globalThis.String(e))
        : [],
      pricingInfo: globalThis.Array.isArray(object?.pricingInfo)
        ? object.pricingInfo.map((e: any) => PricingInfo.fromJSON(e))
        : [],
      serviceProviderName: isSet(object.serviceProviderName) ? globalThis.String(object.serviceProviderName) : "",
      geoTaxonomy: isSet(object.geoTaxonomy) ? GeoTaxonomy.fromJSON(object.geoTaxonomy) : undefined,
    };
  },

  toJSON(message: Sku): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.skuId !== "") {
      obj.skuId = message.skuId;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.category !== undefined) {
      obj.category = Category.toJSON(message.category);
    }
    if (message.serviceRegions?.length) {
      obj.serviceRegions = message.serviceRegions;
    }
    if (message.pricingInfo?.length) {
      obj.pricingInfo = message.pricingInfo.map((e) => PricingInfo.toJSON(e));
    }
    if (message.serviceProviderName !== "") {
      obj.serviceProviderName = message.serviceProviderName;
    }
    if (message.geoTaxonomy !== undefined) {
      obj.geoTaxonomy = GeoTaxonomy.toJSON(message.geoTaxonomy);
    }
    return obj;
  },

  create(base?: DeepPartial<Sku>): Sku {
    return Sku.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Sku>): Sku {
    const message = createBaseSku();
    message.name = object.name ?? "";
    message.skuId = object.skuId ?? "";
    message.description = object.description ?? "";
    message.category = (object.category !== undefined && object.category !== null)
      ? Category.fromPartial(object.category)
      : undefined;
    message.serviceRegions = object.serviceRegions?.map((e) => e) || [];
    message.pricingInfo = object.pricingInfo?.map((e) => PricingInfo.fromPartial(e)) || [];
    message.serviceProviderName = object.serviceProviderName ?? "";
    message.geoTaxonomy = (object.geoTaxonomy !== undefined && object.geoTaxonomy !== null)
      ? GeoTaxonomy.fromPartial(object.geoTaxonomy)
      : undefined;
    return message;
  },
};

function createBaseCategory(): Category {
  return { serviceDisplayName: "", resourceFamily: "", resourceGroup: "", usageType: "" };
}

export const Category: MessageFns<Category> = {
  encode(message: Category, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceDisplayName !== "") {
      writer.uint32(10).string(message.serviceDisplayName);
    }
    if (message.resourceFamily !== "") {
      writer.uint32(18).string(message.resourceFamily);
    }
    if (message.resourceGroup !== "") {
      writer.uint32(26).string(message.resourceGroup);
    }
    if (message.usageType !== "") {
      writer.uint32(34).string(message.usageType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Category {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceDisplayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceFamily = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resourceGroup = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.usageType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Category {
    return {
      serviceDisplayName: isSet(object.serviceDisplayName) ? globalThis.String(object.serviceDisplayName) : "",
      resourceFamily: isSet(object.resourceFamily) ? globalThis.String(object.resourceFamily) : "",
      resourceGroup: isSet(object.resourceGroup) ? globalThis.String(object.resourceGroup) : "",
      usageType: isSet(object.usageType) ? globalThis.String(object.usageType) : "",
    };
  },

  toJSON(message: Category): unknown {
    const obj: any = {};
    if (message.serviceDisplayName !== "") {
      obj.serviceDisplayName = message.serviceDisplayName;
    }
    if (message.resourceFamily !== "") {
      obj.resourceFamily = message.resourceFamily;
    }
    if (message.resourceGroup !== "") {
      obj.resourceGroup = message.resourceGroup;
    }
    if (message.usageType !== "") {
      obj.usageType = message.usageType;
    }
    return obj;
  },

  create(base?: DeepPartial<Category>): Category {
    return Category.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Category>): Category {
    const message = createBaseCategory();
    message.serviceDisplayName = object.serviceDisplayName ?? "";
    message.resourceFamily = object.resourceFamily ?? "";
    message.resourceGroup = object.resourceGroup ?? "";
    message.usageType = object.usageType ?? "";
    return message;
  },
};

function createBasePricingInfo(): PricingInfo {
  return {
    effectiveTime: undefined,
    summary: "",
    pricingExpression: undefined,
    aggregationInfo: undefined,
    currencyConversionRate: 0,
  };
}

export const PricingInfo: MessageFns<PricingInfo> = {
  encode(message: PricingInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.effectiveTime !== undefined) {
      Timestamp.encode(toTimestamp(message.effectiveTime), writer.uint32(10).fork()).join();
    }
    if (message.summary !== "") {
      writer.uint32(18).string(message.summary);
    }
    if (message.pricingExpression !== undefined) {
      PricingExpression.encode(message.pricingExpression, writer.uint32(26).fork()).join();
    }
    if (message.aggregationInfo !== undefined) {
      AggregationInfo.encode(message.aggregationInfo, writer.uint32(34).fork()).join();
    }
    if (message.currencyConversionRate !== 0) {
      writer.uint32(41).double(message.currencyConversionRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricingInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricingInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.effectiveTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.summary = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pricingExpression = PricingExpression.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.aggregationInfo = AggregationInfo.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.currencyConversionRate = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PricingInfo {
    return {
      effectiveTime: isSet(object.effectiveTime) ? fromJsonTimestamp(object.effectiveTime) : undefined,
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      pricingExpression: isSet(object.pricingExpression)
        ? PricingExpression.fromJSON(object.pricingExpression)
        : undefined,
      aggregationInfo: isSet(object.aggregationInfo) ? AggregationInfo.fromJSON(object.aggregationInfo) : undefined,
      currencyConversionRate: isSet(object.currencyConversionRate)
        ? globalThis.Number(object.currencyConversionRate)
        : 0,
    };
  },

  toJSON(message: PricingInfo): unknown {
    const obj: any = {};
    if (message.effectiveTime !== undefined) {
      obj.effectiveTime = message.effectiveTime.toISOString();
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.pricingExpression !== undefined) {
      obj.pricingExpression = PricingExpression.toJSON(message.pricingExpression);
    }
    if (message.aggregationInfo !== undefined) {
      obj.aggregationInfo = AggregationInfo.toJSON(message.aggregationInfo);
    }
    if (message.currencyConversionRate !== 0) {
      obj.currencyConversionRate = message.currencyConversionRate;
    }
    return obj;
  },

  create(base?: DeepPartial<PricingInfo>): PricingInfo {
    return PricingInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PricingInfo>): PricingInfo {
    const message = createBasePricingInfo();
    message.effectiveTime = object.effectiveTime ?? undefined;
    message.summary = object.summary ?? "";
    message.pricingExpression = (object.pricingExpression !== undefined && object.pricingExpression !== null)
      ? PricingExpression.fromPartial(object.pricingExpression)
      : undefined;
    message.aggregationInfo = (object.aggregationInfo !== undefined && object.aggregationInfo !== null)
      ? AggregationInfo.fromPartial(object.aggregationInfo)
      : undefined;
    message.currencyConversionRate = object.currencyConversionRate ?? 0;
    return message;
  },
};

function createBasePricingExpression(): PricingExpression {
  return {
    usageUnit: "",
    displayQuantity: 0,
    tieredRates: [],
    usageUnitDescription: "",
    baseUnit: "",
    baseUnitDescription: "",
    baseUnitConversionFactor: 0,
  };
}

export const PricingExpression: MessageFns<PricingExpression> = {
  encode(message: PricingExpression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.usageUnit !== "") {
      writer.uint32(10).string(message.usageUnit);
    }
    if (message.displayQuantity !== 0) {
      writer.uint32(17).double(message.displayQuantity);
    }
    for (const v of message.tieredRates) {
      PricingExpression_TierRate.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.usageUnitDescription !== "") {
      writer.uint32(34).string(message.usageUnitDescription);
    }
    if (message.baseUnit !== "") {
      writer.uint32(42).string(message.baseUnit);
    }
    if (message.baseUnitDescription !== "") {
      writer.uint32(50).string(message.baseUnitDescription);
    }
    if (message.baseUnitConversionFactor !== 0) {
      writer.uint32(57).double(message.baseUnitConversionFactor);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricingExpression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricingExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.usageUnit = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.displayQuantity = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tieredRates.push(PricingExpression_TierRate.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.usageUnitDescription = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.baseUnit = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.baseUnitDescription = reader.string();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.baseUnitConversionFactor = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PricingExpression {
    return {
      usageUnit: isSet(object.usageUnit) ? globalThis.String(object.usageUnit) : "",
      displayQuantity: isSet(object.displayQuantity) ? globalThis.Number(object.displayQuantity) : 0,
      tieredRates: globalThis.Array.isArray(object?.tieredRates)
        ? object.tieredRates.map((e: any) => PricingExpression_TierRate.fromJSON(e))
        : [],
      usageUnitDescription: isSet(object.usageUnitDescription) ? globalThis.String(object.usageUnitDescription) : "",
      baseUnit: isSet(object.baseUnit) ? globalThis.String(object.baseUnit) : "",
      baseUnitDescription: isSet(object.baseUnitDescription) ? globalThis.String(object.baseUnitDescription) : "",
      baseUnitConversionFactor: isSet(object.baseUnitConversionFactor)
        ? globalThis.Number(object.baseUnitConversionFactor)
        : 0,
    };
  },

  toJSON(message: PricingExpression): unknown {
    const obj: any = {};
    if (message.usageUnit !== "") {
      obj.usageUnit = message.usageUnit;
    }
    if (message.displayQuantity !== 0) {
      obj.displayQuantity = message.displayQuantity;
    }
    if (message.tieredRates?.length) {
      obj.tieredRates = message.tieredRates.map((e) => PricingExpression_TierRate.toJSON(e));
    }
    if (message.usageUnitDescription !== "") {
      obj.usageUnitDescription = message.usageUnitDescription;
    }
    if (message.baseUnit !== "") {
      obj.baseUnit = message.baseUnit;
    }
    if (message.baseUnitDescription !== "") {
      obj.baseUnitDescription = message.baseUnitDescription;
    }
    if (message.baseUnitConversionFactor !== 0) {
      obj.baseUnitConversionFactor = message.baseUnitConversionFactor;
    }
    return obj;
  },

  create(base?: DeepPartial<PricingExpression>): PricingExpression {
    return PricingExpression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PricingExpression>): PricingExpression {
    const message = createBasePricingExpression();
    message.usageUnit = object.usageUnit ?? "";
    message.displayQuantity = object.displayQuantity ?? 0;
    message.tieredRates = object.tieredRates?.map((e) => PricingExpression_TierRate.fromPartial(e)) || [];
    message.usageUnitDescription = object.usageUnitDescription ?? "";
    message.baseUnit = object.baseUnit ?? "";
    message.baseUnitDescription = object.baseUnitDescription ?? "";
    message.baseUnitConversionFactor = object.baseUnitConversionFactor ?? 0;
    return message;
  },
};

function createBasePricingExpression_TierRate(): PricingExpression_TierRate {
  return { startUsageAmount: 0, unitPrice: undefined };
}

export const PricingExpression_TierRate: MessageFns<PricingExpression_TierRate> = {
  encode(message: PricingExpression_TierRate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startUsageAmount !== 0) {
      writer.uint32(9).double(message.startUsageAmount);
    }
    if (message.unitPrice !== undefined) {
      Money.encode(message.unitPrice, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricingExpression_TierRate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricingExpression_TierRate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.startUsageAmount = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unitPrice = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PricingExpression_TierRate {
    return {
      startUsageAmount: isSet(object.startUsageAmount) ? globalThis.Number(object.startUsageAmount) : 0,
      unitPrice: isSet(object.unitPrice) ? Money.fromJSON(object.unitPrice) : undefined,
    };
  },

  toJSON(message: PricingExpression_TierRate): unknown {
    const obj: any = {};
    if (message.startUsageAmount !== 0) {
      obj.startUsageAmount = message.startUsageAmount;
    }
    if (message.unitPrice !== undefined) {
      obj.unitPrice = Money.toJSON(message.unitPrice);
    }
    return obj;
  },

  create(base?: DeepPartial<PricingExpression_TierRate>): PricingExpression_TierRate {
    return PricingExpression_TierRate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PricingExpression_TierRate>): PricingExpression_TierRate {
    const message = createBasePricingExpression_TierRate();
    message.startUsageAmount = object.startUsageAmount ?? 0;
    message.unitPrice = (object.unitPrice !== undefined && object.unitPrice !== null)
      ? Money.fromPartial(object.unitPrice)
      : undefined;
    return message;
  },
};

function createBaseAggregationInfo(): AggregationInfo {
  return { aggregationLevel: 0, aggregationInterval: 0, aggregationCount: 0 };
}

export const AggregationInfo: MessageFns<AggregationInfo> = {
  encode(message: AggregationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aggregationLevel !== 0) {
      writer.uint32(8).int32(message.aggregationLevel);
    }
    if (message.aggregationInterval !== 0) {
      writer.uint32(16).int32(message.aggregationInterval);
    }
    if (message.aggregationCount !== 0) {
      writer.uint32(24).int32(message.aggregationCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.aggregationLevel = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.aggregationInterval = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.aggregationCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregationInfo {
    return {
      aggregationLevel: isSet(object.aggregationLevel)
        ? aggregationInfo_AggregationLevelFromJSON(object.aggregationLevel)
        : 0,
      aggregationInterval: isSet(object.aggregationInterval)
        ? aggregationInfo_AggregationIntervalFromJSON(object.aggregationInterval)
        : 0,
      aggregationCount: isSet(object.aggregationCount) ? globalThis.Number(object.aggregationCount) : 0,
    };
  },

  toJSON(message: AggregationInfo): unknown {
    const obj: any = {};
    if (message.aggregationLevel !== 0) {
      obj.aggregationLevel = aggregationInfo_AggregationLevelToJSON(message.aggregationLevel);
    }
    if (message.aggregationInterval !== 0) {
      obj.aggregationInterval = aggregationInfo_AggregationIntervalToJSON(message.aggregationInterval);
    }
    if (message.aggregationCount !== 0) {
      obj.aggregationCount = Math.round(message.aggregationCount);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregationInfo>): AggregationInfo {
    return AggregationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregationInfo>): AggregationInfo {
    const message = createBaseAggregationInfo();
    message.aggregationLevel = object.aggregationLevel ?? 0;
    message.aggregationInterval = object.aggregationInterval ?? 0;
    message.aggregationCount = object.aggregationCount ?? 0;
    return message;
  },
};

function createBaseGeoTaxonomy(): GeoTaxonomy {
  return { type: 0, regions: [] };
}

export const GeoTaxonomy: MessageFns<GeoTaxonomy> = {
  encode(message: GeoTaxonomy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.regions) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeoTaxonomy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoTaxonomy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.regions.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoTaxonomy {
    return {
      type: isSet(object.type) ? geoTaxonomy_TypeFromJSON(object.type) : 0,
      regions: globalThis.Array.isArray(object?.regions) ? object.regions.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GeoTaxonomy): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = geoTaxonomy_TypeToJSON(message.type);
    }
    if (message.regions?.length) {
      obj.regions = message.regions;
    }
    return obj;
  },

  create(base?: DeepPartial<GeoTaxonomy>): GeoTaxonomy {
    return GeoTaxonomy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoTaxonomy>): GeoTaxonomy {
    const message = createBaseGeoTaxonomy();
    message.type = object.type ?? 0;
    message.regions = object.regions?.map((e) => e) || [];
    return message;
  },
};

function createBaseListServicesRequest(): ListServicesRequest {
  return { pageSize: 0, pageToken: "" };
}

export const ListServicesRequest: MessageFns<ListServicesRequest> = {
  encode(message: ListServicesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServicesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServicesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServicesRequest {
    return {
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListServicesRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListServicesRequest>): ListServicesRequest {
    return ListServicesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListServicesRequest>): ListServicesRequest {
    const message = createBaseListServicesRequest();
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListServicesResponse(): ListServicesResponse {
  return { services: [], nextPageToken: "" };
}

export const ListServicesResponse: MessageFns<ListServicesResponse> = {
  encode(message: ListServicesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.services) {
      Service.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServicesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListServicesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.services.push(Service.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListServicesResponse {
    return {
      services: globalThis.Array.isArray(object?.services) ? object.services.map((e: any) => Service.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListServicesResponse): unknown {
    const obj: any = {};
    if (message.services?.length) {
      obj.services = message.services.map((e) => Service.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListServicesResponse>): ListServicesResponse {
    return ListServicesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListServicesResponse>): ListServicesResponse {
    const message = createBaseListServicesResponse();
    message.services = object.services?.map((e) => Service.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseListSkusRequest(): ListSkusRequest {
  return { parent: "", startTime: undefined, endTime: undefined, currencyCode: "", pageSize: 0, pageToken: "" };
}

export const ListSkusRequest: MessageFns<ListSkusRequest> = {
  encode(message: ListSkusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    if (message.currencyCode !== "") {
      writer.uint32(34).string(message.currencyCode);
    }
    if (message.pageSize !== 0) {
      writer.uint32(40).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(50).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSkusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSkusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSkusRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListSkusRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSkusRequest>): ListSkusRequest {
    return ListSkusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSkusRequest>): ListSkusRequest {
    const message = createBaseListSkusRequest();
    message.parent = object.parent ?? "";
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.currencyCode = object.currencyCode ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSkusResponse(): ListSkusResponse {
  return { skus: [], nextPageToken: "" };
}

export const ListSkusResponse: MessageFns<ListSkusResponse> = {
  encode(message: ListSkusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.skus) {
      Sku.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSkusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSkusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skus.push(Sku.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSkusResponse {
    return {
      skus: globalThis.Array.isArray(object?.skus) ? object.skus.map((e: any) => Sku.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListSkusResponse): unknown {
    const obj: any = {};
    if (message.skus?.length) {
      obj.skus = message.skus.map((e) => Sku.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSkusResponse>): ListSkusResponse {
    return ListSkusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSkusResponse>): ListSkusResponse {
    const message = createBaseListSkusResponse();
    message.skus = object.skus?.map((e) => Sku.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

/**
 * A catalog of Google Cloud Platform services and SKUs.
 * Provides pricing information and metadata on Google Cloud Platform services
 * and SKUs.
 */
export type CloudCatalogDefinition = typeof CloudCatalogDefinition;
export const CloudCatalogDefinition = {
  name: "CloudCatalog",
  fullName: "google.cloud.billing.v1.CloudCatalog",
  methods: {
    /** Lists all public cloud services. */
    listServices: {
      name: "ListServices",
      requestType: ListServicesRequest,
      requestStream: false,
      responseType: ListServicesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([0])],
          578365826: [Buffer.from([14, 18, 12, 47, 118, 49, 47, 115, 101, 114, 118, 105, 99, 101, 115])],
        },
      },
    },
    /** Lists all publicly available SKUs for a given cloud service. */
    listSkus: {
      name: "ListSkus",
      requestType: ListSkusRequest,
      requestStream: false,
      responseType: ListSkusResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              30,
              18,
              28,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              115,
              47,
              42,
              125,
              47,
              115,
              107,
              117,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CloudCatalogServiceImplementation<CallContextExt = {}> {
  /** Lists all public cloud services. */
  listServices(
    request: ListServicesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListServicesResponse>>;
  /** Lists all publicly available SKUs for a given cloud service. */
  listSkus(request: ListSkusRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListSkusResponse>>;
}

export interface CloudCatalogClient<CallOptionsExt = {}> {
  /** Lists all public cloud services. */
  listServices(
    request: DeepPartial<ListServicesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListServicesResponse>;
  /** Lists all publicly available SKUs for a given cloud service. */
  listSkus(request: DeepPartial<ListSkusRequest>, options?: CallOptions & CallOptionsExt): Promise<ListSkusResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
