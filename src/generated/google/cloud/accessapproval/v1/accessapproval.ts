// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/accessapproval/v1/accessapproval.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.accessapproval.v1";

/** Represents the type of enrollment for a given service to Access Approval. */
export enum EnrollmentLevel {
  /** ENROLLMENT_LEVEL_UNSPECIFIED - Default value for proto, shouldn't be used. */
  ENROLLMENT_LEVEL_UNSPECIFIED = 0,
  /** BLOCK_ALL - Service is enrolled in Access Approval for all requests */
  BLOCK_ALL = 1,
  UNRECOGNIZED = -1,
}

export function enrollmentLevelFromJSON(object: any): EnrollmentLevel {
  switch (object) {
    case 0:
    case "ENROLLMENT_LEVEL_UNSPECIFIED":
      return EnrollmentLevel.ENROLLMENT_LEVEL_UNSPECIFIED;
    case 1:
    case "BLOCK_ALL":
      return EnrollmentLevel.BLOCK_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EnrollmentLevel.UNRECOGNIZED;
  }
}

export function enrollmentLevelToJSON(object: EnrollmentLevel): string {
  switch (object) {
    case EnrollmentLevel.ENROLLMENT_LEVEL_UNSPECIFIED:
      return "ENROLLMENT_LEVEL_UNSPECIFIED";
    case EnrollmentLevel.BLOCK_ALL:
      return "BLOCK_ALL";
    case EnrollmentLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Home office and physical location of the principal. */
export interface AccessLocations {
  /**
   * The "home office" location of the principal. A two-letter country code
   * (ISO 3166-1 alpha-2), such as "US", "DE" or "GB" or a region code. In some
   * limited situations Google systems may refer refer to a region code instead
   * of a country code.
   * Possible Region Codes:
   *
   *   * ASI: Asia
   *   * EUR: Europe
   *   * OCE: Oceania
   *   * AFR: Africa
   *   * NAM: North America
   *   * SAM: South America
   *   * ANT: Antarctica
   *   * ANY: Any location
   */
  principalOfficeCountry: string;
  /**
   * Physical location of the principal at the time of the access. A
   * two-letter country code (ISO 3166-1 alpha-2), such as "US", "DE" or "GB" or
   * a region code. In some limited situations Google systems may refer refer to
   * a region code instead of a country code.
   * Possible Region Codes:
   *
   *   * ASI: Asia
   *   * EUR: Europe
   *   * OCE: Oceania
   *   * AFR: Africa
   *   * NAM: North America
   *   * SAM: South America
   *   * ANT: Antarctica
   *   * ANY: Any location
   */
  principalPhysicalLocationCountry: string;
}

export interface AccessReason {
  /** Type of access justification. */
  type: AccessReason_Type;
  /** More detail about certain reason types. See comments for each type above. */
  detail: string;
}

/** Type of access justification. */
export enum AccessReason_Type {
  /** TYPE_UNSPECIFIED - Default value for proto, shouldn't be used. */
  TYPE_UNSPECIFIED = 0,
  /**
   * CUSTOMER_INITIATED_SUPPORT - Customer made a request or raised an issue that required the principal to
   * access customer data. `detail` is of the form ("#####" is the issue ID):
   *
   *   * "Feedback Report: #####"
   *   * "Case Number: #####"
   *   * "Case ID: #####"
   *   * "E-PIN Reference: #####"
   *   * "Google-#####"
   *   * "T-#####"
   */
  CUSTOMER_INITIATED_SUPPORT = 1,
  /**
   * GOOGLE_INITIATED_SERVICE - The principal accessed customer data in order to diagnose or resolve a
   * suspected issue in services. Often this access is used to confirm that
   * customers are not affected by a suspected service issue or to remediate a
   * reversible system issue.
   */
  GOOGLE_INITIATED_SERVICE = 2,
  /**
   * GOOGLE_INITIATED_REVIEW - Google initiated service for security, fraud, abuse, or compliance
   * purposes.
   */
  GOOGLE_INITIATED_REVIEW = 3,
  /**
   * THIRD_PARTY_DATA_REQUEST - The principal was compelled to access customer data in order to respond
   * to a legal third party data request or process, including legal processes
   * from customers themselves.
   */
  THIRD_PARTY_DATA_REQUEST = 4,
  /**
   * GOOGLE_RESPONSE_TO_PRODUCTION_ALERT - The principal accessed customer data in order to diagnose or resolve a
   * suspected issue in services or a known outage.
   */
  GOOGLE_RESPONSE_TO_PRODUCTION_ALERT = 5,
  UNRECOGNIZED = -1,
}

export function accessReason_TypeFromJSON(object: any): AccessReason_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return AccessReason_Type.TYPE_UNSPECIFIED;
    case 1:
    case "CUSTOMER_INITIATED_SUPPORT":
      return AccessReason_Type.CUSTOMER_INITIATED_SUPPORT;
    case 2:
    case "GOOGLE_INITIATED_SERVICE":
      return AccessReason_Type.GOOGLE_INITIATED_SERVICE;
    case 3:
    case "GOOGLE_INITIATED_REVIEW":
      return AccessReason_Type.GOOGLE_INITIATED_REVIEW;
    case 4:
    case "THIRD_PARTY_DATA_REQUEST":
      return AccessReason_Type.THIRD_PARTY_DATA_REQUEST;
    case 5:
    case "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT":
      return AccessReason_Type.GOOGLE_RESPONSE_TO_PRODUCTION_ALERT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessReason_Type.UNRECOGNIZED;
  }
}

export function accessReason_TypeToJSON(object: AccessReason_Type): string {
  switch (object) {
    case AccessReason_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case AccessReason_Type.CUSTOMER_INITIATED_SUPPORT:
      return "CUSTOMER_INITIATED_SUPPORT";
    case AccessReason_Type.GOOGLE_INITIATED_SERVICE:
      return "GOOGLE_INITIATED_SERVICE";
    case AccessReason_Type.GOOGLE_INITIATED_REVIEW:
      return "GOOGLE_INITIATED_REVIEW";
    case AccessReason_Type.THIRD_PARTY_DATA_REQUEST:
      return "THIRD_PARTY_DATA_REQUEST";
    case AccessReason_Type.GOOGLE_RESPONSE_TO_PRODUCTION_ALERT:
      return "GOOGLE_RESPONSE_TO_PRODUCTION_ALERT";
    case AccessReason_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information about the digital signature of the resource. */
export interface SignatureInfo {
  /** The digital signature. */
  signature: Buffer;
  /**
   * The public key for the Google default signing, encoded in PEM format. The
   * signature was created using a private key which may be verified using
   * this public key.
   */
  googlePublicKeyPem?:
    | string
    | undefined;
  /** The resource name of the customer CryptoKeyVersion used for signing. */
  customerKmsKeyVersion?: string | undefined;
}

/** A decision that has been made to approve access to a resource. */
export interface ApproveDecision {
  /** The time at which approval was granted. */
  approveTime:
    | Date
    | undefined;
  /** The time at which the approval expires. */
  expireTime:
    | Date
    | undefined;
  /** If set, denotes the timestamp at which the approval is invalidated. */
  invalidateTime:
    | Date
    | undefined;
  /** The signature for the ApprovalRequest and details on how it was signed. */
  signatureInfo:
    | SignatureInfo
    | undefined;
  /** True when the request has been auto-approved. */
  autoApproved: boolean;
}

/** A decision that has been made to dismiss an approval request. */
export interface DismissDecision {
  /** The time at which the approval request was dismissed. */
  dismissTime:
    | Date
    | undefined;
  /**
   * This field will be true if the ApprovalRequest was implicitly dismissed due
   * to inaction by the access approval approvers (the request is not acted
   * on by the approvers before the exiration time).
   */
  implicit: boolean;
}

/** The properties associated with the resource of the request. */
export interface ResourceProperties {
  /**
   * Whether an approval will exclude the descendants of the resource being
   * requested.
   */
  excludesDescendants: boolean;
}

/** A request for the customer to approve access to a resource. */
export interface ApprovalRequest {
  /**
   * The resource name of the request. Format is
   * "{projects|folders|organizations}/{id}/approvalRequests/{approval_request}".
   */
  name: string;
  /**
   * The resource for which approval is being requested. The format of the
   * resource name is defined at
   * https://cloud.google.com/apis/design/resource_names. The resource name here
   * may either be a "full" resource name (e.g.
   * "//library.googleapis.com/shelves/shelf1/books/book2") or a "relative"
   * resource name (e.g. "shelves/shelf1/books/book2") as described in the
   * resource name specification.
   */
  requestedResourceName: string;
  /** Properties related to the resource represented by requested_resource_name. */
  requestedResourceProperties:
    | ResourceProperties
    | undefined;
  /** The justification for which approval is being requested. */
  requestedReason:
    | AccessReason
    | undefined;
  /** The locations for which approval is being requested. */
  requestedLocations:
    | AccessLocations
    | undefined;
  /** The time at which approval was requested. */
  requestTime:
    | Date
    | undefined;
  /**
   * The requested expiration for the approval. If the request is approved,
   * access will be granted from the time of approval until the expiration time.
   */
  requestedExpiration:
    | Date
    | undefined;
  /** Access was approved. */
  approve?:
    | ApproveDecision
    | undefined;
  /** The request was dismissed. */
  dismiss?: DismissDecision | undefined;
}

/** Represents the enrollment of a cloud resource into a specific service. */
export interface EnrolledService {
  /**
   * The product for which Access Approval will be enrolled. Allowed values are
   * listed below (case-sensitive):
   *
   *   * all
   *   * GA
   *   * App Engine
   *   * BigQuery
   *   * Cloud Bigtable
   *   * Cloud Key Management Service
   *   * Compute Engine
   *   * Cloud Dataflow
   *   * Cloud Dataproc
   *   * Cloud DLP
   *   * Cloud EKM
   *   * Cloud HSM
   *   * Cloud Identity and Access Management
   *   * Cloud Logging
   *   * Cloud Pub/Sub
   *   * Cloud Spanner
   *   * Cloud SQL
   *   * Cloud Storage
   *   * Google Kubernetes Engine
   *   * Organization Policy Serivice
   *   * Persistent Disk
   *   * Resource Manager
   *   * Secret Manager
   *   * Speaker ID
   *
   * Note: These values are supported as input for legacy purposes, but will not
   * be returned from the API.
   *
   *   * all
   *   * ga-only
   *   * appengine.googleapis.com
   *   * bigquery.googleapis.com
   *   * bigtable.googleapis.com
   *   * container.googleapis.com
   *   * cloudkms.googleapis.com
   *   * cloudresourcemanager.googleapis.com
   *   * cloudsql.googleapis.com
   *   * compute.googleapis.com
   *   * dataflow.googleapis.com
   *   * dataproc.googleapis.com
   *   * dlp.googleapis.com
   *   * iam.googleapis.com
   *   * logging.googleapis.com
   *   * orgpolicy.googleapis.com
   *   * pubsub.googleapis.com
   *   * spanner.googleapis.com
   *   * secretmanager.googleapis.com
   *   * speakerid.googleapis.com
   *   * storage.googleapis.com
   *
   * Calls to UpdateAccessApprovalSettings using 'all' or any of the
   * XXX.googleapis.com will be translated to the associated product name
   * ('all', 'App Engine', etc.).
   *
   * Note: 'all' will enroll the resource in all products supported at both 'GA'
   * and 'Preview' levels.
   *
   * More information about levels of support is available at
   * https://cloud.google.com/access-approval/docs/supported-services
   */
  cloudProduct: string;
  /** The enrollment level of the service. */
  enrollmentLevel: EnrollmentLevel;
}

/** Settings on a Project/Folder/Organization related to Access Approval. */
export interface AccessApprovalSettings {
  /**
   * The resource name of the settings. Format is one of:
   *
   *   * "projects/{project}/accessApprovalSettings"
   *   * "folders/{folder}/accessApprovalSettings"
   *   * "organizations/{organization}/accessApprovalSettings"
   */
  name: string;
  /**
   * A list of email addresses to which notifications relating to approval
   * requests should be sent. Notifications relating to a resource will be sent
   * to all emails in the settings of ancestor resources of that resource. A
   * maximum of 50 email addresses are allowed.
   */
  notificationEmails: string[];
  /**
   * A list of Google Cloud Services for which the given resource has Access
   * Approval enrolled. Access requests for the resource given by name against
   * any of these services contained here will be required to have explicit
   * approval. If name refers to an organization, enrollment can be done for
   * individual services. If name refers to a folder or project, enrollment can
   * only be done on an all or nothing basis.
   *
   * If a cloud_product is repeated in this list, the first entry will be
   * honored and all following entries will be discarded. A maximum of 10
   * enrolled services will be enforced, to be expanded as the set of supported
   * services is expanded.
   */
  enrolledServices: EnrolledService[];
  /**
   * Output only. This field is read only (not settable via
   * UpdateAccessApprovalSettings method). If the field is true, that
   * indicates that at least one service is enrolled for Access Approval in one
   * or more ancestors of the Project or Folder (this field will always be
   * unset for the organization since organizations do not have ancestors).
   */
  enrolledAncestor: boolean;
  /**
   * The asymmetric crypto key version to use for signing approval requests.
   * Empty active_key_version indicates that a Google-managed key should be used
   * for signing. This property will be ignored if set by an ancestor of this
   * resource, and new non-empty values may not be set.
   */
  activeKeyVersion: string;
  /**
   * Output only. This field is read only (not settable via UpdateAccessApprovalSettings
   * method). If the field is true, that indicates that an ancestor of this
   * Project or Folder has set active_key_version (this field will always be
   * unset for the organization since organizations do not have ancestors).
   */
  ancestorHasActiveKeyVersion: boolean;
  /**
   * Output only. This field is read only (not settable via UpdateAccessApprovalSettings
   * method). If the field is true, that indicates that there is some
   * configuration issue with the active_key_version configured at this level in
   * the resource hierarchy (e.g. it doesn't exist or the Access Approval
   * service account doesn't have the correct permissions on it, etc.) This key
   * version is not necessarily the effective key version at this level, as key
   * versions are inherited top-down.
   */
  invalidKeyVersion: boolean;
}

/** Access Approval service account related to a project/folder/organization. */
export interface AccessApprovalServiceAccount {
  /**
   * The resource name of the Access Approval service account. Format is one of:
   *
   *   * "projects/{project}/serviceAccount"
   *   * "folders/{folder}/serviceAccount"
   *   * "organizations/{organization}/serviceAccount"
   */
  name: string;
  /** Email address of the service account. */
  accountEmail: string;
}

/** Request to list approval requests. */
export interface ListApprovalRequestsMessage {
  /**
   * The parent resource. This may be "projects/{project}",
   * "folders/{folder}", or "organizations/{organization}".
   */
  parent: string;
  /**
   * A filter on the type of approval requests to retrieve. Must be one of the
   * following values:
   *
   *   * [not set]: Requests that are pending or have active approvals.
   *   * ALL: All requests.
   *   * PENDING: Only pending requests.
   *   * ACTIVE: Only active (i.e. currently approved) requests.
   *   * DISMISSED: Only requests that have been dismissed, or requests that
   *     are not approved and past expiration.
   *   * EXPIRED: Only requests that have been approved, and the approval has
   *     expired.
   *   * HISTORY: Active, dismissed and expired requests.
   */
  filter: string;
  /** Requested page size. */
  pageSize: number;
  /** A token identifying the page of results to return. */
  pageToken: string;
}

/** Response to listing of ApprovalRequest objects. */
export interface ListApprovalRequestsResponse {
  /** Approval request details. */
  approvalRequests: ApprovalRequest[];
  /** Token to retrieve the next page of results, or empty if there are no more. */
  nextPageToken: string;
}

/** Request to get an approval request. */
export interface GetApprovalRequestMessage {
  /**
   * The name of the approval request to retrieve.
   * Format:
   * "{projects|folders|organizations}/{id}/approvalRequests/{approval_request}"
   */
  name: string;
}

/** Request to approve an ApprovalRequest. */
export interface ApproveApprovalRequestMessage {
  /** Name of the approval request to approve. */
  name: string;
  /** The expiration time of this approval. */
  expireTime: Date | undefined;
}

/** Request to dismiss an approval request. */
export interface DismissApprovalRequestMessage {
  /** Name of the ApprovalRequest to dismiss. */
  name: string;
}

/** Request to invalidate an existing approval. */
export interface InvalidateApprovalRequestMessage {
  /** Name of the ApprovalRequest to invalidate. */
  name: string;
}

/** Request to get access approval settings. */
export interface GetAccessApprovalSettingsMessage {
  /**
   * The name of the AccessApprovalSettings to retrieve.
   * Format: "{projects|folders|organizations}/{id}/accessApprovalSettings"
   */
  name: string;
}

/** Request to update access approval settings. */
export interface UpdateAccessApprovalSettingsMessage {
  /** The new AccessApprovalSettings. */
  settings:
    | AccessApprovalSettings
    | undefined;
  /**
   * The update mask applies to the settings. Only the top level fields of
   * AccessApprovalSettings (notification_emails & enrolled_services) are
   * supported. For each field, if it is included, the currently stored value
   * will be entirely overwritten with the value of the field passed in this
   * request.
   *
   * For the `FieldMask` definition, see
   * https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask
   * If this field is left unset, only the notification_emails field will be
   * updated.
   */
  updateMask: string[] | undefined;
}

/** Request to delete access approval settings. */
export interface DeleteAccessApprovalSettingsMessage {
  /** Name of the AccessApprovalSettings to delete. */
  name: string;
}

/** Request to get an Access Approval service account. */
export interface GetAccessApprovalServiceAccountMessage {
  /** Name of the AccessApprovalServiceAccount to retrieve. */
  name: string;
}

function createBaseAccessLocations(): AccessLocations {
  return { principalOfficeCountry: "", principalPhysicalLocationCountry: "" };
}

export const AccessLocations: MessageFns<AccessLocations> = {
  encode(message: AccessLocations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.principalOfficeCountry !== "") {
      writer.uint32(10).string(message.principalOfficeCountry);
    }
    if (message.principalPhysicalLocationCountry !== "") {
      writer.uint32(18).string(message.principalPhysicalLocationCountry);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessLocations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessLocations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.principalOfficeCountry = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.principalPhysicalLocationCountry = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessLocations {
    return {
      principalOfficeCountry: isSet(object.principalOfficeCountry)
        ? globalThis.String(object.principalOfficeCountry)
        : "",
      principalPhysicalLocationCountry: isSet(object.principalPhysicalLocationCountry)
        ? globalThis.String(object.principalPhysicalLocationCountry)
        : "",
    };
  },

  toJSON(message: AccessLocations): unknown {
    const obj: any = {};
    if (message.principalOfficeCountry !== "") {
      obj.principalOfficeCountry = message.principalOfficeCountry;
    }
    if (message.principalPhysicalLocationCountry !== "") {
      obj.principalPhysicalLocationCountry = message.principalPhysicalLocationCountry;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessLocations>): AccessLocations {
    return AccessLocations.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessLocations>): AccessLocations {
    const message = createBaseAccessLocations();
    message.principalOfficeCountry = object.principalOfficeCountry ?? "";
    message.principalPhysicalLocationCountry = object.principalPhysicalLocationCountry ?? "";
    return message;
  },
};

function createBaseAccessReason(): AccessReason {
  return { type: 0, detail: "" };
}

export const AccessReason: MessageFns<AccessReason> = {
  encode(message: AccessReason, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.detail !== "") {
      writer.uint32(18).string(message.detail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessReason {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessReason();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detail = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessReason {
    return {
      type: isSet(object.type) ? accessReason_TypeFromJSON(object.type) : 0,
      detail: isSet(object.detail) ? globalThis.String(object.detail) : "",
    };
  },

  toJSON(message: AccessReason): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = accessReason_TypeToJSON(message.type);
    }
    if (message.detail !== "") {
      obj.detail = message.detail;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessReason>): AccessReason {
    return AccessReason.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessReason>): AccessReason {
    const message = createBaseAccessReason();
    message.type = object.type ?? 0;
    message.detail = object.detail ?? "";
    return message;
  },
};

function createBaseSignatureInfo(): SignatureInfo {
  return { signature: Buffer.alloc(0), googlePublicKeyPem: undefined, customerKmsKeyVersion: undefined };
}

export const SignatureInfo: MessageFns<SignatureInfo> = {
  encode(message: SignatureInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signature.length !== 0) {
      writer.uint32(10).bytes(message.signature);
    }
    if (message.googlePublicKeyPem !== undefined) {
      writer.uint32(18).string(message.googlePublicKeyPem);
    }
    if (message.customerKmsKeyVersion !== undefined) {
      writer.uint32(26).string(message.customerKmsKeyVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignatureInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignatureInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.signature = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.googlePublicKeyPem = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customerKmsKeyVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignatureInfo {
    return {
      signature: isSet(object.signature) ? Buffer.from(bytesFromBase64(object.signature)) : Buffer.alloc(0),
      googlePublicKeyPem: isSet(object.googlePublicKeyPem) ? globalThis.String(object.googlePublicKeyPem) : undefined,
      customerKmsKeyVersion: isSet(object.customerKmsKeyVersion)
        ? globalThis.String(object.customerKmsKeyVersion)
        : undefined,
    };
  },

  toJSON(message: SignatureInfo): unknown {
    const obj: any = {};
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    if (message.googlePublicKeyPem !== undefined) {
      obj.googlePublicKeyPem = message.googlePublicKeyPem;
    }
    if (message.customerKmsKeyVersion !== undefined) {
      obj.customerKmsKeyVersion = message.customerKmsKeyVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<SignatureInfo>): SignatureInfo {
    return SignatureInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignatureInfo>): SignatureInfo {
    const message = createBaseSignatureInfo();
    message.signature = object.signature ?? Buffer.alloc(0);
    message.googlePublicKeyPem = object.googlePublicKeyPem ?? undefined;
    message.customerKmsKeyVersion = object.customerKmsKeyVersion ?? undefined;
    return message;
  },
};

function createBaseApproveDecision(): ApproveDecision {
  return {
    approveTime: undefined,
    expireTime: undefined,
    invalidateTime: undefined,
    signatureInfo: undefined,
    autoApproved: false,
  };
}

export const ApproveDecision: MessageFns<ApproveDecision> = {
  encode(message: ApproveDecision, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.approveTime !== undefined) {
      Timestamp.encode(toTimestamp(message.approveTime), writer.uint32(10).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(18).fork()).join();
    }
    if (message.invalidateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.invalidateTime), writer.uint32(26).fork()).join();
    }
    if (message.signatureInfo !== undefined) {
      SignatureInfo.encode(message.signatureInfo, writer.uint32(34).fork()).join();
    }
    if (message.autoApproved !== false) {
      writer.uint32(40).bool(message.autoApproved);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApproveDecision {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveDecision();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.approveTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.invalidateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.signatureInfo = SignatureInfo.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.autoApproved = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveDecision {
    return {
      approveTime: isSet(object.approveTime) ? fromJsonTimestamp(object.approveTime) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      invalidateTime: isSet(object.invalidateTime) ? fromJsonTimestamp(object.invalidateTime) : undefined,
      signatureInfo: isSet(object.signatureInfo) ? SignatureInfo.fromJSON(object.signatureInfo) : undefined,
      autoApproved: isSet(object.autoApproved) ? globalThis.Boolean(object.autoApproved) : false,
    };
  },

  toJSON(message: ApproveDecision): unknown {
    const obj: any = {};
    if (message.approveTime !== undefined) {
      obj.approveTime = message.approveTime.toISOString();
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.invalidateTime !== undefined) {
      obj.invalidateTime = message.invalidateTime.toISOString();
    }
    if (message.signatureInfo !== undefined) {
      obj.signatureInfo = SignatureInfo.toJSON(message.signatureInfo);
    }
    if (message.autoApproved !== false) {
      obj.autoApproved = message.autoApproved;
    }
    return obj;
  },

  create(base?: DeepPartial<ApproveDecision>): ApproveDecision {
    return ApproveDecision.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApproveDecision>): ApproveDecision {
    const message = createBaseApproveDecision();
    message.approveTime = object.approveTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.invalidateTime = object.invalidateTime ?? undefined;
    message.signatureInfo = (object.signatureInfo !== undefined && object.signatureInfo !== null)
      ? SignatureInfo.fromPartial(object.signatureInfo)
      : undefined;
    message.autoApproved = object.autoApproved ?? false;
    return message;
  },
};

function createBaseDismissDecision(): DismissDecision {
  return { dismissTime: undefined, implicit: false };
}

export const DismissDecision: MessageFns<DismissDecision> = {
  encode(message: DismissDecision, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dismissTime !== undefined) {
      Timestamp.encode(toTimestamp(message.dismissTime), writer.uint32(10).fork()).join();
    }
    if (message.implicit !== false) {
      writer.uint32(16).bool(message.implicit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DismissDecision {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDismissDecision();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dismissTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.implicit = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DismissDecision {
    return {
      dismissTime: isSet(object.dismissTime) ? fromJsonTimestamp(object.dismissTime) : undefined,
      implicit: isSet(object.implicit) ? globalThis.Boolean(object.implicit) : false,
    };
  },

  toJSON(message: DismissDecision): unknown {
    const obj: any = {};
    if (message.dismissTime !== undefined) {
      obj.dismissTime = message.dismissTime.toISOString();
    }
    if (message.implicit !== false) {
      obj.implicit = message.implicit;
    }
    return obj;
  },

  create(base?: DeepPartial<DismissDecision>): DismissDecision {
    return DismissDecision.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DismissDecision>): DismissDecision {
    const message = createBaseDismissDecision();
    message.dismissTime = object.dismissTime ?? undefined;
    message.implicit = object.implicit ?? false;
    return message;
  },
};

function createBaseResourceProperties(): ResourceProperties {
  return { excludesDescendants: false };
}

export const ResourceProperties: MessageFns<ResourceProperties> = {
  encode(message: ResourceProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.excludesDescendants !== false) {
      writer.uint32(8).bool(message.excludesDescendants);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.excludesDescendants = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceProperties {
    return {
      excludesDescendants: isSet(object.excludesDescendants) ? globalThis.Boolean(object.excludesDescendants) : false,
    };
  },

  toJSON(message: ResourceProperties): unknown {
    const obj: any = {};
    if (message.excludesDescendants !== false) {
      obj.excludesDescendants = message.excludesDescendants;
    }
    return obj;
  },

  create(base?: DeepPartial<ResourceProperties>): ResourceProperties {
    return ResourceProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResourceProperties>): ResourceProperties {
    const message = createBaseResourceProperties();
    message.excludesDescendants = object.excludesDescendants ?? false;
    return message;
  },
};

function createBaseApprovalRequest(): ApprovalRequest {
  return {
    name: "",
    requestedResourceName: "",
    requestedResourceProperties: undefined,
    requestedReason: undefined,
    requestedLocations: undefined,
    requestTime: undefined,
    requestedExpiration: undefined,
    approve: undefined,
    dismiss: undefined,
  };
}

export const ApprovalRequest: MessageFns<ApprovalRequest> = {
  encode(message: ApprovalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestedResourceName !== "") {
      writer.uint32(18).string(message.requestedResourceName);
    }
    if (message.requestedResourceProperties !== undefined) {
      ResourceProperties.encode(message.requestedResourceProperties, writer.uint32(74).fork()).join();
    }
    if (message.requestedReason !== undefined) {
      AccessReason.encode(message.requestedReason, writer.uint32(26).fork()).join();
    }
    if (message.requestedLocations !== undefined) {
      AccessLocations.encode(message.requestedLocations, writer.uint32(34).fork()).join();
    }
    if (message.requestTime !== undefined) {
      Timestamp.encode(toTimestamp(message.requestTime), writer.uint32(42).fork()).join();
    }
    if (message.requestedExpiration !== undefined) {
      Timestamp.encode(toTimestamp(message.requestedExpiration), writer.uint32(50).fork()).join();
    }
    if (message.approve !== undefined) {
      ApproveDecision.encode(message.approve, writer.uint32(58).fork()).join();
    }
    if (message.dismiss !== undefined) {
      DismissDecision.encode(message.dismiss, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApprovalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApprovalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestedResourceName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.requestedResourceProperties = ResourceProperties.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestedReason = AccessReason.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestedLocations = AccessLocations.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.requestedExpiration = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.approve = ApproveDecision.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.dismiss = DismissDecision.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApprovalRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestedResourceName: isSet(object.requestedResourceName) ? globalThis.String(object.requestedResourceName) : "",
      requestedResourceProperties: isSet(object.requestedResourceProperties)
        ? ResourceProperties.fromJSON(object.requestedResourceProperties)
        : undefined,
      requestedReason: isSet(object.requestedReason) ? AccessReason.fromJSON(object.requestedReason) : undefined,
      requestedLocations: isSet(object.requestedLocations)
        ? AccessLocations.fromJSON(object.requestedLocations)
        : undefined,
      requestTime: isSet(object.requestTime) ? fromJsonTimestamp(object.requestTime) : undefined,
      requestedExpiration: isSet(object.requestedExpiration)
        ? fromJsonTimestamp(object.requestedExpiration)
        : undefined,
      approve: isSet(object.approve) ? ApproveDecision.fromJSON(object.approve) : undefined,
      dismiss: isSet(object.dismiss) ? DismissDecision.fromJSON(object.dismiss) : undefined,
    };
  },

  toJSON(message: ApprovalRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestedResourceName !== "") {
      obj.requestedResourceName = message.requestedResourceName;
    }
    if (message.requestedResourceProperties !== undefined) {
      obj.requestedResourceProperties = ResourceProperties.toJSON(message.requestedResourceProperties);
    }
    if (message.requestedReason !== undefined) {
      obj.requestedReason = AccessReason.toJSON(message.requestedReason);
    }
    if (message.requestedLocations !== undefined) {
      obj.requestedLocations = AccessLocations.toJSON(message.requestedLocations);
    }
    if (message.requestTime !== undefined) {
      obj.requestTime = message.requestTime.toISOString();
    }
    if (message.requestedExpiration !== undefined) {
      obj.requestedExpiration = message.requestedExpiration.toISOString();
    }
    if (message.approve !== undefined) {
      obj.approve = ApproveDecision.toJSON(message.approve);
    }
    if (message.dismiss !== undefined) {
      obj.dismiss = DismissDecision.toJSON(message.dismiss);
    }
    return obj;
  },

  create(base?: DeepPartial<ApprovalRequest>): ApprovalRequest {
    return ApprovalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApprovalRequest>): ApprovalRequest {
    const message = createBaseApprovalRequest();
    message.name = object.name ?? "";
    message.requestedResourceName = object.requestedResourceName ?? "";
    message.requestedResourceProperties =
      (object.requestedResourceProperties !== undefined && object.requestedResourceProperties !== null)
        ? ResourceProperties.fromPartial(object.requestedResourceProperties)
        : undefined;
    message.requestedReason = (object.requestedReason !== undefined && object.requestedReason !== null)
      ? AccessReason.fromPartial(object.requestedReason)
      : undefined;
    message.requestedLocations = (object.requestedLocations !== undefined && object.requestedLocations !== null)
      ? AccessLocations.fromPartial(object.requestedLocations)
      : undefined;
    message.requestTime = object.requestTime ?? undefined;
    message.requestedExpiration = object.requestedExpiration ?? undefined;
    message.approve = (object.approve !== undefined && object.approve !== null)
      ? ApproveDecision.fromPartial(object.approve)
      : undefined;
    message.dismiss = (object.dismiss !== undefined && object.dismiss !== null)
      ? DismissDecision.fromPartial(object.dismiss)
      : undefined;
    return message;
  },
};

function createBaseEnrolledService(): EnrolledService {
  return { cloudProduct: "", enrollmentLevel: 0 };
}

export const EnrolledService: MessageFns<EnrolledService> = {
  encode(message: EnrolledService, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudProduct !== "") {
      writer.uint32(10).string(message.cloudProduct);
    }
    if (message.enrollmentLevel !== 0) {
      writer.uint32(16).int32(message.enrollmentLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnrolledService {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnrolledService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudProduct = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enrollmentLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnrolledService {
    return {
      cloudProduct: isSet(object.cloudProduct) ? globalThis.String(object.cloudProduct) : "",
      enrollmentLevel: isSet(object.enrollmentLevel) ? enrollmentLevelFromJSON(object.enrollmentLevel) : 0,
    };
  },

  toJSON(message: EnrolledService): unknown {
    const obj: any = {};
    if (message.cloudProduct !== "") {
      obj.cloudProduct = message.cloudProduct;
    }
    if (message.enrollmentLevel !== 0) {
      obj.enrollmentLevel = enrollmentLevelToJSON(message.enrollmentLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<EnrolledService>): EnrolledService {
    return EnrolledService.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EnrolledService>): EnrolledService {
    const message = createBaseEnrolledService();
    message.cloudProduct = object.cloudProduct ?? "";
    message.enrollmentLevel = object.enrollmentLevel ?? 0;
    return message;
  },
};

function createBaseAccessApprovalSettings(): AccessApprovalSettings {
  return {
    name: "",
    notificationEmails: [],
    enrolledServices: [],
    enrolledAncestor: false,
    activeKeyVersion: "",
    ancestorHasActiveKeyVersion: false,
    invalidKeyVersion: false,
  };
}

export const AccessApprovalSettings: MessageFns<AccessApprovalSettings> = {
  encode(message: AccessApprovalSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.notificationEmails) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.enrolledServices) {
      EnrolledService.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.enrolledAncestor !== false) {
      writer.uint32(32).bool(message.enrolledAncestor);
    }
    if (message.activeKeyVersion !== "") {
      writer.uint32(50).string(message.activeKeyVersion);
    }
    if (message.ancestorHasActiveKeyVersion !== false) {
      writer.uint32(56).bool(message.ancestorHasActiveKeyVersion);
    }
    if (message.invalidKeyVersion !== false) {
      writer.uint32(64).bool(message.invalidKeyVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessApprovalSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessApprovalSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.notificationEmails.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.enrolledServices.push(EnrolledService.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enrolledAncestor = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.activeKeyVersion = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.ancestorHasActiveKeyVersion = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.invalidKeyVersion = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessApprovalSettings {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      notificationEmails: globalThis.Array.isArray(object?.notificationEmails)
        ? object.notificationEmails.map((e: any) => globalThis.String(e))
        : [],
      enrolledServices: globalThis.Array.isArray(object?.enrolledServices)
        ? object.enrolledServices.map((e: any) => EnrolledService.fromJSON(e))
        : [],
      enrolledAncestor: isSet(object.enrolledAncestor) ? globalThis.Boolean(object.enrolledAncestor) : false,
      activeKeyVersion: isSet(object.activeKeyVersion) ? globalThis.String(object.activeKeyVersion) : "",
      ancestorHasActiveKeyVersion: isSet(object.ancestorHasActiveKeyVersion)
        ? globalThis.Boolean(object.ancestorHasActiveKeyVersion)
        : false,
      invalidKeyVersion: isSet(object.invalidKeyVersion) ? globalThis.Boolean(object.invalidKeyVersion) : false,
    };
  },

  toJSON(message: AccessApprovalSettings): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.notificationEmails?.length) {
      obj.notificationEmails = message.notificationEmails;
    }
    if (message.enrolledServices?.length) {
      obj.enrolledServices = message.enrolledServices.map((e) => EnrolledService.toJSON(e));
    }
    if (message.enrolledAncestor !== false) {
      obj.enrolledAncestor = message.enrolledAncestor;
    }
    if (message.activeKeyVersion !== "") {
      obj.activeKeyVersion = message.activeKeyVersion;
    }
    if (message.ancestorHasActiveKeyVersion !== false) {
      obj.ancestorHasActiveKeyVersion = message.ancestorHasActiveKeyVersion;
    }
    if (message.invalidKeyVersion !== false) {
      obj.invalidKeyVersion = message.invalidKeyVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessApprovalSettings>): AccessApprovalSettings {
    return AccessApprovalSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessApprovalSettings>): AccessApprovalSettings {
    const message = createBaseAccessApprovalSettings();
    message.name = object.name ?? "";
    message.notificationEmails = object.notificationEmails?.map((e) => e) || [];
    message.enrolledServices = object.enrolledServices?.map((e) => EnrolledService.fromPartial(e)) || [];
    message.enrolledAncestor = object.enrolledAncestor ?? false;
    message.activeKeyVersion = object.activeKeyVersion ?? "";
    message.ancestorHasActiveKeyVersion = object.ancestorHasActiveKeyVersion ?? false;
    message.invalidKeyVersion = object.invalidKeyVersion ?? false;
    return message;
  },
};

function createBaseAccessApprovalServiceAccount(): AccessApprovalServiceAccount {
  return { name: "", accountEmail: "" };
}

export const AccessApprovalServiceAccount: MessageFns<AccessApprovalServiceAccount> = {
  encode(message: AccessApprovalServiceAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.accountEmail !== "") {
      writer.uint32(18).string(message.accountEmail);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessApprovalServiceAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessApprovalServiceAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.accountEmail = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessApprovalServiceAccount {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      accountEmail: isSet(object.accountEmail) ? globalThis.String(object.accountEmail) : "",
    };
  },

  toJSON(message: AccessApprovalServiceAccount): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.accountEmail !== "") {
      obj.accountEmail = message.accountEmail;
    }
    return obj;
  },

  create(base?: DeepPartial<AccessApprovalServiceAccount>): AccessApprovalServiceAccount {
    return AccessApprovalServiceAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessApprovalServiceAccount>): AccessApprovalServiceAccount {
    const message = createBaseAccessApprovalServiceAccount();
    message.name = object.name ?? "";
    message.accountEmail = object.accountEmail ?? "";
    return message;
  },
};

function createBaseListApprovalRequestsMessage(): ListApprovalRequestsMessage {
  return { parent: "", filter: "", pageSize: 0, pageToken: "" };
}

export const ListApprovalRequestsMessage: MessageFns<ListApprovalRequestsMessage> = {
  encode(message: ListApprovalRequestsMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.filter !== "") {
      writer.uint32(18).string(message.filter);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListApprovalRequestsMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListApprovalRequestsMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListApprovalRequestsMessage {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListApprovalRequestsMessage): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListApprovalRequestsMessage>): ListApprovalRequestsMessage {
    return ListApprovalRequestsMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListApprovalRequestsMessage>): ListApprovalRequestsMessage {
    const message = createBaseListApprovalRequestsMessage();
    message.parent = object.parent ?? "";
    message.filter = object.filter ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListApprovalRequestsResponse(): ListApprovalRequestsResponse {
  return { approvalRequests: [], nextPageToken: "" };
}

export const ListApprovalRequestsResponse: MessageFns<ListApprovalRequestsResponse> = {
  encode(message: ListApprovalRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.approvalRequests) {
      ApprovalRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListApprovalRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListApprovalRequestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.approvalRequests.push(ApprovalRequest.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListApprovalRequestsResponse {
    return {
      approvalRequests: globalThis.Array.isArray(object?.approvalRequests)
        ? object.approvalRequests.map((e: any) => ApprovalRequest.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListApprovalRequestsResponse): unknown {
    const obj: any = {};
    if (message.approvalRequests?.length) {
      obj.approvalRequests = message.approvalRequests.map((e) => ApprovalRequest.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListApprovalRequestsResponse>): ListApprovalRequestsResponse {
    return ListApprovalRequestsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListApprovalRequestsResponse>): ListApprovalRequestsResponse {
    const message = createBaseListApprovalRequestsResponse();
    message.approvalRequests = object.approvalRequests?.map((e) => ApprovalRequest.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetApprovalRequestMessage(): GetApprovalRequestMessage {
  return { name: "" };
}

export const GetApprovalRequestMessage: MessageFns<GetApprovalRequestMessage> = {
  encode(message: GetApprovalRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetApprovalRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetApprovalRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetApprovalRequestMessage {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetApprovalRequestMessage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetApprovalRequestMessage>): GetApprovalRequestMessage {
    return GetApprovalRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetApprovalRequestMessage>): GetApprovalRequestMessage {
    const message = createBaseGetApprovalRequestMessage();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseApproveApprovalRequestMessage(): ApproveApprovalRequestMessage {
  return { name: "", expireTime: undefined };
}

export const ApproveApprovalRequestMessage: MessageFns<ApproveApprovalRequestMessage> = {
  encode(message: ApproveApprovalRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApproveApprovalRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApproveApprovalRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApproveApprovalRequestMessage {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
    };
  },

  toJSON(message: ApproveApprovalRequestMessage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ApproveApprovalRequestMessage>): ApproveApprovalRequestMessage {
    return ApproveApprovalRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApproveApprovalRequestMessage>): ApproveApprovalRequestMessage {
    const message = createBaseApproveApprovalRequestMessage();
    message.name = object.name ?? "";
    message.expireTime = object.expireTime ?? undefined;
    return message;
  },
};

function createBaseDismissApprovalRequestMessage(): DismissApprovalRequestMessage {
  return { name: "" };
}

export const DismissApprovalRequestMessage: MessageFns<DismissApprovalRequestMessage> = {
  encode(message: DismissApprovalRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DismissApprovalRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDismissApprovalRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DismissApprovalRequestMessage {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DismissApprovalRequestMessage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DismissApprovalRequestMessage>): DismissApprovalRequestMessage {
    return DismissApprovalRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DismissApprovalRequestMessage>): DismissApprovalRequestMessage {
    const message = createBaseDismissApprovalRequestMessage();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseInvalidateApprovalRequestMessage(): InvalidateApprovalRequestMessage {
  return { name: "" };
}

export const InvalidateApprovalRequestMessage: MessageFns<InvalidateApprovalRequestMessage> = {
  encode(message: InvalidateApprovalRequestMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvalidateApprovalRequestMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvalidateApprovalRequestMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvalidateApprovalRequestMessage {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: InvalidateApprovalRequestMessage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<InvalidateApprovalRequestMessage>): InvalidateApprovalRequestMessage {
    return InvalidateApprovalRequestMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InvalidateApprovalRequestMessage>): InvalidateApprovalRequestMessage {
    const message = createBaseInvalidateApprovalRequestMessage();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetAccessApprovalSettingsMessage(): GetAccessApprovalSettingsMessage {
  return { name: "" };
}

export const GetAccessApprovalSettingsMessage: MessageFns<GetAccessApprovalSettingsMessage> = {
  encode(message: GetAccessApprovalSettingsMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAccessApprovalSettingsMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccessApprovalSettingsMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccessApprovalSettingsMessage {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAccessApprovalSettingsMessage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAccessApprovalSettingsMessage>): GetAccessApprovalSettingsMessage {
    return GetAccessApprovalSettingsMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAccessApprovalSettingsMessage>): GetAccessApprovalSettingsMessage {
    const message = createBaseGetAccessApprovalSettingsMessage();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateAccessApprovalSettingsMessage(): UpdateAccessApprovalSettingsMessage {
  return { settings: undefined, updateMask: undefined };
}

export const UpdateAccessApprovalSettingsMessage: MessageFns<UpdateAccessApprovalSettingsMessage> = {
  encode(message: UpdateAccessApprovalSettingsMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settings !== undefined) {
      AccessApprovalSettings.encode(message.settings, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAccessApprovalSettingsMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAccessApprovalSettingsMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.settings = AccessApprovalSettings.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAccessApprovalSettingsMessage {
    return {
      settings: isSet(object.settings) ? AccessApprovalSettings.fromJSON(object.settings) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAccessApprovalSettingsMessage): unknown {
    const obj: any = {};
    if (message.settings !== undefined) {
      obj.settings = AccessApprovalSettings.toJSON(message.settings);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAccessApprovalSettingsMessage>): UpdateAccessApprovalSettingsMessage {
    return UpdateAccessApprovalSettingsMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAccessApprovalSettingsMessage>): UpdateAccessApprovalSettingsMessage {
    const message = createBaseUpdateAccessApprovalSettingsMessage();
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? AccessApprovalSettings.fromPartial(object.settings)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteAccessApprovalSettingsMessage(): DeleteAccessApprovalSettingsMessage {
  return { name: "" };
}

export const DeleteAccessApprovalSettingsMessage: MessageFns<DeleteAccessApprovalSettingsMessage> = {
  encode(message: DeleteAccessApprovalSettingsMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAccessApprovalSettingsMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAccessApprovalSettingsMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAccessApprovalSettingsMessage {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteAccessApprovalSettingsMessage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAccessApprovalSettingsMessage>): DeleteAccessApprovalSettingsMessage {
    return DeleteAccessApprovalSettingsMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAccessApprovalSettingsMessage>): DeleteAccessApprovalSettingsMessage {
    const message = createBaseDeleteAccessApprovalSettingsMessage();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetAccessApprovalServiceAccountMessage(): GetAccessApprovalServiceAccountMessage {
  return { name: "" };
}

export const GetAccessApprovalServiceAccountMessage: MessageFns<GetAccessApprovalServiceAccountMessage> = {
  encode(message: GetAccessApprovalServiceAccountMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAccessApprovalServiceAccountMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAccessApprovalServiceAccountMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAccessApprovalServiceAccountMessage {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAccessApprovalServiceAccountMessage): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAccessApprovalServiceAccountMessage>): GetAccessApprovalServiceAccountMessage {
    return GetAccessApprovalServiceAccountMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAccessApprovalServiceAccountMessage>): GetAccessApprovalServiceAccountMessage {
    const message = createBaseGetAccessApprovalServiceAccountMessage();
    message.name = object.name ?? "";
    return message;
  },
};

/**
 * This API allows a customer to manage accesses to cloud resources by
 * Google personnel. It defines the following resource model:
 *
 * - The API has a collection of
 *   [ApprovalRequest][google.cloud.accessapproval.v1.ApprovalRequest]
 *   resources, named `approvalRequests/{approval_request}`
 * - The API has top-level settings per Project/Folder/Organization, named
 *   `accessApprovalSettings`
 *
 * The service also periodically emails a list of recipients, defined at the
 * Project/Folder/Organization level in the accessApprovalSettings, when there
 * is a pending ApprovalRequest for them to act on. The ApprovalRequests can
 * also optionally be published to a Pub/Sub topic owned by the customer
 * (contact support if you would like to enable Pub/Sub notifications).
 *
 * ApprovalRequests can be approved or dismissed. Google personnel can only
 * access the indicated resource or resources if the request is approved
 * (subject to some exclusions:
 * https://cloud.google.com/access-approval/docs/overview#exclusions).
 *
 * Note: Using Access Approval functionality will mean that Google may not be
 * able to meet the SLAs for your chosen products, as any support response times
 * may be dramatically increased. As such the SLAs do not apply to any service
 * disruption to the extent impacted by Customer's use of Access Approval. Do
 * not enable Access Approval for projects where you may require high service
 * availability and rapid response by Google Cloud Support.
 *
 * After a request is approved or dismissed, no further action may be taken on
 * it. Requests with the requested_expiration in the past or with no activity
 * for 14 days are considered dismissed. When an approval expires, the request
 * is considered dismissed.
 *
 * If a request is not approved or dismissed, we call it pending.
 */
export type AccessApprovalDefinition = typeof AccessApprovalDefinition;
export const AccessApprovalDefinition = {
  name: "AccessApproval",
  fullName: "google.cloud.accessapproval.v1.AccessApproval",
  methods: {
    /**
     * Lists approval requests associated with a project, folder, or organization.
     * Approval requests can be filtered by state (pending, active, dismissed).
     * The order is reverse chronological.
     */
    listApprovalRequests: {
      name: "ListApprovalRequests",
      requestType: ListApprovalRequestsMessage,
      requestStream: false,
      responseType: ListApprovalRequestsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              134,
              1,
              90,
              41,
              18,
              39,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              125,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              90,
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              18,
              40,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets an approval request. Returns NOT_FOUND if the request does not exist. */
    getApprovalRequest: {
      name: "GetApprovalRequest",
      requestType: GetApprovalRequestMessage,
      requestStream: false,
      responseType: ApprovalRequest,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              134,
              1,
              90,
              41,
              18,
              39,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
              90,
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
              18,
              40,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Approves a request and returns the updated ApprovalRequest.
     *
     * Returns NOT_FOUND if the request does not exist. Returns
     * FAILED_PRECONDITION if the request exists but is not in a pending state.
     */
    approveApprovalRequest: {
      name: "ApproveApprovalRequest",
      requestType: ApproveApprovalRequestMessage,
      requestStream: false,
      responseType: ApprovalRequest,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              167,
              1,
              58,
              1,
              42,
              90,
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              112,
              112,
              114,
              111,
              118,
              101,
              90,
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              112,
              112,
              114,
              111,
              118,
              101,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
              58,
              97,
              112,
              112,
              114,
              111,
              118,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Dismisses a request. Returns the updated ApprovalRequest.
     *
     * NOTE: This does not deny access to the resource if another request has been
     * made and approved. It is equivalent in effect to ignoring the request
     * altogether.
     *
     * Returns NOT_FOUND if the request does not exist.
     *
     * Returns FAILED_PRECONDITION if the request exists but is not in a pending
     * state.
     */
    dismissApprovalRequest: {
      name: "DismissApprovalRequest",
      requestType: DismissApprovalRequestMessage,
      requestStream: false,
      responseType: ApprovalRequest,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              167,
              1,
              58,
              1,
              42,
              90,
              52,
              58,
              1,
              42,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              115,
              109,
              105,
              115,
              115,
              90,
              58,
              58,
              1,
              42,
              34,
              53,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              115,
              109,
              105,
              115,
              115,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
              58,
              100,
              105,
              115,
              109,
              105,
              115,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Invalidates an existing ApprovalRequest. Returns the updated
     * ApprovalRequest.
     *
     * NOTE: This does not deny access to the resource if another request has been
     * made and approved. It only invalidates a single approval.
     *
     * Returns FAILED_PRECONDITION if the request exists but is not in an approved
     * state.
     */
    invalidateApprovalRequest: {
      name: "InvalidateApprovalRequest",
      requestType: InvalidateApprovalRequestMessage,
      requestStream: false,
      responseType: ApprovalRequest,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              176,
              1,
              58,
              1,
              42,
              90,
              55,
              58,
              1,
              42,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
              58,
              105,
              110,
              118,
              97,
              108,
              105,
              100,
              97,
              116,
              101,
              90,
              61,
              58,
              1,
              42,
              34,
              56,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
              58,
              105,
              110,
              118,
              97,
              108,
              105,
              100,
              97,
              116,
              101,
              34,
              51,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              82,
              101,
              113,
              117,
              101,
              115,
              116,
              115,
              47,
              42,
              125,
              58,
              105,
              110,
              118,
              97,
              108,
              105,
              100,
              97,
              116,
              101,
            ]),
          ],
        },
      },
    },
    /** Gets the settings associated with a project, folder, or organization. */
    getAccessApprovalSettings: {
      name: "GetAccessApprovalSettings",
      requestType: GetAccessApprovalSettingsMessage,
      requestStream: false,
      responseType: AccessApprovalSettings,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              146,
              1,
              90,
              45,
              18,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              115,
              115,
              65,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
              90,
              51,
              18,
              49,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              115,
              115,
              65,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
              18,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              115,
              115,
              65,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates the settings associated with a project, folder, or organization.
     * Settings to update are determined by the value of field_mask.
     */
    updateAccessApprovalSettings: {
      name: "UpdateAccessApprovalSettings",
      requestType: UpdateAccessApprovalSettingsMessage,
      requestStream: false,
      responseType: AccessApprovalSettings,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              203,
              1,
              58,
              8,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              90,
              64,
              58,
              8,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              50,
              52,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              115,
              115,
              65,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
              90,
              70,
              58,
              8,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              50,
              58,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              115,
              115,
              65,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
              50,
              53,
              47,
              118,
              49,
              47,
              123,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              115,
              115,
              65,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the settings associated with a project, folder, or organization.
     * This will have the effect of disabling Access Approval for the project,
     * folder, or organization, but only if all ancestors also have Access
     * Approval disabled. If Access Approval is enabled at a higher level of the
     * hierarchy, then Access Approval will still be enabled at this level as
     * the settings are inherited.
     */
    deleteAccessApprovalSettings: {
      name: "DeleteAccessApprovalSettings",
      requestType: DeleteAccessApprovalSettingsMessage,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              146,
              1,
              90,
              45,
              42,
              43,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              115,
              115,
              65,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
              90,
              51,
              42,
              49,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              115,
              115,
              65,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
              42,
              44,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              97,
              99,
              99,
              101,
              115,
              115,
              65,
              112,
              112,
              114,
              111,
              118,
              97,
              108,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Retrieves the service account that is used by Access Approval to access KMS
     * keys for signing approved approval requests.
     */
    getAccessApprovalServiceAccount: {
      name: "GetAccessApprovalServiceAccount",
      requestType: GetAccessApprovalServiceAccountMessage,
      requestStream: false,
      responseType: AccessApprovalServiceAccount,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              122,
              90,
              37,
              18,
              35,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              102,
              111,
              108,
              100,
              101,
              114,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              125,
              90,
              43,
              18,
              41,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              125,
              18,
              36,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              99,
              101,
              65,
              99,
              99,
              111,
              117,
              110,
              116,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface AccessApprovalServiceImplementation<CallContextExt = {}> {
  /**
   * Lists approval requests associated with a project, folder, or organization.
   * Approval requests can be filtered by state (pending, active, dismissed).
   * The order is reverse chronological.
   */
  listApprovalRequests(
    request: ListApprovalRequestsMessage,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListApprovalRequestsResponse>>;
  /** Gets an approval request. Returns NOT_FOUND if the request does not exist. */
  getApprovalRequest(
    request: GetApprovalRequestMessage,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ApprovalRequest>>;
  /**
   * Approves a request and returns the updated ApprovalRequest.
   *
   * Returns NOT_FOUND if the request does not exist. Returns
   * FAILED_PRECONDITION if the request exists but is not in a pending state.
   */
  approveApprovalRequest(
    request: ApproveApprovalRequestMessage,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ApprovalRequest>>;
  /**
   * Dismisses a request. Returns the updated ApprovalRequest.
   *
   * NOTE: This does not deny access to the resource if another request has been
   * made and approved. It is equivalent in effect to ignoring the request
   * altogether.
   *
   * Returns NOT_FOUND if the request does not exist.
   *
   * Returns FAILED_PRECONDITION if the request exists but is not in a pending
   * state.
   */
  dismissApprovalRequest(
    request: DismissApprovalRequestMessage,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ApprovalRequest>>;
  /**
   * Invalidates an existing ApprovalRequest. Returns the updated
   * ApprovalRequest.
   *
   * NOTE: This does not deny access to the resource if another request has been
   * made and approved. It only invalidates a single approval.
   *
   * Returns FAILED_PRECONDITION if the request exists but is not in an approved
   * state.
   */
  invalidateApprovalRequest(
    request: InvalidateApprovalRequestMessage,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ApprovalRequest>>;
  /** Gets the settings associated with a project, folder, or organization. */
  getAccessApprovalSettings(
    request: GetAccessApprovalSettingsMessage,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AccessApprovalSettings>>;
  /**
   * Updates the settings associated with a project, folder, or organization.
   * Settings to update are determined by the value of field_mask.
   */
  updateAccessApprovalSettings(
    request: UpdateAccessApprovalSettingsMessage,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AccessApprovalSettings>>;
  /**
   * Deletes the settings associated with a project, folder, or organization.
   * This will have the effect of disabling Access Approval for the project,
   * folder, or organization, but only if all ancestors also have Access
   * Approval disabled. If Access Approval is enabled at a higher level of the
   * hierarchy, then Access Approval will still be enabled at this level as
   * the settings are inherited.
   */
  deleteAccessApprovalSettings(
    request: DeleteAccessApprovalSettingsMessage,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Retrieves the service account that is used by Access Approval to access KMS
   * keys for signing approved approval requests.
   */
  getAccessApprovalServiceAccount(
    request: GetAccessApprovalServiceAccountMessage,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AccessApprovalServiceAccount>>;
}

export interface AccessApprovalClient<CallOptionsExt = {}> {
  /**
   * Lists approval requests associated with a project, folder, or organization.
   * Approval requests can be filtered by state (pending, active, dismissed).
   * The order is reverse chronological.
   */
  listApprovalRequests(
    request: DeepPartial<ListApprovalRequestsMessage>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListApprovalRequestsResponse>;
  /** Gets an approval request. Returns NOT_FOUND if the request does not exist. */
  getApprovalRequest(
    request: DeepPartial<GetApprovalRequestMessage>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ApprovalRequest>;
  /**
   * Approves a request and returns the updated ApprovalRequest.
   *
   * Returns NOT_FOUND if the request does not exist. Returns
   * FAILED_PRECONDITION if the request exists but is not in a pending state.
   */
  approveApprovalRequest(
    request: DeepPartial<ApproveApprovalRequestMessage>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ApprovalRequest>;
  /**
   * Dismisses a request. Returns the updated ApprovalRequest.
   *
   * NOTE: This does not deny access to the resource if another request has been
   * made and approved. It is equivalent in effect to ignoring the request
   * altogether.
   *
   * Returns NOT_FOUND if the request does not exist.
   *
   * Returns FAILED_PRECONDITION if the request exists but is not in a pending
   * state.
   */
  dismissApprovalRequest(
    request: DeepPartial<DismissApprovalRequestMessage>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ApprovalRequest>;
  /**
   * Invalidates an existing ApprovalRequest. Returns the updated
   * ApprovalRequest.
   *
   * NOTE: This does not deny access to the resource if another request has been
   * made and approved. It only invalidates a single approval.
   *
   * Returns FAILED_PRECONDITION if the request exists but is not in an approved
   * state.
   */
  invalidateApprovalRequest(
    request: DeepPartial<InvalidateApprovalRequestMessage>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ApprovalRequest>;
  /** Gets the settings associated with a project, folder, or organization. */
  getAccessApprovalSettings(
    request: DeepPartial<GetAccessApprovalSettingsMessage>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AccessApprovalSettings>;
  /**
   * Updates the settings associated with a project, folder, or organization.
   * Settings to update are determined by the value of field_mask.
   */
  updateAccessApprovalSettings(
    request: DeepPartial<UpdateAccessApprovalSettingsMessage>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AccessApprovalSettings>;
  /**
   * Deletes the settings associated with a project, folder, or organization.
   * This will have the effect of disabling Access Approval for the project,
   * folder, or organization, but only if all ancestors also have Access
   * Approval disabled. If Access Approval is enabled at a higher level of the
   * hierarchy, then Access Approval will still be enabled at this level as
   * the settings are inherited.
   */
  deleteAccessApprovalSettings(
    request: DeepPartial<DeleteAccessApprovalSettingsMessage>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Retrieves the service account that is used by Access Approval to access KMS
   * keys for signing approved approval requests.
   */
  getAccessApprovalServiceAccount(
    request: DeepPartial<GetAccessApprovalServiceAccountMessage>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AccessApprovalServiceAccount>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
