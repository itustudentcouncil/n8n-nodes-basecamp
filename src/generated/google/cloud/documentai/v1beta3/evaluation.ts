// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/documentai/v1beta3/evaluation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.documentai.v1beta3";

/** Gives a short summary of an evaluation, and links to the evaluation itself. */
export interface EvaluationReference {
  /** The resource name of the Long Running Operation for the evaluation. */
  operation: string;
  /** The resource name of the evaluation. */
  evaluation: string;
  /** An aggregate of the statistics for the evaluation with fuzzy matching on. */
  aggregateMetrics:
    | Evaluation_Metrics
    | undefined;
  /** An aggregate of the statistics for the evaluation with fuzzy matching off. */
  aggregateMetricsExact: Evaluation_Metrics | undefined;
}

/** An evaluation of a ProcessorVersion's performance. */
export interface Evaluation {
  /**
   * The resource name of the evaluation.
   * Format:
   * `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processor_version}/evaluations/{evaluation}`
   */
  name: string;
  /** The time that the evaluation was created. */
  createTime:
    | Date
    | undefined;
  /** Counters for the documents used in the evaluation. */
  documentCounters:
    | Evaluation_Counters
    | undefined;
  /** Metrics for all the entities in aggregate. */
  allEntitiesMetrics:
    | Evaluation_MultiConfidenceMetrics
    | undefined;
  /** Metrics across confidence levels, for different entities. */
  entityMetrics: { [key: string]: Evaluation_MultiConfidenceMetrics };
  /** The KMS key name used for encryption. */
  kmsKeyName: string;
  /** The KMS key version with which data is encrypted. */
  kmsKeyVersionName: string;
}

/** Evaluation counters for the documents that were used. */
export interface Evaluation_Counters {
  /** How many documents were sent for evaluation. */
  inputDocumentsCount: number;
  /**
   * How many documents were not included in the evaluation as they didn't
   * pass validation.
   */
  invalidDocumentsCount: number;
  /**
   * How many documents were not included in the evaluation as Document AI
   * failed to process them.
   */
  failedDocumentsCount: number;
  /** How many documents were used in the evaluation. */
  evaluatedDocumentsCount: number;
}

/** Evaluation metrics, either in aggregate or about a specific entity. */
export interface Evaluation_Metrics {
  /** The calculated precision. */
  precision: number;
  /** The calculated recall. */
  recall: number;
  /** The calculated f1 score. */
  f1Score: number;
  /** The amount of occurrences in predicted documents. */
  predictedOccurrencesCount: number;
  /** The amount of occurrences in ground truth documents. */
  groundTruthOccurrencesCount: number;
  /** The amount of documents with a predicted occurrence. */
  predictedDocumentCount: number;
  /** The amount of documents with a ground truth occurrence. */
  groundTruthDocumentCount: number;
  /** The amount of true positives. */
  truePositivesCount: number;
  /** The amount of false positives. */
  falsePositivesCount: number;
  /** The amount of false negatives. */
  falseNegativesCount: number;
  /** The amount of documents that had an occurrence of this label. */
  totalDocumentsCount: number;
}

/** Evaluations metrics, at a specific confidence level. */
export interface Evaluation_ConfidenceLevelMetrics {
  /** The confidence level. */
  confidenceLevel: number;
  /** The metrics at the specific confidence level. */
  metrics: Evaluation_Metrics | undefined;
}

/** Metrics across multiple confidence levels. */
export interface Evaluation_MultiConfidenceMetrics {
  /** Metrics across confidence levels with fuzzy matching enabled. */
  confidenceLevelMetrics: Evaluation_ConfidenceLevelMetrics[];
  /** Metrics across confidence levels with only exact matching. */
  confidenceLevelMetricsExact: Evaluation_ConfidenceLevelMetrics[];
  /**
   * The calculated area under the precision recall curve (AUPRC), computed by
   * integrating over all confidence thresholds.
   */
  auprc: number;
  /**
   * The Estimated Calibration Error (ECE) of the confidence of the predicted
   * entities.
   */
  estimatedCalibrationError: number;
  /**
   * The AUPRC for metrics with fuzzy matching disabled, i.e., exact matching
   * only.
   */
  auprcExact: number;
  /**
   * The ECE for the predicted entities with fuzzy matching disabled, i.e.,
   * exact matching only.
   */
  estimatedCalibrationErrorExact: number;
  /** The metrics type for the label. */
  metricsType: Evaluation_MultiConfidenceMetrics_MetricsType;
}

/** A type that determines how metrics should be interpreted. */
export enum Evaluation_MultiConfidenceMetrics_MetricsType {
  /**
   * METRICS_TYPE_UNSPECIFIED - The metrics type is unspecified. By default, metrics without a
   * particular specification are for leaf entity types (i.e., top-level
   * entity types without child types, or child types which are not
   * parent types themselves).
   */
  METRICS_TYPE_UNSPECIFIED = 0,
  /**
   * AGGREGATE - Indicates whether metrics for this particular label type represent an
   * aggregate of metrics for other types instead of being based on actual
   * TP/FP/FN values for the label type. Metrics for parent (i.e., non-leaf)
   * entity types are an aggregate of metrics for their children.
   */
  AGGREGATE = 1,
  UNRECOGNIZED = -1,
}

export function evaluation_MultiConfidenceMetrics_MetricsTypeFromJSON(
  object: any,
): Evaluation_MultiConfidenceMetrics_MetricsType {
  switch (object) {
    case 0:
    case "METRICS_TYPE_UNSPECIFIED":
      return Evaluation_MultiConfidenceMetrics_MetricsType.METRICS_TYPE_UNSPECIFIED;
    case 1:
    case "AGGREGATE":
      return Evaluation_MultiConfidenceMetrics_MetricsType.AGGREGATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Evaluation_MultiConfidenceMetrics_MetricsType.UNRECOGNIZED;
  }
}

export function evaluation_MultiConfidenceMetrics_MetricsTypeToJSON(
  object: Evaluation_MultiConfidenceMetrics_MetricsType,
): string {
  switch (object) {
    case Evaluation_MultiConfidenceMetrics_MetricsType.METRICS_TYPE_UNSPECIFIED:
      return "METRICS_TYPE_UNSPECIFIED";
    case Evaluation_MultiConfidenceMetrics_MetricsType.AGGREGATE:
      return "AGGREGATE";
    case Evaluation_MultiConfidenceMetrics_MetricsType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Evaluation_EntityMetricsEntry {
  key: string;
  value: Evaluation_MultiConfidenceMetrics | undefined;
}

function createBaseEvaluationReference(): EvaluationReference {
  return { operation: "", evaluation: "", aggregateMetrics: undefined, aggregateMetricsExact: undefined };
}

export const EvaluationReference: MessageFns<EvaluationReference> = {
  encode(message: EvaluationReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== "") {
      writer.uint32(10).string(message.operation);
    }
    if (message.evaluation !== "") {
      writer.uint32(18).string(message.evaluation);
    }
    if (message.aggregateMetrics !== undefined) {
      Evaluation_Metrics.encode(message.aggregateMetrics, writer.uint32(34).fork()).join();
    }
    if (message.aggregateMetricsExact !== undefined) {
      Evaluation_Metrics.encode(message.aggregateMetricsExact, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluationReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluationReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operation = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.evaluation = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.aggregateMetrics = Evaluation_Metrics.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.aggregateMetricsExact = Evaluation_Metrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluationReference {
    return {
      operation: isSet(object.operation) ? globalThis.String(object.operation) : "",
      evaluation: isSet(object.evaluation) ? globalThis.String(object.evaluation) : "",
      aggregateMetrics: isSet(object.aggregateMetrics)
        ? Evaluation_Metrics.fromJSON(object.aggregateMetrics)
        : undefined,
      aggregateMetricsExact: isSet(object.aggregateMetricsExact)
        ? Evaluation_Metrics.fromJSON(object.aggregateMetricsExact)
        : undefined,
    };
  },

  toJSON(message: EvaluationReference): unknown {
    const obj: any = {};
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    if (message.evaluation !== "") {
      obj.evaluation = message.evaluation;
    }
    if (message.aggregateMetrics !== undefined) {
      obj.aggregateMetrics = Evaluation_Metrics.toJSON(message.aggregateMetrics);
    }
    if (message.aggregateMetricsExact !== undefined) {
      obj.aggregateMetricsExact = Evaluation_Metrics.toJSON(message.aggregateMetricsExact);
    }
    return obj;
  },

  create(base?: DeepPartial<EvaluationReference>): EvaluationReference {
    return EvaluationReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EvaluationReference>): EvaluationReference {
    const message = createBaseEvaluationReference();
    message.operation = object.operation ?? "";
    message.evaluation = object.evaluation ?? "";
    message.aggregateMetrics = (object.aggregateMetrics !== undefined && object.aggregateMetrics !== null)
      ? Evaluation_Metrics.fromPartial(object.aggregateMetrics)
      : undefined;
    message.aggregateMetricsExact =
      (object.aggregateMetricsExact !== undefined && object.aggregateMetricsExact !== null)
        ? Evaluation_Metrics.fromPartial(object.aggregateMetricsExact)
        : undefined;
    return message;
  },
};

function createBaseEvaluation(): Evaluation {
  return {
    name: "",
    createTime: undefined,
    documentCounters: undefined,
    allEntitiesMetrics: undefined,
    entityMetrics: {},
    kmsKeyName: "",
    kmsKeyVersionName: "",
  };
}

export const Evaluation: MessageFns<Evaluation> = {
  encode(message: Evaluation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.documentCounters !== undefined) {
      Evaluation_Counters.encode(message.documentCounters, writer.uint32(42).fork()).join();
    }
    if (message.allEntitiesMetrics !== undefined) {
      Evaluation_MultiConfidenceMetrics.encode(message.allEntitiesMetrics, writer.uint32(26).fork()).join();
    }
    Object.entries(message.entityMetrics).forEach(([key, value]) => {
      Evaluation_EntityMetricsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.kmsKeyName !== "") {
      writer.uint32(50).string(message.kmsKeyName);
    }
    if (message.kmsKeyVersionName !== "") {
      writer.uint32(58).string(message.kmsKeyVersionName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Evaluation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.documentCounters = Evaluation_Counters.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.allEntitiesMetrics = Evaluation_MultiConfidenceMetrics.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Evaluation_EntityMetricsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.entityMetrics[entry4.key] = entry4.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.kmsKeyVersionName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Evaluation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      documentCounters: isSet(object.documentCounters)
        ? Evaluation_Counters.fromJSON(object.documentCounters)
        : undefined,
      allEntitiesMetrics: isSet(object.allEntitiesMetrics)
        ? Evaluation_MultiConfidenceMetrics.fromJSON(object.allEntitiesMetrics)
        : undefined,
      entityMetrics: isObject(object.entityMetrics)
        ? Object.entries(object.entityMetrics).reduce<{ [key: string]: Evaluation_MultiConfidenceMetrics }>(
          (acc, [key, value]) => {
            acc[key] = Evaluation_MultiConfidenceMetrics.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : "",
      kmsKeyVersionName: isSet(object.kmsKeyVersionName) ? globalThis.String(object.kmsKeyVersionName) : "",
    };
  },

  toJSON(message: Evaluation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.documentCounters !== undefined) {
      obj.documentCounters = Evaluation_Counters.toJSON(message.documentCounters);
    }
    if (message.allEntitiesMetrics !== undefined) {
      obj.allEntitiesMetrics = Evaluation_MultiConfidenceMetrics.toJSON(message.allEntitiesMetrics);
    }
    if (message.entityMetrics) {
      const entries = Object.entries(message.entityMetrics);
      if (entries.length > 0) {
        obj.entityMetrics = {};
        entries.forEach(([k, v]) => {
          obj.entityMetrics[k] = Evaluation_MultiConfidenceMetrics.toJSON(v);
        });
      }
    }
    if (message.kmsKeyName !== "") {
      obj.kmsKeyName = message.kmsKeyName;
    }
    if (message.kmsKeyVersionName !== "") {
      obj.kmsKeyVersionName = message.kmsKeyVersionName;
    }
    return obj;
  },

  create(base?: DeepPartial<Evaluation>): Evaluation {
    return Evaluation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Evaluation>): Evaluation {
    const message = createBaseEvaluation();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.documentCounters = (object.documentCounters !== undefined && object.documentCounters !== null)
      ? Evaluation_Counters.fromPartial(object.documentCounters)
      : undefined;
    message.allEntitiesMetrics = (object.allEntitiesMetrics !== undefined && object.allEntitiesMetrics !== null)
      ? Evaluation_MultiConfidenceMetrics.fromPartial(object.allEntitiesMetrics)
      : undefined;
    message.entityMetrics = Object.entries(object.entityMetrics ?? {}).reduce<
      { [key: string]: Evaluation_MultiConfidenceMetrics }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Evaluation_MultiConfidenceMetrics.fromPartial(value);
      }
      return acc;
    }, {});
    message.kmsKeyName = object.kmsKeyName ?? "";
    message.kmsKeyVersionName = object.kmsKeyVersionName ?? "";
    return message;
  },
};

function createBaseEvaluation_Counters(): Evaluation_Counters {
  return { inputDocumentsCount: 0, invalidDocumentsCount: 0, failedDocumentsCount: 0, evaluatedDocumentsCount: 0 };
}

export const Evaluation_Counters: MessageFns<Evaluation_Counters> = {
  encode(message: Evaluation_Counters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputDocumentsCount !== 0) {
      writer.uint32(8).int32(message.inputDocumentsCount);
    }
    if (message.invalidDocumentsCount !== 0) {
      writer.uint32(16).int32(message.invalidDocumentsCount);
    }
    if (message.failedDocumentsCount !== 0) {
      writer.uint32(24).int32(message.failedDocumentsCount);
    }
    if (message.evaluatedDocumentsCount !== 0) {
      writer.uint32(32).int32(message.evaluatedDocumentsCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Evaluation_Counters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluation_Counters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.inputDocumentsCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.invalidDocumentsCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.failedDocumentsCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.evaluatedDocumentsCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Evaluation_Counters {
    return {
      inputDocumentsCount: isSet(object.inputDocumentsCount) ? globalThis.Number(object.inputDocumentsCount) : 0,
      invalidDocumentsCount: isSet(object.invalidDocumentsCount) ? globalThis.Number(object.invalidDocumentsCount) : 0,
      failedDocumentsCount: isSet(object.failedDocumentsCount) ? globalThis.Number(object.failedDocumentsCount) : 0,
      evaluatedDocumentsCount: isSet(object.evaluatedDocumentsCount)
        ? globalThis.Number(object.evaluatedDocumentsCount)
        : 0,
    };
  },

  toJSON(message: Evaluation_Counters): unknown {
    const obj: any = {};
    if (message.inputDocumentsCount !== 0) {
      obj.inputDocumentsCount = Math.round(message.inputDocumentsCount);
    }
    if (message.invalidDocumentsCount !== 0) {
      obj.invalidDocumentsCount = Math.round(message.invalidDocumentsCount);
    }
    if (message.failedDocumentsCount !== 0) {
      obj.failedDocumentsCount = Math.round(message.failedDocumentsCount);
    }
    if (message.evaluatedDocumentsCount !== 0) {
      obj.evaluatedDocumentsCount = Math.round(message.evaluatedDocumentsCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Evaluation_Counters>): Evaluation_Counters {
    return Evaluation_Counters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Evaluation_Counters>): Evaluation_Counters {
    const message = createBaseEvaluation_Counters();
    message.inputDocumentsCount = object.inputDocumentsCount ?? 0;
    message.invalidDocumentsCount = object.invalidDocumentsCount ?? 0;
    message.failedDocumentsCount = object.failedDocumentsCount ?? 0;
    message.evaluatedDocumentsCount = object.evaluatedDocumentsCount ?? 0;
    return message;
  },
};

function createBaseEvaluation_Metrics(): Evaluation_Metrics {
  return {
    precision: 0,
    recall: 0,
    f1Score: 0,
    predictedOccurrencesCount: 0,
    groundTruthOccurrencesCount: 0,
    predictedDocumentCount: 0,
    groundTruthDocumentCount: 0,
    truePositivesCount: 0,
    falsePositivesCount: 0,
    falseNegativesCount: 0,
    totalDocumentsCount: 0,
  };
}

export const Evaluation_Metrics: MessageFns<Evaluation_Metrics> = {
  encode(message: Evaluation_Metrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.precision !== 0) {
      writer.uint32(13).float(message.precision);
    }
    if (message.recall !== 0) {
      writer.uint32(21).float(message.recall);
    }
    if (message.f1Score !== 0) {
      writer.uint32(29).float(message.f1Score);
    }
    if (message.predictedOccurrencesCount !== 0) {
      writer.uint32(32).int32(message.predictedOccurrencesCount);
    }
    if (message.groundTruthOccurrencesCount !== 0) {
      writer.uint32(40).int32(message.groundTruthOccurrencesCount);
    }
    if (message.predictedDocumentCount !== 0) {
      writer.uint32(80).int32(message.predictedDocumentCount);
    }
    if (message.groundTruthDocumentCount !== 0) {
      writer.uint32(88).int32(message.groundTruthDocumentCount);
    }
    if (message.truePositivesCount !== 0) {
      writer.uint32(48).int32(message.truePositivesCount);
    }
    if (message.falsePositivesCount !== 0) {
      writer.uint32(56).int32(message.falsePositivesCount);
    }
    if (message.falseNegativesCount !== 0) {
      writer.uint32(64).int32(message.falseNegativesCount);
    }
    if (message.totalDocumentsCount !== 0) {
      writer.uint32(72).int32(message.totalDocumentsCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Evaluation_Metrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluation_Metrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.precision = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.recall = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.f1Score = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.predictedOccurrencesCount = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.groundTruthOccurrencesCount = reader.int32();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.predictedDocumentCount = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.groundTruthDocumentCount = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.truePositivesCount = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.falsePositivesCount = reader.int32();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.falseNegativesCount = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.totalDocumentsCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Evaluation_Metrics {
    return {
      precision: isSet(object.precision) ? globalThis.Number(object.precision) : 0,
      recall: isSet(object.recall) ? globalThis.Number(object.recall) : 0,
      f1Score: isSet(object.f1Score) ? globalThis.Number(object.f1Score) : 0,
      predictedOccurrencesCount: isSet(object.predictedOccurrencesCount)
        ? globalThis.Number(object.predictedOccurrencesCount)
        : 0,
      groundTruthOccurrencesCount: isSet(object.groundTruthOccurrencesCount)
        ? globalThis.Number(object.groundTruthOccurrencesCount)
        : 0,
      predictedDocumentCount: isSet(object.predictedDocumentCount)
        ? globalThis.Number(object.predictedDocumentCount)
        : 0,
      groundTruthDocumentCount: isSet(object.groundTruthDocumentCount)
        ? globalThis.Number(object.groundTruthDocumentCount)
        : 0,
      truePositivesCount: isSet(object.truePositivesCount) ? globalThis.Number(object.truePositivesCount) : 0,
      falsePositivesCount: isSet(object.falsePositivesCount) ? globalThis.Number(object.falsePositivesCount) : 0,
      falseNegativesCount: isSet(object.falseNegativesCount) ? globalThis.Number(object.falseNegativesCount) : 0,
      totalDocumentsCount: isSet(object.totalDocumentsCount) ? globalThis.Number(object.totalDocumentsCount) : 0,
    };
  },

  toJSON(message: Evaluation_Metrics): unknown {
    const obj: any = {};
    if (message.precision !== 0) {
      obj.precision = message.precision;
    }
    if (message.recall !== 0) {
      obj.recall = message.recall;
    }
    if (message.f1Score !== 0) {
      obj.f1Score = message.f1Score;
    }
    if (message.predictedOccurrencesCount !== 0) {
      obj.predictedOccurrencesCount = Math.round(message.predictedOccurrencesCount);
    }
    if (message.groundTruthOccurrencesCount !== 0) {
      obj.groundTruthOccurrencesCount = Math.round(message.groundTruthOccurrencesCount);
    }
    if (message.predictedDocumentCount !== 0) {
      obj.predictedDocumentCount = Math.round(message.predictedDocumentCount);
    }
    if (message.groundTruthDocumentCount !== 0) {
      obj.groundTruthDocumentCount = Math.round(message.groundTruthDocumentCount);
    }
    if (message.truePositivesCount !== 0) {
      obj.truePositivesCount = Math.round(message.truePositivesCount);
    }
    if (message.falsePositivesCount !== 0) {
      obj.falsePositivesCount = Math.round(message.falsePositivesCount);
    }
    if (message.falseNegativesCount !== 0) {
      obj.falseNegativesCount = Math.round(message.falseNegativesCount);
    }
    if (message.totalDocumentsCount !== 0) {
      obj.totalDocumentsCount = Math.round(message.totalDocumentsCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Evaluation_Metrics>): Evaluation_Metrics {
    return Evaluation_Metrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Evaluation_Metrics>): Evaluation_Metrics {
    const message = createBaseEvaluation_Metrics();
    message.precision = object.precision ?? 0;
    message.recall = object.recall ?? 0;
    message.f1Score = object.f1Score ?? 0;
    message.predictedOccurrencesCount = object.predictedOccurrencesCount ?? 0;
    message.groundTruthOccurrencesCount = object.groundTruthOccurrencesCount ?? 0;
    message.predictedDocumentCount = object.predictedDocumentCount ?? 0;
    message.groundTruthDocumentCount = object.groundTruthDocumentCount ?? 0;
    message.truePositivesCount = object.truePositivesCount ?? 0;
    message.falsePositivesCount = object.falsePositivesCount ?? 0;
    message.falseNegativesCount = object.falseNegativesCount ?? 0;
    message.totalDocumentsCount = object.totalDocumentsCount ?? 0;
    return message;
  },
};

function createBaseEvaluation_ConfidenceLevelMetrics(): Evaluation_ConfidenceLevelMetrics {
  return { confidenceLevel: 0, metrics: undefined };
}

export const Evaluation_ConfidenceLevelMetrics: MessageFns<Evaluation_ConfidenceLevelMetrics> = {
  encode(message: Evaluation_ConfidenceLevelMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.confidenceLevel !== 0) {
      writer.uint32(13).float(message.confidenceLevel);
    }
    if (message.metrics !== undefined) {
      Evaluation_Metrics.encode(message.metrics, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Evaluation_ConfidenceLevelMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluation_ConfidenceLevelMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.confidenceLevel = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metrics = Evaluation_Metrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Evaluation_ConfidenceLevelMetrics {
    return {
      confidenceLevel: isSet(object.confidenceLevel) ? globalThis.Number(object.confidenceLevel) : 0,
      metrics: isSet(object.metrics) ? Evaluation_Metrics.fromJSON(object.metrics) : undefined,
    };
  },

  toJSON(message: Evaluation_ConfidenceLevelMetrics): unknown {
    const obj: any = {};
    if (message.confidenceLevel !== 0) {
      obj.confidenceLevel = message.confidenceLevel;
    }
    if (message.metrics !== undefined) {
      obj.metrics = Evaluation_Metrics.toJSON(message.metrics);
    }
    return obj;
  },

  create(base?: DeepPartial<Evaluation_ConfidenceLevelMetrics>): Evaluation_ConfidenceLevelMetrics {
    return Evaluation_ConfidenceLevelMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Evaluation_ConfidenceLevelMetrics>): Evaluation_ConfidenceLevelMetrics {
    const message = createBaseEvaluation_ConfidenceLevelMetrics();
    message.confidenceLevel = object.confidenceLevel ?? 0;
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? Evaluation_Metrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

function createBaseEvaluation_MultiConfidenceMetrics(): Evaluation_MultiConfidenceMetrics {
  return {
    confidenceLevelMetrics: [],
    confidenceLevelMetricsExact: [],
    auprc: 0,
    estimatedCalibrationError: 0,
    auprcExact: 0,
    estimatedCalibrationErrorExact: 0,
    metricsType: 0,
  };
}

export const Evaluation_MultiConfidenceMetrics: MessageFns<Evaluation_MultiConfidenceMetrics> = {
  encode(message: Evaluation_MultiConfidenceMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.confidenceLevelMetrics) {
      Evaluation_ConfidenceLevelMetrics.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.confidenceLevelMetricsExact) {
      Evaluation_ConfidenceLevelMetrics.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.auprc !== 0) {
      writer.uint32(21).float(message.auprc);
    }
    if (message.estimatedCalibrationError !== 0) {
      writer.uint32(29).float(message.estimatedCalibrationError);
    }
    if (message.auprcExact !== 0) {
      writer.uint32(45).float(message.auprcExact);
    }
    if (message.estimatedCalibrationErrorExact !== 0) {
      writer.uint32(53).float(message.estimatedCalibrationErrorExact);
    }
    if (message.metricsType !== 0) {
      writer.uint32(56).int32(message.metricsType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Evaluation_MultiConfidenceMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluation_MultiConfidenceMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.confidenceLevelMetrics.push(Evaluation_ConfidenceLevelMetrics.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.confidenceLevelMetricsExact.push(Evaluation_ConfidenceLevelMetrics.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.auprc = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.estimatedCalibrationError = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.auprcExact = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.estimatedCalibrationErrorExact = reader.float();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.metricsType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Evaluation_MultiConfidenceMetrics {
    return {
      confidenceLevelMetrics: globalThis.Array.isArray(object?.confidenceLevelMetrics)
        ? object.confidenceLevelMetrics.map((e: any) => Evaluation_ConfidenceLevelMetrics.fromJSON(e))
        : [],
      confidenceLevelMetricsExact: globalThis.Array.isArray(object?.confidenceLevelMetricsExact)
        ? object.confidenceLevelMetricsExact.map((e: any) => Evaluation_ConfidenceLevelMetrics.fromJSON(e))
        : [],
      auprc: isSet(object.auprc) ? globalThis.Number(object.auprc) : 0,
      estimatedCalibrationError: isSet(object.estimatedCalibrationError)
        ? globalThis.Number(object.estimatedCalibrationError)
        : 0,
      auprcExact: isSet(object.auprcExact) ? globalThis.Number(object.auprcExact) : 0,
      estimatedCalibrationErrorExact: isSet(object.estimatedCalibrationErrorExact)
        ? globalThis.Number(object.estimatedCalibrationErrorExact)
        : 0,
      metricsType: isSet(object.metricsType)
        ? evaluation_MultiConfidenceMetrics_MetricsTypeFromJSON(object.metricsType)
        : 0,
    };
  },

  toJSON(message: Evaluation_MultiConfidenceMetrics): unknown {
    const obj: any = {};
    if (message.confidenceLevelMetrics?.length) {
      obj.confidenceLevelMetrics = message.confidenceLevelMetrics.map((e) =>
        Evaluation_ConfidenceLevelMetrics.toJSON(e)
      );
    }
    if (message.confidenceLevelMetricsExact?.length) {
      obj.confidenceLevelMetricsExact = message.confidenceLevelMetricsExact.map((e) =>
        Evaluation_ConfidenceLevelMetrics.toJSON(e)
      );
    }
    if (message.auprc !== 0) {
      obj.auprc = message.auprc;
    }
    if (message.estimatedCalibrationError !== 0) {
      obj.estimatedCalibrationError = message.estimatedCalibrationError;
    }
    if (message.auprcExact !== 0) {
      obj.auprcExact = message.auprcExact;
    }
    if (message.estimatedCalibrationErrorExact !== 0) {
      obj.estimatedCalibrationErrorExact = message.estimatedCalibrationErrorExact;
    }
    if (message.metricsType !== 0) {
      obj.metricsType = evaluation_MultiConfidenceMetrics_MetricsTypeToJSON(message.metricsType);
    }
    return obj;
  },

  create(base?: DeepPartial<Evaluation_MultiConfidenceMetrics>): Evaluation_MultiConfidenceMetrics {
    return Evaluation_MultiConfidenceMetrics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Evaluation_MultiConfidenceMetrics>): Evaluation_MultiConfidenceMetrics {
    const message = createBaseEvaluation_MultiConfidenceMetrics();
    message.confidenceLevelMetrics =
      object.confidenceLevelMetrics?.map((e) => Evaluation_ConfidenceLevelMetrics.fromPartial(e)) || [];
    message.confidenceLevelMetricsExact =
      object.confidenceLevelMetricsExact?.map((e) => Evaluation_ConfidenceLevelMetrics.fromPartial(e)) || [];
    message.auprc = object.auprc ?? 0;
    message.estimatedCalibrationError = object.estimatedCalibrationError ?? 0;
    message.auprcExact = object.auprcExact ?? 0;
    message.estimatedCalibrationErrorExact = object.estimatedCalibrationErrorExact ?? 0;
    message.metricsType = object.metricsType ?? 0;
    return message;
  },
};

function createBaseEvaluation_EntityMetricsEntry(): Evaluation_EntityMetricsEntry {
  return { key: "", value: undefined };
}

export const Evaluation_EntityMetricsEntry: MessageFns<Evaluation_EntityMetricsEntry> = {
  encode(message: Evaluation_EntityMetricsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Evaluation_MultiConfidenceMetrics.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Evaluation_EntityMetricsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluation_EntityMetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Evaluation_MultiConfidenceMetrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Evaluation_EntityMetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Evaluation_MultiConfidenceMetrics.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Evaluation_EntityMetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Evaluation_MultiConfidenceMetrics.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Evaluation_EntityMetricsEntry>): Evaluation_EntityMetricsEntry {
    return Evaluation_EntityMetricsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Evaluation_EntityMetricsEntry>): Evaluation_EntityMetricsEntry {
    const message = createBaseEvaluation_EntityMetricsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Evaluation_MultiConfidenceMetrics.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
