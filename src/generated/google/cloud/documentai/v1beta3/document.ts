// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/documentai/v1beta3/document.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { Color } from "../../../type/color.js";
import { DateMessage } from "../../../type/date.js";
import { DateTime } from "../../../type/datetime.js";
import { Money } from "../../../type/money.js";
import { PostalAddress } from "../../../type/postal_address.js";
import { Barcode } from "./barcode.js";
import { BoundingPoly } from "./geometry.js";

export const protobufPackage = "google.cloud.documentai.v1beta3";

/**
 * Document represents the canonical document resource in Document AI. It is an
 * interchange format that provides insights into documents and allows for
 * collaboration between users and Document AI to iterate and optimize for
 * quality.
 */
export interface Document {
  /**
   * Optional. Currently supports Google Cloud Storage URI of the form
   * `gs://bucket_name/object_name`. Object versioning is not supported.
   * For more information, refer to [Google Cloud Storage Request
   * URIs](https://cloud.google.com/storage/docs/reference-uris).
   */
  uri?:
    | string
    | undefined;
  /**
   * Optional. Inline document content, represented as a stream of bytes.
   * Note: As with all `bytes` fields, protobuffers use a pure binary
   * representation, whereas JSON representations use base64.
   */
  content?:
    | Buffer
    | undefined;
  /**
   * An IANA published [media type (MIME
   * type)](https://www.iana.org/assignments/media-types/media-types.xhtml).
   */
  mimeType: string;
  /** Optional. UTF-8 encoded text in reading order from the document. */
  text: string;
  /**
   * Styles for the
   * [Document.text][google.cloud.documentai.v1beta3.Document.text].
   *
   * @deprecated
   */
  textStyles: Document_Style[];
  /**
   * Visual page layout for the
   * [Document][google.cloud.documentai.v1beta3.Document].
   */
  pages: Document_Page[];
  /**
   * A list of entities detected on
   * [Document.text][google.cloud.documentai.v1beta3.Document.text]. For
   * document shards, entities in this list may cross shard boundaries.
   */
  entities: Document_Entity[];
  /**
   * Placeholder.  Relationship among
   * [Document.entities][google.cloud.documentai.v1beta3.Document.entities].
   */
  entityRelations: Document_EntityRelation[];
  /**
   * Placeholder.  A list of text corrections made to
   * [Document.text][google.cloud.documentai.v1beta3.Document.text].  This is
   * usually used for annotating corrections to OCR mistakes.  Text changes for
   * a given revision may not overlap with each other.
   */
  textChanges: Document_TextChange[];
  /**
   * Information about the sharding if this document is sharded part of a larger
   * document. If the document is not sharded, this message is not specified.
   */
  shardInfo:
    | Document_ShardInfo
    | undefined;
  /** Any error that occurred while processing this document. */
  error:
    | Status
    | undefined;
  /** Placeholder. Revision history of this document. */
  revisions: Document_Revision[];
  /** Parsed layout of the document. */
  documentLayout:
    | Document_DocumentLayout
    | undefined;
  /** Document chunked based on chunking config. */
  chunkedDocument: Document_ChunkedDocument | undefined;
}

/**
 * For a large document, sharding may be performed to produce several
 * document shards. Each document shard contains this field to detail which
 * shard it is.
 */
export interface Document_ShardInfo {
  /** The 0-based index of this shard. */
  shardIndex: Long;
  /** Total number of shards. */
  shardCount: Long;
  /**
   * The index of the first character in
   * [Document.text][google.cloud.documentai.v1beta3.Document.text] in the
   * overall document global text.
   */
  textOffset: Long;
}

/**
 * Annotation for common text style attributes. This adheres to CSS
 * conventions as much as possible.
 */
export interface Document_Style {
  /**
   * Text anchor indexing into the
   * [Document.text][google.cloud.documentai.v1beta3.Document.text].
   */
  textAnchor:
    | Document_TextAnchor
    | undefined;
  /** Text color. */
  color:
    | Color
    | undefined;
  /** Text background color. */
  backgroundColor:
    | Color
    | undefined;
  /**
   * [Font weight](https://www.w3schools.com/cssref/pr_font_weight.asp).
   * Possible values are `normal`, `bold`, `bolder`, and `lighter`.
   */
  fontWeight: string;
  /**
   * [Text style](https://www.w3schools.com/cssref/pr_font_font-style.asp).
   * Possible values are `normal`, `italic`, and `oblique`.
   */
  textStyle: string;
  /**
   * [Text
   * decoration](https://www.w3schools.com/cssref/pr_text_text-decoration.asp).
   * Follows CSS standard. <text-decoration-line> <text-decoration-color>
   * <text-decoration-style>
   */
  textDecoration: string;
  /** Font size. */
  fontSize:
    | Document_Style_FontSize
    | undefined;
  /**
   * Font family such as `Arial`, `Times New Roman`.
   * https://www.w3schools.com/cssref/pr_font_font-family.asp
   */
  fontFamily: string;
}

/** Font size with unit. */
export interface Document_Style_FontSize {
  /** Font size for the text. */
  size: number;
  /**
   * Unit for the font size. Follows CSS naming (such as `in`, `px`, and
   * `pt`).
   */
  unit: string;
}

/** A page in a [Document][google.cloud.documentai.v1beta3.Document]. */
export interface Document_Page {
  /**
   * 1-based index for current
   * [Page][google.cloud.documentai.v1beta3.Document.Page] in a parent
   * [Document][google.cloud.documentai.v1beta3.Document]. Useful when a page
   * is taken out of a [Document][google.cloud.documentai.v1beta3.Document]
   * for individual processing.
   */
  pageNumber: number;
  /**
   * Rendered image for this page. This image is preprocessed to remove any
   * skew, rotation, and distortions such that the annotation bounding boxes
   * can be upright and axis-aligned.
   */
  image:
    | Document_Page_Image
    | undefined;
  /**
   * Transformation matrices that were applied to the original document image
   * to produce
   * [Page.image][google.cloud.documentai.v1beta3.Document.Page.image].
   */
  transforms: Document_Page_Matrix[];
  /** Physical dimension of the page. */
  dimension:
    | Document_Page_Dimension
    | undefined;
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for the
   * page.
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
  /**
   * A list of visually detected text blocks on the page.
   * A block has a set of lines (collected into paragraphs) that have a common
   * line-spacing and orientation.
   */
  blocks: Document_Page_Block[];
  /**
   * A list of visually detected text paragraphs on the page.
   * A collection of lines that a human would perceive as a paragraph.
   */
  paragraphs: Document_Page_Paragraph[];
  /**
   * A list of visually detected text lines on the page.
   * A collection of tokens that a human would perceive as a line.
   */
  lines: Document_Page_Line[];
  /** A list of visually detected tokens on the page. */
  tokens: Document_Page_Token[];
  /**
   * A list of detected non-text visual elements e.g. checkbox,
   * signature etc. on the page.
   */
  visualElements: Document_Page_VisualElement[];
  /** A list of visually detected tables on the page. */
  tables: Document_Page_Table[];
  /** A list of visually detected form fields on the page. */
  formFields: Document_Page_FormField[];
  /** A list of visually detected symbols on the page. */
  symbols: Document_Page_Symbol[];
  /** A list of detected barcodes. */
  detectedBarcodes: Document_Page_DetectedBarcode[];
  /** Image quality scores. */
  imageQualityScores:
    | Document_Page_ImageQualityScores
    | undefined;
  /**
   * The history of this page.
   *
   * @deprecated
   */
  provenance: Document_Provenance | undefined;
}

/** Dimension for the page. */
export interface Document_Page_Dimension {
  /** Page width. */
  width: number;
  /** Page height. */
  height: number;
  /** Dimension unit. */
  unit: string;
}

/** Rendered image contents for this page. */
export interface Document_Page_Image {
  /** Raw byte content of the image. */
  content: Buffer;
  /**
   * Encoding [media type (MIME
   * type)](https://www.iana.org/assignments/media-types/media-types.xhtml)
   * for the image.
   */
  mimeType: string;
  /** Width of the image in pixels. */
  width: number;
  /** Height of the image in pixels. */
  height: number;
}

/**
 * Representation for transformation matrix, intended to be compatible and
 * used with OpenCV format for image manipulation.
 */
export interface Document_Page_Matrix {
  /** Number of rows in the matrix. */
  rows: number;
  /** Number of columns in the matrix. */
  cols: number;
  /**
   * This encodes information about what data type the matrix uses.
   * For example, 0 (CV_8U) is an unsigned 8-bit image. For the full list
   * of OpenCV primitive data types, please refer to
   * https://docs.opencv.org/4.3.0/d1/d1b/group__core__hal__interface.html
   */
  type: number;
  /** The matrix data. */
  data: Buffer;
}

/** Visual element describing a layout unit on a page. */
export interface Document_Page_Layout {
  /**
   * Text anchor indexing into the
   * [Document.text][google.cloud.documentai.v1beta3.Document.text].
   */
  textAnchor:
    | Document_TextAnchor
    | undefined;
  /**
   * Confidence of the current
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] within
   * context of the object this layout is for. e.g. confidence can be for a
   * single token, a table, a visual element, etc. depending on context.
   * Range `[0, 1]`.
   */
  confidence: number;
  /**
   * The bounding polygon for the
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout].
   */
  boundingPoly:
    | BoundingPoly
    | undefined;
  /**
   * Detected orientation for the
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout].
   */
  orientation: Document_Page_Layout_Orientation;
}

/** Detected human reading orientation. */
export enum Document_Page_Layout_Orientation {
  /** ORIENTATION_UNSPECIFIED - Unspecified orientation. */
  ORIENTATION_UNSPECIFIED = 0,
  /** PAGE_UP - Orientation is aligned with page up. */
  PAGE_UP = 1,
  /**
   * PAGE_RIGHT - Orientation is aligned with page right.
   * Turn the head 90 degrees clockwise from upright to read.
   */
  PAGE_RIGHT = 2,
  /**
   * PAGE_DOWN - Orientation is aligned with page down.
   * Turn the head 180 degrees from upright to read.
   */
  PAGE_DOWN = 3,
  /**
   * PAGE_LEFT - Orientation is aligned with page left.
   * Turn the head 90 degrees counterclockwise from upright to read.
   */
  PAGE_LEFT = 4,
  UNRECOGNIZED = -1,
}

export function document_Page_Layout_OrientationFromJSON(object: any): Document_Page_Layout_Orientation {
  switch (object) {
    case 0:
    case "ORIENTATION_UNSPECIFIED":
      return Document_Page_Layout_Orientation.ORIENTATION_UNSPECIFIED;
    case 1:
    case "PAGE_UP":
      return Document_Page_Layout_Orientation.PAGE_UP;
    case 2:
    case "PAGE_RIGHT":
      return Document_Page_Layout_Orientation.PAGE_RIGHT;
    case 3:
    case "PAGE_DOWN":
      return Document_Page_Layout_Orientation.PAGE_DOWN;
    case 4:
    case "PAGE_LEFT":
      return Document_Page_Layout_Orientation.PAGE_LEFT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Document_Page_Layout_Orientation.UNRECOGNIZED;
  }
}

export function document_Page_Layout_OrientationToJSON(object: Document_Page_Layout_Orientation): string {
  switch (object) {
    case Document_Page_Layout_Orientation.ORIENTATION_UNSPECIFIED:
      return "ORIENTATION_UNSPECIFIED";
    case Document_Page_Layout_Orientation.PAGE_UP:
      return "PAGE_UP";
    case Document_Page_Layout_Orientation.PAGE_RIGHT:
      return "PAGE_RIGHT";
    case Document_Page_Layout_Orientation.PAGE_DOWN:
      return "PAGE_DOWN";
    case Document_Page_Layout_Orientation.PAGE_LEFT:
      return "PAGE_LEFT";
    case Document_Page_Layout_Orientation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A block has a set of lines (collected into paragraphs) that have a
 * common line-spacing and orientation.
 */
export interface Document_Page_Block {
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for
   * [Block][google.cloud.documentai.v1beta3.Document.Page.Block].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
  /**
   * The history of this annotation.
   *
   * @deprecated
   */
  provenance: Document_Provenance | undefined;
}

/** A collection of lines that a human would perceive as a paragraph. */
export interface Document_Page_Paragraph {
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for
   * [Paragraph][google.cloud.documentai.v1beta3.Document.Page.Paragraph].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
  /**
   * The  history of this annotation.
   *
   * @deprecated
   */
  provenance: Document_Provenance | undefined;
}

/**
 * A collection of tokens that a human would perceive as a line.
 * Does not cross column boundaries, can be horizontal, vertical, etc.
 */
export interface Document_Page_Line {
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for
   * [Line][google.cloud.documentai.v1beta3.Document.Page.Line].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
  /**
   * The  history of this annotation.
   *
   * @deprecated
   */
  provenance: Document_Provenance | undefined;
}

/** A detected token. */
export interface Document_Page_Token {
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for
   * [Token][google.cloud.documentai.v1beta3.Document.Page.Token].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /**
   * Detected break at the end of a
   * [Token][google.cloud.documentai.v1beta3.Document.Page.Token].
   */
  detectedBreak:
    | Document_Page_Token_DetectedBreak
    | undefined;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
  /**
   * The history of this annotation.
   *
   * @deprecated
   */
  provenance:
    | Document_Provenance
    | undefined;
  /** Text style attributes. */
  styleInfo: Document_Page_Token_StyleInfo | undefined;
}

/**
 * Detected break at the end of a
 * [Token][google.cloud.documentai.v1beta3.Document.Page.Token].
 */
export interface Document_Page_Token_DetectedBreak {
  /** Detected break type. */
  type: Document_Page_Token_DetectedBreak_Type;
}

/** Enum to denote the type of break found. */
export enum Document_Page_Token_DetectedBreak_Type {
  /** TYPE_UNSPECIFIED - Unspecified break type. */
  TYPE_UNSPECIFIED = 0,
  /** SPACE - A single whitespace. */
  SPACE = 1,
  /** WIDE_SPACE - A wider whitespace. */
  WIDE_SPACE = 2,
  /** HYPHEN - A hyphen that indicates that a token has been split across lines. */
  HYPHEN = 3,
  UNRECOGNIZED = -1,
}

export function document_Page_Token_DetectedBreak_TypeFromJSON(object: any): Document_Page_Token_DetectedBreak_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Document_Page_Token_DetectedBreak_Type.TYPE_UNSPECIFIED;
    case 1:
    case "SPACE":
      return Document_Page_Token_DetectedBreak_Type.SPACE;
    case 2:
    case "WIDE_SPACE":
      return Document_Page_Token_DetectedBreak_Type.WIDE_SPACE;
    case 3:
    case "HYPHEN":
      return Document_Page_Token_DetectedBreak_Type.HYPHEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Document_Page_Token_DetectedBreak_Type.UNRECOGNIZED;
  }
}

export function document_Page_Token_DetectedBreak_TypeToJSON(object: Document_Page_Token_DetectedBreak_Type): string {
  switch (object) {
    case Document_Page_Token_DetectedBreak_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Document_Page_Token_DetectedBreak_Type.SPACE:
      return "SPACE";
    case Document_Page_Token_DetectedBreak_Type.WIDE_SPACE:
      return "WIDE_SPACE";
    case Document_Page_Token_DetectedBreak_Type.HYPHEN:
      return "HYPHEN";
    case Document_Page_Token_DetectedBreak_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Font and other text style attributes. */
export interface Document_Page_Token_StyleInfo {
  /** Font size in points (`1` point is `¹⁄₇₂` inches). */
  fontSize: number;
  /**
   * Font size in pixels, equal to _unrounded
   * [font_size][google.cloud.documentai.v1beta3.Document.Page.Token.StyleInfo.font_size]_
   * * _resolution_ ÷ `72.0`.
   */
  pixelFontSize: number;
  /** Letter spacing in points. */
  letterSpacing: number;
  /** Name or style of the font. */
  fontType: string;
  /**
   * Whether the text is bold (equivalent to
   * [font_weight][google.cloud.documentai.v1beta3.Document.Page.Token.StyleInfo.font_weight]
   * is at least `700`).
   */
  bold: boolean;
  /** Whether the text is italic. */
  italic: boolean;
  /** Whether the text is underlined. */
  underlined: boolean;
  /** Whether the text is strikethrough. This feature is not supported yet. */
  strikeout: boolean;
  /** Whether the text is a subscript. This feature is not supported yet. */
  subscript: boolean;
  /** Whether the text is a superscript. This feature is not supported yet. */
  superscript: boolean;
  /** Whether the text is in small caps. This feature is not supported yet. */
  smallcaps: boolean;
  /**
   * TrueType weight on a scale `100` (thin) to `1000` (ultra-heavy).
   * Normal is `400`, bold is `700`.
   */
  fontWeight: number;
  /** Whether the text is handwritten. */
  handwritten: boolean;
  /** Color of the text. */
  textColor:
    | Color
    | undefined;
  /** Color of the background. */
  backgroundColor: Color | undefined;
}

/** A detected symbol. */
export interface Document_Page_Symbol {
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for
   * [Symbol][google.cloud.documentai.v1beta3.Document.Page.Symbol].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
}

/**
 * Detected non-text visual elements e.g. checkbox, signature etc. on the
 * page.
 */
export interface Document_Page_VisualElement {
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for
   * [VisualElement][google.cloud.documentai.v1beta3.Document.Page.VisualElement].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /**
   * Type of the
   * [VisualElement][google.cloud.documentai.v1beta3.Document.Page.VisualElement].
   */
  type: string;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
}

/** A table representation similar to HTML table structure. */
export interface Document_Page_Table {
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for
   * [Table][google.cloud.documentai.v1beta3.Document.Page.Table].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** Header rows of the table. */
  headerRows: Document_Page_Table_TableRow[];
  /** Body rows of the table. */
  bodyRows: Document_Page_Table_TableRow[];
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
  /**
   * The history of this table.
   *
   * @deprecated
   */
  provenance: Document_Provenance | undefined;
}

/** A row of table cells. */
export interface Document_Page_Table_TableRow {
  /** Cells that make up this row. */
  cells: Document_Page_Table_TableCell[];
}

/** A cell representation inside the table. */
export interface Document_Page_Table_TableCell {
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for
   * [TableCell][google.cloud.documentai.v1beta3.Document.Page.Table.TableCell].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** How many rows this cell spans. */
  rowSpan: number;
  /** How many columns this cell spans. */
  colSpan: number;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
}

/** A form field detected on the page. */
export interface Document_Page_FormField {
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for the
   * [FormField][google.cloud.documentai.v1beta3.Document.Page.FormField]
   * name. e.g. `Address`, `Email`, `Grand total`, `Phone number`, etc.
   */
  fieldName:
    | Document_Page_Layout
    | undefined;
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for the
   * [FormField][google.cloud.documentai.v1beta3.Document.Page.FormField]
   * value.
   */
  fieldValue:
    | Document_Page_Layout
    | undefined;
  /** A list of detected languages for name together with confidence. */
  nameDetectedLanguages: Document_Page_DetectedLanguage[];
  /** A list of detected languages for value together with confidence. */
  valueDetectedLanguages: Document_Page_DetectedLanguage[];
  /**
   * If the value is non-textual, this field represents the type. Current
   * valid values are:
   *
   * - blank (this indicates the `field_value` is normal text)
   * - `unfilled_checkbox`
   * - `filled_checkbox`
   */
  valueType: string;
  /**
   * Created for Labeling UI to export key text.
   * If corrections were made to the text identified by the
   * `field_name.text_anchor`, this field will contain the correction.
   */
  correctedKeyText: string;
  /**
   * Created for Labeling UI to export value text.
   * If corrections were made to the text identified by the
   * `field_value.text_anchor`, this field will contain the correction.
   */
  correctedValueText: string;
  /** The history of this annotation. */
  provenance: Document_Provenance | undefined;
}

/** A detected barcode. */
export interface Document_Page_DetectedBarcode {
  /**
   * [Layout][google.cloud.documentai.v1beta3.Document.Page.Layout] for
   * [DetectedBarcode][google.cloud.documentai.v1beta3.Document.Page.DetectedBarcode].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /**
   * Detailed barcode information of the
   * [DetectedBarcode][google.cloud.documentai.v1beta3.Document.Page.DetectedBarcode].
   */
  barcode: Barcode | undefined;
}

/** Detected language for a structural component. */
export interface Document_Page_DetectedLanguage {
  /**
   * The [BCP-47 language
   * code](https://www.unicode.org/reports/tr35/#Unicode_locale_identifier),
   * such as `en-US` or `sr-Latn`.
   */
  languageCode: string;
  /** Confidence of detected language. Range `[0, 1]`. */
  confidence: number;
}

/** Image quality scores for the page image. */
export interface Document_Page_ImageQualityScores {
  /** The overall quality score. Range `[0, 1]` where `1` is perfect quality. */
  qualityScore: number;
  /** A list of detected defects. */
  detectedDefects: Document_Page_ImageQualityScores_DetectedDefect[];
}

/** Image Quality Defects */
export interface Document_Page_ImageQualityScores_DetectedDefect {
  /**
   * Name of the defect type. Supported values are:
   *
   * - `quality/defect_blurry`
   * - `quality/defect_noisy`
   * - `quality/defect_dark`
   * - `quality/defect_faint`
   * - `quality/defect_text_too_small`
   * - `quality/defect_document_cutoff`
   * - `quality/defect_text_cutoff`
   * - `quality/defect_glare`
   */
  type: string;
  /**
   * Confidence of detected defect. Range `[0, 1]` where `1` indicates
   * strong confidence that the defect exists.
   */
  confidence: number;
}

/**
 * An entity that could be a phrase in the text or a property that belongs to
 * the document. It is a known entity type, such as a person, an organization,
 * or location.
 */
export interface Document_Entity {
  /**
   * Optional. Provenance of the entity.
   * Text anchor indexing into the
   * [Document.text][google.cloud.documentai.v1beta3.Document.text].
   */
  textAnchor:
    | Document_TextAnchor
    | undefined;
  /** Required. Entity type from a schema e.g. `Address`. */
  type: string;
  /** Optional. Text value of the entity e.g. `1600 Amphitheatre Pkwy`. */
  mentionText: string;
  /** Optional. Deprecated.  Use `id` field instead. */
  mentionId: string;
  /** Optional. Confidence of detected Schema entity. Range `[0, 1]`. */
  confidence: number;
  /**
   * Optional. Represents the provenance of this entity wrt. the location on
   * the page where it was found.
   */
  pageAnchor:
    | Document_PageAnchor
    | undefined;
  /**
   * Optional. Canonical id. This will be a unique value in the entity list
   * for this document.
   */
  id: string;
  /**
   * Optional. Normalized entity value. Absent if the extracted value could
   * not be converted or the type (e.g. address) is not supported for certain
   * parsers. This field is also only populated for certain supported document
   * types.
   */
  normalizedValue:
    | Document_Entity_NormalizedValue
    | undefined;
  /**
   * Optional. Entities can be nested to form a hierarchical data structure
   * representing the content in the document.
   */
  properties: Document_Entity[];
  /** Optional. The history of this annotation. */
  provenance:
    | Document_Provenance
    | undefined;
  /**
   * Optional. Whether the entity will be redacted for de-identification
   * purposes.
   */
  redacted: boolean;
}

/** Parsed and normalized entity value. */
export interface Document_Entity_NormalizedValue {
  /**
   * Money value. See also:
   * https://github.com/googleapis/googleapis/blob/master/google/type/money.proto
   */
  moneyValue?:
    | Money
    | undefined;
  /**
   * Date value. Includes year, month, day. See also:
   * https://github.com/googleapis/googleapis/blob/master/google/type/date.proto
   */
  dateValue?:
    | DateMessage
    | undefined;
  /**
   * DateTime value. Includes date, time, and timezone. See also:
   * https://github.com/googleapis/googleapis/blob/master/google/type/datetime.proto
   */
  datetimeValue?:
    | DateTime
    | undefined;
  /**
   * Postal address. See also:
   * https://github.com/googleapis/googleapis/blob/master/google/type/postal_address.proto
   */
  addressValue?:
    | PostalAddress
    | undefined;
  /**
   * Boolean value. Can be used for entities with binary values, or for
   * checkboxes.
   */
  booleanValue?:
    | boolean
    | undefined;
  /** Integer value. */
  integerValue?:
    | number
    | undefined;
  /** Float value. */
  floatValue?:
    | number
    | undefined;
  /**
   * Optional. An optional field to store a normalized string.
   * For some entity types, one of respective `structured_value` fields may
   * also be populated. Also not all the types of `structured_value` will be
   * normalized. For example, some processors may not generate `float`
   * or `integer` normalized text by default.
   *
   * Below are sample formats mapped to structured values.
   *
   * - Money/Currency type (`money_value`) is in the ISO 4217 text format.
   * - Date type (`date_value`) is in the ISO 8601 text format.
   * - Datetime type (`datetime_value`) is in the ISO 8601 text format.
   */
  text: string;
}

/**
 * Relationship between
 * [Entities][google.cloud.documentai.v1beta3.Document.Entity].
 */
export interface Document_EntityRelation {
  /** Subject entity id. */
  subjectId: string;
  /** Object entity id. */
  objectId: string;
  /** Relationship description. */
  relation: string;
}

/**
 * Text reference indexing into the
 * [Document.text][google.cloud.documentai.v1beta3.Document.text].
 */
export interface Document_TextAnchor {
  /**
   * The text segments from the
   * [Document.text][google.cloud.documentai.v1beta3.Document.text].
   */
  textSegments: Document_TextAnchor_TextSegment[];
  /**
   * Contains the content of the text span so that users do
   * not have to look it up in the text_segments.  It is always
   * populated for formFields.
   */
  content: string;
}

/**
 * A text segment in the
 * [Document.text][google.cloud.documentai.v1beta3.Document.text]. The
 * indices may be out of bounds which indicate that the text extends into
 * another document shard for large sharded documents. See
 * [ShardInfo.text_offset][google.cloud.documentai.v1beta3.Document.ShardInfo.text_offset]
 */
export interface Document_TextAnchor_TextSegment {
  /**
   * [TextSegment][google.cloud.documentai.v1beta3.Document.TextAnchor.TextSegment]
   * start UTF-8 char index in the
   * [Document.text][google.cloud.documentai.v1beta3.Document.text].
   */
  startIndex: Long;
  /**
   * [TextSegment][google.cloud.documentai.v1beta3.Document.TextAnchor.TextSegment]
   * half open end UTF-8 char index in the
   * [Document.text][google.cloud.documentai.v1beta3.Document.text].
   */
  endIndex: Long;
}

/**
 * Referencing the visual context of the entity in the
 * [Document.pages][google.cloud.documentai.v1beta3.Document.pages]. Page
 * anchors can be cross-page, consist of multiple bounding polygons and
 * optionally reference specific layout element types.
 */
export interface Document_PageAnchor {
  /** One or more references to visual page elements */
  pageRefs: Document_PageAnchor_PageRef[];
}

/** Represents a weak reference to a page element within a document. */
export interface Document_PageAnchor_PageRef {
  /**
   * Required. Index into the
   * [Document.pages][google.cloud.documentai.v1beta3.Document.pages]
   * element, for example using
   * `[Document.pages][page_refs.page]` to locate the related page element.
   * This field is skipped when its value is the default `0`. See
   * https://developers.google.com/protocol-buffers/docs/proto3#json.
   */
  page: Long;
  /**
   * Optional. The type of the layout element that is being referenced if
   * any.
   */
  layoutType: Document_PageAnchor_PageRef_LayoutType;
  /**
   * Optional. Deprecated.  Use
   * [PageRef.bounding_poly][google.cloud.documentai.v1beta3.Document.PageAnchor.PageRef.bounding_poly]
   * instead.
   *
   * @deprecated
   */
  layoutId: string;
  /**
   * Optional. Identifies the bounding polygon of a layout element on the
   * page. If `layout_type` is set, the bounding polygon must be exactly the
   * same to the layout element it's referring to.
   */
  boundingPoly:
    | BoundingPoly
    | undefined;
  /**
   * Optional. Confidence of detected page element, if applicable. Range
   * `[0, 1]`.
   */
  confidence: number;
}

/** The type of layout that is being referenced. */
export enum Document_PageAnchor_PageRef_LayoutType {
  /** LAYOUT_TYPE_UNSPECIFIED - Layout Unspecified. */
  LAYOUT_TYPE_UNSPECIFIED = 0,
  /**
   * BLOCK - References a
   * [Page.blocks][google.cloud.documentai.v1beta3.Document.Page.blocks]
   * element.
   */
  BLOCK = 1,
  /**
   * PARAGRAPH - References a
   * [Page.paragraphs][google.cloud.documentai.v1beta3.Document.Page.paragraphs]
   * element.
   */
  PARAGRAPH = 2,
  /**
   * LINE - References a
   * [Page.lines][google.cloud.documentai.v1beta3.Document.Page.lines]
   * element.
   */
  LINE = 3,
  /**
   * TOKEN - References a
   * [Page.tokens][google.cloud.documentai.v1beta3.Document.Page.tokens]
   * element.
   */
  TOKEN = 4,
  /**
   * VISUAL_ELEMENT - References a
   * [Page.visual_elements][google.cloud.documentai.v1beta3.Document.Page.visual_elements]
   * element.
   */
  VISUAL_ELEMENT = 5,
  /**
   * TABLE - Refrrences a
   * [Page.tables][google.cloud.documentai.v1beta3.Document.Page.tables]
   * element.
   */
  TABLE = 6,
  /**
   * FORM_FIELD - References a
   * [Page.form_fields][google.cloud.documentai.v1beta3.Document.Page.form_fields]
   * element.
   */
  FORM_FIELD = 7,
  UNRECOGNIZED = -1,
}

export function document_PageAnchor_PageRef_LayoutTypeFromJSON(object: any): Document_PageAnchor_PageRef_LayoutType {
  switch (object) {
    case 0:
    case "LAYOUT_TYPE_UNSPECIFIED":
      return Document_PageAnchor_PageRef_LayoutType.LAYOUT_TYPE_UNSPECIFIED;
    case 1:
    case "BLOCK":
      return Document_PageAnchor_PageRef_LayoutType.BLOCK;
    case 2:
    case "PARAGRAPH":
      return Document_PageAnchor_PageRef_LayoutType.PARAGRAPH;
    case 3:
    case "LINE":
      return Document_PageAnchor_PageRef_LayoutType.LINE;
    case 4:
    case "TOKEN":
      return Document_PageAnchor_PageRef_LayoutType.TOKEN;
    case 5:
    case "VISUAL_ELEMENT":
      return Document_PageAnchor_PageRef_LayoutType.VISUAL_ELEMENT;
    case 6:
    case "TABLE":
      return Document_PageAnchor_PageRef_LayoutType.TABLE;
    case 7:
    case "FORM_FIELD":
      return Document_PageAnchor_PageRef_LayoutType.FORM_FIELD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Document_PageAnchor_PageRef_LayoutType.UNRECOGNIZED;
  }
}

export function document_PageAnchor_PageRef_LayoutTypeToJSON(object: Document_PageAnchor_PageRef_LayoutType): string {
  switch (object) {
    case Document_PageAnchor_PageRef_LayoutType.LAYOUT_TYPE_UNSPECIFIED:
      return "LAYOUT_TYPE_UNSPECIFIED";
    case Document_PageAnchor_PageRef_LayoutType.BLOCK:
      return "BLOCK";
    case Document_PageAnchor_PageRef_LayoutType.PARAGRAPH:
      return "PARAGRAPH";
    case Document_PageAnchor_PageRef_LayoutType.LINE:
      return "LINE";
    case Document_PageAnchor_PageRef_LayoutType.TOKEN:
      return "TOKEN";
    case Document_PageAnchor_PageRef_LayoutType.VISUAL_ELEMENT:
      return "VISUAL_ELEMENT";
    case Document_PageAnchor_PageRef_LayoutType.TABLE:
      return "TABLE";
    case Document_PageAnchor_PageRef_LayoutType.FORM_FIELD:
      return "FORM_FIELD";
    case Document_PageAnchor_PageRef_LayoutType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Structure to identify provenance relationships between annotations in
 * different revisions.
 */
export interface Document_Provenance {
  /**
   * The index of the revision that produced this element.
   *
   * @deprecated
   */
  revision: number;
  /**
   * The Id of this operation.  Needs to be unique within the scope of the
   * revision.
   *
   * @deprecated
   */
  id: number;
  /** References to the original elements that are replaced. */
  parents: Document_Provenance_Parent[];
  /** The type of provenance operation. */
  type: Document_Provenance_OperationType;
}

/** If a processor or agent does an explicit operation on existing elements. */
export enum Document_Provenance_OperationType {
  /**
   * OPERATION_TYPE_UNSPECIFIED - Operation type unspecified. If no operation is specified a provenance
   * entry is simply used to match against a `parent`.
   */
  OPERATION_TYPE_UNSPECIFIED = 0,
  /** ADD - Add an element. */
  ADD = 1,
  /** REMOVE - Remove an element identified by `parent`. */
  REMOVE = 2,
  /**
   * UPDATE - Updates any fields within the given provenance scope of the message. It
   * overwrites the fields rather than replacing them.  Use this when you
   * want to update a field value of an entity without also updating all the
   * child properties.
   */
  UPDATE = 7,
  /** REPLACE - Currently unused. Replace an element identified by `parent`. */
  REPLACE = 3,
  /**
   * EVAL_REQUESTED - Deprecated. Request human review for the element identified by
   * `parent`.
   *
   * @deprecated
   */
  EVAL_REQUESTED = 4,
  /**
   * EVAL_APPROVED - Deprecated. Element is reviewed and approved at human review,
   * confidence will be set to 1.0.
   *
   * @deprecated
   */
  EVAL_APPROVED = 5,
  /**
   * EVAL_SKIPPED - Deprecated. Element is skipped in the validation process.
   *
   * @deprecated
   */
  EVAL_SKIPPED = 6,
  UNRECOGNIZED = -1,
}

export function document_Provenance_OperationTypeFromJSON(object: any): Document_Provenance_OperationType {
  switch (object) {
    case 0:
    case "OPERATION_TYPE_UNSPECIFIED":
      return Document_Provenance_OperationType.OPERATION_TYPE_UNSPECIFIED;
    case 1:
    case "ADD":
      return Document_Provenance_OperationType.ADD;
    case 2:
    case "REMOVE":
      return Document_Provenance_OperationType.REMOVE;
    case 7:
    case "UPDATE":
      return Document_Provenance_OperationType.UPDATE;
    case 3:
    case "REPLACE":
      return Document_Provenance_OperationType.REPLACE;
    case 4:
    case "EVAL_REQUESTED":
      return Document_Provenance_OperationType.EVAL_REQUESTED;
    case 5:
    case "EVAL_APPROVED":
      return Document_Provenance_OperationType.EVAL_APPROVED;
    case 6:
    case "EVAL_SKIPPED":
      return Document_Provenance_OperationType.EVAL_SKIPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Document_Provenance_OperationType.UNRECOGNIZED;
  }
}

export function document_Provenance_OperationTypeToJSON(object: Document_Provenance_OperationType): string {
  switch (object) {
    case Document_Provenance_OperationType.OPERATION_TYPE_UNSPECIFIED:
      return "OPERATION_TYPE_UNSPECIFIED";
    case Document_Provenance_OperationType.ADD:
      return "ADD";
    case Document_Provenance_OperationType.REMOVE:
      return "REMOVE";
    case Document_Provenance_OperationType.UPDATE:
      return "UPDATE";
    case Document_Provenance_OperationType.REPLACE:
      return "REPLACE";
    case Document_Provenance_OperationType.EVAL_REQUESTED:
      return "EVAL_REQUESTED";
    case Document_Provenance_OperationType.EVAL_APPROVED:
      return "EVAL_APPROVED";
    case Document_Provenance_OperationType.EVAL_SKIPPED:
      return "EVAL_SKIPPED";
    case Document_Provenance_OperationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The parent element the current element is based on. Used for
 * referencing/aligning, removal and replacement operations.
 */
export interface Document_Provenance_Parent {
  /** The index of the index into current revision's parent_ids list. */
  revision: number;
  /**
   * The index of the parent item in the corresponding item list (eg. list
   * of entities, properties within entities, etc.) in the parent revision.
   */
  index: number;
  /**
   * The id of the parent provenance.
   *
   * @deprecated
   */
  id: number;
}

/** Contains past or forward revisions of this document. */
export interface Document_Revision {
  /**
   * If the change was made by a person specify the name or id of that
   * person.
   */
  agent?:
    | string
    | undefined;
  /**
   * If the annotation was made by processor identify the processor by its
   * resource name.
   */
  processor?:
    | string
    | undefined;
  /**
   * Id of the revision, internally generated by doc proto storage.
   * Unique within the context of the document.
   */
  id: string;
  /**
   * The revisions that this revision is based on.  This can include one or
   * more parent (when documents are merged.)  This field represents the
   * index into the `revisions` field.
   *
   * @deprecated
   */
  parent: number[];
  /**
   * The revisions that this revision is based on. Must include all the ids
   * that have anything to do with this revision - eg. there are
   * `provenance.parent.revision` fields that index into this field.
   */
  parentIds: string[];
  /**
   * The time that the revision was created, internally generated by
   * doc proto storage at the time of create.
   */
  createTime:
    | Date
    | undefined;
  /** Human Review information of this revision. */
  humanReview: Document_Revision_HumanReview | undefined;
}

/** Human Review information of the document. */
export interface Document_Revision_HumanReview {
  /** Human review state. e.g. `requested`, `succeeded`, `rejected`. */
  state: string;
  /**
   * A message providing more details about the current state of processing.
   * For example, the rejection reason when the state is `rejected`.
   */
  stateMessage: string;
}

/** This message is used for text changes aka. OCR corrections. */
export interface Document_TextChange {
  /**
   * Provenance of the correction.
   * Text anchor indexing into the
   * [Document.text][google.cloud.documentai.v1beta3.Document.text].  There
   * can only be a single `TextAnchor.text_segments` element.  If the start
   * and end index of the text segment are the same, the text change is
   * inserted before that index.
   */
  textAnchor:
    | Document_TextAnchor
    | undefined;
  /** The text that replaces the text identified in the `text_anchor`. */
  changedText: string;
  /**
   * The history of this annotation.
   *
   * @deprecated
   */
  provenance: Document_Provenance[];
}

/**
 * Represents the parsed layout of a document as a collection of blocks that
 * the document is divided into.
 */
export interface Document_DocumentLayout {
  /** List of blocks in the document. */
  blocks: Document_DocumentLayout_DocumentLayoutBlock[];
}

/**
 * Represents a block. A block could be one of the various types (text,
 * table, list) supported.
 */
export interface Document_DocumentLayout_DocumentLayoutBlock {
  /** Block consisting of text content. */
  textBlock?:
    | Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock
    | undefined;
  /** Block consisting of table content/structure. */
  tableBlock?:
    | Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock
    | undefined;
  /** Block consisting of list content/structure. */
  listBlock?:
    | Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock
    | undefined;
  /** ID of the block. */
  blockId: string;
  /** Page span of the block. */
  pageSpan: Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan | undefined;
}

/** Represents where the block starts and ends in the document. */
export interface Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan {
  /** Page where block starts in the document. */
  pageStart: number;
  /** Page where block ends in the document. */
  pageEnd: number;
}

/** Represents a text type block. */
export interface Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock {
  /** Text content stored in the block. */
  text: string;
  /**
   * Type of the text in the block. Available options are: `paragraph`,
   * `subtitle`, `heading-1`, `heading-2`, `heading-3`, `heading-4`,
   * `heading-5`, `header`, `footer`.
   */
  type: string;
  /**
   * A text block could further have child blocks.
   * Repeated blocks support further hierarchies and nested blocks.
   */
  blocks: Document_DocumentLayout_DocumentLayoutBlock[];
}

/** Represents a table type block. */
export interface Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock {
  /** Header rows at the top of the table. */
  headerRows: Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow[];
  /** Body rows containing main table content. */
  bodyRows: Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow[];
  /** Table caption/title. */
  caption: string;
}

/** Represents a row in a table. */
export interface Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow {
  /** A table row is a list of table cells. */
  cells: Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell[];
}

/** Represents a cell in a table row. */
export interface Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell {
  /**
   * A table cell is a list of blocks.
   * Repeated blocks support further hierarchies and nested blocks.
   */
  blocks: Document_DocumentLayout_DocumentLayoutBlock[];
  /** How many rows this cell spans. */
  rowSpan: number;
  /** How many columns this cell spans. */
  colSpan: number;
}

/** Represents a list type block. */
export interface Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock {
  /** List entries that constitute a list block. */
  listEntries: Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry[];
  /**
   * Type of the list_entries (if exist). Available options are `ordered`
   * and `unordered`.
   */
  type: string;
}

/** Represents an entry in the list. */
export interface Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry {
  /**
   * A list entry is a list of blocks.
   * Repeated blocks support further hierarchies and nested blocks.
   */
  blocks: Document_DocumentLayout_DocumentLayoutBlock[];
}

/** Represents the chunks that the document is divided into. */
export interface Document_ChunkedDocument {
  /** List of chunks. */
  chunks: Document_ChunkedDocument_Chunk[];
}

/** Represents a chunk. */
export interface Document_ChunkedDocument_Chunk {
  /** ID of the chunk. */
  chunkId: string;
  /** Unused. */
  sourceBlockIds: string[];
  /** Text content of the chunk. */
  content: string;
  /** Page span of the chunk. */
  pageSpan:
    | Document_ChunkedDocument_Chunk_ChunkPageSpan
    | undefined;
  /** Page headers associated with the chunk. */
  pageHeaders: Document_ChunkedDocument_Chunk_ChunkPageHeader[];
  /** Page footers associated with the chunk. */
  pageFooters: Document_ChunkedDocument_Chunk_ChunkPageFooter[];
}

/** Represents where the chunk starts and ends in the document. */
export interface Document_ChunkedDocument_Chunk_ChunkPageSpan {
  /** Page where chunk starts in the document. */
  pageStart: number;
  /** Page where chunk ends in the document. */
  pageEnd: number;
}

/** Represents the page header associated with the chunk. */
export interface Document_ChunkedDocument_Chunk_ChunkPageHeader {
  /** Header in text format. */
  text: string;
  /** Page span of the header. */
  pageSpan: Document_ChunkedDocument_Chunk_ChunkPageSpan | undefined;
}

/** Represents the page footer associated with the chunk. */
export interface Document_ChunkedDocument_Chunk_ChunkPageFooter {
  /** Footer in text format. */
  text: string;
  /** Page span of the footer. */
  pageSpan: Document_ChunkedDocument_Chunk_ChunkPageSpan | undefined;
}

/** The revision reference specifies which revision on the document to read. */
export interface RevisionRef {
  /** Reads the revision by the predefined case. */
  revisionCase?:
    | RevisionRef_RevisionCase
    | undefined;
  /** Reads the revision given by the id. */
  revisionId?:
    | string
    | undefined;
  /**
   * Reads the revision generated by the processor version.
   * The format takes the full resource name of processor version.
   * `projects/{project}/locations/{location}/processors/{processor}/processorVersions/{processorVersion}`
   */
  latestProcessorVersion?: string | undefined;
}

/** Some predefined revision cases. */
export enum RevisionRef_RevisionCase {
  /** REVISION_CASE_UNSPECIFIED - Unspecified case, fall back to read the `LATEST_HUMAN_REVIEW`. */
  REVISION_CASE_UNSPECIFIED = 0,
  /** LATEST_HUMAN_REVIEW - The latest revision made by a human. */
  LATEST_HUMAN_REVIEW = 1,
  /** LATEST_TIMESTAMP - The latest revision based on timestamp. */
  LATEST_TIMESTAMP = 2,
  /** BASE_OCR_REVISION - The first (OCR) revision. */
  BASE_OCR_REVISION = 3,
  UNRECOGNIZED = -1,
}

export function revisionRef_RevisionCaseFromJSON(object: any): RevisionRef_RevisionCase {
  switch (object) {
    case 0:
    case "REVISION_CASE_UNSPECIFIED":
      return RevisionRef_RevisionCase.REVISION_CASE_UNSPECIFIED;
    case 1:
    case "LATEST_HUMAN_REVIEW":
      return RevisionRef_RevisionCase.LATEST_HUMAN_REVIEW;
    case 2:
    case "LATEST_TIMESTAMP":
      return RevisionRef_RevisionCase.LATEST_TIMESTAMP;
    case 3:
    case "BASE_OCR_REVISION":
      return RevisionRef_RevisionCase.BASE_OCR_REVISION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RevisionRef_RevisionCase.UNRECOGNIZED;
  }
}

export function revisionRef_RevisionCaseToJSON(object: RevisionRef_RevisionCase): string {
  switch (object) {
    case RevisionRef_RevisionCase.REVISION_CASE_UNSPECIFIED:
      return "REVISION_CASE_UNSPECIFIED";
    case RevisionRef_RevisionCase.LATEST_HUMAN_REVIEW:
      return "LATEST_HUMAN_REVIEW";
    case RevisionRef_RevisionCase.LATEST_TIMESTAMP:
      return "LATEST_TIMESTAMP";
    case RevisionRef_RevisionCase.BASE_OCR_REVISION:
      return "BASE_OCR_REVISION";
    case RevisionRef_RevisionCase.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseDocument(): Document {
  return {
    uri: undefined,
    content: undefined,
    mimeType: "",
    text: "",
    textStyles: [],
    pages: [],
    entities: [],
    entityRelations: [],
    textChanges: [],
    shardInfo: undefined,
    error: undefined,
    revisions: [],
    documentLayout: undefined,
    chunkedDocument: undefined,
  };
}

export const Document: MessageFns<Document> = {
  encode(message: Document, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== undefined) {
      writer.uint32(10).string(message.uri);
    }
    if (message.content !== undefined) {
      writer.uint32(18).bytes(message.content);
    }
    if (message.mimeType !== "") {
      writer.uint32(26).string(message.mimeType);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    for (const v of message.textStyles) {
      Document_Style.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.pages) {
      Document_Page.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.entities) {
      Document_Entity.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.entityRelations) {
      Document_EntityRelation.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.textChanges) {
      Document_TextChange.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.shardInfo !== undefined) {
      Document_ShardInfo.encode(message.shardInfo, writer.uint32(74).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(82).fork()).join();
    }
    for (const v of message.revisions) {
      Document_Revision.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.documentLayout !== undefined) {
      Document_DocumentLayout.encode(message.documentLayout, writer.uint32(138).fork()).join();
    }
    if (message.chunkedDocument !== undefined) {
      Document_ChunkedDocument.encode(message.chunkedDocument, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.textStyles.push(Document_Style.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pages.push(Document_Page.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.entities.push(Document_Entity.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.entityRelations.push(Document_EntityRelation.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.textChanges.push(Document_TextChange.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.shardInfo = Document_ShardInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.revisions.push(Document_Revision.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.documentLayout = Document_DocumentLayout.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.chunkedDocument = Document_ChunkedDocument.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : undefined,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      textStyles: globalThis.Array.isArray(object?.textStyles)
        ? object.textStyles.map((e: any) => Document_Style.fromJSON(e))
        : [],
      pages: globalThis.Array.isArray(object?.pages) ? object.pages.map((e: any) => Document_Page.fromJSON(e)) : [],
      entities: globalThis.Array.isArray(object?.entities)
        ? object.entities.map((e: any) => Document_Entity.fromJSON(e))
        : [],
      entityRelations: globalThis.Array.isArray(object?.entityRelations)
        ? object.entityRelations.map((e: any) => Document_EntityRelation.fromJSON(e))
        : [],
      textChanges: globalThis.Array.isArray(object?.textChanges)
        ? object.textChanges.map((e: any) => Document_TextChange.fromJSON(e))
        : [],
      shardInfo: isSet(object.shardInfo) ? Document_ShardInfo.fromJSON(object.shardInfo) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      revisions: globalThis.Array.isArray(object?.revisions)
        ? object.revisions.map((e: any) => Document_Revision.fromJSON(e))
        : [],
      documentLayout: isSet(object.documentLayout)
        ? Document_DocumentLayout.fromJSON(object.documentLayout)
        : undefined,
      chunkedDocument: isSet(object.chunkedDocument)
        ? Document_ChunkedDocument.fromJSON(object.chunkedDocument)
        : undefined,
    };
  },

  toJSON(message: Document): unknown {
    const obj: any = {};
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.content !== undefined) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.textStyles?.length) {
      obj.textStyles = message.textStyles.map((e) => Document_Style.toJSON(e));
    }
    if (message.pages?.length) {
      obj.pages = message.pages.map((e) => Document_Page.toJSON(e));
    }
    if (message.entities?.length) {
      obj.entities = message.entities.map((e) => Document_Entity.toJSON(e));
    }
    if (message.entityRelations?.length) {
      obj.entityRelations = message.entityRelations.map((e) => Document_EntityRelation.toJSON(e));
    }
    if (message.textChanges?.length) {
      obj.textChanges = message.textChanges.map((e) => Document_TextChange.toJSON(e));
    }
    if (message.shardInfo !== undefined) {
      obj.shardInfo = Document_ShardInfo.toJSON(message.shardInfo);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.revisions?.length) {
      obj.revisions = message.revisions.map((e) => Document_Revision.toJSON(e));
    }
    if (message.documentLayout !== undefined) {
      obj.documentLayout = Document_DocumentLayout.toJSON(message.documentLayout);
    }
    if (message.chunkedDocument !== undefined) {
      obj.chunkedDocument = Document_ChunkedDocument.toJSON(message.chunkedDocument);
    }
    return obj;
  },

  create(base?: DeepPartial<Document>): Document {
    return Document.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document>): Document {
    const message = createBaseDocument();
    message.uri = object.uri ?? undefined;
    message.content = object.content ?? undefined;
    message.mimeType = object.mimeType ?? "";
    message.text = object.text ?? "";
    message.textStyles = object.textStyles?.map((e) => Document_Style.fromPartial(e)) || [];
    message.pages = object.pages?.map((e) => Document_Page.fromPartial(e)) || [];
    message.entities = object.entities?.map((e) => Document_Entity.fromPartial(e)) || [];
    message.entityRelations = object.entityRelations?.map((e) => Document_EntityRelation.fromPartial(e)) || [];
    message.textChanges = object.textChanges?.map((e) => Document_TextChange.fromPartial(e)) || [];
    message.shardInfo = (object.shardInfo !== undefined && object.shardInfo !== null)
      ? Document_ShardInfo.fromPartial(object.shardInfo)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.revisions = object.revisions?.map((e) => Document_Revision.fromPartial(e)) || [];
    message.documentLayout = (object.documentLayout !== undefined && object.documentLayout !== null)
      ? Document_DocumentLayout.fromPartial(object.documentLayout)
      : undefined;
    message.chunkedDocument = (object.chunkedDocument !== undefined && object.chunkedDocument !== null)
      ? Document_ChunkedDocument.fromPartial(object.chunkedDocument)
      : undefined;
    return message;
  },
};

function createBaseDocument_ShardInfo(): Document_ShardInfo {
  return { shardIndex: Long.ZERO, shardCount: Long.ZERO, textOffset: Long.ZERO };
}

export const Document_ShardInfo: MessageFns<Document_ShardInfo> = {
  encode(message: Document_ShardInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.shardIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.shardIndex.toString());
    }
    if (!message.shardCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.shardCount.toString());
    }
    if (!message.textOffset.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.textOffset.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_ShardInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_ShardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.shardIndex = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.shardCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.textOffset = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_ShardInfo {
    return {
      shardIndex: isSet(object.shardIndex) ? Long.fromValue(object.shardIndex) : Long.ZERO,
      shardCount: isSet(object.shardCount) ? Long.fromValue(object.shardCount) : Long.ZERO,
      textOffset: isSet(object.textOffset) ? Long.fromValue(object.textOffset) : Long.ZERO,
    };
  },

  toJSON(message: Document_ShardInfo): unknown {
    const obj: any = {};
    if (!message.shardIndex.equals(Long.ZERO)) {
      obj.shardIndex = (message.shardIndex || Long.ZERO).toString();
    }
    if (!message.shardCount.equals(Long.ZERO)) {
      obj.shardCount = (message.shardCount || Long.ZERO).toString();
    }
    if (!message.textOffset.equals(Long.ZERO)) {
      obj.textOffset = (message.textOffset || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Document_ShardInfo>): Document_ShardInfo {
    return Document_ShardInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_ShardInfo>): Document_ShardInfo {
    const message = createBaseDocument_ShardInfo();
    message.shardIndex = (object.shardIndex !== undefined && object.shardIndex !== null)
      ? Long.fromValue(object.shardIndex)
      : Long.ZERO;
    message.shardCount = (object.shardCount !== undefined && object.shardCount !== null)
      ? Long.fromValue(object.shardCount)
      : Long.ZERO;
    message.textOffset = (object.textOffset !== undefined && object.textOffset !== null)
      ? Long.fromValue(object.textOffset)
      : Long.ZERO;
    return message;
  },
};

function createBaseDocument_Style(): Document_Style {
  return {
    textAnchor: undefined,
    color: undefined,
    backgroundColor: undefined,
    fontWeight: "",
    textStyle: "",
    textDecoration: "",
    fontSize: undefined,
    fontFamily: "",
  };
}

export const Document_Style: MessageFns<Document_Style> = {
  encode(message: Document_Style, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textAnchor !== undefined) {
      Document_TextAnchor.encode(message.textAnchor, writer.uint32(10).fork()).join();
    }
    if (message.color !== undefined) {
      Color.encode(message.color, writer.uint32(18).fork()).join();
    }
    if (message.backgroundColor !== undefined) {
      Color.encode(message.backgroundColor, writer.uint32(26).fork()).join();
    }
    if (message.fontWeight !== "") {
      writer.uint32(34).string(message.fontWeight);
    }
    if (message.textStyle !== "") {
      writer.uint32(42).string(message.textStyle);
    }
    if (message.textDecoration !== "") {
      writer.uint32(50).string(message.textDecoration);
    }
    if (message.fontSize !== undefined) {
      Document_Style_FontSize.encode(message.fontSize, writer.uint32(58).fork()).join();
    }
    if (message.fontFamily !== "") {
      writer.uint32(66).string(message.fontFamily);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Style {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Style();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textAnchor = Document_TextAnchor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.color = Color.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backgroundColor = Color.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fontWeight = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.textStyle = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.textDecoration = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.fontSize = Document_Style_FontSize.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.fontFamily = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Style {
    return {
      textAnchor: isSet(object.textAnchor) ? Document_TextAnchor.fromJSON(object.textAnchor) : undefined,
      color: isSet(object.color) ? Color.fromJSON(object.color) : undefined,
      backgroundColor: isSet(object.backgroundColor) ? Color.fromJSON(object.backgroundColor) : undefined,
      fontWeight: isSet(object.fontWeight) ? globalThis.String(object.fontWeight) : "",
      textStyle: isSet(object.textStyle) ? globalThis.String(object.textStyle) : "",
      textDecoration: isSet(object.textDecoration) ? globalThis.String(object.textDecoration) : "",
      fontSize: isSet(object.fontSize) ? Document_Style_FontSize.fromJSON(object.fontSize) : undefined,
      fontFamily: isSet(object.fontFamily) ? globalThis.String(object.fontFamily) : "",
    };
  },

  toJSON(message: Document_Style): unknown {
    const obj: any = {};
    if (message.textAnchor !== undefined) {
      obj.textAnchor = Document_TextAnchor.toJSON(message.textAnchor);
    }
    if (message.color !== undefined) {
      obj.color = Color.toJSON(message.color);
    }
    if (message.backgroundColor !== undefined) {
      obj.backgroundColor = Color.toJSON(message.backgroundColor);
    }
    if (message.fontWeight !== "") {
      obj.fontWeight = message.fontWeight;
    }
    if (message.textStyle !== "") {
      obj.textStyle = message.textStyle;
    }
    if (message.textDecoration !== "") {
      obj.textDecoration = message.textDecoration;
    }
    if (message.fontSize !== undefined) {
      obj.fontSize = Document_Style_FontSize.toJSON(message.fontSize);
    }
    if (message.fontFamily !== "") {
      obj.fontFamily = message.fontFamily;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Style>): Document_Style {
    return Document_Style.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Style>): Document_Style {
    const message = createBaseDocument_Style();
    message.textAnchor = (object.textAnchor !== undefined && object.textAnchor !== null)
      ? Document_TextAnchor.fromPartial(object.textAnchor)
      : undefined;
    message.color = (object.color !== undefined && object.color !== null) ? Color.fromPartial(object.color) : undefined;
    message.backgroundColor = (object.backgroundColor !== undefined && object.backgroundColor !== null)
      ? Color.fromPartial(object.backgroundColor)
      : undefined;
    message.fontWeight = object.fontWeight ?? "";
    message.textStyle = object.textStyle ?? "";
    message.textDecoration = object.textDecoration ?? "";
    message.fontSize = (object.fontSize !== undefined && object.fontSize !== null)
      ? Document_Style_FontSize.fromPartial(object.fontSize)
      : undefined;
    message.fontFamily = object.fontFamily ?? "";
    return message;
  },
};

function createBaseDocument_Style_FontSize(): Document_Style_FontSize {
  return { size: 0, unit: "" };
}

export const Document_Style_FontSize: MessageFns<Document_Style_FontSize> = {
  encode(message: Document_Style_FontSize, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.size !== 0) {
      writer.uint32(13).float(message.size);
    }
    if (message.unit !== "") {
      writer.uint32(18).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Style_FontSize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Style_FontSize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.size = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Style_FontSize {
    return {
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: Document_Style_FontSize): unknown {
    const obj: any = {};
    if (message.size !== 0) {
      obj.size = message.size;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Style_FontSize>): Document_Style_FontSize {
    return Document_Style_FontSize.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Style_FontSize>): Document_Style_FontSize {
    const message = createBaseDocument_Style_FontSize();
    message.size = object.size ?? 0;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseDocument_Page(): Document_Page {
  return {
    pageNumber: 0,
    image: undefined,
    transforms: [],
    dimension: undefined,
    layout: undefined,
    detectedLanguages: [],
    blocks: [],
    paragraphs: [],
    lines: [],
    tokens: [],
    visualElements: [],
    tables: [],
    formFields: [],
    symbols: [],
    detectedBarcodes: [],
    imageQualityScores: undefined,
    provenance: undefined,
  };
}

export const Document_Page: MessageFns<Document_Page> = {
  encode(message: Document_Page, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageNumber !== 0) {
      writer.uint32(8).int32(message.pageNumber);
    }
    if (message.image !== undefined) {
      Document_Page_Image.encode(message.image, writer.uint32(106).fork()).join();
    }
    for (const v of message.transforms) {
      Document_Page_Matrix.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.dimension !== undefined) {
      Document_Page_Dimension.encode(message.dimension, writer.uint32(18).fork()).join();
    }
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(26).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.blocks) {
      Document_Page_Block.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.paragraphs) {
      Document_Page_Paragraph.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.lines) {
      Document_Page_Line.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.tokens) {
      Document_Page_Token.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.visualElements) {
      Document_Page_VisualElement.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.tables) {
      Document_Page_Table.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.formFields) {
      Document_Page_FormField.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.symbols) {
      Document_Page_Symbol.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.detectedBarcodes) {
      Document_Page_DetectedBarcode.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.imageQualityScores !== undefined) {
      Document_Page_ImageQualityScores.encode(message.imageQualityScores, writer.uint32(138).fork()).join();
    }
    if (message.provenance !== undefined) {
      Document_Provenance.encode(message.provenance, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageNumber = reader.int32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.image = Document_Page_Image.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.transforms.push(Document_Page_Matrix.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimension = Document_Page_Dimension.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.blocks.push(Document_Page_Block.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.paragraphs.push(Document_Page_Paragraph.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lines.push(Document_Page_Line.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tokens.push(Document_Page_Token.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.visualElements.push(Document_Page_VisualElement.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.tables.push(Document_Page_Table.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.formFields.push(Document_Page_FormField.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.symbols.push(Document_Page_Symbol.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.detectedBarcodes.push(Document_Page_DetectedBarcode.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.imageQualityScores = Document_Page_ImageQualityScores.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.provenance = Document_Provenance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page {
    return {
      pageNumber: isSet(object.pageNumber) ? globalThis.Number(object.pageNumber) : 0,
      image: isSet(object.image) ? Document_Page_Image.fromJSON(object.image) : undefined,
      transforms: globalThis.Array.isArray(object?.transforms)
        ? object.transforms.map((e: any) => Document_Page_Matrix.fromJSON(e))
        : [],
      dimension: isSet(object.dimension) ? Document_Page_Dimension.fromJSON(object.dimension) : undefined,
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
      blocks: globalThis.Array.isArray(object?.blocks)
        ? object.blocks.map((e: any) => Document_Page_Block.fromJSON(e))
        : [],
      paragraphs: globalThis.Array.isArray(object?.paragraphs)
        ? object.paragraphs.map((e: any) => Document_Page_Paragraph.fromJSON(e))
        : [],
      lines: globalThis.Array.isArray(object?.lines)
        ? object.lines.map((e: any) => Document_Page_Line.fromJSON(e))
        : [],
      tokens: globalThis.Array.isArray(object?.tokens)
        ? object.tokens.map((e: any) => Document_Page_Token.fromJSON(e))
        : [],
      visualElements: globalThis.Array.isArray(object?.visualElements)
        ? object.visualElements.map((e: any) => Document_Page_VisualElement.fromJSON(e))
        : [],
      tables: globalThis.Array.isArray(object?.tables)
        ? object.tables.map((e: any) => Document_Page_Table.fromJSON(e))
        : [],
      formFields: globalThis.Array.isArray(object?.formFields)
        ? object.formFields.map((e: any) => Document_Page_FormField.fromJSON(e))
        : [],
      symbols: globalThis.Array.isArray(object?.symbols)
        ? object.symbols.map((e: any) => Document_Page_Symbol.fromJSON(e))
        : [],
      detectedBarcodes: globalThis.Array.isArray(object?.detectedBarcodes)
        ? object.detectedBarcodes.map((e: any) => Document_Page_DetectedBarcode.fromJSON(e))
        : [],
      imageQualityScores: isSet(object.imageQualityScores)
        ? Document_Page_ImageQualityScores.fromJSON(object.imageQualityScores)
        : undefined,
      provenance: isSet(object.provenance) ? Document_Provenance.fromJSON(object.provenance) : undefined,
    };
  },

  toJSON(message: Document_Page): unknown {
    const obj: any = {};
    if (message.pageNumber !== 0) {
      obj.pageNumber = Math.round(message.pageNumber);
    }
    if (message.image !== undefined) {
      obj.image = Document_Page_Image.toJSON(message.image);
    }
    if (message.transforms?.length) {
      obj.transforms = message.transforms.map((e) => Document_Page_Matrix.toJSON(e));
    }
    if (message.dimension !== undefined) {
      obj.dimension = Document_Page_Dimension.toJSON(message.dimension);
    }
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => Document_Page_Block.toJSON(e));
    }
    if (message.paragraphs?.length) {
      obj.paragraphs = message.paragraphs.map((e) => Document_Page_Paragraph.toJSON(e));
    }
    if (message.lines?.length) {
      obj.lines = message.lines.map((e) => Document_Page_Line.toJSON(e));
    }
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => Document_Page_Token.toJSON(e));
    }
    if (message.visualElements?.length) {
      obj.visualElements = message.visualElements.map((e) => Document_Page_VisualElement.toJSON(e));
    }
    if (message.tables?.length) {
      obj.tables = message.tables.map((e) => Document_Page_Table.toJSON(e));
    }
    if (message.formFields?.length) {
      obj.formFields = message.formFields.map((e) => Document_Page_FormField.toJSON(e));
    }
    if (message.symbols?.length) {
      obj.symbols = message.symbols.map((e) => Document_Page_Symbol.toJSON(e));
    }
    if (message.detectedBarcodes?.length) {
      obj.detectedBarcodes = message.detectedBarcodes.map((e) => Document_Page_DetectedBarcode.toJSON(e));
    }
    if (message.imageQualityScores !== undefined) {
      obj.imageQualityScores = Document_Page_ImageQualityScores.toJSON(message.imageQualityScores);
    }
    if (message.provenance !== undefined) {
      obj.provenance = Document_Provenance.toJSON(message.provenance);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page>): Document_Page {
    return Document_Page.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page>): Document_Page {
    const message = createBaseDocument_Page();
    message.pageNumber = object.pageNumber ?? 0;
    message.image = (object.image !== undefined && object.image !== null)
      ? Document_Page_Image.fromPartial(object.image)
      : undefined;
    message.transforms = object.transforms?.map((e) => Document_Page_Matrix.fromPartial(e)) || [];
    message.dimension = (object.dimension !== undefined && object.dimension !== null)
      ? Document_Page_Dimension.fromPartial(object.dimension)
      : undefined;
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    message.blocks = object.blocks?.map((e) => Document_Page_Block.fromPartial(e)) || [];
    message.paragraphs = object.paragraphs?.map((e) => Document_Page_Paragraph.fromPartial(e)) || [];
    message.lines = object.lines?.map((e) => Document_Page_Line.fromPartial(e)) || [];
    message.tokens = object.tokens?.map((e) => Document_Page_Token.fromPartial(e)) || [];
    message.visualElements = object.visualElements?.map((e) => Document_Page_VisualElement.fromPartial(e)) || [];
    message.tables = object.tables?.map((e) => Document_Page_Table.fromPartial(e)) || [];
    message.formFields = object.formFields?.map((e) => Document_Page_FormField.fromPartial(e)) || [];
    message.symbols = object.symbols?.map((e) => Document_Page_Symbol.fromPartial(e)) || [];
    message.detectedBarcodes = object.detectedBarcodes?.map((e) => Document_Page_DetectedBarcode.fromPartial(e)) || [];
    message.imageQualityScores = (object.imageQualityScores !== undefined && object.imageQualityScores !== null)
      ? Document_Page_ImageQualityScores.fromPartial(object.imageQualityScores)
      : undefined;
    message.provenance = (object.provenance !== undefined && object.provenance !== null)
      ? Document_Provenance.fromPartial(object.provenance)
      : undefined;
    return message;
  },
};

function createBaseDocument_Page_Dimension(): Document_Page_Dimension {
  return { width: 0, height: 0, unit: "" };
}

export const Document_Page_Dimension: MessageFns<Document_Page_Dimension> = {
  encode(message: Document_Page_Dimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(13).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(21).float(message.height);
    }
    if (message.unit !== "") {
      writer.uint32(26).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Dimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Dimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.width = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.height = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Dimension {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: Document_Page_Dimension): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Dimension>): Document_Page_Dimension {
    return Document_Page_Dimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Dimension>): Document_Page_Dimension {
    const message = createBaseDocument_Page_Dimension();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseDocument_Page_Image(): Document_Page_Image {
  return { content: Buffer.alloc(0), mimeType: "", width: 0, height: 0 };
}

export const Document_Page_Image: MessageFns<Document_Page_Image> = {
  encode(message: Document_Page_Image, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content.length !== 0) {
      writer.uint32(10).bytes(message.content);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    if (message.width !== 0) {
      writer.uint32(24).int32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(32).int32(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Image {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Image();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.width = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.height = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Image {
    return {
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0),
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: Document_Page_Image): unknown {
    const obj: any = {};
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Image>): Document_Page_Image {
    return Document_Page_Image.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Image>): Document_Page_Image {
    const message = createBaseDocument_Page_Image();
    message.content = object.content ?? Buffer.alloc(0);
    message.mimeType = object.mimeType ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseDocument_Page_Matrix(): Document_Page_Matrix {
  return { rows: 0, cols: 0, type: 0, data: Buffer.alloc(0) };
}

export const Document_Page_Matrix: MessageFns<Document_Page_Matrix> = {
  encode(message: Document_Page_Matrix, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rows !== 0) {
      writer.uint32(8).int32(message.rows);
    }
    if (message.cols !== 0) {
      writer.uint32(16).int32(message.cols);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.data.length !== 0) {
      writer.uint32(34).bytes(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Matrix {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Matrix();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rows = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.cols = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Matrix {
    return {
      rows: isSet(object.rows) ? globalThis.Number(object.rows) : 0,
      cols: isSet(object.cols) ? globalThis.Number(object.cols) : 0,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Document_Page_Matrix): unknown {
    const obj: any = {};
    if (message.rows !== 0) {
      obj.rows = Math.round(message.rows);
    }
    if (message.cols !== 0) {
      obj.cols = Math.round(message.cols);
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Matrix>): Document_Page_Matrix {
    return Document_Page_Matrix.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Matrix>): Document_Page_Matrix {
    const message = createBaseDocument_Page_Matrix();
    message.rows = object.rows ?? 0;
    message.cols = object.cols ?? 0;
    message.type = object.type ?? 0;
    message.data = object.data ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseDocument_Page_Layout(): Document_Page_Layout {
  return { textAnchor: undefined, confidence: 0, boundingPoly: undefined, orientation: 0 };
}

export const Document_Page_Layout: MessageFns<Document_Page_Layout> = {
  encode(message: Document_Page_Layout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textAnchor !== undefined) {
      Document_TextAnchor.encode(message.textAnchor, writer.uint32(10).fork()).join();
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    if (message.boundingPoly !== undefined) {
      BoundingPoly.encode(message.boundingPoly, writer.uint32(26).fork()).join();
    }
    if (message.orientation !== 0) {
      writer.uint32(32).int32(message.orientation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Layout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Layout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textAnchor = Document_TextAnchor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.boundingPoly = BoundingPoly.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.orientation = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Layout {
    return {
      textAnchor: isSet(object.textAnchor) ? Document_TextAnchor.fromJSON(object.textAnchor) : undefined,
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      boundingPoly: isSet(object.boundingPoly) ? BoundingPoly.fromJSON(object.boundingPoly) : undefined,
      orientation: isSet(object.orientation) ? document_Page_Layout_OrientationFromJSON(object.orientation) : 0,
    };
  },

  toJSON(message: Document_Page_Layout): unknown {
    const obj: any = {};
    if (message.textAnchor !== undefined) {
      obj.textAnchor = Document_TextAnchor.toJSON(message.textAnchor);
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.boundingPoly !== undefined) {
      obj.boundingPoly = BoundingPoly.toJSON(message.boundingPoly);
    }
    if (message.orientation !== 0) {
      obj.orientation = document_Page_Layout_OrientationToJSON(message.orientation);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Layout>): Document_Page_Layout {
    return Document_Page_Layout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Layout>): Document_Page_Layout {
    const message = createBaseDocument_Page_Layout();
    message.textAnchor = (object.textAnchor !== undefined && object.textAnchor !== null)
      ? Document_TextAnchor.fromPartial(object.textAnchor)
      : undefined;
    message.confidence = object.confidence ?? 0;
    message.boundingPoly = (object.boundingPoly !== undefined && object.boundingPoly !== null)
      ? BoundingPoly.fromPartial(object.boundingPoly)
      : undefined;
    message.orientation = object.orientation ?? 0;
    return message;
  },
};

function createBaseDocument_Page_Block(): Document_Page_Block {
  return { layout: undefined, detectedLanguages: [], provenance: undefined };
}

export const Document_Page_Block: MessageFns<Document_Page_Block> = {
  encode(message: Document_Page_Block, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.provenance !== undefined) {
      Document_Provenance.encode(message.provenance, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Block {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Block();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provenance = Document_Provenance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Block {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
      provenance: isSet(object.provenance) ? Document_Provenance.fromJSON(object.provenance) : undefined,
    };
  },

  toJSON(message: Document_Page_Block): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    if (message.provenance !== undefined) {
      obj.provenance = Document_Provenance.toJSON(message.provenance);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Block>): Document_Page_Block {
    return Document_Page_Block.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Block>): Document_Page_Block {
    const message = createBaseDocument_Page_Block();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    message.provenance = (object.provenance !== undefined && object.provenance !== null)
      ? Document_Provenance.fromPartial(object.provenance)
      : undefined;
    return message;
  },
};

function createBaseDocument_Page_Paragraph(): Document_Page_Paragraph {
  return { layout: undefined, detectedLanguages: [], provenance: undefined };
}

export const Document_Page_Paragraph: MessageFns<Document_Page_Paragraph> = {
  encode(message: Document_Page_Paragraph, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.provenance !== undefined) {
      Document_Provenance.encode(message.provenance, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Paragraph {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Paragraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provenance = Document_Provenance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Paragraph {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
      provenance: isSet(object.provenance) ? Document_Provenance.fromJSON(object.provenance) : undefined,
    };
  },

  toJSON(message: Document_Page_Paragraph): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    if (message.provenance !== undefined) {
      obj.provenance = Document_Provenance.toJSON(message.provenance);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Paragraph>): Document_Page_Paragraph {
    return Document_Page_Paragraph.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Paragraph>): Document_Page_Paragraph {
    const message = createBaseDocument_Page_Paragraph();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    message.provenance = (object.provenance !== undefined && object.provenance !== null)
      ? Document_Provenance.fromPartial(object.provenance)
      : undefined;
    return message;
  },
};

function createBaseDocument_Page_Line(): Document_Page_Line {
  return { layout: undefined, detectedLanguages: [], provenance: undefined };
}

export const Document_Page_Line: MessageFns<Document_Page_Line> = {
  encode(message: Document_Page_Line, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.provenance !== undefined) {
      Document_Provenance.encode(message.provenance, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Line {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Line();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provenance = Document_Provenance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Line {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
      provenance: isSet(object.provenance) ? Document_Provenance.fromJSON(object.provenance) : undefined,
    };
  },

  toJSON(message: Document_Page_Line): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    if (message.provenance !== undefined) {
      obj.provenance = Document_Provenance.toJSON(message.provenance);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Line>): Document_Page_Line {
    return Document_Page_Line.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Line>): Document_Page_Line {
    const message = createBaseDocument_Page_Line();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    message.provenance = (object.provenance !== undefined && object.provenance !== null)
      ? Document_Provenance.fromPartial(object.provenance)
      : undefined;
    return message;
  },
};

function createBaseDocument_Page_Token(): Document_Page_Token {
  return {
    layout: undefined,
    detectedBreak: undefined,
    detectedLanguages: [],
    provenance: undefined,
    styleInfo: undefined,
  };
}

export const Document_Page_Token: MessageFns<Document_Page_Token> = {
  encode(message: Document_Page_Token, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    if (message.detectedBreak !== undefined) {
      Document_Page_Token_DetectedBreak.encode(message.detectedBreak, writer.uint32(18).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.provenance !== undefined) {
      Document_Provenance.encode(message.provenance, writer.uint32(34).fork()).join();
    }
    if (message.styleInfo !== undefined) {
      Document_Page_Token_StyleInfo.encode(message.styleInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Token {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Token();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedBreak = Document_Page_Token_DetectedBreak.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.provenance = Document_Provenance.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.styleInfo = Document_Page_Token_StyleInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Token {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      detectedBreak: isSet(object.detectedBreak)
        ? Document_Page_Token_DetectedBreak.fromJSON(object.detectedBreak)
        : undefined,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
      provenance: isSet(object.provenance) ? Document_Provenance.fromJSON(object.provenance) : undefined,
      styleInfo: isSet(object.styleInfo) ? Document_Page_Token_StyleInfo.fromJSON(object.styleInfo) : undefined,
    };
  },

  toJSON(message: Document_Page_Token): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.detectedBreak !== undefined) {
      obj.detectedBreak = Document_Page_Token_DetectedBreak.toJSON(message.detectedBreak);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    if (message.provenance !== undefined) {
      obj.provenance = Document_Provenance.toJSON(message.provenance);
    }
    if (message.styleInfo !== undefined) {
      obj.styleInfo = Document_Page_Token_StyleInfo.toJSON(message.styleInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Token>): Document_Page_Token {
    return Document_Page_Token.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Token>): Document_Page_Token {
    const message = createBaseDocument_Page_Token();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.detectedBreak = (object.detectedBreak !== undefined && object.detectedBreak !== null)
      ? Document_Page_Token_DetectedBreak.fromPartial(object.detectedBreak)
      : undefined;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    message.provenance = (object.provenance !== undefined && object.provenance !== null)
      ? Document_Provenance.fromPartial(object.provenance)
      : undefined;
    message.styleInfo = (object.styleInfo !== undefined && object.styleInfo !== null)
      ? Document_Page_Token_StyleInfo.fromPartial(object.styleInfo)
      : undefined;
    return message;
  },
};

function createBaseDocument_Page_Token_DetectedBreak(): Document_Page_Token_DetectedBreak {
  return { type: 0 };
}

export const Document_Page_Token_DetectedBreak: MessageFns<Document_Page_Token_DetectedBreak> = {
  encode(message: Document_Page_Token_DetectedBreak, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Token_DetectedBreak {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Token_DetectedBreak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Token_DetectedBreak {
    return { type: isSet(object.type) ? document_Page_Token_DetectedBreak_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: Document_Page_Token_DetectedBreak): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = document_Page_Token_DetectedBreak_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Token_DetectedBreak>): Document_Page_Token_DetectedBreak {
    return Document_Page_Token_DetectedBreak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Token_DetectedBreak>): Document_Page_Token_DetectedBreak {
    const message = createBaseDocument_Page_Token_DetectedBreak();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseDocument_Page_Token_StyleInfo(): Document_Page_Token_StyleInfo {
  return {
    fontSize: 0,
    pixelFontSize: 0,
    letterSpacing: 0,
    fontType: "",
    bold: false,
    italic: false,
    underlined: false,
    strikeout: false,
    subscript: false,
    superscript: false,
    smallcaps: false,
    fontWeight: 0,
    handwritten: false,
    textColor: undefined,
    backgroundColor: undefined,
  };
}

export const Document_Page_Token_StyleInfo: MessageFns<Document_Page_Token_StyleInfo> = {
  encode(message: Document_Page_Token_StyleInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fontSize !== 0) {
      writer.uint32(8).int32(message.fontSize);
    }
    if (message.pixelFontSize !== 0) {
      writer.uint32(17).double(message.pixelFontSize);
    }
    if (message.letterSpacing !== 0) {
      writer.uint32(25).double(message.letterSpacing);
    }
    if (message.fontType !== "") {
      writer.uint32(34).string(message.fontType);
    }
    if (message.bold !== false) {
      writer.uint32(40).bool(message.bold);
    }
    if (message.italic !== false) {
      writer.uint32(48).bool(message.italic);
    }
    if (message.underlined !== false) {
      writer.uint32(56).bool(message.underlined);
    }
    if (message.strikeout !== false) {
      writer.uint32(64).bool(message.strikeout);
    }
    if (message.subscript !== false) {
      writer.uint32(72).bool(message.subscript);
    }
    if (message.superscript !== false) {
      writer.uint32(80).bool(message.superscript);
    }
    if (message.smallcaps !== false) {
      writer.uint32(88).bool(message.smallcaps);
    }
    if (message.fontWeight !== 0) {
      writer.uint32(96).int32(message.fontWeight);
    }
    if (message.handwritten !== false) {
      writer.uint32(104).bool(message.handwritten);
    }
    if (message.textColor !== undefined) {
      Color.encode(message.textColor, writer.uint32(114).fork()).join();
    }
    if (message.backgroundColor !== undefined) {
      Color.encode(message.backgroundColor, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Token_StyleInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Token_StyleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fontSize = reader.int32();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.pixelFontSize = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.letterSpacing = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fontType = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.bold = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.italic = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.underlined = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.strikeout = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.subscript = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.superscript = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.smallcaps = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.fontWeight = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.handwritten = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.textColor = Color.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.backgroundColor = Color.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Token_StyleInfo {
    return {
      fontSize: isSet(object.fontSize) ? globalThis.Number(object.fontSize) : 0,
      pixelFontSize: isSet(object.pixelFontSize) ? globalThis.Number(object.pixelFontSize) : 0,
      letterSpacing: isSet(object.letterSpacing) ? globalThis.Number(object.letterSpacing) : 0,
      fontType: isSet(object.fontType) ? globalThis.String(object.fontType) : "",
      bold: isSet(object.bold) ? globalThis.Boolean(object.bold) : false,
      italic: isSet(object.italic) ? globalThis.Boolean(object.italic) : false,
      underlined: isSet(object.underlined) ? globalThis.Boolean(object.underlined) : false,
      strikeout: isSet(object.strikeout) ? globalThis.Boolean(object.strikeout) : false,
      subscript: isSet(object.subscript) ? globalThis.Boolean(object.subscript) : false,
      superscript: isSet(object.superscript) ? globalThis.Boolean(object.superscript) : false,
      smallcaps: isSet(object.smallcaps) ? globalThis.Boolean(object.smallcaps) : false,
      fontWeight: isSet(object.fontWeight) ? globalThis.Number(object.fontWeight) : 0,
      handwritten: isSet(object.handwritten) ? globalThis.Boolean(object.handwritten) : false,
      textColor: isSet(object.textColor) ? Color.fromJSON(object.textColor) : undefined,
      backgroundColor: isSet(object.backgroundColor) ? Color.fromJSON(object.backgroundColor) : undefined,
    };
  },

  toJSON(message: Document_Page_Token_StyleInfo): unknown {
    const obj: any = {};
    if (message.fontSize !== 0) {
      obj.fontSize = Math.round(message.fontSize);
    }
    if (message.pixelFontSize !== 0) {
      obj.pixelFontSize = message.pixelFontSize;
    }
    if (message.letterSpacing !== 0) {
      obj.letterSpacing = message.letterSpacing;
    }
    if (message.fontType !== "") {
      obj.fontType = message.fontType;
    }
    if (message.bold !== false) {
      obj.bold = message.bold;
    }
    if (message.italic !== false) {
      obj.italic = message.italic;
    }
    if (message.underlined !== false) {
      obj.underlined = message.underlined;
    }
    if (message.strikeout !== false) {
      obj.strikeout = message.strikeout;
    }
    if (message.subscript !== false) {
      obj.subscript = message.subscript;
    }
    if (message.superscript !== false) {
      obj.superscript = message.superscript;
    }
    if (message.smallcaps !== false) {
      obj.smallcaps = message.smallcaps;
    }
    if (message.fontWeight !== 0) {
      obj.fontWeight = Math.round(message.fontWeight);
    }
    if (message.handwritten !== false) {
      obj.handwritten = message.handwritten;
    }
    if (message.textColor !== undefined) {
      obj.textColor = Color.toJSON(message.textColor);
    }
    if (message.backgroundColor !== undefined) {
      obj.backgroundColor = Color.toJSON(message.backgroundColor);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Token_StyleInfo>): Document_Page_Token_StyleInfo {
    return Document_Page_Token_StyleInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Token_StyleInfo>): Document_Page_Token_StyleInfo {
    const message = createBaseDocument_Page_Token_StyleInfo();
    message.fontSize = object.fontSize ?? 0;
    message.pixelFontSize = object.pixelFontSize ?? 0;
    message.letterSpacing = object.letterSpacing ?? 0;
    message.fontType = object.fontType ?? "";
    message.bold = object.bold ?? false;
    message.italic = object.italic ?? false;
    message.underlined = object.underlined ?? false;
    message.strikeout = object.strikeout ?? false;
    message.subscript = object.subscript ?? false;
    message.superscript = object.superscript ?? false;
    message.smallcaps = object.smallcaps ?? false;
    message.fontWeight = object.fontWeight ?? 0;
    message.handwritten = object.handwritten ?? false;
    message.textColor = (object.textColor !== undefined && object.textColor !== null)
      ? Color.fromPartial(object.textColor)
      : undefined;
    message.backgroundColor = (object.backgroundColor !== undefined && object.backgroundColor !== null)
      ? Color.fromPartial(object.backgroundColor)
      : undefined;
    return message;
  },
};

function createBaseDocument_Page_Symbol(): Document_Page_Symbol {
  return { layout: undefined, detectedLanguages: [] };
}

export const Document_Page_Symbol: MessageFns<Document_Page_Symbol> = {
  encode(message: Document_Page_Symbol, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Symbol {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Symbol();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Symbol {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_Symbol): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Symbol>): Document_Page_Symbol {
    return Document_Page_Symbol.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Symbol>): Document_Page_Symbol {
    const message = createBaseDocument_Page_Symbol();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseDocument_Page_VisualElement(): Document_Page_VisualElement {
  return { layout: undefined, type: "", detectedLanguages: [] };
}

export const Document_Page_VisualElement: MessageFns<Document_Page_VisualElement> = {
  encode(message: Document_Page_VisualElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_VisualElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_VisualElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_VisualElement {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_VisualElement): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_VisualElement>): Document_Page_VisualElement {
    return Document_Page_VisualElement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_VisualElement>): Document_Page_VisualElement {
    const message = createBaseDocument_Page_VisualElement();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.type = object.type ?? "";
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseDocument_Page_Table(): Document_Page_Table {
  return { layout: undefined, headerRows: [], bodyRows: [], detectedLanguages: [], provenance: undefined };
}

export const Document_Page_Table: MessageFns<Document_Page_Table> = {
  encode(message: Document_Page_Table, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    for (const v of message.headerRows) {
      Document_Page_Table_TableRow.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.bodyRows) {
      Document_Page_Table_TableRow.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.provenance !== undefined) {
      Document_Provenance.encode(message.provenance, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Table {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Table();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.headerRows.push(Document_Page_Table_TableRow.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bodyRows.push(Document_Page_Table_TableRow.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.provenance = Document_Provenance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Table {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      headerRows: globalThis.Array.isArray(object?.headerRows)
        ? object.headerRows.map((e: any) => Document_Page_Table_TableRow.fromJSON(e))
        : [],
      bodyRows: globalThis.Array.isArray(object?.bodyRows)
        ? object.bodyRows.map((e: any) => Document_Page_Table_TableRow.fromJSON(e))
        : [],
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
      provenance: isSet(object.provenance) ? Document_Provenance.fromJSON(object.provenance) : undefined,
    };
  },

  toJSON(message: Document_Page_Table): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.headerRows?.length) {
      obj.headerRows = message.headerRows.map((e) => Document_Page_Table_TableRow.toJSON(e));
    }
    if (message.bodyRows?.length) {
      obj.bodyRows = message.bodyRows.map((e) => Document_Page_Table_TableRow.toJSON(e));
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    if (message.provenance !== undefined) {
      obj.provenance = Document_Provenance.toJSON(message.provenance);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Table>): Document_Page_Table {
    return Document_Page_Table.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Table>): Document_Page_Table {
    const message = createBaseDocument_Page_Table();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.headerRows = object.headerRows?.map((e) => Document_Page_Table_TableRow.fromPartial(e)) || [];
    message.bodyRows = object.bodyRows?.map((e) => Document_Page_Table_TableRow.fromPartial(e)) || [];
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    message.provenance = (object.provenance !== undefined && object.provenance !== null)
      ? Document_Provenance.fromPartial(object.provenance)
      : undefined;
    return message;
  },
};

function createBaseDocument_Page_Table_TableRow(): Document_Page_Table_TableRow {
  return { cells: [] };
}

export const Document_Page_Table_TableRow: MessageFns<Document_Page_Table_TableRow> = {
  encode(message: Document_Page_Table_TableRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cells) {
      Document_Page_Table_TableCell.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Table_TableRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Table_TableRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cells.push(Document_Page_Table_TableCell.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Table_TableRow {
    return {
      cells: globalThis.Array.isArray(object?.cells)
        ? object.cells.map((e: any) => Document_Page_Table_TableCell.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_Table_TableRow): unknown {
    const obj: any = {};
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => Document_Page_Table_TableCell.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Table_TableRow>): Document_Page_Table_TableRow {
    return Document_Page_Table_TableRow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Table_TableRow>): Document_Page_Table_TableRow {
    const message = createBaseDocument_Page_Table_TableRow();
    message.cells = object.cells?.map((e) => Document_Page_Table_TableCell.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_Page_Table_TableCell(): Document_Page_Table_TableCell {
  return { layout: undefined, rowSpan: 0, colSpan: 0, detectedLanguages: [] };
}

export const Document_Page_Table_TableCell: MessageFns<Document_Page_Table_TableCell> = {
  encode(message: Document_Page_Table_TableCell, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    if (message.rowSpan !== 0) {
      writer.uint32(16).int32(message.rowSpan);
    }
    if (message.colSpan !== 0) {
      writer.uint32(24).int32(message.colSpan);
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Table_TableCell {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Table_TableCell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.rowSpan = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.colSpan = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Table_TableCell {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      rowSpan: isSet(object.rowSpan) ? globalThis.Number(object.rowSpan) : 0,
      colSpan: isSet(object.colSpan) ? globalThis.Number(object.colSpan) : 0,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_Table_TableCell): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.rowSpan !== 0) {
      obj.rowSpan = Math.round(message.rowSpan);
    }
    if (message.colSpan !== 0) {
      obj.colSpan = Math.round(message.colSpan);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Table_TableCell>): Document_Page_Table_TableCell {
    return Document_Page_Table_TableCell.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Table_TableCell>): Document_Page_Table_TableCell {
    const message = createBaseDocument_Page_Table_TableCell();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.rowSpan = object.rowSpan ?? 0;
    message.colSpan = object.colSpan ?? 0;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseDocument_Page_FormField(): Document_Page_FormField {
  return {
    fieldName: undefined,
    fieldValue: undefined,
    nameDetectedLanguages: [],
    valueDetectedLanguages: [],
    valueType: "",
    correctedKeyText: "",
    correctedValueText: "",
    provenance: undefined,
  };
}

export const Document_Page_FormField: MessageFns<Document_Page_FormField> = {
  encode(message: Document_Page_FormField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldName !== undefined) {
      Document_Page_Layout.encode(message.fieldName, writer.uint32(10).fork()).join();
    }
    if (message.fieldValue !== undefined) {
      Document_Page_Layout.encode(message.fieldValue, writer.uint32(18).fork()).join();
    }
    for (const v of message.nameDetectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.valueDetectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.valueType !== "") {
      writer.uint32(42).string(message.valueType);
    }
    if (message.correctedKeyText !== "") {
      writer.uint32(50).string(message.correctedKeyText);
    }
    if (message.correctedValueText !== "") {
      writer.uint32(58).string(message.correctedValueText);
    }
    if (message.provenance !== undefined) {
      Document_Provenance.encode(message.provenance, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_FormField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_FormField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldName = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldValue = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nameDetectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.valueDetectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.valueType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.correctedKeyText = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.correctedValueText = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.provenance = Document_Provenance.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_FormField {
    return {
      fieldName: isSet(object.fieldName) ? Document_Page_Layout.fromJSON(object.fieldName) : undefined,
      fieldValue: isSet(object.fieldValue) ? Document_Page_Layout.fromJSON(object.fieldValue) : undefined,
      nameDetectedLanguages: globalThis.Array.isArray(object?.nameDetectedLanguages)
        ? object.nameDetectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
      valueDetectedLanguages: globalThis.Array.isArray(object?.valueDetectedLanguages)
        ? object.valueDetectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
      valueType: isSet(object.valueType) ? globalThis.String(object.valueType) : "",
      correctedKeyText: isSet(object.correctedKeyText) ? globalThis.String(object.correctedKeyText) : "",
      correctedValueText: isSet(object.correctedValueText) ? globalThis.String(object.correctedValueText) : "",
      provenance: isSet(object.provenance) ? Document_Provenance.fromJSON(object.provenance) : undefined,
    };
  },

  toJSON(message: Document_Page_FormField): unknown {
    const obj: any = {};
    if (message.fieldName !== undefined) {
      obj.fieldName = Document_Page_Layout.toJSON(message.fieldName);
    }
    if (message.fieldValue !== undefined) {
      obj.fieldValue = Document_Page_Layout.toJSON(message.fieldValue);
    }
    if (message.nameDetectedLanguages?.length) {
      obj.nameDetectedLanguages = message.nameDetectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    if (message.valueDetectedLanguages?.length) {
      obj.valueDetectedLanguages = message.valueDetectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    if (message.valueType !== "") {
      obj.valueType = message.valueType;
    }
    if (message.correctedKeyText !== "") {
      obj.correctedKeyText = message.correctedKeyText;
    }
    if (message.correctedValueText !== "") {
      obj.correctedValueText = message.correctedValueText;
    }
    if (message.provenance !== undefined) {
      obj.provenance = Document_Provenance.toJSON(message.provenance);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_FormField>): Document_Page_FormField {
    return Document_Page_FormField.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_FormField>): Document_Page_FormField {
    const message = createBaseDocument_Page_FormField();
    message.fieldName = (object.fieldName !== undefined && object.fieldName !== null)
      ? Document_Page_Layout.fromPartial(object.fieldName)
      : undefined;
    message.fieldValue = (object.fieldValue !== undefined && object.fieldValue !== null)
      ? Document_Page_Layout.fromPartial(object.fieldValue)
      : undefined;
    message.nameDetectedLanguages =
      object.nameDetectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) || [];
    message.valueDetectedLanguages =
      object.valueDetectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) || [];
    message.valueType = object.valueType ?? "";
    message.correctedKeyText = object.correctedKeyText ?? "";
    message.correctedValueText = object.correctedValueText ?? "";
    message.provenance = (object.provenance !== undefined && object.provenance !== null)
      ? Document_Provenance.fromPartial(object.provenance)
      : undefined;
    return message;
  },
};

function createBaseDocument_Page_DetectedBarcode(): Document_Page_DetectedBarcode {
  return { layout: undefined, barcode: undefined };
}

export const Document_Page_DetectedBarcode: MessageFns<Document_Page_DetectedBarcode> = {
  encode(message: Document_Page_DetectedBarcode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    if (message.barcode !== undefined) {
      Barcode.encode(message.barcode, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_DetectedBarcode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_DetectedBarcode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.barcode = Barcode.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_DetectedBarcode {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      barcode: isSet(object.barcode) ? Barcode.fromJSON(object.barcode) : undefined,
    };
  },

  toJSON(message: Document_Page_DetectedBarcode): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.barcode !== undefined) {
      obj.barcode = Barcode.toJSON(message.barcode);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_DetectedBarcode>): Document_Page_DetectedBarcode {
    return Document_Page_DetectedBarcode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_DetectedBarcode>): Document_Page_DetectedBarcode {
    const message = createBaseDocument_Page_DetectedBarcode();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.barcode = (object.barcode !== undefined && object.barcode !== null)
      ? Barcode.fromPartial(object.barcode)
      : undefined;
    return message;
  },
};

function createBaseDocument_Page_DetectedLanguage(): Document_Page_DetectedLanguage {
  return { languageCode: "", confidence: 0 };
}

export const Document_Page_DetectedLanguage: MessageFns<Document_Page_DetectedLanguage> = {
  encode(message: Document_Page_DetectedLanguage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.languageCode !== "") {
      writer.uint32(10).string(message.languageCode);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_DetectedLanguage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_DetectedLanguage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_DetectedLanguage {
    return {
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: Document_Page_DetectedLanguage): unknown {
    const obj: any = {};
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_DetectedLanguage>): Document_Page_DetectedLanguage {
    return Document_Page_DetectedLanguage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_DetectedLanguage>): Document_Page_DetectedLanguage {
    const message = createBaseDocument_Page_DetectedLanguage();
    message.languageCode = object.languageCode ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseDocument_Page_ImageQualityScores(): Document_Page_ImageQualityScores {
  return { qualityScore: 0, detectedDefects: [] };
}

export const Document_Page_ImageQualityScores: MessageFns<Document_Page_ImageQualityScores> = {
  encode(message: Document_Page_ImageQualityScores, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.qualityScore !== 0) {
      writer.uint32(13).float(message.qualityScore);
    }
    for (const v of message.detectedDefects) {
      Document_Page_ImageQualityScores_DetectedDefect.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_ImageQualityScores {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_ImageQualityScores();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.qualityScore = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedDefects.push(Document_Page_ImageQualityScores_DetectedDefect.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_ImageQualityScores {
    return {
      qualityScore: isSet(object.qualityScore) ? globalThis.Number(object.qualityScore) : 0,
      detectedDefects: globalThis.Array.isArray(object?.detectedDefects)
        ? object.detectedDefects.map((e: any) => Document_Page_ImageQualityScores_DetectedDefect.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_ImageQualityScores): unknown {
    const obj: any = {};
    if (message.qualityScore !== 0) {
      obj.qualityScore = message.qualityScore;
    }
    if (message.detectedDefects?.length) {
      obj.detectedDefects = message.detectedDefects.map((e) =>
        Document_Page_ImageQualityScores_DetectedDefect.toJSON(e)
      );
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_ImageQualityScores>): Document_Page_ImageQualityScores {
    return Document_Page_ImageQualityScores.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_ImageQualityScores>): Document_Page_ImageQualityScores {
    const message = createBaseDocument_Page_ImageQualityScores();
    message.qualityScore = object.qualityScore ?? 0;
    message.detectedDefects =
      object.detectedDefects?.map((e) => Document_Page_ImageQualityScores_DetectedDefect.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_Page_ImageQualityScores_DetectedDefect(): Document_Page_ImageQualityScores_DetectedDefect {
  return { type: "", confidence: 0 };
}

export const Document_Page_ImageQualityScores_DetectedDefect: MessageFns<
  Document_Page_ImageQualityScores_DetectedDefect
> = {
  encode(
    message: Document_Page_ImageQualityScores_DetectedDefect,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_ImageQualityScores_DetectedDefect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_ImageQualityScores_DetectedDefect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_ImageQualityScores_DetectedDefect {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: Document_Page_ImageQualityScores_DetectedDefect): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Document_Page_ImageQualityScores_DetectedDefect>,
  ): Document_Page_ImageQualityScores_DetectedDefect {
    return Document_Page_ImageQualityScores_DetectedDefect.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_Page_ImageQualityScores_DetectedDefect>,
  ): Document_Page_ImageQualityScores_DetectedDefect {
    const message = createBaseDocument_Page_ImageQualityScores_DetectedDefect();
    message.type = object.type ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseDocument_Entity(): Document_Entity {
  return {
    textAnchor: undefined,
    type: "",
    mentionText: "",
    mentionId: "",
    confidence: 0,
    pageAnchor: undefined,
    id: "",
    normalizedValue: undefined,
    properties: [],
    provenance: undefined,
    redacted: false,
  };
}

export const Document_Entity: MessageFns<Document_Entity> = {
  encode(message: Document_Entity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textAnchor !== undefined) {
      Document_TextAnchor.encode(message.textAnchor, writer.uint32(10).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.mentionText !== "") {
      writer.uint32(26).string(message.mentionText);
    }
    if (message.mentionId !== "") {
      writer.uint32(34).string(message.mentionId);
    }
    if (message.confidence !== 0) {
      writer.uint32(45).float(message.confidence);
    }
    if (message.pageAnchor !== undefined) {
      Document_PageAnchor.encode(message.pageAnchor, writer.uint32(50).fork()).join();
    }
    if (message.id !== "") {
      writer.uint32(58).string(message.id);
    }
    if (message.normalizedValue !== undefined) {
      Document_Entity_NormalizedValue.encode(message.normalizedValue, writer.uint32(74).fork()).join();
    }
    for (const v of message.properties) {
      Document_Entity.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.provenance !== undefined) {
      Document_Provenance.encode(message.provenance, writer.uint32(90).fork()).join();
    }
    if (message.redacted !== false) {
      writer.uint32(96).bool(message.redacted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Entity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Entity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textAnchor = Document_TextAnchor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mentionText = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mentionId = reader.string();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pageAnchor = Document_PageAnchor.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.id = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.normalizedValue = Document_Entity_NormalizedValue.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.properties.push(Document_Entity.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.provenance = Document_Provenance.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.redacted = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Entity {
    return {
      textAnchor: isSet(object.textAnchor) ? Document_TextAnchor.fromJSON(object.textAnchor) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      mentionText: isSet(object.mentionText) ? globalThis.String(object.mentionText) : "",
      mentionId: isSet(object.mentionId) ? globalThis.String(object.mentionId) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      pageAnchor: isSet(object.pageAnchor) ? Document_PageAnchor.fromJSON(object.pageAnchor) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      normalizedValue: isSet(object.normalizedValue)
        ? Document_Entity_NormalizedValue.fromJSON(object.normalizedValue)
        : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Document_Entity.fromJSON(e))
        : [],
      provenance: isSet(object.provenance) ? Document_Provenance.fromJSON(object.provenance) : undefined,
      redacted: isSet(object.redacted) ? globalThis.Boolean(object.redacted) : false,
    };
  },

  toJSON(message: Document_Entity): unknown {
    const obj: any = {};
    if (message.textAnchor !== undefined) {
      obj.textAnchor = Document_TextAnchor.toJSON(message.textAnchor);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.mentionText !== "") {
      obj.mentionText = message.mentionText;
    }
    if (message.mentionId !== "") {
      obj.mentionId = message.mentionId;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.pageAnchor !== undefined) {
      obj.pageAnchor = Document_PageAnchor.toJSON(message.pageAnchor);
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.normalizedValue !== undefined) {
      obj.normalizedValue = Document_Entity_NormalizedValue.toJSON(message.normalizedValue);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Document_Entity.toJSON(e));
    }
    if (message.provenance !== undefined) {
      obj.provenance = Document_Provenance.toJSON(message.provenance);
    }
    if (message.redacted !== false) {
      obj.redacted = message.redacted;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Entity>): Document_Entity {
    return Document_Entity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Entity>): Document_Entity {
    const message = createBaseDocument_Entity();
    message.textAnchor = (object.textAnchor !== undefined && object.textAnchor !== null)
      ? Document_TextAnchor.fromPartial(object.textAnchor)
      : undefined;
    message.type = object.type ?? "";
    message.mentionText = object.mentionText ?? "";
    message.mentionId = object.mentionId ?? "";
    message.confidence = object.confidence ?? 0;
    message.pageAnchor = (object.pageAnchor !== undefined && object.pageAnchor !== null)
      ? Document_PageAnchor.fromPartial(object.pageAnchor)
      : undefined;
    message.id = object.id ?? "";
    message.normalizedValue = (object.normalizedValue !== undefined && object.normalizedValue !== null)
      ? Document_Entity_NormalizedValue.fromPartial(object.normalizedValue)
      : undefined;
    message.properties = object.properties?.map((e) => Document_Entity.fromPartial(e)) || [];
    message.provenance = (object.provenance !== undefined && object.provenance !== null)
      ? Document_Provenance.fromPartial(object.provenance)
      : undefined;
    message.redacted = object.redacted ?? false;
    return message;
  },
};

function createBaseDocument_Entity_NormalizedValue(): Document_Entity_NormalizedValue {
  return {
    moneyValue: undefined,
    dateValue: undefined,
    datetimeValue: undefined,
    addressValue: undefined,
    booleanValue: undefined,
    integerValue: undefined,
    floatValue: undefined,
    text: "",
  };
}

export const Document_Entity_NormalizedValue: MessageFns<Document_Entity_NormalizedValue> = {
  encode(message: Document_Entity_NormalizedValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.moneyValue !== undefined) {
      Money.encode(message.moneyValue, writer.uint32(18).fork()).join();
    }
    if (message.dateValue !== undefined) {
      DateMessage.encode(message.dateValue, writer.uint32(26).fork()).join();
    }
    if (message.datetimeValue !== undefined) {
      DateTime.encode(message.datetimeValue, writer.uint32(34).fork()).join();
    }
    if (message.addressValue !== undefined) {
      PostalAddress.encode(message.addressValue, writer.uint32(42).fork()).join();
    }
    if (message.booleanValue !== undefined) {
      writer.uint32(48).bool(message.booleanValue);
    }
    if (message.integerValue !== undefined) {
      writer.uint32(56).int32(message.integerValue);
    }
    if (message.floatValue !== undefined) {
      writer.uint32(69).float(message.floatValue);
    }
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Entity_NormalizedValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Entity_NormalizedValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.moneyValue = Money.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dateValue = DateMessage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.datetimeValue = DateTime.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.addressValue = PostalAddress.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.booleanValue = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.integerValue = reader.int32();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.floatValue = reader.float();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Entity_NormalizedValue {
    return {
      moneyValue: isSet(object.moneyValue) ? Money.fromJSON(object.moneyValue) : undefined,
      dateValue: isSet(object.dateValue) ? DateMessage.fromJSON(object.dateValue) : undefined,
      datetimeValue: isSet(object.datetimeValue) ? DateTime.fromJSON(object.datetimeValue) : undefined,
      addressValue: isSet(object.addressValue) ? PostalAddress.fromJSON(object.addressValue) : undefined,
      booleanValue: isSet(object.booleanValue) ? globalThis.Boolean(object.booleanValue) : undefined,
      integerValue: isSet(object.integerValue) ? globalThis.Number(object.integerValue) : undefined,
      floatValue: isSet(object.floatValue) ? globalThis.Number(object.floatValue) : undefined,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: Document_Entity_NormalizedValue): unknown {
    const obj: any = {};
    if (message.moneyValue !== undefined) {
      obj.moneyValue = Money.toJSON(message.moneyValue);
    }
    if (message.dateValue !== undefined) {
      obj.dateValue = DateMessage.toJSON(message.dateValue);
    }
    if (message.datetimeValue !== undefined) {
      obj.datetimeValue = DateTime.toJSON(message.datetimeValue);
    }
    if (message.addressValue !== undefined) {
      obj.addressValue = PostalAddress.toJSON(message.addressValue);
    }
    if (message.booleanValue !== undefined) {
      obj.booleanValue = message.booleanValue;
    }
    if (message.integerValue !== undefined) {
      obj.integerValue = Math.round(message.integerValue);
    }
    if (message.floatValue !== undefined) {
      obj.floatValue = message.floatValue;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Entity_NormalizedValue>): Document_Entity_NormalizedValue {
    return Document_Entity_NormalizedValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Entity_NormalizedValue>): Document_Entity_NormalizedValue {
    const message = createBaseDocument_Entity_NormalizedValue();
    message.moneyValue = (object.moneyValue !== undefined && object.moneyValue !== null)
      ? Money.fromPartial(object.moneyValue)
      : undefined;
    message.dateValue = (object.dateValue !== undefined && object.dateValue !== null)
      ? DateMessage.fromPartial(object.dateValue)
      : undefined;
    message.datetimeValue = (object.datetimeValue !== undefined && object.datetimeValue !== null)
      ? DateTime.fromPartial(object.datetimeValue)
      : undefined;
    message.addressValue = (object.addressValue !== undefined && object.addressValue !== null)
      ? PostalAddress.fromPartial(object.addressValue)
      : undefined;
    message.booleanValue = object.booleanValue ?? undefined;
    message.integerValue = object.integerValue ?? undefined;
    message.floatValue = object.floatValue ?? undefined;
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseDocument_EntityRelation(): Document_EntityRelation {
  return { subjectId: "", objectId: "", relation: "" };
}

export const Document_EntityRelation: MessageFns<Document_EntityRelation> = {
  encode(message: Document_EntityRelation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subjectId !== "") {
      writer.uint32(10).string(message.subjectId);
    }
    if (message.objectId !== "") {
      writer.uint32(18).string(message.objectId);
    }
    if (message.relation !== "") {
      writer.uint32(26).string(message.relation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_EntityRelation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_EntityRelation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.objectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.relation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_EntityRelation {
    return {
      subjectId: isSet(object.subjectId) ? globalThis.String(object.subjectId) : "",
      objectId: isSet(object.objectId) ? globalThis.String(object.objectId) : "",
      relation: isSet(object.relation) ? globalThis.String(object.relation) : "",
    };
  },

  toJSON(message: Document_EntityRelation): unknown {
    const obj: any = {};
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    if (message.objectId !== "") {
      obj.objectId = message.objectId;
    }
    if (message.relation !== "") {
      obj.relation = message.relation;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_EntityRelation>): Document_EntityRelation {
    return Document_EntityRelation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_EntityRelation>): Document_EntityRelation {
    const message = createBaseDocument_EntityRelation();
    message.subjectId = object.subjectId ?? "";
    message.objectId = object.objectId ?? "";
    message.relation = object.relation ?? "";
    return message;
  },
};

function createBaseDocument_TextAnchor(): Document_TextAnchor {
  return { textSegments: [], content: "" };
}

export const Document_TextAnchor: MessageFns<Document_TextAnchor> = {
  encode(message: Document_TextAnchor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.textSegments) {
      Document_TextAnchor_TextSegment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_TextAnchor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_TextAnchor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textSegments.push(Document_TextAnchor_TextSegment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_TextAnchor {
    return {
      textSegments: globalThis.Array.isArray(object?.textSegments)
        ? object.textSegments.map((e: any) => Document_TextAnchor_TextSegment.fromJSON(e))
        : [],
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: Document_TextAnchor): unknown {
    const obj: any = {};
    if (message.textSegments?.length) {
      obj.textSegments = message.textSegments.map((e) => Document_TextAnchor_TextSegment.toJSON(e));
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_TextAnchor>): Document_TextAnchor {
    return Document_TextAnchor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_TextAnchor>): Document_TextAnchor {
    const message = createBaseDocument_TextAnchor();
    message.textSegments = object.textSegments?.map((e) => Document_TextAnchor_TextSegment.fromPartial(e)) || [];
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseDocument_TextAnchor_TextSegment(): Document_TextAnchor_TextSegment {
  return { startIndex: Long.ZERO, endIndex: Long.ZERO };
}

export const Document_TextAnchor_TextSegment: MessageFns<Document_TextAnchor_TextSegment> = {
  encode(message: Document_TextAnchor_TextSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.startIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.startIndex.toString());
    }
    if (!message.endIndex.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endIndex.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_TextAnchor_TextSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_TextAnchor_TextSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startIndex = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endIndex = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_TextAnchor_TextSegment {
    return {
      startIndex: isSet(object.startIndex) ? Long.fromValue(object.startIndex) : Long.ZERO,
      endIndex: isSet(object.endIndex) ? Long.fromValue(object.endIndex) : Long.ZERO,
    };
  },

  toJSON(message: Document_TextAnchor_TextSegment): unknown {
    const obj: any = {};
    if (!message.startIndex.equals(Long.ZERO)) {
      obj.startIndex = (message.startIndex || Long.ZERO).toString();
    }
    if (!message.endIndex.equals(Long.ZERO)) {
      obj.endIndex = (message.endIndex || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Document_TextAnchor_TextSegment>): Document_TextAnchor_TextSegment {
    return Document_TextAnchor_TextSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_TextAnchor_TextSegment>): Document_TextAnchor_TextSegment {
    const message = createBaseDocument_TextAnchor_TextSegment();
    message.startIndex = (object.startIndex !== undefined && object.startIndex !== null)
      ? Long.fromValue(object.startIndex)
      : Long.ZERO;
    message.endIndex = (object.endIndex !== undefined && object.endIndex !== null)
      ? Long.fromValue(object.endIndex)
      : Long.ZERO;
    return message;
  },
};

function createBaseDocument_PageAnchor(): Document_PageAnchor {
  return { pageRefs: [] };
}

export const Document_PageAnchor: MessageFns<Document_PageAnchor> = {
  encode(message: Document_PageAnchor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pageRefs) {
      Document_PageAnchor_PageRef.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_PageAnchor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_PageAnchor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pageRefs.push(Document_PageAnchor_PageRef.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_PageAnchor {
    return {
      pageRefs: globalThis.Array.isArray(object?.pageRefs)
        ? object.pageRefs.map((e: any) => Document_PageAnchor_PageRef.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_PageAnchor): unknown {
    const obj: any = {};
    if (message.pageRefs?.length) {
      obj.pageRefs = message.pageRefs.map((e) => Document_PageAnchor_PageRef.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_PageAnchor>): Document_PageAnchor {
    return Document_PageAnchor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_PageAnchor>): Document_PageAnchor {
    const message = createBaseDocument_PageAnchor();
    message.pageRefs = object.pageRefs?.map((e) => Document_PageAnchor_PageRef.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_PageAnchor_PageRef(): Document_PageAnchor_PageRef {
  return { page: Long.ZERO, layoutType: 0, layoutId: "", boundingPoly: undefined, confidence: 0 };
}

export const Document_PageAnchor_PageRef: MessageFns<Document_PageAnchor_PageRef> = {
  encode(message: Document_PageAnchor_PageRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.page.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.page.toString());
    }
    if (message.layoutType !== 0) {
      writer.uint32(16).int32(message.layoutType);
    }
    if (message.layoutId !== "") {
      writer.uint32(26).string(message.layoutId);
    }
    if (message.boundingPoly !== undefined) {
      BoundingPoly.encode(message.boundingPoly, writer.uint32(34).fork()).join();
    }
    if (message.confidence !== 0) {
      writer.uint32(45).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_PageAnchor_PageRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_PageAnchor_PageRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.page = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.layoutType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.layoutId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.boundingPoly = BoundingPoly.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_PageAnchor_PageRef {
    return {
      page: isSet(object.page) ? Long.fromValue(object.page) : Long.ZERO,
      layoutType: isSet(object.layoutType) ? document_PageAnchor_PageRef_LayoutTypeFromJSON(object.layoutType) : 0,
      layoutId: isSet(object.layoutId) ? globalThis.String(object.layoutId) : "",
      boundingPoly: isSet(object.boundingPoly) ? BoundingPoly.fromJSON(object.boundingPoly) : undefined,
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: Document_PageAnchor_PageRef): unknown {
    const obj: any = {};
    if (!message.page.equals(Long.ZERO)) {
      obj.page = (message.page || Long.ZERO).toString();
    }
    if (message.layoutType !== 0) {
      obj.layoutType = document_PageAnchor_PageRef_LayoutTypeToJSON(message.layoutType);
    }
    if (message.layoutId !== "") {
      obj.layoutId = message.layoutId;
    }
    if (message.boundingPoly !== undefined) {
      obj.boundingPoly = BoundingPoly.toJSON(message.boundingPoly);
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_PageAnchor_PageRef>): Document_PageAnchor_PageRef {
    return Document_PageAnchor_PageRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_PageAnchor_PageRef>): Document_PageAnchor_PageRef {
    const message = createBaseDocument_PageAnchor_PageRef();
    message.page = (object.page !== undefined && object.page !== null) ? Long.fromValue(object.page) : Long.ZERO;
    message.layoutType = object.layoutType ?? 0;
    message.layoutId = object.layoutId ?? "";
    message.boundingPoly = (object.boundingPoly !== undefined && object.boundingPoly !== null)
      ? BoundingPoly.fromPartial(object.boundingPoly)
      : undefined;
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseDocument_Provenance(): Document_Provenance {
  return { revision: 0, id: 0, parents: [], type: 0 };
}

export const Document_Provenance: MessageFns<Document_Provenance> = {
  encode(message: Document_Provenance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.revision !== 0) {
      writer.uint32(8).int32(message.revision);
    }
    if (message.id !== 0) {
      writer.uint32(16).int32(message.id);
    }
    for (const v of message.parents) {
      Document_Provenance_Parent.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Provenance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Provenance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.revision = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parents.push(Document_Provenance_Parent.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Provenance {
    return {
      revision: isSet(object.revision) ? globalThis.Number(object.revision) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      parents: globalThis.Array.isArray(object?.parents)
        ? object.parents.map((e: any) => Document_Provenance_Parent.fromJSON(e))
        : [],
      type: isSet(object.type) ? document_Provenance_OperationTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: Document_Provenance): unknown {
    const obj: any = {};
    if (message.revision !== 0) {
      obj.revision = Math.round(message.revision);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.parents?.length) {
      obj.parents = message.parents.map((e) => Document_Provenance_Parent.toJSON(e));
    }
    if (message.type !== 0) {
      obj.type = document_Provenance_OperationTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Provenance>): Document_Provenance {
    return Document_Provenance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Provenance>): Document_Provenance {
    const message = createBaseDocument_Provenance();
    message.revision = object.revision ?? 0;
    message.id = object.id ?? 0;
    message.parents = object.parents?.map((e) => Document_Provenance_Parent.fromPartial(e)) || [];
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseDocument_Provenance_Parent(): Document_Provenance_Parent {
  return { revision: 0, index: 0, id: 0 };
}

export const Document_Provenance_Parent: MessageFns<Document_Provenance_Parent> = {
  encode(message: Document_Provenance_Parent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.revision !== 0) {
      writer.uint32(8).int32(message.revision);
    }
    if (message.index !== 0) {
      writer.uint32(24).int32(message.index);
    }
    if (message.id !== 0) {
      writer.uint32(16).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Provenance_Parent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Provenance_Parent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.revision = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.id = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Provenance_Parent {
    return {
      revision: isSet(object.revision) ? globalThis.Number(object.revision) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: Document_Provenance_Parent): unknown {
    const obj: any = {};
    if (message.revision !== 0) {
      obj.revision = Math.round(message.revision);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Provenance_Parent>): Document_Provenance_Parent {
    return Document_Provenance_Parent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Provenance_Parent>): Document_Provenance_Parent {
    const message = createBaseDocument_Provenance_Parent();
    message.revision = object.revision ?? 0;
    message.index = object.index ?? 0;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseDocument_Revision(): Document_Revision {
  return {
    agent: undefined,
    processor: undefined,
    id: "",
    parent: [],
    parentIds: [],
    createTime: undefined,
    humanReview: undefined,
  };
}

export const Document_Revision: MessageFns<Document_Revision> = {
  encode(message: Document_Revision, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.agent !== undefined) {
      writer.uint32(34).string(message.agent);
    }
    if (message.processor !== undefined) {
      writer.uint32(42).string(message.processor);
    }
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    writer.uint32(18).fork();
    for (const v of message.parent) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.parentIds) {
      writer.uint32(58).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.humanReview !== undefined) {
      Document_Revision_HumanReview.encode(message.humanReview, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Revision {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Revision();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.agent = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.processor = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.parent.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.parent.push(reader.int32());
            }

            continue;
          }

          break;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.parentIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.humanReview = Document_Revision_HumanReview.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Revision {
    return {
      agent: isSet(object.agent) ? globalThis.String(object.agent) : undefined,
      processor: isSet(object.processor) ? globalThis.String(object.processor) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      parent: globalThis.Array.isArray(object?.parent) ? object.parent.map((e: any) => globalThis.Number(e)) : [],
      parentIds: globalThis.Array.isArray(object?.parentIds)
        ? object.parentIds.map((e: any) => globalThis.String(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      humanReview: isSet(object.humanReview) ? Document_Revision_HumanReview.fromJSON(object.humanReview) : undefined,
    };
  },

  toJSON(message: Document_Revision): unknown {
    const obj: any = {};
    if (message.agent !== undefined) {
      obj.agent = message.agent;
    }
    if (message.processor !== undefined) {
      obj.processor = message.processor;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.parent?.length) {
      obj.parent = message.parent.map((e) => Math.round(e));
    }
    if (message.parentIds?.length) {
      obj.parentIds = message.parentIds;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.humanReview !== undefined) {
      obj.humanReview = Document_Revision_HumanReview.toJSON(message.humanReview);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Revision>): Document_Revision {
    return Document_Revision.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Revision>): Document_Revision {
    const message = createBaseDocument_Revision();
    message.agent = object.agent ?? undefined;
    message.processor = object.processor ?? undefined;
    message.id = object.id ?? "";
    message.parent = object.parent?.map((e) => e) || [];
    message.parentIds = object.parentIds?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.humanReview = (object.humanReview !== undefined && object.humanReview !== null)
      ? Document_Revision_HumanReview.fromPartial(object.humanReview)
      : undefined;
    return message;
  },
};

function createBaseDocument_Revision_HumanReview(): Document_Revision_HumanReview {
  return { state: "", stateMessage: "" };
}

export const Document_Revision_HumanReview: MessageFns<Document_Revision_HumanReview> = {
  encode(message: Document_Revision_HumanReview, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== "") {
      writer.uint32(10).string(message.state);
    }
    if (message.stateMessage !== "") {
      writer.uint32(18).string(message.stateMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Revision_HumanReview {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Revision_HumanReview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.state = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stateMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Revision_HumanReview {
    return {
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      stateMessage: isSet(object.stateMessage) ? globalThis.String(object.stateMessage) : "",
    };
  },

  toJSON(message: Document_Revision_HumanReview): unknown {
    const obj: any = {};
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.stateMessage !== "") {
      obj.stateMessage = message.stateMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Revision_HumanReview>): Document_Revision_HumanReview {
    return Document_Revision_HumanReview.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Revision_HumanReview>): Document_Revision_HumanReview {
    const message = createBaseDocument_Revision_HumanReview();
    message.state = object.state ?? "";
    message.stateMessage = object.stateMessage ?? "";
    return message;
  },
};

function createBaseDocument_TextChange(): Document_TextChange {
  return { textAnchor: undefined, changedText: "", provenance: [] };
}

export const Document_TextChange: MessageFns<Document_TextChange> = {
  encode(message: Document_TextChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textAnchor !== undefined) {
      Document_TextAnchor.encode(message.textAnchor, writer.uint32(10).fork()).join();
    }
    if (message.changedText !== "") {
      writer.uint32(18).string(message.changedText);
    }
    for (const v of message.provenance) {
      Document_Provenance.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_TextChange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_TextChange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textAnchor = Document_TextAnchor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.changedText = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.provenance.push(Document_Provenance.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_TextChange {
    return {
      textAnchor: isSet(object.textAnchor) ? Document_TextAnchor.fromJSON(object.textAnchor) : undefined,
      changedText: isSet(object.changedText) ? globalThis.String(object.changedText) : "",
      provenance: globalThis.Array.isArray(object?.provenance)
        ? object.provenance.map((e: any) => Document_Provenance.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_TextChange): unknown {
    const obj: any = {};
    if (message.textAnchor !== undefined) {
      obj.textAnchor = Document_TextAnchor.toJSON(message.textAnchor);
    }
    if (message.changedText !== "") {
      obj.changedText = message.changedText;
    }
    if (message.provenance?.length) {
      obj.provenance = message.provenance.map((e) => Document_Provenance.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_TextChange>): Document_TextChange {
    return Document_TextChange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_TextChange>): Document_TextChange {
    const message = createBaseDocument_TextChange();
    message.textAnchor = (object.textAnchor !== undefined && object.textAnchor !== null)
      ? Document_TextAnchor.fromPartial(object.textAnchor)
      : undefined;
    message.changedText = object.changedText ?? "";
    message.provenance = object.provenance?.map((e) => Document_Provenance.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_DocumentLayout(): Document_DocumentLayout {
  return { blocks: [] };
}

export const Document_DocumentLayout: MessageFns<Document_DocumentLayout> = {
  encode(message: Document_DocumentLayout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.blocks) {
      Document_DocumentLayout_DocumentLayoutBlock.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_DocumentLayout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_DocumentLayout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blocks.push(Document_DocumentLayout_DocumentLayoutBlock.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_DocumentLayout {
    return {
      blocks: globalThis.Array.isArray(object?.blocks)
        ? object.blocks.map((e: any) => Document_DocumentLayout_DocumentLayoutBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_DocumentLayout): unknown {
    const obj: any = {};
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => Document_DocumentLayout_DocumentLayoutBlock.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_DocumentLayout>): Document_DocumentLayout {
    return Document_DocumentLayout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_DocumentLayout>): Document_DocumentLayout {
    const message = createBaseDocument_DocumentLayout();
    message.blocks = object.blocks?.map((e) => Document_DocumentLayout_DocumentLayoutBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_DocumentLayout_DocumentLayoutBlock(): Document_DocumentLayout_DocumentLayoutBlock {
  return { textBlock: undefined, tableBlock: undefined, listBlock: undefined, blockId: "", pageSpan: undefined };
}

export const Document_DocumentLayout_DocumentLayoutBlock: MessageFns<Document_DocumentLayout_DocumentLayoutBlock> = {
  encode(
    message: Document_DocumentLayout_DocumentLayoutBlock,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.textBlock !== undefined) {
      Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock.encode(message.textBlock, writer.uint32(18).fork())
        .join();
    }
    if (message.tableBlock !== undefined) {
      Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock.encode(message.tableBlock, writer.uint32(26).fork())
        .join();
    }
    if (message.listBlock !== undefined) {
      Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock.encode(message.listBlock, writer.uint32(34).fork())
        .join();
    }
    if (message.blockId !== "") {
      writer.uint32(10).string(message.blockId);
    }
    if (message.pageSpan !== undefined) {
      Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan.encode(message.pageSpan, writer.uint32(42).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_DocumentLayout_DocumentLayoutBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.textBlock = Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tableBlock = Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.listBlock = Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blockId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageSpan = Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_DocumentLayout_DocumentLayoutBlock {
    return {
      textBlock: isSet(object.textBlock)
        ? Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock.fromJSON(object.textBlock)
        : undefined,
      tableBlock: isSet(object.tableBlock)
        ? Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock.fromJSON(object.tableBlock)
        : undefined,
      listBlock: isSet(object.listBlock)
        ? Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock.fromJSON(object.listBlock)
        : undefined,
      blockId: isSet(object.blockId) ? globalThis.String(object.blockId) : "",
      pageSpan: isSet(object.pageSpan)
        ? Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan.fromJSON(object.pageSpan)
        : undefined,
    };
  },

  toJSON(message: Document_DocumentLayout_DocumentLayoutBlock): unknown {
    const obj: any = {};
    if (message.textBlock !== undefined) {
      obj.textBlock = Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock.toJSON(message.textBlock);
    }
    if (message.tableBlock !== undefined) {
      obj.tableBlock = Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock.toJSON(message.tableBlock);
    }
    if (message.listBlock !== undefined) {
      obj.listBlock = Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock.toJSON(message.listBlock);
    }
    if (message.blockId !== "") {
      obj.blockId = message.blockId;
    }
    if (message.pageSpan !== undefined) {
      obj.pageSpan = Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan.toJSON(message.pageSpan);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock>): Document_DocumentLayout_DocumentLayoutBlock {
    return Document_DocumentLayout_DocumentLayoutBlock.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock>,
  ): Document_DocumentLayout_DocumentLayoutBlock {
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock();
    message.textBlock = (object.textBlock !== undefined && object.textBlock !== null)
      ? Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock.fromPartial(object.textBlock)
      : undefined;
    message.tableBlock = (object.tableBlock !== undefined && object.tableBlock !== null)
      ? Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock.fromPartial(object.tableBlock)
      : undefined;
    message.listBlock = (object.listBlock !== undefined && object.listBlock !== null)
      ? Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock.fromPartial(object.listBlock)
      : undefined;
    message.blockId = object.blockId ?? "";
    message.pageSpan = (object.pageSpan !== undefined && object.pageSpan !== null)
      ? Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan.fromPartial(object.pageSpan)
      : undefined;
    return message;
  },
};

function createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan(): Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan {
  return { pageStart: 0, pageEnd: 0 };
}

export const Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan: MessageFns<
  Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan
> = {
  encode(
    message: Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pageStart !== 0) {
      writer.uint32(8).int32(message.pageStart);
    }
    if (message.pageEnd !== 0) {
      writer.uint32(16).int32(message.pageEnd);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageStart = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageEnd = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan {
    return {
      pageStart: isSet(object.pageStart) ? globalThis.Number(object.pageStart) : 0,
      pageEnd: isSet(object.pageEnd) ? globalThis.Number(object.pageEnd) : 0,
    };
  },

  toJSON(message: Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan): unknown {
    const obj: any = {};
    if (message.pageStart !== 0) {
      obj.pageStart = Math.round(message.pageStart);
    }
    if (message.pageEnd !== 0) {
      obj.pageEnd = Math.round(message.pageEnd);
    }
    return obj;
  },

  create(
    base?: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan {
    return Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan {
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutPageSpan();
    message.pageStart = object.pageStart ?? 0;
    message.pageEnd = object.pageEnd ?? 0;
    return message;
  },
};

function createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock(): Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock {
  return { text: "", type: "", blocks: [] };
}

export const Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock: MessageFns<
  Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock
> = {
  encode(
    message: Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    for (const v of message.blocks) {
      Document_DocumentLayout_DocumentLayoutBlock.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.blocks.push(Document_DocumentLayout_DocumentLayoutBlock.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      blocks: globalThis.Array.isArray(object?.blocks)
        ? object.blocks.map((e: any) => Document_DocumentLayout_DocumentLayoutBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => Document_DocumentLayout_DocumentLayoutBlock.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock {
    return Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock {
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTextBlock();
    message.text = object.text ?? "";
    message.type = object.type ?? "";
    message.blocks = object.blocks?.map((e) => Document_DocumentLayout_DocumentLayoutBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock(): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock {
  return { headerRows: [], bodyRows: [], caption: "" };
}

export const Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock: MessageFns<
  Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock
> = {
  encode(
    message: Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.headerRows) {
      Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.bodyRows) {
      Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.caption !== "") {
      writer.uint32(26).string(message.caption);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.headerRows.push(
            Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.bodyRows.push(
            Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.caption = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock {
    return {
      headerRows: globalThis.Array.isArray(object?.headerRows)
        ? object.headerRows.map((e: any) => Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow.fromJSON(e))
        : [],
      bodyRows: globalThis.Array.isArray(object?.bodyRows)
        ? object.bodyRows.map((e: any) => Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow.fromJSON(e))
        : [],
      caption: isSet(object.caption) ? globalThis.String(object.caption) : "",
    };
  },

  toJSON(message: Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock): unknown {
    const obj: any = {};
    if (message.headerRows?.length) {
      obj.headerRows = message.headerRows.map((e) =>
        Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow.toJSON(e)
      );
    }
    if (message.bodyRows?.length) {
      obj.bodyRows = message.bodyRows.map((e) => Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow.toJSON(e));
    }
    if (message.caption !== "") {
      obj.caption = message.caption;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock {
    return Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock {
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTableBlock();
    message.headerRows =
      object.headerRows?.map((e) => Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow.fromPartial(e)) || [];
    message.bodyRows =
      object.bodyRows?.map((e) => Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow.fromPartial(e)) || [];
    message.caption = object.caption ?? "";
    return message;
  },
};

function createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTableRow(): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow {
  return { cells: [] };
}

export const Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow: MessageFns<
  Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow
> = {
  encode(
    message: Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.cells) {
      Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTableRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cells.push(
            Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow {
    return {
      cells: globalThis.Array.isArray(object?.cells)
        ? object.cells.map((e: any) => Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow): unknown {
    const obj: any = {};
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow {
    return Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableRow {
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTableRow();
    message.cells =
      object.cells?.map((e) => Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTableCell(): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell {
  return { blocks: [], rowSpan: 0, colSpan: 0 };
}

export const Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell: MessageFns<
  Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell
> = {
  encode(
    message: Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.blocks) {
      Document_DocumentLayout_DocumentLayoutBlock.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.rowSpan !== 0) {
      writer.uint32(16).int32(message.rowSpan);
    }
    if (message.colSpan !== 0) {
      writer.uint32(24).int32(message.colSpan);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTableCell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blocks.push(Document_DocumentLayout_DocumentLayoutBlock.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.rowSpan = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.colSpan = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell {
    return {
      blocks: globalThis.Array.isArray(object?.blocks)
        ? object.blocks.map((e: any) => Document_DocumentLayout_DocumentLayoutBlock.fromJSON(e))
        : [],
      rowSpan: isSet(object.rowSpan) ? globalThis.Number(object.rowSpan) : 0,
      colSpan: isSet(object.colSpan) ? globalThis.Number(object.colSpan) : 0,
    };
  },

  toJSON(message: Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell): unknown {
    const obj: any = {};
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => Document_DocumentLayout_DocumentLayoutBlock.toJSON(e));
    }
    if (message.rowSpan !== 0) {
      obj.rowSpan = Math.round(message.rowSpan);
    }
    if (message.colSpan !== 0) {
      obj.colSpan = Math.round(message.colSpan);
    }
    return obj;
  },

  create(
    base?: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell {
    return Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutTableCell {
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutTableCell();
    message.blocks = object.blocks?.map((e) => Document_DocumentLayout_DocumentLayoutBlock.fromPartial(e)) || [];
    message.rowSpan = object.rowSpan ?? 0;
    message.colSpan = object.colSpan ?? 0;
    return message;
  },
};

function createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutListBlock(): Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock {
  return { listEntries: [], type: "" };
}

export const Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock: MessageFns<
  Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock
> = {
  encode(
    message: Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.listEntries) {
      Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutListBlock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.listEntries.push(
            Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry.decode(reader, reader.uint32()),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock {
    return {
      listEntries: globalThis.Array.isArray(object?.listEntries)
        ? object.listEntries.map((e: any) => Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry.fromJSON(e))
        : [],
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock): unknown {
    const obj: any = {};
    if (message.listEntries?.length) {
      obj.listEntries = message.listEntries.map((e) =>
        Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry.toJSON(e)
      );
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock {
    return Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutListBlock {
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutListBlock();
    message.listEntries =
      object.listEntries?.map((e) => Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry.fromPartial(e)) || [];
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutListEntry(): Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry {
  return { blocks: [] };
}

export const Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry: MessageFns<
  Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry
> = {
  encode(
    message: Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.blocks) {
      Document_DocumentLayout_DocumentLayoutBlock.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutListEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.blocks.push(Document_DocumentLayout_DocumentLayoutBlock.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry {
    return {
      blocks: globalThis.Array.isArray(object?.blocks)
        ? object.blocks.map((e: any) => Document_DocumentLayout_DocumentLayoutBlock.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry): unknown {
    const obj: any = {};
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => Document_DocumentLayout_DocumentLayoutBlock.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry {
    return Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry>,
  ): Document_DocumentLayout_DocumentLayoutBlock_LayoutListEntry {
    const message = createBaseDocument_DocumentLayout_DocumentLayoutBlock_LayoutListEntry();
    message.blocks = object.blocks?.map((e) => Document_DocumentLayout_DocumentLayoutBlock.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_ChunkedDocument(): Document_ChunkedDocument {
  return { chunks: [] };
}

export const Document_ChunkedDocument: MessageFns<Document_ChunkedDocument> = {
  encode(message: Document_ChunkedDocument, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.chunks) {
      Document_ChunkedDocument_Chunk.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_ChunkedDocument {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_ChunkedDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chunks.push(Document_ChunkedDocument_Chunk.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_ChunkedDocument {
    return {
      chunks: globalThis.Array.isArray(object?.chunks)
        ? object.chunks.map((e: any) => Document_ChunkedDocument_Chunk.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_ChunkedDocument): unknown {
    const obj: any = {};
    if (message.chunks?.length) {
      obj.chunks = message.chunks.map((e) => Document_ChunkedDocument_Chunk.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_ChunkedDocument>): Document_ChunkedDocument {
    return Document_ChunkedDocument.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_ChunkedDocument>): Document_ChunkedDocument {
    const message = createBaseDocument_ChunkedDocument();
    message.chunks = object.chunks?.map((e) => Document_ChunkedDocument_Chunk.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_ChunkedDocument_Chunk(): Document_ChunkedDocument_Chunk {
  return { chunkId: "", sourceBlockIds: [], content: "", pageSpan: undefined, pageHeaders: [], pageFooters: [] };
}

export const Document_ChunkedDocument_Chunk: MessageFns<Document_ChunkedDocument_Chunk> = {
  encode(message: Document_ChunkedDocument_Chunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chunkId !== "") {
      writer.uint32(10).string(message.chunkId);
    }
    for (const v of message.sourceBlockIds) {
      writer.uint32(18).string(v!);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.pageSpan !== undefined) {
      Document_ChunkedDocument_Chunk_ChunkPageSpan.encode(message.pageSpan, writer.uint32(34).fork()).join();
    }
    for (const v of message.pageHeaders) {
      Document_ChunkedDocument_Chunk_ChunkPageHeader.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.pageFooters) {
      Document_ChunkedDocument_Chunk_ChunkPageFooter.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_ChunkedDocument_Chunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_ChunkedDocument_Chunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chunkId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourceBlockIds.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageSpan = Document_ChunkedDocument_Chunk_ChunkPageSpan.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.pageHeaders.push(Document_ChunkedDocument_Chunk_ChunkPageHeader.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pageFooters.push(Document_ChunkedDocument_Chunk_ChunkPageFooter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_ChunkedDocument_Chunk {
    return {
      chunkId: isSet(object.chunkId) ? globalThis.String(object.chunkId) : "",
      sourceBlockIds: globalThis.Array.isArray(object?.sourceBlockIds)
        ? object.sourceBlockIds.map((e: any) => globalThis.String(e))
        : [],
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      pageSpan: isSet(object.pageSpan)
        ? Document_ChunkedDocument_Chunk_ChunkPageSpan.fromJSON(object.pageSpan)
        : undefined,
      pageHeaders: globalThis.Array.isArray(object?.pageHeaders)
        ? object.pageHeaders.map((e: any) => Document_ChunkedDocument_Chunk_ChunkPageHeader.fromJSON(e))
        : [],
      pageFooters: globalThis.Array.isArray(object?.pageFooters)
        ? object.pageFooters.map((e: any) => Document_ChunkedDocument_Chunk_ChunkPageFooter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_ChunkedDocument_Chunk): unknown {
    const obj: any = {};
    if (message.chunkId !== "") {
      obj.chunkId = message.chunkId;
    }
    if (message.sourceBlockIds?.length) {
      obj.sourceBlockIds = message.sourceBlockIds;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.pageSpan !== undefined) {
      obj.pageSpan = Document_ChunkedDocument_Chunk_ChunkPageSpan.toJSON(message.pageSpan);
    }
    if (message.pageHeaders?.length) {
      obj.pageHeaders = message.pageHeaders.map((e) => Document_ChunkedDocument_Chunk_ChunkPageHeader.toJSON(e));
    }
    if (message.pageFooters?.length) {
      obj.pageFooters = message.pageFooters.map((e) => Document_ChunkedDocument_Chunk_ChunkPageFooter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_ChunkedDocument_Chunk>): Document_ChunkedDocument_Chunk {
    return Document_ChunkedDocument_Chunk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_ChunkedDocument_Chunk>): Document_ChunkedDocument_Chunk {
    const message = createBaseDocument_ChunkedDocument_Chunk();
    message.chunkId = object.chunkId ?? "";
    message.sourceBlockIds = object.sourceBlockIds?.map((e) => e) || [];
    message.content = object.content ?? "";
    message.pageSpan = (object.pageSpan !== undefined && object.pageSpan !== null)
      ? Document_ChunkedDocument_Chunk_ChunkPageSpan.fromPartial(object.pageSpan)
      : undefined;
    message.pageHeaders =
      object.pageHeaders?.map((e) => Document_ChunkedDocument_Chunk_ChunkPageHeader.fromPartial(e)) || [];
    message.pageFooters =
      object.pageFooters?.map((e) => Document_ChunkedDocument_Chunk_ChunkPageFooter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_ChunkedDocument_Chunk_ChunkPageSpan(): Document_ChunkedDocument_Chunk_ChunkPageSpan {
  return { pageStart: 0, pageEnd: 0 };
}

export const Document_ChunkedDocument_Chunk_ChunkPageSpan: MessageFns<Document_ChunkedDocument_Chunk_ChunkPageSpan> = {
  encode(
    message: Document_ChunkedDocument_Chunk_ChunkPageSpan,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.pageStart !== 0) {
      writer.uint32(8).int32(message.pageStart);
    }
    if (message.pageEnd !== 0) {
      writer.uint32(16).int32(message.pageEnd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_ChunkedDocument_Chunk_ChunkPageSpan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_ChunkedDocument_Chunk_ChunkPageSpan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageStart = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageEnd = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_ChunkedDocument_Chunk_ChunkPageSpan {
    return {
      pageStart: isSet(object.pageStart) ? globalThis.Number(object.pageStart) : 0,
      pageEnd: isSet(object.pageEnd) ? globalThis.Number(object.pageEnd) : 0,
    };
  },

  toJSON(message: Document_ChunkedDocument_Chunk_ChunkPageSpan): unknown {
    const obj: any = {};
    if (message.pageStart !== 0) {
      obj.pageStart = Math.round(message.pageStart);
    }
    if (message.pageEnd !== 0) {
      obj.pageEnd = Math.round(message.pageEnd);
    }
    return obj;
  },

  create(
    base?: DeepPartial<Document_ChunkedDocument_Chunk_ChunkPageSpan>,
  ): Document_ChunkedDocument_Chunk_ChunkPageSpan {
    return Document_ChunkedDocument_Chunk_ChunkPageSpan.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_ChunkedDocument_Chunk_ChunkPageSpan>,
  ): Document_ChunkedDocument_Chunk_ChunkPageSpan {
    const message = createBaseDocument_ChunkedDocument_Chunk_ChunkPageSpan();
    message.pageStart = object.pageStart ?? 0;
    message.pageEnd = object.pageEnd ?? 0;
    return message;
  },
};

function createBaseDocument_ChunkedDocument_Chunk_ChunkPageHeader(): Document_ChunkedDocument_Chunk_ChunkPageHeader {
  return { text: "", pageSpan: undefined };
}

export const Document_ChunkedDocument_Chunk_ChunkPageHeader: MessageFns<
  Document_ChunkedDocument_Chunk_ChunkPageHeader
> = {
  encode(
    message: Document_ChunkedDocument_Chunk_ChunkPageHeader,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.pageSpan !== undefined) {
      Document_ChunkedDocument_Chunk_ChunkPageSpan.encode(message.pageSpan, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_ChunkedDocument_Chunk_ChunkPageHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_ChunkedDocument_Chunk_ChunkPageHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageSpan = Document_ChunkedDocument_Chunk_ChunkPageSpan.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_ChunkedDocument_Chunk_ChunkPageHeader {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      pageSpan: isSet(object.pageSpan)
        ? Document_ChunkedDocument_Chunk_ChunkPageSpan.fromJSON(object.pageSpan)
        : undefined,
    };
  },

  toJSON(message: Document_ChunkedDocument_Chunk_ChunkPageHeader): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.pageSpan !== undefined) {
      obj.pageSpan = Document_ChunkedDocument_Chunk_ChunkPageSpan.toJSON(message.pageSpan);
    }
    return obj;
  },

  create(
    base?: DeepPartial<Document_ChunkedDocument_Chunk_ChunkPageHeader>,
  ): Document_ChunkedDocument_Chunk_ChunkPageHeader {
    return Document_ChunkedDocument_Chunk_ChunkPageHeader.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_ChunkedDocument_Chunk_ChunkPageHeader>,
  ): Document_ChunkedDocument_Chunk_ChunkPageHeader {
    const message = createBaseDocument_ChunkedDocument_Chunk_ChunkPageHeader();
    message.text = object.text ?? "";
    message.pageSpan = (object.pageSpan !== undefined && object.pageSpan !== null)
      ? Document_ChunkedDocument_Chunk_ChunkPageSpan.fromPartial(object.pageSpan)
      : undefined;
    return message;
  },
};

function createBaseDocument_ChunkedDocument_Chunk_ChunkPageFooter(): Document_ChunkedDocument_Chunk_ChunkPageFooter {
  return { text: "", pageSpan: undefined };
}

export const Document_ChunkedDocument_Chunk_ChunkPageFooter: MessageFns<
  Document_ChunkedDocument_Chunk_ChunkPageFooter
> = {
  encode(
    message: Document_ChunkedDocument_Chunk_ChunkPageFooter,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.pageSpan !== undefined) {
      Document_ChunkedDocument_Chunk_ChunkPageSpan.encode(message.pageSpan, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_ChunkedDocument_Chunk_ChunkPageFooter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_ChunkedDocument_Chunk_ChunkPageFooter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageSpan = Document_ChunkedDocument_Chunk_ChunkPageSpan.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_ChunkedDocument_Chunk_ChunkPageFooter {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      pageSpan: isSet(object.pageSpan)
        ? Document_ChunkedDocument_Chunk_ChunkPageSpan.fromJSON(object.pageSpan)
        : undefined,
    };
  },

  toJSON(message: Document_ChunkedDocument_Chunk_ChunkPageFooter): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.pageSpan !== undefined) {
      obj.pageSpan = Document_ChunkedDocument_Chunk_ChunkPageSpan.toJSON(message.pageSpan);
    }
    return obj;
  },

  create(
    base?: DeepPartial<Document_ChunkedDocument_Chunk_ChunkPageFooter>,
  ): Document_ChunkedDocument_Chunk_ChunkPageFooter {
    return Document_ChunkedDocument_Chunk_ChunkPageFooter.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Document_ChunkedDocument_Chunk_ChunkPageFooter>,
  ): Document_ChunkedDocument_Chunk_ChunkPageFooter {
    const message = createBaseDocument_ChunkedDocument_Chunk_ChunkPageFooter();
    message.text = object.text ?? "";
    message.pageSpan = (object.pageSpan !== undefined && object.pageSpan !== null)
      ? Document_ChunkedDocument_Chunk_ChunkPageSpan.fromPartial(object.pageSpan)
      : undefined;
    return message;
  },
};

function createBaseRevisionRef(): RevisionRef {
  return { revisionCase: undefined, revisionId: undefined, latestProcessorVersion: undefined };
}

export const RevisionRef: MessageFns<RevisionRef> = {
  encode(message: RevisionRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.revisionCase !== undefined) {
      writer.uint32(8).int32(message.revisionCase);
    }
    if (message.revisionId !== undefined) {
      writer.uint32(18).string(message.revisionId);
    }
    if (message.latestProcessorVersion !== undefined) {
      writer.uint32(26).string(message.latestProcessorVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevisionRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevisionRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.revisionCase = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.latestProcessorVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevisionRef {
    return {
      revisionCase: isSet(object.revisionCase) ? revisionRef_RevisionCaseFromJSON(object.revisionCase) : undefined,
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : undefined,
      latestProcessorVersion: isSet(object.latestProcessorVersion)
        ? globalThis.String(object.latestProcessorVersion)
        : undefined,
    };
  },

  toJSON(message: RevisionRef): unknown {
    const obj: any = {};
    if (message.revisionCase !== undefined) {
      obj.revisionCase = revisionRef_RevisionCaseToJSON(message.revisionCase);
    }
    if (message.revisionId !== undefined) {
      obj.revisionId = message.revisionId;
    }
    if (message.latestProcessorVersion !== undefined) {
      obj.latestProcessorVersion = message.latestProcessorVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<RevisionRef>): RevisionRef {
    return RevisionRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RevisionRef>): RevisionRef {
    const message = createBaseRevisionRef();
    message.revisionCase = object.revisionCase ?? undefined;
    message.revisionId = object.revisionId ?? undefined;
    message.latestProcessorVersion = object.latestProcessorVersion ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
