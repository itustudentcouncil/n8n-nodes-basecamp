// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/documentai/v1beta1/document_understanding.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { BoundingPoly } from "./geometry.js";

export const protobufPackage = "google.cloud.documentai.v1beta1";

/** Request to batch process documents as an asynchronous operation. */
export interface BatchProcessDocumentsRequest {
  /** Required. Individual requests for each document. */
  requests: ProcessDocumentRequest[];
  /**
   * Target project and location to make a call.
   *
   * Format: `projects/{project-id}/locations/{location-id}`.
   *
   * If no location is specified, a region will be chosen automatically.
   */
  parent: string;
}

/** Request to process one document. */
export interface ProcessDocumentRequest {
  /** Required. Information about the input file. */
  inputConfig:
    | InputConfig
    | undefined;
  /** Required. The desired output location. */
  outputConfig:
    | OutputConfig
    | undefined;
  /**
   * Specifies a known document type for deeper structure detection. Valid
   * values are currently "general" and "invoice". If not provided, "general"\
   * is used as default. If any other value is given, the request is rejected.
   */
  documentType: string;
  /**
   * Controls table extraction behavior. If not specified, the system will
   * decide reasonable defaults.
   */
  tableExtractionParams:
    | TableExtractionParams
    | undefined;
  /**
   * Controls form extraction behavior. If not specified, the system will
   * decide reasonable defaults.
   */
  formExtractionParams:
    | FormExtractionParams
    | undefined;
  /**
   * Controls entity extraction behavior. If not specified, the system will
   * decide reasonable defaults.
   */
  entityExtractionParams:
    | EntityExtractionParams
    | undefined;
  /**
   * Controls OCR behavior. If not specified, the system will decide reasonable
   * defaults.
   */
  ocrParams: OcrParams | undefined;
}

/**
 * Response to an batch document processing request. This is returned in
 * the LRO Operation after the operation is complete.
 */
export interface BatchProcessDocumentsResponse {
  /** Responses for each individual document. */
  responses: ProcessDocumentResponse[];
}

/** Response to a single document processing request. */
export interface ProcessDocumentResponse {
  /**
   * Information about the input file. This is the same as the corresponding
   * input config in the request.
   */
  inputConfig:
    | InputConfig
    | undefined;
  /**
   * The output location of the parsed responses. The responses are written to
   * this location as JSON-serialized `Document` objects.
   */
  outputConfig: OutputConfig | undefined;
}

/** Parameters to control Optical Character Recognition (OCR) behavior. */
export interface OcrParams {
  /**
   * List of languages to use for OCR. In most cases, an empty value
   * yields the best results since it enables automatic language detection. For
   * languages based on the Latin alphabet, setting `language_hints` is not
   * needed. In rare cases, when the language of the text in the image is known,
   * setting a hint will help get better results (although it will be a
   * significant hindrance if the hint is wrong). Document processing returns an
   * error if one or more of the specified languages is not one of the
   * supported languages.
   */
  languageHints: string[];
}

/** Parameters to control table extraction behavior. */
export interface TableExtractionParams {
  /** Whether to enable table extraction. */
  enabled: boolean;
  /**
   * Optional. Table bounding box hints that can be provided to complex cases
   * which our algorithm cannot locate the table(s) in.
   */
  tableBoundHints: TableBoundHint[];
  /**
   * Optional. Table header hints. The extraction will bias towards producing
   * these terms as table headers, which may improve accuracy.
   */
  headerHints: string[];
  /**
   * Model version of the table extraction system. Default is "builtin/stable".
   * Specify "builtin/latest" for the latest model.
   */
  modelVersion: string;
}

/** A hint for a table bounding box on the page for table parsing. */
export interface TableBoundHint {
  /**
   * Optional. Page number for multi-paged inputs this hint applies to. If not
   * provided, this hint will apply to all pages by default. This value is
   * 1-based.
   */
  pageNumber: number;
  /**
   * Bounding box hint for a table on this page. The coordinates must be
   * normalized to [0,1] and the bounding box must be an axis-aligned rectangle.
   */
  boundingBox: BoundingPoly | undefined;
}

/** Parameters to control form extraction behavior. */
export interface FormExtractionParams {
  /** Whether to enable form extraction. */
  enabled: boolean;
  /**
   * User can provide pairs of (key text, value type) to improve the parsing
   * result.
   *
   * For example, if a document has a field called "Date" that holds a date
   * value and a field called "Amount" that may hold either a currency value
   * (e.g., "$500.00") or a simple number value (e.g., "20"), you could use the
   * following hints: [ {"key": "Date", value_types: [ "DATE"]}, {"key":
   * "Amount", "value_types": [ "PRICE", "NUMBER" ]} ]
   *
   * If the value type is unknown, but you want to provide hints for the keys,
   * you can leave the value_types field blank. e.g. {"key": "Date",
   * "value_types": []}
   */
  keyValuePairHints: KeyValuePairHint[];
  /**
   * Model version of the form extraction system. Default is
   * "builtin/stable". Specify "builtin/latest" for the latest model.
   */
  modelVersion: string;
}

/** User-provided hint for key value pair. */
export interface KeyValuePairHint {
  /** The key text for the hint. */
  key: string;
  /**
   * Type of the value. This is case-insensitive, and could be one of:
   * ADDRESS, LOCATION, ORGANIZATION, PERSON, PHONE_NUMBER,
   * ID, NUMBER, EMAIL, PRICE, TERMS, DATE, NAME. Types not in this list will
   * be ignored.
   */
  valueTypes: string[];
}

/** Parameters to control entity extraction behavior. */
export interface EntityExtractionParams {
  /** Whether to enable entity extraction. */
  enabled: boolean;
  /**
   * Model version of the entity extraction. Default is
   * "builtin/stable". Specify "builtin/latest" for the latest model.
   */
  modelVersion: string;
}

/** The desired input location and metadata. */
export interface InputConfig {
  /**
   * The Google Cloud Storage location to read the input from. This must be a
   * single file.
   */
  gcsSource?:
    | GcsSource
    | undefined;
  /**
   * Required. Mimetype of the input. Current supported mimetypes are
   * application/pdf, image/tiff, and image/gif.
   */
  mimeType: string;
}

/** The desired output location and metadata. */
export interface OutputConfig {
  /** The Google Cloud Storage location to write the output to. */
  gcsDestination?:
    | GcsDestination
    | undefined;
  /**
   * The max number of pages to include into each output Document shard JSON on
   * Google Cloud Storage.
   *
   * The valid range is [1, 100]. If not specified, the default value is 20.
   *
   * For example, for one pdf file with 100 pages, 100 parsed pages will be
   * produced. If `pages_per_shard` = 20, then 5 Document shard JSON files each
   * containing 20 parsed pages will be written under the prefix
   * [OutputConfig.gcs_destination.uri][] and suffix pages-x-to-y.json where
   * x and y are 1-indexed page numbers.
   *
   * Example GCS outputs with 157 pages and pages_per_shard = 50:
   *
   * <prefix>pages-001-to-050.json
   * <prefix>pages-051-to-100.json
   * <prefix>pages-101-to-150.json
   * <prefix>pages-151-to-157.json
   */
  pagesPerShard: number;
}

/** The Google Cloud Storage location where the input file will be read from. */
export interface GcsSource {
  uri: string;
}

/** The Google Cloud Storage location where the output file will be written to. */
export interface GcsDestination {
  uri: string;
}

/** Contains metadata for the BatchProcessDocuments operation. */
export interface OperationMetadata {
  /** The state of the current batch processing. */
  state: OperationMetadata_State;
  /** A message providing more details about the current state of processing. */
  stateMessage: string;
  /** The creation time of the operation. */
  createTime:
    | Date
    | undefined;
  /** The last update time of the operation. */
  updateTime: Date | undefined;
}

export enum OperationMetadata_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** ACCEPTED - Request is received. */
  ACCEPTED = 1,
  /** WAITING - Request operation is waiting for scheduling. */
  WAITING = 2,
  /** RUNNING - Request is being processed. */
  RUNNING = 3,
  /** SUCCEEDED - The batch processing completed successfully. */
  SUCCEEDED = 4,
  /** CANCELLED - The batch processing was cancelled. */
  CANCELLED = 5,
  /** FAILED - The batch processing has failed. */
  FAILED = 6,
  UNRECOGNIZED = -1,
}

export function operationMetadata_StateFromJSON(object: any): OperationMetadata_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return OperationMetadata_State.STATE_UNSPECIFIED;
    case 1:
    case "ACCEPTED":
      return OperationMetadata_State.ACCEPTED;
    case 2:
    case "WAITING":
      return OperationMetadata_State.WAITING;
    case 3:
    case "RUNNING":
      return OperationMetadata_State.RUNNING;
    case 4:
    case "SUCCEEDED":
      return OperationMetadata_State.SUCCEEDED;
    case 5:
    case "CANCELLED":
      return OperationMetadata_State.CANCELLED;
    case 6:
    case "FAILED":
      return OperationMetadata_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OperationMetadata_State.UNRECOGNIZED;
  }
}

export function operationMetadata_StateToJSON(object: OperationMetadata_State): string {
  switch (object) {
    case OperationMetadata_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case OperationMetadata_State.ACCEPTED:
      return "ACCEPTED";
    case OperationMetadata_State.WAITING:
      return "WAITING";
    case OperationMetadata_State.RUNNING:
      return "RUNNING";
    case OperationMetadata_State.SUCCEEDED:
      return "SUCCEEDED";
    case OperationMetadata_State.CANCELLED:
      return "CANCELLED";
    case OperationMetadata_State.FAILED:
      return "FAILED";
    case OperationMetadata_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseBatchProcessDocumentsRequest(): BatchProcessDocumentsRequest {
  return { requests: [], parent: "" };
}

export const BatchProcessDocumentsRequest: MessageFns<BatchProcessDocumentsRequest> = {
  encode(message: BatchProcessDocumentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requests) {
      ProcessDocumentRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.parent !== "") {
      writer.uint32(18).string(message.parent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchProcessDocumentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchProcessDocumentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.requests.push(ProcessDocumentRequest.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.parent = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchProcessDocumentsRequest {
    return {
      requests: globalThis.Array.isArray(object?.requests)
        ? object.requests.map((e: any) => ProcessDocumentRequest.fromJSON(e))
        : [],
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
    };
  },

  toJSON(message: BatchProcessDocumentsRequest): unknown {
    const obj: any = {};
    if (message.requests?.length) {
      obj.requests = message.requests.map((e) => ProcessDocumentRequest.toJSON(e));
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchProcessDocumentsRequest>): BatchProcessDocumentsRequest {
    return BatchProcessDocumentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchProcessDocumentsRequest>): BatchProcessDocumentsRequest {
    const message = createBaseBatchProcessDocumentsRequest();
    message.requests = object.requests?.map((e) => ProcessDocumentRequest.fromPartial(e)) || [];
    message.parent = object.parent ?? "";
    return message;
  },
};

function createBaseProcessDocumentRequest(): ProcessDocumentRequest {
  return {
    inputConfig: undefined,
    outputConfig: undefined,
    documentType: "",
    tableExtractionParams: undefined,
    formExtractionParams: undefined,
    entityExtractionParams: undefined,
    ocrParams: undefined,
  };
}

export const ProcessDocumentRequest: MessageFns<ProcessDocumentRequest> = {
  encode(message: ProcessDocumentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputConfig !== undefined) {
      InputConfig.encode(message.inputConfig, writer.uint32(10).fork()).join();
    }
    if (message.outputConfig !== undefined) {
      OutputConfig.encode(message.outputConfig, writer.uint32(18).fork()).join();
    }
    if (message.documentType !== "") {
      writer.uint32(26).string(message.documentType);
    }
    if (message.tableExtractionParams !== undefined) {
      TableExtractionParams.encode(message.tableExtractionParams, writer.uint32(34).fork()).join();
    }
    if (message.formExtractionParams !== undefined) {
      FormExtractionParams.encode(message.formExtractionParams, writer.uint32(42).fork()).join();
    }
    if (message.entityExtractionParams !== undefined) {
      EntityExtractionParams.encode(message.entityExtractionParams, writer.uint32(50).fork()).join();
    }
    if (message.ocrParams !== undefined) {
      OcrParams.encode(message.ocrParams, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDocumentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDocumentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputConfig = InputConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputConfig = OutputConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.documentType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tableExtractionParams = TableExtractionParams.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.formExtractionParams = FormExtractionParams.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.entityExtractionParams = EntityExtractionParams.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ocrParams = OcrParams.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDocumentRequest {
    return {
      inputConfig: isSet(object.inputConfig) ? InputConfig.fromJSON(object.inputConfig) : undefined,
      outputConfig: isSet(object.outputConfig) ? OutputConfig.fromJSON(object.outputConfig) : undefined,
      documentType: isSet(object.documentType) ? globalThis.String(object.documentType) : "",
      tableExtractionParams: isSet(object.tableExtractionParams)
        ? TableExtractionParams.fromJSON(object.tableExtractionParams)
        : undefined,
      formExtractionParams: isSet(object.formExtractionParams)
        ? FormExtractionParams.fromJSON(object.formExtractionParams)
        : undefined,
      entityExtractionParams: isSet(object.entityExtractionParams)
        ? EntityExtractionParams.fromJSON(object.entityExtractionParams)
        : undefined,
      ocrParams: isSet(object.ocrParams) ? OcrParams.fromJSON(object.ocrParams) : undefined,
    };
  },

  toJSON(message: ProcessDocumentRequest): unknown {
    const obj: any = {};
    if (message.inputConfig !== undefined) {
      obj.inputConfig = InputConfig.toJSON(message.inputConfig);
    }
    if (message.outputConfig !== undefined) {
      obj.outputConfig = OutputConfig.toJSON(message.outputConfig);
    }
    if (message.documentType !== "") {
      obj.documentType = message.documentType;
    }
    if (message.tableExtractionParams !== undefined) {
      obj.tableExtractionParams = TableExtractionParams.toJSON(message.tableExtractionParams);
    }
    if (message.formExtractionParams !== undefined) {
      obj.formExtractionParams = FormExtractionParams.toJSON(message.formExtractionParams);
    }
    if (message.entityExtractionParams !== undefined) {
      obj.entityExtractionParams = EntityExtractionParams.toJSON(message.entityExtractionParams);
    }
    if (message.ocrParams !== undefined) {
      obj.ocrParams = OcrParams.toJSON(message.ocrParams);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessDocumentRequest>): ProcessDocumentRequest {
    return ProcessDocumentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessDocumentRequest>): ProcessDocumentRequest {
    const message = createBaseProcessDocumentRequest();
    message.inputConfig = (object.inputConfig !== undefined && object.inputConfig !== null)
      ? InputConfig.fromPartial(object.inputConfig)
      : undefined;
    message.outputConfig = (object.outputConfig !== undefined && object.outputConfig !== null)
      ? OutputConfig.fromPartial(object.outputConfig)
      : undefined;
    message.documentType = object.documentType ?? "";
    message.tableExtractionParams =
      (object.tableExtractionParams !== undefined && object.tableExtractionParams !== null)
        ? TableExtractionParams.fromPartial(object.tableExtractionParams)
        : undefined;
    message.formExtractionParams = (object.formExtractionParams !== undefined && object.formExtractionParams !== null)
      ? FormExtractionParams.fromPartial(object.formExtractionParams)
      : undefined;
    message.entityExtractionParams =
      (object.entityExtractionParams !== undefined && object.entityExtractionParams !== null)
        ? EntityExtractionParams.fromPartial(object.entityExtractionParams)
        : undefined;
    message.ocrParams = (object.ocrParams !== undefined && object.ocrParams !== null)
      ? OcrParams.fromPartial(object.ocrParams)
      : undefined;
    return message;
  },
};

function createBaseBatchProcessDocumentsResponse(): BatchProcessDocumentsResponse {
  return { responses: [] };
}

export const BatchProcessDocumentsResponse: MessageFns<BatchProcessDocumentsResponse> = {
  encode(message: BatchProcessDocumentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.responses) {
      ProcessDocumentResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BatchProcessDocumentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchProcessDocumentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.responses.push(ProcessDocumentResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchProcessDocumentsResponse {
    return {
      responses: globalThis.Array.isArray(object?.responses)
        ? object.responses.map((e: any) => ProcessDocumentResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchProcessDocumentsResponse): unknown {
    const obj: any = {};
    if (message.responses?.length) {
      obj.responses = message.responses.map((e) => ProcessDocumentResponse.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchProcessDocumentsResponse>): BatchProcessDocumentsResponse {
    return BatchProcessDocumentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchProcessDocumentsResponse>): BatchProcessDocumentsResponse {
    const message = createBaseBatchProcessDocumentsResponse();
    message.responses = object.responses?.map((e) => ProcessDocumentResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProcessDocumentResponse(): ProcessDocumentResponse {
  return { inputConfig: undefined, outputConfig: undefined };
}

export const ProcessDocumentResponse: MessageFns<ProcessDocumentResponse> = {
  encode(message: ProcessDocumentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inputConfig !== undefined) {
      InputConfig.encode(message.inputConfig, writer.uint32(10).fork()).join();
    }
    if (message.outputConfig !== undefined) {
      OutputConfig.encode(message.outputConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessDocumentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessDocumentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputConfig = InputConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputConfig = OutputConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessDocumentResponse {
    return {
      inputConfig: isSet(object.inputConfig) ? InputConfig.fromJSON(object.inputConfig) : undefined,
      outputConfig: isSet(object.outputConfig) ? OutputConfig.fromJSON(object.outputConfig) : undefined,
    };
  },

  toJSON(message: ProcessDocumentResponse): unknown {
    const obj: any = {};
    if (message.inputConfig !== undefined) {
      obj.inputConfig = InputConfig.toJSON(message.inputConfig);
    }
    if (message.outputConfig !== undefined) {
      obj.outputConfig = OutputConfig.toJSON(message.outputConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ProcessDocumentResponse>): ProcessDocumentResponse {
    return ProcessDocumentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProcessDocumentResponse>): ProcessDocumentResponse {
    const message = createBaseProcessDocumentResponse();
    message.inputConfig = (object.inputConfig !== undefined && object.inputConfig !== null)
      ? InputConfig.fromPartial(object.inputConfig)
      : undefined;
    message.outputConfig = (object.outputConfig !== undefined && object.outputConfig !== null)
      ? OutputConfig.fromPartial(object.outputConfig)
      : undefined;
    return message;
  },
};

function createBaseOcrParams(): OcrParams {
  return { languageHints: [] };
}

export const OcrParams: MessageFns<OcrParams> = {
  encode(message: OcrParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.languageHints) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OcrParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOcrParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageHints.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OcrParams {
    return {
      languageHints: globalThis.Array.isArray(object?.languageHints)
        ? object.languageHints.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OcrParams): unknown {
    const obj: any = {};
    if (message.languageHints?.length) {
      obj.languageHints = message.languageHints;
    }
    return obj;
  },

  create(base?: DeepPartial<OcrParams>): OcrParams {
    return OcrParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OcrParams>): OcrParams {
    const message = createBaseOcrParams();
    message.languageHints = object.languageHints?.map((e) => e) || [];
    return message;
  },
};

function createBaseTableExtractionParams(): TableExtractionParams {
  return { enabled: false, tableBoundHints: [], headerHints: [], modelVersion: "" };
}

export const TableExtractionParams: MessageFns<TableExtractionParams> = {
  encode(message: TableExtractionParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    for (const v of message.tableBoundHints) {
      TableBoundHint.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.headerHints) {
      writer.uint32(26).string(v!);
    }
    if (message.modelVersion !== "") {
      writer.uint32(34).string(message.modelVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableExtractionParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableExtractionParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tableBoundHints.push(TableBoundHint.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.headerHints.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.modelVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableExtractionParams {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      tableBoundHints: globalThis.Array.isArray(object?.tableBoundHints)
        ? object.tableBoundHints.map((e: any) => TableBoundHint.fromJSON(e))
        : [],
      headerHints: globalThis.Array.isArray(object?.headerHints)
        ? object.headerHints.map((e: any) => globalThis.String(e))
        : [],
      modelVersion: isSet(object.modelVersion) ? globalThis.String(object.modelVersion) : "",
    };
  },

  toJSON(message: TableExtractionParams): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.tableBoundHints?.length) {
      obj.tableBoundHints = message.tableBoundHints.map((e) => TableBoundHint.toJSON(e));
    }
    if (message.headerHints?.length) {
      obj.headerHints = message.headerHints;
    }
    if (message.modelVersion !== "") {
      obj.modelVersion = message.modelVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<TableExtractionParams>): TableExtractionParams {
    return TableExtractionParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableExtractionParams>): TableExtractionParams {
    const message = createBaseTableExtractionParams();
    message.enabled = object.enabled ?? false;
    message.tableBoundHints = object.tableBoundHints?.map((e) => TableBoundHint.fromPartial(e)) || [];
    message.headerHints = object.headerHints?.map((e) => e) || [];
    message.modelVersion = object.modelVersion ?? "";
    return message;
  },
};

function createBaseTableBoundHint(): TableBoundHint {
  return { pageNumber: 0, boundingBox: undefined };
}

export const TableBoundHint: MessageFns<TableBoundHint> = {
  encode(message: TableBoundHint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageNumber !== 0) {
      writer.uint32(8).int32(message.pageNumber);
    }
    if (message.boundingBox !== undefined) {
      BoundingPoly.encode(message.boundingBox, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableBoundHint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableBoundHint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageNumber = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.boundingBox = BoundingPoly.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableBoundHint {
    return {
      pageNumber: isSet(object.pageNumber) ? globalThis.Number(object.pageNumber) : 0,
      boundingBox: isSet(object.boundingBox) ? BoundingPoly.fromJSON(object.boundingBox) : undefined,
    };
  },

  toJSON(message: TableBoundHint): unknown {
    const obj: any = {};
    if (message.pageNumber !== 0) {
      obj.pageNumber = Math.round(message.pageNumber);
    }
    if (message.boundingBox !== undefined) {
      obj.boundingBox = BoundingPoly.toJSON(message.boundingBox);
    }
    return obj;
  },

  create(base?: DeepPartial<TableBoundHint>): TableBoundHint {
    return TableBoundHint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableBoundHint>): TableBoundHint {
    const message = createBaseTableBoundHint();
    message.pageNumber = object.pageNumber ?? 0;
    message.boundingBox = (object.boundingBox !== undefined && object.boundingBox !== null)
      ? BoundingPoly.fromPartial(object.boundingBox)
      : undefined;
    return message;
  },
};

function createBaseFormExtractionParams(): FormExtractionParams {
  return { enabled: false, keyValuePairHints: [], modelVersion: "" };
}

export const FormExtractionParams: MessageFns<FormExtractionParams> = {
  encode(message: FormExtractionParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    for (const v of message.keyValuePairHints) {
      KeyValuePairHint.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.modelVersion !== "") {
      writer.uint32(26).string(message.modelVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FormExtractionParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFormExtractionParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.keyValuePairHints.push(KeyValuePairHint.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.modelVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FormExtractionParams {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      keyValuePairHints: globalThis.Array.isArray(object?.keyValuePairHints)
        ? object.keyValuePairHints.map((e: any) => KeyValuePairHint.fromJSON(e))
        : [],
      modelVersion: isSet(object.modelVersion) ? globalThis.String(object.modelVersion) : "",
    };
  },

  toJSON(message: FormExtractionParams): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.keyValuePairHints?.length) {
      obj.keyValuePairHints = message.keyValuePairHints.map((e) => KeyValuePairHint.toJSON(e));
    }
    if (message.modelVersion !== "") {
      obj.modelVersion = message.modelVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<FormExtractionParams>): FormExtractionParams {
    return FormExtractionParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FormExtractionParams>): FormExtractionParams {
    const message = createBaseFormExtractionParams();
    message.enabled = object.enabled ?? false;
    message.keyValuePairHints = object.keyValuePairHints?.map((e) => KeyValuePairHint.fromPartial(e)) || [];
    message.modelVersion = object.modelVersion ?? "";
    return message;
  },
};

function createBaseKeyValuePairHint(): KeyValuePairHint {
  return { key: "", valueTypes: [] };
}

export const KeyValuePairHint: MessageFns<KeyValuePairHint> = {
  encode(message: KeyValuePairHint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.valueTypes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyValuePairHint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyValuePairHint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.valueTypes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyValuePairHint {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      valueTypes: globalThis.Array.isArray(object?.valueTypes)
        ? object.valueTypes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: KeyValuePairHint): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.valueTypes?.length) {
      obj.valueTypes = message.valueTypes;
    }
    return obj;
  },

  create(base?: DeepPartial<KeyValuePairHint>): KeyValuePairHint {
    return KeyValuePairHint.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyValuePairHint>): KeyValuePairHint {
    const message = createBaseKeyValuePairHint();
    message.key = object.key ?? "";
    message.valueTypes = object.valueTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseEntityExtractionParams(): EntityExtractionParams {
  return { enabled: false, modelVersion: "" };
}

export const EntityExtractionParams: MessageFns<EntityExtractionParams> = {
  encode(message: EntityExtractionParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (message.modelVersion !== "") {
      writer.uint32(18).string(message.modelVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntityExtractionParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntityExtractionParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.modelVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntityExtractionParams {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      modelVersion: isSet(object.modelVersion) ? globalThis.String(object.modelVersion) : "",
    };
  },

  toJSON(message: EntityExtractionParams): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.modelVersion !== "") {
      obj.modelVersion = message.modelVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<EntityExtractionParams>): EntityExtractionParams {
    return EntityExtractionParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntityExtractionParams>): EntityExtractionParams {
    const message = createBaseEntityExtractionParams();
    message.enabled = object.enabled ?? false;
    message.modelVersion = object.modelVersion ?? "";
    return message;
  },
};

function createBaseInputConfig(): InputConfig {
  return { gcsSource: undefined, mimeType: "" };
}

export const InputConfig: MessageFns<InputConfig> = {
  encode(message: InputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsSource !== undefined) {
      GcsSource.encode(message.gcsSource, writer.uint32(10).fork()).join();
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsSource = GcsSource.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputConfig {
    return {
      gcsSource: isSet(object.gcsSource) ? GcsSource.fromJSON(object.gcsSource) : undefined,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: InputConfig): unknown {
    const obj: any = {};
    if (message.gcsSource !== undefined) {
      obj.gcsSource = GcsSource.toJSON(message.gcsSource);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create(base?: DeepPartial<InputConfig>): InputConfig {
    return InputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InputConfig>): InputConfig {
    const message = createBaseInputConfig();
    message.gcsSource = (object.gcsSource !== undefined && object.gcsSource !== null)
      ? GcsSource.fromPartial(object.gcsSource)
      : undefined;
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseOutputConfig(): OutputConfig {
  return { gcsDestination: undefined, pagesPerShard: 0 };
}

export const OutputConfig: MessageFns<OutputConfig> = {
  encode(message: OutputConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcsDestination !== undefined) {
      GcsDestination.encode(message.gcsDestination, writer.uint32(10).fork()).join();
    }
    if (message.pagesPerShard !== 0) {
      writer.uint32(16).int32(message.pagesPerShard);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcsDestination = GcsDestination.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pagesPerShard = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputConfig {
    return {
      gcsDestination: isSet(object.gcsDestination) ? GcsDestination.fromJSON(object.gcsDestination) : undefined,
      pagesPerShard: isSet(object.pagesPerShard) ? globalThis.Number(object.pagesPerShard) : 0,
    };
  },

  toJSON(message: OutputConfig): unknown {
    const obj: any = {};
    if (message.gcsDestination !== undefined) {
      obj.gcsDestination = GcsDestination.toJSON(message.gcsDestination);
    }
    if (message.pagesPerShard !== 0) {
      obj.pagesPerShard = Math.round(message.pagesPerShard);
    }
    return obj;
  },

  create(base?: DeepPartial<OutputConfig>): OutputConfig {
    return OutputConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutputConfig>): OutputConfig {
    const message = createBaseOutputConfig();
    message.gcsDestination = (object.gcsDestination !== undefined && object.gcsDestination !== null)
      ? GcsDestination.fromPartial(object.gcsDestination)
      : undefined;
    message.pagesPerShard = object.pagesPerShard ?? 0;
    return message;
  },
};

function createBaseGcsSource(): GcsSource {
  return { uri: "" };
}

export const GcsSource: MessageFns<GcsSource> = {
  encode(message: GcsSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsSource {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: GcsSource): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsSource>): GcsSource {
    return GcsSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsSource>): GcsSource {
    const message = createBaseGcsSource();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseGcsDestination(): GcsDestination {
  return { uri: "" };
}

export const GcsDestination: MessageFns<GcsDestination> = {
  encode(message: GcsDestination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcsDestination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcsDestination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcsDestination {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : "" };
  },

  toJSON(message: GcsDestination): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    return obj;
  },

  create(base?: DeepPartial<GcsDestination>): GcsDestination {
    return GcsDestination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcsDestination>): GcsDestination {
    const message = createBaseGcsDestination();
    message.uri = object.uri ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return { state: 0, stateMessage: "", createTime: undefined, updateTime: undefined };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.stateMessage !== "") {
      writer.uint32(18).string(message.stateMessage);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stateMessage = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      state: isSet(object.state) ? operationMetadata_StateFromJSON(object.state) : 0,
      stateMessage: isSet(object.stateMessage) ? globalThis.String(object.stateMessage) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = operationMetadata_StateToJSON(message.state);
    }
    if (message.stateMessage !== "") {
      obj.stateMessage = message.stateMessage;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.state = object.state ?? 0;
    message.stateMessage = object.stateMessage ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

/**
 * Service to parse structured information from unstructured or semi-structured
 * documents using state-of-the-art Google AI such as natural language,
 * computer vision, and translation.
 */
export type DocumentUnderstandingServiceDefinition = typeof DocumentUnderstandingServiceDefinition;
export const DocumentUnderstandingServiceDefinition = {
  name: "DocumentUnderstandingService",
  fullName: "google.cloud.documentai.v1beta1.DocumentUnderstandingService",
  methods: {
    /** LRO endpoint to batch process many documents. */
    batchProcessDocuments: {
      name: "BatchProcessDocuments",
      requestType: BatchProcessDocumentsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              50,
              10,
              29,
              66,
              97,
              116,
              99,
              104,
              80,
              114,
              111,
              99,
              101,
              115,
              115,
              68,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              82,
              101,
              115,
              112,
              111,
              110,
              115,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([8, 114, 101, 113, 117, 101, 115, 116, 115])],
          578365826: [
            Buffer.from([
              126,
              58,
              1,
              42,
              90,
              56,
              58,
              1,
              42,
              34,
              51,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              125,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              80,
              114,
              111,
              99,
              101,
              115,
              115,
              34,
              63,
              47,
              118,
              49,
              98,
              101,
              116,
              97,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              100,
              111,
              99,
              117,
              109,
              101,
              110,
              116,
              115,
              58,
              98,
              97,
              116,
              99,
              104,
              80,
              114,
              111,
              99,
              101,
              115,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface DocumentUnderstandingServiceImplementation<CallContextExt = {}> {
  /** LRO endpoint to batch process many documents. */
  batchProcessDocuments(
    request: BatchProcessDocumentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
}

export interface DocumentUnderstandingServiceClient<CallOptionsExt = {}> {
  /** LRO endpoint to batch process many documents. */
  batchProcessDocuments(
    request: DeepPartial<BatchProcessDocumentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
