// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/documentai/v1beta1/document.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Status } from "../../../rpc/status.js";
import { Color } from "../../../type/color.js";
import { BoundingPoly } from "./geometry.js";

export const protobufPackage = "google.cloud.documentai.v1beta1";

/**
 * Document represents the canonical document resource in Document Understanding
 * AI.
 * It is an interchange format that provides insights into documents and allows
 * for collaboration between users and Document Understanding AI to iterate and
 * optimize for quality.
 */
export interface Document {
  /**
   * Currently supports Google Cloud Storage URI of the form
   *    `gs://bucket_name/object_name`. Object versioning is not supported.
   *    See [Google Cloud Storage Request
   *    URIs](https://cloud.google.com/storage/docs/reference-uris) for more
   *    info.
   */
  uri?:
    | string
    | undefined;
  /**
   * Inline document content, represented as a stream of bytes.
   * Note: As with all `bytes` fields, protobuffers use a pure binary
   * representation, whereas JSON representations use base64.
   */
  content?:
    | Buffer
    | undefined;
  /**
   * An IANA published MIME type (also referred to as media type). For more
   * information, see
   * https://www.iana.org/assignments/media-types/media-types.xhtml.
   */
  mimeType: string;
  /** UTF-8 encoded text in reading order from the document. */
  text: string;
  /**
   * Styles for the
   * [Document.text][google.cloud.documentai.v1beta1.Document.text].
   */
  textStyles: Document_Style[];
  /**
   * Visual page layout for the
   * [Document][google.cloud.documentai.v1beta1.Document].
   */
  pages: Document_Page[];
  /**
   * A list of entities detected on
   * [Document.text][google.cloud.documentai.v1beta1.Document.text]. For
   * document shards, entities in this list may cross shard boundaries.
   */
  entities: Document_Entity[];
  /**
   * Relationship among
   * [Document.entities][google.cloud.documentai.v1beta1.Document.entities].
   */
  entityRelations: Document_EntityRelation[];
  /**
   * Information about the sharding if this document is sharded part of a larger
   * document. If the document is not sharded, this message is not specified.
   */
  shardInfo:
    | Document_ShardInfo
    | undefined;
  /** Any error that occurred while processing this document. */
  error: Status | undefined;
}

/**
 * For a large document, sharding may be performed to produce several
 * document shards. Each document shard contains this field to detail which
 * shard it is.
 */
export interface Document_ShardInfo {
  /** The 0-based index of this shard. */
  shardIndex: Long;
  /** Total number of shards. */
  shardCount: Long;
  /**
   * The index of the first character in
   * [Document.text][google.cloud.documentai.v1beta1.Document.text] in the
   * overall document global text.
   */
  textOffset: Long;
}

/**
 * Annotation for common text style attributes. This adheres to CSS
 * conventions as much as possible.
 */
export interface Document_Style {
  /**
   * Text anchor indexing into the
   * [Document.text][google.cloud.documentai.v1beta1.Document.text].
   */
  textAnchor:
    | Document_TextAnchor
    | undefined;
  /** Text color. */
  color:
    | Color
    | undefined;
  /** Text background color. */
  backgroundColor:
    | Color
    | undefined;
  /**
   * Font weight. Possible values are normal, bold, bolder, and lighter.
   * https://www.w3schools.com/cssref/pr_font_weight.asp
   */
  fontWeight: string;
  /**
   * Text style. Possible values are normal, italic, and oblique.
   * https://www.w3schools.com/cssref/pr_font_font-style.asp
   */
  textStyle: string;
  /**
   * Text decoration. Follows CSS standard.
   * <text-decoration-line> <text-decoration-color> <text-decoration-style>
   * https://www.w3schools.com/cssref/pr_text_text-decoration.asp
   */
  textDecoration: string;
  /** Font size. */
  fontSize: Document_Style_FontSize | undefined;
}

/** Font size with unit. */
export interface Document_Style_FontSize {
  /** Font size for the text. */
  size: number;
  /** Unit for the font size. Follows CSS naming (in, px, pt, etc.). */
  unit: string;
}

/** A page in a [Document][google.cloud.documentai.v1beta1.Document]. */
export interface Document_Page {
  /**
   * 1-based index for current
   * [Page][google.cloud.documentai.v1beta1.Document.Page] in a parent
   * [Document][google.cloud.documentai.v1beta1.Document]. Useful when a page
   * is taken out of a [Document][google.cloud.documentai.v1beta1.Document]
   * for individual processing.
   */
  pageNumber: number;
  /** Physical dimension of the page. */
  dimension:
    | Document_Page_Dimension
    | undefined;
  /**
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout] for the
   * page.
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
  /**
   * A list of visually detected text blocks on the page.
   * A block has a set of lines (collected into paragraphs) that have a common
   * line-spacing and orientation.
   */
  blocks: Document_Page_Block[];
  /**
   * A list of visually detected text paragraphs on the page.
   * A collection of lines that a human would perceive as a paragraph.
   */
  paragraphs: Document_Page_Paragraph[];
  /**
   * A list of visually detected text lines on the page.
   * A collection of tokens that a human would perceive as a line.
   */
  lines: Document_Page_Line[];
  /** A list of visually detected tokens on the page. */
  tokens: Document_Page_Token[];
  /**
   * A list of detected non-text visual elements e.g. checkbox,
   * signature etc. on the page.
   */
  visualElements: Document_Page_VisualElement[];
  /** A list of visually detected tables on the page. */
  tables: Document_Page_Table[];
  /** A list of visually detected form fields on the page. */
  formFields: Document_Page_FormField[];
}

/** Dimension for the page. */
export interface Document_Page_Dimension {
  /** Page width. */
  width: number;
  /** Page height. */
  height: number;
  /** Dimension unit. */
  unit: string;
}

/** Visual element describing a layout unit on a page. */
export interface Document_Page_Layout {
  /**
   * Text anchor indexing into the
   * [Document.text][google.cloud.documentai.v1beta1.Document.text].
   */
  textAnchor:
    | Document_TextAnchor
    | undefined;
  /**
   * Confidence of the current
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout] within
   * context of the object this layout is for. e.g. confidence can be for a
   * single token, a table, a visual element, etc. depending on context.
   * Range [0, 1].
   */
  confidence: number;
  /**
   * The bounding polygon for the
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout].
   */
  boundingPoly:
    | BoundingPoly
    | undefined;
  /**
   * Detected orientation for the
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout].
   */
  orientation: Document_Page_Layout_Orientation;
}

/** Detected human reading orientation. */
export enum Document_Page_Layout_Orientation {
  /** ORIENTATION_UNSPECIFIED - Unspecified orientation. */
  ORIENTATION_UNSPECIFIED = 0,
  /** PAGE_UP - Orientation is aligned with page up. */
  PAGE_UP = 1,
  /**
   * PAGE_RIGHT - Orientation is aligned with page right.
   * Turn the head 90 degrees clockwise from upright to read.
   */
  PAGE_RIGHT = 2,
  /**
   * PAGE_DOWN - Orientation is aligned with page down.
   * Turn the head 180 degrees from upright to read.
   */
  PAGE_DOWN = 3,
  /**
   * PAGE_LEFT - Orientation is aligned with page left.
   * Turn the head 90 degrees counterclockwise from upright to read.
   */
  PAGE_LEFT = 4,
  UNRECOGNIZED = -1,
}

export function document_Page_Layout_OrientationFromJSON(object: any): Document_Page_Layout_Orientation {
  switch (object) {
    case 0:
    case "ORIENTATION_UNSPECIFIED":
      return Document_Page_Layout_Orientation.ORIENTATION_UNSPECIFIED;
    case 1:
    case "PAGE_UP":
      return Document_Page_Layout_Orientation.PAGE_UP;
    case 2:
    case "PAGE_RIGHT":
      return Document_Page_Layout_Orientation.PAGE_RIGHT;
    case 3:
    case "PAGE_DOWN":
      return Document_Page_Layout_Orientation.PAGE_DOWN;
    case 4:
    case "PAGE_LEFT":
      return Document_Page_Layout_Orientation.PAGE_LEFT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Document_Page_Layout_Orientation.UNRECOGNIZED;
  }
}

export function document_Page_Layout_OrientationToJSON(object: Document_Page_Layout_Orientation): string {
  switch (object) {
    case Document_Page_Layout_Orientation.ORIENTATION_UNSPECIFIED:
      return "ORIENTATION_UNSPECIFIED";
    case Document_Page_Layout_Orientation.PAGE_UP:
      return "PAGE_UP";
    case Document_Page_Layout_Orientation.PAGE_RIGHT:
      return "PAGE_RIGHT";
    case Document_Page_Layout_Orientation.PAGE_DOWN:
      return "PAGE_DOWN";
    case Document_Page_Layout_Orientation.PAGE_LEFT:
      return "PAGE_LEFT";
    case Document_Page_Layout_Orientation.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A block has a set of lines (collected into paragraphs) that have a
 * common line-spacing and orientation.
 */
export interface Document_Page_Block {
  /**
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout] for
   * [Block][google.cloud.documentai.v1beta1.Document.Page.Block].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
}

/** A collection of lines that a human would perceive as a paragraph. */
export interface Document_Page_Paragraph {
  /**
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout] for
   * [Paragraph][google.cloud.documentai.v1beta1.Document.Page.Paragraph].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
}

/**
 * A collection of tokens that a human would perceive as a line.
 * Does not cross column boundaries, can be horizontal, vertical, etc.
 */
export interface Document_Page_Line {
  /**
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout] for
   * [Line][google.cloud.documentai.v1beta1.Document.Page.Line].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
}

/** A detected token. */
export interface Document_Page_Token {
  /**
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout] for
   * [Token][google.cloud.documentai.v1beta1.Document.Page.Token].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /**
   * Detected break at the end of a
   * [Token][google.cloud.documentai.v1beta1.Document.Page.Token].
   */
  detectedBreak:
    | Document_Page_Token_DetectedBreak
    | undefined;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
}

/**
 * Detected break at the end of a
 * [Token][google.cloud.documentai.v1beta1.Document.Page.Token].
 */
export interface Document_Page_Token_DetectedBreak {
  /** Detected break type. */
  type: Document_Page_Token_DetectedBreak_Type;
}

/** Enum to denote the type of break found. */
export enum Document_Page_Token_DetectedBreak_Type {
  /** TYPE_UNSPECIFIED - Unspecified break type. */
  TYPE_UNSPECIFIED = 0,
  /** SPACE - A single whitespace. */
  SPACE = 1,
  /** WIDE_SPACE - A wider whitespace. */
  WIDE_SPACE = 2,
  /** HYPHEN - A hyphen that indicates that a token has been split across lines. */
  HYPHEN = 3,
  UNRECOGNIZED = -1,
}

export function document_Page_Token_DetectedBreak_TypeFromJSON(object: any): Document_Page_Token_DetectedBreak_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Document_Page_Token_DetectedBreak_Type.TYPE_UNSPECIFIED;
    case 1:
    case "SPACE":
      return Document_Page_Token_DetectedBreak_Type.SPACE;
    case 2:
    case "WIDE_SPACE":
      return Document_Page_Token_DetectedBreak_Type.WIDE_SPACE;
    case 3:
    case "HYPHEN":
      return Document_Page_Token_DetectedBreak_Type.HYPHEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Document_Page_Token_DetectedBreak_Type.UNRECOGNIZED;
  }
}

export function document_Page_Token_DetectedBreak_TypeToJSON(object: Document_Page_Token_DetectedBreak_Type): string {
  switch (object) {
    case Document_Page_Token_DetectedBreak_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Document_Page_Token_DetectedBreak_Type.SPACE:
      return "SPACE";
    case Document_Page_Token_DetectedBreak_Type.WIDE_SPACE:
      return "WIDE_SPACE";
    case Document_Page_Token_DetectedBreak_Type.HYPHEN:
      return "HYPHEN";
    case Document_Page_Token_DetectedBreak_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Detected non-text visual elements e.g. checkbox, signature etc. on the
 * page.
 */
export interface Document_Page_VisualElement {
  /**
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout] for
   * [Token][google.cloud.documentai.v1beta1.Document.Page.Token].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /**
   * Type of the
   * [VisualElement][google.cloud.documentai.v1beta1.Document.Page.VisualElement].
   */
  type: string;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
}

/** A table representation similar to HTML table structure. */
export interface Document_Page_Table {
  /**
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout] for
   * [Table][google.cloud.documentai.v1beta1.Document.Page.Table].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** Header rows of the table. */
  headerRows: Document_Page_Table_TableRow[];
  /** Body rows of the table. */
  bodyRows: Document_Page_Table_TableRow[];
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
}

/** A row of table cells. */
export interface Document_Page_Table_TableRow {
  /** Cells that make up this row. */
  cells: Document_Page_Table_TableCell[];
}

/** A cell representation inside the table. */
export interface Document_Page_Table_TableCell {
  /**
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout] for
   * [TableCell][google.cloud.documentai.v1beta1.Document.Page.Table.TableCell].
   */
  layout:
    | Document_Page_Layout
    | undefined;
  /** How many rows this cell spans. */
  rowSpan: number;
  /** How many columns this cell spans. */
  colSpan: number;
  /** A list of detected languages together with confidence. */
  detectedLanguages: Document_Page_DetectedLanguage[];
}

/** A form field detected on the page. */
export interface Document_Page_FormField {
  /**
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout] for the
   * [FormField][google.cloud.documentai.v1beta1.Document.Page.FormField]
   * name. e.g. `Address`, `Email`, `Grand total`, `Phone number`, etc.
   */
  fieldName:
    | Document_Page_Layout
    | undefined;
  /**
   * [Layout][google.cloud.documentai.v1beta1.Document.Page.Layout] for the
   * [FormField][google.cloud.documentai.v1beta1.Document.Page.FormField]
   * value.
   */
  fieldValue:
    | Document_Page_Layout
    | undefined;
  /** A list of detected languages for name together with confidence. */
  nameDetectedLanguages: Document_Page_DetectedLanguage[];
  /** A list of detected languages for value together with confidence. */
  valueDetectedLanguages: Document_Page_DetectedLanguage[];
}

/** Detected language for a structural component. */
export interface Document_Page_DetectedLanguage {
  /**
   * The BCP-47 language code, such as "en-US" or "sr-Latn". For more
   * information, see
   * http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
   */
  languageCode: string;
  /** Confidence of detected language. Range [0, 1]. */
  confidence: number;
}

/**
 * A phrase in the text that is a known entity type, such as a person, an
 * organization, or location.
 */
export interface Document_Entity {
  /**
   * Provenance of the entity.
   * Text anchor indexing into the
   * [Document.text][google.cloud.documentai.v1beta1.Document.text].
   */
  textAnchor:
    | Document_TextAnchor
    | undefined;
  /** Required. Entity type from a schema e.g. `Address`. */
  type: string;
  /** Text value in the document e.g. `1600 Amphitheatre Pkwy`. */
  mentionText: string;
  /**
   * Canonical mention name. This will be a unique value in the entity list
   * for this document.
   */
  mentionId: string;
}

/**
 * Relationship between
 * [Entities][google.cloud.documentai.v1beta1.Document.Entity].
 */
export interface Document_EntityRelation {
  /** Subject entity mention_id. */
  subjectId: string;
  /** Object entity mention_id. */
  objectId: string;
  /** Relationship description. */
  relation: string;
}

/**
 * Text reference indexing into the
 * [Document.text][google.cloud.documentai.v1beta1.Document.text].
 */
export interface Document_TextAnchor {
  /**
   * The text segments from the
   * [Document.text][google.cloud.documentai.v1beta1.Document.text].
   */
  textSegments: Document_TextAnchor_TextSegment[];
}

/**
 * A text segment in the
 * [Document.text][google.cloud.documentai.v1beta1.Document.text]. The
 * indices may be out of bounds which indicate that the text extends into
 * another document shard for large sharded documents. See
 * [ShardInfo.text_offset][google.cloud.documentai.v1beta1.Document.ShardInfo.text_offset]
 */
export interface Document_TextAnchor_TextSegment {
  /**
   * [TextSegment][google.cloud.documentai.v1beta1.Document.TextAnchor.TextSegment]
   * start UTF-8 char index in the
   * [Document.text][google.cloud.documentai.v1beta1.Document.text].
   */
  startIndex: Long;
  /**
   * [TextSegment][google.cloud.documentai.v1beta1.Document.TextAnchor.TextSegment]
   * half open end UTF-8 char index in the
   * [Document.text][google.cloud.documentai.v1beta1.Document.text].
   */
  endIndex: Long;
}

function createBaseDocument(): Document {
  return {
    uri: undefined,
    content: undefined,
    mimeType: "",
    text: "",
    textStyles: [],
    pages: [],
    entities: [],
    entityRelations: [],
    shardInfo: undefined,
    error: undefined,
  };
}

export const Document: MessageFns<Document> = {
  encode(message: Document, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== undefined) {
      writer.uint32(10).string(message.uri);
    }
    if (message.content !== undefined) {
      writer.uint32(18).bytes(message.content);
    }
    if (message.mimeType !== "") {
      writer.uint32(26).string(message.mimeType);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    for (const v of message.textStyles) {
      Document_Style.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.pages) {
      Document_Page.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.entities) {
      Document_Entity.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.entityRelations) {
      Document_EntityRelation.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.shardInfo !== undefined) {
      Document_ShardInfo.encode(message.shardInfo, writer.uint32(74).fork()).join();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.textStyles.push(Document_Style.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pages.push(Document_Page.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.entities.push(Document_Entity.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.entityRelations.push(Document_EntityRelation.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.shardInfo = Document_ShardInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : undefined,
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : undefined,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      textStyles: globalThis.Array.isArray(object?.textStyles)
        ? object.textStyles.map((e: any) => Document_Style.fromJSON(e))
        : [],
      pages: globalThis.Array.isArray(object?.pages) ? object.pages.map((e: any) => Document_Page.fromJSON(e)) : [],
      entities: globalThis.Array.isArray(object?.entities)
        ? object.entities.map((e: any) => Document_Entity.fromJSON(e))
        : [],
      entityRelations: globalThis.Array.isArray(object?.entityRelations)
        ? object.entityRelations.map((e: any) => Document_EntityRelation.fromJSON(e))
        : [],
      shardInfo: isSet(object.shardInfo) ? Document_ShardInfo.fromJSON(object.shardInfo) : undefined,
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: Document): unknown {
    const obj: any = {};
    if (message.uri !== undefined) {
      obj.uri = message.uri;
    }
    if (message.content !== undefined) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.textStyles?.length) {
      obj.textStyles = message.textStyles.map((e) => Document_Style.toJSON(e));
    }
    if (message.pages?.length) {
      obj.pages = message.pages.map((e) => Document_Page.toJSON(e));
    }
    if (message.entities?.length) {
      obj.entities = message.entities.map((e) => Document_Entity.toJSON(e));
    }
    if (message.entityRelations?.length) {
      obj.entityRelations = message.entityRelations.map((e) => Document_EntityRelation.toJSON(e));
    }
    if (message.shardInfo !== undefined) {
      obj.shardInfo = Document_ShardInfo.toJSON(message.shardInfo);
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<Document>): Document {
    return Document.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document>): Document {
    const message = createBaseDocument();
    message.uri = object.uri ?? undefined;
    message.content = object.content ?? undefined;
    message.mimeType = object.mimeType ?? "";
    message.text = object.text ?? "";
    message.textStyles = object.textStyles?.map((e) => Document_Style.fromPartial(e)) || [];
    message.pages = object.pages?.map((e) => Document_Page.fromPartial(e)) || [];
    message.entities = object.entities?.map((e) => Document_Entity.fromPartial(e)) || [];
    message.entityRelations = object.entityRelations?.map((e) => Document_EntityRelation.fromPartial(e)) || [];
    message.shardInfo = (object.shardInfo !== undefined && object.shardInfo !== null)
      ? Document_ShardInfo.fromPartial(object.shardInfo)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseDocument_ShardInfo(): Document_ShardInfo {
  return { shardIndex: Long.ZERO, shardCount: Long.ZERO, textOffset: Long.ZERO };
}

export const Document_ShardInfo: MessageFns<Document_ShardInfo> = {
  encode(message: Document_ShardInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.shardIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.shardIndex.toString());
    }
    if (!message.shardCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.shardCount.toString());
    }
    if (!message.textOffset.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.textOffset.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_ShardInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_ShardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.shardIndex = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.shardCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.textOffset = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_ShardInfo {
    return {
      shardIndex: isSet(object.shardIndex) ? Long.fromValue(object.shardIndex) : Long.ZERO,
      shardCount: isSet(object.shardCount) ? Long.fromValue(object.shardCount) : Long.ZERO,
      textOffset: isSet(object.textOffset) ? Long.fromValue(object.textOffset) : Long.ZERO,
    };
  },

  toJSON(message: Document_ShardInfo): unknown {
    const obj: any = {};
    if (!message.shardIndex.equals(Long.ZERO)) {
      obj.shardIndex = (message.shardIndex || Long.ZERO).toString();
    }
    if (!message.shardCount.equals(Long.ZERO)) {
      obj.shardCount = (message.shardCount || Long.ZERO).toString();
    }
    if (!message.textOffset.equals(Long.ZERO)) {
      obj.textOffset = (message.textOffset || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Document_ShardInfo>): Document_ShardInfo {
    return Document_ShardInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_ShardInfo>): Document_ShardInfo {
    const message = createBaseDocument_ShardInfo();
    message.shardIndex = (object.shardIndex !== undefined && object.shardIndex !== null)
      ? Long.fromValue(object.shardIndex)
      : Long.ZERO;
    message.shardCount = (object.shardCount !== undefined && object.shardCount !== null)
      ? Long.fromValue(object.shardCount)
      : Long.ZERO;
    message.textOffset = (object.textOffset !== undefined && object.textOffset !== null)
      ? Long.fromValue(object.textOffset)
      : Long.ZERO;
    return message;
  },
};

function createBaseDocument_Style(): Document_Style {
  return {
    textAnchor: undefined,
    color: undefined,
    backgroundColor: undefined,
    fontWeight: "",
    textStyle: "",
    textDecoration: "",
    fontSize: undefined,
  };
}

export const Document_Style: MessageFns<Document_Style> = {
  encode(message: Document_Style, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textAnchor !== undefined) {
      Document_TextAnchor.encode(message.textAnchor, writer.uint32(10).fork()).join();
    }
    if (message.color !== undefined) {
      Color.encode(message.color, writer.uint32(18).fork()).join();
    }
    if (message.backgroundColor !== undefined) {
      Color.encode(message.backgroundColor, writer.uint32(26).fork()).join();
    }
    if (message.fontWeight !== "") {
      writer.uint32(34).string(message.fontWeight);
    }
    if (message.textStyle !== "") {
      writer.uint32(42).string(message.textStyle);
    }
    if (message.textDecoration !== "") {
      writer.uint32(50).string(message.textDecoration);
    }
    if (message.fontSize !== undefined) {
      Document_Style_FontSize.encode(message.fontSize, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Style {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Style();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textAnchor = Document_TextAnchor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.color = Color.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backgroundColor = Color.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fontWeight = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.textStyle = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.textDecoration = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.fontSize = Document_Style_FontSize.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Style {
    return {
      textAnchor: isSet(object.textAnchor) ? Document_TextAnchor.fromJSON(object.textAnchor) : undefined,
      color: isSet(object.color) ? Color.fromJSON(object.color) : undefined,
      backgroundColor: isSet(object.backgroundColor) ? Color.fromJSON(object.backgroundColor) : undefined,
      fontWeight: isSet(object.fontWeight) ? globalThis.String(object.fontWeight) : "",
      textStyle: isSet(object.textStyle) ? globalThis.String(object.textStyle) : "",
      textDecoration: isSet(object.textDecoration) ? globalThis.String(object.textDecoration) : "",
      fontSize: isSet(object.fontSize) ? Document_Style_FontSize.fromJSON(object.fontSize) : undefined,
    };
  },

  toJSON(message: Document_Style): unknown {
    const obj: any = {};
    if (message.textAnchor !== undefined) {
      obj.textAnchor = Document_TextAnchor.toJSON(message.textAnchor);
    }
    if (message.color !== undefined) {
      obj.color = Color.toJSON(message.color);
    }
    if (message.backgroundColor !== undefined) {
      obj.backgroundColor = Color.toJSON(message.backgroundColor);
    }
    if (message.fontWeight !== "") {
      obj.fontWeight = message.fontWeight;
    }
    if (message.textStyle !== "") {
      obj.textStyle = message.textStyle;
    }
    if (message.textDecoration !== "") {
      obj.textDecoration = message.textDecoration;
    }
    if (message.fontSize !== undefined) {
      obj.fontSize = Document_Style_FontSize.toJSON(message.fontSize);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Style>): Document_Style {
    return Document_Style.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Style>): Document_Style {
    const message = createBaseDocument_Style();
    message.textAnchor = (object.textAnchor !== undefined && object.textAnchor !== null)
      ? Document_TextAnchor.fromPartial(object.textAnchor)
      : undefined;
    message.color = (object.color !== undefined && object.color !== null) ? Color.fromPartial(object.color) : undefined;
    message.backgroundColor = (object.backgroundColor !== undefined && object.backgroundColor !== null)
      ? Color.fromPartial(object.backgroundColor)
      : undefined;
    message.fontWeight = object.fontWeight ?? "";
    message.textStyle = object.textStyle ?? "";
    message.textDecoration = object.textDecoration ?? "";
    message.fontSize = (object.fontSize !== undefined && object.fontSize !== null)
      ? Document_Style_FontSize.fromPartial(object.fontSize)
      : undefined;
    return message;
  },
};

function createBaseDocument_Style_FontSize(): Document_Style_FontSize {
  return { size: 0, unit: "" };
}

export const Document_Style_FontSize: MessageFns<Document_Style_FontSize> = {
  encode(message: Document_Style_FontSize, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.size !== 0) {
      writer.uint32(13).float(message.size);
    }
    if (message.unit !== "") {
      writer.uint32(18).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Style_FontSize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Style_FontSize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.size = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Style_FontSize {
    return {
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: Document_Style_FontSize): unknown {
    const obj: any = {};
    if (message.size !== 0) {
      obj.size = message.size;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Style_FontSize>): Document_Style_FontSize {
    return Document_Style_FontSize.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Style_FontSize>): Document_Style_FontSize {
    const message = createBaseDocument_Style_FontSize();
    message.size = object.size ?? 0;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseDocument_Page(): Document_Page {
  return {
    pageNumber: 0,
    dimension: undefined,
    layout: undefined,
    detectedLanguages: [],
    blocks: [],
    paragraphs: [],
    lines: [],
    tokens: [],
    visualElements: [],
    tables: [],
    formFields: [],
  };
}

export const Document_Page: MessageFns<Document_Page> = {
  encode(message: Document_Page, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageNumber !== 0) {
      writer.uint32(8).int32(message.pageNumber);
    }
    if (message.dimension !== undefined) {
      Document_Page_Dimension.encode(message.dimension, writer.uint32(18).fork()).join();
    }
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(26).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.blocks) {
      Document_Page_Block.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.paragraphs) {
      Document_Page_Paragraph.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.lines) {
      Document_Page_Line.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.tokens) {
      Document_Page_Token.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.visualElements) {
      Document_Page_VisualElement.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.tables) {
      Document_Page_Table.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.formFields) {
      Document_Page_FormField.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageNumber = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dimension = Document_Page_Dimension.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.blocks.push(Document_Page_Block.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.paragraphs.push(Document_Page_Paragraph.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.lines.push(Document_Page_Line.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.tokens.push(Document_Page_Token.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.visualElements.push(Document_Page_VisualElement.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.tables.push(Document_Page_Table.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.formFields.push(Document_Page_FormField.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page {
    return {
      pageNumber: isSet(object.pageNumber) ? globalThis.Number(object.pageNumber) : 0,
      dimension: isSet(object.dimension) ? Document_Page_Dimension.fromJSON(object.dimension) : undefined,
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
      blocks: globalThis.Array.isArray(object?.blocks)
        ? object.blocks.map((e: any) => Document_Page_Block.fromJSON(e))
        : [],
      paragraphs: globalThis.Array.isArray(object?.paragraphs)
        ? object.paragraphs.map((e: any) => Document_Page_Paragraph.fromJSON(e))
        : [],
      lines: globalThis.Array.isArray(object?.lines)
        ? object.lines.map((e: any) => Document_Page_Line.fromJSON(e))
        : [],
      tokens: globalThis.Array.isArray(object?.tokens)
        ? object.tokens.map((e: any) => Document_Page_Token.fromJSON(e))
        : [],
      visualElements: globalThis.Array.isArray(object?.visualElements)
        ? object.visualElements.map((e: any) => Document_Page_VisualElement.fromJSON(e))
        : [],
      tables: globalThis.Array.isArray(object?.tables)
        ? object.tables.map((e: any) => Document_Page_Table.fromJSON(e))
        : [],
      formFields: globalThis.Array.isArray(object?.formFields)
        ? object.formFields.map((e: any) => Document_Page_FormField.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page): unknown {
    const obj: any = {};
    if (message.pageNumber !== 0) {
      obj.pageNumber = Math.round(message.pageNumber);
    }
    if (message.dimension !== undefined) {
      obj.dimension = Document_Page_Dimension.toJSON(message.dimension);
    }
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    if (message.blocks?.length) {
      obj.blocks = message.blocks.map((e) => Document_Page_Block.toJSON(e));
    }
    if (message.paragraphs?.length) {
      obj.paragraphs = message.paragraphs.map((e) => Document_Page_Paragraph.toJSON(e));
    }
    if (message.lines?.length) {
      obj.lines = message.lines.map((e) => Document_Page_Line.toJSON(e));
    }
    if (message.tokens?.length) {
      obj.tokens = message.tokens.map((e) => Document_Page_Token.toJSON(e));
    }
    if (message.visualElements?.length) {
      obj.visualElements = message.visualElements.map((e) => Document_Page_VisualElement.toJSON(e));
    }
    if (message.tables?.length) {
      obj.tables = message.tables.map((e) => Document_Page_Table.toJSON(e));
    }
    if (message.formFields?.length) {
      obj.formFields = message.formFields.map((e) => Document_Page_FormField.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page>): Document_Page {
    return Document_Page.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page>): Document_Page {
    const message = createBaseDocument_Page();
    message.pageNumber = object.pageNumber ?? 0;
    message.dimension = (object.dimension !== undefined && object.dimension !== null)
      ? Document_Page_Dimension.fromPartial(object.dimension)
      : undefined;
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    message.blocks = object.blocks?.map((e) => Document_Page_Block.fromPartial(e)) || [];
    message.paragraphs = object.paragraphs?.map((e) => Document_Page_Paragraph.fromPartial(e)) || [];
    message.lines = object.lines?.map((e) => Document_Page_Line.fromPartial(e)) || [];
    message.tokens = object.tokens?.map((e) => Document_Page_Token.fromPartial(e)) || [];
    message.visualElements = object.visualElements?.map((e) => Document_Page_VisualElement.fromPartial(e)) || [];
    message.tables = object.tables?.map((e) => Document_Page_Table.fromPartial(e)) || [];
    message.formFields = object.formFields?.map((e) => Document_Page_FormField.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_Page_Dimension(): Document_Page_Dimension {
  return { width: 0, height: 0, unit: "" };
}

export const Document_Page_Dimension: MessageFns<Document_Page_Dimension> = {
  encode(message: Document_Page_Dimension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.width !== 0) {
      writer.uint32(13).float(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(21).float(message.height);
    }
    if (message.unit !== "") {
      writer.uint32(26).string(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Dimension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Dimension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.width = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.height = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unit = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Dimension {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
    };
  },

  toJSON(message: Document_Page_Dimension): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Dimension>): Document_Page_Dimension {
    return Document_Page_Dimension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Dimension>): Document_Page_Dimension {
    const message = createBaseDocument_Page_Dimension();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.unit = object.unit ?? "";
    return message;
  },
};

function createBaseDocument_Page_Layout(): Document_Page_Layout {
  return { textAnchor: undefined, confidence: 0, boundingPoly: undefined, orientation: 0 };
}

export const Document_Page_Layout: MessageFns<Document_Page_Layout> = {
  encode(message: Document_Page_Layout, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textAnchor !== undefined) {
      Document_TextAnchor.encode(message.textAnchor, writer.uint32(10).fork()).join();
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    if (message.boundingPoly !== undefined) {
      BoundingPoly.encode(message.boundingPoly, writer.uint32(26).fork()).join();
    }
    if (message.orientation !== 0) {
      writer.uint32(32).int32(message.orientation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Layout {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Layout();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textAnchor = Document_TextAnchor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.boundingPoly = BoundingPoly.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.orientation = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Layout {
    return {
      textAnchor: isSet(object.textAnchor) ? Document_TextAnchor.fromJSON(object.textAnchor) : undefined,
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      boundingPoly: isSet(object.boundingPoly) ? BoundingPoly.fromJSON(object.boundingPoly) : undefined,
      orientation: isSet(object.orientation) ? document_Page_Layout_OrientationFromJSON(object.orientation) : 0,
    };
  },

  toJSON(message: Document_Page_Layout): unknown {
    const obj: any = {};
    if (message.textAnchor !== undefined) {
      obj.textAnchor = Document_TextAnchor.toJSON(message.textAnchor);
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.boundingPoly !== undefined) {
      obj.boundingPoly = BoundingPoly.toJSON(message.boundingPoly);
    }
    if (message.orientation !== 0) {
      obj.orientation = document_Page_Layout_OrientationToJSON(message.orientation);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Layout>): Document_Page_Layout {
    return Document_Page_Layout.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Layout>): Document_Page_Layout {
    const message = createBaseDocument_Page_Layout();
    message.textAnchor = (object.textAnchor !== undefined && object.textAnchor !== null)
      ? Document_TextAnchor.fromPartial(object.textAnchor)
      : undefined;
    message.confidence = object.confidence ?? 0;
    message.boundingPoly = (object.boundingPoly !== undefined && object.boundingPoly !== null)
      ? BoundingPoly.fromPartial(object.boundingPoly)
      : undefined;
    message.orientation = object.orientation ?? 0;
    return message;
  },
};

function createBaseDocument_Page_Block(): Document_Page_Block {
  return { layout: undefined, detectedLanguages: [] };
}

export const Document_Page_Block: MessageFns<Document_Page_Block> = {
  encode(message: Document_Page_Block, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Block {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Block();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Block {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_Block): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Block>): Document_Page_Block {
    return Document_Page_Block.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Block>): Document_Page_Block {
    const message = createBaseDocument_Page_Block();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseDocument_Page_Paragraph(): Document_Page_Paragraph {
  return { layout: undefined, detectedLanguages: [] };
}

export const Document_Page_Paragraph: MessageFns<Document_Page_Paragraph> = {
  encode(message: Document_Page_Paragraph, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Paragraph {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Paragraph();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Paragraph {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_Paragraph): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Paragraph>): Document_Page_Paragraph {
    return Document_Page_Paragraph.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Paragraph>): Document_Page_Paragraph {
    const message = createBaseDocument_Page_Paragraph();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseDocument_Page_Line(): Document_Page_Line {
  return { layout: undefined, detectedLanguages: [] };
}

export const Document_Page_Line: MessageFns<Document_Page_Line> = {
  encode(message: Document_Page_Line, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Line {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Line();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Line {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_Line): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Line>): Document_Page_Line {
    return Document_Page_Line.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Line>): Document_Page_Line {
    const message = createBaseDocument_Page_Line();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseDocument_Page_Token(): Document_Page_Token {
  return { layout: undefined, detectedBreak: undefined, detectedLanguages: [] };
}

export const Document_Page_Token: MessageFns<Document_Page_Token> = {
  encode(message: Document_Page_Token, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    if (message.detectedBreak !== undefined) {
      Document_Page_Token_DetectedBreak.encode(message.detectedBreak, writer.uint32(18).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Token {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Token();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.detectedBreak = Document_Page_Token_DetectedBreak.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Token {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      detectedBreak: isSet(object.detectedBreak)
        ? Document_Page_Token_DetectedBreak.fromJSON(object.detectedBreak)
        : undefined,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_Token): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.detectedBreak !== undefined) {
      obj.detectedBreak = Document_Page_Token_DetectedBreak.toJSON(message.detectedBreak);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Token>): Document_Page_Token {
    return Document_Page_Token.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Token>): Document_Page_Token {
    const message = createBaseDocument_Page_Token();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.detectedBreak = (object.detectedBreak !== undefined && object.detectedBreak !== null)
      ? Document_Page_Token_DetectedBreak.fromPartial(object.detectedBreak)
      : undefined;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseDocument_Page_Token_DetectedBreak(): Document_Page_Token_DetectedBreak {
  return { type: 0 };
}

export const Document_Page_Token_DetectedBreak: MessageFns<Document_Page_Token_DetectedBreak> = {
  encode(message: Document_Page_Token_DetectedBreak, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Token_DetectedBreak {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Token_DetectedBreak();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Token_DetectedBreak {
    return { type: isSet(object.type) ? document_Page_Token_DetectedBreak_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: Document_Page_Token_DetectedBreak): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = document_Page_Token_DetectedBreak_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Token_DetectedBreak>): Document_Page_Token_DetectedBreak {
    return Document_Page_Token_DetectedBreak.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Token_DetectedBreak>): Document_Page_Token_DetectedBreak {
    const message = createBaseDocument_Page_Token_DetectedBreak();
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseDocument_Page_VisualElement(): Document_Page_VisualElement {
  return { layout: undefined, type: "", detectedLanguages: [] };
}

export const Document_Page_VisualElement: MessageFns<Document_Page_VisualElement> = {
  encode(message: Document_Page_VisualElement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_VisualElement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_VisualElement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_VisualElement {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_VisualElement): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_VisualElement>): Document_Page_VisualElement {
    return Document_Page_VisualElement.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_VisualElement>): Document_Page_VisualElement {
    const message = createBaseDocument_Page_VisualElement();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.type = object.type ?? "";
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseDocument_Page_Table(): Document_Page_Table {
  return { layout: undefined, headerRows: [], bodyRows: [], detectedLanguages: [] };
}

export const Document_Page_Table: MessageFns<Document_Page_Table> = {
  encode(message: Document_Page_Table, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    for (const v of message.headerRows) {
      Document_Page_Table_TableRow.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.bodyRows) {
      Document_Page_Table_TableRow.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Table {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Table();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.headerRows.push(Document_Page_Table_TableRow.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.bodyRows.push(Document_Page_Table_TableRow.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Table {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      headerRows: globalThis.Array.isArray(object?.headerRows)
        ? object.headerRows.map((e: any) => Document_Page_Table_TableRow.fromJSON(e))
        : [],
      bodyRows: globalThis.Array.isArray(object?.bodyRows)
        ? object.bodyRows.map((e: any) => Document_Page_Table_TableRow.fromJSON(e))
        : [],
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_Table): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.headerRows?.length) {
      obj.headerRows = message.headerRows.map((e) => Document_Page_Table_TableRow.toJSON(e));
    }
    if (message.bodyRows?.length) {
      obj.bodyRows = message.bodyRows.map((e) => Document_Page_Table_TableRow.toJSON(e));
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Table>): Document_Page_Table {
    return Document_Page_Table.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Table>): Document_Page_Table {
    const message = createBaseDocument_Page_Table();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.headerRows = object.headerRows?.map((e) => Document_Page_Table_TableRow.fromPartial(e)) || [];
    message.bodyRows = object.bodyRows?.map((e) => Document_Page_Table_TableRow.fromPartial(e)) || [];
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseDocument_Page_Table_TableRow(): Document_Page_Table_TableRow {
  return { cells: [] };
}

export const Document_Page_Table_TableRow: MessageFns<Document_Page_Table_TableRow> = {
  encode(message: Document_Page_Table_TableRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cells) {
      Document_Page_Table_TableCell.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Table_TableRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Table_TableRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cells.push(Document_Page_Table_TableCell.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Table_TableRow {
    return {
      cells: globalThis.Array.isArray(object?.cells)
        ? object.cells.map((e: any) => Document_Page_Table_TableCell.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_Table_TableRow): unknown {
    const obj: any = {};
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => Document_Page_Table_TableCell.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Table_TableRow>): Document_Page_Table_TableRow {
    return Document_Page_Table_TableRow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Table_TableRow>): Document_Page_Table_TableRow {
    const message = createBaseDocument_Page_Table_TableRow();
    message.cells = object.cells?.map((e) => Document_Page_Table_TableCell.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_Page_Table_TableCell(): Document_Page_Table_TableCell {
  return { layout: undefined, rowSpan: 0, colSpan: 0, detectedLanguages: [] };
}

export const Document_Page_Table_TableCell: MessageFns<Document_Page_Table_TableCell> = {
  encode(message: Document_Page_Table_TableCell, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.layout !== undefined) {
      Document_Page_Layout.encode(message.layout, writer.uint32(10).fork()).join();
    }
    if (message.rowSpan !== 0) {
      writer.uint32(16).int32(message.rowSpan);
    }
    if (message.colSpan !== 0) {
      writer.uint32(24).int32(message.colSpan);
    }
    for (const v of message.detectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_Table_TableCell {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_Table_TableCell();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.layout = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.rowSpan = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.colSpan = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.detectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_Table_TableCell {
    return {
      layout: isSet(object.layout) ? Document_Page_Layout.fromJSON(object.layout) : undefined,
      rowSpan: isSet(object.rowSpan) ? globalThis.Number(object.rowSpan) : 0,
      colSpan: isSet(object.colSpan) ? globalThis.Number(object.colSpan) : 0,
      detectedLanguages: globalThis.Array.isArray(object?.detectedLanguages)
        ? object.detectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_Table_TableCell): unknown {
    const obj: any = {};
    if (message.layout !== undefined) {
      obj.layout = Document_Page_Layout.toJSON(message.layout);
    }
    if (message.rowSpan !== 0) {
      obj.rowSpan = Math.round(message.rowSpan);
    }
    if (message.colSpan !== 0) {
      obj.colSpan = Math.round(message.colSpan);
    }
    if (message.detectedLanguages?.length) {
      obj.detectedLanguages = message.detectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_Table_TableCell>): Document_Page_Table_TableCell {
    return Document_Page_Table_TableCell.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_Table_TableCell>): Document_Page_Table_TableCell {
    const message = createBaseDocument_Page_Table_TableCell();
    message.layout = (object.layout !== undefined && object.layout !== null)
      ? Document_Page_Layout.fromPartial(object.layout)
      : undefined;
    message.rowSpan = object.rowSpan ?? 0;
    message.colSpan = object.colSpan ?? 0;
    message.detectedLanguages = object.detectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseDocument_Page_FormField(): Document_Page_FormField {
  return { fieldName: undefined, fieldValue: undefined, nameDetectedLanguages: [], valueDetectedLanguages: [] };
}

export const Document_Page_FormField: MessageFns<Document_Page_FormField> = {
  encode(message: Document_Page_FormField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldName !== undefined) {
      Document_Page_Layout.encode(message.fieldName, writer.uint32(10).fork()).join();
    }
    if (message.fieldValue !== undefined) {
      Document_Page_Layout.encode(message.fieldValue, writer.uint32(18).fork()).join();
    }
    for (const v of message.nameDetectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.valueDetectedLanguages) {
      Document_Page_DetectedLanguage.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_FormField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_FormField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fieldName = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fieldValue = Document_Page_Layout.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nameDetectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.valueDetectedLanguages.push(Document_Page_DetectedLanguage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_FormField {
    return {
      fieldName: isSet(object.fieldName) ? Document_Page_Layout.fromJSON(object.fieldName) : undefined,
      fieldValue: isSet(object.fieldValue) ? Document_Page_Layout.fromJSON(object.fieldValue) : undefined,
      nameDetectedLanguages: globalThis.Array.isArray(object?.nameDetectedLanguages)
        ? object.nameDetectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
      valueDetectedLanguages: globalThis.Array.isArray(object?.valueDetectedLanguages)
        ? object.valueDetectedLanguages.map((e: any) => Document_Page_DetectedLanguage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_Page_FormField): unknown {
    const obj: any = {};
    if (message.fieldName !== undefined) {
      obj.fieldName = Document_Page_Layout.toJSON(message.fieldName);
    }
    if (message.fieldValue !== undefined) {
      obj.fieldValue = Document_Page_Layout.toJSON(message.fieldValue);
    }
    if (message.nameDetectedLanguages?.length) {
      obj.nameDetectedLanguages = message.nameDetectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    if (message.valueDetectedLanguages?.length) {
      obj.valueDetectedLanguages = message.valueDetectedLanguages.map((e) => Document_Page_DetectedLanguage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_FormField>): Document_Page_FormField {
    return Document_Page_FormField.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_FormField>): Document_Page_FormField {
    const message = createBaseDocument_Page_FormField();
    message.fieldName = (object.fieldName !== undefined && object.fieldName !== null)
      ? Document_Page_Layout.fromPartial(object.fieldName)
      : undefined;
    message.fieldValue = (object.fieldValue !== undefined && object.fieldValue !== null)
      ? Document_Page_Layout.fromPartial(object.fieldValue)
      : undefined;
    message.nameDetectedLanguages =
      object.nameDetectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) || [];
    message.valueDetectedLanguages =
      object.valueDetectedLanguages?.map((e) => Document_Page_DetectedLanguage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_Page_DetectedLanguage(): Document_Page_DetectedLanguage {
  return { languageCode: "", confidence: 0 };
}

export const Document_Page_DetectedLanguage: MessageFns<Document_Page_DetectedLanguage> = {
  encode(message: Document_Page_DetectedLanguage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.languageCode !== "") {
      writer.uint32(10).string(message.languageCode);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Page_DetectedLanguage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Page_DetectedLanguage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Page_DetectedLanguage {
    return {
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
    };
  },

  toJSON(message: Document_Page_DetectedLanguage): unknown {
    const obj: any = {};
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Page_DetectedLanguage>): Document_Page_DetectedLanguage {
    return Document_Page_DetectedLanguage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Page_DetectedLanguage>): Document_Page_DetectedLanguage {
    const message = createBaseDocument_Page_DetectedLanguage();
    message.languageCode = object.languageCode ?? "";
    message.confidence = object.confidence ?? 0;
    return message;
  },
};

function createBaseDocument_Entity(): Document_Entity {
  return { textAnchor: undefined, type: "", mentionText: "", mentionId: "" };
}

export const Document_Entity: MessageFns<Document_Entity> = {
  encode(message: Document_Entity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textAnchor !== undefined) {
      Document_TextAnchor.encode(message.textAnchor, writer.uint32(10).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.mentionText !== "") {
      writer.uint32(26).string(message.mentionText);
    }
    if (message.mentionId !== "") {
      writer.uint32(34).string(message.mentionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_Entity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_Entity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textAnchor = Document_TextAnchor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mentionText = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mentionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_Entity {
    return {
      textAnchor: isSet(object.textAnchor) ? Document_TextAnchor.fromJSON(object.textAnchor) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      mentionText: isSet(object.mentionText) ? globalThis.String(object.mentionText) : "",
      mentionId: isSet(object.mentionId) ? globalThis.String(object.mentionId) : "",
    };
  },

  toJSON(message: Document_Entity): unknown {
    const obj: any = {};
    if (message.textAnchor !== undefined) {
      obj.textAnchor = Document_TextAnchor.toJSON(message.textAnchor);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.mentionText !== "") {
      obj.mentionText = message.mentionText;
    }
    if (message.mentionId !== "") {
      obj.mentionId = message.mentionId;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_Entity>): Document_Entity {
    return Document_Entity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_Entity>): Document_Entity {
    const message = createBaseDocument_Entity();
    message.textAnchor = (object.textAnchor !== undefined && object.textAnchor !== null)
      ? Document_TextAnchor.fromPartial(object.textAnchor)
      : undefined;
    message.type = object.type ?? "";
    message.mentionText = object.mentionText ?? "";
    message.mentionId = object.mentionId ?? "";
    return message;
  },
};

function createBaseDocument_EntityRelation(): Document_EntityRelation {
  return { subjectId: "", objectId: "", relation: "" };
}

export const Document_EntityRelation: MessageFns<Document_EntityRelation> = {
  encode(message: Document_EntityRelation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subjectId !== "") {
      writer.uint32(10).string(message.subjectId);
    }
    if (message.objectId !== "") {
      writer.uint32(18).string(message.objectId);
    }
    if (message.relation !== "") {
      writer.uint32(26).string(message.relation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_EntityRelation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_EntityRelation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subjectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.objectId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.relation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_EntityRelation {
    return {
      subjectId: isSet(object.subjectId) ? globalThis.String(object.subjectId) : "",
      objectId: isSet(object.objectId) ? globalThis.String(object.objectId) : "",
      relation: isSet(object.relation) ? globalThis.String(object.relation) : "",
    };
  },

  toJSON(message: Document_EntityRelation): unknown {
    const obj: any = {};
    if (message.subjectId !== "") {
      obj.subjectId = message.subjectId;
    }
    if (message.objectId !== "") {
      obj.objectId = message.objectId;
    }
    if (message.relation !== "") {
      obj.relation = message.relation;
    }
    return obj;
  },

  create(base?: DeepPartial<Document_EntityRelation>): Document_EntityRelation {
    return Document_EntityRelation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_EntityRelation>): Document_EntityRelation {
    const message = createBaseDocument_EntityRelation();
    message.subjectId = object.subjectId ?? "";
    message.objectId = object.objectId ?? "";
    message.relation = object.relation ?? "";
    return message;
  },
};

function createBaseDocument_TextAnchor(): Document_TextAnchor {
  return { textSegments: [] };
}

export const Document_TextAnchor: MessageFns<Document_TextAnchor> = {
  encode(message: Document_TextAnchor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.textSegments) {
      Document_TextAnchor_TextSegment.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_TextAnchor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_TextAnchor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.textSegments.push(Document_TextAnchor_TextSegment.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_TextAnchor {
    return {
      textSegments: globalThis.Array.isArray(object?.textSegments)
        ? object.textSegments.map((e: any) => Document_TextAnchor_TextSegment.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Document_TextAnchor): unknown {
    const obj: any = {};
    if (message.textSegments?.length) {
      obj.textSegments = message.textSegments.map((e) => Document_TextAnchor_TextSegment.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Document_TextAnchor>): Document_TextAnchor {
    return Document_TextAnchor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_TextAnchor>): Document_TextAnchor {
    const message = createBaseDocument_TextAnchor();
    message.textSegments = object.textSegments?.map((e) => Document_TextAnchor_TextSegment.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDocument_TextAnchor_TextSegment(): Document_TextAnchor_TextSegment {
  return { startIndex: Long.ZERO, endIndex: Long.ZERO };
}

export const Document_TextAnchor_TextSegment: MessageFns<Document_TextAnchor_TextSegment> = {
  encode(message: Document_TextAnchor_TextSegment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.startIndex.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.startIndex.toString());
    }
    if (!message.endIndex.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.endIndex.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Document_TextAnchor_TextSegment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocument_TextAnchor_TextSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startIndex = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endIndex = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Document_TextAnchor_TextSegment {
    return {
      startIndex: isSet(object.startIndex) ? Long.fromValue(object.startIndex) : Long.ZERO,
      endIndex: isSet(object.endIndex) ? Long.fromValue(object.endIndex) : Long.ZERO,
    };
  },

  toJSON(message: Document_TextAnchor_TextSegment): unknown {
    const obj: any = {};
    if (!message.startIndex.equals(Long.ZERO)) {
      obj.startIndex = (message.startIndex || Long.ZERO).toString();
    }
    if (!message.endIndex.equals(Long.ZERO)) {
      obj.endIndex = (message.endIndex || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Document_TextAnchor_TextSegment>): Document_TextAnchor_TextSegment {
    return Document_TextAnchor_TextSegment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Document_TextAnchor_TextSegment>): Document_TextAnchor_TextSegment {
    const message = createBaseDocument_TextAnchor_TextSegment();
    message.startIndex = (object.startIndex !== undefined && object.startIndex !== null)
      ? Long.fromValue(object.startIndex)
      : Long.ZERO;
    message.endIndex = (object.endIndex !== undefined && object.endIndex !== null)
      ? Long.fromValue(object.endIndex)
      : Long.ZERO;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
