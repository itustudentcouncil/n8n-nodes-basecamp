// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/security/privateca/v1beta1/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../../protobuf/duration.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { BoolValue, Int32Value } from "../../../../protobuf/wrappers.js";

export const protobufPackage = "google.cloud.security.privateca.v1beta1";

/**
 * A [RevocationReason][google.cloud.security.privateca.v1beta1.RevocationReason] indicates whether a [Certificate][google.cloud.security.privateca.v1beta1.Certificate] has been revoked,
 * and the reason for revocation. These correspond to standard revocation
 * reasons from RFC 5280. Note that the enum labels and values in this
 * definition are not the same ASN.1 values defined in RFC 5280. These values
 * will be translated to the correct ASN.1 values when a CRL is created.
 */
export enum RevocationReason {
  /**
   * REVOCATION_REASON_UNSPECIFIED - Default unspecified value. This value does indicate that a [Certificate][google.cloud.security.privateca.v1beta1.Certificate]
   * has been revoked, but that a reason has not been recorded.
   */
  REVOCATION_REASON_UNSPECIFIED = 0,
  /** KEY_COMPROMISE - Key material for this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] may have leaked. */
  KEY_COMPROMISE = 1,
  /**
   * CERTIFICATE_AUTHORITY_COMPROMISE - The key material for a certificate authority in the issuing path may have
   * leaked.
   */
  CERTIFICATE_AUTHORITY_COMPROMISE = 2,
  /** AFFILIATION_CHANGED - The subject or other attributes in this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] have changed. */
  AFFILIATION_CHANGED = 3,
  /** SUPERSEDED - This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] has been superseded. */
  SUPERSEDED = 4,
  /**
   * CESSATION_OF_OPERATION - This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] or entities in the issuing path have ceased to
   * operate.
   */
  CESSATION_OF_OPERATION = 5,
  /**
   * CERTIFICATE_HOLD - This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] should not be considered valid, it is expected that it
   * may become valid in the future.
   */
  CERTIFICATE_HOLD = 6,
  /**
   * PRIVILEGE_WITHDRAWN - This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] no longer has permission to assert the listed
   * attributes.
   */
  PRIVILEGE_WITHDRAWN = 7,
  /**
   * ATTRIBUTE_AUTHORITY_COMPROMISE - The authority which determines appropriate attributes for a [Certificate][google.cloud.security.privateca.v1beta1.Certificate]
   * may have been compromised.
   */
  ATTRIBUTE_AUTHORITY_COMPROMISE = 8,
  UNRECOGNIZED = -1,
}

export function revocationReasonFromJSON(object: any): RevocationReason {
  switch (object) {
    case 0:
    case "REVOCATION_REASON_UNSPECIFIED":
      return RevocationReason.REVOCATION_REASON_UNSPECIFIED;
    case 1:
    case "KEY_COMPROMISE":
      return RevocationReason.KEY_COMPROMISE;
    case 2:
    case "CERTIFICATE_AUTHORITY_COMPROMISE":
      return RevocationReason.CERTIFICATE_AUTHORITY_COMPROMISE;
    case 3:
    case "AFFILIATION_CHANGED":
      return RevocationReason.AFFILIATION_CHANGED;
    case 4:
    case "SUPERSEDED":
      return RevocationReason.SUPERSEDED;
    case 5:
    case "CESSATION_OF_OPERATION":
      return RevocationReason.CESSATION_OF_OPERATION;
    case 6:
    case "CERTIFICATE_HOLD":
      return RevocationReason.CERTIFICATE_HOLD;
    case 7:
    case "PRIVILEGE_WITHDRAWN":
      return RevocationReason.PRIVILEGE_WITHDRAWN;
    case 8:
    case "ATTRIBUTE_AUTHORITY_COMPROMISE":
      return RevocationReason.ATTRIBUTE_AUTHORITY_COMPROMISE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RevocationReason.UNRECOGNIZED;
  }
}

export function revocationReasonToJSON(object: RevocationReason): string {
  switch (object) {
    case RevocationReason.REVOCATION_REASON_UNSPECIFIED:
      return "REVOCATION_REASON_UNSPECIFIED";
    case RevocationReason.KEY_COMPROMISE:
      return "KEY_COMPROMISE";
    case RevocationReason.CERTIFICATE_AUTHORITY_COMPROMISE:
      return "CERTIFICATE_AUTHORITY_COMPROMISE";
    case RevocationReason.AFFILIATION_CHANGED:
      return "AFFILIATION_CHANGED";
    case RevocationReason.SUPERSEDED:
      return "SUPERSEDED";
    case RevocationReason.CESSATION_OF_OPERATION:
      return "CESSATION_OF_OPERATION";
    case RevocationReason.CERTIFICATE_HOLD:
      return "CERTIFICATE_HOLD";
    case RevocationReason.PRIVILEGE_WITHDRAWN:
      return "PRIVILEGE_WITHDRAWN";
    case RevocationReason.ATTRIBUTE_AUTHORITY_COMPROMISE:
      return "ATTRIBUTE_AUTHORITY_COMPROMISE";
    case RevocationReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] represents an individual Certificate Authority.
 * A [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] can be used to create [Certificates][google.cloud.security.privateca.v1beta1.Certificate].
 */
export interface CertificateAuthority {
  /**
   * Output only. The resource name for this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] in the
   * format `projects/* /locations/* /certificateAuthorities/*`.
   */
  name: string;
  /** Required. Immutable. The [Type][google.cloud.security.privateca.v1beta1.CertificateAuthority.Type] of this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. */
  type: CertificateAuthority_Type;
  /** Required. Immutable. The [Tier][google.cloud.security.privateca.v1beta1.CertificateAuthority.Tier] of this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. */
  tier: CertificateAuthority_Tier;
  /** Required. Immutable. The config used to create a self-signed X.509 certificate or CSR. */
  config:
    | CertificateConfig
    | undefined;
  /**
   * Required. The desired lifetime of the CA certificate. Used to create the
   * "not_before_time" and "not_after_time" fields inside an X.509
   * certificate.
   */
  lifetime:
    | Duration
    | undefined;
  /**
   * Required. Immutable. Used when issuing certificates for this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. If this
   * [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] is a self-signed CertificateAuthority, this key
   * is also used to sign the self-signed CA certificate. Otherwise, it
   * is used to sign a CSR.
   */
  keySpec:
    | CertificateAuthority_KeyVersionSpec
    | undefined;
  /**
   * Optional. The [CertificateAuthorityPolicy][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy] to enforce when issuing
   * [Certificates][google.cloud.security.privateca.v1beta1.Certificate] from this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
   */
  certificatePolicy:
    | CertificateAuthority_CertificateAuthorityPolicy
    | undefined;
  /**
   * Optional. The [IssuingOptions][google.cloud.security.privateca.v1beta1.CertificateAuthority.IssuingOptions] to follow when issuing [Certificates][google.cloud.security.privateca.v1beta1.Certificate]
   * from this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
   */
  issuingOptions:
    | CertificateAuthority_IssuingOptions
    | undefined;
  /**
   * Optional. If this is a subordinate [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], this field will be set
   * with the subordinate configuration, which describes its issuers. This may
   * be updated, but this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must continue to validate.
   */
  subordinateConfig:
    | SubordinateConfig
    | undefined;
  /** Output only. The [State][google.cloud.security.privateca.v1beta1.CertificateAuthority.State] for this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. */
  state: CertificateAuthority_State;
  /**
   * Output only. This [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s certificate chain, including the current
   * [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s certificate. Ordered such that the root issuer
   * is the final element (consistent with RFC 5246). For a self-signed CA, this
   * will only list the current [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s certificate.
   */
  pemCaCertificates: string[];
  /**
   * Output only. A structured description of this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s CA certificate
   * and its issuers. Ordered as self-to-root.
   */
  caCertificateDescriptions: CertificateDescription[];
  /**
   * Immutable. The name of a Cloud Storage bucket where this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will
   * publish content, such as the CA certificate and CRLs. This must be a bucket
   * name, without any prefixes (such as `gs://`) or suffixes (such as
   * `.googleapis.com`). For example, to use a bucket named `my-bucket`, you
   * would simply specify `my-bucket`. If not specified, a managed bucket will
   * be created.
   */
  gcsBucket: string;
  /**
   * Output only. URLs for accessing content published by this CA, such as the CA certificate
   * and CRLs.
   */
  accessUrls:
    | CertificateAuthority_AccessUrls
    | undefined;
  /** Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will be deleted, if
   * scheduled for deletion.
   */
  deleteTime:
    | Date
    | undefined;
  /** Optional. Labels with user-defined metadata. */
  labels: { [key: string]: string };
}

/** The type of a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], indicating its issuing chain. */
export enum CertificateAuthority_Type {
  /** TYPE_UNSPECIFIED - Not specified. */
  TYPE_UNSPECIFIED = 0,
  /** SELF_SIGNED - Self-signed CA. */
  SELF_SIGNED = 1,
  /**
   * SUBORDINATE - Subordinate CA. Could be issued by a Private CA [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
   * or an unmanaged CA.
   */
  SUBORDINATE = 2,
  UNRECOGNIZED = -1,
}

export function certificateAuthority_TypeFromJSON(object: any): CertificateAuthority_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return CertificateAuthority_Type.TYPE_UNSPECIFIED;
    case 1:
    case "SELF_SIGNED":
      return CertificateAuthority_Type.SELF_SIGNED;
    case 2:
    case "SUBORDINATE":
      return CertificateAuthority_Type.SUBORDINATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateAuthority_Type.UNRECOGNIZED;
  }
}

export function certificateAuthority_TypeToJSON(object: CertificateAuthority_Type): string {
  switch (object) {
    case CertificateAuthority_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case CertificateAuthority_Type.SELF_SIGNED:
      return "SELF_SIGNED";
    case CertificateAuthority_Type.SUBORDINATE:
      return "SUBORDINATE";
    case CertificateAuthority_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The tier of a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], indicating its supported
 * functionality and/or billing SKU.
 */
export enum CertificateAuthority_Tier {
  /** TIER_UNSPECIFIED - Not specified. */
  TIER_UNSPECIFIED = 0,
  /** ENTERPRISE - Enterprise tier. */
  ENTERPRISE = 1,
  /** DEVOPS - DevOps tier. */
  DEVOPS = 2,
  UNRECOGNIZED = -1,
}

export function certificateAuthority_TierFromJSON(object: any): CertificateAuthority_Tier {
  switch (object) {
    case 0:
    case "TIER_UNSPECIFIED":
      return CertificateAuthority_Tier.TIER_UNSPECIFIED;
    case 1:
    case "ENTERPRISE":
      return CertificateAuthority_Tier.ENTERPRISE;
    case 2:
    case "DEVOPS":
      return CertificateAuthority_Tier.DEVOPS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateAuthority_Tier.UNRECOGNIZED;
  }
}

export function certificateAuthority_TierToJSON(object: CertificateAuthority_Tier): string {
  switch (object) {
    case CertificateAuthority_Tier.TIER_UNSPECIFIED:
      return "TIER_UNSPECIFIED";
    case CertificateAuthority_Tier.ENTERPRISE:
      return "ENTERPRISE";
    case CertificateAuthority_Tier.DEVOPS:
      return "DEVOPS";
    case CertificateAuthority_Tier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The state of a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], indicating if it can be used. */
export enum CertificateAuthority_State {
  /** STATE_UNSPECIFIED - Not specified. */
  STATE_UNSPECIFIED = 0,
  /**
   * ENABLED - Certificates can be issued from this CA. CRLs will be generated for this
   * CA.
   */
  ENABLED = 1,
  /** DISABLED - Certificates cannot be issued from this CA. CRLs will still be generated. */
  DISABLED = 2,
  /** PENDING_ACTIVATION - Certificates cannot be issued from this CA. CRLs will not be generated. */
  PENDING_ACTIVATION = 3,
  /** PENDING_DELETION - Certificates cannot be issued from this CA. CRLs will not be generated. */
  PENDING_DELETION = 4,
  UNRECOGNIZED = -1,
}

export function certificateAuthority_StateFromJSON(object: any): CertificateAuthority_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return CertificateAuthority_State.STATE_UNSPECIFIED;
    case 1:
    case "ENABLED":
      return CertificateAuthority_State.ENABLED;
    case 2:
    case "DISABLED":
      return CertificateAuthority_State.DISABLED;
    case 3:
    case "PENDING_ACTIVATION":
      return CertificateAuthority_State.PENDING_ACTIVATION;
    case 4:
    case "PENDING_DELETION":
      return CertificateAuthority_State.PENDING_DELETION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateAuthority_State.UNRECOGNIZED;
  }
}

export function certificateAuthority_StateToJSON(object: CertificateAuthority_State): string {
  switch (object) {
    case CertificateAuthority_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case CertificateAuthority_State.ENABLED:
      return "ENABLED";
    case CertificateAuthority_State.DISABLED:
      return "DISABLED";
    case CertificateAuthority_State.PENDING_ACTIVATION:
      return "PENDING_ACTIVATION";
    case CertificateAuthority_State.PENDING_DELETION:
      return "PENDING_DELETION";
    case CertificateAuthority_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The algorithm of a Cloud KMS CryptoKeyVersion of a
 * [CryptoKey][google.cloud.kms.v1.CryptoKey] with the
 * [CryptoKeyPurpose][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose] value
 * `ASYMMETRIC_SIGN`. These values correspond to the
 * [CryptoKeyVersionAlgorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
 * values. For RSA signing algorithms, the PSS algorithms should be preferred,
 * use PKCS1 algorithms if required for compatibility. For further
 * recommandations, see
 * https://cloud.google.com/kms/docs/algorithms#algorithm_recommendations.
 */
export enum CertificateAuthority_SignHashAlgorithm {
  /** SIGN_HASH_ALGORITHM_UNSPECIFIED - Not specified. */
  SIGN_HASH_ALGORITHM_UNSPECIFIED = 0,
  /** RSA_PSS_2048_SHA256 - maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256 */
  RSA_PSS_2048_SHA256 = 1,
  /** RSA_PSS_3072_SHA256 - maps to CryptoKeyVersionAlgorithm. RSA_SIGN_PSS_3072_SHA256 */
  RSA_PSS_3072_SHA256 = 2,
  /** RSA_PSS_4096_SHA256 - maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA256 */
  RSA_PSS_4096_SHA256 = 3,
  /** RSA_PKCS1_2048_SHA256 - maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_2048_SHA256 */
  RSA_PKCS1_2048_SHA256 = 6,
  /** RSA_PKCS1_3072_SHA256 - maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_3072_SHA256 */
  RSA_PKCS1_3072_SHA256 = 7,
  /** RSA_PKCS1_4096_SHA256 - maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA256 */
  RSA_PKCS1_4096_SHA256 = 8,
  /** EC_P256_SHA256 - maps to CryptoKeyVersionAlgorithm.EC_SIGN_P256_SHA256 */
  EC_P256_SHA256 = 4,
  /** EC_P384_SHA384 - maps to CryptoKeyVersionAlgorithm.EC_SIGN_P384_SHA384 */
  EC_P384_SHA384 = 5,
  UNRECOGNIZED = -1,
}

export function certificateAuthority_SignHashAlgorithmFromJSON(object: any): CertificateAuthority_SignHashAlgorithm {
  switch (object) {
    case 0:
    case "SIGN_HASH_ALGORITHM_UNSPECIFIED":
      return CertificateAuthority_SignHashAlgorithm.SIGN_HASH_ALGORITHM_UNSPECIFIED;
    case 1:
    case "RSA_PSS_2048_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PSS_2048_SHA256;
    case 2:
    case "RSA_PSS_3072_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PSS_3072_SHA256;
    case 3:
    case "RSA_PSS_4096_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PSS_4096_SHA256;
    case 6:
    case "RSA_PKCS1_2048_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_2048_SHA256;
    case 7:
    case "RSA_PKCS1_3072_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_3072_SHA256;
    case 8:
    case "RSA_PKCS1_4096_SHA256":
      return CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_4096_SHA256;
    case 4:
    case "EC_P256_SHA256":
      return CertificateAuthority_SignHashAlgorithm.EC_P256_SHA256;
    case 5:
    case "EC_P384_SHA384":
      return CertificateAuthority_SignHashAlgorithm.EC_P384_SHA384;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateAuthority_SignHashAlgorithm.UNRECOGNIZED;
  }
}

export function certificateAuthority_SignHashAlgorithmToJSON(object: CertificateAuthority_SignHashAlgorithm): string {
  switch (object) {
    case CertificateAuthority_SignHashAlgorithm.SIGN_HASH_ALGORITHM_UNSPECIFIED:
      return "SIGN_HASH_ALGORITHM_UNSPECIFIED";
    case CertificateAuthority_SignHashAlgorithm.RSA_PSS_2048_SHA256:
      return "RSA_PSS_2048_SHA256";
    case CertificateAuthority_SignHashAlgorithm.RSA_PSS_3072_SHA256:
      return "RSA_PSS_3072_SHA256";
    case CertificateAuthority_SignHashAlgorithm.RSA_PSS_4096_SHA256:
      return "RSA_PSS_4096_SHA256";
    case CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_2048_SHA256:
      return "RSA_PKCS1_2048_SHA256";
    case CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_3072_SHA256:
      return "RSA_PKCS1_3072_SHA256";
    case CertificateAuthority_SignHashAlgorithm.RSA_PKCS1_4096_SHA256:
      return "RSA_PKCS1_4096_SHA256";
    case CertificateAuthority_SignHashAlgorithm.EC_P256_SHA256:
      return "EC_P256_SHA256";
    case CertificateAuthority_SignHashAlgorithm.EC_P384_SHA384:
      return "EC_P384_SHA384";
    case CertificateAuthority_SignHashAlgorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Options that affect all certificates issued by a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. */
export interface CertificateAuthority_IssuingOptions {
  /**
   * Required. When true, includes a URL to the issuing CA certificate in the
   * "authority information access" X.509 extension.
   */
  includeCaCertUrl: boolean;
  /**
   * Required. When true, includes a URL to the CRL corresponding to certificates
   * issued from a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
   * CRLs will expire 7 days from their creation. However, we will rebuild
   * daily. CRLs are also rebuilt shortly after a certificate is revoked.
   */
  includeCrlAccessUrl: boolean;
}

/**
 * The issuing policy for a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
 * [Certificates][google.cloud.security.privateca.v1beta1.Certificate] will not be successfully issued from this
 * [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] if they violate the policy.
 */
export interface CertificateAuthority_CertificateAuthorityPolicy {
  /**
   * Optional. All [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
   * must match at least one listed [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper] in the list.
   */
  allowedConfigList?:
    | CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList
    | undefined;
  /**
   * Optional. All [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
   * will use the provided configuration values, overwriting any requested
   * configuration values.
   */
  overwriteConfigValues?:
    | ReusableConfigWrapper
    | undefined;
  /**
   * Optional. If any [Subject][google.cloud.security.privateca.v1beta1.Subject] is specified here, then all
   * [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must
   * match at least one listed [Subject][google.cloud.security.privateca.v1beta1.Subject]. If a [Subject][google.cloud.security.privateca.v1beta1.Subject] has an empty
   * field, any value will be allowed for that field.
   */
  allowedLocationsAndOrganizations: Subject[];
  /**
   * Optional. If any value is specified here, then all
   * [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must
   * match at least one listed value. If no value is specified, all values
   * will be allowed for this fied. Glob patterns are also supported.
   */
  allowedCommonNames: string[];
  /**
   * Optional. If a [AllowedSubjectAltNames][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames] is specified here, then all
   * [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must
   * match [AllowedSubjectAltNames][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames]. If no value or an empty value
   * is specified, any value will be allowed for the [SubjectAltNames][google.cloud.security.privateca.v1beta1.SubjectAltNames]
   * field.
   */
  allowedSans:
    | CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames
    | undefined;
  /**
   * Optional. The maximum lifetime allowed by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. Note that
   * if the any part if the issuing chain expires before a [Certificate][google.cloud.security.privateca.v1beta1.Certificate]'s
   * requested maximum_lifetime, the effective lifetime will be explicitly
   * truncated.
   */
  maximumLifetime:
    | Duration
    | undefined;
  /**
   * Optional. If specified, then only methods allowed in the [IssuanceModes][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes] may be
   * used to issue [Certificates][google.cloud.security.privateca.v1beta1.Certificate].
   */
  allowedIssuanceModes: CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes | undefined;
}

export interface CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList {
  /**
   * Required. All [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
   * must match at least one listed [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper]. If a
   * [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper] has an empty field, any value will be
   * allowed for that field.
   */
  allowedConfigValues: ReusableConfigWrapper[];
}

/**
 * [AllowedSubjectAltNames][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames] specifies the allowed values for
 * [SubjectAltNames][google.cloud.security.privateca.v1beta1.SubjectAltNames] by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] when issuing
 * [Certificates][google.cloud.security.privateca.v1beta1.Certificate].
 */
export interface CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames {
  /**
   * Optional. Contains valid, fully-qualified host names. Glob patterns are also
   * supported. To allow an explicit wildcard certificate, escape with
   * backlash (i.e. `\*`).
   * E.g. for globbed entries: `*bar.com` will allow `foo.bar.com`, but not
   * `*.bar.com`, unless the [allow_globbing_dns_wildcards][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames.allow_globbing_dns_wildcards] field is set.
   * E.g. for wildcard entries: `\*.bar.com` will allow `*.bar.com`, but not
   * `foo.bar.com`.
   */
  allowedDnsNames: string[];
  /**
   * Optional. Contains valid RFC 3986 URIs. Glob patterns are also supported. To
   * match across path seperators (i.e. '/') use the double star glob
   * pattern (i.e. '**').
   */
  allowedUris: string[];
  /**
   * Optional. Contains valid RFC 2822 E-mail addresses. Glob patterns are also
   * supported.
   */
  allowedEmailAddresses: string[];
  /**
   * Optional. Contains valid 32-bit IPv4 addresses and subnet ranges or RFC 4291 IPv6
   * addresses and subnet ranges. Subnet ranges are specified using the
   * '/' notation (e.g. 10.0.0.0/8, 2001:700:300:1800::/64). Glob patterns
   * are supported only for ip address entries (i.e. not for subnet ranges).
   */
  allowedIps: string[];
  /**
   * Optional. Specifies if glob patterns used for [allowed_dns_names][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames.allowed_dns_names] allows
   * wildcard certificates.
   */
  allowGlobbingDnsWildcards: boolean;
  /** Optional. Specifies if to allow custom X509Extension values. */
  allowCustomSans: boolean;
}

/**
 * [IssuanceModes][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes] specifies the allowed ways in which
 * [Certificates][google.cloud.security.privateca.v1beta1.Certificate] may be requested from this
 * [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
 */
export interface CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes {
  /**
   * Required. When true, allows callers to create [Certificates][google.cloud.security.privateca.v1beta1.Certificate] by
   * specifying a CSR.
   */
  allowCsrBasedIssuance: boolean;
  /**
   * Required. When true, allows callers to create [Certificates][google.cloud.security.privateca.v1beta1.Certificate] by
   * specifying a [CertificateConfig][google.cloud.security.privateca.v1beta1.CertificateConfig].
   */
  allowConfigBasedIssuance: boolean;
}

/** URLs where a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will publish content. */
export interface CertificateAuthority_AccessUrls {
  /**
   * The URL where this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s CA certificate is
   * published. This will only be set for CAs that have been activated.
   */
  caCertificateAccessUrl: string;
  /**
   * The URL where this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s CRLs are published. This
   * will only be set for CAs that have been activated.
   */
  crlAccessUrl: string;
}

/** A Cloud KMS key configuration that a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will use. */
export interface CertificateAuthority_KeyVersionSpec {
  /**
   * Required. The resource name for an existing Cloud KMS CryptoKeyVersion in the
   * format
   * `projects/* /locations/* /keyRings/* /cryptoKeys/* /cryptoKeyVersions/*`.
   * This option enables full flexibility in the key's capabilities and
   * properties.
   */
  cloudKmsKeyVersion?:
    | string
    | undefined;
  /**
   * Required. The algorithm to use for creating a managed Cloud KMS key for a for a
   * simplified experience. All managed keys will be have their
   * [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] as `HSM`.
   */
  algorithm?: CertificateAuthority_SignHashAlgorithm | undefined;
}

export interface CertificateAuthority_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] corresponds to a signed X.509 certificate
 * Revocation List (CRL). A CRL contains the serial numbers of certificates that
 * should no longer be trusted.
 */
export interface CertificateRevocationList {
  /**
   * Output only. The resource path for this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] in
   * the format
   * `projects/* /locations/* /certificateAuthorities/* /
   *    certificateRevocationLists/*`.
   */
  name: string;
  /** Output only. The CRL sequence number that appears in pem_crl. */
  sequenceNumber: Long;
  /** Output only. The revoked serial numbers that appear in pem_crl. */
  revokedCertificates: CertificateRevocationList_RevokedCertificate[];
  /** Output only. The PEM-encoded X.509 CRL. */
  pemCrl: string;
  /** Output only. The location where 'pem_crl' can be accessed. */
  accessUrl: string;
  /** Output only. The [State][google.cloud.security.privateca.v1beta1.CertificateRevocationList.State] for this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList]. */
  state: CertificateRevocationList_State;
  /** Output only. The time at which this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] was updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. Labels with user-defined metadata. */
  labels: { [key: string]: string };
}

/** The state of a [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList], indicating if it is current. */
export enum CertificateRevocationList_State {
  /** STATE_UNSPECIFIED - Not specified. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - The [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] is up to date. */
  ACTIVE = 1,
  /** SUPERSEDED - The [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] is no longer current. */
  SUPERSEDED = 2,
  UNRECOGNIZED = -1,
}

export function certificateRevocationList_StateFromJSON(object: any): CertificateRevocationList_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return CertificateRevocationList_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return CertificateRevocationList_State.ACTIVE;
    case 2:
    case "SUPERSEDED":
      return CertificateRevocationList_State.SUPERSEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CertificateRevocationList_State.UNRECOGNIZED;
  }
}

export function certificateRevocationList_StateToJSON(object: CertificateRevocationList_State): string {
  switch (object) {
    case CertificateRevocationList_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case CertificateRevocationList_State.ACTIVE:
      return "ACTIVE";
    case CertificateRevocationList_State.SUPERSEDED:
      return "SUPERSEDED";
    case CertificateRevocationList_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes a revoked [Certificate][google.cloud.security.privateca.v1beta1.Certificate]. */
export interface CertificateRevocationList_RevokedCertificate {
  /**
   * The resource path for the [Certificate][google.cloud.security.privateca.v1beta1.Certificate] in the format
   * `projects/* /locations/* /certificateAuthorities/* /certificates/*`.
   */
  certificate: string;
  /** The serial number of the [Certificate][google.cloud.security.privateca.v1beta1.Certificate]. */
  hexSerialNumber: string;
  /** The reason the [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was revoked. */
  revocationReason: RevocationReason;
}

export interface CertificateRevocationList_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A [Certificate][google.cloud.security.privateca.v1beta1.Certificate] corresponds to a signed X.509 certificate issued by a
 * [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
 */
export interface Certificate {
  /**
   * Output only. The resource path for this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] in the format
   * `projects/* /locations/* /certificateAuthorities/* /certificates/*`.
   */
  name: string;
  /** Immutable. A pem-encoded X.509 certificate signing request (CSR). */
  pemCsr?:
    | string
    | undefined;
  /**
   * Immutable. A description of the certificate and key that does not require X.509 or
   * ASN.1.
   */
  config?:
    | CertificateConfig
    | undefined;
  /**
   * Required. Immutable. The desired lifetime of a certificate. Used to create the
   * "not_before_time" and "not_after_time" fields inside an X.509
   * certificate. Note that the lifetime may be truncated if it would extend
   * past the life of any certificate authority in the issuing chain.
   */
  lifetime:
    | Duration
    | undefined;
  /**
   * Output only. Details regarding the revocation of this [Certificate][google.cloud.security.privateca.v1beta1.Certificate]. This
   * [Certificate][google.cloud.security.privateca.v1beta1.Certificate] is considered revoked if and only if this field is present.
   */
  revocationDetails:
    | Certificate_RevocationDetails
    | undefined;
  /** Output only. The pem-encoded, signed X.509 certificate. */
  pemCertificate: string;
  /** Output only. A structured description of the issued X.509 certificate. */
  certificateDescription:
    | CertificateDescription
    | undefined;
  /**
   * Output only. The chain that may be used to verify the X.509 certificate. Expected to be
   * in issuer-to-root order according to RFC 5246.
   */
  pemCertificateChain: string[];
  /** Output only. The time at which this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. Labels with user-defined metadata. */
  labels: { [key: string]: string };
}

/** Describes fields that are relavent to the revocation of a [Certificate][google.cloud.security.privateca.v1beta1.Certificate]. */
export interface Certificate_RevocationDetails {
  /** Indicates why a [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was revoked. */
  revocationState: RevocationReason;
  /** The time at which this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was revoked. */
  revocationTime: Date | undefined;
}

export interface Certificate_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] refers to a managed [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues]. Those, in
 * turn, are used to describe certain fields of an X.509 certificate, such as
 * the key usage fields, fields specific to CA certificates, certificate policy
 * extensions and custom extensions.
 */
export interface ReusableConfig {
  /**
   * Output only. The resource path for this [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] in the format
   * `projects/* /locations/* /reusableConfigs/*`.
   */
  name: string;
  /** Required. The config values. */
  values:
    | ReusableConfigValues
    | undefined;
  /**
   * Optional. A human-readable description of scenarios these ReusableConfigValues may be
   * compatible with.
   */
  description: string;
  /** Output only. The time at which this [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which this [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] was updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. Labels with user-defined metadata. */
  labels: { [key: string]: string };
}

export interface ReusableConfig_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues] is used to describe certain fields of an
 * X.509 certificate, such as the key usage fields, fields specific to CA
 * certificates, certificate policy extensions and custom extensions.
 */
export interface ReusableConfigValues {
  /** Optional. Indicates the intended use for keys that correspond to a certificate. */
  keyUsage:
    | KeyUsage
    | undefined;
  /**
   * Optional. Describes options in this [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues] that are
   * relevant in a CA certificate.
   */
  caOptions:
    | ReusableConfigValues_CaOptions
    | undefined;
  /**
   * Optional. Describes the X.509 certificate policy object identifiers, per
   * https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
   */
  policyIds: ObjectId[];
  /**
   * Optional. Describes Online Certificate Status Protocol (OCSP) endpoint addresses
   * that appear in the "Authority Information Access" extension in the
   * certificate.
   */
  aiaOcspServers: string[];
  /** Optional. Describes custom X.509 extensions. */
  additionalExtensions: X509Extension[];
}

/** Describes values that are relevant in a CA certificate. */
export interface ReusableConfigValues_CaOptions {
  /**
   * Optional. Refers to the "CA" X.509 extension, which is a boolean value. When this
   * value is missing, the extension will be omitted from the CA certificate.
   */
  isCa:
    | boolean
    | undefined;
  /**
   * Optional. Refers to the path length restriction X.509 extension. For a CA
   * certificate, this value describes the depth of subordinate CA
   * certificates that are allowed.
   * If this value is less than 0, the request will fail.
   * If this value is missing, the max path length will be omitted from the
   * CA certificate.
   */
  maxIssuerPathLength: number | undefined;
}

/**
 * A [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper] describes values that may assist in creating an
 * X.509 certificate, or a reference to a pre-defined set of values.
 */
export interface ReusableConfigWrapper {
  /**
   * Required. A resource path to a [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] in the format
   * `projects/* /locations/* /reusableConfigs/*`.
   */
  reusableConfig?:
    | string
    | undefined;
  /** Required. A user-specified inline [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues]. */
  reusableConfigValues?: ReusableConfigValues | undefined;
}

/**
 * Describes a subordinate CA's issuers. This is either a resource path to a
 * known issuing [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], or a PEM issuer certificate chain.
 */
export interface SubordinateConfig {
  /**
   * Required. This can refer to a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] in the same project that
   * was used to create a subordinate [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. This field
   * is used for information and usability purposes only. The resource name
   * is in the format `projects/* /locations/* /certificateAuthorities/*`.
   */
  certificateAuthority?:
    | string
    | undefined;
  /**
   * Required. Contains the PEM certificate chain for the issuers of this
   * [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], but not pem certificate for this CA itself.
   */
  pemIssuerChain?: SubordinateConfig_SubordinateConfigChain | undefined;
}

/**
 * This message describes a subordinate CA's issuer certificate chain. This
 * wrapper exists for compatibility reasons.
 */
export interface SubordinateConfig_SubordinateConfigChain {
  /** Required. Expected to be in leaf-to-root order according to RFC 5246. */
  pemCertificates: string[];
}

/** A [PublicKey][google.cloud.security.privateca.v1beta1.PublicKey] describes a public key. */
export interface PublicKey {
  /** Required. The type of public key. */
  type: PublicKey_KeyType;
  /**
   * Required. A public key. Padding and encoding varies by 'KeyType' and is described
   * along with the KeyType values.
   */
  key: Buffer;
}

/**
 * Types of public keys that are supported.
 * At a minimum, we support RSA and ECDSA, for the key sizes or curves listed:
 * https://cloud.google.com/kms/docs/algorithms#asymmetric_signing_algorithms
 */
export enum PublicKey_KeyType {
  /** KEY_TYPE_UNSPECIFIED - Default unspecified value. */
  KEY_TYPE_UNSPECIFIED = 0,
  /** PEM_RSA_KEY - A PEM-encoded PKCS#1/RFC 3447 RSAPrivateKey structure. */
  PEM_RSA_KEY = 1,
  /** PEM_EC_KEY - A PEM-encoded compressed NIST P-256/secp256r1/prime256v1 or P-384 key. */
  PEM_EC_KEY = 2,
  UNRECOGNIZED = -1,
}

export function publicKey_KeyTypeFromJSON(object: any): PublicKey_KeyType {
  switch (object) {
    case 0:
    case "KEY_TYPE_UNSPECIFIED":
      return PublicKey_KeyType.KEY_TYPE_UNSPECIFIED;
    case 1:
    case "PEM_RSA_KEY":
      return PublicKey_KeyType.PEM_RSA_KEY;
    case 2:
    case "PEM_EC_KEY":
      return PublicKey_KeyType.PEM_EC_KEY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PublicKey_KeyType.UNRECOGNIZED;
  }
}

export function publicKey_KeyTypeToJSON(object: PublicKey_KeyType): string {
  switch (object) {
    case PublicKey_KeyType.KEY_TYPE_UNSPECIFIED:
      return "KEY_TYPE_UNSPECIFIED";
    case PublicKey_KeyType.PEM_RSA_KEY:
      return "PEM_RSA_KEY";
    case PublicKey_KeyType.PEM_EC_KEY:
      return "PEM_EC_KEY";
    case PublicKey_KeyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A [CertificateConfig][google.cloud.security.privateca.v1beta1.CertificateConfig] describes an X.509 certificate or CSR that is to be
 * created, as an alternative to using ASN.1.
 */
export interface CertificateConfig {
  /**
   * Required. Specifies some of the values in a certificate that are related to the
   * subject.
   */
  subjectConfig:
    | CertificateConfig_SubjectConfig
    | undefined;
  /**
   * Required. Describes how some of the technical fields in a certificate should be
   * populated.
   */
  reusableConfig:
    | ReusableConfigWrapper
    | undefined;
  /**
   * Optional. The public key that corresponds to this config. This is, for example, used
   * when issuing [Certificates][google.cloud.security.privateca.v1beta1.Certificate], but not when creating a
   * self-signed [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] or [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] CSR.
   */
  publicKey: PublicKey | undefined;
}

/**
 * These values are used to create the distinguished name and subject
 * alternative name fields in an X.509 certificate.
 */
export interface CertificateConfig_SubjectConfig {
  /** Required. Contains distinguished name fields such as the location and organization. */
  subject:
    | Subject
    | undefined;
  /** Optional. The "common name" of the distinguished name. */
  commonName: string;
  /** Optional. The subject alternative name fields. */
  subjectAltName: SubjectAltNames | undefined;
}

/**
 * A [CertificateDescription][google.cloud.security.privateca.v1beta1.CertificateDescription] describes an X.509 certificate or CSR that has
 * been issued, as an alternative to using ASN.1 / X.509.
 */
export interface CertificateDescription {
  /**
   * Describes some of the values in a certificate that are related to the
   * subject and lifetime.
   */
  subjectDescription:
    | CertificateDescription_SubjectDescription
    | undefined;
  /** Describes some of the technical fields in a certificate. */
  configValues:
    | ReusableConfigValues
    | undefined;
  /** The public key that corresponds to an issued certificate. */
  publicKey:
    | PublicKey
    | undefined;
  /**
   * Provides a means of identifiying certificates that contain a particular
   * public key, per https://tools.ietf.org/html/rfc5280#section-4.2.1.2.
   */
  subjectKeyId:
    | CertificateDescription_KeyId
    | undefined;
  /**
   * Identifies the subject_key_id of the parent certificate, per
   * https://tools.ietf.org/html/rfc5280#section-4.2.1.1
   */
  authorityKeyId:
    | CertificateDescription_KeyId
    | undefined;
  /**
   * Describes a list of locations to obtain CRL information, i.e.
   * the DistributionPoint.fullName described by
   * https://tools.ietf.org/html/rfc5280#section-4.2.1.13
   */
  crlDistributionPoints: string[];
  /**
   * Describes lists of issuer CA certificate URLs that appear in the
   * "Authority Information Access" extension in the certificate.
   */
  aiaIssuingCertificateUrls: string[];
  /** The hash of the x.509 certificate. */
  certFingerprint: CertificateDescription_CertificateFingerprint | undefined;
}

/**
 * These values describe fields in an issued X.509 certificate such as the
 * distinguished name, subject alternative names, serial number, and lifetime.
 */
export interface CertificateDescription_SubjectDescription {
  /** Contains distinguished name fields such as the location and organization. */
  subject:
    | Subject
    | undefined;
  /** The "common name" of the distinguished name. */
  commonName: string;
  /** The subject alternative name fields. */
  subjectAltName:
    | SubjectAltNames
    | undefined;
  /** The serial number encoded in lowercase hexadecimal. */
  hexSerialNumber: string;
  /**
   * For convenience, the actual lifetime of an issued certificate.
   * Corresponds to 'not_after_time' - 'not_before_time'.
   */
  lifetime:
    | Duration
    | undefined;
  /** The time at which the certificate becomes valid. */
  notBeforeTime:
    | Date
    | undefined;
  /** The time at which the certificate expires. */
  notAfterTime: Date | undefined;
}

/**
 * A KeyId identifies a specific public key, usually by hashing the public
 * key.
 */
export interface CertificateDescription_KeyId {
  /**
   * Optional. The value of this KeyId encoded in lowercase hexadecimal. This is most
   * likely the 160 bit SHA-1 hash of the public key.
   */
  keyId: string;
}

/** A group of fingerprints for the x509 certificate. */
export interface CertificateDescription_CertificateFingerprint {
  /** The SHA 256 hash, encoded in hexadecimal, of the DER x509 certificate. */
  sha256Hash: string;
}

/**
 * An [ObjectId][google.cloud.security.privateca.v1beta1.ObjectId] specifies an object identifier (OID). These provide context
 * and describe types in ASN.1 messages.
 */
export interface ObjectId {
  /**
   * Required. The parts of an OID path. The most significant parts of the path come
   * first.
   */
  objectIdPath: number[];
}

/**
 * An [X509Extension][google.cloud.security.privateca.v1beta1.X509Extension] specifies an X.509 extension, which may be used in
 * different parts of X.509 objects like certificates, CSRs, and CRLs.
 */
export interface X509Extension {
  /** Required. The OID for this X.509 extension. */
  objectId:
    | ObjectId
    | undefined;
  /**
   * Required. Indicates whether or not this extension is critical (i.e., if the client
   * does not know how to handle this extension, the client should consider this
   * to be an error).
   */
  critical: boolean;
  /** Required. The value of this X.509 extension. */
  value: Buffer;
}

/**
 * A [KeyUsage][google.cloud.security.privateca.v1beta1.KeyUsage] describes key usage values that may appear in an X.509
 * certificate.
 */
export interface KeyUsage {
  /** Describes high-level ways in which a key may be used. */
  baseKeyUsage:
    | KeyUsage_KeyUsageOptions
    | undefined;
  /** Detailed scenarios in which a key may be used. */
  extendedKeyUsage:
    | KeyUsage_ExtendedKeyUsageOptions
    | undefined;
  /**
   * Used to describe extended key usages that are not listed in the
   * [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1beta1.KeyUsage.ExtendedKeyUsageOptions] message.
   */
  unknownExtendedKeyUsages: ObjectId[];
}

/**
 * [KeyUsage.KeyUsageOptions][google.cloud.security.privateca.v1beta1.KeyUsage.KeyUsageOptions] corresponds to the key usage values
 * described in https://tools.ietf.org/html/rfc5280#section-4.2.1.3.
 */
export interface KeyUsage_KeyUsageOptions {
  /** The key may be used for digital signatures. */
  digitalSignature: boolean;
  /**
   * The key may be used for cryptographic commitments. Note that this may
   * also be referred to as "non-repudiation".
   */
  contentCommitment: boolean;
  /** The key may be used to encipher other keys. */
  keyEncipherment: boolean;
  /** The key may be used to encipher data. */
  dataEncipherment: boolean;
  /** The key may be used in a key agreement protocol. */
  keyAgreement: boolean;
  /** The key may be used to sign certificates. */
  certSign: boolean;
  /** The key may be used sign certificate revocation lists. */
  crlSign: boolean;
  /** The key may be used to encipher only. */
  encipherOnly: boolean;
  /** The key may be used to decipher only. */
  decipherOnly: boolean;
}

/**
 * [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1beta1.KeyUsage.ExtendedKeyUsageOptions] has fields that correspond to
 * certain common OIDs that could be specified as an extended key usage value.
 */
export interface KeyUsage_ExtendedKeyUsageOptions {
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW
   * server authentication", though regularly used for non-WWW TLS.
   */
  serverAuth: boolean;
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW
   * client authentication", though regularly used for non-WWW TLS.
   */
  clientAuth: boolean;
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of
   * downloadable executable code client authentication".
   */
  codeSigning: boolean;
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email
   * protection".
   */
  emailProtection: boolean;
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding
   * the hash of an object to a time".
   */
  timeStamping: boolean;
  /**
   * Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing
   * OCSP responses".
   */
  ocspSigning: boolean;
}

/**
 * [Subject][google.cloud.security.privateca.v1beta1.Subject] describes parts of a distinguished name that, in turn,
 * describes the subject of the certificate.
 */
export interface Subject {
  /** The country code of the subject. */
  countryCode: string;
  /** The organization of the subject. */
  organization: string;
  /** The organizational_unit of the subject. */
  organizationalUnit: string;
  /** The locality or city of the subject. */
  locality: string;
  /** The province, territory, or regional state of the subject. */
  province: string;
  /** The street address of the subject. */
  streetAddress: string;
  /** The postal code of the subject. */
  postalCode: string;
}

/**
 * [SubjectAltNames][google.cloud.security.privateca.v1beta1.SubjectAltNames] corresponds to a more modern way of listing what
 * the asserted identity is in a certificate (i.e., compared to the "common
 * name" in the distinguished name).
 */
export interface SubjectAltNames {
  /** Contains only valid, fully-qualified host names. */
  dnsNames: string[];
  /** Contains only valid RFC 3986 URIs. */
  uris: string[];
  /** Contains only valid RFC 2822 E-mail addresses. */
  emailAddresses: string[];
  /** Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses. */
  ipAddresses: string[];
  /** Contains additional subject alternative name values. */
  customSans: X509Extension[];
}

function createBaseCertificateAuthority(): CertificateAuthority {
  return {
    name: "",
    type: 0,
    tier: 0,
    config: undefined,
    lifetime: undefined,
    keySpec: undefined,
    certificatePolicy: undefined,
    issuingOptions: undefined,
    subordinateConfig: undefined,
    state: 0,
    pemCaCertificates: [],
    caCertificateDescriptions: [],
    gcsBucket: "",
    accessUrls: undefined,
    createTime: undefined,
    updateTime: undefined,
    deleteTime: undefined,
    labels: {},
  };
}

export const CertificateAuthority: MessageFns<CertificateAuthority> = {
  encode(message: CertificateAuthority, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.tier !== 0) {
      writer.uint32(24).int32(message.tier);
    }
    if (message.config !== undefined) {
      CertificateConfig.encode(message.config, writer.uint32(34).fork()).join();
    }
    if (message.lifetime !== undefined) {
      Duration.encode(message.lifetime, writer.uint32(42).fork()).join();
    }
    if (message.keySpec !== undefined) {
      CertificateAuthority_KeyVersionSpec.encode(message.keySpec, writer.uint32(50).fork()).join();
    }
    if (message.certificatePolicy !== undefined) {
      CertificateAuthority_CertificateAuthorityPolicy.encode(message.certificatePolicy, writer.uint32(58).fork())
        .join();
    }
    if (message.issuingOptions !== undefined) {
      CertificateAuthority_IssuingOptions.encode(message.issuingOptions, writer.uint32(66).fork()).join();
    }
    if (message.subordinateConfig !== undefined) {
      SubordinateConfig.encode(message.subordinateConfig, writer.uint32(154).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    for (const v of message.pemCaCertificates) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.caCertificateDescriptions) {
      CertificateDescription.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.gcsBucket !== "") {
      writer.uint32(106).string(message.gcsBucket);
    }
    if (message.accessUrls !== undefined) {
      CertificateAuthority_AccessUrls.encode(message.accessUrls, writer.uint32(114).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(122).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(130).fork()).join();
    }
    if (message.deleteTime !== undefined) {
      Timestamp.encode(toTimestamp(message.deleteTime), writer.uint32(138).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CertificateAuthority_LabelsEntry.encode({ key: key as any, value }, writer.uint32(146).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateAuthority {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.config = CertificateConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lifetime = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.keySpec = CertificateAuthority_KeyVersionSpec.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.certificatePolicy = CertificateAuthority_CertificateAuthorityPolicy.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.issuingOptions = CertificateAuthority_IssuingOptions.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.subordinateConfig = SubordinateConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.pemCaCertificates.push(reader.string());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.caCertificateDescriptions.push(CertificateDescription.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.gcsBucket = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.accessUrls = CertificateAuthority_AccessUrls.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.deleteTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          const entry18 = CertificateAuthority_LabelsEntry.decode(reader, reader.uint32());
          if (entry18.value !== undefined) {
            message.labels[entry18.key] = entry18.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? certificateAuthority_TypeFromJSON(object.type) : 0,
      tier: isSet(object.tier) ? certificateAuthority_TierFromJSON(object.tier) : 0,
      config: isSet(object.config) ? CertificateConfig.fromJSON(object.config) : undefined,
      lifetime: isSet(object.lifetime) ? Duration.fromJSON(object.lifetime) : undefined,
      keySpec: isSet(object.keySpec) ? CertificateAuthority_KeyVersionSpec.fromJSON(object.keySpec) : undefined,
      certificatePolicy: isSet(object.certificatePolicy)
        ? CertificateAuthority_CertificateAuthorityPolicy.fromJSON(object.certificatePolicy)
        : undefined,
      issuingOptions: isSet(object.issuingOptions)
        ? CertificateAuthority_IssuingOptions.fromJSON(object.issuingOptions)
        : undefined,
      subordinateConfig: isSet(object.subordinateConfig)
        ? SubordinateConfig.fromJSON(object.subordinateConfig)
        : undefined,
      state: isSet(object.state) ? certificateAuthority_StateFromJSON(object.state) : 0,
      pemCaCertificates: globalThis.Array.isArray(object?.pemCaCertificates)
        ? object.pemCaCertificates.map((e: any) => globalThis.String(e))
        : [],
      caCertificateDescriptions: globalThis.Array.isArray(object?.caCertificateDescriptions)
        ? object.caCertificateDescriptions.map((e: any) => CertificateDescription.fromJSON(e))
        : [],
      gcsBucket: isSet(object.gcsBucket) ? globalThis.String(object.gcsBucket) : "",
      accessUrls: isSet(object.accessUrls) ? CertificateAuthority_AccessUrls.fromJSON(object.accessUrls) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      deleteTime: isSet(object.deleteTime) ? fromJsonTimestamp(object.deleteTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CertificateAuthority): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = certificateAuthority_TypeToJSON(message.type);
    }
    if (message.tier !== 0) {
      obj.tier = certificateAuthority_TierToJSON(message.tier);
    }
    if (message.config !== undefined) {
      obj.config = CertificateConfig.toJSON(message.config);
    }
    if (message.lifetime !== undefined) {
      obj.lifetime = Duration.toJSON(message.lifetime);
    }
    if (message.keySpec !== undefined) {
      obj.keySpec = CertificateAuthority_KeyVersionSpec.toJSON(message.keySpec);
    }
    if (message.certificatePolicy !== undefined) {
      obj.certificatePolicy = CertificateAuthority_CertificateAuthorityPolicy.toJSON(message.certificatePolicy);
    }
    if (message.issuingOptions !== undefined) {
      obj.issuingOptions = CertificateAuthority_IssuingOptions.toJSON(message.issuingOptions);
    }
    if (message.subordinateConfig !== undefined) {
      obj.subordinateConfig = SubordinateConfig.toJSON(message.subordinateConfig);
    }
    if (message.state !== 0) {
      obj.state = certificateAuthority_StateToJSON(message.state);
    }
    if (message.pemCaCertificates?.length) {
      obj.pemCaCertificates = message.pemCaCertificates;
    }
    if (message.caCertificateDescriptions?.length) {
      obj.caCertificateDescriptions = message.caCertificateDescriptions.map((e) => CertificateDescription.toJSON(e));
    }
    if (message.gcsBucket !== "") {
      obj.gcsBucket = message.gcsBucket;
    }
    if (message.accessUrls !== undefined) {
      obj.accessUrls = CertificateAuthority_AccessUrls.toJSON(message.accessUrls);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.deleteTime !== undefined) {
      obj.deleteTime = message.deleteTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateAuthority>): CertificateAuthority {
    return CertificateAuthority.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateAuthority>): CertificateAuthority {
    const message = createBaseCertificateAuthority();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.tier = object.tier ?? 0;
    message.config = (object.config !== undefined && object.config !== null)
      ? CertificateConfig.fromPartial(object.config)
      : undefined;
    message.lifetime = (object.lifetime !== undefined && object.lifetime !== null)
      ? Duration.fromPartial(object.lifetime)
      : undefined;
    message.keySpec = (object.keySpec !== undefined && object.keySpec !== null)
      ? CertificateAuthority_KeyVersionSpec.fromPartial(object.keySpec)
      : undefined;
    message.certificatePolicy = (object.certificatePolicy !== undefined && object.certificatePolicy !== null)
      ? CertificateAuthority_CertificateAuthorityPolicy.fromPartial(object.certificatePolicy)
      : undefined;
    message.issuingOptions = (object.issuingOptions !== undefined && object.issuingOptions !== null)
      ? CertificateAuthority_IssuingOptions.fromPartial(object.issuingOptions)
      : undefined;
    message.subordinateConfig = (object.subordinateConfig !== undefined && object.subordinateConfig !== null)
      ? SubordinateConfig.fromPartial(object.subordinateConfig)
      : undefined;
    message.state = object.state ?? 0;
    message.pemCaCertificates = object.pemCaCertificates?.map((e) => e) || [];
    message.caCertificateDescriptions =
      object.caCertificateDescriptions?.map((e) => CertificateDescription.fromPartial(e)) || [];
    message.gcsBucket = object.gcsBucket ?? "";
    message.accessUrls = (object.accessUrls !== undefined && object.accessUrls !== null)
      ? CertificateAuthority_AccessUrls.fromPartial(object.accessUrls)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.deleteTime = object.deleteTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCertificateAuthority_IssuingOptions(): CertificateAuthority_IssuingOptions {
  return { includeCaCertUrl: false, includeCrlAccessUrl: false };
}

export const CertificateAuthority_IssuingOptions: MessageFns<CertificateAuthority_IssuingOptions> = {
  encode(message: CertificateAuthority_IssuingOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeCaCertUrl !== false) {
      writer.uint32(8).bool(message.includeCaCertUrl);
    }
    if (message.includeCrlAccessUrl !== false) {
      writer.uint32(16).bool(message.includeCrlAccessUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateAuthority_IssuingOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority_IssuingOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.includeCaCertUrl = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.includeCrlAccessUrl = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority_IssuingOptions {
    return {
      includeCaCertUrl: isSet(object.includeCaCertUrl) ? globalThis.Boolean(object.includeCaCertUrl) : false,
      includeCrlAccessUrl: isSet(object.includeCrlAccessUrl) ? globalThis.Boolean(object.includeCrlAccessUrl) : false,
    };
  },

  toJSON(message: CertificateAuthority_IssuingOptions): unknown {
    const obj: any = {};
    if (message.includeCaCertUrl !== false) {
      obj.includeCaCertUrl = message.includeCaCertUrl;
    }
    if (message.includeCrlAccessUrl !== false) {
      obj.includeCrlAccessUrl = message.includeCrlAccessUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateAuthority_IssuingOptions>): CertificateAuthority_IssuingOptions {
    return CertificateAuthority_IssuingOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateAuthority_IssuingOptions>): CertificateAuthority_IssuingOptions {
    const message = createBaseCertificateAuthority_IssuingOptions();
    message.includeCaCertUrl = object.includeCaCertUrl ?? false;
    message.includeCrlAccessUrl = object.includeCrlAccessUrl ?? false;
    return message;
  },
};

function createBaseCertificateAuthority_CertificateAuthorityPolicy(): CertificateAuthority_CertificateAuthorityPolicy {
  return {
    allowedConfigList: undefined,
    overwriteConfigValues: undefined,
    allowedLocationsAndOrganizations: [],
    allowedCommonNames: [],
    allowedSans: undefined,
    maximumLifetime: undefined,
    allowedIssuanceModes: undefined,
  };
}

export const CertificateAuthority_CertificateAuthorityPolicy: MessageFns<
  CertificateAuthority_CertificateAuthorityPolicy
> = {
  encode(
    message: CertificateAuthority_CertificateAuthorityPolicy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.allowedConfigList !== undefined) {
      CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList.encode(
        message.allowedConfigList,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.overwriteConfigValues !== undefined) {
      ReusableConfigWrapper.encode(message.overwriteConfigValues, writer.uint32(18).fork()).join();
    }
    for (const v of message.allowedLocationsAndOrganizations) {
      Subject.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.allowedCommonNames) {
      writer.uint32(34).string(v!);
    }
    if (message.allowedSans !== undefined) {
      CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames.encode(
        message.allowedSans,
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.maximumLifetime !== undefined) {
      Duration.encode(message.maximumLifetime, writer.uint32(50).fork()).join();
    }
    if (message.allowedIssuanceModes !== undefined) {
      CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes.encode(
        message.allowedIssuanceModes,
        writer.uint32(66).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateAuthority_CertificateAuthorityPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority_CertificateAuthorityPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedConfigList = CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.overwriteConfigValues = ReusableConfigWrapper.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.allowedLocationsAndOrganizations.push(Subject.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.allowedCommonNames.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.allowedSans = CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames.decode(
            reader,
            reader.uint32(),
          );
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.maximumLifetime = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.allowedIssuanceModes = CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority_CertificateAuthorityPolicy {
    return {
      allowedConfigList: isSet(object.allowedConfigList)
        ? CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList.fromJSON(object.allowedConfigList)
        : undefined,
      overwriteConfigValues: isSet(object.overwriteConfigValues)
        ? ReusableConfigWrapper.fromJSON(object.overwriteConfigValues)
        : undefined,
      allowedLocationsAndOrganizations: globalThis.Array.isArray(object?.allowedLocationsAndOrganizations)
        ? object.allowedLocationsAndOrganizations.map((e: any) => Subject.fromJSON(e))
        : [],
      allowedCommonNames: globalThis.Array.isArray(object?.allowedCommonNames)
        ? object.allowedCommonNames.map((e: any) => globalThis.String(e))
        : [],
      allowedSans: isSet(object.allowedSans)
        ? CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames.fromJSON(object.allowedSans)
        : undefined,
      maximumLifetime: isSet(object.maximumLifetime) ? Duration.fromJSON(object.maximumLifetime) : undefined,
      allowedIssuanceModes: isSet(object.allowedIssuanceModes)
        ? CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes.fromJSON(object.allowedIssuanceModes)
        : undefined,
    };
  },

  toJSON(message: CertificateAuthority_CertificateAuthorityPolicy): unknown {
    const obj: any = {};
    if (message.allowedConfigList !== undefined) {
      obj.allowedConfigList = CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList.toJSON(
        message.allowedConfigList,
      );
    }
    if (message.overwriteConfigValues !== undefined) {
      obj.overwriteConfigValues = ReusableConfigWrapper.toJSON(message.overwriteConfigValues);
    }
    if (message.allowedLocationsAndOrganizations?.length) {
      obj.allowedLocationsAndOrganizations = message.allowedLocationsAndOrganizations.map((e) => Subject.toJSON(e));
    }
    if (message.allowedCommonNames?.length) {
      obj.allowedCommonNames = message.allowedCommonNames;
    }
    if (message.allowedSans !== undefined) {
      obj.allowedSans = CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames.toJSON(
        message.allowedSans,
      );
    }
    if (message.maximumLifetime !== undefined) {
      obj.maximumLifetime = Duration.toJSON(message.maximumLifetime);
    }
    if (message.allowedIssuanceModes !== undefined) {
      obj.allowedIssuanceModes = CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes.toJSON(
        message.allowedIssuanceModes,
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<CertificateAuthority_CertificateAuthorityPolicy>,
  ): CertificateAuthority_CertificateAuthorityPolicy {
    return CertificateAuthority_CertificateAuthorityPolicy.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CertificateAuthority_CertificateAuthorityPolicy>,
  ): CertificateAuthority_CertificateAuthorityPolicy {
    const message = createBaseCertificateAuthority_CertificateAuthorityPolicy();
    message.allowedConfigList = (object.allowedConfigList !== undefined && object.allowedConfigList !== null)
      ? CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList.fromPartial(object.allowedConfigList)
      : undefined;
    message.overwriteConfigValues =
      (object.overwriteConfigValues !== undefined && object.overwriteConfigValues !== null)
        ? ReusableConfigWrapper.fromPartial(object.overwriteConfigValues)
        : undefined;
    message.allowedLocationsAndOrganizations =
      object.allowedLocationsAndOrganizations?.map((e) => Subject.fromPartial(e)) || [];
    message.allowedCommonNames = object.allowedCommonNames?.map((e) => e) || [];
    message.allowedSans = (object.allowedSans !== undefined && object.allowedSans !== null)
      ? CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames.fromPartial(object.allowedSans)
      : undefined;
    message.maximumLifetime = (object.maximumLifetime !== undefined && object.maximumLifetime !== null)
      ? Duration.fromPartial(object.maximumLifetime)
      : undefined;
    message.allowedIssuanceModes = (object.allowedIssuanceModes !== undefined && object.allowedIssuanceModes !== null)
      ? CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes.fromPartial(object.allowedIssuanceModes)
      : undefined;
    return message;
  },
};

function createBaseCertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList(): CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList {
  return { allowedConfigValues: [] };
}

export const CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList: MessageFns<
  CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList
> = {
  encode(
    message: CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.allowedConfigValues) {
      ReusableConfigWrapper.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedConfigValues.push(ReusableConfigWrapper.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList {
    return {
      allowedConfigValues: globalThis.Array.isArray(object?.allowedConfigValues)
        ? object.allowedConfigValues.map((e: any) => ReusableConfigWrapper.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList): unknown {
    const obj: any = {};
    if (message.allowedConfigValues?.length) {
      obj.allowedConfigValues = message.allowedConfigValues.map((e) => ReusableConfigWrapper.toJSON(e));
    }
    return obj;
  },

  create(
    base?: DeepPartial<CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList>,
  ): CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList {
    return CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList>,
  ): CertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList {
    const message = createBaseCertificateAuthority_CertificateAuthorityPolicy_AllowedConfigList();
    message.allowedConfigValues = object.allowedConfigValues?.map((e) => ReusableConfigWrapper.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames(): CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames {
  return {
    allowedDnsNames: [],
    allowedUris: [],
    allowedEmailAddresses: [],
    allowedIps: [],
    allowGlobbingDnsWildcards: false,
    allowCustomSans: false,
  };
}

export const CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames: MessageFns<
  CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames
> = {
  encode(
    message: CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.allowedDnsNames) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.allowedUris) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.allowedEmailAddresses) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.allowedIps) {
      writer.uint32(34).string(v!);
    }
    if (message.allowGlobbingDnsWildcards !== false) {
      writer.uint32(40).bool(message.allowGlobbingDnsWildcards);
    }
    if (message.allowCustomSans !== false) {
      writer.uint32(48).bool(message.allowCustomSans);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowedDnsNames.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.allowedUris.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.allowedEmailAddresses.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.allowedIps.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.allowGlobbingDnsWildcards = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.allowCustomSans = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames {
    return {
      allowedDnsNames: globalThis.Array.isArray(object?.allowedDnsNames)
        ? object.allowedDnsNames.map((e: any) => globalThis.String(e))
        : [],
      allowedUris: globalThis.Array.isArray(object?.allowedUris)
        ? object.allowedUris.map((e: any) => globalThis.String(e))
        : [],
      allowedEmailAddresses: globalThis.Array.isArray(object?.allowedEmailAddresses)
        ? object.allowedEmailAddresses.map((e: any) => globalThis.String(e))
        : [],
      allowedIps: globalThis.Array.isArray(object?.allowedIps)
        ? object.allowedIps.map((e: any) => globalThis.String(e))
        : [],
      allowGlobbingDnsWildcards: isSet(object.allowGlobbingDnsWildcards)
        ? globalThis.Boolean(object.allowGlobbingDnsWildcards)
        : false,
      allowCustomSans: isSet(object.allowCustomSans) ? globalThis.Boolean(object.allowCustomSans) : false,
    };
  },

  toJSON(message: CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames): unknown {
    const obj: any = {};
    if (message.allowedDnsNames?.length) {
      obj.allowedDnsNames = message.allowedDnsNames;
    }
    if (message.allowedUris?.length) {
      obj.allowedUris = message.allowedUris;
    }
    if (message.allowedEmailAddresses?.length) {
      obj.allowedEmailAddresses = message.allowedEmailAddresses;
    }
    if (message.allowedIps?.length) {
      obj.allowedIps = message.allowedIps;
    }
    if (message.allowGlobbingDnsWildcards !== false) {
      obj.allowGlobbingDnsWildcards = message.allowGlobbingDnsWildcards;
    }
    if (message.allowCustomSans !== false) {
      obj.allowCustomSans = message.allowCustomSans;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames>,
  ): CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames {
    return CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames>,
  ): CertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames {
    const message = createBaseCertificateAuthority_CertificateAuthorityPolicy_AllowedSubjectAltNames();
    message.allowedDnsNames = object.allowedDnsNames?.map((e) => e) || [];
    message.allowedUris = object.allowedUris?.map((e) => e) || [];
    message.allowedEmailAddresses = object.allowedEmailAddresses?.map((e) => e) || [];
    message.allowedIps = object.allowedIps?.map((e) => e) || [];
    message.allowGlobbingDnsWildcards = object.allowGlobbingDnsWildcards ?? false;
    message.allowCustomSans = object.allowCustomSans ?? false;
    return message;
  },
};

function createBaseCertificateAuthority_CertificateAuthorityPolicy_IssuanceModes(): CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes {
  return { allowCsrBasedIssuance: false, allowConfigBasedIssuance: false };
}

export const CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes: MessageFns<
  CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes
> = {
  encode(
    message: CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.allowCsrBasedIssuance !== false) {
      writer.uint32(8).bool(message.allowCsrBasedIssuance);
    }
    if (message.allowConfigBasedIssuance !== false) {
      writer.uint32(16).bool(message.allowConfigBasedIssuance);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority_CertificateAuthorityPolicy_IssuanceModes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.allowCsrBasedIssuance = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowConfigBasedIssuance = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes {
    return {
      allowCsrBasedIssuance: isSet(object.allowCsrBasedIssuance)
        ? globalThis.Boolean(object.allowCsrBasedIssuance)
        : false,
      allowConfigBasedIssuance: isSet(object.allowConfigBasedIssuance)
        ? globalThis.Boolean(object.allowConfigBasedIssuance)
        : false,
    };
  },

  toJSON(message: CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes): unknown {
    const obj: any = {};
    if (message.allowCsrBasedIssuance !== false) {
      obj.allowCsrBasedIssuance = message.allowCsrBasedIssuance;
    }
    if (message.allowConfigBasedIssuance !== false) {
      obj.allowConfigBasedIssuance = message.allowConfigBasedIssuance;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes>,
  ): CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes {
    return CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes>,
  ): CertificateAuthority_CertificateAuthorityPolicy_IssuanceModes {
    const message = createBaseCertificateAuthority_CertificateAuthorityPolicy_IssuanceModes();
    message.allowCsrBasedIssuance = object.allowCsrBasedIssuance ?? false;
    message.allowConfigBasedIssuance = object.allowConfigBasedIssuance ?? false;
    return message;
  },
};

function createBaseCertificateAuthority_AccessUrls(): CertificateAuthority_AccessUrls {
  return { caCertificateAccessUrl: "", crlAccessUrl: "" };
}

export const CertificateAuthority_AccessUrls: MessageFns<CertificateAuthority_AccessUrls> = {
  encode(message: CertificateAuthority_AccessUrls, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.caCertificateAccessUrl !== "") {
      writer.uint32(10).string(message.caCertificateAccessUrl);
    }
    if (message.crlAccessUrl !== "") {
      writer.uint32(18).string(message.crlAccessUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateAuthority_AccessUrls {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority_AccessUrls();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.caCertificateAccessUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.crlAccessUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority_AccessUrls {
    return {
      caCertificateAccessUrl: isSet(object.caCertificateAccessUrl)
        ? globalThis.String(object.caCertificateAccessUrl)
        : "",
      crlAccessUrl: isSet(object.crlAccessUrl) ? globalThis.String(object.crlAccessUrl) : "",
    };
  },

  toJSON(message: CertificateAuthority_AccessUrls): unknown {
    const obj: any = {};
    if (message.caCertificateAccessUrl !== "") {
      obj.caCertificateAccessUrl = message.caCertificateAccessUrl;
    }
    if (message.crlAccessUrl !== "") {
      obj.crlAccessUrl = message.crlAccessUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateAuthority_AccessUrls>): CertificateAuthority_AccessUrls {
    return CertificateAuthority_AccessUrls.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateAuthority_AccessUrls>): CertificateAuthority_AccessUrls {
    const message = createBaseCertificateAuthority_AccessUrls();
    message.caCertificateAccessUrl = object.caCertificateAccessUrl ?? "";
    message.crlAccessUrl = object.crlAccessUrl ?? "";
    return message;
  },
};

function createBaseCertificateAuthority_KeyVersionSpec(): CertificateAuthority_KeyVersionSpec {
  return { cloudKmsKeyVersion: undefined, algorithm: undefined };
}

export const CertificateAuthority_KeyVersionSpec: MessageFns<CertificateAuthority_KeyVersionSpec> = {
  encode(message: CertificateAuthority_KeyVersionSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cloudKmsKeyVersion !== undefined) {
      writer.uint32(10).string(message.cloudKmsKeyVersion);
    }
    if (message.algorithm !== undefined) {
      writer.uint32(16).int32(message.algorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateAuthority_KeyVersionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority_KeyVersionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cloudKmsKeyVersion = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority_KeyVersionSpec {
    return {
      cloudKmsKeyVersion: isSet(object.cloudKmsKeyVersion) ? globalThis.String(object.cloudKmsKeyVersion) : undefined,
      algorithm: isSet(object.algorithm) ? certificateAuthority_SignHashAlgorithmFromJSON(object.algorithm) : undefined,
    };
  },

  toJSON(message: CertificateAuthority_KeyVersionSpec): unknown {
    const obj: any = {};
    if (message.cloudKmsKeyVersion !== undefined) {
      obj.cloudKmsKeyVersion = message.cloudKmsKeyVersion;
    }
    if (message.algorithm !== undefined) {
      obj.algorithm = certificateAuthority_SignHashAlgorithmToJSON(message.algorithm);
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateAuthority_KeyVersionSpec>): CertificateAuthority_KeyVersionSpec {
    return CertificateAuthority_KeyVersionSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateAuthority_KeyVersionSpec>): CertificateAuthority_KeyVersionSpec {
    const message = createBaseCertificateAuthority_KeyVersionSpec();
    message.cloudKmsKeyVersion = object.cloudKmsKeyVersion ?? undefined;
    message.algorithm = object.algorithm ?? undefined;
    return message;
  },
};

function createBaseCertificateAuthority_LabelsEntry(): CertificateAuthority_LabelsEntry {
  return { key: "", value: "" };
}

export const CertificateAuthority_LabelsEntry: MessageFns<CertificateAuthority_LabelsEntry> = {
  encode(message: CertificateAuthority_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateAuthority_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateAuthority_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateAuthority_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CertificateAuthority_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateAuthority_LabelsEntry>): CertificateAuthority_LabelsEntry {
    return CertificateAuthority_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateAuthority_LabelsEntry>): CertificateAuthority_LabelsEntry {
    const message = createBaseCertificateAuthority_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCertificateRevocationList(): CertificateRevocationList {
  return {
    name: "",
    sequenceNumber: Long.ZERO,
    revokedCertificates: [],
    pemCrl: "",
    accessUrl: "",
    state: 0,
    createTime: undefined,
    updateTime: undefined,
    labels: {},
  };
}

export const CertificateRevocationList: MessageFns<CertificateRevocationList> = {
  encode(message: CertificateRevocationList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.sequenceNumber.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.sequenceNumber.toString());
    }
    for (const v of message.revokedCertificates) {
      CertificateRevocationList_RevokedCertificate.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.pemCrl !== "") {
      writer.uint32(34).string(message.pemCrl);
    }
    if (message.accessUrl !== "") {
      writer.uint32(42).string(message.accessUrl);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      CertificateRevocationList_LabelsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateRevocationList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateRevocationList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.sequenceNumber = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.revokedCertificates.push(
            CertificateRevocationList_RevokedCertificate.decode(reader, reader.uint32()),
          );
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pemCrl = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.accessUrl = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = CertificateRevocationList_LabelsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.labels[entry9.key] = entry9.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateRevocationList {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sequenceNumber: isSet(object.sequenceNumber) ? Long.fromValue(object.sequenceNumber) : Long.ZERO,
      revokedCertificates: globalThis.Array.isArray(object?.revokedCertificates)
        ? object.revokedCertificates.map((e: any) => CertificateRevocationList_RevokedCertificate.fromJSON(e))
        : [],
      pemCrl: isSet(object.pemCrl) ? globalThis.String(object.pemCrl) : "",
      accessUrl: isSet(object.accessUrl) ? globalThis.String(object.accessUrl) : "",
      state: isSet(object.state) ? certificateRevocationList_StateFromJSON(object.state) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CertificateRevocationList): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.sequenceNumber.equals(Long.ZERO)) {
      obj.sequenceNumber = (message.sequenceNumber || Long.ZERO).toString();
    }
    if (message.revokedCertificates?.length) {
      obj.revokedCertificates = message.revokedCertificates.map((e) =>
        CertificateRevocationList_RevokedCertificate.toJSON(e)
      );
    }
    if (message.pemCrl !== "") {
      obj.pemCrl = message.pemCrl;
    }
    if (message.accessUrl !== "") {
      obj.accessUrl = message.accessUrl;
    }
    if (message.state !== 0) {
      obj.state = certificateRevocationList_StateToJSON(message.state);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateRevocationList>): CertificateRevocationList {
    return CertificateRevocationList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateRevocationList>): CertificateRevocationList {
    const message = createBaseCertificateRevocationList();
    message.name = object.name ?? "";
    message.sequenceNumber = (object.sequenceNumber !== undefined && object.sequenceNumber !== null)
      ? Long.fromValue(object.sequenceNumber)
      : Long.ZERO;
    message.revokedCertificates =
      object.revokedCertificates?.map((e) => CertificateRevocationList_RevokedCertificate.fromPartial(e)) || [];
    message.pemCrl = object.pemCrl ?? "";
    message.accessUrl = object.accessUrl ?? "";
    message.state = object.state ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCertificateRevocationList_RevokedCertificate(): CertificateRevocationList_RevokedCertificate {
  return { certificate: "", hexSerialNumber: "", revocationReason: 0 };
}

export const CertificateRevocationList_RevokedCertificate: MessageFns<CertificateRevocationList_RevokedCertificate> = {
  encode(
    message: CertificateRevocationList_RevokedCertificate,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.certificate !== "") {
      writer.uint32(10).string(message.certificate);
    }
    if (message.hexSerialNumber !== "") {
      writer.uint32(18).string(message.hexSerialNumber);
    }
    if (message.revocationReason !== 0) {
      writer.uint32(24).int32(message.revocationReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateRevocationList_RevokedCertificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateRevocationList_RevokedCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificate = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hexSerialNumber = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.revocationReason = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateRevocationList_RevokedCertificate {
    return {
      certificate: isSet(object.certificate) ? globalThis.String(object.certificate) : "",
      hexSerialNumber: isSet(object.hexSerialNumber) ? globalThis.String(object.hexSerialNumber) : "",
      revocationReason: isSet(object.revocationReason) ? revocationReasonFromJSON(object.revocationReason) : 0,
    };
  },

  toJSON(message: CertificateRevocationList_RevokedCertificate): unknown {
    const obj: any = {};
    if (message.certificate !== "") {
      obj.certificate = message.certificate;
    }
    if (message.hexSerialNumber !== "") {
      obj.hexSerialNumber = message.hexSerialNumber;
    }
    if (message.revocationReason !== 0) {
      obj.revocationReason = revocationReasonToJSON(message.revocationReason);
    }
    return obj;
  },

  create(
    base?: DeepPartial<CertificateRevocationList_RevokedCertificate>,
  ): CertificateRevocationList_RevokedCertificate {
    return CertificateRevocationList_RevokedCertificate.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CertificateRevocationList_RevokedCertificate>,
  ): CertificateRevocationList_RevokedCertificate {
    const message = createBaseCertificateRevocationList_RevokedCertificate();
    message.certificate = object.certificate ?? "";
    message.hexSerialNumber = object.hexSerialNumber ?? "";
    message.revocationReason = object.revocationReason ?? 0;
    return message;
  },
};

function createBaseCertificateRevocationList_LabelsEntry(): CertificateRevocationList_LabelsEntry {
  return { key: "", value: "" };
}

export const CertificateRevocationList_LabelsEntry: MessageFns<CertificateRevocationList_LabelsEntry> = {
  encode(message: CertificateRevocationList_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateRevocationList_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateRevocationList_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateRevocationList_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CertificateRevocationList_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateRevocationList_LabelsEntry>): CertificateRevocationList_LabelsEntry {
    return CertificateRevocationList_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateRevocationList_LabelsEntry>): CertificateRevocationList_LabelsEntry {
    const message = createBaseCertificateRevocationList_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCertificate(): Certificate {
  return {
    name: "",
    pemCsr: undefined,
    config: undefined,
    lifetime: undefined,
    revocationDetails: undefined,
    pemCertificate: "",
    certificateDescription: undefined,
    pemCertificateChain: [],
    createTime: undefined,
    updateTime: undefined,
    labels: {},
  };
}

export const Certificate: MessageFns<Certificate> = {
  encode(message: Certificate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.pemCsr !== undefined) {
      writer.uint32(18).string(message.pemCsr);
    }
    if (message.config !== undefined) {
      CertificateConfig.encode(message.config, writer.uint32(26).fork()).join();
    }
    if (message.lifetime !== undefined) {
      Duration.encode(message.lifetime, writer.uint32(34).fork()).join();
    }
    if (message.revocationDetails !== undefined) {
      Certificate_RevocationDetails.encode(message.revocationDetails, writer.uint32(42).fork()).join();
    }
    if (message.pemCertificate !== "") {
      writer.uint32(50).string(message.pemCertificate);
    }
    if (message.certificateDescription !== undefined) {
      CertificateDescription.encode(message.certificateDescription, writer.uint32(58).fork()).join();
    }
    for (const v of message.pemCertificateChain) {
      writer.uint32(66).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Certificate_LabelsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pemCsr = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.config = CertificateConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lifetime = Duration.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.revocationDetails = Certificate_RevocationDetails.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.pemCertificate = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.certificateDescription = CertificateDescription.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.pemCertificateChain.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = Certificate_LabelsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.labels[entry11.key] = entry11.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      pemCsr: isSet(object.pemCsr) ? globalThis.String(object.pemCsr) : undefined,
      config: isSet(object.config) ? CertificateConfig.fromJSON(object.config) : undefined,
      lifetime: isSet(object.lifetime) ? Duration.fromJSON(object.lifetime) : undefined,
      revocationDetails: isSet(object.revocationDetails)
        ? Certificate_RevocationDetails.fromJSON(object.revocationDetails)
        : undefined,
      pemCertificate: isSet(object.pemCertificate) ? globalThis.String(object.pemCertificate) : "",
      certificateDescription: isSet(object.certificateDescription)
        ? CertificateDescription.fromJSON(object.certificateDescription)
        : undefined,
      pemCertificateChain: globalThis.Array.isArray(object?.pemCertificateChain)
        ? object.pemCertificateChain.map((e: any) => globalThis.String(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Certificate): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.pemCsr !== undefined) {
      obj.pemCsr = message.pemCsr;
    }
    if (message.config !== undefined) {
      obj.config = CertificateConfig.toJSON(message.config);
    }
    if (message.lifetime !== undefined) {
      obj.lifetime = Duration.toJSON(message.lifetime);
    }
    if (message.revocationDetails !== undefined) {
      obj.revocationDetails = Certificate_RevocationDetails.toJSON(message.revocationDetails);
    }
    if (message.pemCertificate !== "") {
      obj.pemCertificate = message.pemCertificate;
    }
    if (message.certificateDescription !== undefined) {
      obj.certificateDescription = CertificateDescription.toJSON(message.certificateDescription);
    }
    if (message.pemCertificateChain?.length) {
      obj.pemCertificateChain = message.pemCertificateChain;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate>): Certificate {
    return Certificate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate>): Certificate {
    const message = createBaseCertificate();
    message.name = object.name ?? "";
    message.pemCsr = object.pemCsr ?? undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? CertificateConfig.fromPartial(object.config)
      : undefined;
    message.lifetime = (object.lifetime !== undefined && object.lifetime !== null)
      ? Duration.fromPartial(object.lifetime)
      : undefined;
    message.revocationDetails = (object.revocationDetails !== undefined && object.revocationDetails !== null)
      ? Certificate_RevocationDetails.fromPartial(object.revocationDetails)
      : undefined;
    message.pemCertificate = object.pemCertificate ?? "";
    message.certificateDescription =
      (object.certificateDescription !== undefined && object.certificateDescription !== null)
        ? CertificateDescription.fromPartial(object.certificateDescription)
        : undefined;
    message.pemCertificateChain = object.pemCertificateChain?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCertificate_RevocationDetails(): Certificate_RevocationDetails {
  return { revocationState: 0, revocationTime: undefined };
}

export const Certificate_RevocationDetails: MessageFns<Certificate_RevocationDetails> = {
  encode(message: Certificate_RevocationDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.revocationState !== 0) {
      writer.uint32(8).int32(message.revocationState);
    }
    if (message.revocationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.revocationTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_RevocationDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_RevocationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.revocationState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.revocationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_RevocationDetails {
    return {
      revocationState: isSet(object.revocationState) ? revocationReasonFromJSON(object.revocationState) : 0,
      revocationTime: isSet(object.revocationTime) ? fromJsonTimestamp(object.revocationTime) : undefined,
    };
  },

  toJSON(message: Certificate_RevocationDetails): unknown {
    const obj: any = {};
    if (message.revocationState !== 0) {
      obj.revocationState = revocationReasonToJSON(message.revocationState);
    }
    if (message.revocationTime !== undefined) {
      obj.revocationTime = message.revocationTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate_RevocationDetails>): Certificate_RevocationDetails {
    return Certificate_RevocationDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate_RevocationDetails>): Certificate_RevocationDetails {
    const message = createBaseCertificate_RevocationDetails();
    message.revocationState = object.revocationState ?? 0;
    message.revocationTime = object.revocationTime ?? undefined;
    return message;
  },
};

function createBaseCertificate_LabelsEntry(): Certificate_LabelsEntry {
  return { key: "", value: "" };
}

export const Certificate_LabelsEntry: MessageFns<Certificate_LabelsEntry> = {
  encode(message: Certificate_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Certificate_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificate_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Certificate_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Certificate_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Certificate_LabelsEntry>): Certificate_LabelsEntry {
    return Certificate_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Certificate_LabelsEntry>): Certificate_LabelsEntry {
    const message = createBaseCertificate_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseReusableConfig(): ReusableConfig {
  return { name: "", values: undefined, description: "", createTime: undefined, updateTime: undefined, labels: {} };
}

export const ReusableConfig: MessageFns<ReusableConfig> = {
  encode(message: ReusableConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.values !== undefined) {
      ReusableConfigValues.encode(message.values, writer.uint32(18).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ReusableConfig_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReusableConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReusableConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.values = ReusableConfigValues.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = ReusableConfig_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReusableConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      values: isSet(object.values) ? ReusableConfigValues.fromJSON(object.values) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ReusableConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.values !== undefined) {
      obj.values = ReusableConfigValues.toJSON(message.values);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ReusableConfig>): ReusableConfig {
    return ReusableConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReusableConfig>): ReusableConfig {
    const message = createBaseReusableConfig();
    message.name = object.name ?? "";
    message.values = (object.values !== undefined && object.values !== null)
      ? ReusableConfigValues.fromPartial(object.values)
      : undefined;
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseReusableConfig_LabelsEntry(): ReusableConfig_LabelsEntry {
  return { key: "", value: "" };
}

export const ReusableConfig_LabelsEntry: MessageFns<ReusableConfig_LabelsEntry> = {
  encode(message: ReusableConfig_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReusableConfig_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReusableConfig_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReusableConfig_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ReusableConfig_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ReusableConfig_LabelsEntry>): ReusableConfig_LabelsEntry {
    return ReusableConfig_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReusableConfig_LabelsEntry>): ReusableConfig_LabelsEntry {
    const message = createBaseReusableConfig_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseReusableConfigValues(): ReusableConfigValues {
  return { keyUsage: undefined, caOptions: undefined, policyIds: [], aiaOcspServers: [], additionalExtensions: [] };
}

export const ReusableConfigValues: MessageFns<ReusableConfigValues> = {
  encode(message: ReusableConfigValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyUsage !== undefined) {
      KeyUsage.encode(message.keyUsage, writer.uint32(10).fork()).join();
    }
    if (message.caOptions !== undefined) {
      ReusableConfigValues_CaOptions.encode(message.caOptions, writer.uint32(18).fork()).join();
    }
    for (const v of message.policyIds) {
      ObjectId.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.aiaOcspServers) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.additionalExtensions) {
      X509Extension.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReusableConfigValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReusableConfigValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyUsage = KeyUsage.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.caOptions = ReusableConfigValues_CaOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.policyIds.push(ObjectId.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.aiaOcspServers.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.additionalExtensions.push(X509Extension.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReusableConfigValues {
    return {
      keyUsage: isSet(object.keyUsage) ? KeyUsage.fromJSON(object.keyUsage) : undefined,
      caOptions: isSet(object.caOptions) ? ReusableConfigValues_CaOptions.fromJSON(object.caOptions) : undefined,
      policyIds: globalThis.Array.isArray(object?.policyIds)
        ? object.policyIds.map((e: any) => ObjectId.fromJSON(e))
        : [],
      aiaOcspServers: globalThis.Array.isArray(object?.aiaOcspServers)
        ? object.aiaOcspServers.map((e: any) => globalThis.String(e))
        : [],
      additionalExtensions: globalThis.Array.isArray(object?.additionalExtensions)
        ? object.additionalExtensions.map((e: any) => X509Extension.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReusableConfigValues): unknown {
    const obj: any = {};
    if (message.keyUsage !== undefined) {
      obj.keyUsage = KeyUsage.toJSON(message.keyUsage);
    }
    if (message.caOptions !== undefined) {
      obj.caOptions = ReusableConfigValues_CaOptions.toJSON(message.caOptions);
    }
    if (message.policyIds?.length) {
      obj.policyIds = message.policyIds.map((e) => ObjectId.toJSON(e));
    }
    if (message.aiaOcspServers?.length) {
      obj.aiaOcspServers = message.aiaOcspServers;
    }
    if (message.additionalExtensions?.length) {
      obj.additionalExtensions = message.additionalExtensions.map((e) => X509Extension.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ReusableConfigValues>): ReusableConfigValues {
    return ReusableConfigValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReusableConfigValues>): ReusableConfigValues {
    const message = createBaseReusableConfigValues();
    message.keyUsage = (object.keyUsage !== undefined && object.keyUsage !== null)
      ? KeyUsage.fromPartial(object.keyUsage)
      : undefined;
    message.caOptions = (object.caOptions !== undefined && object.caOptions !== null)
      ? ReusableConfigValues_CaOptions.fromPartial(object.caOptions)
      : undefined;
    message.policyIds = object.policyIds?.map((e) => ObjectId.fromPartial(e)) || [];
    message.aiaOcspServers = object.aiaOcspServers?.map((e) => e) || [];
    message.additionalExtensions = object.additionalExtensions?.map((e) => X509Extension.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReusableConfigValues_CaOptions(): ReusableConfigValues_CaOptions {
  return { isCa: undefined, maxIssuerPathLength: undefined };
}

export const ReusableConfigValues_CaOptions: MessageFns<ReusableConfigValues_CaOptions> = {
  encode(message: ReusableConfigValues_CaOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isCa !== undefined) {
      BoolValue.encode({ value: message.isCa! }, writer.uint32(10).fork()).join();
    }
    if (message.maxIssuerPathLength !== undefined) {
      Int32Value.encode({ value: message.maxIssuerPathLength! }, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReusableConfigValues_CaOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReusableConfigValues_CaOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.isCa = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.maxIssuerPathLength = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReusableConfigValues_CaOptions {
    return {
      isCa: isSet(object.isCa) ? Boolean(object.isCa) : undefined,
      maxIssuerPathLength: isSet(object.maxIssuerPathLength) ? Number(object.maxIssuerPathLength) : undefined,
    };
  },

  toJSON(message: ReusableConfigValues_CaOptions): unknown {
    const obj: any = {};
    if (message.isCa !== undefined) {
      obj.isCa = message.isCa;
    }
    if (message.maxIssuerPathLength !== undefined) {
      obj.maxIssuerPathLength = message.maxIssuerPathLength;
    }
    return obj;
  },

  create(base?: DeepPartial<ReusableConfigValues_CaOptions>): ReusableConfigValues_CaOptions {
    return ReusableConfigValues_CaOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReusableConfigValues_CaOptions>): ReusableConfigValues_CaOptions {
    const message = createBaseReusableConfigValues_CaOptions();
    message.isCa = object.isCa ?? undefined;
    message.maxIssuerPathLength = object.maxIssuerPathLength ?? undefined;
    return message;
  },
};

function createBaseReusableConfigWrapper(): ReusableConfigWrapper {
  return { reusableConfig: undefined, reusableConfigValues: undefined };
}

export const ReusableConfigWrapper: MessageFns<ReusableConfigWrapper> = {
  encode(message: ReusableConfigWrapper, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reusableConfig !== undefined) {
      writer.uint32(10).string(message.reusableConfig);
    }
    if (message.reusableConfigValues !== undefined) {
      ReusableConfigValues.encode(message.reusableConfigValues, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReusableConfigWrapper {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReusableConfigWrapper();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reusableConfig = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reusableConfigValues = ReusableConfigValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReusableConfigWrapper {
    return {
      reusableConfig: isSet(object.reusableConfig) ? globalThis.String(object.reusableConfig) : undefined,
      reusableConfigValues: isSet(object.reusableConfigValues)
        ? ReusableConfigValues.fromJSON(object.reusableConfigValues)
        : undefined,
    };
  },

  toJSON(message: ReusableConfigWrapper): unknown {
    const obj: any = {};
    if (message.reusableConfig !== undefined) {
      obj.reusableConfig = message.reusableConfig;
    }
    if (message.reusableConfigValues !== undefined) {
      obj.reusableConfigValues = ReusableConfigValues.toJSON(message.reusableConfigValues);
    }
    return obj;
  },

  create(base?: DeepPartial<ReusableConfigWrapper>): ReusableConfigWrapper {
    return ReusableConfigWrapper.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReusableConfigWrapper>): ReusableConfigWrapper {
    const message = createBaseReusableConfigWrapper();
    message.reusableConfig = object.reusableConfig ?? undefined;
    message.reusableConfigValues = (object.reusableConfigValues !== undefined && object.reusableConfigValues !== null)
      ? ReusableConfigValues.fromPartial(object.reusableConfigValues)
      : undefined;
    return message;
  },
};

function createBaseSubordinateConfig(): SubordinateConfig {
  return { certificateAuthority: undefined, pemIssuerChain: undefined };
}

export const SubordinateConfig: MessageFns<SubordinateConfig> = {
  encode(message: SubordinateConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.certificateAuthority !== undefined) {
      writer.uint32(10).string(message.certificateAuthority);
    }
    if (message.pemIssuerChain !== undefined) {
      SubordinateConfig_SubordinateConfigChain.encode(message.pemIssuerChain, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubordinateConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubordinateConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.certificateAuthority = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pemIssuerChain = SubordinateConfig_SubordinateConfigChain.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubordinateConfig {
    return {
      certificateAuthority: isSet(object.certificateAuthority)
        ? globalThis.String(object.certificateAuthority)
        : undefined,
      pemIssuerChain: isSet(object.pemIssuerChain)
        ? SubordinateConfig_SubordinateConfigChain.fromJSON(object.pemIssuerChain)
        : undefined,
    };
  },

  toJSON(message: SubordinateConfig): unknown {
    const obj: any = {};
    if (message.certificateAuthority !== undefined) {
      obj.certificateAuthority = message.certificateAuthority;
    }
    if (message.pemIssuerChain !== undefined) {
      obj.pemIssuerChain = SubordinateConfig_SubordinateConfigChain.toJSON(message.pemIssuerChain);
    }
    return obj;
  },

  create(base?: DeepPartial<SubordinateConfig>): SubordinateConfig {
    return SubordinateConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubordinateConfig>): SubordinateConfig {
    const message = createBaseSubordinateConfig();
    message.certificateAuthority = object.certificateAuthority ?? undefined;
    message.pemIssuerChain = (object.pemIssuerChain !== undefined && object.pemIssuerChain !== null)
      ? SubordinateConfig_SubordinateConfigChain.fromPartial(object.pemIssuerChain)
      : undefined;
    return message;
  },
};

function createBaseSubordinateConfig_SubordinateConfigChain(): SubordinateConfig_SubordinateConfigChain {
  return { pemCertificates: [] };
}

export const SubordinateConfig_SubordinateConfigChain: MessageFns<SubordinateConfig_SubordinateConfigChain> = {
  encode(message: SubordinateConfig_SubordinateConfigChain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pemCertificates) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubordinateConfig_SubordinateConfigChain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubordinateConfig_SubordinateConfigChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pemCertificates.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubordinateConfig_SubordinateConfigChain {
    return {
      pemCertificates: globalThis.Array.isArray(object?.pemCertificates)
        ? object.pemCertificates.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SubordinateConfig_SubordinateConfigChain): unknown {
    const obj: any = {};
    if (message.pemCertificates?.length) {
      obj.pemCertificates = message.pemCertificates;
    }
    return obj;
  },

  create(base?: DeepPartial<SubordinateConfig_SubordinateConfigChain>): SubordinateConfig_SubordinateConfigChain {
    return SubordinateConfig_SubordinateConfigChain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubordinateConfig_SubordinateConfigChain>): SubordinateConfig_SubordinateConfigChain {
    const message = createBaseSubordinateConfig_SubordinateConfigChain();
    message.pemCertificates = object.pemCertificates?.map((e) => e) || [];
    return message;
  },
};

function createBasePublicKey(): PublicKey {
  return { type: 0, key: Buffer.alloc(0) };
}

export const PublicKey: MessageFns<PublicKey> = {
  encode(message: PublicKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.key.length !== 0) {
      writer.uint32(18).bytes(message.key);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicKey {
    return {
      type: isSet(object.type) ? publicKey_KeyTypeFromJSON(object.type) : 0,
      key: isSet(object.key) ? Buffer.from(bytesFromBase64(object.key)) : Buffer.alloc(0),
    };
  },

  toJSON(message: PublicKey): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = publicKey_KeyTypeToJSON(message.type);
    }
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    return obj;
  },

  create(base?: DeepPartial<PublicKey>): PublicKey {
    return PublicKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PublicKey>): PublicKey {
    const message = createBasePublicKey();
    message.type = object.type ?? 0;
    message.key = object.key ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseCertificateConfig(): CertificateConfig {
  return { subjectConfig: undefined, reusableConfig: undefined, publicKey: undefined };
}

export const CertificateConfig: MessageFns<CertificateConfig> = {
  encode(message: CertificateConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subjectConfig !== undefined) {
      CertificateConfig_SubjectConfig.encode(message.subjectConfig, writer.uint32(10).fork()).join();
    }
    if (message.reusableConfig !== undefined) {
      ReusableConfigWrapper.encode(message.reusableConfig, writer.uint32(18).fork()).join();
    }
    if (message.publicKey !== undefined) {
      PublicKey.encode(message.publicKey, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subjectConfig = CertificateConfig_SubjectConfig.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reusableConfig = ReusableConfigWrapper.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = PublicKey.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateConfig {
    return {
      subjectConfig: isSet(object.subjectConfig)
        ? CertificateConfig_SubjectConfig.fromJSON(object.subjectConfig)
        : undefined,
      reusableConfig: isSet(object.reusableConfig) ? ReusableConfigWrapper.fromJSON(object.reusableConfig) : undefined,
      publicKey: isSet(object.publicKey) ? PublicKey.fromJSON(object.publicKey) : undefined,
    };
  },

  toJSON(message: CertificateConfig): unknown {
    const obj: any = {};
    if (message.subjectConfig !== undefined) {
      obj.subjectConfig = CertificateConfig_SubjectConfig.toJSON(message.subjectConfig);
    }
    if (message.reusableConfig !== undefined) {
      obj.reusableConfig = ReusableConfigWrapper.toJSON(message.reusableConfig);
    }
    if (message.publicKey !== undefined) {
      obj.publicKey = PublicKey.toJSON(message.publicKey);
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateConfig>): CertificateConfig {
    return CertificateConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateConfig>): CertificateConfig {
    const message = createBaseCertificateConfig();
    message.subjectConfig = (object.subjectConfig !== undefined && object.subjectConfig !== null)
      ? CertificateConfig_SubjectConfig.fromPartial(object.subjectConfig)
      : undefined;
    message.reusableConfig = (object.reusableConfig !== undefined && object.reusableConfig !== null)
      ? ReusableConfigWrapper.fromPartial(object.reusableConfig)
      : undefined;
    message.publicKey = (object.publicKey !== undefined && object.publicKey !== null)
      ? PublicKey.fromPartial(object.publicKey)
      : undefined;
    return message;
  },
};

function createBaseCertificateConfig_SubjectConfig(): CertificateConfig_SubjectConfig {
  return { subject: undefined, commonName: "", subjectAltName: undefined };
}

export const CertificateConfig_SubjectConfig: MessageFns<CertificateConfig_SubjectConfig> = {
  encode(message: CertificateConfig_SubjectConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== undefined) {
      Subject.encode(message.subject, writer.uint32(10).fork()).join();
    }
    if (message.commonName !== "") {
      writer.uint32(18).string(message.commonName);
    }
    if (message.subjectAltName !== undefined) {
      SubjectAltNames.encode(message.subjectAltName, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateConfig_SubjectConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateConfig_SubjectConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subject = Subject.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commonName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subjectAltName = SubjectAltNames.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateConfig_SubjectConfig {
    return {
      subject: isSet(object.subject) ? Subject.fromJSON(object.subject) : undefined,
      commonName: isSet(object.commonName) ? globalThis.String(object.commonName) : "",
      subjectAltName: isSet(object.subjectAltName) ? SubjectAltNames.fromJSON(object.subjectAltName) : undefined,
    };
  },

  toJSON(message: CertificateConfig_SubjectConfig): unknown {
    const obj: any = {};
    if (message.subject !== undefined) {
      obj.subject = Subject.toJSON(message.subject);
    }
    if (message.commonName !== "") {
      obj.commonName = message.commonName;
    }
    if (message.subjectAltName !== undefined) {
      obj.subjectAltName = SubjectAltNames.toJSON(message.subjectAltName);
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateConfig_SubjectConfig>): CertificateConfig_SubjectConfig {
    return CertificateConfig_SubjectConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateConfig_SubjectConfig>): CertificateConfig_SubjectConfig {
    const message = createBaseCertificateConfig_SubjectConfig();
    message.subject = (object.subject !== undefined && object.subject !== null)
      ? Subject.fromPartial(object.subject)
      : undefined;
    message.commonName = object.commonName ?? "";
    message.subjectAltName = (object.subjectAltName !== undefined && object.subjectAltName !== null)
      ? SubjectAltNames.fromPartial(object.subjectAltName)
      : undefined;
    return message;
  },
};

function createBaseCertificateDescription(): CertificateDescription {
  return {
    subjectDescription: undefined,
    configValues: undefined,
    publicKey: undefined,
    subjectKeyId: undefined,
    authorityKeyId: undefined,
    crlDistributionPoints: [],
    aiaIssuingCertificateUrls: [],
    certFingerprint: undefined,
  };
}

export const CertificateDescription: MessageFns<CertificateDescription> = {
  encode(message: CertificateDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subjectDescription !== undefined) {
      CertificateDescription_SubjectDescription.encode(message.subjectDescription, writer.uint32(10).fork()).join();
    }
    if (message.configValues !== undefined) {
      ReusableConfigValues.encode(message.configValues, writer.uint32(18).fork()).join();
    }
    if (message.publicKey !== undefined) {
      PublicKey.encode(message.publicKey, writer.uint32(26).fork()).join();
    }
    if (message.subjectKeyId !== undefined) {
      CertificateDescription_KeyId.encode(message.subjectKeyId, writer.uint32(34).fork()).join();
    }
    if (message.authorityKeyId !== undefined) {
      CertificateDescription_KeyId.encode(message.authorityKeyId, writer.uint32(42).fork()).join();
    }
    for (const v of message.crlDistributionPoints) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.aiaIssuingCertificateUrls) {
      writer.uint32(58).string(v!);
    }
    if (message.certFingerprint !== undefined) {
      CertificateDescription_CertificateFingerprint.encode(message.certFingerprint, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subjectDescription = CertificateDescription_SubjectDescription.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.configValues = ReusableConfigValues.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.publicKey = PublicKey.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.subjectKeyId = CertificateDescription_KeyId.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorityKeyId = CertificateDescription_KeyId.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.crlDistributionPoints.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.aiaIssuingCertificateUrls.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.certFingerprint = CertificateDescription_CertificateFingerprint.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateDescription {
    return {
      subjectDescription: isSet(object.subjectDescription)
        ? CertificateDescription_SubjectDescription.fromJSON(object.subjectDescription)
        : undefined,
      configValues: isSet(object.configValues) ? ReusableConfigValues.fromJSON(object.configValues) : undefined,
      publicKey: isSet(object.publicKey) ? PublicKey.fromJSON(object.publicKey) : undefined,
      subjectKeyId: isSet(object.subjectKeyId) ? CertificateDescription_KeyId.fromJSON(object.subjectKeyId) : undefined,
      authorityKeyId: isSet(object.authorityKeyId)
        ? CertificateDescription_KeyId.fromJSON(object.authorityKeyId)
        : undefined,
      crlDistributionPoints: globalThis.Array.isArray(object?.crlDistributionPoints)
        ? object.crlDistributionPoints.map((e: any) => globalThis.String(e))
        : [],
      aiaIssuingCertificateUrls: globalThis.Array.isArray(object?.aiaIssuingCertificateUrls)
        ? object.aiaIssuingCertificateUrls.map((e: any) => globalThis.String(e))
        : [],
      certFingerprint: isSet(object.certFingerprint)
        ? CertificateDescription_CertificateFingerprint.fromJSON(object.certFingerprint)
        : undefined,
    };
  },

  toJSON(message: CertificateDescription): unknown {
    const obj: any = {};
    if (message.subjectDescription !== undefined) {
      obj.subjectDescription = CertificateDescription_SubjectDescription.toJSON(message.subjectDescription);
    }
    if (message.configValues !== undefined) {
      obj.configValues = ReusableConfigValues.toJSON(message.configValues);
    }
    if (message.publicKey !== undefined) {
      obj.publicKey = PublicKey.toJSON(message.publicKey);
    }
    if (message.subjectKeyId !== undefined) {
      obj.subjectKeyId = CertificateDescription_KeyId.toJSON(message.subjectKeyId);
    }
    if (message.authorityKeyId !== undefined) {
      obj.authorityKeyId = CertificateDescription_KeyId.toJSON(message.authorityKeyId);
    }
    if (message.crlDistributionPoints?.length) {
      obj.crlDistributionPoints = message.crlDistributionPoints;
    }
    if (message.aiaIssuingCertificateUrls?.length) {
      obj.aiaIssuingCertificateUrls = message.aiaIssuingCertificateUrls;
    }
    if (message.certFingerprint !== undefined) {
      obj.certFingerprint = CertificateDescription_CertificateFingerprint.toJSON(message.certFingerprint);
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateDescription>): CertificateDescription {
    return CertificateDescription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateDescription>): CertificateDescription {
    const message = createBaseCertificateDescription();
    message.subjectDescription = (object.subjectDescription !== undefined && object.subjectDescription !== null)
      ? CertificateDescription_SubjectDescription.fromPartial(object.subjectDescription)
      : undefined;
    message.configValues = (object.configValues !== undefined && object.configValues !== null)
      ? ReusableConfigValues.fromPartial(object.configValues)
      : undefined;
    message.publicKey = (object.publicKey !== undefined && object.publicKey !== null)
      ? PublicKey.fromPartial(object.publicKey)
      : undefined;
    message.subjectKeyId = (object.subjectKeyId !== undefined && object.subjectKeyId !== null)
      ? CertificateDescription_KeyId.fromPartial(object.subjectKeyId)
      : undefined;
    message.authorityKeyId = (object.authorityKeyId !== undefined && object.authorityKeyId !== null)
      ? CertificateDescription_KeyId.fromPartial(object.authorityKeyId)
      : undefined;
    message.crlDistributionPoints = object.crlDistributionPoints?.map((e) => e) || [];
    message.aiaIssuingCertificateUrls = object.aiaIssuingCertificateUrls?.map((e) => e) || [];
    message.certFingerprint = (object.certFingerprint !== undefined && object.certFingerprint !== null)
      ? CertificateDescription_CertificateFingerprint.fromPartial(object.certFingerprint)
      : undefined;
    return message;
  },
};

function createBaseCertificateDescription_SubjectDescription(): CertificateDescription_SubjectDescription {
  return {
    subject: undefined,
    commonName: "",
    subjectAltName: undefined,
    hexSerialNumber: "",
    lifetime: undefined,
    notBeforeTime: undefined,
    notAfterTime: undefined,
  };
}

export const CertificateDescription_SubjectDescription: MessageFns<CertificateDescription_SubjectDescription> = {
  encode(message: CertificateDescription_SubjectDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== undefined) {
      Subject.encode(message.subject, writer.uint32(10).fork()).join();
    }
    if (message.commonName !== "") {
      writer.uint32(18).string(message.commonName);
    }
    if (message.subjectAltName !== undefined) {
      SubjectAltNames.encode(message.subjectAltName, writer.uint32(26).fork()).join();
    }
    if (message.hexSerialNumber !== "") {
      writer.uint32(34).string(message.hexSerialNumber);
    }
    if (message.lifetime !== undefined) {
      Duration.encode(message.lifetime, writer.uint32(42).fork()).join();
    }
    if (message.notBeforeTime !== undefined) {
      Timestamp.encode(toTimestamp(message.notBeforeTime), writer.uint32(50).fork()).join();
    }
    if (message.notAfterTime !== undefined) {
      Timestamp.encode(toTimestamp(message.notAfterTime), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateDescription_SubjectDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateDescription_SubjectDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subject = Subject.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.commonName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.subjectAltName = SubjectAltNames.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.hexSerialNumber = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lifetime = Duration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.notBeforeTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.notAfterTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateDescription_SubjectDescription {
    return {
      subject: isSet(object.subject) ? Subject.fromJSON(object.subject) : undefined,
      commonName: isSet(object.commonName) ? globalThis.String(object.commonName) : "",
      subjectAltName: isSet(object.subjectAltName) ? SubjectAltNames.fromJSON(object.subjectAltName) : undefined,
      hexSerialNumber: isSet(object.hexSerialNumber) ? globalThis.String(object.hexSerialNumber) : "",
      lifetime: isSet(object.lifetime) ? Duration.fromJSON(object.lifetime) : undefined,
      notBeforeTime: isSet(object.notBeforeTime) ? fromJsonTimestamp(object.notBeforeTime) : undefined,
      notAfterTime: isSet(object.notAfterTime) ? fromJsonTimestamp(object.notAfterTime) : undefined,
    };
  },

  toJSON(message: CertificateDescription_SubjectDescription): unknown {
    const obj: any = {};
    if (message.subject !== undefined) {
      obj.subject = Subject.toJSON(message.subject);
    }
    if (message.commonName !== "") {
      obj.commonName = message.commonName;
    }
    if (message.subjectAltName !== undefined) {
      obj.subjectAltName = SubjectAltNames.toJSON(message.subjectAltName);
    }
    if (message.hexSerialNumber !== "") {
      obj.hexSerialNumber = message.hexSerialNumber;
    }
    if (message.lifetime !== undefined) {
      obj.lifetime = Duration.toJSON(message.lifetime);
    }
    if (message.notBeforeTime !== undefined) {
      obj.notBeforeTime = message.notBeforeTime.toISOString();
    }
    if (message.notAfterTime !== undefined) {
      obj.notAfterTime = message.notAfterTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateDescription_SubjectDescription>): CertificateDescription_SubjectDescription {
    return CertificateDescription_SubjectDescription.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CertificateDescription_SubjectDescription>,
  ): CertificateDescription_SubjectDescription {
    const message = createBaseCertificateDescription_SubjectDescription();
    message.subject = (object.subject !== undefined && object.subject !== null)
      ? Subject.fromPartial(object.subject)
      : undefined;
    message.commonName = object.commonName ?? "";
    message.subjectAltName = (object.subjectAltName !== undefined && object.subjectAltName !== null)
      ? SubjectAltNames.fromPartial(object.subjectAltName)
      : undefined;
    message.hexSerialNumber = object.hexSerialNumber ?? "";
    message.lifetime = (object.lifetime !== undefined && object.lifetime !== null)
      ? Duration.fromPartial(object.lifetime)
      : undefined;
    message.notBeforeTime = object.notBeforeTime ?? undefined;
    message.notAfterTime = object.notAfterTime ?? undefined;
    return message;
  },
};

function createBaseCertificateDescription_KeyId(): CertificateDescription_KeyId {
  return { keyId: "" };
}

export const CertificateDescription_KeyId: MessageFns<CertificateDescription_KeyId> = {
  encode(message: CertificateDescription_KeyId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyId !== "") {
      writer.uint32(10).string(message.keyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertificateDescription_KeyId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertificateDescription_KeyId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.keyId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertificateDescription_KeyId {
    return { keyId: isSet(object.keyId) ? globalThis.String(object.keyId) : "" };
  },

  toJSON(message: CertificateDescription_KeyId): unknown {
    const obj: any = {};
    if (message.keyId !== "") {
      obj.keyId = message.keyId;
    }
    return obj;
  },

  create(base?: DeepPartial<CertificateDescription_KeyId>): CertificateDescription_KeyId {
    return CertificateDescription_KeyId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CertificateDescription_KeyId>): CertificateDescription_KeyId {
    const message = createBaseCertificateDescription_KeyId();
    message.keyId = object.keyId ?? "";
    return message;
  },
};

function createBaseCertificateDescription_CertificateFingerprint(): CertificateDescription_CertificateFingerprint {
  return { sha256Hash: "" };
}

export const CertificateDescription_CertificateFingerprint: MessageFns<CertificateDescription_CertificateFingerprint> =
  {
    encode(
      message: CertificateDescription_CertificateFingerprint,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.sha256Hash !== "") {
        writer.uint32(10).string(message.sha256Hash);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CertificateDescription_CertificateFingerprint {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCertificateDescription_CertificateFingerprint();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.sha256Hash = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CertificateDescription_CertificateFingerprint {
      return { sha256Hash: isSet(object.sha256Hash) ? globalThis.String(object.sha256Hash) : "" };
    },

    toJSON(message: CertificateDescription_CertificateFingerprint): unknown {
      const obj: any = {};
      if (message.sha256Hash !== "") {
        obj.sha256Hash = message.sha256Hash;
      }
      return obj;
    },

    create(
      base?: DeepPartial<CertificateDescription_CertificateFingerprint>,
    ): CertificateDescription_CertificateFingerprint {
      return CertificateDescription_CertificateFingerprint.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CertificateDescription_CertificateFingerprint>,
    ): CertificateDescription_CertificateFingerprint {
      const message = createBaseCertificateDescription_CertificateFingerprint();
      message.sha256Hash = object.sha256Hash ?? "";
      return message;
    },
  };

function createBaseObjectId(): ObjectId {
  return { objectIdPath: [] };
}

export const ObjectId: MessageFns<ObjectId> = {
  encode(message: ObjectId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.objectIdPath) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.objectIdPath.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.objectIdPath.push(reader.int32());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectId {
    return {
      objectIdPath: globalThis.Array.isArray(object?.objectIdPath)
        ? object.objectIdPath.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: ObjectId): unknown {
    const obj: any = {};
    if (message.objectIdPath?.length) {
      obj.objectIdPath = message.objectIdPath.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectId>): ObjectId {
    return ObjectId.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectId>): ObjectId {
    const message = createBaseObjectId();
    message.objectIdPath = object.objectIdPath?.map((e) => e) || [];
    return message;
  },
};

function createBaseX509Extension(): X509Extension {
  return { objectId: undefined, critical: false, value: Buffer.alloc(0) };
}

export const X509Extension: MessageFns<X509Extension> = {
  encode(message: X509Extension, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.objectId !== undefined) {
      ObjectId.encode(message.objectId, writer.uint32(10).fork()).join();
    }
    if (message.critical !== false) {
      writer.uint32(16).bool(message.critical);
    }
    if (message.value.length !== 0) {
      writer.uint32(26).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): X509Extension {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseX509Extension();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.objectId = ObjectId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.critical = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.value = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): X509Extension {
    return {
      objectId: isSet(object.objectId) ? ObjectId.fromJSON(object.objectId) : undefined,
      critical: isSet(object.critical) ? globalThis.Boolean(object.critical) : false,
      value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0),
    };
  },

  toJSON(message: X509Extension): unknown {
    const obj: any = {};
    if (message.objectId !== undefined) {
      obj.objectId = ObjectId.toJSON(message.objectId);
    }
    if (message.critical !== false) {
      obj.critical = message.critical;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<X509Extension>): X509Extension {
    return X509Extension.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<X509Extension>): X509Extension {
    const message = createBaseX509Extension();
    message.objectId = (object.objectId !== undefined && object.objectId !== null)
      ? ObjectId.fromPartial(object.objectId)
      : undefined;
    message.critical = object.critical ?? false;
    message.value = object.value ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseKeyUsage(): KeyUsage {
  return { baseKeyUsage: undefined, extendedKeyUsage: undefined, unknownExtendedKeyUsages: [] };
}

export const KeyUsage: MessageFns<KeyUsage> = {
  encode(message: KeyUsage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseKeyUsage !== undefined) {
      KeyUsage_KeyUsageOptions.encode(message.baseKeyUsage, writer.uint32(10).fork()).join();
    }
    if (message.extendedKeyUsage !== undefined) {
      KeyUsage_ExtendedKeyUsageOptions.encode(message.extendedKeyUsage, writer.uint32(18).fork()).join();
    }
    for (const v of message.unknownExtendedKeyUsages) {
      ObjectId.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyUsage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyUsage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseKeyUsage = KeyUsage_KeyUsageOptions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.extendedKeyUsage = KeyUsage_ExtendedKeyUsageOptions.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unknownExtendedKeyUsages.push(ObjectId.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyUsage {
    return {
      baseKeyUsage: isSet(object.baseKeyUsage) ? KeyUsage_KeyUsageOptions.fromJSON(object.baseKeyUsage) : undefined,
      extendedKeyUsage: isSet(object.extendedKeyUsage)
        ? KeyUsage_ExtendedKeyUsageOptions.fromJSON(object.extendedKeyUsage)
        : undefined,
      unknownExtendedKeyUsages: globalThis.Array.isArray(object?.unknownExtendedKeyUsages)
        ? object.unknownExtendedKeyUsages.map((e: any) => ObjectId.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KeyUsage): unknown {
    const obj: any = {};
    if (message.baseKeyUsage !== undefined) {
      obj.baseKeyUsage = KeyUsage_KeyUsageOptions.toJSON(message.baseKeyUsage);
    }
    if (message.extendedKeyUsage !== undefined) {
      obj.extendedKeyUsage = KeyUsage_ExtendedKeyUsageOptions.toJSON(message.extendedKeyUsage);
    }
    if (message.unknownExtendedKeyUsages?.length) {
      obj.unknownExtendedKeyUsages = message.unknownExtendedKeyUsages.map((e) => ObjectId.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<KeyUsage>): KeyUsage {
    return KeyUsage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyUsage>): KeyUsage {
    const message = createBaseKeyUsage();
    message.baseKeyUsage = (object.baseKeyUsage !== undefined && object.baseKeyUsage !== null)
      ? KeyUsage_KeyUsageOptions.fromPartial(object.baseKeyUsage)
      : undefined;
    message.extendedKeyUsage = (object.extendedKeyUsage !== undefined && object.extendedKeyUsage !== null)
      ? KeyUsage_ExtendedKeyUsageOptions.fromPartial(object.extendedKeyUsage)
      : undefined;
    message.unknownExtendedKeyUsages = object.unknownExtendedKeyUsages?.map((e) => ObjectId.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKeyUsage_KeyUsageOptions(): KeyUsage_KeyUsageOptions {
  return {
    digitalSignature: false,
    contentCommitment: false,
    keyEncipherment: false,
    dataEncipherment: false,
    keyAgreement: false,
    certSign: false,
    crlSign: false,
    encipherOnly: false,
    decipherOnly: false,
  };
}

export const KeyUsage_KeyUsageOptions: MessageFns<KeyUsage_KeyUsageOptions> = {
  encode(message: KeyUsage_KeyUsageOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.digitalSignature !== false) {
      writer.uint32(8).bool(message.digitalSignature);
    }
    if (message.contentCommitment !== false) {
      writer.uint32(16).bool(message.contentCommitment);
    }
    if (message.keyEncipherment !== false) {
      writer.uint32(24).bool(message.keyEncipherment);
    }
    if (message.dataEncipherment !== false) {
      writer.uint32(32).bool(message.dataEncipherment);
    }
    if (message.keyAgreement !== false) {
      writer.uint32(40).bool(message.keyAgreement);
    }
    if (message.certSign !== false) {
      writer.uint32(48).bool(message.certSign);
    }
    if (message.crlSign !== false) {
      writer.uint32(56).bool(message.crlSign);
    }
    if (message.encipherOnly !== false) {
      writer.uint32(64).bool(message.encipherOnly);
    }
    if (message.decipherOnly !== false) {
      writer.uint32(72).bool(message.decipherOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyUsage_KeyUsageOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyUsage_KeyUsageOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.digitalSignature = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.contentCommitment = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.keyEncipherment = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.dataEncipherment = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.keyAgreement = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.certSign = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.crlSign = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.encipherOnly = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.decipherOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyUsage_KeyUsageOptions {
    return {
      digitalSignature: isSet(object.digitalSignature) ? globalThis.Boolean(object.digitalSignature) : false,
      contentCommitment: isSet(object.contentCommitment) ? globalThis.Boolean(object.contentCommitment) : false,
      keyEncipherment: isSet(object.keyEncipherment) ? globalThis.Boolean(object.keyEncipherment) : false,
      dataEncipherment: isSet(object.dataEncipherment) ? globalThis.Boolean(object.dataEncipherment) : false,
      keyAgreement: isSet(object.keyAgreement) ? globalThis.Boolean(object.keyAgreement) : false,
      certSign: isSet(object.certSign) ? globalThis.Boolean(object.certSign) : false,
      crlSign: isSet(object.crlSign) ? globalThis.Boolean(object.crlSign) : false,
      encipherOnly: isSet(object.encipherOnly) ? globalThis.Boolean(object.encipherOnly) : false,
      decipherOnly: isSet(object.decipherOnly) ? globalThis.Boolean(object.decipherOnly) : false,
    };
  },

  toJSON(message: KeyUsage_KeyUsageOptions): unknown {
    const obj: any = {};
    if (message.digitalSignature !== false) {
      obj.digitalSignature = message.digitalSignature;
    }
    if (message.contentCommitment !== false) {
      obj.contentCommitment = message.contentCommitment;
    }
    if (message.keyEncipherment !== false) {
      obj.keyEncipherment = message.keyEncipherment;
    }
    if (message.dataEncipherment !== false) {
      obj.dataEncipherment = message.dataEncipherment;
    }
    if (message.keyAgreement !== false) {
      obj.keyAgreement = message.keyAgreement;
    }
    if (message.certSign !== false) {
      obj.certSign = message.certSign;
    }
    if (message.crlSign !== false) {
      obj.crlSign = message.crlSign;
    }
    if (message.encipherOnly !== false) {
      obj.encipherOnly = message.encipherOnly;
    }
    if (message.decipherOnly !== false) {
      obj.decipherOnly = message.decipherOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<KeyUsage_KeyUsageOptions>): KeyUsage_KeyUsageOptions {
    return KeyUsage_KeyUsageOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyUsage_KeyUsageOptions>): KeyUsage_KeyUsageOptions {
    const message = createBaseKeyUsage_KeyUsageOptions();
    message.digitalSignature = object.digitalSignature ?? false;
    message.contentCommitment = object.contentCommitment ?? false;
    message.keyEncipherment = object.keyEncipherment ?? false;
    message.dataEncipherment = object.dataEncipherment ?? false;
    message.keyAgreement = object.keyAgreement ?? false;
    message.certSign = object.certSign ?? false;
    message.crlSign = object.crlSign ?? false;
    message.encipherOnly = object.encipherOnly ?? false;
    message.decipherOnly = object.decipherOnly ?? false;
    return message;
  },
};

function createBaseKeyUsage_ExtendedKeyUsageOptions(): KeyUsage_ExtendedKeyUsageOptions {
  return {
    serverAuth: false,
    clientAuth: false,
    codeSigning: false,
    emailProtection: false,
    timeStamping: false,
    ocspSigning: false,
  };
}

export const KeyUsage_ExtendedKeyUsageOptions: MessageFns<KeyUsage_ExtendedKeyUsageOptions> = {
  encode(message: KeyUsage_ExtendedKeyUsageOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverAuth !== false) {
      writer.uint32(8).bool(message.serverAuth);
    }
    if (message.clientAuth !== false) {
      writer.uint32(16).bool(message.clientAuth);
    }
    if (message.codeSigning !== false) {
      writer.uint32(24).bool(message.codeSigning);
    }
    if (message.emailProtection !== false) {
      writer.uint32(32).bool(message.emailProtection);
    }
    if (message.timeStamping !== false) {
      writer.uint32(40).bool(message.timeStamping);
    }
    if (message.ocspSigning !== false) {
      writer.uint32(48).bool(message.ocspSigning);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyUsage_ExtendedKeyUsageOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyUsage_ExtendedKeyUsageOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.serverAuth = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.clientAuth = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.codeSigning = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.emailProtection = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.timeStamping = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.ocspSigning = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyUsage_ExtendedKeyUsageOptions {
    return {
      serverAuth: isSet(object.serverAuth) ? globalThis.Boolean(object.serverAuth) : false,
      clientAuth: isSet(object.clientAuth) ? globalThis.Boolean(object.clientAuth) : false,
      codeSigning: isSet(object.codeSigning) ? globalThis.Boolean(object.codeSigning) : false,
      emailProtection: isSet(object.emailProtection) ? globalThis.Boolean(object.emailProtection) : false,
      timeStamping: isSet(object.timeStamping) ? globalThis.Boolean(object.timeStamping) : false,
      ocspSigning: isSet(object.ocspSigning) ? globalThis.Boolean(object.ocspSigning) : false,
    };
  },

  toJSON(message: KeyUsage_ExtendedKeyUsageOptions): unknown {
    const obj: any = {};
    if (message.serverAuth !== false) {
      obj.serverAuth = message.serverAuth;
    }
    if (message.clientAuth !== false) {
      obj.clientAuth = message.clientAuth;
    }
    if (message.codeSigning !== false) {
      obj.codeSigning = message.codeSigning;
    }
    if (message.emailProtection !== false) {
      obj.emailProtection = message.emailProtection;
    }
    if (message.timeStamping !== false) {
      obj.timeStamping = message.timeStamping;
    }
    if (message.ocspSigning !== false) {
      obj.ocspSigning = message.ocspSigning;
    }
    return obj;
  },

  create(base?: DeepPartial<KeyUsage_ExtendedKeyUsageOptions>): KeyUsage_ExtendedKeyUsageOptions {
    return KeyUsage_ExtendedKeyUsageOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<KeyUsage_ExtendedKeyUsageOptions>): KeyUsage_ExtendedKeyUsageOptions {
    const message = createBaseKeyUsage_ExtendedKeyUsageOptions();
    message.serverAuth = object.serverAuth ?? false;
    message.clientAuth = object.clientAuth ?? false;
    message.codeSigning = object.codeSigning ?? false;
    message.emailProtection = object.emailProtection ?? false;
    message.timeStamping = object.timeStamping ?? false;
    message.ocspSigning = object.ocspSigning ?? false;
    return message;
  },
};

function createBaseSubject(): Subject {
  return {
    countryCode: "",
    organization: "",
    organizationalUnit: "",
    locality: "",
    province: "",
    streetAddress: "",
    postalCode: "",
  };
}

export const Subject: MessageFns<Subject> = {
  encode(message: Subject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.countryCode !== "") {
      writer.uint32(10).string(message.countryCode);
    }
    if (message.organization !== "") {
      writer.uint32(18).string(message.organization);
    }
    if (message.organizationalUnit !== "") {
      writer.uint32(26).string(message.organizationalUnit);
    }
    if (message.locality !== "") {
      writer.uint32(34).string(message.locality);
    }
    if (message.province !== "") {
      writer.uint32(42).string(message.province);
    }
    if (message.streetAddress !== "") {
      writer.uint32(50).string(message.streetAddress);
    }
    if (message.postalCode !== "") {
      writer.uint32(58).string(message.postalCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.countryCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.organization = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.organizationalUnit = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.locality = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.province = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.streetAddress = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.postalCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subject {
    return {
      countryCode: isSet(object.countryCode) ? globalThis.String(object.countryCode) : "",
      organization: isSet(object.organization) ? globalThis.String(object.organization) : "",
      organizationalUnit: isSet(object.organizationalUnit) ? globalThis.String(object.organizationalUnit) : "",
      locality: isSet(object.locality) ? globalThis.String(object.locality) : "",
      province: isSet(object.province) ? globalThis.String(object.province) : "",
      streetAddress: isSet(object.streetAddress) ? globalThis.String(object.streetAddress) : "",
      postalCode: isSet(object.postalCode) ? globalThis.String(object.postalCode) : "",
    };
  },

  toJSON(message: Subject): unknown {
    const obj: any = {};
    if (message.countryCode !== "") {
      obj.countryCode = message.countryCode;
    }
    if (message.organization !== "") {
      obj.organization = message.organization;
    }
    if (message.organizationalUnit !== "") {
      obj.organizationalUnit = message.organizationalUnit;
    }
    if (message.locality !== "") {
      obj.locality = message.locality;
    }
    if (message.province !== "") {
      obj.province = message.province;
    }
    if (message.streetAddress !== "") {
      obj.streetAddress = message.streetAddress;
    }
    if (message.postalCode !== "") {
      obj.postalCode = message.postalCode;
    }
    return obj;
  },

  create(base?: DeepPartial<Subject>): Subject {
    return Subject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subject>): Subject {
    const message = createBaseSubject();
    message.countryCode = object.countryCode ?? "";
    message.organization = object.organization ?? "";
    message.organizationalUnit = object.organizationalUnit ?? "";
    message.locality = object.locality ?? "";
    message.province = object.province ?? "";
    message.streetAddress = object.streetAddress ?? "";
    message.postalCode = object.postalCode ?? "";
    return message;
  },
};

function createBaseSubjectAltNames(): SubjectAltNames {
  return { dnsNames: [], uris: [], emailAddresses: [], ipAddresses: [], customSans: [] };
}

export const SubjectAltNames: MessageFns<SubjectAltNames> = {
  encode(message: SubjectAltNames, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dnsNames) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.uris) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.emailAddresses) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.ipAddresses) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.customSans) {
      X509Extension.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubjectAltNames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubjectAltNames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dnsNames.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uris.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.emailAddresses.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ipAddresses.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.customSans.push(X509Extension.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubjectAltNames {
    return {
      dnsNames: globalThis.Array.isArray(object?.dnsNames) ? object.dnsNames.map((e: any) => globalThis.String(e)) : [],
      uris: globalThis.Array.isArray(object?.uris) ? object.uris.map((e: any) => globalThis.String(e)) : [],
      emailAddresses: globalThis.Array.isArray(object?.emailAddresses)
        ? object.emailAddresses.map((e: any) => globalThis.String(e))
        : [],
      ipAddresses: globalThis.Array.isArray(object?.ipAddresses)
        ? object.ipAddresses.map((e: any) => globalThis.String(e))
        : [],
      customSans: globalThis.Array.isArray(object?.customSans)
        ? object.customSans.map((e: any) => X509Extension.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubjectAltNames): unknown {
    const obj: any = {};
    if (message.dnsNames?.length) {
      obj.dnsNames = message.dnsNames;
    }
    if (message.uris?.length) {
      obj.uris = message.uris;
    }
    if (message.emailAddresses?.length) {
      obj.emailAddresses = message.emailAddresses;
    }
    if (message.ipAddresses?.length) {
      obj.ipAddresses = message.ipAddresses;
    }
    if (message.customSans?.length) {
      obj.customSans = message.customSans.map((e) => X509Extension.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SubjectAltNames>): SubjectAltNames {
    return SubjectAltNames.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubjectAltNames>): SubjectAltNames {
    const message = createBaseSubjectAltNames();
    message.dnsNames = object.dnsNames?.map((e) => e) || [];
    message.uris = object.uris?.map((e) => e) || [];
    message.emailAddresses = object.emailAddresses?.map((e) => e) || [];
    message.ipAddresses = object.ipAddresses?.map((e) => e) || [];
    message.customSans = object.customSans?.map((e) => X509Extension.fromPartial(e)) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
