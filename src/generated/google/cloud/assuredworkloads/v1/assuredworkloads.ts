// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/assuredworkloads/v1/assuredworkloads.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { Duration } from "../../../protobuf/duration.js";
import { Empty } from "../../../protobuf/empty.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.assuredworkloads.v1";

/** Request for creating a workload. */
export interface CreateWorkloadRequest {
  /**
   * Required. The resource name of the new Workload's parent.
   * Must be of the form `organizations/{org_id}/locations/{location_id}`.
   */
  parent: string;
  /** Required. Assured Workload to create */
  workload:
    | Workload
    | undefined;
  /**
   * Optional. A identifier associated with the workload and underlying projects which
   * allows for the break down of billing costs for a workload. The value
   * provided for the identifier will add a label to the workload and contained
   * projects with the identifier as the value.
   */
  externalId: string;
}

/** Request for Updating a workload. */
export interface UpdateWorkloadRequest {
  /**
   * Required. The workload to update.
   * The workload's `name` field is used to identify the workload to be updated.
   * Format:
   * organizations/{org_id}/locations/{location_id}/workloads/{workload_id}
   */
  workload:
    | Workload
    | undefined;
  /** Required. The list of fields to be updated. */
  updateMask: string[] | undefined;
}

/** Request for deleting a Workload. */
export interface DeleteWorkloadRequest {
  /**
   * Required. The `name` field is used to identify the workload.
   * Format:
   * organizations/{org_id}/locations/{location_id}/workloads/{workload_id}
   */
  name: string;
  /**
   * Optional. The etag of the workload.
   * If this is provided, it must match the server's etag.
   */
  etag: string;
}

/** Request for fetching a workload. */
export interface GetWorkloadRequest {
  /**
   * Required. The resource name of the Workload to fetch. This is the workload's
   * relative path in the API, formatted as
   * "organizations/{organization_id}/locations/{location_id}/workloads/{workload_id}".
   * For example,
   * "organizations/123/locations/us-east1/workloads/assured-workload-1".
   */
  name: string;
}

/** Request for fetching workloads in an organization. */
export interface ListWorkloadsRequest {
  /**
   * Required. Parent Resource to list workloads from.
   * Must be of the form `organizations/{org_id}/locations/{location}`.
   */
  parent: string;
  /** Page size. */
  pageSize: number;
  /**
   * Page token returned from previous request. Page token contains context from
   * previous request. Page token needs to be passed in the second and following
   * requests.
   */
  pageToken: string;
  /**
   * A custom filter for filtering by properties of a workload. At this time,
   * only filtering by labels is supported.
   */
  filter: string;
}

/** Response of ListWorkloads endpoint. */
export interface ListWorkloadsResponse {
  /** List of Workloads under a given parent. */
  workloads: Workload[];
  /** The next page token. Return empty if reached the last page. */
  nextPageToken: string;
}

/**
 * A Workload object for managing highly regulated workloads of cloud
 * customers.
 */
export interface Workload {
  /**
   * Optional. The resource name of the workload.
   * Format:
   * organizations/{organization}/locations/{location}/workloads/{workload}
   *
   * Read-only.
   */
  name: string;
  /**
   * Required. The user-assigned display name of the Workload.
   * When present it must be between 4 to 30 characters.
   * Allowed characters are: lowercase and uppercase letters, numbers,
   * hyphen, and spaces.
   *
   * Example: My Workload
   */
  displayName: string;
  /**
   * Output only. The resources associated with this workload.
   * These resources will be created when creating the workload.
   * If any of the projects already exist, the workload creation will fail.
   * Always read only.
   */
  resources: Workload_ResourceInfo[];
  /** Required. Immutable. Compliance Regime associated with this workload. */
  complianceRegime: Workload_ComplianceRegime;
  /** Output only. Immutable. The Workload creation timestamp. */
  createTime:
    | Date
    | undefined;
  /**
   * Optional. The billing account used for the resources which are
   * direct children of workload. This billing account is initially associated
   * with the resources created as part of Workload creation.
   * After the initial creation of these resources, the customer can change
   * the assigned billing account.
   * The resource name has the form
   * `billingAccounts/{billing_account_id}`. For example,
   * `billingAccounts/012345-567890-ABCDEF`.
   */
  billingAccount: string;
  /**
   * Optional. ETag of the workload, it is calculated on the basis
   * of the Workload contents. It will be used in Update & Delete operations.
   */
  etag: string;
  /** Optional. Labels applied to the workload. */
  labels: { [key: string]: string };
  /**
   * Input only. The parent resource for the resources managed by this Assured Workload. May
   * be either empty or a folder resource which is a child of the
   * Workload parent. If not specified all resources are created under the
   * parent organization.
   * Format:
   * folders/{folder_id}
   */
  provisionedResourcesParent: string;
  /**
   * Input only. Settings used to create a CMEK crypto key. When set, a project with a KMS
   * CMEK key is provisioned.
   * This field is deprecated as of Feb 28, 2022.
   * In order to create a Keyring, callers should specify,
   * ENCRYPTION_KEYS_PROJECT or KEYRING in ResourceSettings.resource_type field.
   *
   * @deprecated
   */
  kmsSettings:
    | Workload_KMSSettings
    | undefined;
  /**
   * Input only. Resource properties that are used to customize workload resources.
   * These properties (such as custom project id) will be used to create
   * workload resources if possible. This field is optional.
   */
  resourceSettings: Workload_ResourceSettings[];
  /** Output only. Represents the KAJ enrollment state of the given workload. */
  kajEnrollmentState: Workload_KajEnrollmentState;
  /**
   * Optional. Indicates the sovereignty status of the given workload.
   * Currently meant to be used by Europe/Canada customers.
   */
  enableSovereignControls: boolean;
  /**
   * Output only. Represents the SAA enrollment response of the given workload.
   * SAA enrollment response is queried during GetWorkload call.
   * In failure cases, user friendly error message is shown in SAA details page.
   */
  saaEnrollmentResponse:
    | Workload_SaaEnrollmentResponse
    | undefined;
  /**
   * Output only. Urls for services which are compliant for this Assured Workload, but which
   * are currently disallowed by the ResourceUsageRestriction org policy.
   * Invoke RestrictAllowedResources endpoint to allow your project developers
   * to use these services in their environment."
   */
  compliantButDisallowedServices: string[];
  /** Optional. Compliance Regime associated with this workload. */
  partner: Workload_Partner;
}

/** Supported Compliance Regimes. */
export enum Workload_ComplianceRegime {
  /** COMPLIANCE_REGIME_UNSPECIFIED - Unknown compliance regime. */
  COMPLIANCE_REGIME_UNSPECIFIED = 0,
  /** IL4 - Information protection as per DoD IL4 requirements. */
  IL4 = 1,
  /** CJIS - Criminal Justice Information Services (CJIS) Security policies. */
  CJIS = 2,
  /** FEDRAMP_HIGH - FedRAMP High data protection controls */
  FEDRAMP_HIGH = 3,
  /** FEDRAMP_MODERATE - FedRAMP Moderate data protection controls */
  FEDRAMP_MODERATE = 4,
  /** US_REGIONAL_ACCESS - Assured Workloads For US Regions data protection controls */
  US_REGIONAL_ACCESS = 5,
  /** HIPAA - Health Insurance Portability and Accountability Act controls */
  HIPAA = 6,
  /** HITRUST - Health Information Trust Alliance controls */
  HITRUST = 7,
  /** EU_REGIONS_AND_SUPPORT - Assured Workloads For EU Regions and Support controls */
  EU_REGIONS_AND_SUPPORT = 8,
  /** CA_REGIONS_AND_SUPPORT - Assured Workloads For Canada Regions and Support controls */
  CA_REGIONS_AND_SUPPORT = 9,
  /** ITAR - International Traffic in Arms Regulations */
  ITAR = 10,
  /**
   * AU_REGIONS_AND_US_SUPPORT - Assured Workloads for Australia Regions and Support controls
   * Available for public preview consumption.
   * Don't create production workloads.
   */
  AU_REGIONS_AND_US_SUPPORT = 11,
  /** ASSURED_WORKLOADS_FOR_PARTNERS - Assured Workloads for Partners */
  ASSURED_WORKLOADS_FOR_PARTNERS = 12,
  UNRECOGNIZED = -1,
}

export function workload_ComplianceRegimeFromJSON(object: any): Workload_ComplianceRegime {
  switch (object) {
    case 0:
    case "COMPLIANCE_REGIME_UNSPECIFIED":
      return Workload_ComplianceRegime.COMPLIANCE_REGIME_UNSPECIFIED;
    case 1:
    case "IL4":
      return Workload_ComplianceRegime.IL4;
    case 2:
    case "CJIS":
      return Workload_ComplianceRegime.CJIS;
    case 3:
    case "FEDRAMP_HIGH":
      return Workload_ComplianceRegime.FEDRAMP_HIGH;
    case 4:
    case "FEDRAMP_MODERATE":
      return Workload_ComplianceRegime.FEDRAMP_MODERATE;
    case 5:
    case "US_REGIONAL_ACCESS":
      return Workload_ComplianceRegime.US_REGIONAL_ACCESS;
    case 6:
    case "HIPAA":
      return Workload_ComplianceRegime.HIPAA;
    case 7:
    case "HITRUST":
      return Workload_ComplianceRegime.HITRUST;
    case 8:
    case "EU_REGIONS_AND_SUPPORT":
      return Workload_ComplianceRegime.EU_REGIONS_AND_SUPPORT;
    case 9:
    case "CA_REGIONS_AND_SUPPORT":
      return Workload_ComplianceRegime.CA_REGIONS_AND_SUPPORT;
    case 10:
    case "ITAR":
      return Workload_ComplianceRegime.ITAR;
    case 11:
    case "AU_REGIONS_AND_US_SUPPORT":
      return Workload_ComplianceRegime.AU_REGIONS_AND_US_SUPPORT;
    case 12:
    case "ASSURED_WORKLOADS_FOR_PARTNERS":
      return Workload_ComplianceRegime.ASSURED_WORKLOADS_FOR_PARTNERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Workload_ComplianceRegime.UNRECOGNIZED;
  }
}

export function workload_ComplianceRegimeToJSON(object: Workload_ComplianceRegime): string {
  switch (object) {
    case Workload_ComplianceRegime.COMPLIANCE_REGIME_UNSPECIFIED:
      return "COMPLIANCE_REGIME_UNSPECIFIED";
    case Workload_ComplianceRegime.IL4:
      return "IL4";
    case Workload_ComplianceRegime.CJIS:
      return "CJIS";
    case Workload_ComplianceRegime.FEDRAMP_HIGH:
      return "FEDRAMP_HIGH";
    case Workload_ComplianceRegime.FEDRAMP_MODERATE:
      return "FEDRAMP_MODERATE";
    case Workload_ComplianceRegime.US_REGIONAL_ACCESS:
      return "US_REGIONAL_ACCESS";
    case Workload_ComplianceRegime.HIPAA:
      return "HIPAA";
    case Workload_ComplianceRegime.HITRUST:
      return "HITRUST";
    case Workload_ComplianceRegime.EU_REGIONS_AND_SUPPORT:
      return "EU_REGIONS_AND_SUPPORT";
    case Workload_ComplianceRegime.CA_REGIONS_AND_SUPPORT:
      return "CA_REGIONS_AND_SUPPORT";
    case Workload_ComplianceRegime.ITAR:
      return "ITAR";
    case Workload_ComplianceRegime.AU_REGIONS_AND_US_SUPPORT:
      return "AU_REGIONS_AND_US_SUPPORT";
    case Workload_ComplianceRegime.ASSURED_WORKLOADS_FOR_PARTNERS:
      return "ASSURED_WORKLOADS_FOR_PARTNERS";
    case Workload_ComplianceRegime.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Key Access Justifications(KAJ) Enrollment State. */
export enum Workload_KajEnrollmentState {
  /** KAJ_ENROLLMENT_STATE_UNSPECIFIED - Default State for KAJ Enrollment. */
  KAJ_ENROLLMENT_STATE_UNSPECIFIED = 0,
  /** KAJ_ENROLLMENT_STATE_PENDING - Pending State for KAJ Enrollment. */
  KAJ_ENROLLMENT_STATE_PENDING = 1,
  /** KAJ_ENROLLMENT_STATE_COMPLETE - Complete State for KAJ Enrollment. */
  KAJ_ENROLLMENT_STATE_COMPLETE = 2,
  UNRECOGNIZED = -1,
}

export function workload_KajEnrollmentStateFromJSON(object: any): Workload_KajEnrollmentState {
  switch (object) {
    case 0:
    case "KAJ_ENROLLMENT_STATE_UNSPECIFIED":
      return Workload_KajEnrollmentState.KAJ_ENROLLMENT_STATE_UNSPECIFIED;
    case 1:
    case "KAJ_ENROLLMENT_STATE_PENDING":
      return Workload_KajEnrollmentState.KAJ_ENROLLMENT_STATE_PENDING;
    case 2:
    case "KAJ_ENROLLMENT_STATE_COMPLETE":
      return Workload_KajEnrollmentState.KAJ_ENROLLMENT_STATE_COMPLETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Workload_KajEnrollmentState.UNRECOGNIZED;
  }
}

export function workload_KajEnrollmentStateToJSON(object: Workload_KajEnrollmentState): string {
  switch (object) {
    case Workload_KajEnrollmentState.KAJ_ENROLLMENT_STATE_UNSPECIFIED:
      return "KAJ_ENROLLMENT_STATE_UNSPECIFIED";
    case Workload_KajEnrollmentState.KAJ_ENROLLMENT_STATE_PENDING:
      return "KAJ_ENROLLMENT_STATE_PENDING";
    case Workload_KajEnrollmentState.KAJ_ENROLLMENT_STATE_COMPLETE:
      return "KAJ_ENROLLMENT_STATE_COMPLETE";
    case Workload_KajEnrollmentState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Supported Assured Workloads Partners. */
export enum Workload_Partner {
  /** PARTNER_UNSPECIFIED - Unknown partner regime/controls. */
  PARTNER_UNSPECIFIED = 0,
  /** LOCAL_CONTROLS_BY_S3NS - S3NS regime/controls. */
  LOCAL_CONTROLS_BY_S3NS = 1,
  UNRECOGNIZED = -1,
}

export function workload_PartnerFromJSON(object: any): Workload_Partner {
  switch (object) {
    case 0:
    case "PARTNER_UNSPECIFIED":
      return Workload_Partner.PARTNER_UNSPECIFIED;
    case 1:
    case "LOCAL_CONTROLS_BY_S3NS":
      return Workload_Partner.LOCAL_CONTROLS_BY_S3NS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Workload_Partner.UNRECOGNIZED;
  }
}

export function workload_PartnerToJSON(object: Workload_Partner): string {
  switch (object) {
    case Workload_Partner.PARTNER_UNSPECIFIED:
      return "PARTNER_UNSPECIFIED";
    case Workload_Partner.LOCAL_CONTROLS_BY_S3NS:
      return "LOCAL_CONTROLS_BY_S3NS";
    case Workload_Partner.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represent the resources that are children of this Workload. */
export interface Workload_ResourceInfo {
  /**
   * Resource identifier.
   * For a project this represents project_number.
   */
  resourceId: Long;
  /** Indicates the type of resource. */
  resourceType: Workload_ResourceInfo_ResourceType;
}

/** The type of resource. */
export enum Workload_ResourceInfo_ResourceType {
  /** RESOURCE_TYPE_UNSPECIFIED - Unknown resource type. */
  RESOURCE_TYPE_UNSPECIFIED = 0,
  /**
   * CONSUMER_PROJECT - Consumer project.
   * AssuredWorkloads Projects are no longer supported. This field will be
   * ignored only in CreateWorkload requests. ListWorkloads and GetWorkload
   * will continue to provide projects information.
   * Use CONSUMER_FOLDER instead.
   *
   * @deprecated
   */
  CONSUMER_PROJECT = 1,
  /** CONSUMER_FOLDER - Consumer Folder. */
  CONSUMER_FOLDER = 4,
  /** ENCRYPTION_KEYS_PROJECT - Consumer project containing encryption keys. */
  ENCRYPTION_KEYS_PROJECT = 2,
  /** KEYRING - Keyring resource that hosts encryption keys. */
  KEYRING = 3,
  UNRECOGNIZED = -1,
}

export function workload_ResourceInfo_ResourceTypeFromJSON(object: any): Workload_ResourceInfo_ResourceType {
  switch (object) {
    case 0:
    case "RESOURCE_TYPE_UNSPECIFIED":
      return Workload_ResourceInfo_ResourceType.RESOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "CONSUMER_PROJECT":
      return Workload_ResourceInfo_ResourceType.CONSUMER_PROJECT;
    case 4:
    case "CONSUMER_FOLDER":
      return Workload_ResourceInfo_ResourceType.CONSUMER_FOLDER;
    case 2:
    case "ENCRYPTION_KEYS_PROJECT":
      return Workload_ResourceInfo_ResourceType.ENCRYPTION_KEYS_PROJECT;
    case 3:
    case "KEYRING":
      return Workload_ResourceInfo_ResourceType.KEYRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Workload_ResourceInfo_ResourceType.UNRECOGNIZED;
  }
}

export function workload_ResourceInfo_ResourceTypeToJSON(object: Workload_ResourceInfo_ResourceType): string {
  switch (object) {
    case Workload_ResourceInfo_ResourceType.RESOURCE_TYPE_UNSPECIFIED:
      return "RESOURCE_TYPE_UNSPECIFIED";
    case Workload_ResourceInfo_ResourceType.CONSUMER_PROJECT:
      return "CONSUMER_PROJECT";
    case Workload_ResourceInfo_ResourceType.CONSUMER_FOLDER:
      return "CONSUMER_FOLDER";
    case Workload_ResourceInfo_ResourceType.ENCRYPTION_KEYS_PROJECT:
      return "ENCRYPTION_KEYS_PROJECT";
    case Workload_ResourceInfo_ResourceType.KEYRING:
      return "KEYRING";
    case Workload_ResourceInfo_ResourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Settings specific to the Key Management Service.
 * This message is deprecated.
 * In order to create a Keyring, callers should specify,
 * ENCRYPTION_KEYS_PROJECT or KEYRING in ResourceSettings.resource_type field.
 *
 * @deprecated
 */
export interface Workload_KMSSettings {
  /**
   * Required. Input only. Immutable. The time at which the Key Management Service will automatically create a
   * new version of the crypto key and mark it as the primary.
   */
  nextRotationTime:
    | Date
    | undefined;
  /**
   * Required. Input only. Immutable. [next_rotation_time] will be advanced by this period when the Key
   * Management Service automatically rotates a key. Must be at least 24 hours
   * and at most 876,000 hours.
   */
  rotationPeriod: Duration | undefined;
}

/** Represent the custom settings for the resources to be created. */
export interface Workload_ResourceSettings {
  /**
   * Resource identifier.
   * For a project this represents project_id. If the project is already
   * taken, the workload creation will fail.
   * For KeyRing, this represents the keyring_id.
   * For a folder, don't set this value as folder_id is assigned by Google.
   */
  resourceId: string;
  /**
   * Indicates the type of resource. This field should be specified to
   * correspond the id to the right resource type (CONSUMER_FOLDER or
   * ENCRYPTION_KEYS_PROJECT)
   */
  resourceType: Workload_ResourceInfo_ResourceType;
  /**
   * User-assigned resource display name.
   * If not empty it will be used to create a resource with the specified
   * name.
   */
  displayName: string;
}

/** Signed Access Approvals (SAA) enrollment response. */
export interface Workload_SaaEnrollmentResponse {
  /** Indicates SAA enrollment status of a given workload. */
  setupStatus?:
    | Workload_SaaEnrollmentResponse_SetupState
    | undefined;
  /** Indicates SAA enrollment setup error if any. */
  setupErrors: Workload_SaaEnrollmentResponse_SetupError[];
}

/** Setup state of SAA enrollment. */
export enum Workload_SaaEnrollmentResponse_SetupState {
  /** SETUP_STATE_UNSPECIFIED - Unspecified. */
  SETUP_STATE_UNSPECIFIED = 0,
  /** STATUS_PENDING - SAA enrollment pending. */
  STATUS_PENDING = 1,
  /** STATUS_COMPLETE - SAA enrollment comopleted. */
  STATUS_COMPLETE = 2,
  UNRECOGNIZED = -1,
}

export function workload_SaaEnrollmentResponse_SetupStateFromJSON(
  object: any,
): Workload_SaaEnrollmentResponse_SetupState {
  switch (object) {
    case 0:
    case "SETUP_STATE_UNSPECIFIED":
      return Workload_SaaEnrollmentResponse_SetupState.SETUP_STATE_UNSPECIFIED;
    case 1:
    case "STATUS_PENDING":
      return Workload_SaaEnrollmentResponse_SetupState.STATUS_PENDING;
    case 2:
    case "STATUS_COMPLETE":
      return Workload_SaaEnrollmentResponse_SetupState.STATUS_COMPLETE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Workload_SaaEnrollmentResponse_SetupState.UNRECOGNIZED;
  }
}

export function workload_SaaEnrollmentResponse_SetupStateToJSON(
  object: Workload_SaaEnrollmentResponse_SetupState,
): string {
  switch (object) {
    case Workload_SaaEnrollmentResponse_SetupState.SETUP_STATE_UNSPECIFIED:
      return "SETUP_STATE_UNSPECIFIED";
    case Workload_SaaEnrollmentResponse_SetupState.STATUS_PENDING:
      return "STATUS_PENDING";
    case Workload_SaaEnrollmentResponse_SetupState.STATUS_COMPLETE:
      return "STATUS_COMPLETE";
    case Workload_SaaEnrollmentResponse_SetupState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Setup error of SAA enrollment. */
export enum Workload_SaaEnrollmentResponse_SetupError {
  /** SETUP_ERROR_UNSPECIFIED - Unspecified. */
  SETUP_ERROR_UNSPECIFIED = 0,
  /**
   * ERROR_INVALID_BASE_SETUP - Invalid states for all customers, to be redirected to AA UI for
   * additional details.
   */
  ERROR_INVALID_BASE_SETUP = 1,
  /** ERROR_MISSING_EXTERNAL_SIGNING_KEY - Returned when there is not an EKM key configured. */
  ERROR_MISSING_EXTERNAL_SIGNING_KEY = 2,
  /**
   * ERROR_NOT_ALL_SERVICES_ENROLLED - Returned when there are no enrolled services or the customer is
   * enrolled in CAA only for a subset of services.
   */
  ERROR_NOT_ALL_SERVICES_ENROLLED = 3,
  /**
   * ERROR_SETUP_CHECK_FAILED - Returned when exception was encountered during evaluation of other
   * criteria.
   */
  ERROR_SETUP_CHECK_FAILED = 4,
  UNRECOGNIZED = -1,
}

export function workload_SaaEnrollmentResponse_SetupErrorFromJSON(
  object: any,
): Workload_SaaEnrollmentResponse_SetupError {
  switch (object) {
    case 0:
    case "SETUP_ERROR_UNSPECIFIED":
      return Workload_SaaEnrollmentResponse_SetupError.SETUP_ERROR_UNSPECIFIED;
    case 1:
    case "ERROR_INVALID_BASE_SETUP":
      return Workload_SaaEnrollmentResponse_SetupError.ERROR_INVALID_BASE_SETUP;
    case 2:
    case "ERROR_MISSING_EXTERNAL_SIGNING_KEY":
      return Workload_SaaEnrollmentResponse_SetupError.ERROR_MISSING_EXTERNAL_SIGNING_KEY;
    case 3:
    case "ERROR_NOT_ALL_SERVICES_ENROLLED":
      return Workload_SaaEnrollmentResponse_SetupError.ERROR_NOT_ALL_SERVICES_ENROLLED;
    case 4:
    case "ERROR_SETUP_CHECK_FAILED":
      return Workload_SaaEnrollmentResponse_SetupError.ERROR_SETUP_CHECK_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Workload_SaaEnrollmentResponse_SetupError.UNRECOGNIZED;
  }
}

export function workload_SaaEnrollmentResponse_SetupErrorToJSON(
  object: Workload_SaaEnrollmentResponse_SetupError,
): string {
  switch (object) {
    case Workload_SaaEnrollmentResponse_SetupError.SETUP_ERROR_UNSPECIFIED:
      return "SETUP_ERROR_UNSPECIFIED";
    case Workload_SaaEnrollmentResponse_SetupError.ERROR_INVALID_BASE_SETUP:
      return "ERROR_INVALID_BASE_SETUP";
    case Workload_SaaEnrollmentResponse_SetupError.ERROR_MISSING_EXTERNAL_SIGNING_KEY:
      return "ERROR_MISSING_EXTERNAL_SIGNING_KEY";
    case Workload_SaaEnrollmentResponse_SetupError.ERROR_NOT_ALL_SERVICES_ENROLLED:
      return "ERROR_NOT_ALL_SERVICES_ENROLLED";
    case Workload_SaaEnrollmentResponse_SetupError.ERROR_SETUP_CHECK_FAILED:
      return "ERROR_SETUP_CHECK_FAILED";
    case Workload_SaaEnrollmentResponse_SetupError.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Workload_LabelsEntry {
  key: string;
  value: string;
}

/** Operation metadata to give request details of CreateWorkload. */
export interface CreateWorkloadOperationMetadata {
  /** Optional. Time when the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Optional. The display name of the workload. */
  displayName: string;
  /** Optional. The parent of the workload. */
  parent: string;
  /**
   * Optional. Compliance controls that should be applied to the resources managed by
   * the workload.
   */
  complianceRegime: Workload_ComplianceRegime;
}

/** Request for restricting list of available resources in Workload environment. */
export interface RestrictAllowedResourcesRequest {
  /**
   * Required. The resource name of the Workload. This is the workloads's
   * relative path in the API, formatted as
   * "organizations/{organization_id}/locations/{location_id}/workloads/{workload_id}".
   * For example,
   * "organizations/123/locations/us-east1/workloads/assured-workload-1".
   */
  name: string;
  /** Required. The type of restriction for using gcp products in the Workload environment. */
  restrictionType: RestrictAllowedResourcesRequest_RestrictionType;
}

/** The type of restriction. */
export enum RestrictAllowedResourcesRequest_RestrictionType {
  /** RESTRICTION_TYPE_UNSPECIFIED - Unknown restriction type. */
  RESTRICTION_TYPE_UNSPECIFIED = 0,
  /**
   * ALLOW_ALL_GCP_RESOURCES - Allow the use all of all gcp products, irrespective of the compliance
   * posture. This effectively removes gcp.restrictServiceUsage OrgPolicy
   * on the AssuredWorkloads Folder.
   */
  ALLOW_ALL_GCP_RESOURCES = 1,
  /**
   * ALLOW_COMPLIANT_RESOURCES - Based on Workload's compliance regime, allowed list changes.
   * See - https://cloud.google.com/assured-workloads/docs/supported-products
   * for the list of supported resources.
   */
  ALLOW_COMPLIANT_RESOURCES = 2,
  UNRECOGNIZED = -1,
}

export function restrictAllowedResourcesRequest_RestrictionTypeFromJSON(
  object: any,
): RestrictAllowedResourcesRequest_RestrictionType {
  switch (object) {
    case 0:
    case "RESTRICTION_TYPE_UNSPECIFIED":
      return RestrictAllowedResourcesRequest_RestrictionType.RESTRICTION_TYPE_UNSPECIFIED;
    case 1:
    case "ALLOW_ALL_GCP_RESOURCES":
      return RestrictAllowedResourcesRequest_RestrictionType.ALLOW_ALL_GCP_RESOURCES;
    case 2:
    case "ALLOW_COMPLIANT_RESOURCES":
      return RestrictAllowedResourcesRequest_RestrictionType.ALLOW_COMPLIANT_RESOURCES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RestrictAllowedResourcesRequest_RestrictionType.UNRECOGNIZED;
  }
}

export function restrictAllowedResourcesRequest_RestrictionTypeToJSON(
  object: RestrictAllowedResourcesRequest_RestrictionType,
): string {
  switch (object) {
    case RestrictAllowedResourcesRequest_RestrictionType.RESTRICTION_TYPE_UNSPECIFIED:
      return "RESTRICTION_TYPE_UNSPECIFIED";
    case RestrictAllowedResourcesRequest_RestrictionType.ALLOW_ALL_GCP_RESOURCES:
      return "ALLOW_ALL_GCP_RESOURCES";
    case RestrictAllowedResourcesRequest_RestrictionType.ALLOW_COMPLIANT_RESOURCES:
      return "ALLOW_COMPLIANT_RESOURCES";
    case RestrictAllowedResourcesRequest_RestrictionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Response for restricting the list of allowed resources. */
export interface RestrictAllowedResourcesResponse {
}

/**
 * Request for acknowledging the violation
 * Next Id: 4
 */
export interface AcknowledgeViolationRequest {
  /**
   * Required. The resource name of the Violation to acknowledge.
   * Format:
   * organizations/{organization}/locations/{location}/workloads/{workload}/violations/{violation}
   */
  name: string;
  /** Required. Business justification explaining the need for violation acknowledgement */
  comment: string;
  /**
   * Optional. This field is deprecated and will be removed in future version of the API.
   * Name of the OrgPolicy which was modified with non-compliant change and
   * resulted in this violation.
   * Format:
   * projects/{project_number}/policies/{constraint_name}
   * folders/{folder_id}/policies/{constraint_name}
   * organizations/{organization_id}/policies/{constraint_name}
   *
   * @deprecated
   */
  nonCompliantOrgPolicy: string;
}

/** Response for violation acknowledgement */
export interface AcknowledgeViolationResponse {
}

/** Interval defining a time window. */
export interface TimeWindow {
  /** The start of the time window. */
  startTime:
    | Date
    | undefined;
  /** The end of the time window. */
  endTime: Date | undefined;
}

/** Request for fetching violations in an organization. */
export interface ListViolationsRequest {
  /**
   * Required. The Workload name.
   * Format `organizations/{org_id}/locations/{location}/workloads/{workload}`.
   */
  parent: string;
  /**
   * Optional. Specifies the time window for retrieving active Violations.
   * When specified, retrieves Violations that were active between start_time
   * and end_time.
   */
  interval:
    | TimeWindow
    | undefined;
  /** Optional. Page size. */
  pageSize: number;
  /** Optional. Page token returned from previous request. */
  pageToken: string;
  /** Optional. A custom filter for filtering by the Violations properties. */
  filter: string;
}

/** Response of ListViolations endpoint. */
export interface ListViolationsResponse {
  /** List of Violations under a Workload. */
  violations: Violation[];
  /** The next page token. Returns empty if reached the last page. */
  nextPageToken: string;
}

/** Request for fetching a Workload Violation. */
export interface GetViolationRequest {
  /**
   * Required. The resource name of the Violation to fetch (ie. Violation.name).
   * Format:
   * organizations/{organization}/locations/{location}/workloads/{workload}/violations/{violation}
   */
  name: string;
}

/** Workload monitoring Violation. */
export interface Violation {
  /**
   * Output only. Immutable. Name of the Violation.
   * Format:
   * organizations/{organization}/locations/{location}/workloads/{workload_id}/violations/{violations_id}
   */
  name: string;
  /**
   * Output only. Description for the Violation.
   * e.g. OrgPolicy gcp.resourceLocations has non compliant value.
   */
  description: string;
  /** Output only. Time of the event which triggered the Violation. */
  beginTime:
    | Date
    | undefined;
  /** Output only. The last time when the Violation record was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Time of the event which fixed the Violation.
   * If the violation is ACTIVE this will be empty.
   */
  resolveTime:
    | Date
    | undefined;
  /**
   * Output only. Category under which this violation is mapped.
   * e.g. Location, Service Usage, Access, Encryption, etc.
   */
  category: string;
  /** Output only. State of the violation */
  state: Violation_State;
  /**
   * Output only. Immutable. The org-policy-constraint that was incorrectly changed, which resulted in
   * this violation.
   */
  orgPolicyConstraint: string;
  /**
   * Output only. Immutable. Audit Log Link for violated resource
   * Format:
   * https://console.cloud.google.com/logs/query;query={logName}{protoPayload.resourceName}{timeRange}{folder}
   */
  auditLogLink: string;
  /**
   * Output only. Immutable. Name of the OrgPolicy which was modified with non-compliant change and
   * resulted this violation.
   *  Format:
   *  projects/{project_number}/policies/{constraint_name}
   *  folders/{folder_id}/policies/{constraint_name}
   *  organizations/{organization_id}/policies/{constraint_name}
   */
  nonCompliantOrgPolicy: string;
  /** Output only. Compliance violation remediation */
  remediation:
    | Violation_Remediation
    | undefined;
  /** Output only. A boolean that indicates if the violation is acknowledged */
  acknowledged: boolean;
  /**
   * Optional. Timestamp when this violation was acknowledged last.
   * This will be absent when acknowledged field is marked as false.
   */
  acknowledgementTime?:
    | Date
    | undefined;
  /**
   * Output only. Immutable. Audit Log link to find business justification provided for violation
   * exception. Format:
   * https://console.cloud.google.com/logs/query;query={logName}{protoPayload.resourceName}{protoPayload.methodName}{timeRange}{organization}
   */
  exceptionAuditLogLink: string;
}

/** Violation State Values */
export enum Violation_State {
  /** STATE_UNSPECIFIED - Unspecified state. */
  STATE_UNSPECIFIED = 0,
  /** RESOLVED - Violation is resolved. */
  RESOLVED = 2,
  /** UNRESOLVED - Violation is Unresolved */
  UNRESOLVED = 3,
  /** EXCEPTION - Violation is Exception */
  EXCEPTION = 4,
  UNRECOGNIZED = -1,
}

export function violation_StateFromJSON(object: any): Violation_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Violation_State.STATE_UNSPECIFIED;
    case 2:
    case "RESOLVED":
      return Violation_State.RESOLVED;
    case 3:
    case "UNRESOLVED":
      return Violation_State.UNRESOLVED;
    case 4:
    case "EXCEPTION":
      return Violation_State.EXCEPTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Violation_State.UNRECOGNIZED;
  }
}

export function violation_StateToJSON(object: Violation_State): string {
  switch (object) {
    case Violation_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Violation_State.RESOLVED:
      return "RESOLVED";
    case Violation_State.UNRESOLVED:
      return "UNRESOLVED";
    case Violation_State.EXCEPTION:
      return "EXCEPTION";
    case Violation_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents remediation guidance to resolve compliance violation for
 * AssuredWorkload
 */
export interface Violation_Remediation {
  /** Required. Remediation instructions to resolve violations */
  instructions:
    | Violation_Remediation_Instructions
    | undefined;
  /**
   * Values that can resolve the violation
   * For example: for list org policy violations, this will either be the list
   * of allowed or denied values
   */
  compliantValues: string[];
  /** Output only. Reemediation type based on the type of org policy values violated */
  remediationType: Violation_Remediation_RemediationType;
}

/**
 * Classifying remediation into various types based on the kind of
 * violation. For example, violations caused due to changes in boolean org
 * policy requires different remediation instructions compared to violation
 * caused due to changes in allowed values of list org policy.
 */
export enum Violation_Remediation_RemediationType {
  /** REMEDIATION_TYPE_UNSPECIFIED - Unspecified remediation type */
  REMEDIATION_TYPE_UNSPECIFIED = 0,
  /** REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION - Remediation type for boolean org policy */
  REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION = 1,
  /**
   * REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION - Remediation type for list org policy which have allowed values in the
   * monitoring rule
   */
  REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION = 2,
  /**
   * REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION - Remediation type for list org policy which have denied values in the
   * monitoring rule
   */
  REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION = 3,
  /** REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION - Remediation type for gcp.restrictCmekCryptoKeyProjects */
  REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION = 4,
  UNRECOGNIZED = -1,
}

export function violation_Remediation_RemediationTypeFromJSON(object: any): Violation_Remediation_RemediationType {
  switch (object) {
    case 0:
    case "REMEDIATION_TYPE_UNSPECIFIED":
      return Violation_Remediation_RemediationType.REMEDIATION_TYPE_UNSPECIFIED;
    case 1:
    case "REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION":
      return Violation_Remediation_RemediationType.REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION;
    case 2:
    case "REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION":
      return Violation_Remediation_RemediationType.REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION;
    case 3:
    case "REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION":
      return Violation_Remediation_RemediationType.REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION;
    case 4:
    case "REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION":
      return Violation_Remediation_RemediationType.REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Violation_Remediation_RemediationType.UNRECOGNIZED;
  }
}

export function violation_Remediation_RemediationTypeToJSON(object: Violation_Remediation_RemediationType): string {
  switch (object) {
    case Violation_Remediation_RemediationType.REMEDIATION_TYPE_UNSPECIFIED:
      return "REMEDIATION_TYPE_UNSPECIFIED";
    case Violation_Remediation_RemediationType.REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION:
      return "REMEDIATION_BOOLEAN_ORG_POLICY_VIOLATION";
    case Violation_Remediation_RemediationType.REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION:
      return "REMEDIATION_LIST_ALLOWED_VALUES_ORG_POLICY_VIOLATION";
    case Violation_Remediation_RemediationType.REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION:
      return "REMEDIATION_LIST_DENIED_VALUES_ORG_POLICY_VIOLATION";
    case Violation_Remediation_RemediationType.REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION:
      return "REMEDIATION_RESTRICT_CMEK_CRYPTO_KEY_PROJECTS_ORG_POLICY_VIOLATION";
    case Violation_Remediation_RemediationType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Instructions to remediate violation */
export interface Violation_Remediation_Instructions {
  /** Remediation instructions to resolve violation via gcloud cli */
  gcloudInstructions:
    | Violation_Remediation_Instructions_Gcloud
    | undefined;
  /** Remediation instructions to resolve violation via cloud console */
  consoleInstructions: Violation_Remediation_Instructions_Console | undefined;
}

/** Remediation instructions to resolve violation via gcloud cli */
export interface Violation_Remediation_Instructions_Gcloud {
  /** Gcloud command to resolve violation */
  gcloudCommands: string[];
  /** Steps to resolve violation via gcloud cli */
  steps: string[];
  /** Additional urls for more information about steps */
  additionalLinks: string[];
}

/** Remediation instructions to resolve violation via cloud console */
export interface Violation_Remediation_Instructions_Console {
  /** Link to console page where violations can be resolved */
  consoleUris: string[];
  /** Steps to resolve violation via cloud console */
  steps: string[];
  /** Additional urls for more information about steps */
  additionalLinks: string[];
}

function createBaseCreateWorkloadRequest(): CreateWorkloadRequest {
  return { parent: "", workload: undefined, externalId: "" };
}

export const CreateWorkloadRequest: MessageFns<CreateWorkloadRequest> = {
  encode(message: CreateWorkloadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.workload !== undefined) {
      Workload.encode(message.workload, writer.uint32(18).fork()).join();
    }
    if (message.externalId !== "") {
      writer.uint32(26).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWorkloadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWorkloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.workload = Workload.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWorkloadRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      workload: isSet(object.workload) ? Workload.fromJSON(object.workload) : undefined,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: CreateWorkloadRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.workload !== undefined) {
      obj.workload = Workload.toJSON(message.workload);
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWorkloadRequest>): CreateWorkloadRequest {
    return CreateWorkloadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWorkloadRequest>): CreateWorkloadRequest {
    const message = createBaseCreateWorkloadRequest();
    message.parent = object.parent ?? "";
    message.workload = (object.workload !== undefined && object.workload !== null)
      ? Workload.fromPartial(object.workload)
      : undefined;
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseUpdateWorkloadRequest(): UpdateWorkloadRequest {
  return { workload: undefined, updateMask: undefined };
}

export const UpdateWorkloadRequest: MessageFns<UpdateWorkloadRequest> = {
  encode(message: UpdateWorkloadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workload !== undefined) {
      Workload.encode(message.workload, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateWorkloadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateWorkloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workload = Workload.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateWorkloadRequest {
    return {
      workload: isSet(object.workload) ? Workload.fromJSON(object.workload) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateWorkloadRequest): unknown {
    const obj: any = {};
    if (message.workload !== undefined) {
      obj.workload = Workload.toJSON(message.workload);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateWorkloadRequest>): UpdateWorkloadRequest {
    return UpdateWorkloadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateWorkloadRequest>): UpdateWorkloadRequest {
    const message = createBaseUpdateWorkloadRequest();
    message.workload = (object.workload !== undefined && object.workload !== null)
      ? Workload.fromPartial(object.workload)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseDeleteWorkloadRequest(): DeleteWorkloadRequest {
  return { name: "", etag: "" };
}

export const DeleteWorkloadRequest: MessageFns<DeleteWorkloadRequest> = {
  encode(message: DeleteWorkloadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteWorkloadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteWorkloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteWorkloadRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteWorkloadRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteWorkloadRequest>): DeleteWorkloadRequest {
    return DeleteWorkloadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteWorkloadRequest>): DeleteWorkloadRequest {
    const message = createBaseDeleteWorkloadRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseGetWorkloadRequest(): GetWorkloadRequest {
  return { name: "" };
}

export const GetWorkloadRequest: MessageFns<GetWorkloadRequest> = {
  encode(message: GetWorkloadRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetWorkloadRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetWorkloadRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetWorkloadRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetWorkloadRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetWorkloadRequest>): GetWorkloadRequest {
    return GetWorkloadRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetWorkloadRequest>): GetWorkloadRequest {
    const message = createBaseGetWorkloadRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListWorkloadsRequest(): ListWorkloadsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListWorkloadsRequest: MessageFns<ListWorkloadsRequest> = {
  encode(message: ListWorkloadsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkloadsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkloadsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkloadsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListWorkloadsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkloadsRequest>): ListWorkloadsRequest {
    return ListWorkloadsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkloadsRequest>): ListWorkloadsRequest {
    const message = createBaseListWorkloadsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListWorkloadsResponse(): ListWorkloadsResponse {
  return { workloads: [], nextPageToken: "" };
}

export const ListWorkloadsResponse: MessageFns<ListWorkloadsResponse> = {
  encode(message: ListWorkloadsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workloads) {
      Workload.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkloadsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkloadsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workloads.push(Workload.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkloadsResponse {
    return {
      workloads: globalThis.Array.isArray(object?.workloads)
        ? object.workloads.map((e: any) => Workload.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListWorkloadsResponse): unknown {
    const obj: any = {};
    if (message.workloads?.length) {
      obj.workloads = message.workloads.map((e) => Workload.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkloadsResponse>): ListWorkloadsResponse {
    return ListWorkloadsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkloadsResponse>): ListWorkloadsResponse {
    const message = createBaseListWorkloadsResponse();
    message.workloads = object.workloads?.map((e) => Workload.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseWorkload(): Workload {
  return {
    name: "",
    displayName: "",
    resources: [],
    complianceRegime: 0,
    createTime: undefined,
    billingAccount: "",
    etag: "",
    labels: {},
    provisionedResourcesParent: "",
    kmsSettings: undefined,
    resourceSettings: [],
    kajEnrollmentState: 0,
    enableSovereignControls: false,
    saaEnrollmentResponse: undefined,
    compliantButDisallowedServices: [],
    partner: 0,
  };
}

export const Workload: MessageFns<Workload> = {
  encode(message: Workload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.resources) {
      Workload_ResourceInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.complianceRegime !== 0) {
      writer.uint32(32).int32(message.complianceRegime);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.billingAccount !== "") {
      writer.uint32(50).string(message.billingAccount);
    }
    if (message.etag !== "") {
      writer.uint32(74).string(message.etag);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Workload_LabelsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.provisionedResourcesParent !== "") {
      writer.uint32(106).string(message.provisionedResourcesParent);
    }
    if (message.kmsSettings !== undefined) {
      Workload_KMSSettings.encode(message.kmsSettings, writer.uint32(114).fork()).join();
    }
    for (const v of message.resourceSettings) {
      Workload_ResourceSettings.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.kajEnrollmentState !== 0) {
      writer.uint32(136).int32(message.kajEnrollmentState);
    }
    if (message.enableSovereignControls !== false) {
      writer.uint32(144).bool(message.enableSovereignControls);
    }
    if (message.saaEnrollmentResponse !== undefined) {
      Workload_SaaEnrollmentResponse.encode(message.saaEnrollmentResponse, writer.uint32(162).fork()).join();
    }
    for (const v of message.compliantButDisallowedServices) {
      writer.uint32(194).string(v!);
    }
    if (message.partner !== 0) {
      writer.uint32(200).int32(message.partner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resources.push(Workload_ResourceInfo.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.complianceRegime = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.billingAccount = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Workload_LabelsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.labels[entry10.key] = entry10.value;
          }
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.provisionedResourcesParent = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.kmsSettings = Workload_KMSSettings.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.resourceSettings.push(Workload_ResourceSettings.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.kajEnrollmentState = reader.int32() as any;
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.enableSovereignControls = reader.bool();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.saaEnrollmentResponse = Workload_SaaEnrollmentResponse.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.compliantButDisallowedServices.push(reader.string());
          continue;
        case 25:
          if (tag !== 200) {
            break;
          }

          message.partner = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workload {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      resources: globalThis.Array.isArray(object?.resources)
        ? object.resources.map((e: any) => Workload_ResourceInfo.fromJSON(e))
        : [],
      complianceRegime: isSet(object.complianceRegime) ? workload_ComplianceRegimeFromJSON(object.complianceRegime) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      billingAccount: isSet(object.billingAccount) ? globalThis.String(object.billingAccount) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      provisionedResourcesParent: isSet(object.provisionedResourcesParent)
        ? globalThis.String(object.provisionedResourcesParent)
        : "",
      kmsSettings: isSet(object.kmsSettings) ? Workload_KMSSettings.fromJSON(object.kmsSettings) : undefined,
      resourceSettings: globalThis.Array.isArray(object?.resourceSettings)
        ? object.resourceSettings.map((e: any) => Workload_ResourceSettings.fromJSON(e))
        : [],
      kajEnrollmentState: isSet(object.kajEnrollmentState)
        ? workload_KajEnrollmentStateFromJSON(object.kajEnrollmentState)
        : 0,
      enableSovereignControls: isSet(object.enableSovereignControls)
        ? globalThis.Boolean(object.enableSovereignControls)
        : false,
      saaEnrollmentResponse: isSet(object.saaEnrollmentResponse)
        ? Workload_SaaEnrollmentResponse.fromJSON(object.saaEnrollmentResponse)
        : undefined,
      compliantButDisallowedServices: globalThis.Array.isArray(object?.compliantButDisallowedServices)
        ? object.compliantButDisallowedServices.map((e: any) => globalThis.String(e))
        : [],
      partner: isSet(object.partner) ? workload_PartnerFromJSON(object.partner) : 0,
    };
  },

  toJSON(message: Workload): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.resources?.length) {
      obj.resources = message.resources.map((e) => Workload_ResourceInfo.toJSON(e));
    }
    if (message.complianceRegime !== 0) {
      obj.complianceRegime = workload_ComplianceRegimeToJSON(message.complianceRegime);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.billingAccount !== "") {
      obj.billingAccount = message.billingAccount;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.provisionedResourcesParent !== "") {
      obj.provisionedResourcesParent = message.provisionedResourcesParent;
    }
    if (message.kmsSettings !== undefined) {
      obj.kmsSettings = Workload_KMSSettings.toJSON(message.kmsSettings);
    }
    if (message.resourceSettings?.length) {
      obj.resourceSettings = message.resourceSettings.map((e) => Workload_ResourceSettings.toJSON(e));
    }
    if (message.kajEnrollmentState !== 0) {
      obj.kajEnrollmentState = workload_KajEnrollmentStateToJSON(message.kajEnrollmentState);
    }
    if (message.enableSovereignControls !== false) {
      obj.enableSovereignControls = message.enableSovereignControls;
    }
    if (message.saaEnrollmentResponse !== undefined) {
      obj.saaEnrollmentResponse = Workload_SaaEnrollmentResponse.toJSON(message.saaEnrollmentResponse);
    }
    if (message.compliantButDisallowedServices?.length) {
      obj.compliantButDisallowedServices = message.compliantButDisallowedServices;
    }
    if (message.partner !== 0) {
      obj.partner = workload_PartnerToJSON(message.partner);
    }
    return obj;
  },

  create(base?: DeepPartial<Workload>): Workload {
    return Workload.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workload>): Workload {
    const message = createBaseWorkload();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.resources = object.resources?.map((e) => Workload_ResourceInfo.fromPartial(e)) || [];
    message.complianceRegime = object.complianceRegime ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.billingAccount = object.billingAccount ?? "";
    message.etag = object.etag ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.provisionedResourcesParent = object.provisionedResourcesParent ?? "";
    message.kmsSettings = (object.kmsSettings !== undefined && object.kmsSettings !== null)
      ? Workload_KMSSettings.fromPartial(object.kmsSettings)
      : undefined;
    message.resourceSettings = object.resourceSettings?.map((e) => Workload_ResourceSettings.fromPartial(e)) || [];
    message.kajEnrollmentState = object.kajEnrollmentState ?? 0;
    message.enableSovereignControls = object.enableSovereignControls ?? false;
    message.saaEnrollmentResponse =
      (object.saaEnrollmentResponse !== undefined && object.saaEnrollmentResponse !== null)
        ? Workload_SaaEnrollmentResponse.fromPartial(object.saaEnrollmentResponse)
        : undefined;
    message.compliantButDisallowedServices = object.compliantButDisallowedServices?.map((e) => e) || [];
    message.partner = object.partner ?? 0;
    return message;
  },
};

function createBaseWorkload_ResourceInfo(): Workload_ResourceInfo {
  return { resourceId: Long.ZERO, resourceType: 0 };
}

export const Workload_ResourceInfo: MessageFns<Workload_ResourceInfo> = {
  encode(message: Workload_ResourceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.resourceId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.resourceId.toString());
    }
    if (message.resourceType !== 0) {
      writer.uint32(16).int32(message.resourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workload_ResourceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkload_ResourceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.resourceId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.resourceType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workload_ResourceInfo {
    return {
      resourceId: isSet(object.resourceId) ? Long.fromValue(object.resourceId) : Long.ZERO,
      resourceType: isSet(object.resourceType) ? workload_ResourceInfo_ResourceTypeFromJSON(object.resourceType) : 0,
    };
  },

  toJSON(message: Workload_ResourceInfo): unknown {
    const obj: any = {};
    if (!message.resourceId.equals(Long.ZERO)) {
      obj.resourceId = (message.resourceId || Long.ZERO).toString();
    }
    if (message.resourceType !== 0) {
      obj.resourceType = workload_ResourceInfo_ResourceTypeToJSON(message.resourceType);
    }
    return obj;
  },

  create(base?: DeepPartial<Workload_ResourceInfo>): Workload_ResourceInfo {
    return Workload_ResourceInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workload_ResourceInfo>): Workload_ResourceInfo {
    const message = createBaseWorkload_ResourceInfo();
    message.resourceId = (object.resourceId !== undefined && object.resourceId !== null)
      ? Long.fromValue(object.resourceId)
      : Long.ZERO;
    message.resourceType = object.resourceType ?? 0;
    return message;
  },
};

function createBaseWorkload_KMSSettings(): Workload_KMSSettings {
  return { nextRotationTime: undefined, rotationPeriod: undefined };
}

export const Workload_KMSSettings: MessageFns<Workload_KMSSettings> = {
  encode(message: Workload_KMSSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nextRotationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.nextRotationTime), writer.uint32(10).fork()).join();
    }
    if (message.rotationPeriod !== undefined) {
      Duration.encode(message.rotationPeriod, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workload_KMSSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkload_KMSSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nextRotationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rotationPeriod = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workload_KMSSettings {
    return {
      nextRotationTime: isSet(object.nextRotationTime) ? fromJsonTimestamp(object.nextRotationTime) : undefined,
      rotationPeriod: isSet(object.rotationPeriod) ? Duration.fromJSON(object.rotationPeriod) : undefined,
    };
  },

  toJSON(message: Workload_KMSSettings): unknown {
    const obj: any = {};
    if (message.nextRotationTime !== undefined) {
      obj.nextRotationTime = message.nextRotationTime.toISOString();
    }
    if (message.rotationPeriod !== undefined) {
      obj.rotationPeriod = Duration.toJSON(message.rotationPeriod);
    }
    return obj;
  },

  create(base?: DeepPartial<Workload_KMSSettings>): Workload_KMSSettings {
    return Workload_KMSSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workload_KMSSettings>): Workload_KMSSettings {
    const message = createBaseWorkload_KMSSettings();
    message.nextRotationTime = object.nextRotationTime ?? undefined;
    message.rotationPeriod = (object.rotationPeriod !== undefined && object.rotationPeriod !== null)
      ? Duration.fromPartial(object.rotationPeriod)
      : undefined;
    return message;
  },
};

function createBaseWorkload_ResourceSettings(): Workload_ResourceSettings {
  return { resourceId: "", resourceType: 0, displayName: "" };
}

export const Workload_ResourceSettings: MessageFns<Workload_ResourceSettings> = {
  encode(message: Workload_ResourceSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resourceId !== "") {
      writer.uint32(10).string(message.resourceId);
    }
    if (message.resourceType !== 0) {
      writer.uint32(16).int32(message.resourceType);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workload_ResourceSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkload_ResourceSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resourceId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.resourceType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workload_ResourceSettings {
    return {
      resourceId: isSet(object.resourceId) ? globalThis.String(object.resourceId) : "",
      resourceType: isSet(object.resourceType) ? workload_ResourceInfo_ResourceTypeFromJSON(object.resourceType) : 0,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: Workload_ResourceSettings): unknown {
    const obj: any = {};
    if (message.resourceId !== "") {
      obj.resourceId = message.resourceId;
    }
    if (message.resourceType !== 0) {
      obj.resourceType = workload_ResourceInfo_ResourceTypeToJSON(message.resourceType);
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<Workload_ResourceSettings>): Workload_ResourceSettings {
    return Workload_ResourceSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workload_ResourceSettings>): Workload_ResourceSettings {
    const message = createBaseWorkload_ResourceSettings();
    message.resourceId = object.resourceId ?? "";
    message.resourceType = object.resourceType ?? 0;
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseWorkload_SaaEnrollmentResponse(): Workload_SaaEnrollmentResponse {
  return { setupStatus: undefined, setupErrors: [] };
}

export const Workload_SaaEnrollmentResponse: MessageFns<Workload_SaaEnrollmentResponse> = {
  encode(message: Workload_SaaEnrollmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.setupStatus !== undefined) {
      writer.uint32(8).int32(message.setupStatus);
    }
    writer.uint32(18).fork();
    for (const v of message.setupErrors) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workload_SaaEnrollmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkload_SaaEnrollmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.setupStatus = reader.int32() as any;
          continue;
        case 2:
          if (tag === 16) {
            message.setupErrors.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.setupErrors.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workload_SaaEnrollmentResponse {
    return {
      setupStatus: isSet(object.setupStatus)
        ? workload_SaaEnrollmentResponse_SetupStateFromJSON(object.setupStatus)
        : undefined,
      setupErrors: globalThis.Array.isArray(object?.setupErrors)
        ? object.setupErrors.map((e: any) => workload_SaaEnrollmentResponse_SetupErrorFromJSON(e))
        : [],
    };
  },

  toJSON(message: Workload_SaaEnrollmentResponse): unknown {
    const obj: any = {};
    if (message.setupStatus !== undefined) {
      obj.setupStatus = workload_SaaEnrollmentResponse_SetupStateToJSON(message.setupStatus);
    }
    if (message.setupErrors?.length) {
      obj.setupErrors = message.setupErrors.map((e) => workload_SaaEnrollmentResponse_SetupErrorToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Workload_SaaEnrollmentResponse>): Workload_SaaEnrollmentResponse {
    return Workload_SaaEnrollmentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workload_SaaEnrollmentResponse>): Workload_SaaEnrollmentResponse {
    const message = createBaseWorkload_SaaEnrollmentResponse();
    message.setupStatus = object.setupStatus ?? undefined;
    message.setupErrors = object.setupErrors?.map((e) => e) || [];
    return message;
  },
};

function createBaseWorkload_LabelsEntry(): Workload_LabelsEntry {
  return { key: "", value: "" };
}

export const Workload_LabelsEntry: MessageFns<Workload_LabelsEntry> = {
  encode(message: Workload_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workload_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkload_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workload_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Workload_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Workload_LabelsEntry>): Workload_LabelsEntry {
    return Workload_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Workload_LabelsEntry>): Workload_LabelsEntry {
    const message = createBaseWorkload_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateWorkloadOperationMetadata(): CreateWorkloadOperationMetadata {
  return { createTime: undefined, displayName: "", parent: "", complianceRegime: 0 };
}

export const CreateWorkloadOperationMetadata: MessageFns<CreateWorkloadOperationMetadata> = {
  encode(message: CreateWorkloadOperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.parent !== "") {
      writer.uint32(26).string(message.parent);
    }
    if (message.complianceRegime !== 0) {
      writer.uint32(32).int32(message.complianceRegime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateWorkloadOperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateWorkloadOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.complianceRegime = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateWorkloadOperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      complianceRegime: isSet(object.complianceRegime) ? workload_ComplianceRegimeFromJSON(object.complianceRegime) : 0,
    };
  },

  toJSON(message: CreateWorkloadOperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.complianceRegime !== 0) {
      obj.complianceRegime = workload_ComplianceRegimeToJSON(message.complianceRegime);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateWorkloadOperationMetadata>): CreateWorkloadOperationMetadata {
    return CreateWorkloadOperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateWorkloadOperationMetadata>): CreateWorkloadOperationMetadata {
    const message = createBaseCreateWorkloadOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.displayName = object.displayName ?? "";
    message.parent = object.parent ?? "";
    message.complianceRegime = object.complianceRegime ?? 0;
    return message;
  },
};

function createBaseRestrictAllowedResourcesRequest(): RestrictAllowedResourcesRequest {
  return { name: "", restrictionType: 0 };
}

export const RestrictAllowedResourcesRequest: MessageFns<RestrictAllowedResourcesRequest> = {
  encode(message: RestrictAllowedResourcesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.restrictionType !== 0) {
      writer.uint32(16).int32(message.restrictionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestrictAllowedResourcesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestrictAllowedResourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.restrictionType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestrictAllowedResourcesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      restrictionType: isSet(object.restrictionType)
        ? restrictAllowedResourcesRequest_RestrictionTypeFromJSON(object.restrictionType)
        : 0,
    };
  },

  toJSON(message: RestrictAllowedResourcesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.restrictionType !== 0) {
      obj.restrictionType = restrictAllowedResourcesRequest_RestrictionTypeToJSON(message.restrictionType);
    }
    return obj;
  },

  create(base?: DeepPartial<RestrictAllowedResourcesRequest>): RestrictAllowedResourcesRequest {
    return RestrictAllowedResourcesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestrictAllowedResourcesRequest>): RestrictAllowedResourcesRequest {
    const message = createBaseRestrictAllowedResourcesRequest();
    message.name = object.name ?? "";
    message.restrictionType = object.restrictionType ?? 0;
    return message;
  },
};

function createBaseRestrictAllowedResourcesResponse(): RestrictAllowedResourcesResponse {
  return {};
}

export const RestrictAllowedResourcesResponse: MessageFns<RestrictAllowedResourcesResponse> = {
  encode(_: RestrictAllowedResourcesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestrictAllowedResourcesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestrictAllowedResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RestrictAllowedResourcesResponse {
    return {};
  },

  toJSON(_: RestrictAllowedResourcesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RestrictAllowedResourcesResponse>): RestrictAllowedResourcesResponse {
    return RestrictAllowedResourcesResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RestrictAllowedResourcesResponse>): RestrictAllowedResourcesResponse {
    const message = createBaseRestrictAllowedResourcesResponse();
    return message;
  },
};

function createBaseAcknowledgeViolationRequest(): AcknowledgeViolationRequest {
  return { name: "", comment: "", nonCompliantOrgPolicy: "" };
}

export const AcknowledgeViolationRequest: MessageFns<AcknowledgeViolationRequest> = {
  encode(message: AcknowledgeViolationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.comment !== "") {
      writer.uint32(18).string(message.comment);
    }
    if (message.nonCompliantOrgPolicy !== "") {
      writer.uint32(26).string(message.nonCompliantOrgPolicy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcknowledgeViolationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgeViolationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.comment = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nonCompliantOrgPolicy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcknowledgeViolationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : "",
      nonCompliantOrgPolicy: isSet(object.nonCompliantOrgPolicy) ? globalThis.String(object.nonCompliantOrgPolicy) : "",
    };
  },

  toJSON(message: AcknowledgeViolationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.comment !== "") {
      obj.comment = message.comment;
    }
    if (message.nonCompliantOrgPolicy !== "") {
      obj.nonCompliantOrgPolicy = message.nonCompliantOrgPolicy;
    }
    return obj;
  },

  create(base?: DeepPartial<AcknowledgeViolationRequest>): AcknowledgeViolationRequest {
    return AcknowledgeViolationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcknowledgeViolationRequest>): AcknowledgeViolationRequest {
    const message = createBaseAcknowledgeViolationRequest();
    message.name = object.name ?? "";
    message.comment = object.comment ?? "";
    message.nonCompliantOrgPolicy = object.nonCompliantOrgPolicy ?? "";
    return message;
  },
};

function createBaseAcknowledgeViolationResponse(): AcknowledgeViolationResponse {
  return {};
}

export const AcknowledgeViolationResponse: MessageFns<AcknowledgeViolationResponse> = {
  encode(_: AcknowledgeViolationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcknowledgeViolationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcknowledgeViolationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): AcknowledgeViolationResponse {
    return {};
  },

  toJSON(_: AcknowledgeViolationResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<AcknowledgeViolationResponse>): AcknowledgeViolationResponse {
    return AcknowledgeViolationResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<AcknowledgeViolationResponse>): AcknowledgeViolationResponse {
    const message = createBaseAcknowledgeViolationResponse();
    return message;
  },
};

function createBaseTimeWindow(): TimeWindow {
  return { startTime: undefined, endTime: undefined };
}

export const TimeWindow: MessageFns<TimeWindow> = {
  encode(message: TimeWindow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeWindow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeWindow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeWindow {
    return {
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: TimeWindow): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TimeWindow>): TimeWindow {
    return TimeWindow.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeWindow>): TimeWindow {
    const message = createBaseTimeWindow();
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseListViolationsRequest(): ListViolationsRequest {
  return { parent: "", interval: undefined, pageSize: 0, pageToken: "", filter: "" };
}

export const ListViolationsRequest: MessageFns<ListViolationsRequest> = {
  encode(message: ListViolationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.interval !== undefined) {
      TimeWindow.encode(message.interval, writer.uint32(18).fork()).join();
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(42).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListViolationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListViolationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.interval = TimeWindow.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListViolationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      interval: isSet(object.interval) ? TimeWindow.fromJSON(object.interval) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListViolationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.interval !== undefined) {
      obj.interval = TimeWindow.toJSON(message.interval);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListViolationsRequest>): ListViolationsRequest {
    return ListViolationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListViolationsRequest>): ListViolationsRequest {
    const message = createBaseListViolationsRequest();
    message.parent = object.parent ?? "";
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? TimeWindow.fromPartial(object.interval)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListViolationsResponse(): ListViolationsResponse {
  return { violations: [], nextPageToken: "" };
}

export const ListViolationsResponse: MessageFns<ListViolationsResponse> = {
  encode(message: ListViolationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.violations) {
      Violation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListViolationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListViolationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.violations.push(Violation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListViolationsResponse {
    return {
      violations: globalThis.Array.isArray(object?.violations)
        ? object.violations.map((e: any) => Violation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListViolationsResponse): unknown {
    const obj: any = {};
    if (message.violations?.length) {
      obj.violations = message.violations.map((e) => Violation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListViolationsResponse>): ListViolationsResponse {
    return ListViolationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListViolationsResponse>): ListViolationsResponse {
    const message = createBaseListViolationsResponse();
    message.violations = object.violations?.map((e) => Violation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetViolationRequest(): GetViolationRequest {
  return { name: "" };
}

export const GetViolationRequest: MessageFns<GetViolationRequest> = {
  encode(message: GetViolationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetViolationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetViolationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetViolationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetViolationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetViolationRequest>): GetViolationRequest {
    return GetViolationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetViolationRequest>): GetViolationRequest {
    const message = createBaseGetViolationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseViolation(): Violation {
  return {
    name: "",
    description: "",
    beginTime: undefined,
    updateTime: undefined,
    resolveTime: undefined,
    category: "",
    state: 0,
    orgPolicyConstraint: "",
    auditLogLink: "",
    nonCompliantOrgPolicy: "",
    remediation: undefined,
    acknowledged: false,
    acknowledgementTime: undefined,
    exceptionAuditLogLink: "",
  };
}

export const Violation: MessageFns<Violation> = {
  encode(message: Violation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.beginTime !== undefined) {
      Timestamp.encode(toTimestamp(message.beginTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.resolveTime !== undefined) {
      Timestamp.encode(toTimestamp(message.resolveTime), writer.uint32(42).fork()).join();
    }
    if (message.category !== "") {
      writer.uint32(50).string(message.category);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message.orgPolicyConstraint !== "") {
      writer.uint32(66).string(message.orgPolicyConstraint);
    }
    if (message.auditLogLink !== "") {
      writer.uint32(90).string(message.auditLogLink);
    }
    if (message.nonCompliantOrgPolicy !== "") {
      writer.uint32(98).string(message.nonCompliantOrgPolicy);
    }
    if (message.remediation !== undefined) {
      Violation_Remediation.encode(message.remediation, writer.uint32(106).fork()).join();
    }
    if (message.acknowledged !== false) {
      writer.uint32(112).bool(message.acknowledged);
    }
    if (message.acknowledgementTime !== undefined) {
      Timestamp.encode(toTimestamp(message.acknowledgementTime), writer.uint32(122).fork()).join();
    }
    if (message.exceptionAuditLogLink !== "") {
      writer.uint32(130).string(message.exceptionAuditLogLink);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Violation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViolation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.beginTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.resolveTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.category = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.orgPolicyConstraint = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.auditLogLink = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.nonCompliantOrgPolicy = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.remediation = Violation_Remediation.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.acknowledged = reader.bool();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.acknowledgementTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.exceptionAuditLogLink = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Violation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      beginTime: isSet(object.beginTime) ? fromJsonTimestamp(object.beginTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      resolveTime: isSet(object.resolveTime) ? fromJsonTimestamp(object.resolveTime) : undefined,
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      state: isSet(object.state) ? violation_StateFromJSON(object.state) : 0,
      orgPolicyConstraint: isSet(object.orgPolicyConstraint) ? globalThis.String(object.orgPolicyConstraint) : "",
      auditLogLink: isSet(object.auditLogLink) ? globalThis.String(object.auditLogLink) : "",
      nonCompliantOrgPolicy: isSet(object.nonCompliantOrgPolicy) ? globalThis.String(object.nonCompliantOrgPolicy) : "",
      remediation: isSet(object.remediation) ? Violation_Remediation.fromJSON(object.remediation) : undefined,
      acknowledged: isSet(object.acknowledged) ? globalThis.Boolean(object.acknowledged) : false,
      acknowledgementTime: isSet(object.acknowledgementTime)
        ? fromJsonTimestamp(object.acknowledgementTime)
        : undefined,
      exceptionAuditLogLink: isSet(object.exceptionAuditLogLink) ? globalThis.String(object.exceptionAuditLogLink) : "",
    };
  },

  toJSON(message: Violation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.beginTime !== undefined) {
      obj.beginTime = message.beginTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.resolveTime !== undefined) {
      obj.resolveTime = message.resolveTime.toISOString();
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.state !== 0) {
      obj.state = violation_StateToJSON(message.state);
    }
    if (message.orgPolicyConstraint !== "") {
      obj.orgPolicyConstraint = message.orgPolicyConstraint;
    }
    if (message.auditLogLink !== "") {
      obj.auditLogLink = message.auditLogLink;
    }
    if (message.nonCompliantOrgPolicy !== "") {
      obj.nonCompliantOrgPolicy = message.nonCompliantOrgPolicy;
    }
    if (message.remediation !== undefined) {
      obj.remediation = Violation_Remediation.toJSON(message.remediation);
    }
    if (message.acknowledged !== false) {
      obj.acknowledged = message.acknowledged;
    }
    if (message.acknowledgementTime !== undefined) {
      obj.acknowledgementTime = message.acknowledgementTime.toISOString();
    }
    if (message.exceptionAuditLogLink !== "") {
      obj.exceptionAuditLogLink = message.exceptionAuditLogLink;
    }
    return obj;
  },

  create(base?: DeepPartial<Violation>): Violation {
    return Violation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Violation>): Violation {
    const message = createBaseViolation();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.beginTime = object.beginTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.resolveTime = object.resolveTime ?? undefined;
    message.category = object.category ?? "";
    message.state = object.state ?? 0;
    message.orgPolicyConstraint = object.orgPolicyConstraint ?? "";
    message.auditLogLink = object.auditLogLink ?? "";
    message.nonCompliantOrgPolicy = object.nonCompliantOrgPolicy ?? "";
    message.remediation = (object.remediation !== undefined && object.remediation !== null)
      ? Violation_Remediation.fromPartial(object.remediation)
      : undefined;
    message.acknowledged = object.acknowledged ?? false;
    message.acknowledgementTime = object.acknowledgementTime ?? undefined;
    message.exceptionAuditLogLink = object.exceptionAuditLogLink ?? "";
    return message;
  },
};

function createBaseViolation_Remediation(): Violation_Remediation {
  return { instructions: undefined, compliantValues: [], remediationType: 0 };
}

export const Violation_Remediation: MessageFns<Violation_Remediation> = {
  encode(message: Violation_Remediation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instructions !== undefined) {
      Violation_Remediation_Instructions.encode(message.instructions, writer.uint32(10).fork()).join();
    }
    for (const v of message.compliantValues) {
      writer.uint32(18).string(v!);
    }
    if (message.remediationType !== 0) {
      writer.uint32(24).int32(message.remediationType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Violation_Remediation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViolation_Remediation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.instructions = Violation_Remediation_Instructions.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.compliantValues.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.remediationType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Violation_Remediation {
    return {
      instructions: isSet(object.instructions)
        ? Violation_Remediation_Instructions.fromJSON(object.instructions)
        : undefined,
      compliantValues: globalThis.Array.isArray(object?.compliantValues)
        ? object.compliantValues.map((e: any) => globalThis.String(e))
        : [],
      remediationType: isSet(object.remediationType)
        ? violation_Remediation_RemediationTypeFromJSON(object.remediationType)
        : 0,
    };
  },

  toJSON(message: Violation_Remediation): unknown {
    const obj: any = {};
    if (message.instructions !== undefined) {
      obj.instructions = Violation_Remediation_Instructions.toJSON(message.instructions);
    }
    if (message.compliantValues?.length) {
      obj.compliantValues = message.compliantValues;
    }
    if (message.remediationType !== 0) {
      obj.remediationType = violation_Remediation_RemediationTypeToJSON(message.remediationType);
    }
    return obj;
  },

  create(base?: DeepPartial<Violation_Remediation>): Violation_Remediation {
    return Violation_Remediation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Violation_Remediation>): Violation_Remediation {
    const message = createBaseViolation_Remediation();
    message.instructions = (object.instructions !== undefined && object.instructions !== null)
      ? Violation_Remediation_Instructions.fromPartial(object.instructions)
      : undefined;
    message.compliantValues = object.compliantValues?.map((e) => e) || [];
    message.remediationType = object.remediationType ?? 0;
    return message;
  },
};

function createBaseViolation_Remediation_Instructions(): Violation_Remediation_Instructions {
  return { gcloudInstructions: undefined, consoleInstructions: undefined };
}

export const Violation_Remediation_Instructions: MessageFns<Violation_Remediation_Instructions> = {
  encode(message: Violation_Remediation_Instructions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcloudInstructions !== undefined) {
      Violation_Remediation_Instructions_Gcloud.encode(message.gcloudInstructions, writer.uint32(10).fork()).join();
    }
    if (message.consoleInstructions !== undefined) {
      Violation_Remediation_Instructions_Console.encode(message.consoleInstructions, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Violation_Remediation_Instructions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViolation_Remediation_Instructions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcloudInstructions = Violation_Remediation_Instructions_Gcloud.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.consoleInstructions = Violation_Remediation_Instructions_Console.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Violation_Remediation_Instructions {
    return {
      gcloudInstructions: isSet(object.gcloudInstructions)
        ? Violation_Remediation_Instructions_Gcloud.fromJSON(object.gcloudInstructions)
        : undefined,
      consoleInstructions: isSet(object.consoleInstructions)
        ? Violation_Remediation_Instructions_Console.fromJSON(object.consoleInstructions)
        : undefined,
    };
  },

  toJSON(message: Violation_Remediation_Instructions): unknown {
    const obj: any = {};
    if (message.gcloudInstructions !== undefined) {
      obj.gcloudInstructions = Violation_Remediation_Instructions_Gcloud.toJSON(message.gcloudInstructions);
    }
    if (message.consoleInstructions !== undefined) {
      obj.consoleInstructions = Violation_Remediation_Instructions_Console.toJSON(message.consoleInstructions);
    }
    return obj;
  },

  create(base?: DeepPartial<Violation_Remediation_Instructions>): Violation_Remediation_Instructions {
    return Violation_Remediation_Instructions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Violation_Remediation_Instructions>): Violation_Remediation_Instructions {
    const message = createBaseViolation_Remediation_Instructions();
    message.gcloudInstructions = (object.gcloudInstructions !== undefined && object.gcloudInstructions !== null)
      ? Violation_Remediation_Instructions_Gcloud.fromPartial(object.gcloudInstructions)
      : undefined;
    message.consoleInstructions = (object.consoleInstructions !== undefined && object.consoleInstructions !== null)
      ? Violation_Remediation_Instructions_Console.fromPartial(object.consoleInstructions)
      : undefined;
    return message;
  },
};

function createBaseViolation_Remediation_Instructions_Gcloud(): Violation_Remediation_Instructions_Gcloud {
  return { gcloudCommands: [], steps: [], additionalLinks: [] };
}

export const Violation_Remediation_Instructions_Gcloud: MessageFns<Violation_Remediation_Instructions_Gcloud> = {
  encode(message: Violation_Remediation_Instructions_Gcloud, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.gcloudCommands) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.steps) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.additionalLinks) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Violation_Remediation_Instructions_Gcloud {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViolation_Remediation_Instructions_Gcloud();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcloudCommands.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.steps.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.additionalLinks.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Violation_Remediation_Instructions_Gcloud {
    return {
      gcloudCommands: globalThis.Array.isArray(object?.gcloudCommands)
        ? object.gcloudCommands.map((e: any) => globalThis.String(e))
        : [],
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => globalThis.String(e)) : [],
      additionalLinks: globalThis.Array.isArray(object?.additionalLinks)
        ? object.additionalLinks.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Violation_Remediation_Instructions_Gcloud): unknown {
    const obj: any = {};
    if (message.gcloudCommands?.length) {
      obj.gcloudCommands = message.gcloudCommands;
    }
    if (message.steps?.length) {
      obj.steps = message.steps;
    }
    if (message.additionalLinks?.length) {
      obj.additionalLinks = message.additionalLinks;
    }
    return obj;
  },

  create(base?: DeepPartial<Violation_Remediation_Instructions_Gcloud>): Violation_Remediation_Instructions_Gcloud {
    return Violation_Remediation_Instructions_Gcloud.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Violation_Remediation_Instructions_Gcloud>,
  ): Violation_Remediation_Instructions_Gcloud {
    const message = createBaseViolation_Remediation_Instructions_Gcloud();
    message.gcloudCommands = object.gcloudCommands?.map((e) => e) || [];
    message.steps = object.steps?.map((e) => e) || [];
    message.additionalLinks = object.additionalLinks?.map((e) => e) || [];
    return message;
  },
};

function createBaseViolation_Remediation_Instructions_Console(): Violation_Remediation_Instructions_Console {
  return { consoleUris: [], steps: [], additionalLinks: [] };
}

export const Violation_Remediation_Instructions_Console: MessageFns<Violation_Remediation_Instructions_Console> = {
  encode(message: Violation_Remediation_Instructions_Console, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.consoleUris) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.steps) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.additionalLinks) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Violation_Remediation_Instructions_Console {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViolation_Remediation_Instructions_Console();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.consoleUris.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.steps.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.additionalLinks.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Violation_Remediation_Instructions_Console {
    return {
      consoleUris: globalThis.Array.isArray(object?.consoleUris)
        ? object.consoleUris.map((e: any) => globalThis.String(e))
        : [],
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => globalThis.String(e)) : [],
      additionalLinks: globalThis.Array.isArray(object?.additionalLinks)
        ? object.additionalLinks.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Violation_Remediation_Instructions_Console): unknown {
    const obj: any = {};
    if (message.consoleUris?.length) {
      obj.consoleUris = message.consoleUris;
    }
    if (message.steps?.length) {
      obj.steps = message.steps;
    }
    if (message.additionalLinks?.length) {
      obj.additionalLinks = message.additionalLinks;
    }
    return obj;
  },

  create(base?: DeepPartial<Violation_Remediation_Instructions_Console>): Violation_Remediation_Instructions_Console {
    return Violation_Remediation_Instructions_Console.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Violation_Remediation_Instructions_Console>,
  ): Violation_Remediation_Instructions_Console {
    const message = createBaseViolation_Remediation_Instructions_Console();
    message.consoleUris = object.consoleUris?.map((e) => e) || [];
    message.steps = object.steps?.map((e) => e) || [];
    message.additionalLinks = object.additionalLinks?.map((e) => e) || [];
    return message;
  },
};

/** Service to manage AssuredWorkloads. */
export type AssuredWorkloadsServiceDefinition = typeof AssuredWorkloadsServiceDefinition;
export const AssuredWorkloadsServiceDefinition = {
  name: "AssuredWorkloadsService",
  fullName: "google.cloud.assuredworkloads.v1.AssuredWorkloadsService",
  methods: {
    /** Creates Assured Workload. */
    createWorkload: {
      name: "CreateWorkload",
      requestType: CreateWorkloadRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              43,
              10,
              8,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              18,
              31,
              67,
              114,
              101,
              97,
              116,
              101,
              87,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([15, 112, 97, 114, 101, 110, 116, 44, 119, 111, 114, 107, 108, 111, 97, 100])],
          578365826: [
            Buffer.from([
              62,
              58,
              8,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              34,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an existing workload.
     * Currently allows updating of workload display_name and labels.
     * For force updates don't set etag field in the Workload.
     * Only one update operation per workload can be in progress.
     */
    updateWorkload: {
      name: "UpdateWorkload",
      requestType: UpdateWorkloadRequest,
      requestStream: false,
      responseType: Workload,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              8,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              50,
              59,
              47,
              118,
              49,
              47,
              123,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              46,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Restrict the list of resources allowed in the Workload environment.
     * The current list of allowed products can be found at
     * https://cloud.google.com/assured-workloads/docs/supported-products
     * In addition to assuredworkloads.workload.update permission, the user should
     * also have orgpolicy.policy.set permission on the folder resource
     * to use this functionality.
     */
    restrictAllowedResources: {
      name: "RestrictAllowedResources",
      requestType: RestrictAllowedResourcesRequest,
      requestStream: false,
      responseType: RestrictAllowedResourcesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              80,
              58,
              1,
              42,
              34,
              75,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              116,
              114,
              105,
              99,
              116,
              65,
              108,
              108,
              111,
              119,
              101,
              100,
              82,
              101,
              115,
              111,
              117,
              114,
              99,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the workload. Make sure that workload's direct children are already
     * in a deleted state, otherwise the request will fail with a
     * FAILED_PRECONDITION error.
     */
    deleteWorkload: {
      name: "DeleteWorkload",
      requestType: DeleteWorkloadRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              42,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Gets Assured Workload associated with a CRM Node */
    getWorkload: {
      name: "GetWorkload",
      requestType: GetWorkloadRequest,
      requestStream: false,
      responseType: Workload,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists Assured Workloads under a CRM Node. */
    listWorkloads: {
      name: "ListWorkloads",
      requestType: ListWorkloadsRequest,
      requestStream: false,
      responseType: ListWorkloadsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              52,
              18,
              50,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              111,
              114,
              103,
              97,
              110,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              119,
              111,
              114,
              107,
              108,
              111,
              97,
              100,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists the Violations in the AssuredWorkload Environment.
     * Callers may also choose to read across multiple Workloads as per
     * [AIP-159](https://google.aip.dev/159) by using '-' (the hyphen or dash
     * character) as a wildcard character instead of workload-id in the parent.
     * Format `organizations/{org_id}/locations/{location}/workloads/-`
     */
    listViolations: {
      name: "ListViolations",
      requestType: ListViolationsRequest,
      requestStream: false,
      responseType: ListViolationsResponse,
      responseStream: false,
      options: { _unknownFields: { 8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])] } },
    },
    /** Retrieves Assured Workload Violation based on ID. */
    getViolation: {
      name: "GetViolation",
      requestType: GetViolationRequest,
      requestStream: false,
      responseType: Violation,
      responseStream: false,
      options: { _unknownFields: { 8410: [Buffer.from([4, 110, 97, 109, 101])] } },
    },
    /**
     * Acknowledges an existing violation. By acknowledging a violation, users
     * acknowledge the existence of a compliance violation in their workload and
     * decide to ignore it due to a valid business justification. Acknowledgement
     * is a permanent operation and it cannot be reverted.
     */
    acknowledgeViolation: {
      name: "AcknowledgeViolation",
      requestType: AcknowledgeViolationRequest,
      requestStream: false,
      responseType: AcknowledgeViolationResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface AssuredWorkloadsServiceImplementation<CallContextExt = {}> {
  /** Creates Assured Workload. */
  createWorkload(
    request: CreateWorkloadRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates an existing workload.
   * Currently allows updating of workload display_name and labels.
   * For force updates don't set etag field in the Workload.
   * Only one update operation per workload can be in progress.
   */
  updateWorkload(request: UpdateWorkloadRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Workload>>;
  /**
   * Restrict the list of resources allowed in the Workload environment.
   * The current list of allowed products can be found at
   * https://cloud.google.com/assured-workloads/docs/supported-products
   * In addition to assuredworkloads.workload.update permission, the user should
   * also have orgpolicy.policy.set permission on the folder resource
   * to use this functionality.
   */
  restrictAllowedResources(
    request: RestrictAllowedResourcesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RestrictAllowedResourcesResponse>>;
  /**
   * Deletes the workload. Make sure that workload's direct children are already
   * in a deleted state, otherwise the request will fail with a
   * FAILED_PRECONDITION error.
   */
  deleteWorkload(request: DeleteWorkloadRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Gets Assured Workload associated with a CRM Node */
  getWorkload(request: GetWorkloadRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Workload>>;
  /** Lists Assured Workloads under a CRM Node. */
  listWorkloads(
    request: ListWorkloadsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListWorkloadsResponse>>;
  /**
   * Lists the Violations in the AssuredWorkload Environment.
   * Callers may also choose to read across multiple Workloads as per
   * [AIP-159](https://google.aip.dev/159) by using '-' (the hyphen or dash
   * character) as a wildcard character instead of workload-id in the parent.
   * Format `organizations/{org_id}/locations/{location}/workloads/-`
   */
  listViolations(
    request: ListViolationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListViolationsResponse>>;
  /** Retrieves Assured Workload Violation based on ID. */
  getViolation(request: GetViolationRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Violation>>;
  /**
   * Acknowledges an existing violation. By acknowledging a violation, users
   * acknowledge the existence of a compliance violation in their workload and
   * decide to ignore it due to a valid business justification. Acknowledgement
   * is a permanent operation and it cannot be reverted.
   */
  acknowledgeViolation(
    request: AcknowledgeViolationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AcknowledgeViolationResponse>>;
}

export interface AssuredWorkloadsServiceClient<CallOptionsExt = {}> {
  /** Creates Assured Workload. */
  createWorkload(
    request: DeepPartial<CreateWorkloadRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates an existing workload.
   * Currently allows updating of workload display_name and labels.
   * For force updates don't set etag field in the Workload.
   * Only one update operation per workload can be in progress.
   */
  updateWorkload(
    request: DeepPartial<UpdateWorkloadRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Workload>;
  /**
   * Restrict the list of resources allowed in the Workload environment.
   * The current list of allowed products can be found at
   * https://cloud.google.com/assured-workloads/docs/supported-products
   * In addition to assuredworkloads.workload.update permission, the user should
   * also have orgpolicy.policy.set permission on the folder resource
   * to use this functionality.
   */
  restrictAllowedResources(
    request: DeepPartial<RestrictAllowedResourcesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RestrictAllowedResourcesResponse>;
  /**
   * Deletes the workload. Make sure that workload's direct children are already
   * in a deleted state, otherwise the request will fail with a
   * FAILED_PRECONDITION error.
   */
  deleteWorkload(request: DeepPartial<DeleteWorkloadRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Gets Assured Workload associated with a CRM Node */
  getWorkload(request: DeepPartial<GetWorkloadRequest>, options?: CallOptions & CallOptionsExt): Promise<Workload>;
  /** Lists Assured Workloads under a CRM Node. */
  listWorkloads(
    request: DeepPartial<ListWorkloadsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListWorkloadsResponse>;
  /**
   * Lists the Violations in the AssuredWorkload Environment.
   * Callers may also choose to read across multiple Workloads as per
   * [AIP-159](https://google.aip.dev/159) by using '-' (the hyphen or dash
   * character) as a wildcard character instead of workload-id in the parent.
   * Format `organizations/{org_id}/locations/{location}/workloads/-`
   */
  listViolations(
    request: DeepPartial<ListViolationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListViolationsResponse>;
  /** Retrieves Assured Workload Violation based on ID. */
  getViolation(request: DeepPartial<GetViolationRequest>, options?: CallOptions & CallOptionsExt): Promise<Violation>;
  /**
   * Acknowledges an existing violation. By acknowledging a violation, users
   * acknowledge the existence of a compliance violation in their workload and
   * decide to ignore it due to a valid business justification. Acknowledgement
   * is a permanent operation and it cannot be reverted.
   */
  acknowledgeViolation(
    request: DeepPartial<AcknowledgeViolationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AcknowledgeViolationResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
