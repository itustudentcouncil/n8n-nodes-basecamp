// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/websecurityscanner/v1alpha/scan_config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { ScanRun } from "./scan_run.js";

export const protobufPackage = "google.cloud.websecurityscanner.v1alpha";

/**
 * A ScanConfig resource contains the configurations to launch a scan.
 * next id: 12
 */
export interface ScanConfig {
  /**
   * The resource name of the ScanConfig. The name follows the format of
   * 'projects/{projectId}/scanConfigs/{scanConfigId}'. The ScanConfig IDs are
   * generated by the system.
   */
  name: string;
  /** Required. The user provided display name of the ScanConfig. */
  displayName: string;
  /**
   * The maximum QPS during scanning. A valid value ranges from 5 to 20
   * inclusively. If the field is unspecified or its value is set 0, server will
   * default to 15. Other values outside of [5, 20] range will be rejected with
   * INVALID_ARGUMENT error.
   */
  maxQps: number;
  /** Required. The starting URLs from which the scanner finds site pages. */
  startingUrls: string[];
  /**
   * The authentication configuration. If specified, service will use the
   * authentication configuration during scanning.
   */
  authentication:
    | ScanConfig_Authentication
    | undefined;
  /** The user agent used during scanning. */
  userAgent: ScanConfig_UserAgent;
  /**
   * The blacklist URL patterns as described in
   * https://cloud.google.com/security-scanner/docs/excluded-urls
   */
  blacklistPatterns: string[];
  /** The schedule of the ScanConfig. */
  schedule:
    | ScanConfig_Schedule
    | undefined;
  /**
   * Set of Cloud Platforms targeted by the scan. If empty, APP_ENGINE will be
   * used as a default.
   */
  targetPlatforms: ScanConfig_TargetPlatform[];
  /** Latest ScanRun if available. */
  latestRun: ScanRun | undefined;
}

/** Type of user agents used for scanning. */
export enum ScanConfig_UserAgent {
  /** USER_AGENT_UNSPECIFIED - The user agent is unknown. Service will default to CHROME_LINUX. */
  USER_AGENT_UNSPECIFIED = 0,
  /** CHROME_LINUX - Chrome on Linux. This is the service default if unspecified. */
  CHROME_LINUX = 1,
  /** CHROME_ANDROID - Chrome on Android. */
  CHROME_ANDROID = 2,
  /** SAFARI_IPHONE - Safari on IPhone. */
  SAFARI_IPHONE = 3,
  UNRECOGNIZED = -1,
}

export function scanConfig_UserAgentFromJSON(object: any): ScanConfig_UserAgent {
  switch (object) {
    case 0:
    case "USER_AGENT_UNSPECIFIED":
      return ScanConfig_UserAgent.USER_AGENT_UNSPECIFIED;
    case 1:
    case "CHROME_LINUX":
      return ScanConfig_UserAgent.CHROME_LINUX;
    case 2:
    case "CHROME_ANDROID":
      return ScanConfig_UserAgent.CHROME_ANDROID;
    case 3:
    case "SAFARI_IPHONE":
      return ScanConfig_UserAgent.SAFARI_IPHONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScanConfig_UserAgent.UNRECOGNIZED;
  }
}

export function scanConfig_UserAgentToJSON(object: ScanConfig_UserAgent): string {
  switch (object) {
    case ScanConfig_UserAgent.USER_AGENT_UNSPECIFIED:
      return "USER_AGENT_UNSPECIFIED";
    case ScanConfig_UserAgent.CHROME_LINUX:
      return "CHROME_LINUX";
    case ScanConfig_UserAgent.CHROME_ANDROID:
      return "CHROME_ANDROID";
    case ScanConfig_UserAgent.SAFARI_IPHONE:
      return "SAFARI_IPHONE";
    case ScanConfig_UserAgent.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Cloud platforms supported by Cloud Web Security Scanner. */
export enum ScanConfig_TargetPlatform {
  /**
   * TARGET_PLATFORM_UNSPECIFIED - The target platform is unknown. Requests with this enum value will be
   * rejected with INVALID_ARGUMENT error.
   */
  TARGET_PLATFORM_UNSPECIFIED = 0,
  /** APP_ENGINE - Google App Engine service. */
  APP_ENGINE = 1,
  /** COMPUTE - Google Compute Engine service. */
  COMPUTE = 2,
  UNRECOGNIZED = -1,
}

export function scanConfig_TargetPlatformFromJSON(object: any): ScanConfig_TargetPlatform {
  switch (object) {
    case 0:
    case "TARGET_PLATFORM_UNSPECIFIED":
      return ScanConfig_TargetPlatform.TARGET_PLATFORM_UNSPECIFIED;
    case 1:
    case "APP_ENGINE":
      return ScanConfig_TargetPlatform.APP_ENGINE;
    case 2:
    case "COMPUTE":
      return ScanConfig_TargetPlatform.COMPUTE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScanConfig_TargetPlatform.UNRECOGNIZED;
  }
}

export function scanConfig_TargetPlatformToJSON(object: ScanConfig_TargetPlatform): string {
  switch (object) {
    case ScanConfig_TargetPlatform.TARGET_PLATFORM_UNSPECIFIED:
      return "TARGET_PLATFORM_UNSPECIFIED";
    case ScanConfig_TargetPlatform.APP_ENGINE:
      return "APP_ENGINE";
    case ScanConfig_TargetPlatform.COMPUTE:
      return "COMPUTE";
    case ScanConfig_TargetPlatform.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Scan authentication configuration. */
export interface ScanConfig_Authentication {
  /** Authentication using a Google account. */
  googleAccount?:
    | ScanConfig_Authentication_GoogleAccount
    | undefined;
  /** Authentication using a custom account. */
  customAccount?: ScanConfig_Authentication_CustomAccount | undefined;
}

/** Describes authentication configuration that uses a Google account. */
export interface ScanConfig_Authentication_GoogleAccount {
  /** Required. The user name of the Google account. */
  username: string;
  /**
   * Required. Input only. The password of the Google account. The credential is stored encrypted
   * and not returned in any response nor included in audit logs.
   */
  password: string;
}

/** Describes authentication configuration that uses a custom account. */
export interface ScanConfig_Authentication_CustomAccount {
  /** Required. The user name of the custom account. */
  username: string;
  /**
   * Required. Input only. The password of the custom account. The credential is stored encrypted
   * and not returned in any response nor included in audit logs.
   */
  password: string;
  /** Required. The login form URL of the website. */
  loginUrl: string;
}

/** Scan schedule configuration. */
export interface ScanConfig_Schedule {
  /**
   * A timestamp indicates when the next run will be scheduled. The value is
   * refreshed by the server after each run. If unspecified, it will default
   * to current server time, which means the scan will be scheduled to start
   * immediately.
   */
  scheduleTime:
    | Date
    | undefined;
  /** Required. The duration of time between executions in days. */
  intervalDurationDays: number;
}

function createBaseScanConfig(): ScanConfig {
  return {
    name: "",
    displayName: "",
    maxQps: 0,
    startingUrls: [],
    authentication: undefined,
    userAgent: 0,
    blacklistPatterns: [],
    schedule: undefined,
    targetPlatforms: [],
    latestRun: undefined,
  };
}

export const ScanConfig: MessageFns<ScanConfig> = {
  encode(message: ScanConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.maxQps !== 0) {
      writer.uint32(24).int32(message.maxQps);
    }
    for (const v of message.startingUrls) {
      writer.uint32(34).string(v!);
    }
    if (message.authentication !== undefined) {
      ScanConfig_Authentication.encode(message.authentication, writer.uint32(42).fork()).join();
    }
    if (message.userAgent !== 0) {
      writer.uint32(48).int32(message.userAgent);
    }
    for (const v of message.blacklistPatterns) {
      writer.uint32(58).string(v!);
    }
    if (message.schedule !== undefined) {
      ScanConfig_Schedule.encode(message.schedule, writer.uint32(66).fork()).join();
    }
    writer.uint32(74).fork();
    for (const v of message.targetPlatforms) {
      writer.int32(v);
    }
    writer.join();
    if (message.latestRun !== undefined) {
      ScanRun.encode(message.latestRun, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScanConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScanConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxQps = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.startingUrls.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authentication = ScanConfig_Authentication.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.userAgent = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.blacklistPatterns.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.schedule = ScanConfig_Schedule.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag === 72) {
            message.targetPlatforms.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.targetPlatforms.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.latestRun = ScanRun.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScanConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      maxQps: isSet(object.maxQps) ? globalThis.Number(object.maxQps) : 0,
      startingUrls: globalThis.Array.isArray(object?.startingUrls)
        ? object.startingUrls.map((e: any) => globalThis.String(e))
        : [],
      authentication: isSet(object.authentication)
        ? ScanConfig_Authentication.fromJSON(object.authentication)
        : undefined,
      userAgent: isSet(object.userAgent) ? scanConfig_UserAgentFromJSON(object.userAgent) : 0,
      blacklistPatterns: globalThis.Array.isArray(object?.blacklistPatterns)
        ? object.blacklistPatterns.map((e: any) => globalThis.String(e))
        : [],
      schedule: isSet(object.schedule) ? ScanConfig_Schedule.fromJSON(object.schedule) : undefined,
      targetPlatforms: globalThis.Array.isArray(object?.targetPlatforms)
        ? object.targetPlatforms.map((e: any) => scanConfig_TargetPlatformFromJSON(e))
        : [],
      latestRun: isSet(object.latestRun) ? ScanRun.fromJSON(object.latestRun) : undefined,
    };
  },

  toJSON(message: ScanConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.maxQps !== 0) {
      obj.maxQps = Math.round(message.maxQps);
    }
    if (message.startingUrls?.length) {
      obj.startingUrls = message.startingUrls;
    }
    if (message.authentication !== undefined) {
      obj.authentication = ScanConfig_Authentication.toJSON(message.authentication);
    }
    if (message.userAgent !== 0) {
      obj.userAgent = scanConfig_UserAgentToJSON(message.userAgent);
    }
    if (message.blacklistPatterns?.length) {
      obj.blacklistPatterns = message.blacklistPatterns;
    }
    if (message.schedule !== undefined) {
      obj.schedule = ScanConfig_Schedule.toJSON(message.schedule);
    }
    if (message.targetPlatforms?.length) {
      obj.targetPlatforms = message.targetPlatforms.map((e) => scanConfig_TargetPlatformToJSON(e));
    }
    if (message.latestRun !== undefined) {
      obj.latestRun = ScanRun.toJSON(message.latestRun);
    }
    return obj;
  },

  create(base?: DeepPartial<ScanConfig>): ScanConfig {
    return ScanConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScanConfig>): ScanConfig {
    const message = createBaseScanConfig();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.maxQps = object.maxQps ?? 0;
    message.startingUrls = object.startingUrls?.map((e) => e) || [];
    message.authentication = (object.authentication !== undefined && object.authentication !== null)
      ? ScanConfig_Authentication.fromPartial(object.authentication)
      : undefined;
    message.userAgent = object.userAgent ?? 0;
    message.blacklistPatterns = object.blacklistPatterns?.map((e) => e) || [];
    message.schedule = (object.schedule !== undefined && object.schedule !== null)
      ? ScanConfig_Schedule.fromPartial(object.schedule)
      : undefined;
    message.targetPlatforms = object.targetPlatforms?.map((e) => e) || [];
    message.latestRun = (object.latestRun !== undefined && object.latestRun !== null)
      ? ScanRun.fromPartial(object.latestRun)
      : undefined;
    return message;
  },
};

function createBaseScanConfig_Authentication(): ScanConfig_Authentication {
  return { googleAccount: undefined, customAccount: undefined };
}

export const ScanConfig_Authentication: MessageFns<ScanConfig_Authentication> = {
  encode(message: ScanConfig_Authentication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.googleAccount !== undefined) {
      ScanConfig_Authentication_GoogleAccount.encode(message.googleAccount, writer.uint32(10).fork()).join();
    }
    if (message.customAccount !== undefined) {
      ScanConfig_Authentication_CustomAccount.encode(message.customAccount, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScanConfig_Authentication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScanConfig_Authentication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.googleAccount = ScanConfig_Authentication_GoogleAccount.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customAccount = ScanConfig_Authentication_CustomAccount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScanConfig_Authentication {
    return {
      googleAccount: isSet(object.googleAccount)
        ? ScanConfig_Authentication_GoogleAccount.fromJSON(object.googleAccount)
        : undefined,
      customAccount: isSet(object.customAccount)
        ? ScanConfig_Authentication_CustomAccount.fromJSON(object.customAccount)
        : undefined,
    };
  },

  toJSON(message: ScanConfig_Authentication): unknown {
    const obj: any = {};
    if (message.googleAccount !== undefined) {
      obj.googleAccount = ScanConfig_Authentication_GoogleAccount.toJSON(message.googleAccount);
    }
    if (message.customAccount !== undefined) {
      obj.customAccount = ScanConfig_Authentication_CustomAccount.toJSON(message.customAccount);
    }
    return obj;
  },

  create(base?: DeepPartial<ScanConfig_Authentication>): ScanConfig_Authentication {
    return ScanConfig_Authentication.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScanConfig_Authentication>): ScanConfig_Authentication {
    const message = createBaseScanConfig_Authentication();
    message.googleAccount = (object.googleAccount !== undefined && object.googleAccount !== null)
      ? ScanConfig_Authentication_GoogleAccount.fromPartial(object.googleAccount)
      : undefined;
    message.customAccount = (object.customAccount !== undefined && object.customAccount !== null)
      ? ScanConfig_Authentication_CustomAccount.fromPartial(object.customAccount)
      : undefined;
    return message;
  },
};

function createBaseScanConfig_Authentication_GoogleAccount(): ScanConfig_Authentication_GoogleAccount {
  return { username: "", password: "" };
}

export const ScanConfig_Authentication_GoogleAccount: MessageFns<ScanConfig_Authentication_GoogleAccount> = {
  encode(message: ScanConfig_Authentication_GoogleAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScanConfig_Authentication_GoogleAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScanConfig_Authentication_GoogleAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScanConfig_Authentication_GoogleAccount {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: ScanConfig_Authentication_GoogleAccount): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create(base?: DeepPartial<ScanConfig_Authentication_GoogleAccount>): ScanConfig_Authentication_GoogleAccount {
    return ScanConfig_Authentication_GoogleAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScanConfig_Authentication_GoogleAccount>): ScanConfig_Authentication_GoogleAccount {
    const message = createBaseScanConfig_Authentication_GoogleAccount();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseScanConfig_Authentication_CustomAccount(): ScanConfig_Authentication_CustomAccount {
  return { username: "", password: "", loginUrl: "" };
}

export const ScanConfig_Authentication_CustomAccount: MessageFns<ScanConfig_Authentication_CustomAccount> = {
  encode(message: ScanConfig_Authentication_CustomAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.loginUrl !== "") {
      writer.uint32(26).string(message.loginUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScanConfig_Authentication_CustomAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScanConfig_Authentication_CustomAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.loginUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScanConfig_Authentication_CustomAccount {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      loginUrl: isSet(object.loginUrl) ? globalThis.String(object.loginUrl) : "",
    };
  },

  toJSON(message: ScanConfig_Authentication_CustomAccount): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.loginUrl !== "") {
      obj.loginUrl = message.loginUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<ScanConfig_Authentication_CustomAccount>): ScanConfig_Authentication_CustomAccount {
    return ScanConfig_Authentication_CustomAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScanConfig_Authentication_CustomAccount>): ScanConfig_Authentication_CustomAccount {
    const message = createBaseScanConfig_Authentication_CustomAccount();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.loginUrl = object.loginUrl ?? "";
    return message;
  },
};

function createBaseScanConfig_Schedule(): ScanConfig_Schedule {
  return { scheduleTime: undefined, intervalDurationDays: 0 };
}

export const ScanConfig_Schedule: MessageFns<ScanConfig_Schedule> = {
  encode(message: ScanConfig_Schedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduleTime !== undefined) {
      Timestamp.encode(toTimestamp(message.scheduleTime), writer.uint32(10).fork()).join();
    }
    if (message.intervalDurationDays !== 0) {
      writer.uint32(16).int32(message.intervalDurationDays);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScanConfig_Schedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScanConfig_Schedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scheduleTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.intervalDurationDays = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScanConfig_Schedule {
    return {
      scheduleTime: isSet(object.scheduleTime) ? fromJsonTimestamp(object.scheduleTime) : undefined,
      intervalDurationDays: isSet(object.intervalDurationDays) ? globalThis.Number(object.intervalDurationDays) : 0,
    };
  },

  toJSON(message: ScanConfig_Schedule): unknown {
    const obj: any = {};
    if (message.scheduleTime !== undefined) {
      obj.scheduleTime = message.scheduleTime.toISOString();
    }
    if (message.intervalDurationDays !== 0) {
      obj.intervalDurationDays = Math.round(message.intervalDurationDays);
    }
    return obj;
  },

  create(base?: DeepPartial<ScanConfig_Schedule>): ScanConfig_Schedule {
    return ScanConfig_Schedule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ScanConfig_Schedule>): ScanConfig_Schedule {
    const message = createBaseScanConfig_Schedule();
    message.scheduleTime = object.scheduleTime ?? undefined;
    message.intervalDurationDays = object.intervalDurationDays ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
