// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/websecurityscanner/v1alpha/finding_addon.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.websecurityscanner.v1alpha";

/** Information reported for an outdated library. */
export interface OutdatedLibrary {
  /** The name of the outdated library. */
  libraryName: string;
  /** The version number. */
  version: string;
  /** URLs to learn more information about the vulnerabilities in the library. */
  learnMoreUrls: string[];
}

/**
 * Information regarding any resource causing the vulnerability such
 * as JavaScript sources, image, audio files, etc.
 */
export interface ViolatingResource {
  /** The MIME type of this resource. */
  contentType: string;
  /** URL of this violating resource. */
  resourceUrl: string;
}

/** Information about vulnerable request parameters. */
export interface VulnerableParameters {
  /** The vulnerable parameter names. */
  parameterNames: string[];
}

/** Information about vulnerable or missing HTTP Headers. */
export interface VulnerableHeaders {
  /** List of vulnerable headers. */
  headers: VulnerableHeaders_Header[];
  /** List of missing headers. */
  missingHeaders: VulnerableHeaders_Header[];
}

/** Describes a HTTP Header. */
export interface VulnerableHeaders_Header {
  /** Header name. */
  name: string;
  /** Header value. */
  value: string;
}

/** Information reported for an XSS. */
export interface Xss {
  /** Stack traces leading to the point where the XSS occurred. */
  stackTraces: string[];
  /** An error message generated by a javascript breakage. */
  errorMessage: string;
}

function createBaseOutdatedLibrary(): OutdatedLibrary {
  return { libraryName: "", version: "", learnMoreUrls: [] };
}

export const OutdatedLibrary: MessageFns<OutdatedLibrary> = {
  encode(message: OutdatedLibrary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.libraryName !== "") {
      writer.uint32(10).string(message.libraryName);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    for (const v of message.learnMoreUrls) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutdatedLibrary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutdatedLibrary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.libraryName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.learnMoreUrls.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutdatedLibrary {
    return {
      libraryName: isSet(object.libraryName) ? globalThis.String(object.libraryName) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      learnMoreUrls: globalThis.Array.isArray(object?.learnMoreUrls)
        ? object.learnMoreUrls.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: OutdatedLibrary): unknown {
    const obj: any = {};
    if (message.libraryName !== "") {
      obj.libraryName = message.libraryName;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.learnMoreUrls?.length) {
      obj.learnMoreUrls = message.learnMoreUrls;
    }
    return obj;
  },

  create(base?: DeepPartial<OutdatedLibrary>): OutdatedLibrary {
    return OutdatedLibrary.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OutdatedLibrary>): OutdatedLibrary {
    const message = createBaseOutdatedLibrary();
    message.libraryName = object.libraryName ?? "";
    message.version = object.version ?? "";
    message.learnMoreUrls = object.learnMoreUrls?.map((e) => e) || [];
    return message;
  },
};

function createBaseViolatingResource(): ViolatingResource {
  return { contentType: "", resourceUrl: "" };
}

export const ViolatingResource: MessageFns<ViolatingResource> = {
  encode(message: ViolatingResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentType !== "") {
      writer.uint32(10).string(message.contentType);
    }
    if (message.resourceUrl !== "") {
      writer.uint32(18).string(message.resourceUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViolatingResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViolatingResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contentType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceUrl = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViolatingResource {
    return {
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      resourceUrl: isSet(object.resourceUrl) ? globalThis.String(object.resourceUrl) : "",
    };
  },

  toJSON(message: ViolatingResource): unknown {
    const obj: any = {};
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.resourceUrl !== "") {
      obj.resourceUrl = message.resourceUrl;
    }
    return obj;
  },

  create(base?: DeepPartial<ViolatingResource>): ViolatingResource {
    return ViolatingResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ViolatingResource>): ViolatingResource {
    const message = createBaseViolatingResource();
    message.contentType = object.contentType ?? "";
    message.resourceUrl = object.resourceUrl ?? "";
    return message;
  },
};

function createBaseVulnerableParameters(): VulnerableParameters {
  return { parameterNames: [] };
}

export const VulnerableParameters: MessageFns<VulnerableParameters> = {
  encode(message: VulnerableParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.parameterNames) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerableParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerableParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parameterNames.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerableParameters {
    return {
      parameterNames: globalThis.Array.isArray(object?.parameterNames)
        ? object.parameterNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: VulnerableParameters): unknown {
    const obj: any = {};
    if (message.parameterNames?.length) {
      obj.parameterNames = message.parameterNames;
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerableParameters>): VulnerableParameters {
    return VulnerableParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerableParameters>): VulnerableParameters {
    const message = createBaseVulnerableParameters();
    message.parameterNames = object.parameterNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseVulnerableHeaders(): VulnerableHeaders {
  return { headers: [], missingHeaders: [] };
}

export const VulnerableHeaders: MessageFns<VulnerableHeaders> = {
  encode(message: VulnerableHeaders, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.headers) {
      VulnerableHeaders_Header.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.missingHeaders) {
      VulnerableHeaders_Header.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerableHeaders {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerableHeaders();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.headers.push(VulnerableHeaders_Header.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.missingHeaders.push(VulnerableHeaders_Header.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerableHeaders {
    return {
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => VulnerableHeaders_Header.fromJSON(e))
        : [],
      missingHeaders: globalThis.Array.isArray(object?.missingHeaders)
        ? object.missingHeaders.map((e: any) => VulnerableHeaders_Header.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VulnerableHeaders): unknown {
    const obj: any = {};
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => VulnerableHeaders_Header.toJSON(e));
    }
    if (message.missingHeaders?.length) {
      obj.missingHeaders = message.missingHeaders.map((e) => VulnerableHeaders_Header.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerableHeaders>): VulnerableHeaders {
    return VulnerableHeaders.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerableHeaders>): VulnerableHeaders {
    const message = createBaseVulnerableHeaders();
    message.headers = object.headers?.map((e) => VulnerableHeaders_Header.fromPartial(e)) || [];
    message.missingHeaders = object.missingHeaders?.map((e) => VulnerableHeaders_Header.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVulnerableHeaders_Header(): VulnerableHeaders_Header {
  return { name: "", value: "" };
}

export const VulnerableHeaders_Header: MessageFns<VulnerableHeaders_Header> = {
  encode(message: VulnerableHeaders_Header, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerableHeaders_Header {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerableHeaders_Header();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerableHeaders_Header {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: VulnerableHeaders_Header): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<VulnerableHeaders_Header>): VulnerableHeaders_Header {
    return VulnerableHeaders_Header.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VulnerableHeaders_Header>): VulnerableHeaders_Header {
    const message = createBaseVulnerableHeaders_Header();
    message.name = object.name ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseXss(): Xss {
  return { stackTraces: [], errorMessage: "" };
}

export const Xss: MessageFns<Xss> = {
  encode(message: Xss, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.stackTraces) {
      writer.uint32(10).string(v!);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Xss {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXss();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stackTraces.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Xss {
    return {
      stackTraces: globalThis.Array.isArray(object?.stackTraces)
        ? object.stackTraces.map((e: any) => globalThis.String(e))
        : [],
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
    };
  },

  toJSON(message: Xss): unknown {
    const obj: any = {};
    if (message.stackTraces?.length) {
      obj.stackTraces = message.stackTraces;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    return obj;
  },

  create(base?: DeepPartial<Xss>): Xss {
    return Xss.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Xss>): Xss {
    const message = createBaseXss();
    message.stackTraces = object.stackTraces?.map((e) => e) || [];
    message.errorMessage = object.errorMessage ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
