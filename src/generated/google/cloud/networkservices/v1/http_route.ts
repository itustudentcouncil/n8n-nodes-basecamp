// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/networkservices/v1/http_route.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.networkservices.v1";

/**
 * HttpRoute is the resource defining how HTTP traffic should be routed by a
 * Mesh or Gateway resource.
 */
export interface HttpRoute {
  /**
   * Required. Name of the HttpRoute resource. It matches pattern
   * `projects/* /locations/global/httpRoutes/http_route_name>`.
   */
  name: string;
  /** Output only. Server-defined URL of this resource */
  selfLink: string;
  /**
   * Optional. A free-text description of the resource. Max length 1024
   * characters.
   */
  description: string;
  /** Output only. The timestamp when the resource was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The timestamp when the resource was updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Required. Hostnames define a set of hosts that should match against the
   * HTTP host header to select a HttpRoute to process the request. Hostname is
   * the fully qualified domain name of a network host, as defined by RFC 1123
   * with the exception that:
   *  - IPs are not allowed.
   *  - A hostname may be prefixed with a wildcard label (`*.`). The wildcard
   *    label must appear by itself as the first label.
   *
   * Hostname can be "precise" which is a domain name without the terminating
   * dot of a network host (e.g. `foo.example.com`) or "wildcard", which is a
   * domain name prefixed with a single wildcard label (e.g. `*.example.com`).
   *
   * Note that as per RFC1035 and RFC1123, a label must consist of lower case
   * alphanumeric characters or '-', and must start and end with an alphanumeric
   * character. No other punctuation is allowed.
   *
   * The routes associated with a Mesh or Gateways  must have unique hostnames.
   * If you attempt to attach multiple routes with conflicting hostnames,
   * the configuration will be rejected.
   *
   * For example, while it is acceptable for routes for the hostnames
   * `*.foo.bar.com` and `*.bar.com` to be associated with the same Mesh (or
   * Gateways under the same scope), it is not possible to associate two routes
   * both with `*.bar.com` or both with `bar.com`.
   */
  hostnames: string[];
  /**
   * Optional. Meshes defines a list of meshes this HttpRoute is attached to, as
   * one of the routing rules to route the requests served by the mesh.
   *
   * Each mesh reference should match the pattern:
   * `projects/* /locations/global/meshes/<mesh_name>`
   *
   * The attached Mesh should be of a type SIDECAR
   */
  meshes: string[];
  /**
   * Optional. Gateways defines a list of gateways this HttpRoute is attached
   * to, as one of the routing rules to route the requests served by the
   * gateway.
   *
   * Each gateway reference should match the pattern:
   * `projects/* /locations/global/gateways/<gateway_name>`
   */
  gateways: string[];
  /** Optional. Set of label tags associated with the HttpRoute resource. */
  labels: { [key: string]: string };
  /**
   * Required. Rules that define how traffic is routed and handled.
   * Rules will be matched sequentially based on the RouteMatch specified for
   * the rule.
   */
  rules: HttpRoute_RouteRule[];
}

/** Specifies how to select a route rule based on HTTP request headers. */
export interface HttpRoute_HeaderMatch {
  /**
   * The value of the header should match exactly the content of
   * exact_match.
   */
  exactMatch?:
    | string
    | undefined;
  /**
   * The value of the header must match the regular expression specified in
   * regex_match. For regular expression grammar, please see:
   * https://github.com/google/re2/wiki/Syntax
   */
  regexMatch?:
    | string
    | undefined;
  /** The value of the header must start with the contents of prefix_match. */
  prefixMatch?:
    | string
    | undefined;
  /**
   * A header with header_name must exist. The match takes place whether or
   * not the header has a value.
   */
  presentMatch?:
    | boolean
    | undefined;
  /** The value of the header must end with the contents of suffix_match. */
  suffixMatch?:
    | string
    | undefined;
  /**
   * If specified, the rule will match if the request header value is within
   * the range.
   */
  rangeMatch?:
    | HttpRoute_HeaderMatch_IntegerRange
    | undefined;
  /** The name of the HTTP header to match against. */
  header: string;
  /**
   * If specified, the match result will be inverted before checking. Default
   * value is set to false.
   */
  invertMatch: boolean;
}

/** Represents an integer value range. */
export interface HttpRoute_HeaderMatch_IntegerRange {
  /** Start of the range (inclusive) */
  start: number;
  /** End of the range (exclusive) */
  end: number;
}

/** Specifications to match a query parameter in the request. */
export interface HttpRoute_QueryParameterMatch {
  /**
   * The value of the query parameter must exactly match the contents of
   * exact_match.
   *
   * Only one of exact_match, regex_match, or present_match must be set.
   */
  exactMatch?:
    | string
    | undefined;
  /**
   * The value of the query parameter must match the regular expression
   * specified by regex_match. For regular expression grammar, please see
   * https://github.com/google/re2/wiki/Syntax
   *
   * Only one of exact_match, regex_match, or present_match must be set.
   */
  regexMatch?:
    | string
    | undefined;
  /**
   * Specifies that the QueryParameterMatcher matches if request contains
   * query parameter, irrespective of whether the parameter has a value or
   * not.
   *
   * Only one of exact_match, regex_match, or present_match must be set.
   */
  presentMatch?:
    | boolean
    | undefined;
  /** The name of the query parameter to match. */
  queryParameter: string;
}

/**
 * RouteMatch defines specifications used to match requests. If multiple match
 * types are set, this RouteMatch will match if ALL type of matches are
 * matched.
 */
export interface HttpRoute_RouteMatch {
  /**
   * The HTTP request path value should exactly match this value.
   *
   * Only one of full_path_match, prefix_match, or regex_match should be
   * used.
   */
  fullPathMatch?:
    | string
    | undefined;
  /**
   * The HTTP request path value must begin with specified prefix_match.
   * prefix_match must begin with a /.
   *
   * Only one of full_path_match, prefix_match, or regex_match should be
   * used.
   */
  prefixMatch?:
    | string
    | undefined;
  /**
   * The HTTP request path value must satisfy the regular expression
   * specified by regex_match after removing any query parameters and anchor
   * supplied with the original URL. For regular expression grammar, please
   * see https://github.com/google/re2/wiki/Syntax
   *
   * Only one of full_path_match, prefix_match, or regex_match should be
   * used.
   */
  regexMatch?:
    | string
    | undefined;
  /**
   * Specifies if prefix_match and full_path_match matches are case sensitive.
   * The default value is false.
   */
  ignoreCase: boolean;
  /**
   * Specifies a list of HTTP request headers to match against. ALL of the
   * supplied headers must be matched.
   */
  headers: HttpRoute_HeaderMatch[];
  /**
   * Specifies a list of query parameters to match against. ALL of the query
   * parameters must be matched.
   */
  queryParameters: HttpRoute_QueryParameterMatch[];
}

/** Specifications of a destination to which the request should be routed to. */
export interface HttpRoute_Destination {
  /** The URL of a BackendService to route traffic to. */
  serviceName: string;
  /**
   * Specifies the proportion of requests forwarded to the backend referenced
   * by the serviceName field. This is computed as:
   * - weight/Sum(weights in this destination list).
   * For non-zero values, there may be some epsilon from the exact proportion
   * defined here depending on the precision an implementation supports.
   *
   * If only one serviceName is specified and it has a weight greater than 0,
   * 100% of the traffic is forwarded to that backend.
   *
   * If weights are specified for any one service name, they need to be
   * specified for all of them.
   *
   * If weights are unspecified for all services, then, traffic is distributed
   * in equal proportions to all of them.
   */
  weight: number;
}

/** The specification for redirecting traffic. */
export interface HttpRoute_Redirect {
  /**
   * The host that will be used in the redirect response instead of the one
   * that was supplied in the request.
   */
  hostRedirect: string;
  /**
   * The path that will be used in the redirect response instead of the one
   * that was supplied in the request.
   * path_redirect can not be supplied together with prefix_redirect. Supply
   * one alone or neither. If neither is supplied, the path of the original
   * request will be used for the redirect.
   */
  pathRedirect: string;
  /**
   * Indicates that during redirection, the matched prefix (or path) should be
   * swapped with this value. This option allows URLs be dynamically created
   * based on the request.
   */
  prefixRewrite: string;
  /** The HTTP Status code to use for the redirect. */
  responseCode: HttpRoute_Redirect_ResponseCode;
  /**
   * If set to true, the URL scheme in the redirected request is set to https.
   * If set to false, the URL scheme of the redirected request will remain the
   * same as that of the request.
   *
   * The default is set to false.
   */
  httpsRedirect: boolean;
  /**
   * if set to true, any accompanying query portion of the original URL is
   * removed prior to redirecting the request. If set to false, the query
   * portion of the original URL is retained.
   *
   * The default is set to false.
   */
  stripQuery: boolean;
  /**
   * The port that will be used in the redirected request instead of the one
   * that was supplied in the request.
   */
  portRedirect: number;
}

/** Supported HTTP response code. */
export enum HttpRoute_Redirect_ResponseCode {
  /** RESPONSE_CODE_UNSPECIFIED - Default value */
  RESPONSE_CODE_UNSPECIFIED = 0,
  /** MOVED_PERMANENTLY_DEFAULT - Corresponds to 301. */
  MOVED_PERMANENTLY_DEFAULT = 1,
  /** FOUND - Corresponds to 302. */
  FOUND = 2,
  /** SEE_OTHER - Corresponds to 303. */
  SEE_OTHER = 3,
  /** TEMPORARY_REDIRECT - Corresponds to 307. In this case, the request method will be retained. */
  TEMPORARY_REDIRECT = 4,
  /** PERMANENT_REDIRECT - Corresponds to 308. In this case, the request method will be retained. */
  PERMANENT_REDIRECT = 5,
  UNRECOGNIZED = -1,
}

export function httpRoute_Redirect_ResponseCodeFromJSON(object: any): HttpRoute_Redirect_ResponseCode {
  switch (object) {
    case 0:
    case "RESPONSE_CODE_UNSPECIFIED":
      return HttpRoute_Redirect_ResponseCode.RESPONSE_CODE_UNSPECIFIED;
    case 1:
    case "MOVED_PERMANENTLY_DEFAULT":
      return HttpRoute_Redirect_ResponseCode.MOVED_PERMANENTLY_DEFAULT;
    case 2:
    case "FOUND":
      return HttpRoute_Redirect_ResponseCode.FOUND;
    case 3:
    case "SEE_OTHER":
      return HttpRoute_Redirect_ResponseCode.SEE_OTHER;
    case 4:
    case "TEMPORARY_REDIRECT":
      return HttpRoute_Redirect_ResponseCode.TEMPORARY_REDIRECT;
    case 5:
    case "PERMANENT_REDIRECT":
      return HttpRoute_Redirect_ResponseCode.PERMANENT_REDIRECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HttpRoute_Redirect_ResponseCode.UNRECOGNIZED;
  }
}

export function httpRoute_Redirect_ResponseCodeToJSON(object: HttpRoute_Redirect_ResponseCode): string {
  switch (object) {
    case HttpRoute_Redirect_ResponseCode.RESPONSE_CODE_UNSPECIFIED:
      return "RESPONSE_CODE_UNSPECIFIED";
    case HttpRoute_Redirect_ResponseCode.MOVED_PERMANENTLY_DEFAULT:
      return "MOVED_PERMANENTLY_DEFAULT";
    case HttpRoute_Redirect_ResponseCode.FOUND:
      return "FOUND";
    case HttpRoute_Redirect_ResponseCode.SEE_OTHER:
      return "SEE_OTHER";
    case HttpRoute_Redirect_ResponseCode.TEMPORARY_REDIRECT:
      return "TEMPORARY_REDIRECT";
    case HttpRoute_Redirect_ResponseCode.PERMANENT_REDIRECT:
      return "PERMANENT_REDIRECT";
    case HttpRoute_Redirect_ResponseCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The specification for fault injection introduced into traffic to test the
 * resiliency of clients to destination service failure. As part of fault
 * injection, when clients send requests to a destination, delays can be
 * introduced by client proxy on a percentage of requests before sending those
 * requests to the destination service. Similarly requests can be aborted by
 * client proxy for a percentage of requests.
 */
export interface HttpRoute_FaultInjectionPolicy {
  /** The specification for injecting delay to client requests. */
  delay:
    | HttpRoute_FaultInjectionPolicy_Delay
    | undefined;
  /** The specification for aborting to client requests. */
  abort: HttpRoute_FaultInjectionPolicy_Abort | undefined;
}

/**
 * Specification of how client requests are delayed as part of fault
 * injection before being sent to a destination.
 */
export interface HttpRoute_FaultInjectionPolicy_Delay {
  /** Specify a fixed delay before forwarding the request. */
  fixedDelay:
    | Duration
    | undefined;
  /**
   * The percentage of traffic on which delay will be injected.
   *
   * The value must be between [0, 100]
   */
  percentage: number;
}

/**
 * Specification of how client requests are aborted as part of fault
 * injection before being sent to a destination.
 */
export interface HttpRoute_FaultInjectionPolicy_Abort {
  /**
   * The HTTP status code used to abort the request.
   *
   * The value must be between 200 and 599 inclusive.
   */
  httpStatus: number;
  /**
   * The percentage of traffic which will be aborted.
   *
   * The value must be between [0, 100]
   */
  percentage: number;
}

/**
 * The specification for modifying HTTP header in HTTP request and HTTP
 * response.
 */
export interface HttpRoute_HeaderModifier {
  /**
   * Completely overwrite/replace the headers with given map where key is the
   * name of the header, value is the value of the header.
   */
  set: { [key: string]: string };
  /**
   * Add the headers with given map where key is the name of the header, value
   * is the value of the header.
   */
  add: { [key: string]: string };
  /** Remove headers (matching by header names) specified in the list. */
  remove: string[];
}

export interface HttpRoute_HeaderModifier_SetEntry {
  key: string;
  value: string;
}

export interface HttpRoute_HeaderModifier_AddEntry {
  key: string;
  value: string;
}

/**
 * The specification for modifying the URL of the request, prior to forwarding
 * the request to the destination.
 */
export interface HttpRoute_URLRewrite {
  /**
   * Prior to forwarding the request to the selected destination, the matching
   * portion of the requests path is replaced by this value.
   */
  pathPrefixRewrite: string;
  /**
   * Prior to forwarding the request to the selected destination, the requests
   * host header is replaced by this value.
   */
  hostRewrite: string;
}

/** The specifications for retries. */
export interface HttpRoute_RetryPolicy {
  /**
   * Specifies one or more conditions when this retry policy applies. Valid
   * values are:
   *   5xx: Proxy will attempt a retry if the destination service responds
   *     with any 5xx response code, of if the destination service does not
   *     respond at all, example: disconnect, reset, read timeout, connection
   *     failure and refused streams.
   *
   *   gateway-error: Similar to 5xx, but only applies to response codes 502,
   *     503, 504.
   *
   *   reset: Proxy will attempt a retry if the destination service does not
   *     respond at all (disconnect/reset/read timeout)
   *
   *   connect-failure: Proxy will retry on failures connecting to destination
   *     for example due to connection timeouts.
   *
   *   retriable-4xx: Proxy will retry fro retriable 4xx response codes.
   *     Currently the only retriable error supported is 409.
   *
   *   refused-stream: Proxy will retry if the destination resets the stream
   *     with a REFUSED_STREAM error code. This reset type indicates that it
   *     is safe to retry.
   */
  retryConditions: string[];
  /**
   * Specifies the allowed number of retries. This number must be > 0. If not
   * specified, default to 1.
   */
  numRetries: number;
  /** Specifies a non-zero timeout per retry attempt. */
  perTryTimeout: Duration | undefined;
}

/**
 * Specifies the policy on how requests are shadowed to a separate mirrored
 * destination service. The proxy does not wait for responses from the
 * shadow service. Prior to sending traffic to the shadow service, the
 * host/authority header is suffixed with -shadow.
 */
export interface HttpRoute_RequestMirrorPolicy {
  /**
   * The destination the requests will be mirrored to. The weight of the
   * destination will be ignored.
   */
  destination: HttpRoute_Destination | undefined;
}

/** The Specification for allowing client side cross-origin requests. */
export interface HttpRoute_CorsPolicy {
  /**
   * Specifies the list of origins that will be allowed to do CORS requests.
   * An origin is allowed if it matches either an item in allow_origins or
   * an item in allow_origin_regexes.
   */
  allowOrigins: string[];
  /**
   * Specifies the regular expression patterns that match allowed origins. For
   * regular expression grammar, please see
   * https://github.com/google/re2/wiki/Syntax.
   */
  allowOriginRegexes: string[];
  /** Specifies the content for Access-Control-Allow-Methods header. */
  allowMethods: string[];
  /** Specifies the content for Access-Control-Allow-Headers header. */
  allowHeaders: string[];
  /** Specifies the content for Access-Control-Expose-Headers header. */
  exposeHeaders: string[];
  /**
   * Specifies how long result of a preflight request can be cached in
   * seconds. This translates to the Access-Control-Max-Age header.
   */
  maxAge: string;
  /**
   * In response to a preflight request, setting this to true indicates that
   * the actual request can include user credentials. This translates to the
   * Access-Control-Allow-Credentials header.
   *
   * Default value is false.
   */
  allowCredentials: boolean;
  /**
   * If true, the CORS policy is disabled. The default value is false, which
   * indicates that the CORS policy is in effect.
   */
  disabled: boolean;
}

/** The specifications for routing traffic and applying associated policies. */
export interface HttpRoute_RouteAction {
  /** The destination to which traffic should be forwarded. */
  destinations: HttpRoute_Destination[];
  /** If set, the request is directed as configured by this field. */
  redirect:
    | HttpRoute_Redirect
    | undefined;
  /**
   * The specification for fault injection introduced into traffic to test the
   * resiliency of clients to backend service failure. As part of fault
   * injection, when clients send requests to a backend service, delays can be
   * introduced  on a percentage of requests before sending those requests to
   * the backend service. Similarly requests from clients can be aborted for a
   * percentage of requests.
   *
   * timeout and retry_policy will be ignored by clients that are configured
   * with a fault_injection_policy
   */
  faultInjectionPolicy:
    | HttpRoute_FaultInjectionPolicy
    | undefined;
  /**
   * The specification for modifying the headers of a matching request prior
   * to delivery of the request to the destination. If HeaderModifiers are set
   * on both the Destination and the RouteAction, they will be merged.
   * Conflicts between the two will not be resolved on the configuration.
   */
  requestHeaderModifier:
    | HttpRoute_HeaderModifier
    | undefined;
  /**
   * The specification for modifying the headers of a response prior to
   * sending the response back to the client. If HeaderModifiers are set
   * on both the Destination and the RouteAction, they will be merged.
   * Conflicts between the two will not be resolved on the configuration.
   */
  responseHeaderModifier:
    | HttpRoute_HeaderModifier
    | undefined;
  /**
   * The specification for rewrite URL before forwarding requests to the
   * destination.
   */
  urlRewrite:
    | HttpRoute_URLRewrite
    | undefined;
  /**
   * Specifies the timeout for selected route. Timeout is computed from the
   * time the request has been fully processed (i.e. end of stream) up until
   * the response has been completely processed. Timeout includes all retries.
   */
  timeout:
    | Duration
    | undefined;
  /** Specifies the retry policy associated with this route. */
  retryPolicy:
    | HttpRoute_RetryPolicy
    | undefined;
  /**
   * Specifies the policy on how requests intended for the routes destination
   * are shadowed to a separate mirrored destination. Proxy will not wait for
   * the shadow destination to respond before returning the response. Prior to
   * sending traffic to the shadow service, the host/authority header is
   * suffixed with -shadow.
   */
  requestMirrorPolicy:
    | HttpRoute_RequestMirrorPolicy
    | undefined;
  /** The specification for allowing client side cross-origin requests. */
  corsPolicy: HttpRoute_CorsPolicy | undefined;
}

/**
 * Specifies how to match traffic and how to route traffic when traffic is
 * matched.
 */
export interface HttpRoute_RouteRule {
  /**
   * A list of matches define conditions used for matching the rule against
   * incoming HTTP requests. Each match is independent, i.e. this rule will be
   * matched if ANY one of the matches is satisfied.
   *
   * If no matches field is specified, this rule will unconditionally match
   * traffic.
   *
   * If a default rule is desired to be configured, add a rule with no matches
   * specified to the end of the rules list.
   */
  matches: HttpRoute_RouteMatch[];
  /** The detailed rule defining how to route matched traffic. */
  action: HttpRoute_RouteAction | undefined;
}

export interface HttpRoute_LabelsEntry {
  key: string;
  value: string;
}

/** Request used with the ListHttpRoutes method. */
export interface ListHttpRoutesRequest {
  /**
   * Required. The project and location from which the HttpRoutes should be
   * listed, specified in the format `projects/* /locations/global`.
   */
  parent: string;
  /** Maximum number of HttpRoutes to return per call. */
  pageSize: number;
  /**
   * The value returned by the last `ListHttpRoutesResponse`
   * Indicates that this is a continuation of a prior `ListHttpRoutes` call,
   * and that the system should return the next page of data.
   */
  pageToken: string;
}

/** Response returned by the ListHttpRoutes method. */
export interface ListHttpRoutesResponse {
  /** List of HttpRoute resources. */
  httpRoutes: HttpRoute[];
  /**
   * If there might be more results than those appearing in this response, then
   * `next_page_token` is included. To get the next set of results, call this
   * method again using the value of `next_page_token` as `page_token`.
   */
  nextPageToken: string;
}

/** Request used by the GetHttpRoute method. */
export interface GetHttpRouteRequest {
  /**
   * Required. A name of the HttpRoute to get. Must be in the format
   * `projects/* /locations/global/httpRoutes/*`.
   */
  name: string;
}

/** Request used by the HttpRoute method. */
export interface CreateHttpRouteRequest {
  /**
   * Required. The parent resource of the HttpRoute. Must be in the
   * format `projects/* /locations/global`.
   */
  parent: string;
  /** Required. Short name of the HttpRoute resource to be created. */
  httpRouteId: string;
  /** Required. HttpRoute resource to be created. */
  httpRoute: HttpRoute | undefined;
}

/** Request used by the UpdateHttpRoute method. */
export interface UpdateHttpRouteRequest {
  /**
   * Optional. Field mask is used to specify the fields to be overwritten in the
   * HttpRoute resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then all fields will be overwritten.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. Updated HttpRoute resource. */
  httpRoute: HttpRoute | undefined;
}

/** Request used by the DeleteHttpRoute method. */
export interface DeleteHttpRouteRequest {
  /**
   * Required. A name of the HttpRoute to delete. Must be in the format
   * `projects/* /locations/global/httpRoutes/*`.
   */
  name: string;
}

function createBaseHttpRoute(): HttpRoute {
  return {
    name: "",
    selfLink: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    hostnames: [],
    meshes: [],
    gateways: [],
    labels: {},
    rules: [],
  };
}

export const HttpRoute: MessageFns<HttpRoute> = {
  encode(message: HttpRoute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.selfLink !== "") {
      writer.uint32(90).string(message.selfLink);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    for (const v of message.hostnames) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.meshes) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.gateways) {
      writer.uint32(74).string(v!);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      HttpRoute_LabelsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    for (const v of message.rules) {
      HttpRoute_RouteRule.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hostnames.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.meshes.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.gateways.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = HttpRoute_LabelsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.labels[entry10.key] = entry10.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rules.push(HttpRoute_RouteRule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      hostnames: globalThis.Array.isArray(object?.hostnames)
        ? object.hostnames.map((e: any) => globalThis.String(e))
        : [],
      meshes: globalThis.Array.isArray(object?.meshes) ? object.meshes.map((e: any) => globalThis.String(e)) : [],
      gateways: globalThis.Array.isArray(object?.gateways) ? object.gateways.map((e: any) => globalThis.String(e)) : [],
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => HttpRoute_RouteRule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HttpRoute): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.hostnames?.length) {
      obj.hostnames = message.hostnames;
    }
    if (message.meshes?.length) {
      obj.meshes = message.meshes;
    }
    if (message.gateways?.length) {
      obj.gateways = message.gateways;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => HttpRoute_RouteRule.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute>): HttpRoute {
    return HttpRoute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute>): HttpRoute {
    const message = createBaseHttpRoute();
    message.name = object.name ?? "";
    message.selfLink = object.selfLink ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.hostnames = object.hostnames?.map((e) => e) || [];
    message.meshes = object.meshes?.map((e) => e) || [];
    message.gateways = object.gateways?.map((e) => e) || [];
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.rules = object.rules?.map((e) => HttpRoute_RouteRule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHttpRoute_HeaderMatch(): HttpRoute_HeaderMatch {
  return {
    exactMatch: undefined,
    regexMatch: undefined,
    prefixMatch: undefined,
    presentMatch: undefined,
    suffixMatch: undefined,
    rangeMatch: undefined,
    header: "",
    invertMatch: false,
  };
}

export const HttpRoute_HeaderMatch: MessageFns<HttpRoute_HeaderMatch> = {
  encode(message: HttpRoute_HeaderMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exactMatch !== undefined) {
      writer.uint32(18).string(message.exactMatch);
    }
    if (message.regexMatch !== undefined) {
      writer.uint32(26).string(message.regexMatch);
    }
    if (message.prefixMatch !== undefined) {
      writer.uint32(34).string(message.prefixMatch);
    }
    if (message.presentMatch !== undefined) {
      writer.uint32(40).bool(message.presentMatch);
    }
    if (message.suffixMatch !== undefined) {
      writer.uint32(50).string(message.suffixMatch);
    }
    if (message.rangeMatch !== undefined) {
      HttpRoute_HeaderMatch_IntegerRange.encode(message.rangeMatch, writer.uint32(58).fork()).join();
    }
    if (message.header !== "") {
      writer.uint32(10).string(message.header);
    }
    if (message.invertMatch !== false) {
      writer.uint32(64).bool(message.invertMatch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_HeaderMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_HeaderMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exactMatch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.regexMatch = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.prefixMatch = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.presentMatch = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.suffixMatch = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.rangeMatch = HttpRoute_HeaderMatch_IntegerRange.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.header = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.invertMatch = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_HeaderMatch {
    return {
      exactMatch: isSet(object.exactMatch) ? globalThis.String(object.exactMatch) : undefined,
      regexMatch: isSet(object.regexMatch) ? globalThis.String(object.regexMatch) : undefined,
      prefixMatch: isSet(object.prefixMatch) ? globalThis.String(object.prefixMatch) : undefined,
      presentMatch: isSet(object.presentMatch) ? globalThis.Boolean(object.presentMatch) : undefined,
      suffixMatch: isSet(object.suffixMatch) ? globalThis.String(object.suffixMatch) : undefined,
      rangeMatch: isSet(object.rangeMatch) ? HttpRoute_HeaderMatch_IntegerRange.fromJSON(object.rangeMatch) : undefined,
      header: isSet(object.header) ? globalThis.String(object.header) : "",
      invertMatch: isSet(object.invertMatch) ? globalThis.Boolean(object.invertMatch) : false,
    };
  },

  toJSON(message: HttpRoute_HeaderMatch): unknown {
    const obj: any = {};
    if (message.exactMatch !== undefined) {
      obj.exactMatch = message.exactMatch;
    }
    if (message.regexMatch !== undefined) {
      obj.regexMatch = message.regexMatch;
    }
    if (message.prefixMatch !== undefined) {
      obj.prefixMatch = message.prefixMatch;
    }
    if (message.presentMatch !== undefined) {
      obj.presentMatch = message.presentMatch;
    }
    if (message.suffixMatch !== undefined) {
      obj.suffixMatch = message.suffixMatch;
    }
    if (message.rangeMatch !== undefined) {
      obj.rangeMatch = HttpRoute_HeaderMatch_IntegerRange.toJSON(message.rangeMatch);
    }
    if (message.header !== "") {
      obj.header = message.header;
    }
    if (message.invertMatch !== false) {
      obj.invertMatch = message.invertMatch;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_HeaderMatch>): HttpRoute_HeaderMatch {
    return HttpRoute_HeaderMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_HeaderMatch>): HttpRoute_HeaderMatch {
    const message = createBaseHttpRoute_HeaderMatch();
    message.exactMatch = object.exactMatch ?? undefined;
    message.regexMatch = object.regexMatch ?? undefined;
    message.prefixMatch = object.prefixMatch ?? undefined;
    message.presentMatch = object.presentMatch ?? undefined;
    message.suffixMatch = object.suffixMatch ?? undefined;
    message.rangeMatch = (object.rangeMatch !== undefined && object.rangeMatch !== null)
      ? HttpRoute_HeaderMatch_IntegerRange.fromPartial(object.rangeMatch)
      : undefined;
    message.header = object.header ?? "";
    message.invertMatch = object.invertMatch ?? false;
    return message;
  },
};

function createBaseHttpRoute_HeaderMatch_IntegerRange(): HttpRoute_HeaderMatch_IntegerRange {
  return { start: 0, end: 0 };
}

export const HttpRoute_HeaderMatch_IntegerRange: MessageFns<HttpRoute_HeaderMatch_IntegerRange> = {
  encode(message: HttpRoute_HeaderMatch_IntegerRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== 0) {
      writer.uint32(8).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_HeaderMatch_IntegerRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_HeaderMatch_IntegerRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.start = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_HeaderMatch_IntegerRange {
    return {
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
    };
  },

  toJSON(message: HttpRoute_HeaderMatch_IntegerRange): unknown {
    const obj: any = {};
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_HeaderMatch_IntegerRange>): HttpRoute_HeaderMatch_IntegerRange {
    return HttpRoute_HeaderMatch_IntegerRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_HeaderMatch_IntegerRange>): HttpRoute_HeaderMatch_IntegerRange {
    const message = createBaseHttpRoute_HeaderMatch_IntegerRange();
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    return message;
  },
};

function createBaseHttpRoute_QueryParameterMatch(): HttpRoute_QueryParameterMatch {
  return { exactMatch: undefined, regexMatch: undefined, presentMatch: undefined, queryParameter: "" };
}

export const HttpRoute_QueryParameterMatch: MessageFns<HttpRoute_QueryParameterMatch> = {
  encode(message: HttpRoute_QueryParameterMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.exactMatch !== undefined) {
      writer.uint32(18).string(message.exactMatch);
    }
    if (message.regexMatch !== undefined) {
      writer.uint32(26).string(message.regexMatch);
    }
    if (message.presentMatch !== undefined) {
      writer.uint32(32).bool(message.presentMatch);
    }
    if (message.queryParameter !== "") {
      writer.uint32(10).string(message.queryParameter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_QueryParameterMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_QueryParameterMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.exactMatch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.regexMatch = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.presentMatch = reader.bool();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.queryParameter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_QueryParameterMatch {
    return {
      exactMatch: isSet(object.exactMatch) ? globalThis.String(object.exactMatch) : undefined,
      regexMatch: isSet(object.regexMatch) ? globalThis.String(object.regexMatch) : undefined,
      presentMatch: isSet(object.presentMatch) ? globalThis.Boolean(object.presentMatch) : undefined,
      queryParameter: isSet(object.queryParameter) ? globalThis.String(object.queryParameter) : "",
    };
  },

  toJSON(message: HttpRoute_QueryParameterMatch): unknown {
    const obj: any = {};
    if (message.exactMatch !== undefined) {
      obj.exactMatch = message.exactMatch;
    }
    if (message.regexMatch !== undefined) {
      obj.regexMatch = message.regexMatch;
    }
    if (message.presentMatch !== undefined) {
      obj.presentMatch = message.presentMatch;
    }
    if (message.queryParameter !== "") {
      obj.queryParameter = message.queryParameter;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_QueryParameterMatch>): HttpRoute_QueryParameterMatch {
    return HttpRoute_QueryParameterMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_QueryParameterMatch>): HttpRoute_QueryParameterMatch {
    const message = createBaseHttpRoute_QueryParameterMatch();
    message.exactMatch = object.exactMatch ?? undefined;
    message.regexMatch = object.regexMatch ?? undefined;
    message.presentMatch = object.presentMatch ?? undefined;
    message.queryParameter = object.queryParameter ?? "";
    return message;
  },
};

function createBaseHttpRoute_RouteMatch(): HttpRoute_RouteMatch {
  return {
    fullPathMatch: undefined,
    prefixMatch: undefined,
    regexMatch: undefined,
    ignoreCase: false,
    headers: [],
    queryParameters: [],
  };
}

export const HttpRoute_RouteMatch: MessageFns<HttpRoute_RouteMatch> = {
  encode(message: HttpRoute_RouteMatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fullPathMatch !== undefined) {
      writer.uint32(10).string(message.fullPathMatch);
    }
    if (message.prefixMatch !== undefined) {
      writer.uint32(18).string(message.prefixMatch);
    }
    if (message.regexMatch !== undefined) {
      writer.uint32(26).string(message.regexMatch);
    }
    if (message.ignoreCase !== false) {
      writer.uint32(32).bool(message.ignoreCase);
    }
    for (const v of message.headers) {
      HttpRoute_HeaderMatch.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.queryParameters) {
      HttpRoute_QueryParameterMatch.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_RouteMatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_RouteMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fullPathMatch = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.prefixMatch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.regexMatch = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ignoreCase = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.headers.push(HttpRoute_HeaderMatch.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.queryParameters.push(HttpRoute_QueryParameterMatch.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_RouteMatch {
    return {
      fullPathMatch: isSet(object.fullPathMatch) ? globalThis.String(object.fullPathMatch) : undefined,
      prefixMatch: isSet(object.prefixMatch) ? globalThis.String(object.prefixMatch) : undefined,
      regexMatch: isSet(object.regexMatch) ? globalThis.String(object.regexMatch) : undefined,
      ignoreCase: isSet(object.ignoreCase) ? globalThis.Boolean(object.ignoreCase) : false,
      headers: globalThis.Array.isArray(object?.headers)
        ? object.headers.map((e: any) => HttpRoute_HeaderMatch.fromJSON(e))
        : [],
      queryParameters: globalThis.Array.isArray(object?.queryParameters)
        ? object.queryParameters.map((e: any) => HttpRoute_QueryParameterMatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HttpRoute_RouteMatch): unknown {
    const obj: any = {};
    if (message.fullPathMatch !== undefined) {
      obj.fullPathMatch = message.fullPathMatch;
    }
    if (message.prefixMatch !== undefined) {
      obj.prefixMatch = message.prefixMatch;
    }
    if (message.regexMatch !== undefined) {
      obj.regexMatch = message.regexMatch;
    }
    if (message.ignoreCase !== false) {
      obj.ignoreCase = message.ignoreCase;
    }
    if (message.headers?.length) {
      obj.headers = message.headers.map((e) => HttpRoute_HeaderMatch.toJSON(e));
    }
    if (message.queryParameters?.length) {
      obj.queryParameters = message.queryParameters.map((e) => HttpRoute_QueryParameterMatch.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_RouteMatch>): HttpRoute_RouteMatch {
    return HttpRoute_RouteMatch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_RouteMatch>): HttpRoute_RouteMatch {
    const message = createBaseHttpRoute_RouteMatch();
    message.fullPathMatch = object.fullPathMatch ?? undefined;
    message.prefixMatch = object.prefixMatch ?? undefined;
    message.regexMatch = object.regexMatch ?? undefined;
    message.ignoreCase = object.ignoreCase ?? false;
    message.headers = object.headers?.map((e) => HttpRoute_HeaderMatch.fromPartial(e)) || [];
    message.queryParameters = object.queryParameters?.map((e) => HttpRoute_QueryParameterMatch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHttpRoute_Destination(): HttpRoute_Destination {
  return { serviceName: "", weight: 0 };
}

export const HttpRoute_Destination: MessageFns<HttpRoute_Destination> = {
  encode(message: HttpRoute_Destination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serviceName !== "") {
      writer.uint32(10).string(message.serviceName);
    }
    if (message.weight !== 0) {
      writer.uint32(16).int32(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_Destination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_Destination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.serviceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.weight = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_Destination {
    return {
      serviceName: isSet(object.serviceName) ? globalThis.String(object.serviceName) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: HttpRoute_Destination): unknown {
    const obj: any = {};
    if (message.serviceName !== "") {
      obj.serviceName = message.serviceName;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_Destination>): HttpRoute_Destination {
    return HttpRoute_Destination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_Destination>): HttpRoute_Destination {
    const message = createBaseHttpRoute_Destination();
    message.serviceName = object.serviceName ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseHttpRoute_Redirect(): HttpRoute_Redirect {
  return {
    hostRedirect: "",
    pathRedirect: "",
    prefixRewrite: "",
    responseCode: 0,
    httpsRedirect: false,
    stripQuery: false,
    portRedirect: 0,
  };
}

export const HttpRoute_Redirect: MessageFns<HttpRoute_Redirect> = {
  encode(message: HttpRoute_Redirect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostRedirect !== "") {
      writer.uint32(10).string(message.hostRedirect);
    }
    if (message.pathRedirect !== "") {
      writer.uint32(18).string(message.pathRedirect);
    }
    if (message.prefixRewrite !== "") {
      writer.uint32(26).string(message.prefixRewrite);
    }
    if (message.responseCode !== 0) {
      writer.uint32(32).int32(message.responseCode);
    }
    if (message.httpsRedirect !== false) {
      writer.uint32(40).bool(message.httpsRedirect);
    }
    if (message.stripQuery !== false) {
      writer.uint32(48).bool(message.stripQuery);
    }
    if (message.portRedirect !== 0) {
      writer.uint32(56).int32(message.portRedirect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_Redirect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_Redirect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hostRedirect = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pathRedirect = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.prefixRewrite = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.responseCode = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.httpsRedirect = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.stripQuery = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.portRedirect = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_Redirect {
    return {
      hostRedirect: isSet(object.hostRedirect) ? globalThis.String(object.hostRedirect) : "",
      pathRedirect: isSet(object.pathRedirect) ? globalThis.String(object.pathRedirect) : "",
      prefixRewrite: isSet(object.prefixRewrite) ? globalThis.String(object.prefixRewrite) : "",
      responseCode: isSet(object.responseCode) ? httpRoute_Redirect_ResponseCodeFromJSON(object.responseCode) : 0,
      httpsRedirect: isSet(object.httpsRedirect) ? globalThis.Boolean(object.httpsRedirect) : false,
      stripQuery: isSet(object.stripQuery) ? globalThis.Boolean(object.stripQuery) : false,
      portRedirect: isSet(object.portRedirect) ? globalThis.Number(object.portRedirect) : 0,
    };
  },

  toJSON(message: HttpRoute_Redirect): unknown {
    const obj: any = {};
    if (message.hostRedirect !== "") {
      obj.hostRedirect = message.hostRedirect;
    }
    if (message.pathRedirect !== "") {
      obj.pathRedirect = message.pathRedirect;
    }
    if (message.prefixRewrite !== "") {
      obj.prefixRewrite = message.prefixRewrite;
    }
    if (message.responseCode !== 0) {
      obj.responseCode = httpRoute_Redirect_ResponseCodeToJSON(message.responseCode);
    }
    if (message.httpsRedirect !== false) {
      obj.httpsRedirect = message.httpsRedirect;
    }
    if (message.stripQuery !== false) {
      obj.stripQuery = message.stripQuery;
    }
    if (message.portRedirect !== 0) {
      obj.portRedirect = Math.round(message.portRedirect);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_Redirect>): HttpRoute_Redirect {
    return HttpRoute_Redirect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_Redirect>): HttpRoute_Redirect {
    const message = createBaseHttpRoute_Redirect();
    message.hostRedirect = object.hostRedirect ?? "";
    message.pathRedirect = object.pathRedirect ?? "";
    message.prefixRewrite = object.prefixRewrite ?? "";
    message.responseCode = object.responseCode ?? 0;
    message.httpsRedirect = object.httpsRedirect ?? false;
    message.stripQuery = object.stripQuery ?? false;
    message.portRedirect = object.portRedirect ?? 0;
    return message;
  },
};

function createBaseHttpRoute_FaultInjectionPolicy(): HttpRoute_FaultInjectionPolicy {
  return { delay: undefined, abort: undefined };
}

export const HttpRoute_FaultInjectionPolicy: MessageFns<HttpRoute_FaultInjectionPolicy> = {
  encode(message: HttpRoute_FaultInjectionPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delay !== undefined) {
      HttpRoute_FaultInjectionPolicy_Delay.encode(message.delay, writer.uint32(10).fork()).join();
    }
    if (message.abort !== undefined) {
      HttpRoute_FaultInjectionPolicy_Abort.encode(message.abort, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_FaultInjectionPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_FaultInjectionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.delay = HttpRoute_FaultInjectionPolicy_Delay.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.abort = HttpRoute_FaultInjectionPolicy_Abort.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_FaultInjectionPolicy {
    return {
      delay: isSet(object.delay) ? HttpRoute_FaultInjectionPolicy_Delay.fromJSON(object.delay) : undefined,
      abort: isSet(object.abort) ? HttpRoute_FaultInjectionPolicy_Abort.fromJSON(object.abort) : undefined,
    };
  },

  toJSON(message: HttpRoute_FaultInjectionPolicy): unknown {
    const obj: any = {};
    if (message.delay !== undefined) {
      obj.delay = HttpRoute_FaultInjectionPolicy_Delay.toJSON(message.delay);
    }
    if (message.abort !== undefined) {
      obj.abort = HttpRoute_FaultInjectionPolicy_Abort.toJSON(message.abort);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_FaultInjectionPolicy>): HttpRoute_FaultInjectionPolicy {
    return HttpRoute_FaultInjectionPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_FaultInjectionPolicy>): HttpRoute_FaultInjectionPolicy {
    const message = createBaseHttpRoute_FaultInjectionPolicy();
    message.delay = (object.delay !== undefined && object.delay !== null)
      ? HttpRoute_FaultInjectionPolicy_Delay.fromPartial(object.delay)
      : undefined;
    message.abort = (object.abort !== undefined && object.abort !== null)
      ? HttpRoute_FaultInjectionPolicy_Abort.fromPartial(object.abort)
      : undefined;
    return message;
  },
};

function createBaseHttpRoute_FaultInjectionPolicy_Delay(): HttpRoute_FaultInjectionPolicy_Delay {
  return { fixedDelay: undefined, percentage: 0 };
}

export const HttpRoute_FaultInjectionPolicy_Delay: MessageFns<HttpRoute_FaultInjectionPolicy_Delay> = {
  encode(message: HttpRoute_FaultInjectionPolicy_Delay, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fixedDelay !== undefined) {
      Duration.encode(message.fixedDelay, writer.uint32(10).fork()).join();
    }
    if (message.percentage !== 0) {
      writer.uint32(16).int32(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_FaultInjectionPolicy_Delay {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_FaultInjectionPolicy_Delay();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fixedDelay = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.percentage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_FaultInjectionPolicy_Delay {
    return {
      fixedDelay: isSet(object.fixedDelay) ? Duration.fromJSON(object.fixedDelay) : undefined,
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : 0,
    };
  },

  toJSON(message: HttpRoute_FaultInjectionPolicy_Delay): unknown {
    const obj: any = {};
    if (message.fixedDelay !== undefined) {
      obj.fixedDelay = Duration.toJSON(message.fixedDelay);
    }
    if (message.percentage !== 0) {
      obj.percentage = Math.round(message.percentage);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_FaultInjectionPolicy_Delay>): HttpRoute_FaultInjectionPolicy_Delay {
    return HttpRoute_FaultInjectionPolicy_Delay.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_FaultInjectionPolicy_Delay>): HttpRoute_FaultInjectionPolicy_Delay {
    const message = createBaseHttpRoute_FaultInjectionPolicy_Delay();
    message.fixedDelay = (object.fixedDelay !== undefined && object.fixedDelay !== null)
      ? Duration.fromPartial(object.fixedDelay)
      : undefined;
    message.percentage = object.percentage ?? 0;
    return message;
  },
};

function createBaseHttpRoute_FaultInjectionPolicy_Abort(): HttpRoute_FaultInjectionPolicy_Abort {
  return { httpStatus: 0, percentage: 0 };
}

export const HttpRoute_FaultInjectionPolicy_Abort: MessageFns<HttpRoute_FaultInjectionPolicy_Abort> = {
  encode(message: HttpRoute_FaultInjectionPolicy_Abort, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpStatus !== 0) {
      writer.uint32(8).int32(message.httpStatus);
    }
    if (message.percentage !== 0) {
      writer.uint32(16).int32(message.percentage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_FaultInjectionPolicy_Abort {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_FaultInjectionPolicy_Abort();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.httpStatus = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.percentage = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_FaultInjectionPolicy_Abort {
    return {
      httpStatus: isSet(object.httpStatus) ? globalThis.Number(object.httpStatus) : 0,
      percentage: isSet(object.percentage) ? globalThis.Number(object.percentage) : 0,
    };
  },

  toJSON(message: HttpRoute_FaultInjectionPolicy_Abort): unknown {
    const obj: any = {};
    if (message.httpStatus !== 0) {
      obj.httpStatus = Math.round(message.httpStatus);
    }
    if (message.percentage !== 0) {
      obj.percentage = Math.round(message.percentage);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_FaultInjectionPolicy_Abort>): HttpRoute_FaultInjectionPolicy_Abort {
    return HttpRoute_FaultInjectionPolicy_Abort.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_FaultInjectionPolicy_Abort>): HttpRoute_FaultInjectionPolicy_Abort {
    const message = createBaseHttpRoute_FaultInjectionPolicy_Abort();
    message.httpStatus = object.httpStatus ?? 0;
    message.percentage = object.percentage ?? 0;
    return message;
  },
};

function createBaseHttpRoute_HeaderModifier(): HttpRoute_HeaderModifier {
  return { set: {}, add: {}, remove: [] };
}

export const HttpRoute_HeaderModifier: MessageFns<HttpRoute_HeaderModifier> = {
  encode(message: HttpRoute_HeaderModifier, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.set).forEach(([key, value]) => {
      HttpRoute_HeaderModifier_SetEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.add).forEach(([key, value]) => {
      HttpRoute_HeaderModifier_AddEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    for (const v of message.remove) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_HeaderModifier {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_HeaderModifier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = HttpRoute_HeaderModifier_SetEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.set[entry1.key] = entry1.value;
          }
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = HttpRoute_HeaderModifier_AddEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.add[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.remove.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_HeaderModifier {
    return {
      set: isObject(object.set)
        ? Object.entries(object.set).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      add: isObject(object.add)
        ? Object.entries(object.add).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      remove: globalThis.Array.isArray(object?.remove) ? object.remove.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: HttpRoute_HeaderModifier): unknown {
    const obj: any = {};
    if (message.set) {
      const entries = Object.entries(message.set);
      if (entries.length > 0) {
        obj.set = {};
        entries.forEach(([k, v]) => {
          obj.set[k] = v;
        });
      }
    }
    if (message.add) {
      const entries = Object.entries(message.add);
      if (entries.length > 0) {
        obj.add = {};
        entries.forEach(([k, v]) => {
          obj.add[k] = v;
        });
      }
    }
    if (message.remove?.length) {
      obj.remove = message.remove;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_HeaderModifier>): HttpRoute_HeaderModifier {
    return HttpRoute_HeaderModifier.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_HeaderModifier>): HttpRoute_HeaderModifier {
    const message = createBaseHttpRoute_HeaderModifier();
    message.set = Object.entries(object.set ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.add = Object.entries(object.add ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.remove = object.remove?.map((e) => e) || [];
    return message;
  },
};

function createBaseHttpRoute_HeaderModifier_SetEntry(): HttpRoute_HeaderModifier_SetEntry {
  return { key: "", value: "" };
}

export const HttpRoute_HeaderModifier_SetEntry: MessageFns<HttpRoute_HeaderModifier_SetEntry> = {
  encode(message: HttpRoute_HeaderModifier_SetEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_HeaderModifier_SetEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_HeaderModifier_SetEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_HeaderModifier_SetEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpRoute_HeaderModifier_SetEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_HeaderModifier_SetEntry>): HttpRoute_HeaderModifier_SetEntry {
    return HttpRoute_HeaderModifier_SetEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_HeaderModifier_SetEntry>): HttpRoute_HeaderModifier_SetEntry {
    const message = createBaseHttpRoute_HeaderModifier_SetEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHttpRoute_HeaderModifier_AddEntry(): HttpRoute_HeaderModifier_AddEntry {
  return { key: "", value: "" };
}

export const HttpRoute_HeaderModifier_AddEntry: MessageFns<HttpRoute_HeaderModifier_AddEntry> = {
  encode(message: HttpRoute_HeaderModifier_AddEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_HeaderModifier_AddEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_HeaderModifier_AddEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_HeaderModifier_AddEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpRoute_HeaderModifier_AddEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_HeaderModifier_AddEntry>): HttpRoute_HeaderModifier_AddEntry {
    return HttpRoute_HeaderModifier_AddEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_HeaderModifier_AddEntry>): HttpRoute_HeaderModifier_AddEntry {
    const message = createBaseHttpRoute_HeaderModifier_AddEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHttpRoute_URLRewrite(): HttpRoute_URLRewrite {
  return { pathPrefixRewrite: "", hostRewrite: "" };
}

export const HttpRoute_URLRewrite: MessageFns<HttpRoute_URLRewrite> = {
  encode(message: HttpRoute_URLRewrite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pathPrefixRewrite !== "") {
      writer.uint32(10).string(message.pathPrefixRewrite);
    }
    if (message.hostRewrite !== "") {
      writer.uint32(18).string(message.hostRewrite);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_URLRewrite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_URLRewrite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.pathPrefixRewrite = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.hostRewrite = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_URLRewrite {
    return {
      pathPrefixRewrite: isSet(object.pathPrefixRewrite) ? globalThis.String(object.pathPrefixRewrite) : "",
      hostRewrite: isSet(object.hostRewrite) ? globalThis.String(object.hostRewrite) : "",
    };
  },

  toJSON(message: HttpRoute_URLRewrite): unknown {
    const obj: any = {};
    if (message.pathPrefixRewrite !== "") {
      obj.pathPrefixRewrite = message.pathPrefixRewrite;
    }
    if (message.hostRewrite !== "") {
      obj.hostRewrite = message.hostRewrite;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_URLRewrite>): HttpRoute_URLRewrite {
    return HttpRoute_URLRewrite.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_URLRewrite>): HttpRoute_URLRewrite {
    const message = createBaseHttpRoute_URLRewrite();
    message.pathPrefixRewrite = object.pathPrefixRewrite ?? "";
    message.hostRewrite = object.hostRewrite ?? "";
    return message;
  },
};

function createBaseHttpRoute_RetryPolicy(): HttpRoute_RetryPolicy {
  return { retryConditions: [], numRetries: 0, perTryTimeout: undefined };
}

export const HttpRoute_RetryPolicy: MessageFns<HttpRoute_RetryPolicy> = {
  encode(message: HttpRoute_RetryPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.retryConditions) {
      writer.uint32(10).string(v!);
    }
    if (message.numRetries !== 0) {
      writer.uint32(16).int32(message.numRetries);
    }
    if (message.perTryTimeout !== undefined) {
      Duration.encode(message.perTryTimeout, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_RetryPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_RetryPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.retryConditions.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numRetries = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.perTryTimeout = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_RetryPolicy {
    return {
      retryConditions: globalThis.Array.isArray(object?.retryConditions)
        ? object.retryConditions.map((e: any) => globalThis.String(e))
        : [],
      numRetries: isSet(object.numRetries) ? globalThis.Number(object.numRetries) : 0,
      perTryTimeout: isSet(object.perTryTimeout) ? Duration.fromJSON(object.perTryTimeout) : undefined,
    };
  },

  toJSON(message: HttpRoute_RetryPolicy): unknown {
    const obj: any = {};
    if (message.retryConditions?.length) {
      obj.retryConditions = message.retryConditions;
    }
    if (message.numRetries !== 0) {
      obj.numRetries = Math.round(message.numRetries);
    }
    if (message.perTryTimeout !== undefined) {
      obj.perTryTimeout = Duration.toJSON(message.perTryTimeout);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_RetryPolicy>): HttpRoute_RetryPolicy {
    return HttpRoute_RetryPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_RetryPolicy>): HttpRoute_RetryPolicy {
    const message = createBaseHttpRoute_RetryPolicy();
    message.retryConditions = object.retryConditions?.map((e) => e) || [];
    message.numRetries = object.numRetries ?? 0;
    message.perTryTimeout = (object.perTryTimeout !== undefined && object.perTryTimeout !== null)
      ? Duration.fromPartial(object.perTryTimeout)
      : undefined;
    return message;
  },
};

function createBaseHttpRoute_RequestMirrorPolicy(): HttpRoute_RequestMirrorPolicy {
  return { destination: undefined };
}

export const HttpRoute_RequestMirrorPolicy: MessageFns<HttpRoute_RequestMirrorPolicy> = {
  encode(message: HttpRoute_RequestMirrorPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.destination !== undefined) {
      HttpRoute_Destination.encode(message.destination, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_RequestMirrorPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_RequestMirrorPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destination = HttpRoute_Destination.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_RequestMirrorPolicy {
    return { destination: isSet(object.destination) ? HttpRoute_Destination.fromJSON(object.destination) : undefined };
  },

  toJSON(message: HttpRoute_RequestMirrorPolicy): unknown {
    const obj: any = {};
    if (message.destination !== undefined) {
      obj.destination = HttpRoute_Destination.toJSON(message.destination);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_RequestMirrorPolicy>): HttpRoute_RequestMirrorPolicy {
    return HttpRoute_RequestMirrorPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_RequestMirrorPolicy>): HttpRoute_RequestMirrorPolicy {
    const message = createBaseHttpRoute_RequestMirrorPolicy();
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? HttpRoute_Destination.fromPartial(object.destination)
      : undefined;
    return message;
  },
};

function createBaseHttpRoute_CorsPolicy(): HttpRoute_CorsPolicy {
  return {
    allowOrigins: [],
    allowOriginRegexes: [],
    allowMethods: [],
    allowHeaders: [],
    exposeHeaders: [],
    maxAge: "",
    allowCredentials: false,
    disabled: false,
  };
}

export const HttpRoute_CorsPolicy: MessageFns<HttpRoute_CorsPolicy> = {
  encode(message: HttpRoute_CorsPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.allowOrigins) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.allowOriginRegexes) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.allowMethods) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.allowHeaders) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.exposeHeaders) {
      writer.uint32(42).string(v!);
    }
    if (message.maxAge !== "") {
      writer.uint32(50).string(message.maxAge);
    }
    if (message.allowCredentials !== false) {
      writer.uint32(56).bool(message.allowCredentials);
    }
    if (message.disabled !== false) {
      writer.uint32(64).bool(message.disabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_CorsPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_CorsPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.allowOrigins.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.allowOriginRegexes.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.allowMethods.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.allowHeaders.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.exposeHeaders.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.maxAge = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.allowCredentials = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.disabled = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_CorsPolicy {
    return {
      allowOrigins: globalThis.Array.isArray(object?.allowOrigins)
        ? object.allowOrigins.map((e: any) => globalThis.String(e))
        : [],
      allowOriginRegexes: globalThis.Array.isArray(object?.allowOriginRegexes)
        ? object.allowOriginRegexes.map((e: any) => globalThis.String(e))
        : [],
      allowMethods: globalThis.Array.isArray(object?.allowMethods)
        ? object.allowMethods.map((e: any) => globalThis.String(e))
        : [],
      allowHeaders: globalThis.Array.isArray(object?.allowHeaders)
        ? object.allowHeaders.map((e: any) => globalThis.String(e))
        : [],
      exposeHeaders: globalThis.Array.isArray(object?.exposeHeaders)
        ? object.exposeHeaders.map((e: any) => globalThis.String(e))
        : [],
      maxAge: isSet(object.maxAge) ? globalThis.String(object.maxAge) : "",
      allowCredentials: isSet(object.allowCredentials) ? globalThis.Boolean(object.allowCredentials) : false,
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
    };
  },

  toJSON(message: HttpRoute_CorsPolicy): unknown {
    const obj: any = {};
    if (message.allowOrigins?.length) {
      obj.allowOrigins = message.allowOrigins;
    }
    if (message.allowOriginRegexes?.length) {
      obj.allowOriginRegexes = message.allowOriginRegexes;
    }
    if (message.allowMethods?.length) {
      obj.allowMethods = message.allowMethods;
    }
    if (message.allowHeaders?.length) {
      obj.allowHeaders = message.allowHeaders;
    }
    if (message.exposeHeaders?.length) {
      obj.exposeHeaders = message.exposeHeaders;
    }
    if (message.maxAge !== "") {
      obj.maxAge = message.maxAge;
    }
    if (message.allowCredentials !== false) {
      obj.allowCredentials = message.allowCredentials;
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_CorsPolicy>): HttpRoute_CorsPolicy {
    return HttpRoute_CorsPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_CorsPolicy>): HttpRoute_CorsPolicy {
    const message = createBaseHttpRoute_CorsPolicy();
    message.allowOrigins = object.allowOrigins?.map((e) => e) || [];
    message.allowOriginRegexes = object.allowOriginRegexes?.map((e) => e) || [];
    message.allowMethods = object.allowMethods?.map((e) => e) || [];
    message.allowHeaders = object.allowHeaders?.map((e) => e) || [];
    message.exposeHeaders = object.exposeHeaders?.map((e) => e) || [];
    message.maxAge = object.maxAge ?? "";
    message.allowCredentials = object.allowCredentials ?? false;
    message.disabled = object.disabled ?? false;
    return message;
  },
};

function createBaseHttpRoute_RouteAction(): HttpRoute_RouteAction {
  return {
    destinations: [],
    redirect: undefined,
    faultInjectionPolicy: undefined,
    requestHeaderModifier: undefined,
    responseHeaderModifier: undefined,
    urlRewrite: undefined,
    timeout: undefined,
    retryPolicy: undefined,
    requestMirrorPolicy: undefined,
    corsPolicy: undefined,
  };
}

export const HttpRoute_RouteAction: MessageFns<HttpRoute_RouteAction> = {
  encode(message: HttpRoute_RouteAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.destinations) {
      HttpRoute_Destination.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.redirect !== undefined) {
      HttpRoute_Redirect.encode(message.redirect, writer.uint32(18).fork()).join();
    }
    if (message.faultInjectionPolicy !== undefined) {
      HttpRoute_FaultInjectionPolicy.encode(message.faultInjectionPolicy, writer.uint32(34).fork()).join();
    }
    if (message.requestHeaderModifier !== undefined) {
      HttpRoute_HeaderModifier.encode(message.requestHeaderModifier, writer.uint32(42).fork()).join();
    }
    if (message.responseHeaderModifier !== undefined) {
      HttpRoute_HeaderModifier.encode(message.responseHeaderModifier, writer.uint32(50).fork()).join();
    }
    if (message.urlRewrite !== undefined) {
      HttpRoute_URLRewrite.encode(message.urlRewrite, writer.uint32(58).fork()).join();
    }
    if (message.timeout !== undefined) {
      Duration.encode(message.timeout, writer.uint32(66).fork()).join();
    }
    if (message.retryPolicy !== undefined) {
      HttpRoute_RetryPolicy.encode(message.retryPolicy, writer.uint32(74).fork()).join();
    }
    if (message.requestMirrorPolicy !== undefined) {
      HttpRoute_RequestMirrorPolicy.encode(message.requestMirrorPolicy, writer.uint32(82).fork()).join();
    }
    if (message.corsPolicy !== undefined) {
      HttpRoute_CorsPolicy.encode(message.corsPolicy, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_RouteAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_RouteAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.destinations.push(HttpRoute_Destination.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.redirect = HttpRoute_Redirect.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.faultInjectionPolicy = HttpRoute_FaultInjectionPolicy.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.requestHeaderModifier = HttpRoute_HeaderModifier.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.responseHeaderModifier = HttpRoute_HeaderModifier.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.urlRewrite = HttpRoute_URLRewrite.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.timeout = Duration.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.retryPolicy = HttpRoute_RetryPolicy.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.requestMirrorPolicy = HttpRoute_RequestMirrorPolicy.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.corsPolicy = HttpRoute_CorsPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_RouteAction {
    return {
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => HttpRoute_Destination.fromJSON(e))
        : [],
      redirect: isSet(object.redirect) ? HttpRoute_Redirect.fromJSON(object.redirect) : undefined,
      faultInjectionPolicy: isSet(object.faultInjectionPolicy)
        ? HttpRoute_FaultInjectionPolicy.fromJSON(object.faultInjectionPolicy)
        : undefined,
      requestHeaderModifier: isSet(object.requestHeaderModifier)
        ? HttpRoute_HeaderModifier.fromJSON(object.requestHeaderModifier)
        : undefined,
      responseHeaderModifier: isSet(object.responseHeaderModifier)
        ? HttpRoute_HeaderModifier.fromJSON(object.responseHeaderModifier)
        : undefined,
      urlRewrite: isSet(object.urlRewrite) ? HttpRoute_URLRewrite.fromJSON(object.urlRewrite) : undefined,
      timeout: isSet(object.timeout) ? Duration.fromJSON(object.timeout) : undefined,
      retryPolicy: isSet(object.retryPolicy) ? HttpRoute_RetryPolicy.fromJSON(object.retryPolicy) : undefined,
      requestMirrorPolicy: isSet(object.requestMirrorPolicy)
        ? HttpRoute_RequestMirrorPolicy.fromJSON(object.requestMirrorPolicy)
        : undefined,
      corsPolicy: isSet(object.corsPolicy) ? HttpRoute_CorsPolicy.fromJSON(object.corsPolicy) : undefined,
    };
  },

  toJSON(message: HttpRoute_RouteAction): unknown {
    const obj: any = {};
    if (message.destinations?.length) {
      obj.destinations = message.destinations.map((e) => HttpRoute_Destination.toJSON(e));
    }
    if (message.redirect !== undefined) {
      obj.redirect = HttpRoute_Redirect.toJSON(message.redirect);
    }
    if (message.faultInjectionPolicy !== undefined) {
      obj.faultInjectionPolicy = HttpRoute_FaultInjectionPolicy.toJSON(message.faultInjectionPolicy);
    }
    if (message.requestHeaderModifier !== undefined) {
      obj.requestHeaderModifier = HttpRoute_HeaderModifier.toJSON(message.requestHeaderModifier);
    }
    if (message.responseHeaderModifier !== undefined) {
      obj.responseHeaderModifier = HttpRoute_HeaderModifier.toJSON(message.responseHeaderModifier);
    }
    if (message.urlRewrite !== undefined) {
      obj.urlRewrite = HttpRoute_URLRewrite.toJSON(message.urlRewrite);
    }
    if (message.timeout !== undefined) {
      obj.timeout = Duration.toJSON(message.timeout);
    }
    if (message.retryPolicy !== undefined) {
      obj.retryPolicy = HttpRoute_RetryPolicy.toJSON(message.retryPolicy);
    }
    if (message.requestMirrorPolicy !== undefined) {
      obj.requestMirrorPolicy = HttpRoute_RequestMirrorPolicy.toJSON(message.requestMirrorPolicy);
    }
    if (message.corsPolicy !== undefined) {
      obj.corsPolicy = HttpRoute_CorsPolicy.toJSON(message.corsPolicy);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_RouteAction>): HttpRoute_RouteAction {
    return HttpRoute_RouteAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_RouteAction>): HttpRoute_RouteAction {
    const message = createBaseHttpRoute_RouteAction();
    message.destinations = object.destinations?.map((e) => HttpRoute_Destination.fromPartial(e)) || [];
    message.redirect = (object.redirect !== undefined && object.redirect !== null)
      ? HttpRoute_Redirect.fromPartial(object.redirect)
      : undefined;
    message.faultInjectionPolicy = (object.faultInjectionPolicy !== undefined && object.faultInjectionPolicy !== null)
      ? HttpRoute_FaultInjectionPolicy.fromPartial(object.faultInjectionPolicy)
      : undefined;
    message.requestHeaderModifier =
      (object.requestHeaderModifier !== undefined && object.requestHeaderModifier !== null)
        ? HttpRoute_HeaderModifier.fromPartial(object.requestHeaderModifier)
        : undefined;
    message.responseHeaderModifier =
      (object.responseHeaderModifier !== undefined && object.responseHeaderModifier !== null)
        ? HttpRoute_HeaderModifier.fromPartial(object.responseHeaderModifier)
        : undefined;
    message.urlRewrite = (object.urlRewrite !== undefined && object.urlRewrite !== null)
      ? HttpRoute_URLRewrite.fromPartial(object.urlRewrite)
      : undefined;
    message.timeout = (object.timeout !== undefined && object.timeout !== null)
      ? Duration.fromPartial(object.timeout)
      : undefined;
    message.retryPolicy = (object.retryPolicy !== undefined && object.retryPolicy !== null)
      ? HttpRoute_RetryPolicy.fromPartial(object.retryPolicy)
      : undefined;
    message.requestMirrorPolicy = (object.requestMirrorPolicy !== undefined && object.requestMirrorPolicy !== null)
      ? HttpRoute_RequestMirrorPolicy.fromPartial(object.requestMirrorPolicy)
      : undefined;
    message.corsPolicy = (object.corsPolicy !== undefined && object.corsPolicy !== null)
      ? HttpRoute_CorsPolicy.fromPartial(object.corsPolicy)
      : undefined;
    return message;
  },
};

function createBaseHttpRoute_RouteRule(): HttpRoute_RouteRule {
  return { matches: [], action: undefined };
}

export const HttpRoute_RouteRule: MessageFns<HttpRoute_RouteRule> = {
  encode(message: HttpRoute_RouteRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.matches) {
      HttpRoute_RouteMatch.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.action !== undefined) {
      HttpRoute_RouteAction.encode(message.action, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_RouteRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_RouteRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.matches.push(HttpRoute_RouteMatch.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.action = HttpRoute_RouteAction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_RouteRule {
    return {
      matches: globalThis.Array.isArray(object?.matches)
        ? object.matches.map((e: any) => HttpRoute_RouteMatch.fromJSON(e))
        : [],
      action: isSet(object.action) ? HttpRoute_RouteAction.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: HttpRoute_RouteRule): unknown {
    const obj: any = {};
    if (message.matches?.length) {
      obj.matches = message.matches.map((e) => HttpRoute_RouteMatch.toJSON(e));
    }
    if (message.action !== undefined) {
      obj.action = HttpRoute_RouteAction.toJSON(message.action);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_RouteRule>): HttpRoute_RouteRule {
    return HttpRoute_RouteRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_RouteRule>): HttpRoute_RouteRule {
    const message = createBaseHttpRoute_RouteRule();
    message.matches = object.matches?.map((e) => HttpRoute_RouteMatch.fromPartial(e)) || [];
    message.action = (object.action !== undefined && object.action !== null)
      ? HttpRoute_RouteAction.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseHttpRoute_LabelsEntry(): HttpRoute_LabelsEntry {
  return { key: "", value: "" };
}

export const HttpRoute_LabelsEntry: MessageFns<HttpRoute_LabelsEntry> = {
  encode(message: HttpRoute_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpRoute_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpRoute_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpRoute_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HttpRoute_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HttpRoute_LabelsEntry>): HttpRoute_LabelsEntry {
    return HttpRoute_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpRoute_LabelsEntry>): HttpRoute_LabelsEntry {
    const message = createBaseHttpRoute_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListHttpRoutesRequest(): ListHttpRoutesRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListHttpRoutesRequest: MessageFns<ListHttpRoutesRequest> = {
  encode(message: ListHttpRoutesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHttpRoutesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHttpRoutesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHttpRoutesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListHttpRoutesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListHttpRoutesRequest>): ListHttpRoutesRequest {
    return ListHttpRoutesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListHttpRoutesRequest>): ListHttpRoutesRequest {
    const message = createBaseListHttpRoutesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListHttpRoutesResponse(): ListHttpRoutesResponse {
  return { httpRoutes: [], nextPageToken: "" };
}

export const ListHttpRoutesResponse: MessageFns<ListHttpRoutesResponse> = {
  encode(message: ListHttpRoutesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.httpRoutes) {
      HttpRoute.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHttpRoutesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHttpRoutesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.httpRoutes.push(HttpRoute.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHttpRoutesResponse {
    return {
      httpRoutes: globalThis.Array.isArray(object?.httpRoutes)
        ? object.httpRoutes.map((e: any) => HttpRoute.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListHttpRoutesResponse): unknown {
    const obj: any = {};
    if (message.httpRoutes?.length) {
      obj.httpRoutes = message.httpRoutes.map((e) => HttpRoute.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListHttpRoutesResponse>): ListHttpRoutesResponse {
    return ListHttpRoutesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListHttpRoutesResponse>): ListHttpRoutesResponse {
    const message = createBaseListHttpRoutesResponse();
    message.httpRoutes = object.httpRoutes?.map((e) => HttpRoute.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetHttpRouteRequest(): GetHttpRouteRequest {
  return { name: "" };
}

export const GetHttpRouteRequest: MessageFns<GetHttpRouteRequest> = {
  encode(message: GetHttpRouteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHttpRouteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHttpRouteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHttpRouteRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetHttpRouteRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetHttpRouteRequest>): GetHttpRouteRequest {
    return GetHttpRouteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetHttpRouteRequest>): GetHttpRouteRequest {
    const message = createBaseGetHttpRouteRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateHttpRouteRequest(): CreateHttpRouteRequest {
  return { parent: "", httpRouteId: "", httpRoute: undefined };
}

export const CreateHttpRouteRequest: MessageFns<CreateHttpRouteRequest> = {
  encode(message: CreateHttpRouteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.httpRouteId !== "") {
      writer.uint32(18).string(message.httpRouteId);
    }
    if (message.httpRoute !== undefined) {
      HttpRoute.encode(message.httpRoute, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateHttpRouteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateHttpRouteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.httpRouteId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.httpRoute = HttpRoute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateHttpRouteRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      httpRouteId: isSet(object.httpRouteId) ? globalThis.String(object.httpRouteId) : "",
      httpRoute: isSet(object.httpRoute) ? HttpRoute.fromJSON(object.httpRoute) : undefined,
    };
  },

  toJSON(message: CreateHttpRouteRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.httpRouteId !== "") {
      obj.httpRouteId = message.httpRouteId;
    }
    if (message.httpRoute !== undefined) {
      obj.httpRoute = HttpRoute.toJSON(message.httpRoute);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateHttpRouteRequest>): CreateHttpRouteRequest {
    return CreateHttpRouteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateHttpRouteRequest>): CreateHttpRouteRequest {
    const message = createBaseCreateHttpRouteRequest();
    message.parent = object.parent ?? "";
    message.httpRouteId = object.httpRouteId ?? "";
    message.httpRoute = (object.httpRoute !== undefined && object.httpRoute !== null)
      ? HttpRoute.fromPartial(object.httpRoute)
      : undefined;
    return message;
  },
};

function createBaseUpdateHttpRouteRequest(): UpdateHttpRouteRequest {
  return { updateMask: undefined, httpRoute: undefined };
}

export const UpdateHttpRouteRequest: MessageFns<UpdateHttpRouteRequest> = {
  encode(message: UpdateHttpRouteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.httpRoute !== undefined) {
      HttpRoute.encode(message.httpRoute, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateHttpRouteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateHttpRouteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.httpRoute = HttpRoute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateHttpRouteRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      httpRoute: isSet(object.httpRoute) ? HttpRoute.fromJSON(object.httpRoute) : undefined,
    };
  },

  toJSON(message: UpdateHttpRouteRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.httpRoute !== undefined) {
      obj.httpRoute = HttpRoute.toJSON(message.httpRoute);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateHttpRouteRequest>): UpdateHttpRouteRequest {
    return UpdateHttpRouteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateHttpRouteRequest>): UpdateHttpRouteRequest {
    const message = createBaseUpdateHttpRouteRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.httpRoute = (object.httpRoute !== undefined && object.httpRoute !== null)
      ? HttpRoute.fromPartial(object.httpRoute)
      : undefined;
    return message;
  },
};

function createBaseDeleteHttpRouteRequest(): DeleteHttpRouteRequest {
  return { name: "" };
}

export const DeleteHttpRouteRequest: MessageFns<DeleteHttpRouteRequest> = {
  encode(message: DeleteHttpRouteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteHttpRouteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteHttpRouteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteHttpRouteRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteHttpRouteRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteHttpRouteRequest>): DeleteHttpRouteRequest {
    return DeleteHttpRouteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteHttpRouteRequest>): DeleteHttpRouteRequest {
    const message = createBaseDeleteHttpRouteRequest();
    message.name = object.name ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
