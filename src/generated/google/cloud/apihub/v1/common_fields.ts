// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/apihub/v1/common_fields.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.apihub.v1";

/** Lint state represents success or failure for linting. */
export enum LintState {
  /** LINT_STATE_UNSPECIFIED - Lint state unspecified. */
  LINT_STATE_UNSPECIFIED = 0,
  /** LINT_STATE_SUCCESS - Linting was completed successfully. */
  LINT_STATE_SUCCESS = 1,
  /** LINT_STATE_ERROR - Linting encountered errors. */
  LINT_STATE_ERROR = 2,
  UNRECOGNIZED = -1,
}

export function lintStateFromJSON(object: any): LintState {
  switch (object) {
    case 0:
    case "LINT_STATE_UNSPECIFIED":
      return LintState.LINT_STATE_UNSPECIFIED;
    case 1:
    case "LINT_STATE_SUCCESS":
      return LintState.LINT_STATE_SUCCESS;
    case 2:
    case "LINT_STATE_ERROR":
      return LintState.LINT_STATE_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LintState.UNRECOGNIZED;
  }
}

export function lintStateToJSON(object: LintState): string {
  switch (object) {
    case LintState.LINT_STATE_UNSPECIFIED:
      return "LINT_STATE_UNSPECIFIED";
    case LintState.LINT_STATE_SUCCESS:
      return "LINT_STATE_SUCCESS";
    case LintState.LINT_STATE_ERROR:
      return "LINT_STATE_ERROR";
    case LintState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enumeration of linter types. */
export enum Linter {
  /** LINTER_UNSPECIFIED - Linter type unspecified. */
  LINTER_UNSPECIFIED = 0,
  /** SPECTRAL - Linter type spectral. */
  SPECTRAL = 1,
  /** OTHER - Linter type other. */
  OTHER = 2,
  UNRECOGNIZED = -1,
}

export function linterFromJSON(object: any): Linter {
  switch (object) {
    case 0:
    case "LINTER_UNSPECIFIED":
      return Linter.LINTER_UNSPECIFIED;
    case 1:
    case "SPECTRAL":
      return Linter.SPECTRAL;
    case 2:
    case "OTHER":
      return Linter.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Linter.UNRECOGNIZED;
  }
}

export function linterToJSON(object: Linter): string {
  switch (object) {
    case Linter.LINTER_UNSPECIFIED:
      return "LINTER_UNSPECIFIED";
    case Linter.SPECTRAL:
      return "SPECTRAL";
    case Linter.OTHER:
      return "OTHER";
    case Linter.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Severity of the issue. */
export enum Severity {
  /** SEVERITY_UNSPECIFIED - Severity unspecified. */
  SEVERITY_UNSPECIFIED = 0,
  /** SEVERITY_ERROR - Severity error. */
  SEVERITY_ERROR = 1,
  /** SEVERITY_WARNING - Severity warning. */
  SEVERITY_WARNING = 2,
  /** SEVERITY_INFO - Severity info. */
  SEVERITY_INFO = 3,
  /** SEVERITY_HINT - Severity hint. */
  SEVERITY_HINT = 4,
  UNRECOGNIZED = -1,
}

export function severityFromJSON(object: any): Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNSPECIFIED":
      return Severity.SEVERITY_UNSPECIFIED;
    case 1:
    case "SEVERITY_ERROR":
      return Severity.SEVERITY_ERROR;
    case 2:
    case "SEVERITY_WARNING":
      return Severity.SEVERITY_WARNING;
    case 3:
    case "SEVERITY_INFO":
      return Severity.SEVERITY_INFO;
    case 4:
    case "SEVERITY_HINT":
      return Severity.SEVERITY_HINT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Severity.UNRECOGNIZED;
  }
}

export function severityToJSON(object: Severity): string {
  switch (object) {
    case Severity.SEVERITY_UNSPECIFIED:
      return "SEVERITY_UNSPECIFIED";
    case Severity.SEVERITY_ERROR:
      return "SEVERITY_ERROR";
    case Severity.SEVERITY_WARNING:
      return "SEVERITY_WARNING";
    case Severity.SEVERITY_INFO:
      return "SEVERITY_INFO";
    case Severity.SEVERITY_HINT:
      return "SEVERITY_HINT";
    case Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An API resource in the API Hub. */
export interface Api {
  /**
   * Identifier. The name of the API resource in the API Hub.
   *
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}`
   */
  name: string;
  /** Required. The display name of the API resource. */
  displayName: string;
  /** Optional. The description of the API resource. */
  description: string;
  /** Optional. The documentation for the API resource. */
  documentation:
    | Documentation
    | undefined;
  /** Optional. Owner details for the API resource. */
  owner:
    | Owner
    | undefined;
  /**
   * Output only. The list of versions present in an API resource.
   * Note: An API resource can be associated with more than 1 version.
   * Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
   */
  versions: string[];
  /** Output only. The time at which the API resource was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which the API resource was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. The target users for the API.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-target-user`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  targetUser:
    | AttributeValues
    | undefined;
  /**
   * Optional. The team owning the API.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-team`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  team:
    | AttributeValues
    | undefined;
  /**
   * Optional. The business unit owning the API.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-business-unit`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  businessUnit:
    | AttributeValues
    | undefined;
  /**
   * Optional. The maturity level of the API.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-maturity-level`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  maturityLevel:
    | AttributeValues
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the API
   * resource. The key is the attribute name. It will be of the format:
   * `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
  /**
   * Optional. The style of the API.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-api-style`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  apiStyle:
    | AttributeValues
    | undefined;
  /**
   * Optional. The selected version for an API resource.
   * This can be used when special handling is needed on client side for
   * particular version of the API. Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
   */
  selectedVersion: string;
}

export interface Api_AttributesEntry {
  key: string;
  value: AttributeValues | undefined;
}

/**
 * Represents a version of the API resource in API hub. This is also referred
 * to as the API version.
 */
export interface Version {
  /**
   * Identifier. The name of the version.
   *
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}`
   */
  name: string;
  /** Required. The display name of the version. */
  displayName: string;
  /** Optional. The description of the version. */
  description: string;
  /** Optional. The documentation of the version. */
  documentation:
    | Documentation
    | undefined;
  /**
   * Output only. The specs associated with this version.
   * Note that an API version can be associated with multiple specs.
   * Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
   */
  specs: string[];
  /**
   * Output only. The operations contained in the API version.
   * These operations will be added to the version when a new spec is
   * added or when an existing spec is updated. Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
   */
  apiOperations: string[];
  /**
   * Output only. The definitions contained in the API version.
   * These definitions will be added to the version when a new spec is
   * added or when an existing spec is updated. Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/definitions/{definition}`
   */
  definitions: string[];
  /**
   * Optional. The deployments linked to this API version.
   * Note: A particular API version could be deployed to multiple deployments
   * (for dev deployment, UAT deployment, etc)
   * Format is
   * `projects/{project}/locations/{location}/deployments/{deployment}`
   */
  deployments: string[];
  /** Output only. The time at which the version was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which the version was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. The lifecycle of the API version.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-lifecycle`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  lifecycle:
    | AttributeValues
    | undefined;
  /**
   * Optional. The compliance associated with the API version.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-compliance`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  compliance:
    | AttributeValues
    | undefined;
  /**
   * Optional. The accreditations associated with the API version.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-accreditation`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  accreditation:
    | AttributeValues
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the Version
   * resource. The key is the attribute name. It will be of the format:
   * `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
  /**
   * Optional. The selected deployment for a Version resource.
   * This can be used when special handling is needed on client side for a
   * particular deployment linked to the version.
   * Format is
   * `projects/{project}/locations/{location}/deployments/{deployment}`
   */
  selectedDeployment: string;
}

export interface Version_AttributesEntry {
  key: string;
  value: AttributeValues | undefined;
}

/**
 * Represents a spec associated with an API version in the API
 * Hub. Note that specs of various types can be uploaded, however
 * parsing of details is supported for OpenAPI spec currently.
 */
export interface Spec {
  /**
   * Identifier. The name of the spec.
   *
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
   */
  name: string;
  /**
   * Required. The display name of the spec.
   * This can contain the file name of the spec.
   */
  displayName: string;
  /**
   * Required. The type of spec.
   * The value should be one of the allowed values defined for
   * `projects/{project}/locations/{location}/attributes/system-spec-type`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API.
   *
   * Note, this field is mandatory if content is provided.
   */
  specType:
    | AttributeValues
    | undefined;
  /** Optional. Input only. The contents of the uploaded spec. */
  contents:
    | SpecContents
    | undefined;
  /** Output only. Details parsed from the spec. */
  details:
    | SpecDetails
    | undefined;
  /**
   * Optional. The URI of the spec source in case file is uploaded
   * from an external version control system.
   */
  sourceUri: string;
  /** Output only. The time at which the spec was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which the spec was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. The lint response for the spec. */
  lintResponse:
    | LintResponse
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the spec.
   * The key is the attribute name. It will be of the format:
   * `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
  /**
   * Optional. The documentation of the spec.
   * For OpenAPI spec, this will be populated from `externalDocs` in OpenAPI
   * spec.
   */
  documentation:
    | Documentation
    | undefined;
  /**
   * Optional. Input only. Enum specifying the parsing mode for OpenAPI
   * Specification (OAS) parsing.
   */
  parsingMode: Spec_ParsingMode;
}

/**
 * Specifies the parsing mode for API specifications during creation and
 * update.
 * - `RELAXED`: Parsing errors in the specification content do not fail the
 * API call.
 * - `STRICT`: Parsing errors in the specification content result in failure
 * of the API call.
 * If not specified, defaults to `RELAXED`.
 */
export enum Spec_ParsingMode {
  /** PARSING_MODE_UNSPECIFIED - Defaults to `RELAXED`. */
  PARSING_MODE_UNSPECIFIED = 0,
  /**
   * RELAXED - Parsing of the Spec on create and update is relaxed, meaning that
   * parsing errors the spec contents will not fail the API call.
   */
  RELAXED = 1,
  /**
   * STRICT - Parsing of the Spec on create and update is strict, meaning that
   * parsing errors in the spec contents will fail the API call.
   */
  STRICT = 2,
  UNRECOGNIZED = -1,
}

export function spec_ParsingModeFromJSON(object: any): Spec_ParsingMode {
  switch (object) {
    case 0:
    case "PARSING_MODE_UNSPECIFIED":
      return Spec_ParsingMode.PARSING_MODE_UNSPECIFIED;
    case 1:
    case "RELAXED":
      return Spec_ParsingMode.RELAXED;
    case 2:
    case "STRICT":
      return Spec_ParsingMode.STRICT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Spec_ParsingMode.UNRECOGNIZED;
  }
}

export function spec_ParsingModeToJSON(object: Spec_ParsingMode): string {
  switch (object) {
    case Spec_ParsingMode.PARSING_MODE_UNSPECIFIED:
      return "PARSING_MODE_UNSPECIFIED";
    case Spec_ParsingMode.RELAXED:
      return "RELAXED";
    case Spec_ParsingMode.STRICT:
      return "STRICT";
    case Spec_ParsingMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Spec_AttributesEntry {
  key: string;
  value: AttributeValues | undefined;
}

/**
 * Details of the deployment where APIs are hosted.
 * A deployment could represent an Apigee proxy, API gateway, other Google Cloud
 * services or non-Google Cloud services as well. A deployment entity is a root
 * level entity in the API hub and exists independent of any API.
 */
export interface Deployment {
  /**
   * Identifier. The name of the deployment.
   *
   * Format:
   * `projects/{project}/locations/{location}/deployments/{deployment}`
   */
  name: string;
  /** Required. The display name of the deployment. */
  displayName: string;
  /** Optional. The description of the deployment. */
  description: string;
  /** Optional. The documentation of the deployment. */
  documentation:
    | Documentation
    | undefined;
  /**
   * Required. The type of deployment.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-deployment-type`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  deploymentType:
    | AttributeValues
    | undefined;
  /**
   * Required. A URI to the runtime resource. This URI can be used to manage the
   * resource. For example, if the runtime resource is of type APIGEE_PROXY,
   * then this field will contain the URI to the management UI of the proxy.
   */
  resourceUri: string;
  /**
   * Required. The endpoints at which this deployment resource is listening for
   * API requests. This could be a list of complete URIs, hostnames or an IP
   * addresses.
   */
  endpoints: string[];
  /**
   * Output only. The API versions linked to this deployment.
   * Note: A particular deployment could be linked to multiple different API
   * versions (of same or different APIs).
   */
  apiVersions: string[];
  /** Output only. The time at which the deployment was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which the deployment was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. The SLO for this deployment.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-slo`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  slo:
    | AttributeValues
    | undefined;
  /**
   * Optional. The environment mapping to this deployment.
   * This maps to the following system defined attribute:
   * `projects/{project}/locations/{location}/attributes/system-environment`
   * attribute.
   * The number of values for this attribute will be based on the
   * cardinality of the attribute. The same can be retrieved via GetAttribute
   * API. All values should be from the list of allowed values defined for the
   * attribute.
   */
  environment:
    | AttributeValues
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the
   * deployment resource. The key is the attribute name. It will be of the
   * format: `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
}

export interface Deployment_AttributesEntry {
  key: string;
  value: AttributeValues | undefined;
}

/**
 * Represents an operation contained in an API version in the API Hub.
 * An operation is added/updated/deleted in an API version when a new spec is
 * added or an existing spec is updated/deleted in a version.
 * Currently, an operation will be created only corresponding to OpenAPI spec as
 * parsing is supported for OpenAPI spec.
 */
export interface ApiOperation {
  /**
   * Identifier. The name of the operation.
   *
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
   */
  name: string;
  /**
   * Output only. The name of the spec from where the operation was parsed.
   * Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
   */
  spec: string;
  /** Output only. Operation details. */
  details:
    | OperationDetails
    | undefined;
  /** Output only. The time at which the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which the operation was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the API
   * operation resource. The key is the attribute name. It will be of the
   * format: `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
}

export interface ApiOperation_AttributesEntry {
  key: string;
  value: AttributeValues | undefined;
}

/**
 * Represents a definition for example schema, request, response definitions
 * contained in an API version.
 * A definition is added/updated/deleted in an API version when a new spec is
 * added or an existing spec is updated/deleted in a version. Currently,
 * definition will be created only corresponding to OpenAPI spec as parsing is
 * supported for OpenAPI spec. Also, within OpenAPI spec, only `schema` object
 * is supported.
 */
export interface Definition {
  /** Output only. The value of a schema definition. */
  schema?:
    | Schema
    | undefined;
  /**
   * Identifier. The name of the definition.
   *
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/definitions/{definition}`
   */
  name: string;
  /**
   * Output only. The name of the spec from where the definition was parsed.
   * Format is
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/specs/{spec}`
   */
  spec: string;
  /** Output only. The type of the definition. */
  type: Definition_Type;
  /** Output only. The time at which the definition was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which the definition was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the
   * definition resource. The key is the attribute name. It will be of the
   * format: `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
}

/** Enumeration of definition types. */
export enum Definition_Type {
  /** TYPE_UNSPECIFIED - Definition type unspecified. */
  TYPE_UNSPECIFIED = 0,
  /** SCHEMA - Definition type schema. */
  SCHEMA = 1,
  UNRECOGNIZED = -1,
}

export function definition_TypeFromJSON(object: any): Definition_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Definition_Type.TYPE_UNSPECIFIED;
    case 1:
    case "SCHEMA":
      return Definition_Type.SCHEMA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Definition_Type.UNRECOGNIZED;
  }
}

export function definition_TypeToJSON(object: Definition_Type): string {
  switch (object) {
    case Definition_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Definition_Type.SCHEMA:
      return "SCHEMA";
    case Definition_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Definition_AttributesEntry {
  key: string;
  value: AttributeValues | undefined;
}

/**
 * An attribute in the API Hub.
 * An attribute is a name value pair which can be attached to different
 * resources in the API hub based on the scope of the attribute. Attributes can
 * either be pre-defined by the API Hub or created by users.
 */
export interface Attribute {
  /**
   * Identifier. The name of the attribute in the API Hub.
   *
   * Format:
   * `projects/{project}/locations/{location}/attributes/{attribute}`
   */
  name: string;
  /** Required. The display name of the attribute. */
  displayName: string;
  /** Optional. The description of the attribute. */
  description: string;
  /** Output only. The definition type of the attribute. */
  definitionType: Attribute_DefinitionType;
  /**
   * Required. The scope of the attribute. It represents the resource in the API
   * Hub to which the attribute can be linked.
   */
  scope: Attribute_Scope;
  /** Required. The type of the data of the attribute. */
  dataType: Attribute_DataType;
  /**
   * Optional. The list of allowed values when the attribute value is of type
   * enum. This is required when the data_type of the attribute is ENUM. The
   * maximum number of allowed values of an attribute will be 1000.
   */
  allowedValues: Attribute_AllowedValue[];
  /**
   * Optional. The maximum number of values that the attribute can have when
   * associated with an API Hub resource. Cardinality 1 would represent a
   * single-valued attribute. It must not be less than 1 or greater than 20. If
   * not specified, the cardinality would be set to 1 by default and represent a
   * single-valued attribute.
   */
  cardinality: number;
  /**
   * Output only. When mandatory is true, the attribute is mandatory for the
   * resource specified in the scope. Only System defined attributes can be
   * mandatory.
   */
  mandatory: boolean;
  /** Output only. The time at which the attribute was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which the attribute was last updated. */
  updateTime: Date | undefined;
}

/** Enumeration of attribute definition types. */
export enum Attribute_DefinitionType {
  /** DEFINITION_TYPE_UNSPECIFIED - Attribute definition type unspecified. */
  DEFINITION_TYPE_UNSPECIFIED = 0,
  /**
   * SYSTEM_DEFINED - The attribute is predefined by the API Hub. Note that only the list of
   * allowed values can be updated in this case via UpdateAttribute method.
   */
  SYSTEM_DEFINED = 1,
  /** USER_DEFINED - The attribute is defined by the user. */
  USER_DEFINED = 2,
  UNRECOGNIZED = -1,
}

export function attribute_DefinitionTypeFromJSON(object: any): Attribute_DefinitionType {
  switch (object) {
    case 0:
    case "DEFINITION_TYPE_UNSPECIFIED":
      return Attribute_DefinitionType.DEFINITION_TYPE_UNSPECIFIED;
    case 1:
    case "SYSTEM_DEFINED":
      return Attribute_DefinitionType.SYSTEM_DEFINED;
    case 2:
    case "USER_DEFINED":
      return Attribute_DefinitionType.USER_DEFINED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Attribute_DefinitionType.UNRECOGNIZED;
  }
}

export function attribute_DefinitionTypeToJSON(object: Attribute_DefinitionType): string {
  switch (object) {
    case Attribute_DefinitionType.DEFINITION_TYPE_UNSPECIFIED:
      return "DEFINITION_TYPE_UNSPECIFIED";
    case Attribute_DefinitionType.SYSTEM_DEFINED:
      return "SYSTEM_DEFINED";
    case Attribute_DefinitionType.USER_DEFINED:
      return "USER_DEFINED";
    case Attribute_DefinitionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Enumeration for the scope of the attribute representing the resource in the
 * API Hub to which the attribute can be linked.
 */
export enum Attribute_Scope {
  /** SCOPE_UNSPECIFIED - Scope Unspecified. */
  SCOPE_UNSPECIFIED = 0,
  /** API - Attribute can be linked to an API. */
  API = 1,
  /** VERSION - Attribute can be linked to an API version. */
  VERSION = 2,
  /** SPEC - Attribute can be linked to a Spec. */
  SPEC = 3,
  /** API_OPERATION - Attribute can be linked to an API Operation. */
  API_OPERATION = 4,
  /** DEPLOYMENT - Attribute can be linked to a Deployment. */
  DEPLOYMENT = 5,
  /** DEPENDENCY - Attribute can be linked to a Dependency. */
  DEPENDENCY = 6,
  /** DEFINITION - Attribute can be linked to a definition. */
  DEFINITION = 7,
  /** EXTERNAL_API - Attribute can be linked to a ExternalAPI. */
  EXTERNAL_API = 8,
  /** PLUGIN - Attribute can be linked to a Plugin. */
  PLUGIN = 9,
  UNRECOGNIZED = -1,
}

export function attribute_ScopeFromJSON(object: any): Attribute_Scope {
  switch (object) {
    case 0:
    case "SCOPE_UNSPECIFIED":
      return Attribute_Scope.SCOPE_UNSPECIFIED;
    case 1:
    case "API":
      return Attribute_Scope.API;
    case 2:
    case "VERSION":
      return Attribute_Scope.VERSION;
    case 3:
    case "SPEC":
      return Attribute_Scope.SPEC;
    case 4:
    case "API_OPERATION":
      return Attribute_Scope.API_OPERATION;
    case 5:
    case "DEPLOYMENT":
      return Attribute_Scope.DEPLOYMENT;
    case 6:
    case "DEPENDENCY":
      return Attribute_Scope.DEPENDENCY;
    case 7:
    case "DEFINITION":
      return Attribute_Scope.DEFINITION;
    case 8:
    case "EXTERNAL_API":
      return Attribute_Scope.EXTERNAL_API;
    case 9:
    case "PLUGIN":
      return Attribute_Scope.PLUGIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Attribute_Scope.UNRECOGNIZED;
  }
}

export function attribute_ScopeToJSON(object: Attribute_Scope): string {
  switch (object) {
    case Attribute_Scope.SCOPE_UNSPECIFIED:
      return "SCOPE_UNSPECIFIED";
    case Attribute_Scope.API:
      return "API";
    case Attribute_Scope.VERSION:
      return "VERSION";
    case Attribute_Scope.SPEC:
      return "SPEC";
    case Attribute_Scope.API_OPERATION:
      return "API_OPERATION";
    case Attribute_Scope.DEPLOYMENT:
      return "DEPLOYMENT";
    case Attribute_Scope.DEPENDENCY:
      return "DEPENDENCY";
    case Attribute_Scope.DEFINITION:
      return "DEFINITION";
    case Attribute_Scope.EXTERNAL_API:
      return "EXTERNAL_API";
    case Attribute_Scope.PLUGIN:
      return "PLUGIN";
    case Attribute_Scope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Enumeration of attribute's data type. */
export enum Attribute_DataType {
  /** DATA_TYPE_UNSPECIFIED - Attribute data type unspecified. */
  DATA_TYPE_UNSPECIFIED = 0,
  /** ENUM - Attribute's value is of type enum. */
  ENUM = 1,
  /** JSON - Attribute's value is of type json. */
  JSON = 2,
  /** STRING - Attribute's value is of type string. */
  STRING = 3,
  UNRECOGNIZED = -1,
}

export function attribute_DataTypeFromJSON(object: any): Attribute_DataType {
  switch (object) {
    case 0:
    case "DATA_TYPE_UNSPECIFIED":
      return Attribute_DataType.DATA_TYPE_UNSPECIFIED;
    case 1:
    case "ENUM":
      return Attribute_DataType.ENUM;
    case 2:
    case "JSON":
      return Attribute_DataType.JSON;
    case 3:
    case "STRING":
      return Attribute_DataType.STRING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Attribute_DataType.UNRECOGNIZED;
  }
}

export function attribute_DataTypeToJSON(object: Attribute_DataType): string {
  switch (object) {
    case Attribute_DataType.DATA_TYPE_UNSPECIFIED:
      return "DATA_TYPE_UNSPECIFIED";
    case Attribute_DataType.ENUM:
      return "ENUM";
    case Attribute_DataType.JSON:
      return "JSON";
    case Attribute_DataType.STRING:
      return "STRING";
    case Attribute_DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The value that can be assigned to the attribute when the data type is
 * enum.
 */
export interface Attribute_AllowedValue {
  /**
   * Required. The ID of the allowed value.
   * * If provided, the same will be used. The service will throw an error if
   * the specified id is already used by another allowed value in the same
   * attribute resource.
   * * If not provided, a system generated id derived from the display name
   * will be used. In this case, the service will handle conflict resolution
   * by adding a system generated suffix in case of duplicates.
   *
   * This value should be 4-63 characters, and valid characters
   * are /[a-z][0-9]-/.
   */
  id: string;
  /** Required. The display name of the allowed value. */
  displayName: string;
  /** Optional. The detailed description of the allowed value. */
  description: string;
  /**
   * Optional. When set to true, the allowed value cannot be updated or
   * deleted by the user. It can only be true for System defined attributes.
   */
  immutable: boolean;
}

/** The spec contents. */
export interface SpecContents {
  /** Required. The contents of the spec. */
  contents: Buffer;
  /**
   * Required. The mime type of the content for example application/json,
   * application/yaml, application/wsdl etc.
   */
  mimeType: string;
}

/**
 * SpecDetails contains the details parsed from supported
 * spec types.
 */
export interface SpecDetails {
  /**
   * Output only. Additional details apart from `OperationDetails` parsed from
   * an OpenAPI spec. The OperationDetails parsed from the spec can be
   * obtained by using
   * [ListAPIOperations][google.cloud.apihub.v1.ApiHub.ListApiOperations]
   * method.
   */
  openApiSpecDetails?:
    | OpenApiSpecDetails
    | undefined;
  /** Output only. The description of the spec. */
  description: string;
}

/**
 * OpenApiSpecDetails contains the details parsed from an OpenAPI spec in
 * addition to the fields mentioned in
 * [SpecDetails][google.cloud.apihub.v1.SpecDetails].
 */
export interface OpenApiSpecDetails {
  /** Output only. The format of the spec. */
  format: OpenApiSpecDetails_Format;
  /**
   * Output only. The version in the spec.
   * This maps to `info.version` in OpenAPI spec.
   */
  version: string;
  /**
   * Output only. Owner details for the spec.
   * This maps to `info.contact` in OpenAPI spec.
   */
  owner: Owner | undefined;
}

/** Enumeration of spec formats. */
export enum OpenApiSpecDetails_Format {
  /** FORMAT_UNSPECIFIED - SpecFile type unspecified. */
  FORMAT_UNSPECIFIED = 0,
  /** OPEN_API_SPEC_2_0 - OpenAPI Spec v2.0. */
  OPEN_API_SPEC_2_0 = 1,
  /** OPEN_API_SPEC_3_0 - OpenAPI Spec v3.0. */
  OPEN_API_SPEC_3_0 = 2,
  /** OPEN_API_SPEC_3_1 - OpenAPI Spec v3.1. */
  OPEN_API_SPEC_3_1 = 3,
  UNRECOGNIZED = -1,
}

export function openApiSpecDetails_FormatFromJSON(object: any): OpenApiSpecDetails_Format {
  switch (object) {
    case 0:
    case "FORMAT_UNSPECIFIED":
      return OpenApiSpecDetails_Format.FORMAT_UNSPECIFIED;
    case 1:
    case "OPEN_API_SPEC_2_0":
      return OpenApiSpecDetails_Format.OPEN_API_SPEC_2_0;
    case 2:
    case "OPEN_API_SPEC_3_0":
      return OpenApiSpecDetails_Format.OPEN_API_SPEC_3_0;
    case 3:
    case "OPEN_API_SPEC_3_1":
      return OpenApiSpecDetails_Format.OPEN_API_SPEC_3_1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OpenApiSpecDetails_Format.UNRECOGNIZED;
  }
}

export function openApiSpecDetails_FormatToJSON(object: OpenApiSpecDetails_Format): string {
  switch (object) {
    case OpenApiSpecDetails_Format.FORMAT_UNSPECIFIED:
      return "FORMAT_UNSPECIFIED";
    case OpenApiSpecDetails_Format.OPEN_API_SPEC_2_0:
      return "OPEN_API_SPEC_2_0";
    case OpenApiSpecDetails_Format.OPEN_API_SPEC_3_0:
      return "OPEN_API_SPEC_3_0";
    case OpenApiSpecDetails_Format.OPEN_API_SPEC_3_1:
      return "OPEN_API_SPEC_3_1";
    case OpenApiSpecDetails_Format.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The operation details parsed from the spec. */
export interface OperationDetails {
  /** The HTTP Operation. */
  httpOperation?:
    | HttpOperation
    | undefined;
  /**
   * Output only. Description of the operation behavior.
   * For OpenAPI spec, this will map to `operation.description` in the
   * spec, in case description is empty, `operation.summary` will be used.
   */
  description: string;
  /**
   * Output only. Additional external documentation for this operation.
   * For OpenAPI spec, this will map to `operation.documentation` in the spec.
   */
  documentation:
    | Documentation
    | undefined;
  /**
   * Output only. For OpenAPI spec, this will be set if `operation.deprecated`is
   * marked as `true` in the spec.
   */
  deprecated: boolean;
}

/** The HTTP Operation. */
export interface HttpOperation {
  /** Output only. The path details for the Operation. */
  path:
    | Path
    | undefined;
  /** Output only. Operation method */
  method: HttpOperation_Method;
}

/** Enumeration of Method types. */
export enum HttpOperation_Method {
  /** METHOD_UNSPECIFIED - Method unspecified. */
  METHOD_UNSPECIFIED = 0,
  /** GET - Get Operation type. */
  GET = 1,
  /** PUT - Put Operation type. */
  PUT = 2,
  /** POST - Post Operation type. */
  POST = 3,
  /** DELETE - Delete Operation type. */
  DELETE = 4,
  /** OPTIONS - Options Operation type. */
  OPTIONS = 5,
  /** HEAD - Head Operation type. */
  HEAD = 6,
  /** PATCH - Patch Operation type. */
  PATCH = 7,
  /** TRACE - Trace Operation type. */
  TRACE = 8,
  UNRECOGNIZED = -1,
}

export function httpOperation_MethodFromJSON(object: any): HttpOperation_Method {
  switch (object) {
    case 0:
    case "METHOD_UNSPECIFIED":
      return HttpOperation_Method.METHOD_UNSPECIFIED;
    case 1:
    case "GET":
      return HttpOperation_Method.GET;
    case 2:
    case "PUT":
      return HttpOperation_Method.PUT;
    case 3:
    case "POST":
      return HttpOperation_Method.POST;
    case 4:
    case "DELETE":
      return HttpOperation_Method.DELETE;
    case 5:
    case "OPTIONS":
      return HttpOperation_Method.OPTIONS;
    case 6:
    case "HEAD":
      return HttpOperation_Method.HEAD;
    case 7:
    case "PATCH":
      return HttpOperation_Method.PATCH;
    case 8:
    case "TRACE":
      return HttpOperation_Method.TRACE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HttpOperation_Method.UNRECOGNIZED;
  }
}

export function httpOperation_MethodToJSON(object: HttpOperation_Method): string {
  switch (object) {
    case HttpOperation_Method.METHOD_UNSPECIFIED:
      return "METHOD_UNSPECIFIED";
    case HttpOperation_Method.GET:
      return "GET";
    case HttpOperation_Method.PUT:
      return "PUT";
    case HttpOperation_Method.POST:
      return "POST";
    case HttpOperation_Method.DELETE:
      return "DELETE";
    case HttpOperation_Method.OPTIONS:
      return "OPTIONS";
    case HttpOperation_Method.HEAD:
      return "HEAD";
    case HttpOperation_Method.PATCH:
      return "PATCH";
    case HttpOperation_Method.TRACE:
      return "TRACE";
    case HttpOperation_Method.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The path details derived from the spec. */
export interface Path {
  /** Output only. Complete path relative to server endpoint. */
  path: string;
  /** Output only. A short description for the path applicable to all operations. */
  description: string;
}

/**
 * The schema details derived from the spec. Currently, this entity is supported
 * for OpenAPI spec only.
 * For OpenAPI spec, this maps to the schema defined in
 * the  `definitions` section for OpenAPI 2.0 version and in
 * `components.schemas` section for OpenAPI 3.0 and 3.1 version.
 */
export interface Schema {
  /**
   * Output only. The display name of the schema.
   * This will map to the name of the schema in the spec.
   */
  displayName: string;
  /**
   * Output only. The raw value of the schema definition corresponding to the
   * schema name in the spec.
   */
  rawValue: Buffer;
}

/** Owner details. */
export interface Owner {
  /** Optional. The name of the owner. */
  displayName: string;
  /** Required. The email of the owner. */
  email: string;
}

/** Documentation details. */
export interface Documentation {
  /** Optional. The uri of the externally hosted documentation. */
  externalUri: string;
}

/** The attribute values associated with resource. */
export interface AttributeValues {
  /**
   * The attribute values associated with a resource in case attribute data
   * type is enum.
   */
  enumValues?:
    | AttributeValues_EnumAttributeValues
    | undefined;
  /**
   * The attribute values associated with a resource in case attribute data
   * type is string.
   */
  stringValues?:
    | AttributeValues_StringAttributeValues
    | undefined;
  /**
   * The attribute values associated with a resource in case attribute data
   * type is JSON.
   */
  jsonValues?:
    | AttributeValues_StringAttributeValues
    | undefined;
  /**
   * Output only. The name of the attribute.
   * Format: projects/{project}/locations/{location}/attributes/{attribute}
   */
  attribute: string;
}

/** The attribute values of data type enum. */
export interface AttributeValues_EnumAttributeValues {
  /** Required. The attribute values in case attribute data type is enum. */
  values: Attribute_AllowedValue[];
}

/** The attribute values of data type string or JSON. */
export interface AttributeValues_StringAttributeValues {
  /**
   * Required. The attribute values in case attribute data type is string or
   * JSON.
   */
  values: string[];
}

/**
 * A dependency resource defined in the API hub describes a dependency directed
 * from a consumer to a supplier entity. A dependency can be defined between two
 * [Operations][google.cloud.apihub.v1.Operation] or between
 * an [Operation][google.cloud.apihub.v1.Operation] and [External
 * API][google.cloud.apihub.v1.ExternalApi].
 */
export interface Dependency {
  /**
   * Identifier. The name of the dependency in the API Hub.
   *
   * Format: `projects/{project}/locations/{location}/dependencies/{dependency}`
   */
  name: string;
  /** Required. Immutable. The entity acting as the consumer in the dependency. */
  consumer:
    | DependencyEntityReference
    | undefined;
  /** Required. Immutable. The entity acting as the supplier in the dependency. */
  supplier:
    | DependencyEntityReference
    | undefined;
  /** Output only. State of the dependency. */
  state: Dependency_State;
  /** Optional. Human readable description corresponding of the dependency. */
  description: string;
  /** Output only. Discovery mode of the dependency. */
  discoveryMode: Dependency_DiscoveryMode;
  /**
   * Output only. Error details of a dependency if the system has detected it
   * internally.
   */
  errorDetail:
    | DependencyErrorDetail
    | undefined;
  /** Output only. The time at which the dependency was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time at which the dependency was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the
   * dependency resource. The key is the attribute name. It will be of the
   * format: `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
}

/** Possible states for a dependency. */
export enum Dependency_State {
  /** STATE_UNSPECIFIED - Default value. This value is unused. */
  STATE_UNSPECIFIED = 0,
  /**
   * PROPOSED - Dependency will be in a proposed state when it is newly identified by the
   * API hub on its own.
   */
  PROPOSED = 1,
  /**
   * VALIDATED - Dependency will be in a validated state when it is validated by the
   * admin or manually created in the API hub.
   */
  VALIDATED = 2,
  UNRECOGNIZED = -1,
}

export function dependency_StateFromJSON(object: any): Dependency_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Dependency_State.STATE_UNSPECIFIED;
    case 1:
    case "PROPOSED":
      return Dependency_State.PROPOSED;
    case 2:
    case "VALIDATED":
      return Dependency_State.VALIDATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Dependency_State.UNRECOGNIZED;
  }
}

export function dependency_StateToJSON(object: Dependency_State): string {
  switch (object) {
    case Dependency_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Dependency_State.PROPOSED:
      return "PROPOSED";
    case Dependency_State.VALIDATED:
      return "VALIDATED";
    case Dependency_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible modes of discovering the dependency. */
export enum Dependency_DiscoveryMode {
  /** DISCOVERY_MODE_UNSPECIFIED - Default value. This value is unused. */
  DISCOVERY_MODE_UNSPECIFIED = 0,
  /** MANUAL - Manual mode of discovery when the dependency is defined by the user. */
  MANUAL = 1,
  UNRECOGNIZED = -1,
}

export function dependency_DiscoveryModeFromJSON(object: any): Dependency_DiscoveryMode {
  switch (object) {
    case 0:
    case "DISCOVERY_MODE_UNSPECIFIED":
      return Dependency_DiscoveryMode.DISCOVERY_MODE_UNSPECIFIED;
    case 1:
    case "MANUAL":
      return Dependency_DiscoveryMode.MANUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Dependency_DiscoveryMode.UNRECOGNIZED;
  }
}

export function dependency_DiscoveryModeToJSON(object: Dependency_DiscoveryMode): string {
  switch (object) {
    case Dependency_DiscoveryMode.DISCOVERY_MODE_UNSPECIFIED:
      return "DISCOVERY_MODE_UNSPECIFIED";
    case Dependency_DiscoveryMode.MANUAL:
      return "MANUAL";
    case Dependency_DiscoveryMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Dependency_AttributesEntry {
  key: string;
  value: AttributeValues | undefined;
}

/** Reference to an entity participating in a dependency. */
export interface DependencyEntityReference {
  /**
   * The resource name of an operation in the API Hub.
   *
   * Format:
   * `projects/{project}/locations/{location}/apis/{api}/versions/{version}/operations/{operation}`
   */
  operationResourceName?:
    | string
    | undefined;
  /**
   * The resource name of an external API in the API Hub.
   *
   * Format:
   * `projects/{project}/locations/{location}/externalApis/{external_api}`
   */
  externalApiResourceName?:
    | string
    | undefined;
  /** Output only. Display name of the entity. */
  displayName: string;
}

/** Details describing error condition of a dependency. */
export interface DependencyErrorDetail {
  /** Optional. Error in the dependency. */
  error: DependencyErrorDetail_Error;
  /** Optional. Timestamp at which the error was found. */
  errorTime: Date | undefined;
}

/** Possible values representing an error in the dependency. */
export enum DependencyErrorDetail_Error {
  /** ERROR_UNSPECIFIED - Default value used for no error in the dependency. */
  ERROR_UNSPECIFIED = 0,
  /** SUPPLIER_NOT_FOUND - Supplier entity has been deleted. */
  SUPPLIER_NOT_FOUND = 1,
  /** SUPPLIER_RECREATED - Supplier entity has been recreated. */
  SUPPLIER_RECREATED = 2,
  UNRECOGNIZED = -1,
}

export function dependencyErrorDetail_ErrorFromJSON(object: any): DependencyErrorDetail_Error {
  switch (object) {
    case 0:
    case "ERROR_UNSPECIFIED":
      return DependencyErrorDetail_Error.ERROR_UNSPECIFIED;
    case 1:
    case "SUPPLIER_NOT_FOUND":
      return DependencyErrorDetail_Error.SUPPLIER_NOT_FOUND;
    case 2:
    case "SUPPLIER_RECREATED":
      return DependencyErrorDetail_Error.SUPPLIER_RECREATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DependencyErrorDetail_Error.UNRECOGNIZED;
  }
}

export function dependencyErrorDetail_ErrorToJSON(object: DependencyErrorDetail_Error): string {
  switch (object) {
    case DependencyErrorDetail_Error.ERROR_UNSPECIFIED:
      return "ERROR_UNSPECIFIED";
    case DependencyErrorDetail_Error.SUPPLIER_NOT_FOUND:
      return "SUPPLIER_NOT_FOUND";
    case DependencyErrorDetail_Error.SUPPLIER_RECREATED:
      return "SUPPLIER_RECREATED";
    case DependencyErrorDetail_Error.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** LintResponse contains the response from the linter. */
export interface LintResponse {
  /** Optional. Array of issues found in the analyzed document. */
  issues: Issue[];
  /** Optional. Summary of all issue types and counts for each severity level. */
  summary: LintResponse_SummaryEntry[];
  /** Required. Lint state represents success or failure for linting. */
  state: LintState;
  /** Required. Name of the linting application. */
  source: string;
  /** Required. Name of the linter used. */
  linter: Linter;
  /** Required. Timestamp when the linting response was generated. */
  createTime: Date | undefined;
}

/** Count of issues with a given severity. */
export interface LintResponse_SummaryEntry {
  /** Required. Severity of the issue. */
  severity: Severity;
  /** Required. Count of issues with the given severity. */
  count: number;
}

/** Issue contains the details of a single issue found by the linter. */
export interface Issue {
  /** Required. Rule code unique to each rule defined in linter. */
  code: string;
  /**
   * Required. An array of strings indicating the location in the analyzed
   * document where the rule was triggered.
   */
  path: string[];
  /** Required. Human-readable message describing the issue found by the linter. */
  message: string;
  /** Required. Severity level of the rule violation. */
  severity: Severity;
  /** Required. Object describing where in the file the issue was found. */
  range: Range | undefined;
}

/** Object describing where in the file the issue was found. */
export interface Range {
  /** Required. Start of the issue. */
  start:
    | Point
    | undefined;
  /** Required. End of the issue. */
  end: Point | undefined;
}

/** Point within the file (line and character). */
export interface Point {
  /** Required. Line number (zero-indexed). */
  line: number;
  /** Required. Character position within the line (zero-indexed). */
  character: number;
}

/** Represents the metadata of the long-running operation. */
export interface OperationMetadata {
  /** Output only. The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Output only. Server-defined resource path for the target of the operation. */
  target: string;
  /** Output only. Name of the verb executed by the operation. */
  verb: string;
  /** Output only. Human-readable status of the operation, if any. */
  statusMessage: string;
  /**
   * Output only. Identifies whether the user has requested cancellation
   * of the operation. Operations that have been cancelled successfully
   * have [Operation.error][] value with a
   * [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
   * `Code.CANCELLED`.
   */
  requestedCancellation: boolean;
  /** Output only. API version used to start the operation. */
  apiVersion: string;
}

/**
 * An ApiHubInstance represents the instance resources of the API Hub.
 * Currently, only one ApiHub instance is allowed for each project.
 */
export interface ApiHubInstance {
  /**
   * Identifier. Format:
   * `projects/{project}/locations/{location}/apiHubInstances/{apiHubInstance}`.
   */
  name: string;
  /** Output only. Creation timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update timestamp. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The current state of the ApiHub instance. */
  state: ApiHubInstance_State;
  /**
   * Output only. Extra information about ApiHub instance state. Currently the
   * message would be populated when state is `FAILED`.
   */
  stateMessage: string;
  /** Required. Config of the ApiHub instance. */
  config:
    | ApiHubInstance_Config
    | undefined;
  /**
   * Optional. Instance labels to represent user-provided metadata.
   * Refer to cloud documentation on labels for more details.
   * https://cloud.google.com/compute/docs/labeling-resources
   */
  labels: { [key: string]: string };
  /** Optional. Description of the ApiHub instance. */
  description: string;
}

/** State of the ApiHub Instance. */
export enum ApiHubInstance_State {
  /** STATE_UNSPECIFIED - The default value. This value is used if the state is omitted. */
  STATE_UNSPECIFIED = 0,
  /** INACTIVE - The ApiHub instance has not been initialized or has been deleted. */
  INACTIVE = 1,
  /** CREATING - The ApiHub instance is being created. */
  CREATING = 2,
  /** ACTIVE - The ApiHub instance has been created and is ready for use. */
  ACTIVE = 3,
  /** UPDATING - The ApiHub instance is being updated. */
  UPDATING = 4,
  /** DELETING - The ApiHub instance is being deleted. */
  DELETING = 5,
  /** FAILED - The ApiHub instance encountered an error during a state change. */
  FAILED = 6,
  UNRECOGNIZED = -1,
}

export function apiHubInstance_StateFromJSON(object: any): ApiHubInstance_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ApiHubInstance_State.STATE_UNSPECIFIED;
    case 1:
    case "INACTIVE":
      return ApiHubInstance_State.INACTIVE;
    case 2:
    case "CREATING":
      return ApiHubInstance_State.CREATING;
    case 3:
    case "ACTIVE":
      return ApiHubInstance_State.ACTIVE;
    case 4:
    case "UPDATING":
      return ApiHubInstance_State.UPDATING;
    case 5:
    case "DELETING":
      return ApiHubInstance_State.DELETING;
    case 6:
    case "FAILED":
      return ApiHubInstance_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ApiHubInstance_State.UNRECOGNIZED;
  }
}

export function apiHubInstance_StateToJSON(object: ApiHubInstance_State): string {
  switch (object) {
    case ApiHubInstance_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ApiHubInstance_State.INACTIVE:
      return "INACTIVE";
    case ApiHubInstance_State.CREATING:
      return "CREATING";
    case ApiHubInstance_State.ACTIVE:
      return "ACTIVE";
    case ApiHubInstance_State.UPDATING:
      return "UPDATING";
    case ApiHubInstance_State.DELETING:
      return "DELETING";
    case ApiHubInstance_State.FAILED:
      return "FAILED";
    case ApiHubInstance_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Available configurations to provision an ApiHub Instance. */
export interface ApiHubInstance_Config {
  /**
   * Required. The Customer Managed Encryption Key (CMEK) used for data
   * encryption. The CMEK name should follow the format of
   * `projects/([^/]+)/locations/([^/]+)/keyRings/([^/]+)/cryptoKeys/([^/]+)`,
   * where the location must match the instance location.
   */
  cmekKeyName: string;
}

export interface ApiHubInstance_LabelsEntry {
  key: string;
  value: string;
}

/**
 * An external API represents an API being provided by external sources. This
 * can be used to model third-party APIs and can be used to define dependencies.
 */
export interface ExternalApi {
  /**
   * Identifier. Format:
   * `projects/{project}/locations/{location}/externalApi/{externalApi}`.
   */
  name: string;
  /**
   * Required. Display name of the external API. Max length is 63 characters
   * (Unicode Code Points).
   */
  displayName: string;
  /**
   * Optional. Description of the external API. Max length is 2000 characters
   * (Unicode Code Points).
   */
  description: string;
  /** Optional. List of endpoints on which this API is accessible. */
  endpoints: string[];
  /** Optional. List of paths served by this API. */
  paths: string[];
  /** Optional. Documentation of the external API. */
  documentation:
    | Documentation
    | undefined;
  /**
   * Optional. The list of user defined attributes associated with the Version
   * resource. The key is the attribute name. It will be of the format:
   * `projects/{project}/locations/{location}/attributes/{attribute}`.
   * The value is the attribute values associated with the resource.
   */
  attributes: { [key: string]: AttributeValues };
  /** Output only. Creation timestamp. */
  createTime:
    | Date
    | undefined;
  /** Output only. Last update timestamp. */
  updateTime: Date | undefined;
}

export interface ExternalApi_AttributesEntry {
  key: string;
  value: AttributeValues | undefined;
}

function createBaseApi(): Api {
  return {
    name: "",
    displayName: "",
    description: "",
    documentation: undefined,
    owner: undefined,
    versions: [],
    createTime: undefined,
    updateTime: undefined,
    targetUser: undefined,
    team: undefined,
    businessUnit: undefined,
    maturityLevel: undefined,
    attributes: {},
    apiStyle: undefined,
    selectedVersion: "",
  };
}

export const Api: MessageFns<Api> = {
  encode(message: Api, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.documentation !== undefined) {
      Documentation.encode(message.documentation, writer.uint32(34).fork()).join();
    }
    if (message.owner !== undefined) {
      Owner.encode(message.owner, writer.uint32(42).fork()).join();
    }
    for (const v of message.versions) {
      writer.uint32(50).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.targetUser !== undefined) {
      AttributeValues.encode(message.targetUser, writer.uint32(74).fork()).join();
    }
    if (message.team !== undefined) {
      AttributeValues.encode(message.team, writer.uint32(82).fork()).join();
    }
    if (message.businessUnit !== undefined) {
      AttributeValues.encode(message.businessUnit, writer.uint32(90).fork()).join();
    }
    if (message.maturityLevel !== undefined) {
      AttributeValues.encode(message.maturityLevel, writer.uint32(98).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Api_AttributesEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    if (message.apiStyle !== undefined) {
      AttributeValues.encode(message.apiStyle, writer.uint32(114).fork()).join();
    }
    if (message.selectedVersion !== "") {
      writer.uint32(122).string(message.selectedVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Api {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApi();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.documentation = Documentation.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.owner = Owner.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.versions.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.targetUser = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.team = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.businessUnit = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.maturityLevel = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          const entry13 = Api_AttributesEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.attributes[entry13.key] = entry13.value;
          }
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.apiStyle = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.selectedVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Api {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      documentation: isSet(object.documentation) ? Documentation.fromJSON(object.documentation) : undefined,
      owner: isSet(object.owner) ? Owner.fromJSON(object.owner) : undefined,
      versions: globalThis.Array.isArray(object?.versions) ? object.versions.map((e: any) => globalThis.String(e)) : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      targetUser: isSet(object.targetUser) ? AttributeValues.fromJSON(object.targetUser) : undefined,
      team: isSet(object.team) ? AttributeValues.fromJSON(object.team) : undefined,
      businessUnit: isSet(object.businessUnit) ? AttributeValues.fromJSON(object.businessUnit) : undefined,
      maturityLevel: isSet(object.maturityLevel) ? AttributeValues.fromJSON(object.maturityLevel) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
      apiStyle: isSet(object.apiStyle) ? AttributeValues.fromJSON(object.apiStyle) : undefined,
      selectedVersion: isSet(object.selectedVersion) ? globalThis.String(object.selectedVersion) : "",
    };
  },

  toJSON(message: Api): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.documentation !== undefined) {
      obj.documentation = Documentation.toJSON(message.documentation);
    }
    if (message.owner !== undefined) {
      obj.owner = Owner.toJSON(message.owner);
    }
    if (message.versions?.length) {
      obj.versions = message.versions;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.targetUser !== undefined) {
      obj.targetUser = AttributeValues.toJSON(message.targetUser);
    }
    if (message.team !== undefined) {
      obj.team = AttributeValues.toJSON(message.team);
    }
    if (message.businessUnit !== undefined) {
      obj.businessUnit = AttributeValues.toJSON(message.businessUnit);
    }
    if (message.maturityLevel !== undefined) {
      obj.maturityLevel = AttributeValues.toJSON(message.maturityLevel);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    if (message.apiStyle !== undefined) {
      obj.apiStyle = AttributeValues.toJSON(message.apiStyle);
    }
    if (message.selectedVersion !== "") {
      obj.selectedVersion = message.selectedVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<Api>): Api {
    return Api.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Api>): Api {
    const message = createBaseApi();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? Documentation.fromPartial(object.documentation)
      : undefined;
    message.owner = (object.owner !== undefined && object.owner !== null) ? Owner.fromPartial(object.owner) : undefined;
    message.versions = object.versions?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.targetUser = (object.targetUser !== undefined && object.targetUser !== null)
      ? AttributeValues.fromPartial(object.targetUser)
      : undefined;
    message.team = (object.team !== undefined && object.team !== null)
      ? AttributeValues.fromPartial(object.team)
      : undefined;
    message.businessUnit = (object.businessUnit !== undefined && object.businessUnit !== null)
      ? AttributeValues.fromPartial(object.businessUnit)
      : undefined;
    message.maturityLevel = (object.maturityLevel !== undefined && object.maturityLevel !== null)
      ? AttributeValues.fromPartial(object.maturityLevel)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.apiStyle = (object.apiStyle !== undefined && object.apiStyle !== null)
      ? AttributeValues.fromPartial(object.apiStyle)
      : undefined;
    message.selectedVersion = object.selectedVersion ?? "";
    return message;
  },
};

function createBaseApi_AttributesEntry(): Api_AttributesEntry {
  return { key: "", value: undefined };
}

export const Api_AttributesEntry: MessageFns<Api_AttributesEntry> = {
  encode(message: Api_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Api_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApi_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Api_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Api_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Api_AttributesEntry>): Api_AttributesEntry {
    return Api_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Api_AttributesEntry>): Api_AttributesEntry {
    const message = createBaseApi_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseVersion(): Version {
  return {
    name: "",
    displayName: "",
    description: "",
    documentation: undefined,
    specs: [],
    apiOperations: [],
    definitions: [],
    deployments: [],
    createTime: undefined,
    updateTime: undefined,
    lifecycle: undefined,
    compliance: undefined,
    accreditation: undefined,
    attributes: {},
    selectedDeployment: "",
  };
}

export const Version: MessageFns<Version> = {
  encode(message: Version, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.documentation !== undefined) {
      Documentation.encode(message.documentation, writer.uint32(34).fork()).join();
    }
    for (const v of message.specs) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.apiOperations) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.definitions) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.deployments) {
      writer.uint32(66).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.lifecycle !== undefined) {
      AttributeValues.encode(message.lifecycle, writer.uint32(90).fork()).join();
    }
    if (message.compliance !== undefined) {
      AttributeValues.encode(message.compliance, writer.uint32(98).fork()).join();
    }
    if (message.accreditation !== undefined) {
      AttributeValues.encode(message.accreditation, writer.uint32(106).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Version_AttributesEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    if (message.selectedDeployment !== "") {
      writer.uint32(130).string(message.selectedDeployment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Version {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.documentation = Documentation.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.specs.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.apiOperations.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.definitions.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.deployments.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.lifecycle = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.compliance = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.accreditation = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          const entry14 = Version_AttributesEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.attributes[entry14.key] = entry14.value;
          }
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.selectedDeployment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Version {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      documentation: isSet(object.documentation) ? Documentation.fromJSON(object.documentation) : undefined,
      specs: globalThis.Array.isArray(object?.specs) ? object.specs.map((e: any) => globalThis.String(e)) : [],
      apiOperations: globalThis.Array.isArray(object?.apiOperations)
        ? object.apiOperations.map((e: any) => globalThis.String(e))
        : [],
      definitions: globalThis.Array.isArray(object?.definitions)
        ? object.definitions.map((e: any) => globalThis.String(e))
        : [],
      deployments: globalThis.Array.isArray(object?.deployments)
        ? object.deployments.map((e: any) => globalThis.String(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      lifecycle: isSet(object.lifecycle) ? AttributeValues.fromJSON(object.lifecycle) : undefined,
      compliance: isSet(object.compliance) ? AttributeValues.fromJSON(object.compliance) : undefined,
      accreditation: isSet(object.accreditation) ? AttributeValues.fromJSON(object.accreditation) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
      selectedDeployment: isSet(object.selectedDeployment) ? globalThis.String(object.selectedDeployment) : "",
    };
  },

  toJSON(message: Version): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.documentation !== undefined) {
      obj.documentation = Documentation.toJSON(message.documentation);
    }
    if (message.specs?.length) {
      obj.specs = message.specs;
    }
    if (message.apiOperations?.length) {
      obj.apiOperations = message.apiOperations;
    }
    if (message.definitions?.length) {
      obj.definitions = message.definitions;
    }
    if (message.deployments?.length) {
      obj.deployments = message.deployments;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.lifecycle !== undefined) {
      obj.lifecycle = AttributeValues.toJSON(message.lifecycle);
    }
    if (message.compliance !== undefined) {
      obj.compliance = AttributeValues.toJSON(message.compliance);
    }
    if (message.accreditation !== undefined) {
      obj.accreditation = AttributeValues.toJSON(message.accreditation);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    if (message.selectedDeployment !== "") {
      obj.selectedDeployment = message.selectedDeployment;
    }
    return obj;
  },

  create(base?: DeepPartial<Version>): Version {
    return Version.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Version>): Version {
    const message = createBaseVersion();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? Documentation.fromPartial(object.documentation)
      : undefined;
    message.specs = object.specs?.map((e) => e) || [];
    message.apiOperations = object.apiOperations?.map((e) => e) || [];
    message.definitions = object.definitions?.map((e) => e) || [];
    message.deployments = object.deployments?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.lifecycle = (object.lifecycle !== undefined && object.lifecycle !== null)
      ? AttributeValues.fromPartial(object.lifecycle)
      : undefined;
    message.compliance = (object.compliance !== undefined && object.compliance !== null)
      ? AttributeValues.fromPartial(object.compliance)
      : undefined;
    message.accreditation = (object.accreditation !== undefined && object.accreditation !== null)
      ? AttributeValues.fromPartial(object.accreditation)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.selectedDeployment = object.selectedDeployment ?? "";
    return message;
  },
};

function createBaseVersion_AttributesEntry(): Version_AttributesEntry {
  return { key: "", value: undefined };
}

export const Version_AttributesEntry: MessageFns<Version_AttributesEntry> = {
  encode(message: Version_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Version_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersion_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Version_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Version_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Version_AttributesEntry>): Version_AttributesEntry {
    return Version_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Version_AttributesEntry>): Version_AttributesEntry {
    const message = createBaseVersion_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseSpec(): Spec {
  return {
    name: "",
    displayName: "",
    specType: undefined,
    contents: undefined,
    details: undefined,
    sourceUri: "",
    createTime: undefined,
    updateTime: undefined,
    lintResponse: undefined,
    attributes: {},
    documentation: undefined,
    parsingMode: 0,
  };
}

export const Spec: MessageFns<Spec> = {
  encode(message: Spec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.specType !== undefined) {
      AttributeValues.encode(message.specType, writer.uint32(26).fork()).join();
    }
    if (message.contents !== undefined) {
      SpecContents.encode(message.contents, writer.uint32(34).fork()).join();
    }
    if (message.details !== undefined) {
      SpecDetails.encode(message.details, writer.uint32(42).fork()).join();
    }
    if (message.sourceUri !== "") {
      writer.uint32(50).string(message.sourceUri);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.lintResponse !== undefined) {
      LintResponse.encode(message.lintResponse, writer.uint32(74).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Spec_AttributesEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    if (message.documentation !== undefined) {
      Documentation.encode(message.documentation, writer.uint32(90).fork()).join();
    }
    if (message.parsingMode !== 0) {
      writer.uint32(96).int32(message.parsingMode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.specType = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contents = SpecContents.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.details = SpecDetails.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sourceUri = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.lintResponse = LintResponse.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Spec_AttributesEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.attributes[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.documentation = Documentation.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.parsingMode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Spec {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      specType: isSet(object.specType) ? AttributeValues.fromJSON(object.specType) : undefined,
      contents: isSet(object.contents) ? SpecContents.fromJSON(object.contents) : undefined,
      details: isSet(object.details) ? SpecDetails.fromJSON(object.details) : undefined,
      sourceUri: isSet(object.sourceUri) ? globalThis.String(object.sourceUri) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      lintResponse: isSet(object.lintResponse) ? LintResponse.fromJSON(object.lintResponse) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
      documentation: isSet(object.documentation) ? Documentation.fromJSON(object.documentation) : undefined,
      parsingMode: isSet(object.parsingMode) ? spec_ParsingModeFromJSON(object.parsingMode) : 0,
    };
  },

  toJSON(message: Spec): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.specType !== undefined) {
      obj.specType = AttributeValues.toJSON(message.specType);
    }
    if (message.contents !== undefined) {
      obj.contents = SpecContents.toJSON(message.contents);
    }
    if (message.details !== undefined) {
      obj.details = SpecDetails.toJSON(message.details);
    }
    if (message.sourceUri !== "") {
      obj.sourceUri = message.sourceUri;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.lintResponse !== undefined) {
      obj.lintResponse = LintResponse.toJSON(message.lintResponse);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    if (message.documentation !== undefined) {
      obj.documentation = Documentation.toJSON(message.documentation);
    }
    if (message.parsingMode !== 0) {
      obj.parsingMode = spec_ParsingModeToJSON(message.parsingMode);
    }
    return obj;
  },

  create(base?: DeepPartial<Spec>): Spec {
    return Spec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Spec>): Spec {
    const message = createBaseSpec();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.specType = (object.specType !== undefined && object.specType !== null)
      ? AttributeValues.fromPartial(object.specType)
      : undefined;
    message.contents = (object.contents !== undefined && object.contents !== null)
      ? SpecContents.fromPartial(object.contents)
      : undefined;
    message.details = (object.details !== undefined && object.details !== null)
      ? SpecDetails.fromPartial(object.details)
      : undefined;
    message.sourceUri = object.sourceUri ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.lintResponse = (object.lintResponse !== undefined && object.lintResponse !== null)
      ? LintResponse.fromPartial(object.lintResponse)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? Documentation.fromPartial(object.documentation)
      : undefined;
    message.parsingMode = object.parsingMode ?? 0;
    return message;
  },
};

function createBaseSpec_AttributesEntry(): Spec_AttributesEntry {
  return { key: "", value: undefined };
}

export const Spec_AttributesEntry: MessageFns<Spec_AttributesEntry> = {
  encode(message: Spec_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Spec_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpec_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Spec_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Spec_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Spec_AttributesEntry>): Spec_AttributesEntry {
    return Spec_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Spec_AttributesEntry>): Spec_AttributesEntry {
    const message = createBaseSpec_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDeployment(): Deployment {
  return {
    name: "",
    displayName: "",
    description: "",
    documentation: undefined,
    deploymentType: undefined,
    resourceUri: "",
    endpoints: [],
    apiVersions: [],
    createTime: undefined,
    updateTime: undefined,
    slo: undefined,
    environment: undefined,
    attributes: {},
  };
}

export const Deployment: MessageFns<Deployment> = {
  encode(message: Deployment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.documentation !== undefined) {
      Documentation.encode(message.documentation, writer.uint32(34).fork()).join();
    }
    if (message.deploymentType !== undefined) {
      AttributeValues.encode(message.deploymentType, writer.uint32(42).fork()).join();
    }
    if (message.resourceUri !== "") {
      writer.uint32(50).string(message.resourceUri);
    }
    for (const v of message.endpoints) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.apiVersions) {
      writer.uint32(66).string(v!);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(74).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(82).fork()).join();
    }
    if (message.slo !== undefined) {
      AttributeValues.encode(message.slo, writer.uint32(90).fork()).join();
    }
    if (message.environment !== undefined) {
      AttributeValues.encode(message.environment, writer.uint32(98).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Deployment_AttributesEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deployment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.documentation = Documentation.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.deploymentType = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.resourceUri = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.apiVersions.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.slo = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.environment = AttributeValues.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          const entry13 = Deployment_AttributesEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.attributes[entry13.key] = entry13.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deployment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      documentation: isSet(object.documentation) ? Documentation.fromJSON(object.documentation) : undefined,
      deploymentType: isSet(object.deploymentType) ? AttributeValues.fromJSON(object.deploymentType) : undefined,
      resourceUri: isSet(object.resourceUri) ? globalThis.String(object.resourceUri) : "",
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      apiVersions: globalThis.Array.isArray(object?.apiVersions)
        ? object.apiVersions.map((e: any) => globalThis.String(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      slo: isSet(object.slo) ? AttributeValues.fromJSON(object.slo) : undefined,
      environment: isSet(object.environment) ? AttributeValues.fromJSON(object.environment) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Deployment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.documentation !== undefined) {
      obj.documentation = Documentation.toJSON(message.documentation);
    }
    if (message.deploymentType !== undefined) {
      obj.deploymentType = AttributeValues.toJSON(message.deploymentType);
    }
    if (message.resourceUri !== "") {
      obj.resourceUri = message.resourceUri;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.apiVersions?.length) {
      obj.apiVersions = message.apiVersions;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.slo !== undefined) {
      obj.slo = AttributeValues.toJSON(message.slo);
    }
    if (message.environment !== undefined) {
      obj.environment = AttributeValues.toJSON(message.environment);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Deployment>): Deployment {
    return Deployment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Deployment>): Deployment {
    const message = createBaseDeployment();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? Documentation.fromPartial(object.documentation)
      : undefined;
    message.deploymentType = (object.deploymentType !== undefined && object.deploymentType !== null)
      ? AttributeValues.fromPartial(object.deploymentType)
      : undefined;
    message.resourceUri = object.resourceUri ?? "";
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.apiVersions = object.apiVersions?.map((e) => e) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.slo = (object.slo !== undefined && object.slo !== null)
      ? AttributeValues.fromPartial(object.slo)
      : undefined;
    message.environment = (object.environment !== undefined && object.environment !== null)
      ? AttributeValues.fromPartial(object.environment)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDeployment_AttributesEntry(): Deployment_AttributesEntry {
  return { key: "", value: undefined };
}

export const Deployment_AttributesEntry: MessageFns<Deployment_AttributesEntry> = {
  encode(message: Deployment_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Deployment_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeployment_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Deployment_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Deployment_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Deployment_AttributesEntry>): Deployment_AttributesEntry {
    return Deployment_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Deployment_AttributesEntry>): Deployment_AttributesEntry {
    const message = createBaseDeployment_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseApiOperation(): ApiOperation {
  return { name: "", spec: "", details: undefined, createTime: undefined, updateTime: undefined, attributes: {} };
}

export const ApiOperation: MessageFns<ApiOperation> = {
  encode(message: ApiOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.spec !== "") {
      writer.uint32(18).string(message.spec);
    }
    if (message.details !== undefined) {
      OperationDetails.encode(message.details, writer.uint32(26).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      ApiOperation_AttributesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spec = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.details = OperationDetails.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = ApiOperation_AttributesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.attributes[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiOperation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      spec: isSet(object.spec) ? globalThis.String(object.spec) : "",
      details: isSet(object.details) ? OperationDetails.fromJSON(object.details) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ApiOperation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.spec !== "") {
      obj.spec = message.spec;
    }
    if (message.details !== undefined) {
      obj.details = OperationDetails.toJSON(message.details);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ApiOperation>): ApiOperation {
    return ApiOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiOperation>): ApiOperation {
    const message = createBaseApiOperation();
    message.name = object.name ?? "";
    message.spec = object.spec ?? "";
    message.details = (object.details !== undefined && object.details !== null)
      ? OperationDetails.fromPartial(object.details)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseApiOperation_AttributesEntry(): ApiOperation_AttributesEntry {
  return { key: "", value: undefined };
}

export const ApiOperation_AttributesEntry: MessageFns<ApiOperation_AttributesEntry> = {
  encode(message: ApiOperation_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiOperation_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiOperation_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiOperation_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ApiOperation_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ApiOperation_AttributesEntry>): ApiOperation_AttributesEntry {
    return ApiOperation_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiOperation_AttributesEntry>): ApiOperation_AttributesEntry {
    const message = createBaseApiOperation_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDefinition(): Definition {
  return {
    schema: undefined,
    name: "",
    spec: "",
    type: 0,
    createTime: undefined,
    updateTime: undefined,
    attributes: {},
  };
}

export const Definition: MessageFns<Definition> = {
  encode(message: Definition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.schema !== undefined) {
      Schema.encode(message.schema, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.spec !== "") {
      writer.uint32(18).string(message.spec);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Definition_AttributesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Definition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.schema = Schema.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.spec = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = Definition_AttributesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.attributes[entry7.key] = entry7.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Definition {
    return {
      schema: isSet(object.schema) ? Schema.fromJSON(object.schema) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      spec: isSet(object.spec) ? globalThis.String(object.spec) : "",
      type: isSet(object.type) ? definition_TypeFromJSON(object.type) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Definition): unknown {
    const obj: any = {};
    if (message.schema !== undefined) {
      obj.schema = Schema.toJSON(message.schema);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.spec !== "") {
      obj.spec = message.spec;
    }
    if (message.type !== 0) {
      obj.type = definition_TypeToJSON(message.type);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Definition>): Definition {
    return Definition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Definition>): Definition {
    const message = createBaseDefinition();
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? Schema.fromPartial(object.schema)
      : undefined;
    message.name = object.name ?? "";
    message.spec = object.spec ?? "";
    message.type = object.type ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDefinition_AttributesEntry(): Definition_AttributesEntry {
  return { key: "", value: undefined };
}

export const Definition_AttributesEntry: MessageFns<Definition_AttributesEntry> = {
  encode(message: Definition_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Definition_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefinition_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Definition_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Definition_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Definition_AttributesEntry>): Definition_AttributesEntry {
    return Definition_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Definition_AttributesEntry>): Definition_AttributesEntry {
    const message = createBaseDefinition_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAttribute(): Attribute {
  return {
    name: "",
    displayName: "",
    description: "",
    definitionType: 0,
    scope: 0,
    dataType: 0,
    allowedValues: [],
    cardinality: 0,
    mandatory: false,
    createTime: undefined,
    updateTime: undefined,
  };
}

export const Attribute: MessageFns<Attribute> = {
  encode(message: Attribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.definitionType !== 0) {
      writer.uint32(32).int32(message.definitionType);
    }
    if (message.scope !== 0) {
      writer.uint32(40).int32(message.scope);
    }
    if (message.dataType !== 0) {
      writer.uint32(48).int32(message.dataType);
    }
    for (const v of message.allowedValues) {
      Attribute_AllowedValue.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.cardinality !== 0) {
      writer.uint32(64).int32(message.cardinality);
    }
    if (message.mandatory !== false) {
      writer.uint32(72).bool(message.mandatory);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(82).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.definitionType = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.allowedValues.push(Attribute_AllowedValue.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.cardinality = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.mandatory = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attribute {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      definitionType: isSet(object.definitionType) ? attribute_DefinitionTypeFromJSON(object.definitionType) : 0,
      scope: isSet(object.scope) ? attribute_ScopeFromJSON(object.scope) : 0,
      dataType: isSet(object.dataType) ? attribute_DataTypeFromJSON(object.dataType) : 0,
      allowedValues: globalThis.Array.isArray(object?.allowedValues)
        ? object.allowedValues.map((e: any) => Attribute_AllowedValue.fromJSON(e))
        : [],
      cardinality: isSet(object.cardinality) ? globalThis.Number(object.cardinality) : 0,
      mandatory: isSet(object.mandatory) ? globalThis.Boolean(object.mandatory) : false,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: Attribute): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.definitionType !== 0) {
      obj.definitionType = attribute_DefinitionTypeToJSON(message.definitionType);
    }
    if (message.scope !== 0) {
      obj.scope = attribute_ScopeToJSON(message.scope);
    }
    if (message.dataType !== 0) {
      obj.dataType = attribute_DataTypeToJSON(message.dataType);
    }
    if (message.allowedValues?.length) {
      obj.allowedValues = message.allowedValues.map((e) => Attribute_AllowedValue.toJSON(e));
    }
    if (message.cardinality !== 0) {
      obj.cardinality = Math.round(message.cardinality);
    }
    if (message.mandatory !== false) {
      obj.mandatory = message.mandatory;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Attribute>): Attribute {
    return Attribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Attribute>): Attribute {
    const message = createBaseAttribute();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.definitionType = object.definitionType ?? 0;
    message.scope = object.scope ?? 0;
    message.dataType = object.dataType ?? 0;
    message.allowedValues = object.allowedValues?.map((e) => Attribute_AllowedValue.fromPartial(e)) || [];
    message.cardinality = object.cardinality ?? 0;
    message.mandatory = object.mandatory ?? false;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseAttribute_AllowedValue(): Attribute_AllowedValue {
  return { id: "", displayName: "", description: "", immutable: false };
}

export const Attribute_AllowedValue: MessageFns<Attribute_AllowedValue> = {
  encode(message: Attribute_AllowedValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.immutable !== false) {
      writer.uint32(32).bool(message.immutable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Attribute_AllowedValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttribute_AllowedValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.immutable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Attribute_AllowedValue {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      immutable: isSet(object.immutable) ? globalThis.Boolean(object.immutable) : false,
    };
  },

  toJSON(message: Attribute_AllowedValue): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.immutable !== false) {
      obj.immutable = message.immutable;
    }
    return obj;
  },

  create(base?: DeepPartial<Attribute_AllowedValue>): Attribute_AllowedValue {
    return Attribute_AllowedValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Attribute_AllowedValue>): Attribute_AllowedValue {
    const message = createBaseAttribute_AllowedValue();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.immutable = object.immutable ?? false;
    return message;
  },
};

function createBaseSpecContents(): SpecContents {
  return { contents: Buffer.alloc(0), mimeType: "" };
}

export const SpecContents: MessageFns<SpecContents> = {
  encode(message: SpecContents, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contents.length !== 0) {
      writer.uint32(10).bytes(message.contents);
    }
    if (message.mimeType !== "") {
      writer.uint32(18).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpecContents {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpecContents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contents = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpecContents {
    return {
      contents: isSet(object.contents) ? Buffer.from(bytesFromBase64(object.contents)) : Buffer.alloc(0),
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: SpecContents): unknown {
    const obj: any = {};
    if (message.contents.length !== 0) {
      obj.contents = base64FromBytes(message.contents);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create(base?: DeepPartial<SpecContents>): SpecContents {
    return SpecContents.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpecContents>): SpecContents {
    const message = createBaseSpecContents();
    message.contents = object.contents ?? Buffer.alloc(0);
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseSpecDetails(): SpecDetails {
  return { openApiSpecDetails: undefined, description: "" };
}

export const SpecDetails: MessageFns<SpecDetails> = {
  encode(message: SpecDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.openApiSpecDetails !== undefined) {
      OpenApiSpecDetails.encode(message.openApiSpecDetails, writer.uint32(18).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpecDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpecDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.openApiSpecDetails = OpenApiSpecDetails.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpecDetails {
    return {
      openApiSpecDetails: isSet(object.openApiSpecDetails)
        ? OpenApiSpecDetails.fromJSON(object.openApiSpecDetails)
        : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: SpecDetails): unknown {
    const obj: any = {};
    if (message.openApiSpecDetails !== undefined) {
      obj.openApiSpecDetails = OpenApiSpecDetails.toJSON(message.openApiSpecDetails);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<SpecDetails>): SpecDetails {
    return SpecDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpecDetails>): SpecDetails {
    const message = createBaseSpecDetails();
    message.openApiSpecDetails = (object.openApiSpecDetails !== undefined && object.openApiSpecDetails !== null)
      ? OpenApiSpecDetails.fromPartial(object.openApiSpecDetails)
      : undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseOpenApiSpecDetails(): OpenApiSpecDetails {
  return { format: 0, version: "", owner: undefined };
}

export const OpenApiSpecDetails: MessageFns<OpenApiSpecDetails> = {
  encode(message: OpenApiSpecDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.format !== 0) {
      writer.uint32(8).int32(message.format);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    if (message.owner !== undefined) {
      Owner.encode(message.owner, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpenApiSpecDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpenApiSpecDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.format = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.owner = Owner.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpenApiSpecDetails {
    return {
      format: isSet(object.format) ? openApiSpecDetails_FormatFromJSON(object.format) : 0,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      owner: isSet(object.owner) ? Owner.fromJSON(object.owner) : undefined,
    };
  },

  toJSON(message: OpenApiSpecDetails): unknown {
    const obj: any = {};
    if (message.format !== 0) {
      obj.format = openApiSpecDetails_FormatToJSON(message.format);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.owner !== undefined) {
      obj.owner = Owner.toJSON(message.owner);
    }
    return obj;
  },

  create(base?: DeepPartial<OpenApiSpecDetails>): OpenApiSpecDetails {
    return OpenApiSpecDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OpenApiSpecDetails>): OpenApiSpecDetails {
    const message = createBaseOpenApiSpecDetails();
    message.format = object.format ?? 0;
    message.version = object.version ?? "";
    message.owner = (object.owner !== undefined && object.owner !== null) ? Owner.fromPartial(object.owner) : undefined;
    return message;
  },
};

function createBaseOperationDetails(): OperationDetails {
  return { httpOperation: undefined, description: "", documentation: undefined, deprecated: false };
}

export const OperationDetails: MessageFns<OperationDetails> = {
  encode(message: OperationDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.httpOperation !== undefined) {
      HttpOperation.encode(message.httpOperation, writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.documentation !== undefined) {
      Documentation.encode(message.documentation, writer.uint32(18).fork()).join();
    }
    if (message.deprecated !== false) {
      writer.uint32(24).bool(message.deprecated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 4:
          if (tag !== 34) {
            break;
          }

          message.httpOperation = HttpOperation.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.documentation = Documentation.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.deprecated = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationDetails {
    return {
      httpOperation: isSet(object.httpOperation) ? HttpOperation.fromJSON(object.httpOperation) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      documentation: isSet(object.documentation) ? Documentation.fromJSON(object.documentation) : undefined,
      deprecated: isSet(object.deprecated) ? globalThis.Boolean(object.deprecated) : false,
    };
  },

  toJSON(message: OperationDetails): unknown {
    const obj: any = {};
    if (message.httpOperation !== undefined) {
      obj.httpOperation = HttpOperation.toJSON(message.httpOperation);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.documentation !== undefined) {
      obj.documentation = Documentation.toJSON(message.documentation);
    }
    if (message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationDetails>): OperationDetails {
    return OperationDetails.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationDetails>): OperationDetails {
    const message = createBaseOperationDetails();
    message.httpOperation = (object.httpOperation !== undefined && object.httpOperation !== null)
      ? HttpOperation.fromPartial(object.httpOperation)
      : undefined;
    message.description = object.description ?? "";
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? Documentation.fromPartial(object.documentation)
      : undefined;
    message.deprecated = object.deprecated ?? false;
    return message;
  },
};

function createBaseHttpOperation(): HttpOperation {
  return { path: undefined, method: 0 };
}

export const HttpOperation: MessageFns<HttpOperation> = {
  encode(message: HttpOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== undefined) {
      Path.encode(message.path, writer.uint32(10).fork()).join();
    }
    if (message.method !== 0) {
      writer.uint32(16).int32(message.method);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HttpOperation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHttpOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = Path.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HttpOperation {
    return {
      path: isSet(object.path) ? Path.fromJSON(object.path) : undefined,
      method: isSet(object.method) ? httpOperation_MethodFromJSON(object.method) : 0,
    };
  },

  toJSON(message: HttpOperation): unknown {
    const obj: any = {};
    if (message.path !== undefined) {
      obj.path = Path.toJSON(message.path);
    }
    if (message.method !== 0) {
      obj.method = httpOperation_MethodToJSON(message.method);
    }
    return obj;
  },

  create(base?: DeepPartial<HttpOperation>): HttpOperation {
    return HttpOperation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HttpOperation>): HttpOperation {
    const message = createBaseHttpOperation();
    message.path = (object.path !== undefined && object.path !== null) ? Path.fromPartial(object.path) : undefined;
    message.method = object.method ?? 0;
    return message;
  },
};

function createBasePath(): Path {
  return { path: "", description: "" };
}

export const Path: MessageFns<Path> = {
  encode(message: Path, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Path {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePath();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Path {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Path): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<Path>): Path {
    return Path.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Path>): Path {
    const message = createBasePath();
    message.path = object.path ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseSchema(): Schema {
  return { displayName: "", rawValue: Buffer.alloc(0) };
}

export const Schema: MessageFns<Schema> = {
  encode(message: Schema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.rawValue.length !== 0) {
      writer.uint32(18).bytes(message.rawValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rawValue = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schema {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      rawValue: isSet(object.rawValue) ? Buffer.from(bytesFromBase64(object.rawValue)) : Buffer.alloc(0),
    };
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.rawValue.length !== 0) {
      obj.rawValue = base64FromBytes(message.rawValue);
    }
    return obj;
  },

  create(base?: DeepPartial<Schema>): Schema {
    return Schema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Schema>): Schema {
    const message = createBaseSchema();
    message.displayName = object.displayName ?? "";
    message.rawValue = object.rawValue ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseOwner(): Owner {
  return { displayName: "", email: "" };
}

export const Owner: MessageFns<Owner> = {
  encode(message: Owner, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Owner {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOwner();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Owner {
    return {
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
    };
  },

  toJSON(message: Owner): unknown {
    const obj: any = {};
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    return obj;
  },

  create(base?: DeepPartial<Owner>): Owner {
    return Owner.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Owner>): Owner {
    const message = createBaseOwner();
    message.displayName = object.displayName ?? "";
    message.email = object.email ?? "";
    return message;
  },
};

function createBaseDocumentation(): Documentation {
  return { externalUri: "" };
}

export const Documentation: MessageFns<Documentation> = {
  encode(message: Documentation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.externalUri !== "") {
      writer.uint32(10).string(message.externalUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Documentation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDocumentation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.externalUri = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Documentation {
    return { externalUri: isSet(object.externalUri) ? globalThis.String(object.externalUri) : "" };
  },

  toJSON(message: Documentation): unknown {
    const obj: any = {};
    if (message.externalUri !== "") {
      obj.externalUri = message.externalUri;
    }
    return obj;
  },

  create(base?: DeepPartial<Documentation>): Documentation {
    return Documentation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Documentation>): Documentation {
    const message = createBaseDocumentation();
    message.externalUri = object.externalUri ?? "";
    return message;
  },
};

function createBaseAttributeValues(): AttributeValues {
  return { enumValues: undefined, stringValues: undefined, jsonValues: undefined, attribute: "" };
}

export const AttributeValues: MessageFns<AttributeValues> = {
  encode(message: AttributeValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enumValues !== undefined) {
      AttributeValues_EnumAttributeValues.encode(message.enumValues, writer.uint32(18).fork()).join();
    }
    if (message.stringValues !== undefined) {
      AttributeValues_StringAttributeValues.encode(message.stringValues, writer.uint32(26).fork()).join();
    }
    if (message.jsonValues !== undefined) {
      AttributeValues_StringAttributeValues.encode(message.jsonValues, writer.uint32(34).fork()).join();
    }
    if (message.attribute !== "") {
      writer.uint32(10).string(message.attribute);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.enumValues = AttributeValues_EnumAttributeValues.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stringValues = AttributeValues_StringAttributeValues.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.jsonValues = AttributeValues_StringAttributeValues.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attribute = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValues {
    return {
      enumValues: isSet(object.enumValues)
        ? AttributeValues_EnumAttributeValues.fromJSON(object.enumValues)
        : undefined,
      stringValues: isSet(object.stringValues)
        ? AttributeValues_StringAttributeValues.fromJSON(object.stringValues)
        : undefined,
      jsonValues: isSet(object.jsonValues)
        ? AttributeValues_StringAttributeValues.fromJSON(object.jsonValues)
        : undefined,
      attribute: isSet(object.attribute) ? globalThis.String(object.attribute) : "",
    };
  },

  toJSON(message: AttributeValues): unknown {
    const obj: any = {};
    if (message.enumValues !== undefined) {
      obj.enumValues = AttributeValues_EnumAttributeValues.toJSON(message.enumValues);
    }
    if (message.stringValues !== undefined) {
      obj.stringValues = AttributeValues_StringAttributeValues.toJSON(message.stringValues);
    }
    if (message.jsonValues !== undefined) {
      obj.jsonValues = AttributeValues_StringAttributeValues.toJSON(message.jsonValues);
    }
    if (message.attribute !== "") {
      obj.attribute = message.attribute;
    }
    return obj;
  },

  create(base?: DeepPartial<AttributeValues>): AttributeValues {
    return AttributeValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttributeValues>): AttributeValues {
    const message = createBaseAttributeValues();
    message.enumValues = (object.enumValues !== undefined && object.enumValues !== null)
      ? AttributeValues_EnumAttributeValues.fromPartial(object.enumValues)
      : undefined;
    message.stringValues = (object.stringValues !== undefined && object.stringValues !== null)
      ? AttributeValues_StringAttributeValues.fromPartial(object.stringValues)
      : undefined;
    message.jsonValues = (object.jsonValues !== undefined && object.jsonValues !== null)
      ? AttributeValues_StringAttributeValues.fromPartial(object.jsonValues)
      : undefined;
    message.attribute = object.attribute ?? "";
    return message;
  },
};

function createBaseAttributeValues_EnumAttributeValues(): AttributeValues_EnumAttributeValues {
  return { values: [] };
}

export const AttributeValues_EnumAttributeValues: MessageFns<AttributeValues_EnumAttributeValues> = {
  encode(message: AttributeValues_EnumAttributeValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      Attribute_AllowedValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValues_EnumAttributeValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValues_EnumAttributeValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(Attribute_AllowedValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValues_EnumAttributeValues {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => Attribute_AllowedValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AttributeValues_EnumAttributeValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Attribute_AllowedValue.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AttributeValues_EnumAttributeValues>): AttributeValues_EnumAttributeValues {
    return AttributeValues_EnumAttributeValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttributeValues_EnumAttributeValues>): AttributeValues_EnumAttributeValues {
    const message = createBaseAttributeValues_EnumAttributeValues();
    message.values = object.values?.map((e) => Attribute_AllowedValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAttributeValues_StringAttributeValues(): AttributeValues_StringAttributeValues {
  return { values: [] };
}

export const AttributeValues_StringAttributeValues: MessageFns<AttributeValues_StringAttributeValues> = {
  encode(message: AttributeValues_StringAttributeValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValues_StringAttributeValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValues_StringAttributeValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValues_StringAttributeValues {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AttributeValues_StringAttributeValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<AttributeValues_StringAttributeValues>): AttributeValues_StringAttributeValues {
    return AttributeValues_StringAttributeValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttributeValues_StringAttributeValues>): AttributeValues_StringAttributeValues {
    const message = createBaseAttributeValues_StringAttributeValues();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseDependency(): Dependency {
  return {
    name: "",
    consumer: undefined,
    supplier: undefined,
    state: 0,
    description: "",
    discoveryMode: 0,
    errorDetail: undefined,
    createTime: undefined,
    updateTime: undefined,
    attributes: {},
  };
}

export const Dependency: MessageFns<Dependency> = {
  encode(message: Dependency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.consumer !== undefined) {
      DependencyEntityReference.encode(message.consumer, writer.uint32(18).fork()).join();
    }
    if (message.supplier !== undefined) {
      DependencyEntityReference.encode(message.supplier, writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.discoveryMode !== 0) {
      writer.uint32(48).int32(message.discoveryMode);
    }
    if (message.errorDetail !== undefined) {
      DependencyErrorDetail.encode(message.errorDetail, writer.uint32(58).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Dependency_AttributesEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dependency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.consumer = DependencyEntityReference.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.supplier = DependencyEntityReference.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.discoveryMode = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.errorDetail = DependencyErrorDetail.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = Dependency_AttributesEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.attributes[entry10.key] = entry10.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dependency {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      consumer: isSet(object.consumer) ? DependencyEntityReference.fromJSON(object.consumer) : undefined,
      supplier: isSet(object.supplier) ? DependencyEntityReference.fromJSON(object.supplier) : undefined,
      state: isSet(object.state) ? dependency_StateFromJSON(object.state) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      discoveryMode: isSet(object.discoveryMode) ? dependency_DiscoveryModeFromJSON(object.discoveryMode) : 0,
      errorDetail: isSet(object.errorDetail) ? DependencyErrorDetail.fromJSON(object.errorDetail) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Dependency): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.consumer !== undefined) {
      obj.consumer = DependencyEntityReference.toJSON(message.consumer);
    }
    if (message.supplier !== undefined) {
      obj.supplier = DependencyEntityReference.toJSON(message.supplier);
    }
    if (message.state !== 0) {
      obj.state = dependency_StateToJSON(message.state);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.discoveryMode !== 0) {
      obj.discoveryMode = dependency_DiscoveryModeToJSON(message.discoveryMode);
    }
    if (message.errorDetail !== undefined) {
      obj.errorDetail = DependencyErrorDetail.toJSON(message.errorDetail);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Dependency>): Dependency {
    return Dependency.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Dependency>): Dependency {
    const message = createBaseDependency();
    message.name = object.name ?? "";
    message.consumer = (object.consumer !== undefined && object.consumer !== null)
      ? DependencyEntityReference.fromPartial(object.consumer)
      : undefined;
    message.supplier = (object.supplier !== undefined && object.supplier !== null)
      ? DependencyEntityReference.fromPartial(object.supplier)
      : undefined;
    message.state = object.state ?? 0;
    message.description = object.description ?? "";
    message.discoveryMode = object.discoveryMode ?? 0;
    message.errorDetail = (object.errorDetail !== undefined && object.errorDetail !== null)
      ? DependencyErrorDetail.fromPartial(object.errorDetail)
      : undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDependency_AttributesEntry(): Dependency_AttributesEntry {
  return { key: "", value: undefined };
}

export const Dependency_AttributesEntry: MessageFns<Dependency_AttributesEntry> = {
  encode(message: Dependency_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dependency_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependency_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dependency_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Dependency_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Dependency_AttributesEntry>): Dependency_AttributesEntry {
    return Dependency_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Dependency_AttributesEntry>): Dependency_AttributesEntry {
    const message = createBaseDependency_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDependencyEntityReference(): DependencyEntityReference {
  return { operationResourceName: undefined, externalApiResourceName: undefined, displayName: "" };
}

export const DependencyEntityReference: MessageFns<DependencyEntityReference> = {
  encode(message: DependencyEntityReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operationResourceName !== undefined) {
      writer.uint32(18).string(message.operationResourceName);
    }
    if (message.externalApiResourceName !== undefined) {
      writer.uint32(26).string(message.externalApiResourceName);
    }
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DependencyEntityReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependencyEntityReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operationResourceName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalApiResourceName = reader.string();
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.displayName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DependencyEntityReference {
    return {
      operationResourceName: isSet(object.operationResourceName)
        ? globalThis.String(object.operationResourceName)
        : undefined,
      externalApiResourceName: isSet(object.externalApiResourceName)
        ? globalThis.String(object.externalApiResourceName)
        : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: DependencyEntityReference): unknown {
    const obj: any = {};
    if (message.operationResourceName !== undefined) {
      obj.operationResourceName = message.operationResourceName;
    }
    if (message.externalApiResourceName !== undefined) {
      obj.externalApiResourceName = message.externalApiResourceName;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create(base?: DeepPartial<DependencyEntityReference>): DependencyEntityReference {
    return DependencyEntityReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DependencyEntityReference>): DependencyEntityReference {
    const message = createBaseDependencyEntityReference();
    message.operationResourceName = object.operationResourceName ?? undefined;
    message.externalApiResourceName = object.externalApiResourceName ?? undefined;
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseDependencyErrorDetail(): DependencyErrorDetail {
  return { error: 0, errorTime: undefined };
}

export const DependencyErrorDetail: MessageFns<DependencyErrorDetail> = {
  encode(message: DependencyErrorDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== 0) {
      writer.uint32(8).int32(message.error);
    }
    if (message.errorTime !== undefined) {
      Timestamp.encode(toTimestamp(message.errorTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DependencyErrorDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependencyErrorDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.error = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DependencyErrorDetail {
    return {
      error: isSet(object.error) ? dependencyErrorDetail_ErrorFromJSON(object.error) : 0,
      errorTime: isSet(object.errorTime) ? fromJsonTimestamp(object.errorTime) : undefined,
    };
  },

  toJSON(message: DependencyErrorDetail): unknown {
    const obj: any = {};
    if (message.error !== 0) {
      obj.error = dependencyErrorDetail_ErrorToJSON(message.error);
    }
    if (message.errorTime !== undefined) {
      obj.errorTime = message.errorTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<DependencyErrorDetail>): DependencyErrorDetail {
    return DependencyErrorDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DependencyErrorDetail>): DependencyErrorDetail {
    const message = createBaseDependencyErrorDetail();
    message.error = object.error ?? 0;
    message.errorTime = object.errorTime ?? undefined;
    return message;
  },
};

function createBaseLintResponse(): LintResponse {
  return { issues: [], summary: [], state: 0, source: "", linter: 0, createTime: undefined };
}

export const LintResponse: MessageFns<LintResponse> = {
  encode(message: LintResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.issues) {
      Issue.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.summary) {
      LintResponse_SummaryEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    if (message.linter !== 0) {
      writer.uint32(40).int32(message.linter);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LintResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLintResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.issues.push(Issue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.summary.push(LintResponse_SummaryEntry.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.linter = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LintResponse {
    return {
      issues: globalThis.Array.isArray(object?.issues) ? object.issues.map((e: any) => Issue.fromJSON(e)) : [],
      summary: globalThis.Array.isArray(object?.summary)
        ? object.summary.map((e: any) => LintResponse_SummaryEntry.fromJSON(e))
        : [],
      state: isSet(object.state) ? lintStateFromJSON(object.state) : 0,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      linter: isSet(object.linter) ? linterFromJSON(object.linter) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
    };
  },

  toJSON(message: LintResponse): unknown {
    const obj: any = {};
    if (message.issues?.length) {
      obj.issues = message.issues.map((e) => Issue.toJSON(e));
    }
    if (message.summary?.length) {
      obj.summary = message.summary.map((e) => LintResponse_SummaryEntry.toJSON(e));
    }
    if (message.state !== 0) {
      obj.state = lintStateToJSON(message.state);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.linter !== 0) {
      obj.linter = linterToJSON(message.linter);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<LintResponse>): LintResponse {
    return LintResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LintResponse>): LintResponse {
    const message = createBaseLintResponse();
    message.issues = object.issues?.map((e) => Issue.fromPartial(e)) || [];
    message.summary = object.summary?.map((e) => LintResponse_SummaryEntry.fromPartial(e)) || [];
    message.state = object.state ?? 0;
    message.source = object.source ?? "";
    message.linter = object.linter ?? 0;
    message.createTime = object.createTime ?? undefined;
    return message;
  },
};

function createBaseLintResponse_SummaryEntry(): LintResponse_SummaryEntry {
  return { severity: 0, count: 0 };
}

export const LintResponse_SummaryEntry: MessageFns<LintResponse_SummaryEntry> = {
  encode(message: LintResponse_SummaryEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.severity !== 0) {
      writer.uint32(8).int32(message.severity);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LintResponse_SummaryEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLintResponse_SummaryEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LintResponse_SummaryEntry {
    return {
      severity: isSet(object.severity) ? severityFromJSON(object.severity) : 0,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: LintResponse_SummaryEntry): unknown {
    const obj: any = {};
    if (message.severity !== 0) {
      obj.severity = severityToJSON(message.severity);
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<LintResponse_SummaryEntry>): LintResponse_SummaryEntry {
    return LintResponse_SummaryEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LintResponse_SummaryEntry>): LintResponse_SummaryEntry {
    const message = createBaseLintResponse_SummaryEntry();
    message.severity = object.severity ?? 0;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseIssue(): Issue {
  return { code: "", path: [], message: "", severity: 0, range: undefined };
}

export const Issue: MessageFns<Issue> = {
  encode(message: Issue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    for (const v of message.path) {
      writer.uint32(18).string(v!);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    if (message.severity !== 0) {
      writer.uint32(32).int32(message.severity);
    }
    if (message.range !== undefined) {
      Range.encode(message.range, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Issue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.range = Range.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Issue {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => globalThis.String(e)) : [],
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      severity: isSet(object.severity) ? severityFromJSON(object.severity) : 0,
      range: isSet(object.range) ? Range.fromJSON(object.range) : undefined,
    };
  },

  toJSON(message: Issue): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.path?.length) {
      obj.path = message.path;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.severity !== 0) {
      obj.severity = severityToJSON(message.severity);
    }
    if (message.range !== undefined) {
      obj.range = Range.toJSON(message.range);
    }
    return obj;
  },

  create(base?: DeepPartial<Issue>): Issue {
    return Issue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Issue>): Issue {
    const message = createBaseIssue();
    message.code = object.code ?? "";
    message.path = object.path?.map((e) => e) || [];
    message.message = object.message ?? "";
    message.severity = object.severity ?? 0;
    message.range = (object.range !== undefined && object.range !== null) ? Range.fromPartial(object.range) : undefined;
    return message;
  },
};

function createBaseRange(): Range {
  return { start: undefined, end: undefined };
}

export const Range: MessageFns<Range> = {
  encode(message: Range, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.start !== undefined) {
      Point.encode(message.start, writer.uint32(10).fork()).join();
    }
    if (message.end !== undefined) {
      Point.encode(message.end, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Range {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.start = Point.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.end = Point.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Range {
    return {
      start: isSet(object.start) ? Point.fromJSON(object.start) : undefined,
      end: isSet(object.end) ? Point.fromJSON(object.end) : undefined,
    };
  },

  toJSON(message: Range): unknown {
    const obj: any = {};
    if (message.start !== undefined) {
      obj.start = Point.toJSON(message.start);
    }
    if (message.end !== undefined) {
      obj.end = Point.toJSON(message.end);
    }
    return obj;
  },

  create(base?: DeepPartial<Range>): Range {
    return Range.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Range>): Range {
    const message = createBaseRange();
    message.start = (object.start !== undefined && object.start !== null) ? Point.fromPartial(object.start) : undefined;
    message.end = (object.end !== undefined && object.end !== null) ? Point.fromPartial(object.end) : undefined;
    return message;
  },
};

function createBasePoint(): Point {
  return { line: 0, character: 0 };
}

export const Point: MessageFns<Point> = {
  encode(message: Point, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.line !== 0) {
      writer.uint32(8).int32(message.line);
    }
    if (message.character !== 0) {
      writer.uint32(16).int32(message.character);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Point {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.line = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.character = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Point {
    return {
      line: isSet(object.line) ? globalThis.Number(object.line) : 0,
      character: isSet(object.character) ? globalThis.Number(object.character) : 0,
    };
  },

  toJSON(message: Point): unknown {
    const obj: any = {};
    if (message.line !== 0) {
      obj.line = Math.round(message.line);
    }
    if (message.character !== 0) {
      obj.character = Math.round(message.character);
    }
    return obj;
  },

  create(base?: DeepPartial<Point>): Point {
    return Point.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Point>): Point {
    const message = createBasePoint();
    message.line = object.line ?? 0;
    message.character = object.character ?? 0;
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return {
    createTime: undefined,
    endTime: undefined,
    target: "",
    verb: "",
    statusMessage: "",
    requestedCancellation: false,
    apiVersion: "",
  };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.requestedCancellation !== false) {
      writer.uint32(48).bool(message.requestedCancellation);
    }
    if (message.apiVersion !== "") {
      writer.uint32(58).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.requestedCancellation = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      requestedCancellation: isSet(object.requestedCancellation)
        ? globalThis.Boolean(object.requestedCancellation)
        : false,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.requestedCancellation !== false) {
      obj.requestedCancellation = message.requestedCancellation;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.requestedCancellation = object.requestedCancellation ?? false;
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

function createBaseApiHubInstance(): ApiHubInstance {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    state: 0,
    stateMessage: "",
    config: undefined,
    labels: {},
    description: "",
  };
}

export const ApiHubInstance: MessageFns<ApiHubInstance> = {
  encode(message: ApiHubInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.stateMessage !== "") {
      writer.uint32(42).string(message.stateMessage);
    }
    if (message.config !== undefined) {
      ApiHubInstance_Config.encode(message.config, writer.uint32(50).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ApiHubInstance_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiHubInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiHubInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.stateMessage = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.config = ApiHubInstance_Config.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = ApiHubInstance_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiHubInstance {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? apiHubInstance_StateFromJSON(object.state) : 0,
      stateMessage: isSet(object.stateMessage) ? globalThis.String(object.stateMessage) : "",
      config: isSet(object.config) ? ApiHubInstance_Config.fromJSON(object.config) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ApiHubInstance): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = apiHubInstance_StateToJSON(message.state);
    }
    if (message.stateMessage !== "") {
      obj.stateMessage = message.stateMessage;
    }
    if (message.config !== undefined) {
      obj.config = ApiHubInstance_Config.toJSON(message.config);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiHubInstance>): ApiHubInstance {
    return ApiHubInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiHubInstance>): ApiHubInstance {
    const message = createBaseApiHubInstance();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    message.stateMessage = object.stateMessage ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? ApiHubInstance_Config.fromPartial(object.config)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseApiHubInstance_Config(): ApiHubInstance_Config {
  return { cmekKeyName: "" };
}

export const ApiHubInstance_Config: MessageFns<ApiHubInstance_Config> = {
  encode(message: ApiHubInstance_Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cmekKeyName !== "") {
      writer.uint32(10).string(message.cmekKeyName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiHubInstance_Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiHubInstance_Config();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cmekKeyName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiHubInstance_Config {
    return { cmekKeyName: isSet(object.cmekKeyName) ? globalThis.String(object.cmekKeyName) : "" };
  },

  toJSON(message: ApiHubInstance_Config): unknown {
    const obj: any = {};
    if (message.cmekKeyName !== "") {
      obj.cmekKeyName = message.cmekKeyName;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiHubInstance_Config>): ApiHubInstance_Config {
    return ApiHubInstance_Config.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiHubInstance_Config>): ApiHubInstance_Config {
    const message = createBaseApiHubInstance_Config();
    message.cmekKeyName = object.cmekKeyName ?? "";
    return message;
  },
};

function createBaseApiHubInstance_LabelsEntry(): ApiHubInstance_LabelsEntry {
  return { key: "", value: "" };
}

export const ApiHubInstance_LabelsEntry: MessageFns<ApiHubInstance_LabelsEntry> = {
  encode(message: ApiHubInstance_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApiHubInstance_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApiHubInstance_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApiHubInstance_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ApiHubInstance_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ApiHubInstance_LabelsEntry>): ApiHubInstance_LabelsEntry {
    return ApiHubInstance_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ApiHubInstance_LabelsEntry>): ApiHubInstance_LabelsEntry {
    const message = createBaseApiHubInstance_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseExternalApi(): ExternalApi {
  return {
    name: "",
    displayName: "",
    description: "",
    endpoints: [],
    paths: [],
    documentation: undefined,
    attributes: {},
    createTime: undefined,
    updateTime: undefined,
  };
}

export const ExternalApi: MessageFns<ExternalApi> = {
  encode(message: ExternalApi, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.endpoints) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.paths) {
      writer.uint32(42).string(v!);
    }
    if (message.documentation !== undefined) {
      Documentation.encode(message.documentation, writer.uint32(50).fork()).join();
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      ExternalApi_AttributesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalApi {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalApi();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.paths.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.documentation = Documentation.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = ExternalApi_AttributesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.attributes[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalApi {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e: any) => globalThis.String(e)) : [],
      documentation: isSet(object.documentation) ? Documentation.fromJSON(object.documentation) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: ExternalApi): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.paths?.length) {
      obj.paths = message.paths;
    }
    if (message.documentation !== undefined) {
      obj.documentation = Documentation.toJSON(message.documentation);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalApi>): ExternalApi {
    return ExternalApi.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalApi>): ExternalApi {
    const message = createBaseExternalApi();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.paths = object.paths?.map((e) => e) || [];
    message.documentation = (object.documentation !== undefined && object.documentation !== null)
      ? Documentation.fromPartial(object.documentation)
      : undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseExternalApi_AttributesEntry(): ExternalApi_AttributesEntry {
  return { key: "", value: undefined };
}

export const ExternalApi_AttributesEntry: MessageFns<ExternalApi_AttributesEntry> = {
  encode(message: ExternalApi_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalApi_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalApi_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalApi_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ExternalApi_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<ExternalApi_AttributesEntry>): ExternalApi_AttributesEntry {
    return ExternalApi_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExternalApi_AttributesEntry>): ExternalApi_AttributesEntry {
    const message = createBaseExternalApi_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
