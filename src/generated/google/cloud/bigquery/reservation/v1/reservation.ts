// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/reservation/v1/reservation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../../protobuf/empty.js";
import { FieldMask } from "../../../../protobuf/field_mask.js";
import { Timestamp } from "../../../../protobuf/timestamp.js";
import { Status } from "../../../../rpc/status.js";

export const protobufPackage = "google.cloud.bigquery.reservation.v1";

/**
 * The type of editions.
 * Different features and behaviors are provided to different editions
 * Capacity commitments and reservations are linked to editions.
 */
export enum Edition {
  /** EDITION_UNSPECIFIED - Default value, which will be treated as ENTERPRISE. */
  EDITION_UNSPECIFIED = 0,
  /** STANDARD - Standard edition. */
  STANDARD = 1,
  /** ENTERPRISE - Enterprise edition. */
  ENTERPRISE = 2,
  /** ENTERPRISE_PLUS - Enterprise plus edition. */
  ENTERPRISE_PLUS = 3,
  UNRECOGNIZED = -1,
}

export function editionFromJSON(object: any): Edition {
  switch (object) {
    case 0:
    case "EDITION_UNSPECIFIED":
      return Edition.EDITION_UNSPECIFIED;
    case 1:
    case "STANDARD":
      return Edition.STANDARD;
    case 2:
    case "ENTERPRISE":
      return Edition.ENTERPRISE;
    case 3:
    case "ENTERPRISE_PLUS":
      return Edition.ENTERPRISE_PLUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Edition.UNRECOGNIZED;
  }
}

export function editionToJSON(object: Edition): string {
  switch (object) {
    case Edition.EDITION_UNSPECIFIED:
      return "EDITION_UNSPECIFIED";
    case Edition.STANDARD:
      return "STANDARD";
    case Edition.ENTERPRISE:
      return "ENTERPRISE";
    case Edition.ENTERPRISE_PLUS:
      return "ENTERPRISE_PLUS";
    case Edition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A reservation is a mechanism used to guarantee slots to users. */
export interface Reservation {
  /**
   * The resource name of the reservation, e.g.,
   * `projects/* /locations/* /reservations/team1-prod`.
   * The reservation_id must only contain lower case alphanumeric characters or
   * dashes. It must start with a letter and must not end with a dash. Its
   * maximum length is 64 characters.
   */
  name: string;
  /**
   * Minimum slots available to this reservation. A slot is a unit of
   * computational power in BigQuery, and serves as the unit of parallelism.
   *
   * Queries using this reservation might use more slots during runtime if
   * ignore_idle_slots is set to false.
   *
   * If total slot_capacity of the reservation and its siblings
   * exceeds the total slot_count of all capacity commitments, the request will
   * fail with `google.rpc.Code.RESOURCE_EXHAUSTED`.
   *
   * NOTE: for reservations in US or EU multi-regions, slot capacity constraints
   * are checked separately for default and auxiliary regions. See
   * multi_region_auxiliary flag for more details.
   */
  slotCapacity: Long;
  /**
   * If false, any query or pipeline job using this reservation will use idle
   * slots from other reservations within the same admin project. If true, a
   * query or pipeline job using this reservation will execute with the slot
   * capacity specified in the slot_capacity field at most.
   */
  ignoreIdleSlots: boolean;
  /**
   * The configuration parameters for the auto scaling feature. Note this is an
   * alpha feature.
   */
  autoscale:
    | Reservation_Autoscale
    | undefined;
  /**
   * Job concurrency target which sets a soft upper bound on the number of jobs
   * that can run concurrently in this reservation. This is a soft target due to
   * asynchronous nature of the system and various optimizations for small
   * queries.
   * Default value is 0 which means that concurrency target will be
   * automatically computed by the system.
   * NOTE: this field is exposed as `target_job_concurrency` in the Information
   * Schema, DDL and BQ CLI.
   */
  concurrency: Long;
  /** Output only. Creation time of the reservation. */
  creationTime:
    | Date
    | undefined;
  /** Output only. Last update time of the reservation. */
  updateTime:
    | Date
    | undefined;
  /**
   * Applicable only for reservations located within one of the BigQuery
   * multi-regions (US or EU).
   *
   * If set to true, this reservation is placed in the organization's
   * secondary region which is designated for disaster recovery purposes.
   * If false, this reservation is placed in the organization's default region.
   *
   * NOTE: this is a preview feature. Project must be allow-listed in order to
   * set this field.
   */
  multiRegionAuxiliary: boolean;
  /** Edition of the reservation. */
  edition: Edition;
}

/** Auto scaling settings. */
export interface Reservation_Autoscale {
  /**
   * Output only. The slot capacity added to this reservation when autoscale
   * happens. Will be between [0, max_slots].
   */
  currentSlots: Long;
  /** Number of slots to be scaled when needed. */
  maxSlots: Long;
}

/**
 * Capacity commitment is a way to purchase compute capacity for BigQuery jobs
 * (in the form of slots) with some committed period of usage. Annual
 * commitments renew by default. Commitments can be removed after their
 * commitment end time passes.
 *
 * In order to remove annual commitment, its plan needs to be changed
 * to monthly or flex first.
 *
 * A capacity commitment resource exists as a child resource of the admin
 * project.
 */
export interface CapacityCommitment {
  /**
   * Output only. The resource name of the capacity commitment, e.g.,
   * `projects/myproject/locations/US/capacityCommitments/123`
   * The commitment_id must only contain lower case alphanumeric characters or
   * dashes. It must start with a letter and must not end
   * with a dash. Its maximum length is 64 characters.
   */
  name: string;
  /** Number of slots in this commitment. */
  slotCount: Long;
  /** Capacity commitment commitment plan. */
  plan: CapacityCommitment_CommitmentPlan;
  /** Output only. State of the commitment. */
  state: CapacityCommitment_State;
  /**
   * Output only. The start of the current commitment period. It is applicable
   * only for ACTIVE capacity commitments.
   */
  commitmentStartTime:
    | Date
    | undefined;
  /**
   * Output only. The end of the current commitment period. It is applicable
   * only for ACTIVE capacity commitments.
   */
  commitmentEndTime:
    | Date
    | undefined;
  /** Output only. For FAILED commitment plan, provides the reason of failure. */
  failureStatus:
    | Status
    | undefined;
  /**
   * The plan this capacity commitment is converted to after commitment_end_time
   * passes. Once the plan is changed, committed period is extended according to
   * commitment plan. Only applicable for ANNUAL and TRIAL commitments.
   */
  renewalPlan: CapacityCommitment_CommitmentPlan;
  /**
   * Applicable only for commitments located within one of the BigQuery
   * multi-regions (US or EU).
   *
   * If set to true, this commitment is placed in the organization's
   * secondary region which is designated for disaster recovery purposes.
   * If false, this commitment is placed in the organization's default region.
   *
   * NOTE: this is a preview feature. Project must be allow-listed in order to
   * set this field.
   */
  multiRegionAuxiliary: boolean;
  /** Edition of the capacity commitment. */
  edition: Edition;
}

/**
 * Commitment plan defines the current committed period. Capacity commitment
 * cannot be deleted during it's committed period.
 */
export enum CapacityCommitment_CommitmentPlan {
  /**
   * COMMITMENT_PLAN_UNSPECIFIED - Invalid plan value. Requests with this value will be rejected with
   * error code `google.rpc.Code.INVALID_ARGUMENT`.
   */
  COMMITMENT_PLAN_UNSPECIFIED = 0,
  /**
   * FLEX - Flex commitments have committed period of 1 minute after becoming ACTIVE.
   * After that, they are not in a committed period anymore and can be removed
   * any time.
   */
  FLEX = 3,
  /**
   * FLEX_FLAT_RATE - Same as FLEX, should only be used if flat-rate commitments are still
   * available.
   *
   * @deprecated
   */
  FLEX_FLAT_RATE = 7,
  /**
   * TRIAL - Trial commitments have a committed period of 182 days after becoming
   * ACTIVE. After that, they are converted to a new commitment based on the
   * `renewal_plan`. Default `renewal_plan` for Trial commitment is Flex so
   * that it can be deleted right after committed period ends.
   */
  TRIAL = 5,
  /**
   * MONTHLY - Monthly commitments have a committed period of 30 days after becoming
   * ACTIVE. After that, they are not in a committed period anymore and can be
   * removed any time.
   */
  MONTHLY = 2,
  /**
   * MONTHLY_FLAT_RATE - Same as MONTHLY, should only be used if flat-rate commitments are still
   * available.
   *
   * @deprecated
   */
  MONTHLY_FLAT_RATE = 8,
  /**
   * ANNUAL - Annual commitments have a committed period of 365 days after becoming
   * ACTIVE. After that they are converted to a new commitment based on the
   * renewal_plan.
   */
  ANNUAL = 4,
  /**
   * ANNUAL_FLAT_RATE - Same as ANNUAL, should only be used if flat-rate commitments are still
   * available.
   *
   * @deprecated
   */
  ANNUAL_FLAT_RATE = 9,
  /**
   * THREE_YEAR - 3-year commitments have a committed period of 1095(3 * 365) days after
   * becoming ACTIVE. After that they are converted to a new commitment based
   * on the renewal_plan.
   */
  THREE_YEAR = 10,
  /**
   * NONE - Should only be used for `renewal_plan` and is only meaningful if
   * edition is specified to values other than EDITION_UNSPECIFIED. Otherwise
   * CreateCapacityCommitmentRequest or UpdateCapacityCommitmentRequest will
   * be rejected with error code `google.rpc.Code.INVALID_ARGUMENT`. If the
   * renewal_plan is NONE, capacity commitment will be removed at the end of
   * its commitment period.
   */
  NONE = 6,
  UNRECOGNIZED = -1,
}

export function capacityCommitment_CommitmentPlanFromJSON(object: any): CapacityCommitment_CommitmentPlan {
  switch (object) {
    case 0:
    case "COMMITMENT_PLAN_UNSPECIFIED":
      return CapacityCommitment_CommitmentPlan.COMMITMENT_PLAN_UNSPECIFIED;
    case 3:
    case "FLEX":
      return CapacityCommitment_CommitmentPlan.FLEX;
    case 7:
    case "FLEX_FLAT_RATE":
      return CapacityCommitment_CommitmentPlan.FLEX_FLAT_RATE;
    case 5:
    case "TRIAL":
      return CapacityCommitment_CommitmentPlan.TRIAL;
    case 2:
    case "MONTHLY":
      return CapacityCommitment_CommitmentPlan.MONTHLY;
    case 8:
    case "MONTHLY_FLAT_RATE":
      return CapacityCommitment_CommitmentPlan.MONTHLY_FLAT_RATE;
    case 4:
    case "ANNUAL":
      return CapacityCommitment_CommitmentPlan.ANNUAL;
    case 9:
    case "ANNUAL_FLAT_RATE":
      return CapacityCommitment_CommitmentPlan.ANNUAL_FLAT_RATE;
    case 10:
    case "THREE_YEAR":
      return CapacityCommitment_CommitmentPlan.THREE_YEAR;
    case 6:
    case "NONE":
      return CapacityCommitment_CommitmentPlan.NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CapacityCommitment_CommitmentPlan.UNRECOGNIZED;
  }
}

export function capacityCommitment_CommitmentPlanToJSON(object: CapacityCommitment_CommitmentPlan): string {
  switch (object) {
    case CapacityCommitment_CommitmentPlan.COMMITMENT_PLAN_UNSPECIFIED:
      return "COMMITMENT_PLAN_UNSPECIFIED";
    case CapacityCommitment_CommitmentPlan.FLEX:
      return "FLEX";
    case CapacityCommitment_CommitmentPlan.FLEX_FLAT_RATE:
      return "FLEX_FLAT_RATE";
    case CapacityCommitment_CommitmentPlan.TRIAL:
      return "TRIAL";
    case CapacityCommitment_CommitmentPlan.MONTHLY:
      return "MONTHLY";
    case CapacityCommitment_CommitmentPlan.MONTHLY_FLAT_RATE:
      return "MONTHLY_FLAT_RATE";
    case CapacityCommitment_CommitmentPlan.ANNUAL:
      return "ANNUAL";
    case CapacityCommitment_CommitmentPlan.ANNUAL_FLAT_RATE:
      return "ANNUAL_FLAT_RATE";
    case CapacityCommitment_CommitmentPlan.THREE_YEAR:
      return "THREE_YEAR";
    case CapacityCommitment_CommitmentPlan.NONE:
      return "NONE";
    case CapacityCommitment_CommitmentPlan.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Capacity commitment can either become ACTIVE right away or transition
 * from PENDING to ACTIVE or FAILED.
 */
export enum CapacityCommitment_State {
  /** STATE_UNSPECIFIED - Invalid state value. */
  STATE_UNSPECIFIED = 0,
  /**
   * PENDING - Capacity commitment is pending provisioning. Pending capacity commitment
   * does not contribute to the project's slot_capacity.
   */
  PENDING = 1,
  /**
   * ACTIVE - Once slots are provisioned, capacity commitment becomes active.
   * slot_count is added to the project's slot_capacity.
   */
  ACTIVE = 2,
  /** FAILED - Capacity commitment is failed to be activated by the backend. */
  FAILED = 3,
  UNRECOGNIZED = -1,
}

export function capacityCommitment_StateFromJSON(object: any): CapacityCommitment_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return CapacityCommitment_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return CapacityCommitment_State.PENDING;
    case 2:
    case "ACTIVE":
      return CapacityCommitment_State.ACTIVE;
    case 3:
    case "FAILED":
      return CapacityCommitment_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CapacityCommitment_State.UNRECOGNIZED;
  }
}

export function capacityCommitment_StateToJSON(object: CapacityCommitment_State): string {
  switch (object) {
    case CapacityCommitment_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case CapacityCommitment_State.PENDING:
      return "PENDING";
    case CapacityCommitment_State.ACTIVE:
      return "ACTIVE";
    case CapacityCommitment_State.FAILED:
      return "FAILED";
    case CapacityCommitment_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The request for
 * [ReservationService.CreateReservation][google.cloud.bigquery.reservation.v1.ReservationService.CreateReservation].
 */
export interface CreateReservationRequest {
  /**
   * Required. Project, location. E.g.,
   * `projects/myproject/locations/US`
   */
  parent: string;
  /**
   * The reservation ID. It must only contain lower case alphanumeric
   * characters or dashes. It must start with a letter and must not end
   * with a dash. Its maximum length is 64 characters.
   */
  reservationId: string;
  /** Definition of the new reservation to create. */
  reservation: Reservation | undefined;
}

/**
 * The request for
 * [ReservationService.ListReservations][google.cloud.bigquery.reservation.v1.ReservationService.ListReservations].
 */
export interface ListReservationsRequest {
  /**
   * Required. The parent resource name containing project and location, e.g.:
   *   `projects/myproject/locations/US`
   */
  parent: string;
  /** The maximum number of items to return per page. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
}

/**
 * The response for
 * [ReservationService.ListReservations][google.cloud.bigquery.reservation.v1.ReservationService.ListReservations].
 */
export interface ListReservationsResponse {
  /** List of reservations visible to the user. */
  reservations: Reservation[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/**
 * The request for
 * [ReservationService.GetReservation][google.cloud.bigquery.reservation.v1.ReservationService.GetReservation].
 */
export interface GetReservationRequest {
  /**
   * Required. Resource name of the reservation to retrieve. E.g.,
   *    `projects/myproject/locations/US/reservations/team1-prod`
   */
  name: string;
}

/**
 * The request for
 * [ReservationService.DeleteReservation][google.cloud.bigquery.reservation.v1.ReservationService.DeleteReservation].
 */
export interface DeleteReservationRequest {
  /**
   * Required. Resource name of the reservation to retrieve. E.g.,
   *    `projects/myproject/locations/US/reservations/team1-prod`
   */
  name: string;
}

/**
 * The request for
 * [ReservationService.UpdateReservation][google.cloud.bigquery.reservation.v1.ReservationService.UpdateReservation].
 */
export interface UpdateReservationRequest {
  /** Content of the reservation to update. */
  reservation:
    | Reservation
    | undefined;
  /** Standard field mask for the set of fields to be updated. */
  updateMask: string[] | undefined;
}

/**
 * The request for
 * [ReservationService.CreateCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.CreateCapacityCommitment].
 */
export interface CreateCapacityCommitmentRequest {
  /**
   * Required. Resource name of the parent reservation. E.g.,
   *    `projects/myproject/locations/US`
   */
  parent: string;
  /** Content of the capacity commitment to create. */
  capacityCommitment:
    | CapacityCommitment
    | undefined;
  /**
   * If true, fail the request if another project in the organization has a
   * capacity commitment.
   */
  enforceSingleAdminProjectPerOrg: boolean;
  /**
   * The optional capacity commitment ID. Capacity commitment name will be
   * generated automatically if this field is empty.
   * This field must only contain lower case alphanumeric characters or dashes.
   * The first and last character cannot be a dash. Max length is 64 characters.
   * NOTE: this ID won't be kept if the capacity commitment is split or merged.
   */
  capacityCommitmentId: string;
}

/**
 * The request for
 * [ReservationService.ListCapacityCommitments][google.cloud.bigquery.reservation.v1.ReservationService.ListCapacityCommitments].
 */
export interface ListCapacityCommitmentsRequest {
  /**
   * Required. Resource name of the parent reservation. E.g.,
   *    `projects/myproject/locations/US`
   */
  parent: string;
  /** The maximum number of items to return. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
}

/**
 * The response for
 * [ReservationService.ListCapacityCommitments][google.cloud.bigquery.reservation.v1.ReservationService.ListCapacityCommitments].
 */
export interface ListCapacityCommitmentsResponse {
  /** List of capacity commitments visible to the user. */
  capacityCommitments: CapacityCommitment[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/**
 * The request for
 * [ReservationService.GetCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.GetCapacityCommitment].
 */
export interface GetCapacityCommitmentRequest {
  /**
   * Required. Resource name of the capacity commitment to retrieve. E.g.,
   *    `projects/myproject/locations/US/capacityCommitments/123`
   */
  name: string;
}

/**
 * The request for
 * [ReservationService.DeleteCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.DeleteCapacityCommitment].
 */
export interface DeleteCapacityCommitmentRequest {
  /**
   * Required. Resource name of the capacity commitment to delete. E.g.,
   *    `projects/myproject/locations/US/capacityCommitments/123`
   */
  name: string;
  /**
   * Can be used to force delete commitments even if assignments exist. Deleting
   * commitments with assignments may cause queries to fail if they no longer
   * have access to slots.
   */
  force: boolean;
}

/**
 * The request for
 * [ReservationService.UpdateCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.UpdateCapacityCommitment].
 */
export interface UpdateCapacityCommitmentRequest {
  /** Content of the capacity commitment to update. */
  capacityCommitment:
    | CapacityCommitment
    | undefined;
  /** Standard field mask for the set of fields to be updated. */
  updateMask: string[] | undefined;
}

/**
 * The request for
 * [ReservationService.SplitCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.SplitCapacityCommitment].
 */
export interface SplitCapacityCommitmentRequest {
  /**
   * Required. The resource name e.g.,:
   *  `projects/myproject/locations/US/capacityCommitments/123`
   */
  name: string;
  /** Number of slots in the capacity commitment after the split. */
  slotCount: Long;
}

/**
 * The response for
 * [ReservationService.SplitCapacityCommitment][google.cloud.bigquery.reservation.v1.ReservationService.SplitCapacityCommitment].
 */
export interface SplitCapacityCommitmentResponse {
  /** First capacity commitment, result of a split. */
  first:
    | CapacityCommitment
    | undefined;
  /** Second capacity commitment, result of a split. */
  second: CapacityCommitment | undefined;
}

/**
 * The request for
 * [ReservationService.MergeCapacityCommitments][google.cloud.bigquery.reservation.v1.ReservationService.MergeCapacityCommitments].
 */
export interface MergeCapacityCommitmentsRequest {
  /**
   * Parent resource that identifies admin project and location e.g.,
   *  `projects/myproject/locations/us`
   */
  parent: string;
  /**
   * Ids of capacity commitments to merge.
   * These capacity commitments must exist under admin project and location
   * specified in the parent.
   * ID is the last portion of capacity commitment name e.g., 'abc' for
   * projects/myproject/locations/US/capacityCommitments/abc
   */
  capacityCommitmentIds: string[];
}

/**
 * An assignment allows a project to submit jobs
 * of a certain type using slots from the specified reservation.
 */
export interface Assignment {
  /**
   * Output only. Name of the resource. E.g.:
   * `projects/myproject/locations/US/reservations/team1-prod/assignments/123`.
   * The assignment_id must only contain lower case alphanumeric characters or
   * dashes and the max length is 64 characters.
   */
  name: string;
  /**
   * The resource which will use the reservation. E.g.
   * `projects/myproject`, `folders/123`, or `organizations/456`.
   */
  assignee: string;
  /** Which type of jobs will use the reservation. */
  jobType: Assignment_JobType;
  /** Output only. State of the assignment. */
  state: Assignment_State;
}

/** Types of job, which could be specified when using the reservation. */
export enum Assignment_JobType {
  /**
   * JOB_TYPE_UNSPECIFIED - Invalid type. Requests with this value will be rejected with
   * error code `google.rpc.Code.INVALID_ARGUMENT`.
   */
  JOB_TYPE_UNSPECIFIED = 0,
  /** PIPELINE - Pipeline (load/export) jobs from the project will use the reservation. */
  PIPELINE = 1,
  /** QUERY - Query jobs from the project will use the reservation. */
  QUERY = 2,
  /**
   * ML_EXTERNAL - BigQuery ML jobs that use services external to BigQuery for model
   * training. These jobs will not utilize idle slots from other reservations.
   */
  ML_EXTERNAL = 3,
  /** BACKGROUND - Background jobs that BigQuery runs for the customers in the background. */
  BACKGROUND = 4,
  UNRECOGNIZED = -1,
}

export function assignment_JobTypeFromJSON(object: any): Assignment_JobType {
  switch (object) {
    case 0:
    case "JOB_TYPE_UNSPECIFIED":
      return Assignment_JobType.JOB_TYPE_UNSPECIFIED;
    case 1:
    case "PIPELINE":
      return Assignment_JobType.PIPELINE;
    case 2:
    case "QUERY":
      return Assignment_JobType.QUERY;
    case 3:
    case "ML_EXTERNAL":
      return Assignment_JobType.ML_EXTERNAL;
    case 4:
    case "BACKGROUND":
      return Assignment_JobType.BACKGROUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Assignment_JobType.UNRECOGNIZED;
  }
}

export function assignment_JobTypeToJSON(object: Assignment_JobType): string {
  switch (object) {
    case Assignment_JobType.JOB_TYPE_UNSPECIFIED:
      return "JOB_TYPE_UNSPECIFIED";
    case Assignment_JobType.PIPELINE:
      return "PIPELINE";
    case Assignment_JobType.QUERY:
      return "QUERY";
    case Assignment_JobType.ML_EXTERNAL:
      return "ML_EXTERNAL";
    case Assignment_JobType.BACKGROUND:
      return "BACKGROUND";
    case Assignment_JobType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Assignment will remain in PENDING state if no active capacity commitment is
 * present. It will become ACTIVE when some capacity commitment becomes
 * active.
 */
export enum Assignment_State {
  /** STATE_UNSPECIFIED - Invalid state value. */
  STATE_UNSPECIFIED = 0,
  /**
   * PENDING - Queries from assignee will be executed as on-demand, if related
   * assignment is pending.
   */
  PENDING = 1,
  /** ACTIVE - Assignment is ready. */
  ACTIVE = 2,
  UNRECOGNIZED = -1,
}

export function assignment_StateFromJSON(object: any): Assignment_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Assignment_State.STATE_UNSPECIFIED;
    case 1:
    case "PENDING":
      return Assignment_State.PENDING;
    case 2:
    case "ACTIVE":
      return Assignment_State.ACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Assignment_State.UNRECOGNIZED;
  }
}

export function assignment_StateToJSON(object: Assignment_State): string {
  switch (object) {
    case Assignment_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Assignment_State.PENDING:
      return "PENDING";
    case Assignment_State.ACTIVE:
      return "ACTIVE";
    case Assignment_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The request for
 * [ReservationService.CreateAssignment][google.cloud.bigquery.reservation.v1.ReservationService.CreateAssignment].
 * Note: "bigquery.reservationAssignments.create" permission is required on the
 * related assignee.
 */
export interface CreateAssignmentRequest {
  /**
   * Required. The parent resource name of the assignment
   * E.g. `projects/myproject/locations/US/reservations/team1-prod`
   */
  parent: string;
  /** Assignment resource to create. */
  assignment:
    | Assignment
    | undefined;
  /**
   * The optional assignment ID. Assignment name will be generated automatically
   * if this field is empty.
   * This field must only contain lower case alphanumeric characters or dashes.
   * Max length is 64 characters.
   */
  assignmentId: string;
}

/**
 * The request for
 * [ReservationService.ListAssignments][google.cloud.bigquery.reservation.v1.ReservationService.ListAssignments].
 */
export interface ListAssignmentsRequest {
  /**
   * Required. The parent resource name e.g.:
   *
   * `projects/myproject/locations/US/reservations/team1-prod`
   *
   * Or:
   *
   * `projects/myproject/locations/US/reservations/-`
   */
  parent: string;
  /** The maximum number of items to return per page. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
}

/**
 * The response for
 * [ReservationService.ListAssignments][google.cloud.bigquery.reservation.v1.ReservationService.ListAssignments].
 */
export interface ListAssignmentsResponse {
  /** List of assignments visible to the user. */
  assignments: Assignment[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/**
 * The request for
 * [ReservationService.DeleteAssignment][google.cloud.bigquery.reservation.v1.ReservationService.DeleteAssignment].
 * Note: "bigquery.reservationAssignments.delete" permission is required on the
 * related assignee.
 */
export interface DeleteAssignmentRequest {
  /**
   * Required. Name of the resource, e.g.
   *   `projects/myproject/locations/US/reservations/team1-prod/assignments/123`
   */
  name: string;
}

/**
 * The request for
 * [ReservationService.SearchAssignments][google.cloud.bigquery.reservation.v1.ReservationService.SearchAssignments].
 * Note: "bigquery.reservationAssignments.search" permission is required on the
 * related assignee.
 */
export interface SearchAssignmentsRequest {
  /**
   * Required. The resource name of the admin project(containing project and
   * location), e.g.:
   *   `projects/myproject/locations/US`.
   */
  parent: string;
  /**
   * Please specify resource name as assignee in the query.
   *
   * Examples:
   *
   * * `assignee=projects/myproject`
   * * `assignee=folders/123`
   * * `assignee=organizations/456`
   */
  query: string;
  /** The maximum number of items to return per page. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
}

/**
 * The request for
 * [ReservationService.SearchAllAssignments][google.cloud.bigquery.reservation.v1.ReservationService.SearchAllAssignments].
 * Note: "bigquery.reservationAssignments.search" permission is required on the
 * related assignee.
 */
export interface SearchAllAssignmentsRequest {
  /**
   * Required. The resource name with location (project name could be the
   * wildcard '-'), e.g.:
   *   `projects/-/locations/US`.
   */
  parent: string;
  /**
   * Please specify resource name as assignee in the query.
   *
   * Examples:
   *
   * * `assignee=projects/myproject`
   * * `assignee=folders/123`
   * * `assignee=organizations/456`
   */
  query: string;
  /** The maximum number of items to return per page. */
  pageSize: number;
  /** The next_page_token value returned from a previous List request, if any. */
  pageToken: string;
}

/**
 * The response for
 * [ReservationService.SearchAssignments][google.cloud.bigquery.reservation.v1.ReservationService.SearchAssignments].
 */
export interface SearchAssignmentsResponse {
  /** List of assignments visible to the user. */
  assignments: Assignment[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/**
 * The response for
 * [ReservationService.SearchAllAssignments][google.cloud.bigquery.reservation.v1.ReservationService.SearchAllAssignments].
 */
export interface SearchAllAssignmentsResponse {
  /** List of assignments visible to the user. */
  assignments: Assignment[];
  /**
   * Token to retrieve the next page of results, or empty if there are no
   * more results in the list.
   */
  nextPageToken: string;
}

/**
 * The request for
 * [ReservationService.MoveAssignment][google.cloud.bigquery.reservation.v1.ReservationService.MoveAssignment].
 *
 * **Note**: "bigquery.reservationAssignments.create" permission is required on
 * the destination_id.
 *
 * **Note**: "bigquery.reservationAssignments.create" and
 * "bigquery.reservationAssignments.delete" permission are required on the
 * related assignee.
 */
export interface MoveAssignmentRequest {
  /**
   * Required. The resource name of the assignment,
   * e.g.
   * `projects/myproject/locations/US/reservations/team1-prod/assignments/123`
   */
  name: string;
  /**
   * The new reservation ID, e.g.:
   *   `projects/myotherproject/locations/US/reservations/team2-prod`
   */
  destinationId: string;
  /**
   * The optional assignment ID. A new assignment name is generated if this
   * field is empty.
   *
   * This field can contain only lowercase alphanumeric characters or dashes.
   * Max length is 64 characters.
   */
  assignmentId: string;
}

/**
 * The request for
 * [ReservationService.UpdateAssignment][google.cloud.bigquery.reservation.v1.ReservationService.UpdateAssignment].
 */
export interface UpdateAssignmentRequest {
  /** Content of the assignment to update. */
  assignment:
    | Assignment
    | undefined;
  /** Standard field mask for the set of fields to be updated. */
  updateMask: string[] | undefined;
}

/**
 * Fully qualified reference to BigQuery table.
 * Internally stored as google.cloud.bi.v1.BqTableReference.
 */
export interface TableReference {
  /** The assigned project ID of the project. */
  projectId: string;
  /** The ID of the dataset in the above project. */
  datasetId: string;
  /** The ID of the table in the above dataset. */
  tableId: string;
}

/** Represents a BI Reservation. */
export interface BiReservation {
  /**
   * The resource name of the singleton BI reservation.
   * Reservation names have the form
   * `projects/{project_id}/locations/{location_id}/biReservation`.
   */
  name: string;
  /** Output only. The last update timestamp of a reservation. */
  updateTime:
    | Date
    | undefined;
  /** Size of a reservation, in bytes. */
  size: Long;
  /** Preferred tables to use BI capacity for. */
  preferredTables: TableReference[];
}

/** A request to get a singleton BI reservation. */
export interface GetBiReservationRequest {
  /**
   * Required. Name of the requested reservation, for example:
   * `projects/{project_id}/locations/{location_id}/biReservation`
   */
  name: string;
}

/** A request to update a BI reservation. */
export interface UpdateBiReservationRequest {
  /** A reservation to update. */
  biReservation:
    | BiReservation
    | undefined;
  /** A list of fields to be updated in this request. */
  updateMask: string[] | undefined;
}

function createBaseReservation(): Reservation {
  return {
    name: "",
    slotCapacity: Long.ZERO,
    ignoreIdleSlots: false,
    autoscale: undefined,
    concurrency: Long.ZERO,
    creationTime: undefined,
    updateTime: undefined,
    multiRegionAuxiliary: false,
    edition: 0,
  };
}

export const Reservation: MessageFns<Reservation> = {
  encode(message: Reservation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.slotCapacity.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.slotCapacity.toString());
    }
    if (message.ignoreIdleSlots !== false) {
      writer.uint32(32).bool(message.ignoreIdleSlots);
    }
    if (message.autoscale !== undefined) {
      Reservation_Autoscale.encode(message.autoscale, writer.uint32(58).fork()).join();
    }
    if (!message.concurrency.equals(Long.ZERO)) {
      writer.uint32(128).int64(message.concurrency.toString());
    }
    if (message.creationTime !== undefined) {
      Timestamp.encode(toTimestamp(message.creationTime), writer.uint32(66).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(74).fork()).join();
    }
    if (message.multiRegionAuxiliary !== false) {
      writer.uint32(112).bool(message.multiRegionAuxiliary);
    }
    if (message.edition !== 0) {
      writer.uint32(136).int32(message.edition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reservation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReservation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slotCapacity = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.ignoreIdleSlots = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.autoscale = Reservation_Autoscale.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.concurrency = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.creationTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.multiRegionAuxiliary = reader.bool();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.edition = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reservation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slotCapacity: isSet(object.slotCapacity) ? Long.fromValue(object.slotCapacity) : Long.ZERO,
      ignoreIdleSlots: isSet(object.ignoreIdleSlots) ? globalThis.Boolean(object.ignoreIdleSlots) : false,
      autoscale: isSet(object.autoscale) ? Reservation_Autoscale.fromJSON(object.autoscale) : undefined,
      concurrency: isSet(object.concurrency) ? Long.fromValue(object.concurrency) : Long.ZERO,
      creationTime: isSet(object.creationTime) ? fromJsonTimestamp(object.creationTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      multiRegionAuxiliary: isSet(object.multiRegionAuxiliary)
        ? globalThis.Boolean(object.multiRegionAuxiliary)
        : false,
      edition: isSet(object.edition) ? editionFromJSON(object.edition) : 0,
    };
  },

  toJSON(message: Reservation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.slotCapacity.equals(Long.ZERO)) {
      obj.slotCapacity = (message.slotCapacity || Long.ZERO).toString();
    }
    if (message.ignoreIdleSlots !== false) {
      obj.ignoreIdleSlots = message.ignoreIdleSlots;
    }
    if (message.autoscale !== undefined) {
      obj.autoscale = Reservation_Autoscale.toJSON(message.autoscale);
    }
    if (!message.concurrency.equals(Long.ZERO)) {
      obj.concurrency = (message.concurrency || Long.ZERO).toString();
    }
    if (message.creationTime !== undefined) {
      obj.creationTime = message.creationTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.multiRegionAuxiliary !== false) {
      obj.multiRegionAuxiliary = message.multiRegionAuxiliary;
    }
    if (message.edition !== 0) {
      obj.edition = editionToJSON(message.edition);
    }
    return obj;
  },

  create(base?: DeepPartial<Reservation>): Reservation {
    return Reservation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Reservation>): Reservation {
    const message = createBaseReservation();
    message.name = object.name ?? "";
    message.slotCapacity = (object.slotCapacity !== undefined && object.slotCapacity !== null)
      ? Long.fromValue(object.slotCapacity)
      : Long.ZERO;
    message.ignoreIdleSlots = object.ignoreIdleSlots ?? false;
    message.autoscale = (object.autoscale !== undefined && object.autoscale !== null)
      ? Reservation_Autoscale.fromPartial(object.autoscale)
      : undefined;
    message.concurrency = (object.concurrency !== undefined && object.concurrency !== null)
      ? Long.fromValue(object.concurrency)
      : Long.ZERO;
    message.creationTime = object.creationTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.multiRegionAuxiliary = object.multiRegionAuxiliary ?? false;
    message.edition = object.edition ?? 0;
    return message;
  },
};

function createBaseReservation_Autoscale(): Reservation_Autoscale {
  return { currentSlots: Long.ZERO, maxSlots: Long.ZERO };
}

export const Reservation_Autoscale: MessageFns<Reservation_Autoscale> = {
  encode(message: Reservation_Autoscale, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.currentSlots.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.currentSlots.toString());
    }
    if (!message.maxSlots.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.maxSlots.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reservation_Autoscale {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReservation_Autoscale();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.currentSlots = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxSlots = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reservation_Autoscale {
    return {
      currentSlots: isSet(object.currentSlots) ? Long.fromValue(object.currentSlots) : Long.ZERO,
      maxSlots: isSet(object.maxSlots) ? Long.fromValue(object.maxSlots) : Long.ZERO,
    };
  },

  toJSON(message: Reservation_Autoscale): unknown {
    const obj: any = {};
    if (!message.currentSlots.equals(Long.ZERO)) {
      obj.currentSlots = (message.currentSlots || Long.ZERO).toString();
    }
    if (!message.maxSlots.equals(Long.ZERO)) {
      obj.maxSlots = (message.maxSlots || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Reservation_Autoscale>): Reservation_Autoscale {
    return Reservation_Autoscale.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Reservation_Autoscale>): Reservation_Autoscale {
    const message = createBaseReservation_Autoscale();
    message.currentSlots = (object.currentSlots !== undefined && object.currentSlots !== null)
      ? Long.fromValue(object.currentSlots)
      : Long.ZERO;
    message.maxSlots = (object.maxSlots !== undefined && object.maxSlots !== null)
      ? Long.fromValue(object.maxSlots)
      : Long.ZERO;
    return message;
  },
};

function createBaseCapacityCommitment(): CapacityCommitment {
  return {
    name: "",
    slotCount: Long.ZERO,
    plan: 0,
    state: 0,
    commitmentStartTime: undefined,
    commitmentEndTime: undefined,
    failureStatus: undefined,
    renewalPlan: 0,
    multiRegionAuxiliary: false,
    edition: 0,
  };
}

export const CapacityCommitment: MessageFns<CapacityCommitment> = {
  encode(message: CapacityCommitment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.slotCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.slotCount.toString());
    }
    if (message.plan !== 0) {
      writer.uint32(24).int32(message.plan);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.commitmentStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.commitmentStartTime), writer.uint32(74).fork()).join();
    }
    if (message.commitmentEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.commitmentEndTime), writer.uint32(42).fork()).join();
    }
    if (message.failureStatus !== undefined) {
      Status.encode(message.failureStatus, writer.uint32(58).fork()).join();
    }
    if (message.renewalPlan !== 0) {
      writer.uint32(64).int32(message.renewalPlan);
    }
    if (message.multiRegionAuxiliary !== false) {
      writer.uint32(80).bool(message.multiRegionAuxiliary);
    }
    if (message.edition !== 0) {
      writer.uint32(96).int32(message.edition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CapacityCommitment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCapacityCommitment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slotCount = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.plan = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.commitmentStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.commitmentEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.failureStatus = Status.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.renewalPlan = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.multiRegionAuxiliary = reader.bool();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.edition = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CapacityCommitment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slotCount: isSet(object.slotCount) ? Long.fromValue(object.slotCount) : Long.ZERO,
      plan: isSet(object.plan) ? capacityCommitment_CommitmentPlanFromJSON(object.plan) : 0,
      state: isSet(object.state) ? capacityCommitment_StateFromJSON(object.state) : 0,
      commitmentStartTime: isSet(object.commitmentStartTime)
        ? fromJsonTimestamp(object.commitmentStartTime)
        : undefined,
      commitmentEndTime: isSet(object.commitmentEndTime) ? fromJsonTimestamp(object.commitmentEndTime) : undefined,
      failureStatus: isSet(object.failureStatus) ? Status.fromJSON(object.failureStatus) : undefined,
      renewalPlan: isSet(object.renewalPlan) ? capacityCommitment_CommitmentPlanFromJSON(object.renewalPlan) : 0,
      multiRegionAuxiliary: isSet(object.multiRegionAuxiliary)
        ? globalThis.Boolean(object.multiRegionAuxiliary)
        : false,
      edition: isSet(object.edition) ? editionFromJSON(object.edition) : 0,
    };
  },

  toJSON(message: CapacityCommitment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.slotCount.equals(Long.ZERO)) {
      obj.slotCount = (message.slotCount || Long.ZERO).toString();
    }
    if (message.plan !== 0) {
      obj.plan = capacityCommitment_CommitmentPlanToJSON(message.plan);
    }
    if (message.state !== 0) {
      obj.state = capacityCommitment_StateToJSON(message.state);
    }
    if (message.commitmentStartTime !== undefined) {
      obj.commitmentStartTime = message.commitmentStartTime.toISOString();
    }
    if (message.commitmentEndTime !== undefined) {
      obj.commitmentEndTime = message.commitmentEndTime.toISOString();
    }
    if (message.failureStatus !== undefined) {
      obj.failureStatus = Status.toJSON(message.failureStatus);
    }
    if (message.renewalPlan !== 0) {
      obj.renewalPlan = capacityCommitment_CommitmentPlanToJSON(message.renewalPlan);
    }
    if (message.multiRegionAuxiliary !== false) {
      obj.multiRegionAuxiliary = message.multiRegionAuxiliary;
    }
    if (message.edition !== 0) {
      obj.edition = editionToJSON(message.edition);
    }
    return obj;
  },

  create(base?: DeepPartial<CapacityCommitment>): CapacityCommitment {
    return CapacityCommitment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CapacityCommitment>): CapacityCommitment {
    const message = createBaseCapacityCommitment();
    message.name = object.name ?? "";
    message.slotCount = (object.slotCount !== undefined && object.slotCount !== null)
      ? Long.fromValue(object.slotCount)
      : Long.ZERO;
    message.plan = object.plan ?? 0;
    message.state = object.state ?? 0;
    message.commitmentStartTime = object.commitmentStartTime ?? undefined;
    message.commitmentEndTime = object.commitmentEndTime ?? undefined;
    message.failureStatus = (object.failureStatus !== undefined && object.failureStatus !== null)
      ? Status.fromPartial(object.failureStatus)
      : undefined;
    message.renewalPlan = object.renewalPlan ?? 0;
    message.multiRegionAuxiliary = object.multiRegionAuxiliary ?? false;
    message.edition = object.edition ?? 0;
    return message;
  },
};

function createBaseCreateReservationRequest(): CreateReservationRequest {
  return { parent: "", reservationId: "", reservation: undefined };
}

export const CreateReservationRequest: MessageFns<CreateReservationRequest> = {
  encode(message: CreateReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.reservationId !== "") {
      writer.uint32(18).string(message.reservationId);
    }
    if (message.reservation !== undefined) {
      Reservation.encode(message.reservation, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reservationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reservation = Reservation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateReservationRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      reservationId: isSet(object.reservationId) ? globalThis.String(object.reservationId) : "",
      reservation: isSet(object.reservation) ? Reservation.fromJSON(object.reservation) : undefined,
    };
  },

  toJSON(message: CreateReservationRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.reservationId !== "") {
      obj.reservationId = message.reservationId;
    }
    if (message.reservation !== undefined) {
      obj.reservation = Reservation.toJSON(message.reservation);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateReservationRequest>): CreateReservationRequest {
    return CreateReservationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateReservationRequest>): CreateReservationRequest {
    const message = createBaseCreateReservationRequest();
    message.parent = object.parent ?? "";
    message.reservationId = object.reservationId ?? "";
    message.reservation = (object.reservation !== undefined && object.reservation !== null)
      ? Reservation.fromPartial(object.reservation)
      : undefined;
    return message;
  },
};

function createBaseListReservationsRequest(): ListReservationsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListReservationsRequest: MessageFns<ListReservationsRequest> = {
  encode(message: ListReservationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReservationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReservationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReservationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListReservationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReservationsRequest>): ListReservationsRequest {
    return ListReservationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReservationsRequest>): ListReservationsRequest {
    const message = createBaseListReservationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListReservationsResponse(): ListReservationsResponse {
  return { reservations: [], nextPageToken: "" };
}

export const ListReservationsResponse: MessageFns<ListReservationsResponse> = {
  encode(message: ListReservationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.reservations) {
      Reservation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListReservationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListReservationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reservations.push(Reservation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListReservationsResponse {
    return {
      reservations: globalThis.Array.isArray(object?.reservations)
        ? object.reservations.map((e: any) => Reservation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListReservationsResponse): unknown {
    const obj: any = {};
    if (message.reservations?.length) {
      obj.reservations = message.reservations.map((e) => Reservation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListReservationsResponse>): ListReservationsResponse {
    return ListReservationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListReservationsResponse>): ListReservationsResponse {
    const message = createBaseListReservationsResponse();
    message.reservations = object.reservations?.map((e) => Reservation.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetReservationRequest(): GetReservationRequest {
  return { name: "" };
}

export const GetReservationRequest: MessageFns<GetReservationRequest> = {
  encode(message: GetReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetReservationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetReservationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetReservationRequest>): GetReservationRequest {
    return GetReservationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetReservationRequest>): GetReservationRequest {
    const message = createBaseGetReservationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteReservationRequest(): DeleteReservationRequest {
  return { name: "" };
}

export const DeleteReservationRequest: MessageFns<DeleteReservationRequest> = {
  encode(message: DeleteReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteReservationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteReservationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteReservationRequest>): DeleteReservationRequest {
    return DeleteReservationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteReservationRequest>): DeleteReservationRequest {
    const message = createBaseDeleteReservationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateReservationRequest(): UpdateReservationRequest {
  return { reservation: undefined, updateMask: undefined };
}

export const UpdateReservationRequest: MessageFns<UpdateReservationRequest> = {
  encode(message: UpdateReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reservation !== undefined) {
      Reservation.encode(message.reservation, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reservation = Reservation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateReservationRequest {
    return {
      reservation: isSet(object.reservation) ? Reservation.fromJSON(object.reservation) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateReservationRequest): unknown {
    const obj: any = {};
    if (message.reservation !== undefined) {
      obj.reservation = Reservation.toJSON(message.reservation);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateReservationRequest>): UpdateReservationRequest {
    return UpdateReservationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateReservationRequest>): UpdateReservationRequest {
    const message = createBaseUpdateReservationRequest();
    message.reservation = (object.reservation !== undefined && object.reservation !== null)
      ? Reservation.fromPartial(object.reservation)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseCreateCapacityCommitmentRequest(): CreateCapacityCommitmentRequest {
  return {
    parent: "",
    capacityCommitment: undefined,
    enforceSingleAdminProjectPerOrg: false,
    capacityCommitmentId: "",
  };
}

export const CreateCapacityCommitmentRequest: MessageFns<CreateCapacityCommitmentRequest> = {
  encode(message: CreateCapacityCommitmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.capacityCommitment !== undefined) {
      CapacityCommitment.encode(message.capacityCommitment, writer.uint32(18).fork()).join();
    }
    if (message.enforceSingleAdminProjectPerOrg !== false) {
      writer.uint32(32).bool(message.enforceSingleAdminProjectPerOrg);
    }
    if (message.capacityCommitmentId !== "") {
      writer.uint32(42).string(message.capacityCommitmentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCapacityCommitmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCapacityCommitmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.capacityCommitment = CapacityCommitment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enforceSingleAdminProjectPerOrg = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.capacityCommitmentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCapacityCommitmentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      capacityCommitment: isSet(object.capacityCommitment)
        ? CapacityCommitment.fromJSON(object.capacityCommitment)
        : undefined,
      enforceSingleAdminProjectPerOrg: isSet(object.enforceSingleAdminProjectPerOrg)
        ? globalThis.Boolean(object.enforceSingleAdminProjectPerOrg)
        : false,
      capacityCommitmentId: isSet(object.capacityCommitmentId) ? globalThis.String(object.capacityCommitmentId) : "",
    };
  },

  toJSON(message: CreateCapacityCommitmentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.capacityCommitment !== undefined) {
      obj.capacityCommitment = CapacityCommitment.toJSON(message.capacityCommitment);
    }
    if (message.enforceSingleAdminProjectPerOrg !== false) {
      obj.enforceSingleAdminProjectPerOrg = message.enforceSingleAdminProjectPerOrg;
    }
    if (message.capacityCommitmentId !== "") {
      obj.capacityCommitmentId = message.capacityCommitmentId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateCapacityCommitmentRequest>): CreateCapacityCommitmentRequest {
    return CreateCapacityCommitmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateCapacityCommitmentRequest>): CreateCapacityCommitmentRequest {
    const message = createBaseCreateCapacityCommitmentRequest();
    message.parent = object.parent ?? "";
    message.capacityCommitment = (object.capacityCommitment !== undefined && object.capacityCommitment !== null)
      ? CapacityCommitment.fromPartial(object.capacityCommitment)
      : undefined;
    message.enforceSingleAdminProjectPerOrg = object.enforceSingleAdminProjectPerOrg ?? false;
    message.capacityCommitmentId = object.capacityCommitmentId ?? "";
    return message;
  },
};

function createBaseListCapacityCommitmentsRequest(): ListCapacityCommitmentsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListCapacityCommitmentsRequest: MessageFns<ListCapacityCommitmentsRequest> = {
  encode(message: ListCapacityCommitmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCapacityCommitmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCapacityCommitmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCapacityCommitmentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListCapacityCommitmentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCapacityCommitmentsRequest>): ListCapacityCommitmentsRequest {
    return ListCapacityCommitmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCapacityCommitmentsRequest>): ListCapacityCommitmentsRequest {
    const message = createBaseListCapacityCommitmentsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListCapacityCommitmentsResponse(): ListCapacityCommitmentsResponse {
  return { capacityCommitments: [], nextPageToken: "" };
}

export const ListCapacityCommitmentsResponse: MessageFns<ListCapacityCommitmentsResponse> = {
  encode(message: ListCapacityCommitmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.capacityCommitments) {
      CapacityCommitment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCapacityCommitmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCapacityCommitmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.capacityCommitments.push(CapacityCommitment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCapacityCommitmentsResponse {
    return {
      capacityCommitments: globalThis.Array.isArray(object?.capacityCommitments)
        ? object.capacityCommitments.map((e: any) => CapacityCommitment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListCapacityCommitmentsResponse): unknown {
    const obj: any = {};
    if (message.capacityCommitments?.length) {
      obj.capacityCommitments = message.capacityCommitments.map((e) => CapacityCommitment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListCapacityCommitmentsResponse>): ListCapacityCommitmentsResponse {
    return ListCapacityCommitmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListCapacityCommitmentsResponse>): ListCapacityCommitmentsResponse {
    const message = createBaseListCapacityCommitmentsResponse();
    message.capacityCommitments = object.capacityCommitments?.map((e) => CapacityCommitment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetCapacityCommitmentRequest(): GetCapacityCommitmentRequest {
  return { name: "" };
}

export const GetCapacityCommitmentRequest: MessageFns<GetCapacityCommitmentRequest> = {
  encode(message: GetCapacityCommitmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCapacityCommitmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCapacityCommitmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCapacityCommitmentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetCapacityCommitmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetCapacityCommitmentRequest>): GetCapacityCommitmentRequest {
    return GetCapacityCommitmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCapacityCommitmentRequest>): GetCapacityCommitmentRequest {
    const message = createBaseGetCapacityCommitmentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteCapacityCommitmentRequest(): DeleteCapacityCommitmentRequest {
  return { name: "", force: false };
}

export const DeleteCapacityCommitmentRequest: MessageFns<DeleteCapacityCommitmentRequest> = {
  encode(message: DeleteCapacityCommitmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCapacityCommitmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCapacityCommitmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCapacityCommitmentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteCapacityCommitmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteCapacityCommitmentRequest>): DeleteCapacityCommitmentRequest {
    return DeleteCapacityCommitmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteCapacityCommitmentRequest>): DeleteCapacityCommitmentRequest {
    const message = createBaseDeleteCapacityCommitmentRequest();
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseUpdateCapacityCommitmentRequest(): UpdateCapacityCommitmentRequest {
  return { capacityCommitment: undefined, updateMask: undefined };
}

export const UpdateCapacityCommitmentRequest: MessageFns<UpdateCapacityCommitmentRequest> = {
  encode(message: UpdateCapacityCommitmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.capacityCommitment !== undefined) {
      CapacityCommitment.encode(message.capacityCommitment, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCapacityCommitmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCapacityCommitmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.capacityCommitment = CapacityCommitment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCapacityCommitmentRequest {
    return {
      capacityCommitment: isSet(object.capacityCommitment)
        ? CapacityCommitment.fromJSON(object.capacityCommitment)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateCapacityCommitmentRequest): unknown {
    const obj: any = {};
    if (message.capacityCommitment !== undefined) {
      obj.capacityCommitment = CapacityCommitment.toJSON(message.capacityCommitment);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateCapacityCommitmentRequest>): UpdateCapacityCommitmentRequest {
    return UpdateCapacityCommitmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateCapacityCommitmentRequest>): UpdateCapacityCommitmentRequest {
    const message = createBaseUpdateCapacityCommitmentRequest();
    message.capacityCommitment = (object.capacityCommitment !== undefined && object.capacityCommitment !== null)
      ? CapacityCommitment.fromPartial(object.capacityCommitment)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseSplitCapacityCommitmentRequest(): SplitCapacityCommitmentRequest {
  return { name: "", slotCount: Long.ZERO };
}

export const SplitCapacityCommitmentRequest: MessageFns<SplitCapacityCommitmentRequest> = {
  encode(message: SplitCapacityCommitmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.slotCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.slotCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplitCapacityCommitmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplitCapacityCommitmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.slotCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplitCapacityCommitmentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      slotCount: isSet(object.slotCount) ? Long.fromValue(object.slotCount) : Long.ZERO,
    };
  },

  toJSON(message: SplitCapacityCommitmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.slotCount.equals(Long.ZERO)) {
      obj.slotCount = (message.slotCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SplitCapacityCommitmentRequest>): SplitCapacityCommitmentRequest {
    return SplitCapacityCommitmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SplitCapacityCommitmentRequest>): SplitCapacityCommitmentRequest {
    const message = createBaseSplitCapacityCommitmentRequest();
    message.name = object.name ?? "";
    message.slotCount = (object.slotCount !== undefined && object.slotCount !== null)
      ? Long.fromValue(object.slotCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseSplitCapacityCommitmentResponse(): SplitCapacityCommitmentResponse {
  return { first: undefined, second: undefined };
}

export const SplitCapacityCommitmentResponse: MessageFns<SplitCapacityCommitmentResponse> = {
  encode(message: SplitCapacityCommitmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.first !== undefined) {
      CapacityCommitment.encode(message.first, writer.uint32(10).fork()).join();
    }
    if (message.second !== undefined) {
      CapacityCommitment.encode(message.second, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SplitCapacityCommitmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSplitCapacityCommitmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.first = CapacityCommitment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.second = CapacityCommitment.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SplitCapacityCommitmentResponse {
    return {
      first: isSet(object.first) ? CapacityCommitment.fromJSON(object.first) : undefined,
      second: isSet(object.second) ? CapacityCommitment.fromJSON(object.second) : undefined,
    };
  },

  toJSON(message: SplitCapacityCommitmentResponse): unknown {
    const obj: any = {};
    if (message.first !== undefined) {
      obj.first = CapacityCommitment.toJSON(message.first);
    }
    if (message.second !== undefined) {
      obj.second = CapacityCommitment.toJSON(message.second);
    }
    return obj;
  },

  create(base?: DeepPartial<SplitCapacityCommitmentResponse>): SplitCapacityCommitmentResponse {
    return SplitCapacityCommitmentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SplitCapacityCommitmentResponse>): SplitCapacityCommitmentResponse {
    const message = createBaseSplitCapacityCommitmentResponse();
    message.first = (object.first !== undefined && object.first !== null)
      ? CapacityCommitment.fromPartial(object.first)
      : undefined;
    message.second = (object.second !== undefined && object.second !== null)
      ? CapacityCommitment.fromPartial(object.second)
      : undefined;
    return message;
  },
};

function createBaseMergeCapacityCommitmentsRequest(): MergeCapacityCommitmentsRequest {
  return { parent: "", capacityCommitmentIds: [] };
}

export const MergeCapacityCommitmentsRequest: MessageFns<MergeCapacityCommitmentsRequest> = {
  encode(message: MergeCapacityCommitmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    for (const v of message.capacityCommitmentIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MergeCapacityCommitmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMergeCapacityCommitmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.capacityCommitmentIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MergeCapacityCommitmentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      capacityCommitmentIds: globalThis.Array.isArray(object?.capacityCommitmentIds)
        ? object.capacityCommitmentIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MergeCapacityCommitmentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.capacityCommitmentIds?.length) {
      obj.capacityCommitmentIds = message.capacityCommitmentIds;
    }
    return obj;
  },

  create(base?: DeepPartial<MergeCapacityCommitmentsRequest>): MergeCapacityCommitmentsRequest {
    return MergeCapacityCommitmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MergeCapacityCommitmentsRequest>): MergeCapacityCommitmentsRequest {
    const message = createBaseMergeCapacityCommitmentsRequest();
    message.parent = object.parent ?? "";
    message.capacityCommitmentIds = object.capacityCommitmentIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseAssignment(): Assignment {
  return { name: "", assignee: "", jobType: 0, state: 0 };
}

export const Assignment: MessageFns<Assignment> = {
  encode(message: Assignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.assignee !== "") {
      writer.uint32(34).string(message.assignee);
    }
    if (message.jobType !== 0) {
      writer.uint32(24).int32(message.jobType);
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Assignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.assignee = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.jobType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Assignment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      assignee: isSet(object.assignee) ? globalThis.String(object.assignee) : "",
      jobType: isSet(object.jobType) ? assignment_JobTypeFromJSON(object.jobType) : 0,
      state: isSet(object.state) ? assignment_StateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Assignment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.assignee !== "") {
      obj.assignee = message.assignee;
    }
    if (message.jobType !== 0) {
      obj.jobType = assignment_JobTypeToJSON(message.jobType);
    }
    if (message.state !== 0) {
      obj.state = assignment_StateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<Assignment>): Assignment {
    return Assignment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Assignment>): Assignment {
    const message = createBaseAssignment();
    message.name = object.name ?? "";
    message.assignee = object.assignee ?? "";
    message.jobType = object.jobType ?? 0;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseCreateAssignmentRequest(): CreateAssignmentRequest {
  return { parent: "", assignment: undefined, assignmentId: "" };
}

export const CreateAssignmentRequest: MessageFns<CreateAssignmentRequest> = {
  encode(message: CreateAssignmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.assignment !== undefined) {
      Assignment.encode(message.assignment, writer.uint32(18).fork()).join();
    }
    if (message.assignmentId !== "") {
      writer.uint32(34).string(message.assignmentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAssignmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAssignmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.assignment = Assignment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.assignmentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAssignmentRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      assignment: isSet(object.assignment) ? Assignment.fromJSON(object.assignment) : undefined,
      assignmentId: isSet(object.assignmentId) ? globalThis.String(object.assignmentId) : "",
    };
  },

  toJSON(message: CreateAssignmentRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.assignment !== undefined) {
      obj.assignment = Assignment.toJSON(message.assignment);
    }
    if (message.assignmentId !== "") {
      obj.assignmentId = message.assignmentId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAssignmentRequest>): CreateAssignmentRequest {
    return CreateAssignmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAssignmentRequest>): CreateAssignmentRequest {
    const message = createBaseCreateAssignmentRequest();
    message.parent = object.parent ?? "";
    message.assignment = (object.assignment !== undefined && object.assignment !== null)
      ? Assignment.fromPartial(object.assignment)
      : undefined;
    message.assignmentId = object.assignmentId ?? "";
    return message;
  },
};

function createBaseListAssignmentsRequest(): ListAssignmentsRequest {
  return { parent: "", pageSize: 0, pageToken: "" };
}

export const ListAssignmentsRequest: MessageFns<ListAssignmentsRequest> = {
  encode(message: ListAssignmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssignmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssignmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssignmentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListAssignmentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssignmentsRequest>): ListAssignmentsRequest {
    return ListAssignmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssignmentsRequest>): ListAssignmentsRequest {
    const message = createBaseListAssignmentsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListAssignmentsResponse(): ListAssignmentsResponse {
  return { assignments: [], nextPageToken: "" };
}

export const ListAssignmentsResponse: MessageFns<ListAssignmentsResponse> = {
  encode(message: ListAssignmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assignments) {
      Assignment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAssignmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAssignmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assignments.push(Assignment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAssignmentsResponse {
    return {
      assignments: globalThis.Array.isArray(object?.assignments)
        ? object.assignments.map((e: any) => Assignment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListAssignmentsResponse): unknown {
    const obj: any = {};
    if (message.assignments?.length) {
      obj.assignments = message.assignments.map((e) => Assignment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAssignmentsResponse>): ListAssignmentsResponse {
    return ListAssignmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAssignmentsResponse>): ListAssignmentsResponse {
    const message = createBaseListAssignmentsResponse();
    message.assignments = object.assignments?.map((e) => Assignment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseDeleteAssignmentRequest(): DeleteAssignmentRequest {
  return { name: "" };
}

export const DeleteAssignmentRequest: MessageFns<DeleteAssignmentRequest> = {
  encode(message: DeleteAssignmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAssignmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAssignmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAssignmentRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteAssignmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAssignmentRequest>): DeleteAssignmentRequest {
    return DeleteAssignmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAssignmentRequest>): DeleteAssignmentRequest {
    const message = createBaseDeleteAssignmentRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseSearchAssignmentsRequest(): SearchAssignmentsRequest {
  return { parent: "", query: "", pageSize: 0, pageToken: "" };
}

export const SearchAssignmentsRequest: MessageFns<SearchAssignmentsRequest> = {
  encode(message: SearchAssignmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAssignmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAssignmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAssignmentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: SearchAssignmentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAssignmentsRequest>): SearchAssignmentsRequest {
    return SearchAssignmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAssignmentsRequest>): SearchAssignmentsRequest {
    const message = createBaseSearchAssignmentsRequest();
    message.parent = object.parent ?? "";
    message.query = object.query ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseSearchAllAssignmentsRequest(): SearchAllAssignmentsRequest {
  return { parent: "", query: "", pageSize: 0, pageToken: "" };
}

export const SearchAllAssignmentsRequest: MessageFns<SearchAllAssignmentsRequest> = {
  encode(message: SearchAllAssignmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAllAssignmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAllAssignmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAllAssignmentsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: SearchAllAssignmentsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAllAssignmentsRequest>): SearchAllAssignmentsRequest {
    return SearchAllAssignmentsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAllAssignmentsRequest>): SearchAllAssignmentsRequest {
    const message = createBaseSearchAllAssignmentsRequest();
    message.parent = object.parent ?? "";
    message.query = object.query ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseSearchAssignmentsResponse(): SearchAssignmentsResponse {
  return { assignments: [], nextPageToken: "" };
}

export const SearchAssignmentsResponse: MessageFns<SearchAssignmentsResponse> = {
  encode(message: SearchAssignmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assignments) {
      Assignment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAssignmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAssignmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assignments.push(Assignment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAssignmentsResponse {
    return {
      assignments: globalThis.Array.isArray(object?.assignments)
        ? object.assignments.map((e: any) => Assignment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchAssignmentsResponse): unknown {
    const obj: any = {};
    if (message.assignments?.length) {
      obj.assignments = message.assignments.map((e) => Assignment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAssignmentsResponse>): SearchAssignmentsResponse {
    return SearchAssignmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAssignmentsResponse>): SearchAssignmentsResponse {
    const message = createBaseSearchAssignmentsResponse();
    message.assignments = object.assignments?.map((e) => Assignment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseSearchAllAssignmentsResponse(): SearchAllAssignmentsResponse {
  return { assignments: [], nextPageToken: "" };
}

export const SearchAllAssignmentsResponse: MessageFns<SearchAllAssignmentsResponse> = {
  encode(message: SearchAllAssignmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assignments) {
      Assignment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchAllAssignmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchAllAssignmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assignments.push(Assignment.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchAllAssignmentsResponse {
    return {
      assignments: globalThis.Array.isArray(object?.assignments)
        ? object.assignments.map((e: any) => Assignment.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: SearchAllAssignmentsResponse): unknown {
    const obj: any = {};
    if (message.assignments?.length) {
      obj.assignments = message.assignments.map((e) => Assignment.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchAllAssignmentsResponse>): SearchAllAssignmentsResponse {
    return SearchAllAssignmentsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchAllAssignmentsResponse>): SearchAllAssignmentsResponse {
    const message = createBaseSearchAllAssignmentsResponse();
    message.assignments = object.assignments?.map((e) => Assignment.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseMoveAssignmentRequest(): MoveAssignmentRequest {
  return { name: "", destinationId: "", assignmentId: "" };
}

export const MoveAssignmentRequest: MessageFns<MoveAssignmentRequest> = {
  encode(message: MoveAssignmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.destinationId !== "") {
      writer.uint32(26).string(message.destinationId);
    }
    if (message.assignmentId !== "") {
      writer.uint32(42).string(message.assignmentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveAssignmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveAssignmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destinationId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.assignmentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveAssignmentRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      destinationId: isSet(object.destinationId) ? globalThis.String(object.destinationId) : "",
      assignmentId: isSet(object.assignmentId) ? globalThis.String(object.assignmentId) : "",
    };
  },

  toJSON(message: MoveAssignmentRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.destinationId !== "") {
      obj.destinationId = message.destinationId;
    }
    if (message.assignmentId !== "") {
      obj.assignmentId = message.assignmentId;
    }
    return obj;
  },

  create(base?: DeepPartial<MoveAssignmentRequest>): MoveAssignmentRequest {
    return MoveAssignmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MoveAssignmentRequest>): MoveAssignmentRequest {
    const message = createBaseMoveAssignmentRequest();
    message.name = object.name ?? "";
    message.destinationId = object.destinationId ?? "";
    message.assignmentId = object.assignmentId ?? "";
    return message;
  },
};

function createBaseUpdateAssignmentRequest(): UpdateAssignmentRequest {
  return { assignment: undefined, updateMask: undefined };
}

export const UpdateAssignmentRequest: MessageFns<UpdateAssignmentRequest> = {
  encode(message: UpdateAssignmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assignment !== undefined) {
      Assignment.encode(message.assignment, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAssignmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAssignmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assignment = Assignment.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAssignmentRequest {
    return {
      assignment: isSet(object.assignment) ? Assignment.fromJSON(object.assignment) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateAssignmentRequest): unknown {
    const obj: any = {};
    if (message.assignment !== undefined) {
      obj.assignment = Assignment.toJSON(message.assignment);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAssignmentRequest>): UpdateAssignmentRequest {
    return UpdateAssignmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAssignmentRequest>): UpdateAssignmentRequest {
    const message = createBaseUpdateAssignmentRequest();
    message.assignment = (object.assignment !== undefined && object.assignment !== null)
      ? Assignment.fromPartial(object.assignment)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseTableReference(): TableReference {
  return { projectId: "", datasetId: "", tableId: "" };
}

export const TableReference: MessageFns<TableReference> = {
  encode(message: TableReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.tableId !== "") {
      writer.uint32(26).string(message.tableId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tableId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableReference {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      tableId: isSet(object.tableId) ? globalThis.String(object.tableId) : "",
    };
  },

  toJSON(message: TableReference): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.tableId !== "") {
      obj.tableId = message.tableId;
    }
    return obj;
  },

  create(base?: DeepPartial<TableReference>): TableReference {
    return TableReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableReference>): TableReference {
    const message = createBaseTableReference();
    message.projectId = object.projectId ?? "";
    message.datasetId = object.datasetId ?? "";
    message.tableId = object.tableId ?? "";
    return message;
  },
};

function createBaseBiReservation(): BiReservation {
  return { name: "", updateTime: undefined, size: Long.ZERO, preferredTables: [] };
}

export const BiReservation: MessageFns<BiReservation> = {
  encode(message: BiReservation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    if (!message.size.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.size.toString());
    }
    for (const v of message.preferredTables) {
      TableReference.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BiReservation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBiReservation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.size = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.preferredTables.push(TableReference.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BiReservation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      size: isSet(object.size) ? Long.fromValue(object.size) : Long.ZERO,
      preferredTables: globalThis.Array.isArray(object?.preferredTables)
        ? object.preferredTables.map((e: any) => TableReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BiReservation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (!message.size.equals(Long.ZERO)) {
      obj.size = (message.size || Long.ZERO).toString();
    }
    if (message.preferredTables?.length) {
      obj.preferredTables = message.preferredTables.map((e) => TableReference.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BiReservation>): BiReservation {
    return BiReservation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BiReservation>): BiReservation {
    const message = createBaseBiReservation();
    message.name = object.name ?? "";
    message.updateTime = object.updateTime ?? undefined;
    message.size = (object.size !== undefined && object.size !== null) ? Long.fromValue(object.size) : Long.ZERO;
    message.preferredTables = object.preferredTables?.map((e) => TableReference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetBiReservationRequest(): GetBiReservationRequest {
  return { name: "" };
}

export const GetBiReservationRequest: MessageFns<GetBiReservationRequest> = {
  encode(message: GetBiReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBiReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBiReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBiReservationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetBiReservationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBiReservationRequest>): GetBiReservationRequest {
    return GetBiReservationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBiReservationRequest>): GetBiReservationRequest {
    const message = createBaseGetBiReservationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateBiReservationRequest(): UpdateBiReservationRequest {
  return { biReservation: undefined, updateMask: undefined };
}

export const UpdateBiReservationRequest: MessageFns<UpdateBiReservationRequest> = {
  encode(message: UpdateBiReservationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.biReservation !== undefined) {
      BiReservation.encode(message.biReservation, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBiReservationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBiReservationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.biReservation = BiReservation.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBiReservationRequest {
    return {
      biReservation: isSet(object.biReservation) ? BiReservation.fromJSON(object.biReservation) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateBiReservationRequest): unknown {
    const obj: any = {};
    if (message.biReservation !== undefined) {
      obj.biReservation = BiReservation.toJSON(message.biReservation);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateBiReservationRequest>): UpdateBiReservationRequest {
    return UpdateBiReservationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateBiReservationRequest>): UpdateBiReservationRequest {
    const message = createBaseUpdateBiReservationRequest();
    message.biReservation = (object.biReservation !== undefined && object.biReservation !== null)
      ? BiReservation.fromPartial(object.biReservation)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

/**
 * This API allows users to manage their BigQuery reservations.
 *
 * A reservation provides computational resource guarantees, in the form of
 * [slots](https://cloud.google.com/bigquery/docs/slots), to users. A slot is a
 * unit of computational power in BigQuery, and serves as the basic unit of
 * parallelism. In a scan of a multi-partitioned table, a single slot operates
 * on a single partition of the table. A reservation resource exists as a child
 * resource of the admin project and location, e.g.:
 *   `projects/myproject/locations/US/reservations/reservationName`.
 *
 * A capacity commitment is a way to purchase compute capacity for BigQuery jobs
 * (in the form of slots) with some committed period of usage. A capacity
 * commitment resource exists as a child resource of the admin project and
 * location, e.g.:
 *   `projects/myproject/locations/US/capacityCommitments/id`.
 */
export type ReservationServiceDefinition = typeof ReservationServiceDefinition;
export const ReservationServiceDefinition = {
  name: "ReservationService",
  fullName: "google.cloud.bigquery.reservation.v1.ReservationService",
  methods: {
    /** Creates a new reservation resource. */
    createReservation: {
      name: "CreateReservation",
      requestType: CreateReservationRequest,
      requestStream: false,
      responseType: Reservation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              33,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              44,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              63,
              58,
              11,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              34,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all the reservations for the project in the specified location. */
    listReservations: {
      name: "ListReservations",
      requestType: ListReservationsRequest,
      requestStream: false,
      responseType: ListReservationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns information about the reservation. */
    getReservation: {
      name: "GetReservation",
      requestType: GetReservationRequest,
      requestStream: false,
      responseType: Reservation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              18,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a reservation.
     * Returns `google.rpc.Code.FAILED_PRECONDITION` when reservation has
     * assignments.
     */
    deleteReservation: {
      name: "DeleteReservation",
      requestType: DeleteReservationRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              50,
              42,
              48,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates an existing reservation resource. */
    updateReservation: {
      name: "UpdateReservation",
      requestType: UpdateReservationRequest,
      requestStream: false,
      responseType: Reservation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              23,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              75,
              58,
              11,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              50,
              60,
              47,
              118,
              49,
              47,
              123,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new capacity commitment resource. */
    createCapacityCommitment: {
      name: "CreateCapacityCommitment",
      requestType: CreateCapacityCommitmentRequest,
      requestStream: false,
      responseType: CapacityCommitment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              95,
              99,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
            ]),
          ],
          578365826: [
            Buffer.from([
              78,
              58,
              19,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              95,
              99,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              34,
              55,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              67,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Lists all the capacity commitments for the admin project. */
    listCapacityCommitments: {
      name: "ListCapacityCommitments",
      requestType: ListCapacityCommitmentsRequest,
      requestStream: false,
      responseType: ListCapacityCommitmentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              57,
              18,
              55,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              67,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /** Returns information about the capacity commitment. */
    getCapacityCommitment: {
      name: "GetCapacityCommitment",
      requestType: GetCapacityCommitmentRequest,
      requestStream: false,
      responseType: CapacityCommitment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              57,
              18,
              55,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              67,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a capacity commitment. Attempting to delete capacity commitment
     * before its commitment_end_time will fail with the error code
     * `google.rpc.Code.FAILED_PRECONDITION`.
     */
    deleteCapacityCommitment: {
      name: "DeleteCapacityCommitment",
      requestType: DeleteCapacityCommitmentRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              57,
              42,
              55,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              67,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an existing capacity commitment.
     *
     * Only `plan` and `renewal_plan` fields can be updated.
     *
     * Plan can only be changed to a plan of a longer commitment period.
     * Attempting to change to a plan with shorter commitment period will fail
     * with the error code `google.rpc.Code.FAILED_PRECONDITION`.
     */
    updateCapacityCommitment: {
      name: "UpdateCapacityCommitment",
      requestType: UpdateCapacityCommitmentRequest,
      requestStream: false,
      responseType: CapacityCommitment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              31,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              95,
              99,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              98,
              58,
              19,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              95,
              99,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              50,
              75,
              47,
              118,
              49,
              47,
              123,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              95,
              99,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              67,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Splits capacity commitment to two commitments of the same plan and
     * `commitment_end_time`.
     *
     * A common use case is to enable downgrading commitments.
     *
     * For example, in order to downgrade from 10000 slots to 8000, you might
     * split a 10000 capacity commitment into commitments of 2000 and 8000. Then,
     * you delete the first one after the commitment end time passes.
     */
    splitCapacityCommitment: {
      name: "SplitCapacityCommitment",
      requestType: SplitCapacityCommitmentRequest,
      requestStream: false,
      responseType: SplitCapacityCommitmentResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([15, 110, 97, 109, 101, 44, 115, 108, 111, 116, 95, 99, 111, 117, 110, 116])],
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              67,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              112,
              108,
              105,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Merges capacity commitments of the same plan into a single commitment.
     *
     * The resulting capacity commitment has the greater commitment_end_time
     * out of the to-be-merged capacity commitments.
     *
     * Attempting to merge capacity commitments of different plan will fail
     * with the error code `google.rpc.Code.FAILED_PRECONDITION`.
     */
    mergeCapacityCommitments: {
      name: "MergeCapacityCommitments",
      requestType: MergeCapacityCommitmentsRequest,
      requestStream: false,
      responseType: CapacityCommitment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              30,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              95,
              99,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              95,
              105,
              100,
              115,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              1,
              42,
              34,
              61,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              99,
              97,
              112,
              97,
              99,
              105,
              116,
              121,
              67,
              111,
              109,
              109,
              105,
              116,
              109,
              101,
              110,
              116,
              115,
              58,
              109,
              101,
              114,
              103,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Creates an assignment object which allows the given project to submit jobs
     * of a certain type using slots from the specified reservation.
     *
     * Currently a
     * resource (project, folder, organization) can only have one assignment per
     * each (job_type, location) combination, and that reservation will be used
     * for all jobs of the matching type.
     *
     * Different assignments can be created on different levels of the
     * projects, folders or organization hierarchy.  During query execution,
     * the assignment is looked up at the project, folder and organization levels
     * in that order. The first assignment found is applied to the query.
     *
     * When creating assignments, it does not matter if other assignments exist at
     * higher levels.
     *
     * Example:
     *
     * * The organization `organizationA` contains two projects, `project1`
     *   and `project2`.
     * * Assignments for all three entities (`organizationA`, `project1`, and
     *   `project2`) could all be created and mapped to the same or different
     *   reservations.
     *
     * "None" assignments represent an absence of the assignment. Projects
     * assigned to None use on-demand pricing. To create a "None" assignment, use
     * "none" as a reservation_id in the parent. Example parent:
     * `projects/myproject/locations/US/reservations/none`.
     *
     * Returns `google.rpc.Code.PERMISSION_DENIED` if user does not have
     * 'bigquery.admin' permissions on the project using the reservation
     * and the project that owns this reservation.
     *
     * Returns `google.rpc.Code.INVALID_ARGUMENT` when location of the assignment
     * does not match location of the reservation.
     */
    createAssignment: {
      name: "CreateAssignment",
      requestType: CreateAssignmentRequest,
      requestStream: false,
      responseType: Assignment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 112, 97, 114, 101, 110, 116, 44, 97, 115, 115, 105, 103, 110, 109, 101, 110, 116])],
          578365826: [
            Buffer.from([
              76,
              58,
              10,
              97,
              115,
              115,
              105,
              103,
              110,
              109,
              101,
              110,
              116,
              34,
              62,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              105,
              103,
              110,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Lists assignments.
     *
     * Only explicitly created assignments will be returned.
     *
     * Example:
     *
     * * Organization `organizationA` contains two projects, `project1` and
     *   `project2`.
     * * Reservation `res1` exists and was created previously.
     * * CreateAssignment was used previously to define the following
     *   associations between entities and reservations: `<organizationA, res1>`
     *   and `<project1, res1>`
     *
     * In this example, ListAssignments will just return the above two assignments
     * for reservation `res1`, and no expansion/merge will happen.
     *
     * The wildcard "-" can be used for
     * reservations in the request. In that case all assignments belongs to the
     * specified project and location will be listed.
     *
     * **Note** "-" cannot be used for projects nor locations.
     */
    listAssignments: {
      name: "ListAssignments",
      requestType: ListAssignmentsRequest,
      requestStream: false,
      responseType: ListAssignmentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              64,
              18,
              62,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              115,
              105,
              103,
              110,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a assignment. No expansion will happen.
     *
     * Example:
     *
     * * Organization `organizationA` contains two projects, `project1` and
     *   `project2`.
     * * Reservation `res1` exists and was created previously.
     * * CreateAssignment was used previously to define the following
     *   associations between entities and reservations: `<organizationA, res1>`
     *   and `<project1, res1>`
     *
     * In this example, deletion of the `<organizationA, res1>` assignment won't
     * affect the other assignment `<project1, res1>`. After said deletion,
     * queries from `project1` will still use `res1` while queries from
     * `project2` will switch to use on-demand mode.
     */
    deleteAssignment: {
      name: "DeleteAssignment",
      requestType: DeleteAssignmentRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              64,
              42,
              62,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              115,
              105,
              103,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deprecated: Looks up assignments for a specified resource for a particular
     * region. If the request is about a project:
     *
     * 1. Assignments created on the project will be returned if they exist.
     * 2. Otherwise assignments created on the closest ancestor will be
     *    returned.
     * 3. Assignments for different JobTypes will all be returned.
     *
     * The same logic applies if the request is about a folder.
     *
     * If the request is about an organization, then assignments created on the
     * organization will be returned (organization doesn't have ancestors).
     *
     * Comparing to ListAssignments, there are some behavior
     * differences:
     *
     * 1. permission on the assignee will be verified in this API.
     * 2. Hierarchy lookup (project->folder->organization) happens in this API.
     * 3. Parent here is `projects/* /locations/*`, instead of
     *    `projects/* /locations/*reservations/*`.
     *
     * **Note** "-" cannot be used for projects
     * nor locations.
     *
     * @deprecated
     */
    searchAssignments: {
      name: "SearchAssignments",
      requestType: SearchAssignmentsRequest,
      requestStream: false,
      responseType: SearchAssignmentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 112, 97, 114, 101, 110, 116, 44, 113, 117, 101, 114, 121])],
          578365826: [
            Buffer.from([
              55,
              18,
              53,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              65,
              115,
              115,
              105,
              103,
              110,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Looks up assignments for a specified resource for a particular region.
     * If the request is about a project:
     *
     * 1. Assignments created on the project will be returned if they exist.
     * 2. Otherwise assignments created on the closest ancestor will be
     *    returned.
     * 3. Assignments for different JobTypes will all be returned.
     *
     * The same logic applies if the request is about a folder.
     *
     * If the request is about an organization, then assignments created on the
     * organization will be returned (organization doesn't have ancestors).
     *
     * Comparing to ListAssignments, there are some behavior
     * differences:
     *
     * 1. permission on the assignee will be verified in this API.
     * 2. Hierarchy lookup (project->folder->organization) happens in this API.
     * 3. Parent here is `projects/* /locations/*`, instead of
     *    `projects/* /locations/*reservations/*`.
     */
    searchAllAssignments: {
      name: "SearchAllAssignments",
      requestType: SearchAllAssignmentsRequest,
      requestStream: false,
      responseType: SearchAllAssignmentsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 112, 97, 114, 101, 110, 116, 44, 113, 117, 101, 114, 121])],
          578365826: [
            Buffer.from([
              58,
              18,
              56,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              65,
              108,
              108,
              65,
              115,
              115,
              105,
              103,
              110,
              109,
              101,
              110,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Moves an assignment under a new reservation.
     *
     * This differs from removing an existing assignment and recreating a new one
     * by providing a transactional change that ensures an assignee always has an
     * associated reservation.
     */
    moveAssignment: {
      name: "MoveAssignment",
      requestType: MoveAssignmentRequest,
      requestStream: false,
      responseType: Assignment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              19,
              110,
              97,
              109,
              101,
              44,
              100,
              101,
              115,
              116,
              105,
              110,
              97,
              116,
              105,
              111,
              110,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              72,
              58,
              1,
              42,
              34,
              67,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              115,
              105,
              103,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              109,
              111,
              118,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Updates an existing assignment.
     *
     * Only the `priority` field can be updated.
     */
    updateAssignment: {
      name: "UpdateAssignment",
      requestType: UpdateAssignmentRequest,
      requestStream: false,
      responseType: Assignment,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              22,
              97,
              115,
              115,
              105,
              103,
              110,
              109,
              101,
              110,
              116,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              87,
              58,
              10,
              97,
              115,
              115,
              105,
              103,
              110,
              109,
              101,
              110,
              116,
              50,
              73,
              47,
              118,
              49,
              47,
              123,
              97,
              115,
              115,
              105,
              103,
              110,
              109,
              101,
              110,
              116,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              115,
              105,
              103,
              110,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Retrieves a BI reservation. */
    getBiReservation: {
      name: "GetBiReservation",
      requestType: GetBiReservationRequest,
      requestStream: false,
      responseType: BiReservation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              98,
              105,
              82,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a BI reservation.
     *
     * Only fields specified in the `field_mask` are updated.
     *
     * A singleton BI reservation always exists with default size 0.
     * In order to reserve BI capacity it needs to be updated to an amount
     * greater than 0. In order to release BI capacity reservation size
     * must be set to 0.
     */
    updateBiReservation: {
      name: "UpdateBiReservation",
      requestType: UpdateBiReservationRequest,
      requestStream: false,
      responseType: BiReservation,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              26,
              98,
              105,
              95,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              80,
              58,
              14,
              98,
              105,
              95,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              50,
              62,
              47,
              118,
              49,
              47,
              123,
              98,
              105,
              95,
              114,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              98,
              105,
              82,
              101,
              115,
              101,
              114,
              118,
              97,
              116,
              105,
              111,
              110,
              125,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface ReservationServiceImplementation<CallContextExt = {}> {
  /** Creates a new reservation resource. */
  createReservation(
    request: CreateReservationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Reservation>>;
  /** Lists all the reservations for the project in the specified location. */
  listReservations(
    request: ListReservationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListReservationsResponse>>;
  /** Returns information about the reservation. */
  getReservation(
    request: GetReservationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Reservation>>;
  /**
   * Deletes a reservation.
   * Returns `google.rpc.Code.FAILED_PRECONDITION` when reservation has
   * assignments.
   */
  deleteReservation(
    request: DeleteReservationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Updates an existing reservation resource. */
  updateReservation(
    request: UpdateReservationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Reservation>>;
  /** Creates a new capacity commitment resource. */
  createCapacityCommitment(
    request: CreateCapacityCommitmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CapacityCommitment>>;
  /** Lists all the capacity commitments for the admin project. */
  listCapacityCommitments(
    request: ListCapacityCommitmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListCapacityCommitmentsResponse>>;
  /** Returns information about the capacity commitment. */
  getCapacityCommitment(
    request: GetCapacityCommitmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CapacityCommitment>>;
  /**
   * Deletes a capacity commitment. Attempting to delete capacity commitment
   * before its commitment_end_time will fail with the error code
   * `google.rpc.Code.FAILED_PRECONDITION`.
   */
  deleteCapacityCommitment(
    request: DeleteCapacityCommitmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Updates an existing capacity commitment.
   *
   * Only `plan` and `renewal_plan` fields can be updated.
   *
   * Plan can only be changed to a plan of a longer commitment period.
   * Attempting to change to a plan with shorter commitment period will fail
   * with the error code `google.rpc.Code.FAILED_PRECONDITION`.
   */
  updateCapacityCommitment(
    request: UpdateCapacityCommitmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CapacityCommitment>>;
  /**
   * Splits capacity commitment to two commitments of the same plan and
   * `commitment_end_time`.
   *
   * A common use case is to enable downgrading commitments.
   *
   * For example, in order to downgrade from 10000 slots to 8000, you might
   * split a 10000 capacity commitment into commitments of 2000 and 8000. Then,
   * you delete the first one after the commitment end time passes.
   */
  splitCapacityCommitment(
    request: SplitCapacityCommitmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SplitCapacityCommitmentResponse>>;
  /**
   * Merges capacity commitments of the same plan into a single commitment.
   *
   * The resulting capacity commitment has the greater commitment_end_time
   * out of the to-be-merged capacity commitments.
   *
   * Attempting to merge capacity commitments of different plan will fail
   * with the error code `google.rpc.Code.FAILED_PRECONDITION`.
   */
  mergeCapacityCommitments(
    request: MergeCapacityCommitmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CapacityCommitment>>;
  /**
   * Creates an assignment object which allows the given project to submit jobs
   * of a certain type using slots from the specified reservation.
   *
   * Currently a
   * resource (project, folder, organization) can only have one assignment per
   * each (job_type, location) combination, and that reservation will be used
   * for all jobs of the matching type.
   *
   * Different assignments can be created on different levels of the
   * projects, folders or organization hierarchy.  During query execution,
   * the assignment is looked up at the project, folder and organization levels
   * in that order. The first assignment found is applied to the query.
   *
   * When creating assignments, it does not matter if other assignments exist at
   * higher levels.
   *
   * Example:
   *
   * * The organization `organizationA` contains two projects, `project1`
   *   and `project2`.
   * * Assignments for all three entities (`organizationA`, `project1`, and
   *   `project2`) could all be created and mapped to the same or different
   *   reservations.
   *
   * "None" assignments represent an absence of the assignment. Projects
   * assigned to None use on-demand pricing. To create a "None" assignment, use
   * "none" as a reservation_id in the parent. Example parent:
   * `projects/myproject/locations/US/reservations/none`.
   *
   * Returns `google.rpc.Code.PERMISSION_DENIED` if user does not have
   * 'bigquery.admin' permissions on the project using the reservation
   * and the project that owns this reservation.
   *
   * Returns `google.rpc.Code.INVALID_ARGUMENT` when location of the assignment
   * does not match location of the reservation.
   */
  createAssignment(
    request: CreateAssignmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Assignment>>;
  /**
   * Lists assignments.
   *
   * Only explicitly created assignments will be returned.
   *
   * Example:
   *
   * * Organization `organizationA` contains two projects, `project1` and
   *   `project2`.
   * * Reservation `res1` exists and was created previously.
   * * CreateAssignment was used previously to define the following
   *   associations between entities and reservations: `<organizationA, res1>`
   *   and `<project1, res1>`
   *
   * In this example, ListAssignments will just return the above two assignments
   * for reservation `res1`, and no expansion/merge will happen.
   *
   * The wildcard "-" can be used for
   * reservations in the request. In that case all assignments belongs to the
   * specified project and location will be listed.
   *
   * **Note** "-" cannot be used for projects nor locations.
   */
  listAssignments(
    request: ListAssignmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAssignmentsResponse>>;
  /**
   * Deletes a assignment. No expansion will happen.
   *
   * Example:
   *
   * * Organization `organizationA` contains two projects, `project1` and
   *   `project2`.
   * * Reservation `res1` exists and was created previously.
   * * CreateAssignment was used previously to define the following
   *   associations between entities and reservations: `<organizationA, res1>`
   *   and `<project1, res1>`
   *
   * In this example, deletion of the `<organizationA, res1>` assignment won't
   * affect the other assignment `<project1, res1>`. After said deletion,
   * queries from `project1` will still use `res1` while queries from
   * `project2` will switch to use on-demand mode.
   */
  deleteAssignment(
    request: DeleteAssignmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /**
   * Deprecated: Looks up assignments for a specified resource for a particular
   * region. If the request is about a project:
   *
   * 1. Assignments created on the project will be returned if they exist.
   * 2. Otherwise assignments created on the closest ancestor will be
   *    returned.
   * 3. Assignments for different JobTypes will all be returned.
   *
   * The same logic applies if the request is about a folder.
   *
   * If the request is about an organization, then assignments created on the
   * organization will be returned (organization doesn't have ancestors).
   *
   * Comparing to ListAssignments, there are some behavior
   * differences:
   *
   * 1. permission on the assignee will be verified in this API.
   * 2. Hierarchy lookup (project->folder->organization) happens in this API.
   * 3. Parent here is `projects/* /locations/*`, instead of
   *    `projects/* /locations/*reservations/*`.
   *
   * **Note** "-" cannot be used for projects
   * nor locations.
   *
   * @deprecated
   */
  searchAssignments(
    request: SearchAssignmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchAssignmentsResponse>>;
  /**
   * Looks up assignments for a specified resource for a particular region.
   * If the request is about a project:
   *
   * 1. Assignments created on the project will be returned if they exist.
   * 2. Otherwise assignments created on the closest ancestor will be
   *    returned.
   * 3. Assignments for different JobTypes will all be returned.
   *
   * The same logic applies if the request is about a folder.
   *
   * If the request is about an organization, then assignments created on the
   * organization will be returned (organization doesn't have ancestors).
   *
   * Comparing to ListAssignments, there are some behavior
   * differences:
   *
   * 1. permission on the assignee will be verified in this API.
   * 2. Hierarchy lookup (project->folder->organization) happens in this API.
   * 3. Parent here is `projects/* /locations/*`, instead of
   *    `projects/* /locations/*reservations/*`.
   */
  searchAllAssignments(
    request: SearchAllAssignmentsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchAllAssignmentsResponse>>;
  /**
   * Moves an assignment under a new reservation.
   *
   * This differs from removing an existing assignment and recreating a new one
   * by providing a transactional change that ensures an assignee always has an
   * associated reservation.
   */
  moveAssignment(
    request: MoveAssignmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Assignment>>;
  /**
   * Updates an existing assignment.
   *
   * Only the `priority` field can be updated.
   */
  updateAssignment(
    request: UpdateAssignmentRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Assignment>>;
  /** Retrieves a BI reservation. */
  getBiReservation(
    request: GetBiReservationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BiReservation>>;
  /**
   * Updates a BI reservation.
   *
   * Only fields specified in the `field_mask` are updated.
   *
   * A singleton BI reservation always exists with default size 0.
   * In order to reserve BI capacity it needs to be updated to an amount
   * greater than 0. In order to release BI capacity reservation size
   * must be set to 0.
   */
  updateBiReservation(
    request: UpdateBiReservationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BiReservation>>;
}

export interface ReservationServiceClient<CallOptionsExt = {}> {
  /** Creates a new reservation resource. */
  createReservation(
    request: DeepPartial<CreateReservationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Reservation>;
  /** Lists all the reservations for the project in the specified location. */
  listReservations(
    request: DeepPartial<ListReservationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListReservationsResponse>;
  /** Returns information about the reservation. */
  getReservation(
    request: DeepPartial<GetReservationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Reservation>;
  /**
   * Deletes a reservation.
   * Returns `google.rpc.Code.FAILED_PRECONDITION` when reservation has
   * assignments.
   */
  deleteReservation(
    request: DeepPartial<DeleteReservationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Updates an existing reservation resource. */
  updateReservation(
    request: DeepPartial<UpdateReservationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Reservation>;
  /** Creates a new capacity commitment resource. */
  createCapacityCommitment(
    request: DeepPartial<CreateCapacityCommitmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CapacityCommitment>;
  /** Lists all the capacity commitments for the admin project. */
  listCapacityCommitments(
    request: DeepPartial<ListCapacityCommitmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListCapacityCommitmentsResponse>;
  /** Returns information about the capacity commitment. */
  getCapacityCommitment(
    request: DeepPartial<GetCapacityCommitmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CapacityCommitment>;
  /**
   * Deletes a capacity commitment. Attempting to delete capacity commitment
   * before its commitment_end_time will fail with the error code
   * `google.rpc.Code.FAILED_PRECONDITION`.
   */
  deleteCapacityCommitment(
    request: DeepPartial<DeleteCapacityCommitmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Updates an existing capacity commitment.
   *
   * Only `plan` and `renewal_plan` fields can be updated.
   *
   * Plan can only be changed to a plan of a longer commitment period.
   * Attempting to change to a plan with shorter commitment period will fail
   * with the error code `google.rpc.Code.FAILED_PRECONDITION`.
   */
  updateCapacityCommitment(
    request: DeepPartial<UpdateCapacityCommitmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CapacityCommitment>;
  /**
   * Splits capacity commitment to two commitments of the same plan and
   * `commitment_end_time`.
   *
   * A common use case is to enable downgrading commitments.
   *
   * For example, in order to downgrade from 10000 slots to 8000, you might
   * split a 10000 capacity commitment into commitments of 2000 and 8000. Then,
   * you delete the first one after the commitment end time passes.
   */
  splitCapacityCommitment(
    request: DeepPartial<SplitCapacityCommitmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SplitCapacityCommitmentResponse>;
  /**
   * Merges capacity commitments of the same plan into a single commitment.
   *
   * The resulting capacity commitment has the greater commitment_end_time
   * out of the to-be-merged capacity commitments.
   *
   * Attempting to merge capacity commitments of different plan will fail
   * with the error code `google.rpc.Code.FAILED_PRECONDITION`.
   */
  mergeCapacityCommitments(
    request: DeepPartial<MergeCapacityCommitmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CapacityCommitment>;
  /**
   * Creates an assignment object which allows the given project to submit jobs
   * of a certain type using slots from the specified reservation.
   *
   * Currently a
   * resource (project, folder, organization) can only have one assignment per
   * each (job_type, location) combination, and that reservation will be used
   * for all jobs of the matching type.
   *
   * Different assignments can be created on different levels of the
   * projects, folders or organization hierarchy.  During query execution,
   * the assignment is looked up at the project, folder and organization levels
   * in that order. The first assignment found is applied to the query.
   *
   * When creating assignments, it does not matter if other assignments exist at
   * higher levels.
   *
   * Example:
   *
   * * The organization `organizationA` contains two projects, `project1`
   *   and `project2`.
   * * Assignments for all three entities (`organizationA`, `project1`, and
   *   `project2`) could all be created and mapped to the same or different
   *   reservations.
   *
   * "None" assignments represent an absence of the assignment. Projects
   * assigned to None use on-demand pricing. To create a "None" assignment, use
   * "none" as a reservation_id in the parent. Example parent:
   * `projects/myproject/locations/US/reservations/none`.
   *
   * Returns `google.rpc.Code.PERMISSION_DENIED` if user does not have
   * 'bigquery.admin' permissions on the project using the reservation
   * and the project that owns this reservation.
   *
   * Returns `google.rpc.Code.INVALID_ARGUMENT` when location of the assignment
   * does not match location of the reservation.
   */
  createAssignment(
    request: DeepPartial<CreateAssignmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Assignment>;
  /**
   * Lists assignments.
   *
   * Only explicitly created assignments will be returned.
   *
   * Example:
   *
   * * Organization `organizationA` contains two projects, `project1` and
   *   `project2`.
   * * Reservation `res1` exists and was created previously.
   * * CreateAssignment was used previously to define the following
   *   associations between entities and reservations: `<organizationA, res1>`
   *   and `<project1, res1>`
   *
   * In this example, ListAssignments will just return the above two assignments
   * for reservation `res1`, and no expansion/merge will happen.
   *
   * The wildcard "-" can be used for
   * reservations in the request. In that case all assignments belongs to the
   * specified project and location will be listed.
   *
   * **Note** "-" cannot be used for projects nor locations.
   */
  listAssignments(
    request: DeepPartial<ListAssignmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAssignmentsResponse>;
  /**
   * Deletes a assignment. No expansion will happen.
   *
   * Example:
   *
   * * Organization `organizationA` contains two projects, `project1` and
   *   `project2`.
   * * Reservation `res1` exists and was created previously.
   * * CreateAssignment was used previously to define the following
   *   associations between entities and reservations: `<organizationA, res1>`
   *   and `<project1, res1>`
   *
   * In this example, deletion of the `<organizationA, res1>` assignment won't
   * affect the other assignment `<project1, res1>`. After said deletion,
   * queries from `project1` will still use `res1` while queries from
   * `project2` will switch to use on-demand mode.
   */
  deleteAssignment(
    request: DeepPartial<DeleteAssignmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /**
   * Deprecated: Looks up assignments for a specified resource for a particular
   * region. If the request is about a project:
   *
   * 1. Assignments created on the project will be returned if they exist.
   * 2. Otherwise assignments created on the closest ancestor will be
   *    returned.
   * 3. Assignments for different JobTypes will all be returned.
   *
   * The same logic applies if the request is about a folder.
   *
   * If the request is about an organization, then assignments created on the
   * organization will be returned (organization doesn't have ancestors).
   *
   * Comparing to ListAssignments, there are some behavior
   * differences:
   *
   * 1. permission on the assignee will be verified in this API.
   * 2. Hierarchy lookup (project->folder->organization) happens in this API.
   * 3. Parent here is `projects/* /locations/*`, instead of
   *    `projects/* /locations/*reservations/*`.
   *
   * **Note** "-" cannot be used for projects
   * nor locations.
   *
   * @deprecated
   */
  searchAssignments(
    request: DeepPartial<SearchAssignmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchAssignmentsResponse>;
  /**
   * Looks up assignments for a specified resource for a particular region.
   * If the request is about a project:
   *
   * 1. Assignments created on the project will be returned if they exist.
   * 2. Otherwise assignments created on the closest ancestor will be
   *    returned.
   * 3. Assignments for different JobTypes will all be returned.
   *
   * The same logic applies if the request is about a folder.
   *
   * If the request is about an organization, then assignments created on the
   * organization will be returned (organization doesn't have ancestors).
   *
   * Comparing to ListAssignments, there are some behavior
   * differences:
   *
   * 1. permission on the assignee will be verified in this API.
   * 2. Hierarchy lookup (project->folder->organization) happens in this API.
   * 3. Parent here is `projects/* /locations/*`, instead of
   *    `projects/* /locations/*reservations/*`.
   */
  searchAllAssignments(
    request: DeepPartial<SearchAllAssignmentsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchAllAssignmentsResponse>;
  /**
   * Moves an assignment under a new reservation.
   *
   * This differs from removing an existing assignment and recreating a new one
   * by providing a transactional change that ensures an assignee always has an
   * associated reservation.
   */
  moveAssignment(
    request: DeepPartial<MoveAssignmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Assignment>;
  /**
   * Updates an existing assignment.
   *
   * Only the `priority` field can be updated.
   */
  updateAssignment(
    request: DeepPartial<UpdateAssignmentRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Assignment>;
  /** Retrieves a BI reservation. */
  getBiReservation(
    request: DeepPartial<GetBiReservationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BiReservation>;
  /**
   * Updates a BI reservation.
   *
   * Only fields specified in the `field_mask` are updated.
   *
   * A singleton BI reservation always exists with default size 0.
   * In order to reserve BI capacity it needs to be updated to an amount
   * greater than 0. In order to release BI capacity reservation size
   * must be set to 0.
   */
  updateBiReservation(
    request: DeepPartial<UpdateBiReservationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BiReservation>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
