// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/v2/table.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "../../../protobuf/empty.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  BoolValue,
  Int32Value,
  Int64Value,
  StringValue,
  UInt32Value,
  UInt64Value,
} from "../../../protobuf/wrappers.js";
import { BigLakeConfiguration } from "./biglake_config.js";
import { Clustering } from "./clustering.js";
import { EncryptionConfiguration } from "./encryption_config.js";
import { ErrorProto } from "./error.js";
import { ExternalCatalogTableOptions } from "./external_catalog_table_options.js";
import { ExternalDataConfiguration } from "./external_data_config.js";
import { PartitioningDefinition } from "./partitioning_definition.js";
import { PrivacyPolicy } from "./privacy_policy.js";
import { RangePartitioning } from "./range_partitioning.js";
import { RestrictionConfig } from "./restriction_config.js";
import { TableConstraints } from "./table_constraints.js";
import { TableReference } from "./table_reference.js";
import {
  TableFieldSchema_RoundingMode,
  tableFieldSchema_RoundingModeFromJSON,
  tableFieldSchema_RoundingModeToJSON,
  TableSchema,
} from "./table_schema.js";
import { TimePartitioning } from "./time_partitioning.js";
import { UserDefinedFunctionResource } from "./udf_resource.js";

export const protobufPackage = "google.cloud.bigquery.v2";

/**
 * Replication info of a table created using `AS REPLICA` DDL like:
 * `CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv`
 */
export interface TableReplicationInfo {
  /** Required. Source table reference that is replicated. */
  sourceTable:
    | TableReference
    | undefined;
  /**
   * Optional. Specifies the interval at which the source table is polled for
   * updates.
   * It's Optional. If not specified, default replication interval would be
   * applied.
   */
  replicationIntervalMs: Long;
  /**
   * Optional. Output only. If source is a materialized view, this field
   * signifies the last refresh time of the source.
   */
  replicatedSourceLastRefreshTime: Long;
  /** Optional. Output only. Replication status of configured replication. */
  replicationStatus: TableReplicationInfo_ReplicationStatus;
  /**
   * Optional. Output only. Replication error that will permanently stopped
   * table replication.
   */
  replicationError: ErrorProto | undefined;
}

/**
 * Replication status of the table created using `AS REPLICA` like:
 * `CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv`
 */
export enum TableReplicationInfo_ReplicationStatus {
  /** REPLICATION_STATUS_UNSPECIFIED - Default value. */
  REPLICATION_STATUS_UNSPECIFIED = 0,
  /** ACTIVE - Replication is Active with no errors. */
  ACTIVE = 1,
  /** SOURCE_DELETED - Source object is deleted. */
  SOURCE_DELETED = 2,
  /** PERMISSION_DENIED - Source revoked replication permissions. */
  PERMISSION_DENIED = 3,
  /** UNSUPPORTED_CONFIGURATION - Source configuration doesnâ€™t allow replication. */
  UNSUPPORTED_CONFIGURATION = 4,
  UNRECOGNIZED = -1,
}

export function tableReplicationInfo_ReplicationStatusFromJSON(object: any): TableReplicationInfo_ReplicationStatus {
  switch (object) {
    case 0:
    case "REPLICATION_STATUS_UNSPECIFIED":
      return TableReplicationInfo_ReplicationStatus.REPLICATION_STATUS_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return TableReplicationInfo_ReplicationStatus.ACTIVE;
    case 2:
    case "SOURCE_DELETED":
      return TableReplicationInfo_ReplicationStatus.SOURCE_DELETED;
    case 3:
    case "PERMISSION_DENIED":
      return TableReplicationInfo_ReplicationStatus.PERMISSION_DENIED;
    case 4:
    case "UNSUPPORTED_CONFIGURATION":
      return TableReplicationInfo_ReplicationStatus.UNSUPPORTED_CONFIGURATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TableReplicationInfo_ReplicationStatus.UNRECOGNIZED;
  }
}

export function tableReplicationInfo_ReplicationStatusToJSON(object: TableReplicationInfo_ReplicationStatus): string {
  switch (object) {
    case TableReplicationInfo_ReplicationStatus.REPLICATION_STATUS_UNSPECIFIED:
      return "REPLICATION_STATUS_UNSPECIFIED";
    case TableReplicationInfo_ReplicationStatus.ACTIVE:
      return "ACTIVE";
    case TableReplicationInfo_ReplicationStatus.SOURCE_DELETED:
      return "SOURCE_DELETED";
    case TableReplicationInfo_ReplicationStatus.PERMISSION_DENIED:
      return "PERMISSION_DENIED";
    case TableReplicationInfo_ReplicationStatus.UNSUPPORTED_CONFIGURATION:
      return "UNSUPPORTED_CONFIGURATION";
    case TableReplicationInfo_ReplicationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes the definition of a logical view. */
export interface ViewDefinition {
  /** Required. A query that BigQuery executes when the view is referenced. */
  query: string;
  /** Describes user-defined function resources used in the query. */
  userDefinedFunctionResources: UserDefinedFunctionResource[];
  /**
   * Specifies whether to use BigQuery's legacy SQL for this view.
   * The default value is true. If set to false, the view will use
   * BigQuery's GoogleSQL:
   * https://cloud.google.com/bigquery/sql-reference/
   *
   * Queries and views that reference this view must use the same flag value.
   * A wrapper is used here because the default value is True.
   */
  useLegacySql:
    | boolean
    | undefined;
  /**
   * True if the column names are explicitly specified. For example by using the
   * 'CREATE VIEW v(c1, c2) AS ...' syntax.
   * Can only be set for GoogleSQL views.
   */
  useExplicitColumnNames: boolean;
  /** Optional. Specifices the privacy policy for the view. */
  privacyPolicy:
    | PrivacyPolicy
    | undefined;
  /** Optional. Foreign view representations. */
  foreignDefinitions: ForeignViewDefinition[];
}

/**
 * A view can be represented in multiple ways. Each representation has its own
 * dialect. This message stores the metadata required for these representations.
 */
export interface ForeignViewDefinition {
  /** Required. The query that defines the view. */
  query: string;
  /** Optional. Represents the dialect of the query. */
  dialect: string;
}

/** Definition and configuration of a materialized view. */
export interface MaterializedViewDefinition {
  /** Required. A query whose results are persisted. */
  query: string;
  /**
   * Output only. The time when this materialized view was last refreshed, in
   * milliseconds since the epoch.
   */
  lastRefreshTime: Long;
  /**
   * Optional. Enable automatic refresh of the materialized view when the base
   * table is updated. The default value is "true".
   */
  enableRefresh:
    | boolean
    | undefined;
  /**
   * Optional. The maximum frequency at which this materialized view will be
   * refreshed. The default value is "1800000" (30 minutes).
   */
  refreshIntervalMs:
    | Long
    | undefined;
  /**
   * Optional. This option declares the intention to construct a materialized
   * view that isn't refreshed incrementally.
   */
  allowNonIncrementalDefinition: boolean | undefined;
}

/**
 * Status of a materialized view.
 * The last refresh timestamp status is omitted here, but is present in the
 * MaterializedViewDefinition message.
 */
export interface MaterializedViewStatus {
  /**
   * Output only. Refresh watermark of materialized view. The base tables' data
   * were collected into the materialized view cache until this time.
   */
  refreshWatermark:
    | Date
    | undefined;
  /**
   * Output only. Error result of the last automatic refresh. If present,
   * indicates that the last automatic refresh was unsuccessful.
   */
  lastRefreshStatus: ErrorProto | undefined;
}

/** Information about base table and snapshot time of the snapshot. */
export interface SnapshotDefinition {
  /** Required. Reference describing the ID of the table that was snapshot. */
  baseTableReference:
    | TableReference
    | undefined;
  /**
   * Required. The time at which the base table was snapshot. This value is
   * reported in the JSON response using RFC3339 format.
   */
  snapshotTime: Date | undefined;
}

/** Information about base table and clone time of a table clone. */
export interface CloneDefinition {
  /** Required. Reference describing the ID of the table that was cloned. */
  baseTableReference:
    | TableReference
    | undefined;
  /**
   * Required. The time at which the base table was cloned. This value is
   * reported in the JSON response using RFC3339 format.
   */
  cloneTime: Date | undefined;
}

export interface Streamingbuffer {
  /**
   * Output only. A lower-bound estimate of the number of bytes currently in
   * the streaming buffer.
   */
  estimatedBytes: Long;
  /**
   * Output only. A lower-bound estimate of the number of rows currently in the
   * streaming buffer.
   */
  estimatedRows: Long;
  /**
   * Output only. Contains the timestamp of the oldest entry in the streaming
   * buffer, in milliseconds since the epoch, if the streaming buffer is
   * available.
   */
  oldestEntryTime: Long;
}

export interface Table {
  /** The type of resource ID. */
  kind: string;
  /** Output only. A hash of this resource. */
  etag: string;
  /** Output only. An opaque ID uniquely identifying the table. */
  id: string;
  /** Output only. A URL that can be used to access this resource again. */
  selfLink: string;
  /** Required. Reference describing the ID of this table. */
  tableReference:
    | TableReference
    | undefined;
  /** Optional. A descriptive name for this table. */
  friendlyName:
    | string
    | undefined;
  /** Optional. A user-friendly description of this table. */
  description:
    | string
    | undefined;
  /**
   * The labels associated with this table. You can use these to organize and
   * group your tables. Label keys and values can be no longer than 63
   * characters, can only contain lowercase letters, numeric characters,
   * underscores and dashes. International characters are allowed. Label values
   * are optional. Label keys must start with a letter and each label in the
   * list must have a different key.
   */
  labels: { [key: string]: string };
  /** Optional. Describes the schema of this table. */
  schema:
    | TableSchema
    | undefined;
  /** If specified, configures time-based partitioning for this table. */
  timePartitioning:
    | TimePartitioning
    | undefined;
  /** If specified, configures range partitioning for this table. */
  rangePartitioning:
    | RangePartitioning
    | undefined;
  /**
   * Clustering specification for the table. Must be specified with time-based
   * partitioning, data in the table will be first partitioned and subsequently
   * clustered.
   */
  clustering:
    | Clustering
    | undefined;
  /**
   * Optional. If set to true, queries over this table require
   * a partition filter that can be used for partition elimination to be
   * specified.
   */
  requirePartitionFilter:
    | boolean
    | undefined;
  /**
   * Optional. The partition information for all table formats, including
   * managed partitioned tables, hive partitioned tables, iceberg partitioned,
   * and metastore partitioned tables. This field is only populated for
   * metastore partitioned tables. For other table formats, this is an output
   * only field.
   */
  partitionDefinition?:
    | PartitioningDefinition
    | undefined;
  /**
   * Output only. The size of this table in logical bytes, excluding any data in
   * the streaming buffer.
   */
  numBytes:
    | Long
    | undefined;
  /**
   * Output only. The physical size of this table in bytes. This includes
   * storage used for time travel.
   */
  numPhysicalBytes:
    | Long
    | undefined;
  /**
   * Output only. The number of logical bytes in the table that are considered
   * "long-term storage".
   */
  numLongTermBytes:
    | Long
    | undefined;
  /**
   * Output only. The number of rows of data in this table, excluding any data
   * in the streaming buffer.
   */
  numRows:
    | Long
    | undefined;
  /**
   * Output only. The time when this table was created, in milliseconds since
   * the epoch.
   */
  creationTime: Long;
  /**
   * Optional. The time when this table expires, in milliseconds since the
   * epoch. If not present, the table will persist indefinitely. Expired tables
   * will be deleted and their storage reclaimed.  The defaultTableExpirationMs
   * property of the encapsulating dataset can be used to set a default
   * expirationTime on newly created tables.
   */
  expirationTime:
    | Long
    | undefined;
  /**
   * Output only. The time when this table was last modified, in milliseconds
   * since the epoch.
   */
  lastModifiedTime: Long;
  /**
   * Output only. Describes the table type. The following values are supported:
   *
   * * `TABLE`: A normal BigQuery table.
   * * `VIEW`: A virtual table defined by a SQL query.
   * * `EXTERNAL`: A table that references data stored in an external storage
   *   system, such as Google Cloud Storage.
   * * `MATERIALIZED_VIEW`: A precomputed view defined by a SQL query.
   * * `SNAPSHOT`: An immutable BigQuery table that preserves the contents of a
   *   base table at a particular time. See additional information on
   *   [table
   *   snapshots](https://cloud.google.com/bigquery/docs/table-snapshots-intro).
   *
   * The default value is `TABLE`.
   */
  type: string;
  /** Optional. The view definition. */
  view:
    | ViewDefinition
    | undefined;
  /** Optional. The materialized view definition. */
  materializedView:
    | MaterializedViewDefinition
    | undefined;
  /** Output only. The materialized view status. */
  materializedViewStatus:
    | MaterializedViewStatus
    | undefined;
  /**
   * Optional. Describes the data format, location, and other properties of
   * a table stored outside of BigQuery. By defining these properties, the data
   * source can then be queried as if it were a standard BigQuery table.
   */
  externalDataConfiguration:
    | ExternalDataConfiguration
    | undefined;
  /** Optional. Specifies the configuration of a BigLake managed table. */
  biglakeConfiguration:
    | BigLakeConfiguration
    | undefined;
  /**
   * Output only. The geographic location where the table resides. This value
   * is inherited from the dataset.
   */
  location: string;
  /**
   * Output only. Contains information regarding this table's streaming buffer,
   * if one is present. This field will be absent if the table is not being
   * streamed to or if there is no data in the streaming buffer.
   */
  streamingBuffer:
    | Streamingbuffer
    | undefined;
  /** Custom encryption configuration (e.g., Cloud KMS keys). */
  encryptionConfiguration:
    | EncryptionConfiguration
    | undefined;
  /**
   * Output only. Contains information about the snapshot. This value is set via
   * snapshot creation.
   */
  snapshotDefinition:
    | SnapshotDefinition
    | undefined;
  /**
   * Optional. Defines the default collation specification of new STRING fields
   * in the table. During table creation or update, if a STRING field is added
   * to this table without explicit collation specified, then the table inherits
   * the table default collation. A change to this field affects only fields
   * added afterwards, and does not alter the existing fields.
   * The following values are supported:
   *
   * * 'und:ci': undetermined locale, case insensitive.
   * * '': empty string. Default to case-sensitive behavior.
   */
  defaultCollation:
    | string
    | undefined;
  /**
   * Optional. Defines the default rounding mode specification of new decimal
   * fields (NUMERIC OR BIGNUMERIC) in the table. During table creation or
   * update, if a decimal field is added to this table without an explicit
   * rounding mode specified, then the field inherits the table default
   * rounding mode. Changing this field doesn't affect existing fields.
   */
  defaultRoundingMode: TableFieldSchema_RoundingMode;
  /**
   * Output only. Contains information about the clone. This value is set via
   * the clone operation.
   */
  cloneDefinition:
    | CloneDefinition
    | undefined;
  /**
   * Output only. Number of physical bytes used by time travel storage (deleted
   * or changed data). This data is not kept in real time, and might be delayed
   * by a few seconds to a few minutes.
   */
  numTimeTravelPhysicalBytes:
    | Long
    | undefined;
  /**
   * Output only. Total number of logical bytes in the table or materialized
   * view.
   */
  numTotalLogicalBytes:
    | Long
    | undefined;
  /** Output only. Number of logical bytes that are less than 90 days old. */
  numActiveLogicalBytes:
    | Long
    | undefined;
  /** Output only. Number of logical bytes that are more than 90 days old. */
  numLongTermLogicalBytes:
    | Long
    | undefined;
  /**
   * Output only. Number of physical bytes used by current live data storage.
   * This data is not kept in real time, and might be delayed by a few seconds
   * to a few minutes.
   */
  numCurrentPhysicalBytes:
    | Long
    | undefined;
  /**
   * Output only. The physical size of this table in bytes. This also includes
   * storage used for time travel. This data is not kept in real time, and might
   * be delayed by a few seconds to a few minutes.
   */
  numTotalPhysicalBytes:
    | Long
    | undefined;
  /**
   * Output only. Number of physical bytes less than 90 days old. This data is
   * not kept in real time, and might be delayed by a few seconds to a few
   * minutes.
   */
  numActivePhysicalBytes:
    | Long
    | undefined;
  /**
   * Output only. Number of physical bytes more than 90 days old.
   * This data is not kept in real time, and might be delayed by a few seconds
   * to a few minutes.
   */
  numLongTermPhysicalBytes:
    | Long
    | undefined;
  /**
   * Output only. The number of partitions present in the table or materialized
   * view. This data is not kept in real time, and might be delayed by a few
   * seconds to a few minutes.
   */
  numPartitions:
    | Long
    | undefined;
  /**
   * Optional. The maximum staleness of data that could be returned when the
   * table (or stale MV) is queried. Staleness encoded as a string encoding
   * of sql IntervalValue type.
   */
  maxStaleness: string;
  /**
   * Optional. Output only. Restriction config for table. If set, restrict
   * certain accesses on the table based on the config. See [Data
   * egress](https://cloud.google.com/bigquery/docs/analytics-hub-introduction#data_egress)
   * for more details.
   */
  restrictions:
    | RestrictionConfig
    | undefined;
  /** Optional. Tables Primary Key and Foreign Key information */
  tableConstraints:
    | TableConstraints
    | undefined;
  /**
   * Optional. The [tags](https://cloud.google.com/bigquery/docs/tags) attached
   * to this table. Tag keys are globally unique. Tag key is expected to be in
   * the namespaced format, for example "123456789012/environment" where
   * 123456789012 is the ID of the parent organization or project resource for
   * this tag key. Tag value is expected to be the short name, for example
   * "Production". See [Tag
   * definitions](https://cloud.google.com/iam/docs/tags-access-control#definitions)
   * for more details.
   */
  resourceTags: { [key: string]: string };
  /**
   * Optional. Table replication info for table created `AS REPLICA` DDL like:
   * `CREATE MATERIALIZED VIEW mv1 AS REPLICA OF src_mv`
   */
  tableReplicationInfo:
    | TableReplicationInfo
    | undefined;
  /**
   * Optional. Output only. Table references of all replicas currently active on
   * the table.
   */
  replicas: TableReference[];
  /** Optional. Options defining open source compatible table. */
  externalCatalogTableOptions: ExternalCatalogTableOptions | undefined;
}

export interface Table_LabelsEntry {
  key: string;
  value: string;
}

export interface Table_ResourceTagsEntry {
  key: string;
  value: string;
}

/** Request format for getting table metadata. */
export interface GetTableRequest {
  /** Required. Project ID of the requested table */
  projectId: string;
  /** Required. Dataset ID of the requested table */
  datasetId: string;
  /** Required. Table ID of the requested table */
  tableId: string;
  /**
   * List of table schema fields to return (comma-separated).
   * If unspecified, all fields are returned.
   * A fieldMask cannot be used here because the fields will automatically be
   * converted from camelCase to snake_case and the conversion will fail if
   * there are underscores. Since these are fields in BigQuery table schemas,
   * underscores are allowed.
   */
  selectedFields: string;
  /**
   * Optional. Specifies the view that determines which table information is
   * returned. By default, basic table information and storage statistics
   * (STORAGE_STATS) are returned.
   */
  view: GetTableRequest_TableMetadataView;
}

/** TableMetadataView specifies which table information is returned. */
export enum GetTableRequest_TableMetadataView {
  /**
   * TABLE_METADATA_VIEW_UNSPECIFIED - The default value.
   * Default to the STORAGE_STATS view.
   */
  TABLE_METADATA_VIEW_UNSPECIFIED = 0,
  /**
   * BASIC - Includes basic table information including schema and
   * partitioning specification. This view does not include storage statistics
   * such as numRows or numBytes. This view is significantly more efficient
   * and should be used to support high query rates.
   */
  BASIC = 1,
  /**
   * STORAGE_STATS - Includes all information in the BASIC view as well as storage statistics
   * (numBytes, numLongTermBytes, numRows and lastModifiedTime).
   */
  STORAGE_STATS = 2,
  /**
   * FULL - Includes all table information, including storage statistics.
   * It returns same information as STORAGE_STATS view, but may contain
   * additional information in the future.
   */
  FULL = 3,
  UNRECOGNIZED = -1,
}

export function getTableRequest_TableMetadataViewFromJSON(object: any): GetTableRequest_TableMetadataView {
  switch (object) {
    case 0:
    case "TABLE_METADATA_VIEW_UNSPECIFIED":
      return GetTableRequest_TableMetadataView.TABLE_METADATA_VIEW_UNSPECIFIED;
    case 1:
    case "BASIC":
      return GetTableRequest_TableMetadataView.BASIC;
    case 2:
    case "STORAGE_STATS":
      return GetTableRequest_TableMetadataView.STORAGE_STATS;
    case 3:
    case "FULL":
      return GetTableRequest_TableMetadataView.FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GetTableRequest_TableMetadataView.UNRECOGNIZED;
  }
}

export function getTableRequest_TableMetadataViewToJSON(object: GetTableRequest_TableMetadataView): string {
  switch (object) {
    case GetTableRequest_TableMetadataView.TABLE_METADATA_VIEW_UNSPECIFIED:
      return "TABLE_METADATA_VIEW_UNSPECIFIED";
    case GetTableRequest_TableMetadataView.BASIC:
      return "BASIC";
    case GetTableRequest_TableMetadataView.STORAGE_STATS:
      return "STORAGE_STATS";
    case GetTableRequest_TableMetadataView.FULL:
      return "FULL";
    case GetTableRequest_TableMetadataView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request format for inserting table metadata. */
export interface InsertTableRequest {
  /** Required. Project ID of the new table */
  projectId: string;
  /** Required. Dataset ID of the new table */
  datasetId: string;
  /** Required. A tables resource to insert */
  table: Table | undefined;
}

export interface UpdateOrPatchTableRequest {
  /** Required. Project ID of the table to update */
  projectId: string;
  /** Required. Dataset ID of the table to update */
  datasetId: string;
  /** Required. Table ID of the table to update */
  tableId: string;
  /** Required. A tables resource which will replace or patch the specified table */
  table:
    | Table
    | undefined;
  /** Optional. When true will autodetect schema, else will keep original schema. */
  autodetectSchema: boolean;
}

/** Request format for deleting a table. */
export interface DeleteTableRequest {
  /** Required. Project ID of the table to delete */
  projectId: string;
  /** Required. Dataset ID of the table to delete */
  datasetId: string;
  /** Required. Table ID of the table to delete */
  tableId: string;
}

/** Request format for enumerating tables. */
export interface ListTablesRequest {
  /** Required. Project ID of the tables to list */
  projectId: string;
  /** Required. Dataset ID of the tables to list */
  datasetId: string;
  /**
   * The maximum number of results to return in a single response page.
   * Leverage the page tokens to iterate through the entire collection.
   */
  maxResults:
    | number
    | undefined;
  /**
   * Page token, returned by a previous call, to request the next page of
   * results
   */
  pageToken: string;
}

/** Information about a logical view. */
export interface ListFormatView {
  /**
   * True if view is defined in legacy SQL dialect,
   * false if in GoogleSQL.
   */
  useLegacySql:
    | boolean
    | undefined;
  /** Specifices the privacy policy for the view. */
  privacyPolicy: PrivacyPolicy | undefined;
}

export interface ListFormatTable {
  /** The resource type. */
  kind: string;
  /** An opaque ID of the table. */
  id: string;
  /** A reference uniquely identifying table. */
  tableReference:
    | TableReference
    | undefined;
  /** The user-friendly name for this table. */
  friendlyName:
    | string
    | undefined;
  /** The type of table. */
  type: string;
  /** The time-based partitioning for this table. */
  timePartitioning:
    | TimePartitioning
    | undefined;
  /** The range partitioning for this table. */
  rangePartitioning:
    | RangePartitioning
    | undefined;
  /** Clustering specification for this table, if configured. */
  clustering:
    | Clustering
    | undefined;
  /**
   * The labels associated with this table. You can use these to organize
   * and group your tables.
   */
  labels: { [key: string]: string };
  /** Additional details for a view. */
  view:
    | ListFormatView
    | undefined;
  /**
   * Output only. The time when this table was created, in milliseconds since
   * the epoch.
   */
  creationTime: Long;
  /**
   * The time when this table expires, in milliseconds since the
   * epoch. If not present, the table will persist indefinitely. Expired tables
   * will be deleted and their storage reclaimed.
   */
  expirationTime: Long;
  /**
   * Optional. If set to true, queries including this table must specify a
   * partition filter. This filter is used for partition elimination.
   */
  requirePartitionFilter: boolean | undefined;
}

export interface ListFormatTable_LabelsEntry {
  key: string;
  value: string;
}

/** Partial projection of the metadata for a given table in a list response. */
export interface TableList {
  /** The type of list. */
  kind: string;
  /** A hash of this page of results. */
  etag: string;
  /** A token to request the next page of results. */
  nextPageToken: string;
  /** Tables in the requested dataset. */
  tables: ListFormatTable[];
  /** The total number of tables in the dataset. */
  totalItems: number | undefined;
}

function createBaseTableReplicationInfo(): TableReplicationInfo {
  return {
    sourceTable: undefined,
    replicationIntervalMs: Long.ZERO,
    replicatedSourceLastRefreshTime: Long.ZERO,
    replicationStatus: 0,
    replicationError: undefined,
  };
}

export const TableReplicationInfo: MessageFns<TableReplicationInfo> = {
  encode(message: TableReplicationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceTable !== undefined) {
      TableReference.encode(message.sourceTable, writer.uint32(10).fork()).join();
    }
    if (!message.replicationIntervalMs.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.replicationIntervalMs.toString());
    }
    if (!message.replicatedSourceLastRefreshTime.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.replicatedSourceLastRefreshTime.toString());
    }
    if (message.replicationStatus !== 0) {
      writer.uint32(32).int32(message.replicationStatus);
    }
    if (message.replicationError !== undefined) {
      ErrorProto.encode(message.replicationError, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableReplicationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableReplicationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceTable = TableReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.replicationIntervalMs = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.replicatedSourceLastRefreshTime = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.replicationStatus = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.replicationError = ErrorProto.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableReplicationInfo {
    return {
      sourceTable: isSet(object.sourceTable) ? TableReference.fromJSON(object.sourceTable) : undefined,
      replicationIntervalMs: isSet(object.replicationIntervalMs)
        ? Long.fromValue(object.replicationIntervalMs)
        : Long.ZERO,
      replicatedSourceLastRefreshTime: isSet(object.replicatedSourceLastRefreshTime)
        ? Long.fromValue(object.replicatedSourceLastRefreshTime)
        : Long.ZERO,
      replicationStatus: isSet(object.replicationStatus)
        ? tableReplicationInfo_ReplicationStatusFromJSON(object.replicationStatus)
        : 0,
      replicationError: isSet(object.replicationError) ? ErrorProto.fromJSON(object.replicationError) : undefined,
    };
  },

  toJSON(message: TableReplicationInfo): unknown {
    const obj: any = {};
    if (message.sourceTable !== undefined) {
      obj.sourceTable = TableReference.toJSON(message.sourceTable);
    }
    if (!message.replicationIntervalMs.equals(Long.ZERO)) {
      obj.replicationIntervalMs = (message.replicationIntervalMs || Long.ZERO).toString();
    }
    if (!message.replicatedSourceLastRefreshTime.equals(Long.ZERO)) {
      obj.replicatedSourceLastRefreshTime = (message.replicatedSourceLastRefreshTime || Long.ZERO).toString();
    }
    if (message.replicationStatus !== 0) {
      obj.replicationStatus = tableReplicationInfo_ReplicationStatusToJSON(message.replicationStatus);
    }
    if (message.replicationError !== undefined) {
      obj.replicationError = ErrorProto.toJSON(message.replicationError);
    }
    return obj;
  },

  create(base?: DeepPartial<TableReplicationInfo>): TableReplicationInfo {
    return TableReplicationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableReplicationInfo>): TableReplicationInfo {
    const message = createBaseTableReplicationInfo();
    message.sourceTable = (object.sourceTable !== undefined && object.sourceTable !== null)
      ? TableReference.fromPartial(object.sourceTable)
      : undefined;
    message.replicationIntervalMs =
      (object.replicationIntervalMs !== undefined && object.replicationIntervalMs !== null)
        ? Long.fromValue(object.replicationIntervalMs)
        : Long.ZERO;
    message.replicatedSourceLastRefreshTime =
      (object.replicatedSourceLastRefreshTime !== undefined && object.replicatedSourceLastRefreshTime !== null)
        ? Long.fromValue(object.replicatedSourceLastRefreshTime)
        : Long.ZERO;
    message.replicationStatus = object.replicationStatus ?? 0;
    message.replicationError = (object.replicationError !== undefined && object.replicationError !== null)
      ? ErrorProto.fromPartial(object.replicationError)
      : undefined;
    return message;
  },
};

function createBaseViewDefinition(): ViewDefinition {
  return {
    query: "",
    userDefinedFunctionResources: [],
    useLegacySql: undefined,
    useExplicitColumnNames: false,
    privacyPolicy: undefined,
    foreignDefinitions: [],
  };
}

export const ViewDefinition: MessageFns<ViewDefinition> = {
  encode(message: ViewDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    for (const v of message.userDefinedFunctionResources) {
      UserDefinedFunctionResource.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.useLegacySql !== undefined) {
      BoolValue.encode({ value: message.useLegacySql! }, writer.uint32(26).fork()).join();
    }
    if (message.useExplicitColumnNames !== false) {
      writer.uint32(32).bool(message.useExplicitColumnNames);
    }
    if (message.privacyPolicy !== undefined) {
      PrivacyPolicy.encode(message.privacyPolicy, writer.uint32(42).fork()).join();
    }
    for (const v of message.foreignDefinitions) {
      ForeignViewDefinition.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ViewDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseViewDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userDefinedFunctionResources.push(UserDefinedFunctionResource.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.useLegacySql = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.useExplicitColumnNames = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.privacyPolicy = PrivacyPolicy.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.foreignDefinitions.push(ForeignViewDefinition.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ViewDefinition {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      userDefinedFunctionResources: globalThis.Array.isArray(object?.userDefinedFunctionResources)
        ? object.userDefinedFunctionResources.map((e: any) => UserDefinedFunctionResource.fromJSON(e))
        : [],
      useLegacySql: isSet(object.useLegacySql) ? Boolean(object.useLegacySql) : undefined,
      useExplicitColumnNames: isSet(object.useExplicitColumnNames)
        ? globalThis.Boolean(object.useExplicitColumnNames)
        : false,
      privacyPolicy: isSet(object.privacyPolicy) ? PrivacyPolicy.fromJSON(object.privacyPolicy) : undefined,
      foreignDefinitions: globalThis.Array.isArray(object?.foreignDefinitions)
        ? object.foreignDefinitions.map((e: any) => ForeignViewDefinition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ViewDefinition): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.userDefinedFunctionResources?.length) {
      obj.userDefinedFunctionResources = message.userDefinedFunctionResources.map((e) =>
        UserDefinedFunctionResource.toJSON(e)
      );
    }
    if (message.useLegacySql !== undefined) {
      obj.useLegacySql = message.useLegacySql;
    }
    if (message.useExplicitColumnNames !== false) {
      obj.useExplicitColumnNames = message.useExplicitColumnNames;
    }
    if (message.privacyPolicy !== undefined) {
      obj.privacyPolicy = PrivacyPolicy.toJSON(message.privacyPolicy);
    }
    if (message.foreignDefinitions?.length) {
      obj.foreignDefinitions = message.foreignDefinitions.map((e) => ForeignViewDefinition.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ViewDefinition>): ViewDefinition {
    return ViewDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ViewDefinition>): ViewDefinition {
    const message = createBaseViewDefinition();
    message.query = object.query ?? "";
    message.userDefinedFunctionResources =
      object.userDefinedFunctionResources?.map((e) => UserDefinedFunctionResource.fromPartial(e)) || [];
    message.useLegacySql = object.useLegacySql ?? undefined;
    message.useExplicitColumnNames = object.useExplicitColumnNames ?? false;
    message.privacyPolicy = (object.privacyPolicy !== undefined && object.privacyPolicy !== null)
      ? PrivacyPolicy.fromPartial(object.privacyPolicy)
      : undefined;
    message.foreignDefinitions = object.foreignDefinitions?.map((e) => ForeignViewDefinition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseForeignViewDefinition(): ForeignViewDefinition {
  return { query: "", dialect: "" };
}

export const ForeignViewDefinition: MessageFns<ForeignViewDefinition> = {
  encode(message: ForeignViewDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.dialect !== "") {
      writer.uint32(58).string(message.dialect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForeignViewDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForeignViewDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.dialect = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForeignViewDefinition {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      dialect: isSet(object.dialect) ? globalThis.String(object.dialect) : "",
    };
  },

  toJSON(message: ForeignViewDefinition): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.dialect !== "") {
      obj.dialect = message.dialect;
    }
    return obj;
  },

  create(base?: DeepPartial<ForeignViewDefinition>): ForeignViewDefinition {
    return ForeignViewDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForeignViewDefinition>): ForeignViewDefinition {
    const message = createBaseForeignViewDefinition();
    message.query = object.query ?? "";
    message.dialect = object.dialect ?? "";
    return message;
  },
};

function createBaseMaterializedViewDefinition(): MaterializedViewDefinition {
  return {
    query: "",
    lastRefreshTime: Long.ZERO,
    enableRefresh: undefined,
    refreshIntervalMs: undefined,
    allowNonIncrementalDefinition: undefined,
  };
}

export const MaterializedViewDefinition: MessageFns<MaterializedViewDefinition> = {
  encode(message: MaterializedViewDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (!message.lastRefreshTime.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.lastRefreshTime.toString());
    }
    if (message.enableRefresh !== undefined) {
      BoolValue.encode({ value: message.enableRefresh! }, writer.uint32(26).fork()).join();
    }
    if (message.refreshIntervalMs !== undefined) {
      UInt64Value.encode({ value: message.refreshIntervalMs! }, writer.uint32(34).fork()).join();
    }
    if (message.allowNonIncrementalDefinition !== undefined) {
      BoolValue.encode({ value: message.allowNonIncrementalDefinition! }, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaterializedViewDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaterializedViewDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.lastRefreshTime = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.enableRefresh = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.refreshIntervalMs = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.allowNonIncrementalDefinition = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaterializedViewDefinition {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      lastRefreshTime: isSet(object.lastRefreshTime) ? Long.fromValue(object.lastRefreshTime) : Long.ZERO,
      enableRefresh: isSet(object.enableRefresh) ? Boolean(object.enableRefresh) : undefined,
      refreshIntervalMs: isSet(object.refreshIntervalMs) ? Long.fromValue(object.refreshIntervalMs) : undefined,
      allowNonIncrementalDefinition: isSet(object.allowNonIncrementalDefinition)
        ? Boolean(object.allowNonIncrementalDefinition)
        : undefined,
    };
  },

  toJSON(message: MaterializedViewDefinition): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (!message.lastRefreshTime.equals(Long.ZERO)) {
      obj.lastRefreshTime = (message.lastRefreshTime || Long.ZERO).toString();
    }
    if (message.enableRefresh !== undefined) {
      obj.enableRefresh = message.enableRefresh;
    }
    if (message.refreshIntervalMs !== undefined) {
      obj.refreshIntervalMs = message.refreshIntervalMs;
    }
    if (message.allowNonIncrementalDefinition !== undefined) {
      obj.allowNonIncrementalDefinition = message.allowNonIncrementalDefinition;
    }
    return obj;
  },

  create(base?: DeepPartial<MaterializedViewDefinition>): MaterializedViewDefinition {
    return MaterializedViewDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaterializedViewDefinition>): MaterializedViewDefinition {
    const message = createBaseMaterializedViewDefinition();
    message.query = object.query ?? "";
    message.lastRefreshTime = (object.lastRefreshTime !== undefined && object.lastRefreshTime !== null)
      ? Long.fromValue(object.lastRefreshTime)
      : Long.ZERO;
    message.enableRefresh = object.enableRefresh ?? undefined;
    message.refreshIntervalMs = (object.refreshIntervalMs !== undefined && object.refreshIntervalMs !== null)
      ? Long.fromValue(object.refreshIntervalMs)
      : undefined;
    message.allowNonIncrementalDefinition = object.allowNonIncrementalDefinition ?? undefined;
    return message;
  },
};

function createBaseMaterializedViewStatus(): MaterializedViewStatus {
  return { refreshWatermark: undefined, lastRefreshStatus: undefined };
}

export const MaterializedViewStatus: MessageFns<MaterializedViewStatus> = {
  encode(message: MaterializedViewStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.refreshWatermark !== undefined) {
      Timestamp.encode(toTimestamp(message.refreshWatermark), writer.uint32(10).fork()).join();
    }
    if (message.lastRefreshStatus !== undefined) {
      ErrorProto.encode(message.lastRefreshStatus, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MaterializedViewStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMaterializedViewStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refreshWatermark = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastRefreshStatus = ErrorProto.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MaterializedViewStatus {
    return {
      refreshWatermark: isSet(object.refreshWatermark) ? fromJsonTimestamp(object.refreshWatermark) : undefined,
      lastRefreshStatus: isSet(object.lastRefreshStatus) ? ErrorProto.fromJSON(object.lastRefreshStatus) : undefined,
    };
  },

  toJSON(message: MaterializedViewStatus): unknown {
    const obj: any = {};
    if (message.refreshWatermark !== undefined) {
      obj.refreshWatermark = message.refreshWatermark.toISOString();
    }
    if (message.lastRefreshStatus !== undefined) {
      obj.lastRefreshStatus = ErrorProto.toJSON(message.lastRefreshStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<MaterializedViewStatus>): MaterializedViewStatus {
    return MaterializedViewStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MaterializedViewStatus>): MaterializedViewStatus {
    const message = createBaseMaterializedViewStatus();
    message.refreshWatermark = object.refreshWatermark ?? undefined;
    message.lastRefreshStatus = (object.lastRefreshStatus !== undefined && object.lastRefreshStatus !== null)
      ? ErrorProto.fromPartial(object.lastRefreshStatus)
      : undefined;
    return message;
  },
};

function createBaseSnapshotDefinition(): SnapshotDefinition {
  return { baseTableReference: undefined, snapshotTime: undefined };
}

export const SnapshotDefinition: MessageFns<SnapshotDefinition> = {
  encode(message: SnapshotDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseTableReference !== undefined) {
      TableReference.encode(message.baseTableReference, writer.uint32(10).fork()).join();
    }
    if (message.snapshotTime !== undefined) {
      Timestamp.encode(toTimestamp(message.snapshotTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnapshotDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapshotDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseTableReference = TableReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.snapshotTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnapshotDefinition {
    return {
      baseTableReference: isSet(object.baseTableReference)
        ? TableReference.fromJSON(object.baseTableReference)
        : undefined,
      snapshotTime: isSet(object.snapshotTime) ? fromJsonTimestamp(object.snapshotTime) : undefined,
    };
  },

  toJSON(message: SnapshotDefinition): unknown {
    const obj: any = {};
    if (message.baseTableReference !== undefined) {
      obj.baseTableReference = TableReference.toJSON(message.baseTableReference);
    }
    if (message.snapshotTime !== undefined) {
      obj.snapshotTime = message.snapshotTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<SnapshotDefinition>): SnapshotDefinition {
    return SnapshotDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SnapshotDefinition>): SnapshotDefinition {
    const message = createBaseSnapshotDefinition();
    message.baseTableReference = (object.baseTableReference !== undefined && object.baseTableReference !== null)
      ? TableReference.fromPartial(object.baseTableReference)
      : undefined;
    message.snapshotTime = object.snapshotTime ?? undefined;
    return message;
  },
};

function createBaseCloneDefinition(): CloneDefinition {
  return { baseTableReference: undefined, cloneTime: undefined };
}

export const CloneDefinition: MessageFns<CloneDefinition> = {
  encode(message: CloneDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseTableReference !== undefined) {
      TableReference.encode(message.baseTableReference, writer.uint32(10).fork()).join();
    }
    if (message.cloneTime !== undefined) {
      Timestamp.encode(toTimestamp(message.cloneTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloneDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloneDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseTableReference = TableReference.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cloneTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloneDefinition {
    return {
      baseTableReference: isSet(object.baseTableReference)
        ? TableReference.fromJSON(object.baseTableReference)
        : undefined,
      cloneTime: isSet(object.cloneTime) ? fromJsonTimestamp(object.cloneTime) : undefined,
    };
  },

  toJSON(message: CloneDefinition): unknown {
    const obj: any = {};
    if (message.baseTableReference !== undefined) {
      obj.baseTableReference = TableReference.toJSON(message.baseTableReference);
    }
    if (message.cloneTime !== undefined) {
      obj.cloneTime = message.cloneTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<CloneDefinition>): CloneDefinition {
    return CloneDefinition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloneDefinition>): CloneDefinition {
    const message = createBaseCloneDefinition();
    message.baseTableReference = (object.baseTableReference !== undefined && object.baseTableReference !== null)
      ? TableReference.fromPartial(object.baseTableReference)
      : undefined;
    message.cloneTime = object.cloneTime ?? undefined;
    return message;
  },
};

function createBaseStreamingbuffer(): Streamingbuffer {
  return { estimatedBytes: Long.UZERO, estimatedRows: Long.UZERO, oldestEntryTime: Long.UZERO };
}

export const Streamingbuffer: MessageFns<Streamingbuffer> = {
  encode(message: Streamingbuffer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.estimatedBytes.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.estimatedBytes.toString());
    }
    if (!message.estimatedRows.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.estimatedRows.toString());
    }
    if (!message.oldestEntryTime.equals(Long.UZERO)) {
      writer.uint32(25).fixed64(message.oldestEntryTime.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Streamingbuffer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamingbuffer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.estimatedBytes = Long.fromString(reader.uint64().toString(), true);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.estimatedRows = Long.fromString(reader.uint64().toString(), true);
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.oldestEntryTime = Long.fromString(reader.fixed64().toString(), true);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Streamingbuffer {
    return {
      estimatedBytes: isSet(object.estimatedBytes) ? Long.fromValue(object.estimatedBytes) : Long.UZERO,
      estimatedRows: isSet(object.estimatedRows) ? Long.fromValue(object.estimatedRows) : Long.UZERO,
      oldestEntryTime: isSet(object.oldestEntryTime) ? Long.fromValue(object.oldestEntryTime) : Long.UZERO,
    };
  },

  toJSON(message: Streamingbuffer): unknown {
    const obj: any = {};
    if (!message.estimatedBytes.equals(Long.UZERO)) {
      obj.estimatedBytes = (message.estimatedBytes || Long.UZERO).toString();
    }
    if (!message.estimatedRows.equals(Long.UZERO)) {
      obj.estimatedRows = (message.estimatedRows || Long.UZERO).toString();
    }
    if (!message.oldestEntryTime.equals(Long.UZERO)) {
      obj.oldestEntryTime = (message.oldestEntryTime || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Streamingbuffer>): Streamingbuffer {
    return Streamingbuffer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Streamingbuffer>): Streamingbuffer {
    const message = createBaseStreamingbuffer();
    message.estimatedBytes = (object.estimatedBytes !== undefined && object.estimatedBytes !== null)
      ? Long.fromValue(object.estimatedBytes)
      : Long.UZERO;
    message.estimatedRows = (object.estimatedRows !== undefined && object.estimatedRows !== null)
      ? Long.fromValue(object.estimatedRows)
      : Long.UZERO;
    message.oldestEntryTime = (object.oldestEntryTime !== undefined && object.oldestEntryTime !== null)
      ? Long.fromValue(object.oldestEntryTime)
      : Long.UZERO;
    return message;
  },
};

function createBaseTable(): Table {
  return {
    kind: "",
    etag: "",
    id: "",
    selfLink: "",
    tableReference: undefined,
    friendlyName: undefined,
    description: undefined,
    labels: {},
    schema: undefined,
    timePartitioning: undefined,
    rangePartitioning: undefined,
    clustering: undefined,
    requirePartitionFilter: undefined,
    partitionDefinition: undefined,
    numBytes: undefined,
    numPhysicalBytes: undefined,
    numLongTermBytes: undefined,
    numRows: undefined,
    creationTime: Long.ZERO,
    expirationTime: undefined,
    lastModifiedTime: Long.UZERO,
    type: "",
    view: undefined,
    materializedView: undefined,
    materializedViewStatus: undefined,
    externalDataConfiguration: undefined,
    biglakeConfiguration: undefined,
    location: "",
    streamingBuffer: undefined,
    encryptionConfiguration: undefined,
    snapshotDefinition: undefined,
    defaultCollation: undefined,
    defaultRoundingMode: 0,
    cloneDefinition: undefined,
    numTimeTravelPhysicalBytes: undefined,
    numTotalLogicalBytes: undefined,
    numActiveLogicalBytes: undefined,
    numLongTermLogicalBytes: undefined,
    numCurrentPhysicalBytes: undefined,
    numTotalPhysicalBytes: undefined,
    numActivePhysicalBytes: undefined,
    numLongTermPhysicalBytes: undefined,
    numPartitions: undefined,
    maxStaleness: "",
    restrictions: undefined,
    tableConstraints: undefined,
    resourceTags: {},
    tableReplicationInfo: undefined,
    replicas: [],
    externalCatalogTableOptions: undefined,
  };
}

export const Table: MessageFns<Table> = {
  encode(message: Table, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }
    if (message.selfLink !== "") {
      writer.uint32(34).string(message.selfLink);
    }
    if (message.tableReference !== undefined) {
      TableReference.encode(message.tableReference, writer.uint32(42).fork()).join();
    }
    if (message.friendlyName !== undefined) {
      StringValue.encode({ value: message.friendlyName! }, writer.uint32(50).fork()).join();
    }
    if (message.description !== undefined) {
      StringValue.encode({ value: message.description! }, writer.uint32(58).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Table_LabelsEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.schema !== undefined) {
      TableSchema.encode(message.schema, writer.uint32(74).fork()).join();
    }
    if (message.timePartitioning !== undefined) {
      TimePartitioning.encode(message.timePartitioning, writer.uint32(82).fork()).join();
    }
    if (message.rangePartitioning !== undefined) {
      RangePartitioning.encode(message.rangePartitioning, writer.uint32(218).fork()).join();
    }
    if (message.clustering !== undefined) {
      Clustering.encode(message.clustering, writer.uint32(186).fork()).join();
    }
    if (message.requirePartitionFilter !== undefined) {
      BoolValue.encode({ value: message.requirePartitionFilter! }, writer.uint32(226).fork()).join();
    }
    if (message.partitionDefinition !== undefined) {
      PartitioningDefinition.encode(message.partitionDefinition, writer.uint32(410).fork()).join();
    }
    if (message.numBytes !== undefined) {
      Int64Value.encode({ value: message.numBytes! }, writer.uint32(90).fork()).join();
    }
    if (message.numPhysicalBytes !== undefined) {
      Int64Value.encode({ value: message.numPhysicalBytes! }, writer.uint32(210).fork()).join();
    }
    if (message.numLongTermBytes !== undefined) {
      Int64Value.encode({ value: message.numLongTermBytes! }, writer.uint32(98).fork()).join();
    }
    if (message.numRows !== undefined) {
      UInt64Value.encode({ value: message.numRows! }, writer.uint32(106).fork()).join();
    }
    if (!message.creationTime.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.creationTime.toString());
    }
    if (message.expirationTime !== undefined) {
      Int64Value.encode({ value: message.expirationTime! }, writer.uint32(122).fork()).join();
    }
    if (!message.lastModifiedTime.equals(Long.UZERO)) {
      writer.uint32(129).fixed64(message.lastModifiedTime.toString());
    }
    if (message.type !== "") {
      writer.uint32(138).string(message.type);
    }
    if (message.view !== undefined) {
      ViewDefinition.encode(message.view, writer.uint32(146).fork()).join();
    }
    if (message.materializedView !== undefined) {
      MaterializedViewDefinition.encode(message.materializedView, writer.uint32(202).fork()).join();
    }
    if (message.materializedViewStatus !== undefined) {
      MaterializedViewStatus.encode(message.materializedViewStatus, writer.uint32(338).fork()).join();
    }
    if (message.externalDataConfiguration !== undefined) {
      ExternalDataConfiguration.encode(message.externalDataConfiguration, writer.uint32(154).fork()).join();
    }
    if (message.biglakeConfiguration !== undefined) {
      BigLakeConfiguration.encode(message.biglakeConfiguration, writer.uint32(362).fork()).join();
    }
    if (message.location !== "") {
      writer.uint32(162).string(message.location);
    }
    if (message.streamingBuffer !== undefined) {
      Streamingbuffer.encode(message.streamingBuffer, writer.uint32(170).fork()).join();
    }
    if (message.encryptionConfiguration !== undefined) {
      EncryptionConfiguration.encode(message.encryptionConfiguration, writer.uint32(178).fork()).join();
    }
    if (message.snapshotDefinition !== undefined) {
      SnapshotDefinition.encode(message.snapshotDefinition, writer.uint32(234).fork()).join();
    }
    if (message.defaultCollation !== undefined) {
      StringValue.encode({ value: message.defaultCollation! }, writer.uint32(242).fork()).join();
    }
    if (message.defaultRoundingMode !== 0) {
      writer.uint32(352).int32(message.defaultRoundingMode);
    }
    if (message.cloneDefinition !== undefined) {
      CloneDefinition.encode(message.cloneDefinition, writer.uint32(250).fork()).join();
    }
    if (message.numTimeTravelPhysicalBytes !== undefined) {
      Int64Value.encode({ value: message.numTimeTravelPhysicalBytes! }, writer.uint32(266).fork()).join();
    }
    if (message.numTotalLogicalBytes !== undefined) {
      Int64Value.encode({ value: message.numTotalLogicalBytes! }, writer.uint32(274).fork()).join();
    }
    if (message.numActiveLogicalBytes !== undefined) {
      Int64Value.encode({ value: message.numActiveLogicalBytes! }, writer.uint32(282).fork()).join();
    }
    if (message.numLongTermLogicalBytes !== undefined) {
      Int64Value.encode({ value: message.numLongTermLogicalBytes! }, writer.uint32(290).fork()).join();
    }
    if (message.numCurrentPhysicalBytes !== undefined) {
      Int64Value.encode({ value: message.numCurrentPhysicalBytes! }, writer.uint32(426).fork()).join();
    }
    if (message.numTotalPhysicalBytes !== undefined) {
      Int64Value.encode({ value: message.numTotalPhysicalBytes! }, writer.uint32(298).fork()).join();
    }
    if (message.numActivePhysicalBytes !== undefined) {
      Int64Value.encode({ value: message.numActivePhysicalBytes! }, writer.uint32(306).fork()).join();
    }
    if (message.numLongTermPhysicalBytes !== undefined) {
      Int64Value.encode({ value: message.numLongTermPhysicalBytes! }, writer.uint32(314).fork()).join();
    }
    if (message.numPartitions !== undefined) {
      Int64Value.encode({ value: message.numPartitions! }, writer.uint32(322).fork()).join();
    }
    if (message.maxStaleness !== "") {
      writer.uint32(330).string(message.maxStaleness);
    }
    if (message.restrictions !== undefined) {
      RestrictionConfig.encode(message.restrictions, writer.uint32(370).fork()).join();
    }
    if (message.tableConstraints !== undefined) {
      TableConstraints.encode(message.tableConstraints, writer.uint32(378).fork()).join();
    }
    Object.entries(message.resourceTags).forEach(([key, value]) => {
      Table_ResourceTagsEntry.encode({ key: key as any, value }, writer.uint32(386).fork()).join();
    });
    if (message.tableReplicationInfo !== undefined) {
      TableReplicationInfo.encode(message.tableReplicationInfo, writer.uint32(394).fork()).join();
    }
    for (const v of message.replicas) {
      TableReference.encode(v!, writer.uint32(402).fork()).join();
    }
    if (message.externalCatalogTableOptions !== undefined) {
      ExternalCatalogTableOptions.encode(message.externalCatalogTableOptions, writer.uint32(434).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Table {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.id = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.selfLink = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tableReference = TableReference.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.friendlyName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          const entry8 = Table_LabelsEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.labels[entry8.key] = entry8.value;
          }
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.schema = TableSchema.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.timePartitioning = TimePartitioning.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.rangePartitioning = RangePartitioning.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.clustering = Clustering.decode(reader, reader.uint32());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.requirePartitionFilter = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.partitionDefinition = PartitioningDefinition.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.numBytes = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.numPhysicalBytes = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.numLongTermBytes = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.numRows = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.creationTime = Long.fromString(reader.int64().toString());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.expirationTime = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 16:
          if (tag !== 129) {
            break;
          }

          message.lastModifiedTime = Long.fromString(reader.fixed64().toString(), true);
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.type = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.view = ViewDefinition.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.materializedView = MaterializedViewDefinition.decode(reader, reader.uint32());
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.materializedViewStatus = MaterializedViewStatus.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.externalDataConfiguration = ExternalDataConfiguration.decode(reader, reader.uint32());
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }

          message.biglakeConfiguration = BigLakeConfiguration.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.location = reader.string();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.streamingBuffer = Streamingbuffer.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.encryptionConfiguration = EncryptionConfiguration.decode(reader, reader.uint32());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.snapshotDefinition = SnapshotDefinition.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.defaultCollation = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 44:
          if (tag !== 352) {
            break;
          }

          message.defaultRoundingMode = reader.int32() as any;
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.cloneDefinition = CloneDefinition.decode(reader, reader.uint32());
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.numTimeTravelPhysicalBytes = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.numTotalLogicalBytes = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.numActiveLogicalBytes = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 36:
          if (tag !== 290) {
            break;
          }

          message.numLongTermLogicalBytes = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }

          message.numCurrentPhysicalBytes = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 37:
          if (tag !== 298) {
            break;
          }

          message.numTotalPhysicalBytes = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.numActivePhysicalBytes = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 39:
          if (tag !== 314) {
            break;
          }

          message.numLongTermPhysicalBytes = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.numPartitions = Int64Value.decode(reader, reader.uint32()).value;
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.maxStaleness = reader.string();
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.restrictions = RestrictionConfig.decode(reader, reader.uint32());
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.tableConstraints = TableConstraints.decode(reader, reader.uint32());
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          const entry48 = Table_ResourceTagsEntry.decode(reader, reader.uint32());
          if (entry48.value !== undefined) {
            message.resourceTags[entry48.key] = entry48.value;
          }
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }

          message.tableReplicationInfo = TableReplicationInfo.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.replicas.push(TableReference.decode(reader, reader.uint32()));
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }

          message.externalCatalogTableOptions = ExternalCatalogTableOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Table {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      selfLink: isSet(object.selfLink) ? globalThis.String(object.selfLink) : "",
      tableReference: isSet(object.tableReference) ? TableReference.fromJSON(object.tableReference) : undefined,
      friendlyName: isSet(object.friendlyName) ? String(object.friendlyName) : undefined,
      description: isSet(object.description) ? String(object.description) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      schema: isSet(object.schema) ? TableSchema.fromJSON(object.schema) : undefined,
      timePartitioning: isSet(object.timePartitioning) ? TimePartitioning.fromJSON(object.timePartitioning) : undefined,
      rangePartitioning: isSet(object.rangePartitioning)
        ? RangePartitioning.fromJSON(object.rangePartitioning)
        : undefined,
      clustering: isSet(object.clustering) ? Clustering.fromJSON(object.clustering) : undefined,
      requirePartitionFilter: isSet(object.requirePartitionFilter) ? Boolean(object.requirePartitionFilter) : undefined,
      partitionDefinition: isSet(object.partitionDefinition)
        ? PartitioningDefinition.fromJSON(object.partitionDefinition)
        : undefined,
      numBytes: isSet(object.numBytes) ? Long.fromValue(object.numBytes) : undefined,
      numPhysicalBytes: isSet(object.numPhysicalBytes) ? Long.fromValue(object.numPhysicalBytes) : undefined,
      numLongTermBytes: isSet(object.numLongTermBytes) ? Long.fromValue(object.numLongTermBytes) : undefined,
      numRows: isSet(object.numRows) ? Long.fromValue(object.numRows) : undefined,
      creationTime: isSet(object.creationTime) ? Long.fromValue(object.creationTime) : Long.ZERO,
      expirationTime: isSet(object.expirationTime) ? Long.fromValue(object.expirationTime) : undefined,
      lastModifiedTime: isSet(object.lastModifiedTime) ? Long.fromValue(object.lastModifiedTime) : Long.UZERO,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      view: isSet(object.view) ? ViewDefinition.fromJSON(object.view) : undefined,
      materializedView: isSet(object.materializedView)
        ? MaterializedViewDefinition.fromJSON(object.materializedView)
        : undefined,
      materializedViewStatus: isSet(object.materializedViewStatus)
        ? MaterializedViewStatus.fromJSON(object.materializedViewStatus)
        : undefined,
      externalDataConfiguration: isSet(object.externalDataConfiguration)
        ? ExternalDataConfiguration.fromJSON(object.externalDataConfiguration)
        : undefined,
      biglakeConfiguration: isSet(object.biglakeConfiguration)
        ? BigLakeConfiguration.fromJSON(object.biglakeConfiguration)
        : undefined,
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      streamingBuffer: isSet(object.streamingBuffer) ? Streamingbuffer.fromJSON(object.streamingBuffer) : undefined,
      encryptionConfiguration: isSet(object.encryptionConfiguration)
        ? EncryptionConfiguration.fromJSON(object.encryptionConfiguration)
        : undefined,
      snapshotDefinition: isSet(object.snapshotDefinition)
        ? SnapshotDefinition.fromJSON(object.snapshotDefinition)
        : undefined,
      defaultCollation: isSet(object.defaultCollation) ? String(object.defaultCollation) : undefined,
      defaultRoundingMode: isSet(object.defaultRoundingMode)
        ? tableFieldSchema_RoundingModeFromJSON(object.defaultRoundingMode)
        : 0,
      cloneDefinition: isSet(object.cloneDefinition) ? CloneDefinition.fromJSON(object.cloneDefinition) : undefined,
      numTimeTravelPhysicalBytes: isSet(object.numTimeTravelPhysicalBytes)
        ? Long.fromValue(object.numTimeTravelPhysicalBytes)
        : undefined,
      numTotalLogicalBytes: isSet(object.numTotalLogicalBytes)
        ? Long.fromValue(object.numTotalLogicalBytes)
        : undefined,
      numActiveLogicalBytes: isSet(object.numActiveLogicalBytes)
        ? Long.fromValue(object.numActiveLogicalBytes)
        : undefined,
      numLongTermLogicalBytes: isSet(object.numLongTermLogicalBytes)
        ? Long.fromValue(object.numLongTermLogicalBytes)
        : undefined,
      numCurrentPhysicalBytes: isSet(object.numCurrentPhysicalBytes)
        ? Long.fromValue(object.numCurrentPhysicalBytes)
        : undefined,
      numTotalPhysicalBytes: isSet(object.numTotalPhysicalBytes)
        ? Long.fromValue(object.numTotalPhysicalBytes)
        : undefined,
      numActivePhysicalBytes: isSet(object.numActivePhysicalBytes)
        ? Long.fromValue(object.numActivePhysicalBytes)
        : undefined,
      numLongTermPhysicalBytes: isSet(object.numLongTermPhysicalBytes)
        ? Long.fromValue(object.numLongTermPhysicalBytes)
        : undefined,
      numPartitions: isSet(object.numPartitions) ? Long.fromValue(object.numPartitions) : undefined,
      maxStaleness: isSet(object.maxStaleness) ? globalThis.String(object.maxStaleness) : "",
      restrictions: isSet(object.restrictions) ? RestrictionConfig.fromJSON(object.restrictions) : undefined,
      tableConstraints: isSet(object.tableConstraints) ? TableConstraints.fromJSON(object.tableConstraints) : undefined,
      resourceTags: isObject(object.resourceTags)
        ? Object.entries(object.resourceTags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      tableReplicationInfo: isSet(object.tableReplicationInfo)
        ? TableReplicationInfo.fromJSON(object.tableReplicationInfo)
        : undefined,
      replicas: globalThis.Array.isArray(object?.replicas)
        ? object.replicas.map((e: any) => TableReference.fromJSON(e))
        : [],
      externalCatalogTableOptions: isSet(object.externalCatalogTableOptions)
        ? ExternalCatalogTableOptions.fromJSON(object.externalCatalogTableOptions)
        : undefined,
    };
  },

  toJSON(message: Table): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.selfLink !== "") {
      obj.selfLink = message.selfLink;
    }
    if (message.tableReference !== undefined) {
      obj.tableReference = TableReference.toJSON(message.tableReference);
    }
    if (message.friendlyName !== undefined) {
      obj.friendlyName = message.friendlyName;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.schema !== undefined) {
      obj.schema = TableSchema.toJSON(message.schema);
    }
    if (message.timePartitioning !== undefined) {
      obj.timePartitioning = TimePartitioning.toJSON(message.timePartitioning);
    }
    if (message.rangePartitioning !== undefined) {
      obj.rangePartitioning = RangePartitioning.toJSON(message.rangePartitioning);
    }
    if (message.clustering !== undefined) {
      obj.clustering = Clustering.toJSON(message.clustering);
    }
    if (message.requirePartitionFilter !== undefined) {
      obj.requirePartitionFilter = message.requirePartitionFilter;
    }
    if (message.partitionDefinition !== undefined) {
      obj.partitionDefinition = PartitioningDefinition.toJSON(message.partitionDefinition);
    }
    if (message.numBytes !== undefined) {
      obj.numBytes = message.numBytes;
    }
    if (message.numPhysicalBytes !== undefined) {
      obj.numPhysicalBytes = message.numPhysicalBytes;
    }
    if (message.numLongTermBytes !== undefined) {
      obj.numLongTermBytes = message.numLongTermBytes;
    }
    if (message.numRows !== undefined) {
      obj.numRows = message.numRows;
    }
    if (!message.creationTime.equals(Long.ZERO)) {
      obj.creationTime = (message.creationTime || Long.ZERO).toString();
    }
    if (message.expirationTime !== undefined) {
      obj.expirationTime = message.expirationTime;
    }
    if (!message.lastModifiedTime.equals(Long.UZERO)) {
      obj.lastModifiedTime = (message.lastModifiedTime || Long.UZERO).toString();
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.view !== undefined) {
      obj.view = ViewDefinition.toJSON(message.view);
    }
    if (message.materializedView !== undefined) {
      obj.materializedView = MaterializedViewDefinition.toJSON(message.materializedView);
    }
    if (message.materializedViewStatus !== undefined) {
      obj.materializedViewStatus = MaterializedViewStatus.toJSON(message.materializedViewStatus);
    }
    if (message.externalDataConfiguration !== undefined) {
      obj.externalDataConfiguration = ExternalDataConfiguration.toJSON(message.externalDataConfiguration);
    }
    if (message.biglakeConfiguration !== undefined) {
      obj.biglakeConfiguration = BigLakeConfiguration.toJSON(message.biglakeConfiguration);
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.streamingBuffer !== undefined) {
      obj.streamingBuffer = Streamingbuffer.toJSON(message.streamingBuffer);
    }
    if (message.encryptionConfiguration !== undefined) {
      obj.encryptionConfiguration = EncryptionConfiguration.toJSON(message.encryptionConfiguration);
    }
    if (message.snapshotDefinition !== undefined) {
      obj.snapshotDefinition = SnapshotDefinition.toJSON(message.snapshotDefinition);
    }
    if (message.defaultCollation !== undefined) {
      obj.defaultCollation = message.defaultCollation;
    }
    if (message.defaultRoundingMode !== 0) {
      obj.defaultRoundingMode = tableFieldSchema_RoundingModeToJSON(message.defaultRoundingMode);
    }
    if (message.cloneDefinition !== undefined) {
      obj.cloneDefinition = CloneDefinition.toJSON(message.cloneDefinition);
    }
    if (message.numTimeTravelPhysicalBytes !== undefined) {
      obj.numTimeTravelPhysicalBytes = message.numTimeTravelPhysicalBytes;
    }
    if (message.numTotalLogicalBytes !== undefined) {
      obj.numTotalLogicalBytes = message.numTotalLogicalBytes;
    }
    if (message.numActiveLogicalBytes !== undefined) {
      obj.numActiveLogicalBytes = message.numActiveLogicalBytes;
    }
    if (message.numLongTermLogicalBytes !== undefined) {
      obj.numLongTermLogicalBytes = message.numLongTermLogicalBytes;
    }
    if (message.numCurrentPhysicalBytes !== undefined) {
      obj.numCurrentPhysicalBytes = message.numCurrentPhysicalBytes;
    }
    if (message.numTotalPhysicalBytes !== undefined) {
      obj.numTotalPhysicalBytes = message.numTotalPhysicalBytes;
    }
    if (message.numActivePhysicalBytes !== undefined) {
      obj.numActivePhysicalBytes = message.numActivePhysicalBytes;
    }
    if (message.numLongTermPhysicalBytes !== undefined) {
      obj.numLongTermPhysicalBytes = message.numLongTermPhysicalBytes;
    }
    if (message.numPartitions !== undefined) {
      obj.numPartitions = message.numPartitions;
    }
    if (message.maxStaleness !== "") {
      obj.maxStaleness = message.maxStaleness;
    }
    if (message.restrictions !== undefined) {
      obj.restrictions = RestrictionConfig.toJSON(message.restrictions);
    }
    if (message.tableConstraints !== undefined) {
      obj.tableConstraints = TableConstraints.toJSON(message.tableConstraints);
    }
    if (message.resourceTags) {
      const entries = Object.entries(message.resourceTags);
      if (entries.length > 0) {
        obj.resourceTags = {};
        entries.forEach(([k, v]) => {
          obj.resourceTags[k] = v;
        });
      }
    }
    if (message.tableReplicationInfo !== undefined) {
      obj.tableReplicationInfo = TableReplicationInfo.toJSON(message.tableReplicationInfo);
    }
    if (message.replicas?.length) {
      obj.replicas = message.replicas.map((e) => TableReference.toJSON(e));
    }
    if (message.externalCatalogTableOptions !== undefined) {
      obj.externalCatalogTableOptions = ExternalCatalogTableOptions.toJSON(message.externalCatalogTableOptions);
    }
    return obj;
  },

  create(base?: DeepPartial<Table>): Table {
    return Table.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Table>): Table {
    const message = createBaseTable();
    message.kind = object.kind ?? "";
    message.etag = object.etag ?? "";
    message.id = object.id ?? "";
    message.selfLink = object.selfLink ?? "";
    message.tableReference = (object.tableReference !== undefined && object.tableReference !== null)
      ? TableReference.fromPartial(object.tableReference)
      : undefined;
    message.friendlyName = object.friendlyName ?? undefined;
    message.description = object.description ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.schema = (object.schema !== undefined && object.schema !== null)
      ? TableSchema.fromPartial(object.schema)
      : undefined;
    message.timePartitioning = (object.timePartitioning !== undefined && object.timePartitioning !== null)
      ? TimePartitioning.fromPartial(object.timePartitioning)
      : undefined;
    message.rangePartitioning = (object.rangePartitioning !== undefined && object.rangePartitioning !== null)
      ? RangePartitioning.fromPartial(object.rangePartitioning)
      : undefined;
    message.clustering = (object.clustering !== undefined && object.clustering !== null)
      ? Clustering.fromPartial(object.clustering)
      : undefined;
    message.requirePartitionFilter = object.requirePartitionFilter ?? undefined;
    message.partitionDefinition = (object.partitionDefinition !== undefined && object.partitionDefinition !== null)
      ? PartitioningDefinition.fromPartial(object.partitionDefinition)
      : undefined;
    message.numBytes = (object.numBytes !== undefined && object.numBytes !== null)
      ? Long.fromValue(object.numBytes)
      : undefined;
    message.numPhysicalBytes = (object.numPhysicalBytes !== undefined && object.numPhysicalBytes !== null)
      ? Long.fromValue(object.numPhysicalBytes)
      : undefined;
    message.numLongTermBytes = (object.numLongTermBytes !== undefined && object.numLongTermBytes !== null)
      ? Long.fromValue(object.numLongTermBytes)
      : undefined;
    message.numRows = (object.numRows !== undefined && object.numRows !== null)
      ? Long.fromValue(object.numRows)
      : undefined;
    message.creationTime = (object.creationTime !== undefined && object.creationTime !== null)
      ? Long.fromValue(object.creationTime)
      : Long.ZERO;
    message.expirationTime = (object.expirationTime !== undefined && object.expirationTime !== null)
      ? Long.fromValue(object.expirationTime)
      : undefined;
    message.lastModifiedTime = (object.lastModifiedTime !== undefined && object.lastModifiedTime !== null)
      ? Long.fromValue(object.lastModifiedTime)
      : Long.UZERO;
    message.type = object.type ?? "";
    message.view = (object.view !== undefined && object.view !== null)
      ? ViewDefinition.fromPartial(object.view)
      : undefined;
    message.materializedView = (object.materializedView !== undefined && object.materializedView !== null)
      ? MaterializedViewDefinition.fromPartial(object.materializedView)
      : undefined;
    message.materializedViewStatus =
      (object.materializedViewStatus !== undefined && object.materializedViewStatus !== null)
        ? MaterializedViewStatus.fromPartial(object.materializedViewStatus)
        : undefined;
    message.externalDataConfiguration =
      (object.externalDataConfiguration !== undefined && object.externalDataConfiguration !== null)
        ? ExternalDataConfiguration.fromPartial(object.externalDataConfiguration)
        : undefined;
    message.biglakeConfiguration = (object.biglakeConfiguration !== undefined && object.biglakeConfiguration !== null)
      ? BigLakeConfiguration.fromPartial(object.biglakeConfiguration)
      : undefined;
    message.location = object.location ?? "";
    message.streamingBuffer = (object.streamingBuffer !== undefined && object.streamingBuffer !== null)
      ? Streamingbuffer.fromPartial(object.streamingBuffer)
      : undefined;
    message.encryptionConfiguration =
      (object.encryptionConfiguration !== undefined && object.encryptionConfiguration !== null)
        ? EncryptionConfiguration.fromPartial(object.encryptionConfiguration)
        : undefined;
    message.snapshotDefinition = (object.snapshotDefinition !== undefined && object.snapshotDefinition !== null)
      ? SnapshotDefinition.fromPartial(object.snapshotDefinition)
      : undefined;
    message.defaultCollation = object.defaultCollation ?? undefined;
    message.defaultRoundingMode = object.defaultRoundingMode ?? 0;
    message.cloneDefinition = (object.cloneDefinition !== undefined && object.cloneDefinition !== null)
      ? CloneDefinition.fromPartial(object.cloneDefinition)
      : undefined;
    message.numTimeTravelPhysicalBytes =
      (object.numTimeTravelPhysicalBytes !== undefined && object.numTimeTravelPhysicalBytes !== null)
        ? Long.fromValue(object.numTimeTravelPhysicalBytes)
        : undefined;
    message.numTotalLogicalBytes = (object.numTotalLogicalBytes !== undefined && object.numTotalLogicalBytes !== null)
      ? Long.fromValue(object.numTotalLogicalBytes)
      : undefined;
    message.numActiveLogicalBytes =
      (object.numActiveLogicalBytes !== undefined && object.numActiveLogicalBytes !== null)
        ? Long.fromValue(object.numActiveLogicalBytes)
        : undefined;
    message.numLongTermLogicalBytes =
      (object.numLongTermLogicalBytes !== undefined && object.numLongTermLogicalBytes !== null)
        ? Long.fromValue(object.numLongTermLogicalBytes)
        : undefined;
    message.numCurrentPhysicalBytes =
      (object.numCurrentPhysicalBytes !== undefined && object.numCurrentPhysicalBytes !== null)
        ? Long.fromValue(object.numCurrentPhysicalBytes)
        : undefined;
    message.numTotalPhysicalBytes =
      (object.numTotalPhysicalBytes !== undefined && object.numTotalPhysicalBytes !== null)
        ? Long.fromValue(object.numTotalPhysicalBytes)
        : undefined;
    message.numActivePhysicalBytes =
      (object.numActivePhysicalBytes !== undefined && object.numActivePhysicalBytes !== null)
        ? Long.fromValue(object.numActivePhysicalBytes)
        : undefined;
    message.numLongTermPhysicalBytes =
      (object.numLongTermPhysicalBytes !== undefined && object.numLongTermPhysicalBytes !== null)
        ? Long.fromValue(object.numLongTermPhysicalBytes)
        : undefined;
    message.numPartitions = (object.numPartitions !== undefined && object.numPartitions !== null)
      ? Long.fromValue(object.numPartitions)
      : undefined;
    message.maxStaleness = object.maxStaleness ?? "";
    message.restrictions = (object.restrictions !== undefined && object.restrictions !== null)
      ? RestrictionConfig.fromPartial(object.restrictions)
      : undefined;
    message.tableConstraints = (object.tableConstraints !== undefined && object.tableConstraints !== null)
      ? TableConstraints.fromPartial(object.tableConstraints)
      : undefined;
    message.resourceTags = Object.entries(object.resourceTags ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.tableReplicationInfo = (object.tableReplicationInfo !== undefined && object.tableReplicationInfo !== null)
      ? TableReplicationInfo.fromPartial(object.tableReplicationInfo)
      : undefined;
    message.replicas = object.replicas?.map((e) => TableReference.fromPartial(e)) || [];
    message.externalCatalogTableOptions =
      (object.externalCatalogTableOptions !== undefined && object.externalCatalogTableOptions !== null)
        ? ExternalCatalogTableOptions.fromPartial(object.externalCatalogTableOptions)
        : undefined;
    return message;
  },
};

function createBaseTable_LabelsEntry(): Table_LabelsEntry {
  return { key: "", value: "" };
}

export const Table_LabelsEntry: MessageFns<Table_LabelsEntry> = {
  encode(message: Table_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Table_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTable_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Table_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Table_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Table_LabelsEntry>): Table_LabelsEntry {
    return Table_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Table_LabelsEntry>): Table_LabelsEntry {
    const message = createBaseTable_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTable_ResourceTagsEntry(): Table_ResourceTagsEntry {
  return { key: "", value: "" };
}

export const Table_ResourceTagsEntry: MessageFns<Table_ResourceTagsEntry> = {
  encode(message: Table_ResourceTagsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Table_ResourceTagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTable_ResourceTagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Table_ResourceTagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Table_ResourceTagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Table_ResourceTagsEntry>): Table_ResourceTagsEntry {
    return Table_ResourceTagsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Table_ResourceTagsEntry>): Table_ResourceTagsEntry {
    const message = createBaseTable_ResourceTagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetTableRequest(): GetTableRequest {
  return { projectId: "", datasetId: "", tableId: "", selectedFields: "", view: 0 };
}

export const GetTableRequest: MessageFns<GetTableRequest> = {
  encode(message: GetTableRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.tableId !== "") {
      writer.uint32(26).string(message.tableId);
    }
    if (message.selectedFields !== "") {
      writer.uint32(34).string(message.selectedFields);
    }
    if (message.view !== 0) {
      writer.uint32(40).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTableRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tableId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.selectedFields = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTableRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      tableId: isSet(object.tableId) ? globalThis.String(object.tableId) : "",
      selectedFields: isSet(object.selectedFields) ? globalThis.String(object.selectedFields) : "",
      view: isSet(object.view) ? getTableRequest_TableMetadataViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetTableRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.tableId !== "") {
      obj.tableId = message.tableId;
    }
    if (message.selectedFields !== "") {
      obj.selectedFields = message.selectedFields;
    }
    if (message.view !== 0) {
      obj.view = getTableRequest_TableMetadataViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetTableRequest>): GetTableRequest {
    return GetTableRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTableRequest>): GetTableRequest {
    const message = createBaseGetTableRequest();
    message.projectId = object.projectId ?? "";
    message.datasetId = object.datasetId ?? "";
    message.tableId = object.tableId ?? "";
    message.selectedFields = object.selectedFields ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseInsertTableRequest(): InsertTableRequest {
  return { projectId: "", datasetId: "", table: undefined };
}

export const InsertTableRequest: MessageFns<InsertTableRequest> = {
  encode(message: InsertTableRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.table !== undefined) {
      Table.encode(message.table, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertTableRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertTableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.table = Table.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InsertTableRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      table: isSet(object.table) ? Table.fromJSON(object.table) : undefined,
    };
  },

  toJSON(message: InsertTableRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.table !== undefined) {
      obj.table = Table.toJSON(message.table);
    }
    return obj;
  },

  create(base?: DeepPartial<InsertTableRequest>): InsertTableRequest {
    return InsertTableRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsertTableRequest>): InsertTableRequest {
    const message = createBaseInsertTableRequest();
    message.projectId = object.projectId ?? "";
    message.datasetId = object.datasetId ?? "";
    message.table = (object.table !== undefined && object.table !== null) ? Table.fromPartial(object.table) : undefined;
    return message;
  },
};

function createBaseUpdateOrPatchTableRequest(): UpdateOrPatchTableRequest {
  return { projectId: "", datasetId: "", tableId: "", table: undefined, autodetectSchema: false };
}

export const UpdateOrPatchTableRequest: MessageFns<UpdateOrPatchTableRequest> = {
  encode(message: UpdateOrPatchTableRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.tableId !== "") {
      writer.uint32(26).string(message.tableId);
    }
    if (message.table !== undefined) {
      Table.encode(message.table, writer.uint32(34).fork()).join();
    }
    if (message.autodetectSchema !== false) {
      writer.uint32(40).bool(message.autodetectSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateOrPatchTableRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrPatchTableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tableId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.table = Table.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.autodetectSchema = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateOrPatchTableRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      tableId: isSet(object.tableId) ? globalThis.String(object.tableId) : "",
      table: isSet(object.table) ? Table.fromJSON(object.table) : undefined,
      autodetectSchema: isSet(object.autodetectSchema) ? globalThis.Boolean(object.autodetectSchema) : false,
    };
  },

  toJSON(message: UpdateOrPatchTableRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.tableId !== "") {
      obj.tableId = message.tableId;
    }
    if (message.table !== undefined) {
      obj.table = Table.toJSON(message.table);
    }
    if (message.autodetectSchema !== false) {
      obj.autodetectSchema = message.autodetectSchema;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateOrPatchTableRequest>): UpdateOrPatchTableRequest {
    return UpdateOrPatchTableRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateOrPatchTableRequest>): UpdateOrPatchTableRequest {
    const message = createBaseUpdateOrPatchTableRequest();
    message.projectId = object.projectId ?? "";
    message.datasetId = object.datasetId ?? "";
    message.tableId = object.tableId ?? "";
    message.table = (object.table !== undefined && object.table !== null) ? Table.fromPartial(object.table) : undefined;
    message.autodetectSchema = object.autodetectSchema ?? false;
    return message;
  },
};

function createBaseDeleteTableRequest(): DeleteTableRequest {
  return { projectId: "", datasetId: "", tableId: "" };
}

export const DeleteTableRequest: MessageFns<DeleteTableRequest> = {
  encode(message: DeleteTableRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.tableId !== "") {
      writer.uint32(26).string(message.tableId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTableRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTableRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tableId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTableRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      tableId: isSet(object.tableId) ? globalThis.String(object.tableId) : "",
    };
  },

  toJSON(message: DeleteTableRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.tableId !== "") {
      obj.tableId = message.tableId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteTableRequest>): DeleteTableRequest {
    return DeleteTableRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteTableRequest>): DeleteTableRequest {
    const message = createBaseDeleteTableRequest();
    message.projectId = object.projectId ?? "";
    message.datasetId = object.datasetId ?? "";
    message.tableId = object.tableId ?? "";
    return message;
  },
};

function createBaseListTablesRequest(): ListTablesRequest {
  return { projectId: "", datasetId: "", maxResults: undefined, pageToken: "" };
}

export const ListTablesRequest: MessageFns<ListTablesRequest> = {
  encode(message: ListTablesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.datasetId !== "") {
      writer.uint32(18).string(message.datasetId);
    }
    if (message.maxResults !== undefined) {
      UInt32Value.encode({ value: message.maxResults! }, writer.uint32(26).fork()).join();
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTablesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTablesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.datasetId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.maxResults = UInt32Value.decode(reader, reader.uint32()).value;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTablesRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      datasetId: isSet(object.datasetId) ? globalThis.String(object.datasetId) : "",
      maxResults: isSet(object.maxResults) ? Number(object.maxResults) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
    };
  },

  toJSON(message: ListTablesRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.datasetId !== "") {
      obj.datasetId = message.datasetId;
    }
    if (message.maxResults !== undefined) {
      obj.maxResults = message.maxResults;
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListTablesRequest>): ListTablesRequest {
    return ListTablesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListTablesRequest>): ListTablesRequest {
    const message = createBaseListTablesRequest();
    message.projectId = object.projectId ?? "";
    message.datasetId = object.datasetId ?? "";
    message.maxResults = object.maxResults ?? undefined;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListFormatView(): ListFormatView {
  return { useLegacySql: undefined, privacyPolicy: undefined };
}

export const ListFormatView: MessageFns<ListFormatView> = {
  encode(message: ListFormatView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useLegacySql !== undefined) {
      BoolValue.encode({ value: message.useLegacySql! }, writer.uint32(10).fork()).join();
    }
    if (message.privacyPolicy !== undefined) {
      PrivacyPolicy.encode(message.privacyPolicy, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFormatView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFormatView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.useLegacySql = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.privacyPolicy = PrivacyPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFormatView {
    return {
      useLegacySql: isSet(object.useLegacySql) ? Boolean(object.useLegacySql) : undefined,
      privacyPolicy: isSet(object.privacyPolicy) ? PrivacyPolicy.fromJSON(object.privacyPolicy) : undefined,
    };
  },

  toJSON(message: ListFormatView): unknown {
    const obj: any = {};
    if (message.useLegacySql !== undefined) {
      obj.useLegacySql = message.useLegacySql;
    }
    if (message.privacyPolicy !== undefined) {
      obj.privacyPolicy = PrivacyPolicy.toJSON(message.privacyPolicy);
    }
    return obj;
  },

  create(base?: DeepPartial<ListFormatView>): ListFormatView {
    return ListFormatView.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFormatView>): ListFormatView {
    const message = createBaseListFormatView();
    message.useLegacySql = object.useLegacySql ?? undefined;
    message.privacyPolicy = (object.privacyPolicy !== undefined && object.privacyPolicy !== null)
      ? PrivacyPolicy.fromPartial(object.privacyPolicy)
      : undefined;
    return message;
  },
};

function createBaseListFormatTable(): ListFormatTable {
  return {
    kind: "",
    id: "",
    tableReference: undefined,
    friendlyName: undefined,
    type: "",
    timePartitioning: undefined,
    rangePartitioning: undefined,
    clustering: undefined,
    labels: {},
    view: undefined,
    creationTime: Long.ZERO,
    expirationTime: Long.ZERO,
    requirePartitionFilter: undefined,
  };
}

export const ListFormatTable: MessageFns<ListFormatTable> = {
  encode(message: ListFormatTable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.tableReference !== undefined) {
      TableReference.encode(message.tableReference, writer.uint32(26).fork()).join();
    }
    if (message.friendlyName !== undefined) {
      StringValue.encode({ value: message.friendlyName! }, writer.uint32(34).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(42).string(message.type);
    }
    if (message.timePartitioning !== undefined) {
      TimePartitioning.encode(message.timePartitioning, writer.uint32(50).fork()).join();
    }
    if (message.rangePartitioning !== undefined) {
      RangePartitioning.encode(message.rangePartitioning, writer.uint32(98).fork()).join();
    }
    if (message.clustering !== undefined) {
      Clustering.encode(message.clustering, writer.uint32(90).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ListFormatTable_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.view !== undefined) {
      ListFormatView.encode(message.view, writer.uint32(66).fork()).join();
    }
    if (!message.creationTime.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.creationTime.toString());
    }
    if (!message.expirationTime.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.expirationTime.toString());
    }
    if (message.requirePartitionFilter !== undefined) {
      BoolValue.encode({ value: message.requirePartitionFilter! }, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFormatTable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFormatTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tableReference = TableReference.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.friendlyName = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.type = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timePartitioning = TimePartitioning.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.rangePartitioning = RangePartitioning.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.clustering = Clustering.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = ListFormatTable_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.view = ListFormatView.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.creationTime = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.expirationTime = Long.fromString(reader.int64().toString());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.requirePartitionFilter = BoolValue.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFormatTable {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      tableReference: isSet(object.tableReference) ? TableReference.fromJSON(object.tableReference) : undefined,
      friendlyName: isSet(object.friendlyName) ? String(object.friendlyName) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      timePartitioning: isSet(object.timePartitioning) ? TimePartitioning.fromJSON(object.timePartitioning) : undefined,
      rangePartitioning: isSet(object.rangePartitioning)
        ? RangePartitioning.fromJSON(object.rangePartitioning)
        : undefined,
      clustering: isSet(object.clustering) ? Clustering.fromJSON(object.clustering) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      view: isSet(object.view) ? ListFormatView.fromJSON(object.view) : undefined,
      creationTime: isSet(object.creationTime) ? Long.fromValue(object.creationTime) : Long.ZERO,
      expirationTime: isSet(object.expirationTime) ? Long.fromValue(object.expirationTime) : Long.ZERO,
      requirePartitionFilter: isSet(object.requirePartitionFilter) ? Boolean(object.requirePartitionFilter) : undefined,
    };
  },

  toJSON(message: ListFormatTable): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.tableReference !== undefined) {
      obj.tableReference = TableReference.toJSON(message.tableReference);
    }
    if (message.friendlyName !== undefined) {
      obj.friendlyName = message.friendlyName;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.timePartitioning !== undefined) {
      obj.timePartitioning = TimePartitioning.toJSON(message.timePartitioning);
    }
    if (message.rangePartitioning !== undefined) {
      obj.rangePartitioning = RangePartitioning.toJSON(message.rangePartitioning);
    }
    if (message.clustering !== undefined) {
      obj.clustering = Clustering.toJSON(message.clustering);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.view !== undefined) {
      obj.view = ListFormatView.toJSON(message.view);
    }
    if (!message.creationTime.equals(Long.ZERO)) {
      obj.creationTime = (message.creationTime || Long.ZERO).toString();
    }
    if (!message.expirationTime.equals(Long.ZERO)) {
      obj.expirationTime = (message.expirationTime || Long.ZERO).toString();
    }
    if (message.requirePartitionFilter !== undefined) {
      obj.requirePartitionFilter = message.requirePartitionFilter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFormatTable>): ListFormatTable {
    return ListFormatTable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFormatTable>): ListFormatTable {
    const message = createBaseListFormatTable();
    message.kind = object.kind ?? "";
    message.id = object.id ?? "";
    message.tableReference = (object.tableReference !== undefined && object.tableReference !== null)
      ? TableReference.fromPartial(object.tableReference)
      : undefined;
    message.friendlyName = object.friendlyName ?? undefined;
    message.type = object.type ?? "";
    message.timePartitioning = (object.timePartitioning !== undefined && object.timePartitioning !== null)
      ? TimePartitioning.fromPartial(object.timePartitioning)
      : undefined;
    message.rangePartitioning = (object.rangePartitioning !== undefined && object.rangePartitioning !== null)
      ? RangePartitioning.fromPartial(object.rangePartitioning)
      : undefined;
    message.clustering = (object.clustering !== undefined && object.clustering !== null)
      ? Clustering.fromPartial(object.clustering)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.view = (object.view !== undefined && object.view !== null)
      ? ListFormatView.fromPartial(object.view)
      : undefined;
    message.creationTime = (object.creationTime !== undefined && object.creationTime !== null)
      ? Long.fromValue(object.creationTime)
      : Long.ZERO;
    message.expirationTime = (object.expirationTime !== undefined && object.expirationTime !== null)
      ? Long.fromValue(object.expirationTime)
      : Long.ZERO;
    message.requirePartitionFilter = object.requirePartitionFilter ?? undefined;
    return message;
  },
};

function createBaseListFormatTable_LabelsEntry(): ListFormatTable_LabelsEntry {
  return { key: "", value: "" };
}

export const ListFormatTable_LabelsEntry: MessageFns<ListFormatTable_LabelsEntry> = {
  encode(message: ListFormatTable_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListFormatTable_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListFormatTable_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListFormatTable_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ListFormatTable_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ListFormatTable_LabelsEntry>): ListFormatTable_LabelsEntry {
    return ListFormatTable_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListFormatTable_LabelsEntry>): ListFormatTable_LabelsEntry {
    const message = createBaseListFormatTable_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTableList(): TableList {
  return { kind: "", etag: "", nextPageToken: "", tables: [], totalItems: undefined };
}

export const TableList: MessageFns<TableList> = {
  encode(message: TableList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kind !== "") {
      writer.uint32(10).string(message.kind);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    for (const v of message.tables) {
      ListFormatTable.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.totalItems !== undefined) {
      Int32Value.encode({ value: message.totalItems! }, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.tables.push(ListFormatTable.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.totalItems = Int32Value.decode(reader, reader.uint32()).value;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableList {
    return {
      kind: isSet(object.kind) ? globalThis.String(object.kind) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      tables: globalThis.Array.isArray(object?.tables)
        ? object.tables.map((e: any) => ListFormatTable.fromJSON(e))
        : [],
      totalItems: isSet(object.totalItems) ? Number(object.totalItems) : undefined,
    };
  },

  toJSON(message: TableList): unknown {
    const obj: any = {};
    if (message.kind !== "") {
      obj.kind = message.kind;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.tables?.length) {
      obj.tables = message.tables.map((e) => ListFormatTable.toJSON(e));
    }
    if (message.totalItems !== undefined) {
      obj.totalItems = message.totalItems;
    }
    return obj;
  },

  create(base?: DeepPartial<TableList>): TableList {
    return TableList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableList>): TableList {
    const message = createBaseTableList();
    message.kind = object.kind ?? "";
    message.etag = object.etag ?? "";
    message.nextPageToken = object.nextPageToken ?? "";
    message.tables = object.tables?.map((e) => ListFormatTable.fromPartial(e)) || [];
    message.totalItems = object.totalItems ?? undefined;
    return message;
  },
};

/**
 * This is an experimental RPC service definition for the BigQuery
 * Table Service.
 *
 * It should not be relied on for production use cases at this time.
 */
export type TableServiceDefinition = typeof TableServiceDefinition;
export const TableServiceDefinition = {
  name: "TableService",
  fullName: "google.cloud.bigquery.v2.TableService",
  methods: {
    /**
     * Gets the specified table resource by table ID.
     * This method does not return the data in the table, it only returns the
     * table resource, which describes the structure of this table.
     */
    getTable: {
      name: "GetTable",
      requestType: GetTableRequest,
      requestStream: false,
      responseType: Table,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              82,
              18,
              80,
              47,
              98,
              105,
              103,
              113,
              117,
              101,
              114,
              121,
              47,
              118,
              50,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              123,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              123,
              116,
              97,
              98,
              108,
              101,
              95,
              105,
              100,
              61,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates a new, empty table in the dataset. */
    insertTable: {
      name: "InsertTable",
      requestType: InsertTableRequest,
      requestStream: false,
      responseType: Table,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              76,
              58,
              5,
              116,
              97,
              98,
              108,
              101,
              34,
              67,
              47,
              98,
              105,
              103,
              113,
              117,
              101,
              114,
              121,
              47,
              118,
              50,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              123,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              116,
              97,
              98,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates information in an existing table. The update method replaces the
     * entire table resource, whereas the patch method only replaces fields that
     * are provided in the submitted table resource.
     * This method supports RFC5789 patch semantics.
     */
    patchTable: {
      name: "PatchTable",
      requestType: UpdateOrPatchTableRequest,
      requestStream: false,
      responseType: Table,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              89,
              58,
              5,
              116,
              97,
              98,
              108,
              101,
              50,
              80,
              47,
              98,
              105,
              103,
              113,
              117,
              101,
              114,
              121,
              47,
              118,
              50,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              123,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              123,
              116,
              97,
              98,
              108,
              101,
              95,
              105,
              100,
              61,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates information in an existing table. The update method replaces the
     * entire Table resource, whereas the patch method only replaces fields that
     * are provided in the submitted Table resource.
     */
    updateTable: {
      name: "UpdateTable",
      requestType: UpdateOrPatchTableRequest,
      requestStream: false,
      responseType: Table,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              89,
              58,
              5,
              116,
              97,
              98,
              108,
              101,
              26,
              80,
              47,
              98,
              105,
              103,
              113,
              117,
              101,
              114,
              121,
              47,
              118,
              50,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              123,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              123,
              116,
              97,
              98,
              108,
              101,
              95,
              105,
              100,
              61,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes the table specified by tableId from the dataset.
     * If the table contains data, all the data will be deleted.
     */
    deleteTable: {
      name: "DeleteTable",
      requestType: DeleteTableRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              82,
              42,
              80,
              47,
              98,
              105,
              103,
              113,
              117,
              101,
              114,
              121,
              47,
              118,
              50,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              123,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              116,
              97,
              98,
              108,
              101,
              115,
              47,
              123,
              116,
              97,
              98,
              108,
              101,
              95,
              105,
              100,
              61,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Lists all tables in the specified dataset. Requires the READER dataset
     * role.
     */
    listTables: {
      name: "ListTables",
      requestType: ListTablesRequest,
      requestStream: false,
      responseType: TableList,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              69,
              18,
              67,
              47,
              98,
              105,
              103,
              113,
              117,
              101,
              114,
              121,
              47,
              118,
              50,
              47,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              123,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              115,
              47,
              123,
              100,
              97,
              116,
              97,
              115,
              101,
              116,
              95,
              105,
              100,
              61,
              42,
              125,
              47,
              116,
              97,
              98,
              108,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TableServiceImplementation<CallContextExt = {}> {
  /**
   * Gets the specified table resource by table ID.
   * This method does not return the data in the table, it only returns the
   * table resource, which describes the structure of this table.
   */
  getTable(request: GetTableRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Table>>;
  /** Creates a new, empty table in the dataset. */
  insertTable(request: InsertTableRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Table>>;
  /**
   * Updates information in an existing table. The update method replaces the
   * entire table resource, whereas the patch method only replaces fields that
   * are provided in the submitted table resource.
   * This method supports RFC5789 patch semantics.
   */
  patchTable(request: UpdateOrPatchTableRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Table>>;
  /**
   * Updates information in an existing table. The update method replaces the
   * entire Table resource, whereas the patch method only replaces fields that
   * are provided in the submitted Table resource.
   */
  updateTable(request: UpdateOrPatchTableRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Table>>;
  /**
   * Deletes the table specified by tableId from the dataset.
   * If the table contains data, all the data will be deleted.
   */
  deleteTable(request: DeleteTableRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /**
   * Lists all tables in the specified dataset. Requires the READER dataset
   * role.
   */
  listTables(request: ListTablesRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TableList>>;
}

export interface TableServiceClient<CallOptionsExt = {}> {
  /**
   * Gets the specified table resource by table ID.
   * This method does not return the data in the table, it only returns the
   * table resource, which describes the structure of this table.
   */
  getTable(request: DeepPartial<GetTableRequest>, options?: CallOptions & CallOptionsExt): Promise<Table>;
  /** Creates a new, empty table in the dataset. */
  insertTable(request: DeepPartial<InsertTableRequest>, options?: CallOptions & CallOptionsExt): Promise<Table>;
  /**
   * Updates information in an existing table. The update method replaces the
   * entire table resource, whereas the patch method only replaces fields that
   * are provided in the submitted table resource.
   * This method supports RFC5789 patch semantics.
   */
  patchTable(request: DeepPartial<UpdateOrPatchTableRequest>, options?: CallOptions & CallOptionsExt): Promise<Table>;
  /**
   * Updates information in an existing table. The update method replaces the
   * entire Table resource, whereas the patch method only replaces fields that
   * are provided in the submitted Table resource.
   */
  updateTable(request: DeepPartial<UpdateOrPatchTableRequest>, options?: CallOptions & CallOptionsExt): Promise<Table>;
  /**
   * Deletes the table specified by tableId from the dataset.
   * If the table contains data, all the data will be deleted.
   */
  deleteTable(request: DeepPartial<DeleteTableRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /**
   * Lists all tables in the specified dataset. Requires the READER dataset
   * role.
   */
  listTables(request: DeepPartial<ListTablesRequest>, options?: CallOptions & CallOptionsExt): Promise<TableList>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
