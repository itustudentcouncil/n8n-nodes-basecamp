// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/v2/table_constraints.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { TableReference } from "./table_reference.js";

export const protobufPackage = "google.cloud.bigquery.v2";

/** Represents the primary key constraint on a table's columns. */
export interface PrimaryKey {
  /** Required. The columns that are composed of the primary key constraint. */
  columns: string[];
}

/** The pair of the foreign key column and primary key column. */
export interface ColumnReference {
  /** Required. The column that composes the foreign key. */
  referencingColumn: string;
  /**
   * Required. The column in the primary key that are referenced by the
   * referencing_column.
   */
  referencedColumn: string;
}

/** Represents a foreign key constraint on a table's columns. */
export interface ForeignKey {
  /** Optional. Set only if the foreign key constraint is named. */
  name: string;
  /**
   * Required. The table that holds the primary key and is referenced by this
   * foreign key.
   */
  referencedTable:
    | TableReference
    | undefined;
  /** Required. The columns that compose the foreign key. */
  columnReferences: ColumnReference[];
}

/** The TableConstraints defines the primary key and foreign key. */
export interface TableConstraints {
  /**
   * Optional. Represents a primary key constraint on a table's columns.
   * Present only if the table has a primary key.
   * The primary key is not enforced.
   */
  primaryKey:
    | PrimaryKey
    | undefined;
  /**
   * Optional. Present only if the table has a foreign key.
   * The foreign key is not enforced.
   */
  foreignKeys: ForeignKey[];
}

function createBasePrimaryKey(): PrimaryKey {
  return { columns: [] };
}

export const PrimaryKey: MessageFns<PrimaryKey> = {
  encode(message: PrimaryKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.columns) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrimaryKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrimaryKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.columns.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrimaryKey {
    return {
      columns: globalThis.Array.isArray(object?.columns) ? object.columns.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: PrimaryKey): unknown {
    const obj: any = {};
    if (message.columns?.length) {
      obj.columns = message.columns;
    }
    return obj;
  },

  create(base?: DeepPartial<PrimaryKey>): PrimaryKey {
    return PrimaryKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrimaryKey>): PrimaryKey {
    const message = createBasePrimaryKey();
    message.columns = object.columns?.map((e) => e) || [];
    return message;
  },
};

function createBaseColumnReference(): ColumnReference {
  return { referencingColumn: "", referencedColumn: "" };
}

export const ColumnReference: MessageFns<ColumnReference> = {
  encode(message: ColumnReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referencingColumn !== "") {
      writer.uint32(10).string(message.referencingColumn);
    }
    if (message.referencedColumn !== "") {
      writer.uint32(18).string(message.referencedColumn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColumnReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColumnReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referencingColumn = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.referencedColumn = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColumnReference {
    return {
      referencingColumn: isSet(object.referencingColumn) ? globalThis.String(object.referencingColumn) : "",
      referencedColumn: isSet(object.referencedColumn) ? globalThis.String(object.referencedColumn) : "",
    };
  },

  toJSON(message: ColumnReference): unknown {
    const obj: any = {};
    if (message.referencingColumn !== "") {
      obj.referencingColumn = message.referencingColumn;
    }
    if (message.referencedColumn !== "") {
      obj.referencedColumn = message.referencedColumn;
    }
    return obj;
  },

  create(base?: DeepPartial<ColumnReference>): ColumnReference {
    return ColumnReference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ColumnReference>): ColumnReference {
    const message = createBaseColumnReference();
    message.referencingColumn = object.referencingColumn ?? "";
    message.referencedColumn = object.referencedColumn ?? "";
    return message;
  },
};

function createBaseForeignKey(): ForeignKey {
  return { name: "", referencedTable: undefined, columnReferences: [] };
}

export const ForeignKey: MessageFns<ForeignKey> = {
  encode(message: ForeignKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.referencedTable !== undefined) {
      TableReference.encode(message.referencedTable, writer.uint32(18).fork()).join();
    }
    for (const v of message.columnReferences) {
      ColumnReference.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForeignKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForeignKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.referencedTable = TableReference.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.columnReferences.push(ColumnReference.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForeignKey {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      referencedTable: isSet(object.referencedTable) ? TableReference.fromJSON(object.referencedTable) : undefined,
      columnReferences: globalThis.Array.isArray(object?.columnReferences)
        ? object.columnReferences.map((e: any) => ColumnReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ForeignKey): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.referencedTable !== undefined) {
      obj.referencedTable = TableReference.toJSON(message.referencedTable);
    }
    if (message.columnReferences?.length) {
      obj.columnReferences = message.columnReferences.map((e) => ColumnReference.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ForeignKey>): ForeignKey {
    return ForeignKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForeignKey>): ForeignKey {
    const message = createBaseForeignKey();
    message.name = object.name ?? "";
    message.referencedTable = (object.referencedTable !== undefined && object.referencedTable !== null)
      ? TableReference.fromPartial(object.referencedTable)
      : undefined;
    message.columnReferences = object.columnReferences?.map((e) => ColumnReference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTableConstraints(): TableConstraints {
  return { primaryKey: undefined, foreignKeys: [] };
}

export const TableConstraints: MessageFns<TableConstraints> = {
  encode(message: TableConstraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primaryKey !== undefined) {
      PrimaryKey.encode(message.primaryKey, writer.uint32(10).fork()).join();
    }
    for (const v of message.foreignKeys) {
      ForeignKey.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableConstraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableConstraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.primaryKey = PrimaryKey.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.foreignKeys.push(ForeignKey.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableConstraints {
    return {
      primaryKey: isSet(object.primaryKey) ? PrimaryKey.fromJSON(object.primaryKey) : undefined,
      foreignKeys: globalThis.Array.isArray(object?.foreignKeys)
        ? object.foreignKeys.map((e: any) => ForeignKey.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TableConstraints): unknown {
    const obj: any = {};
    if (message.primaryKey !== undefined) {
      obj.primaryKey = PrimaryKey.toJSON(message.primaryKey);
    }
    if (message.foreignKeys?.length) {
      obj.foreignKeys = message.foreignKeys.map((e) => ForeignKey.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TableConstraints>): TableConstraints {
    return TableConstraints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableConstraints>): TableConstraints {
    const message = createBaseTableConstraints();
    message.primaryKey = (object.primaryKey !== undefined && object.primaryKey !== null)
      ? PrimaryKey.fromPartial(object.primaryKey)
      : undefined;
    message.foreignKeys = object.foreignKeys?.map((e) => ForeignKey.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
