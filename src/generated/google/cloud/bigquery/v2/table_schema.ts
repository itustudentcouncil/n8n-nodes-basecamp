// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/v2/table_schema.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { StringValue } from "../../../protobuf/wrappers.js";

export const protobufPackage = "google.cloud.bigquery.v2";

/** Schema of a table */
export interface TableSchema {
  /** Describes the fields in a table. */
  fields: TableFieldSchema[];
  /**
   * Optional. Specifies metadata of the foreign data type definition in field
   * schema
   * ([TableFieldSchema.foreign_type_definition][google.cloud.bigquery.v2.TableFieldSchema.foreign_type_definition]).
   */
  foreignTypeInfo: ForeignTypeInfo | undefined;
}

/**
 * Metadata about the foreign data type definition such as the system
 * in which the type is defined.
 */
export interface ForeignTypeInfo {
  /** Required. Specifies the system which defines the foreign data type. */
  typeSystem: ForeignTypeInfo_TypeSystem;
}

/**
 * External systems, such as query engines or table formats, that have their
 * own data types.
 */
export enum ForeignTypeInfo_TypeSystem {
  /** TYPE_SYSTEM_UNSPECIFIED - TypeSystem not specified. */
  TYPE_SYSTEM_UNSPECIFIED = 0,
  /** HIVE - Represents Hive data types. */
  HIVE = 1,
  UNRECOGNIZED = -1,
}

export function foreignTypeInfo_TypeSystemFromJSON(object: any): ForeignTypeInfo_TypeSystem {
  switch (object) {
    case 0:
    case "TYPE_SYSTEM_UNSPECIFIED":
      return ForeignTypeInfo_TypeSystem.TYPE_SYSTEM_UNSPECIFIED;
    case 1:
    case "HIVE":
      return ForeignTypeInfo_TypeSystem.HIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ForeignTypeInfo_TypeSystem.UNRECOGNIZED;
  }
}

export function foreignTypeInfo_TypeSystemToJSON(object: ForeignTypeInfo_TypeSystem): string {
  switch (object) {
    case ForeignTypeInfo_TypeSystem.TYPE_SYSTEM_UNSPECIFIED:
      return "TYPE_SYSTEM_UNSPECIFIED";
    case ForeignTypeInfo_TypeSystem.HIVE:
      return "HIVE";
    case ForeignTypeInfo_TypeSystem.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Data policy option proto, it currently supports name only, will support
 * precedence later.
 */
export interface DataPolicyOption {
  /**
   * Data policy resource name in the form of
   * projects/project_id/locations/location_id/dataPolicies/data_policy_id.
   */
  name?: string | undefined;
}

/** A field in TableSchema */
export interface TableFieldSchema {
  /**
   * Required. The field name. The name must contain only letters (a-z, A-Z),
   * numbers (0-9), or underscores (_), and must start with a letter or
   * underscore. The maximum length is 300 characters.
   */
  name: string;
  /**
   * Required. The field data type. Possible values include:
   *
   * * STRING
   * * BYTES
   * * INTEGER (or INT64)
   * * FLOAT (or FLOAT64)
   * * BOOLEAN (or BOOL)
   * * TIMESTAMP
   * * DATE
   * * TIME
   * * DATETIME
   * * GEOGRAPHY
   * * NUMERIC
   * * BIGNUMERIC
   * * JSON
   * * RECORD (or STRUCT)
   * * RANGE
   *
   * Use of RECORD/STRUCT indicates that the field contains a nested schema.
   */
  type: string;
  /**
   * Optional. The field mode. Possible values include NULLABLE, REQUIRED and
   * REPEATED. The default value is NULLABLE.
   */
  mode: string;
  /**
   * Optional. Describes the nested schema fields if the type property is set
   * to RECORD.
   */
  fields: TableFieldSchema[];
  /** Optional. The field description. The maximum length is 1,024 characters. */
  description:
    | string
    | undefined;
  /**
   * Optional. The policy tags attached to this field, used for field-level
   * access control. If not set, defaults to empty policy_tags.
   */
  policyTags:
    | TableFieldSchema_PolicyTagList
    | undefined;
  /** Optional. Data policy options, will replace the data_policies. */
  dataPolicies: DataPolicyOption[];
  /**
   * Optional. Maximum length of values of this field for STRINGS or BYTES.
   *
   * If max_length is not specified, no maximum length constraint is imposed
   * on this field.
   *
   * If type = "STRING", then max_length represents the maximum UTF-8
   * length of strings in this field.
   *
   * If type = "BYTES", then max_length represents the maximum number of
   * bytes in this field.
   *
   * It is invalid to set this field if type &ne; "STRING" and &ne; "BYTES".
   */
  maxLength: Long;
  /**
   * Optional. Precision (maximum number of total digits in base 10) and scale
   * (maximum number of digits in the fractional part in base 10) constraints
   * for values of this field for NUMERIC or BIGNUMERIC.
   *
   * It is invalid to set precision or scale if type &ne; "NUMERIC" and &ne;
   * "BIGNUMERIC".
   *
   * If precision and scale are not specified, no value range constraint is
   * imposed on this field insofar as values are permitted by the type.
   *
   * Values of this NUMERIC or BIGNUMERIC field must be in this range when:
   *
   * * Precision (<var>P</var>) and scale (<var>S</var>) are specified:
   *   [-10<sup><var>P</var>-<var>S</var></sup> + 10<sup>-<var>S</var></sup>,
   *    10<sup><var>P</var>-<var>S</var></sup> - 10<sup>-<var>S</var></sup>]
   * * Precision (<var>P</var>) is specified but not scale (and thus scale is
   *   interpreted to be equal to zero):
   *   [-10<sup><var>P</var></sup> + 1, 10<sup><var>P</var></sup> - 1].
   *
   * Acceptable values for precision and scale if both are specified:
   *
   * * If type = "NUMERIC":
   *   1 &le; precision - scale &le; 29 and 0 &le; scale &le; 9.
   * * If type = "BIGNUMERIC":
   *   1 &le; precision - scale &le; 38 and 0 &le; scale &le; 38.
   *
   * Acceptable values for precision if only precision is specified but not
   * scale (and thus scale is interpreted to be equal to zero):
   *
   * * If type = "NUMERIC": 1 &le; precision &le; 29.
   * * If type = "BIGNUMERIC": 1 &le; precision &le; 38.
   *
   * If scale is specified but not precision, then it is invalid.
   */
  precision: Long;
  /** Optional. See documentation for precision. */
  scale: Long;
  /**
   * Optional. Specifies the rounding mode to be used when storing values of
   * NUMERIC and BIGNUMERIC type.
   */
  roundingMode: TableFieldSchema_RoundingMode;
  /**
   * Optional. Field collation can be set only when the type of field is STRING.
   * The following values are supported:
   *
   * * 'und:ci': undetermined locale, case insensitive.
   * * '': empty string. Default to case-sensitive behavior.
   */
  collation:
    | string
    | undefined;
  /**
   * Optional. A SQL expression to specify the [default value]
   * (https://cloud.google.com/bigquery/docs/default-values) for this field.
   */
  defaultValueExpression:
    | string
    | undefined;
  /**
   * Optional. The subtype of the RANGE, if the type of this field is RANGE. If
   * the type is RANGE, this field is required. Values for the field element
   * type can be the following:
   *
   * * DATE
   * * DATETIME
   * * TIMESTAMP
   */
  rangeElementType:
    | TableFieldSchema_FieldElementType
    | undefined;
  /**
   * Optional. Definition of the foreign data type.
   * Only valid for top-level schema fields (not nested fields).
   * If the type is FOREIGN, this field is required.
   */
  foreignTypeDefinition: string;
}

/**
 * Rounding mode options that can be used when storing NUMERIC
 * or BIGNUMERIC values.
 */
export enum TableFieldSchema_RoundingMode {
  /** ROUNDING_MODE_UNSPECIFIED - Unspecified will default to using ROUND_HALF_AWAY_FROM_ZERO. */
  ROUNDING_MODE_UNSPECIFIED = 0,
  /**
   * ROUND_HALF_AWAY_FROM_ZERO - ROUND_HALF_AWAY_FROM_ZERO rounds half values away from zero
   * when applying precision and scale upon writing of NUMERIC and BIGNUMERIC
   * values.
   * For Scale: 0
   * 1.1, 1.2, 1.3, 1.4 => 1
   * 1.5, 1.6, 1.7, 1.8, 1.9 => 2
   */
  ROUND_HALF_AWAY_FROM_ZERO = 1,
  /**
   * ROUND_HALF_EVEN - ROUND_HALF_EVEN rounds half values to the nearest even value
   * when applying precision and scale upon writing of NUMERIC and BIGNUMERIC
   * values.
   * For Scale: 0
   * 1.1, 1.2, 1.3, 1.4 => 1
   * 1.5 => 2
   * 1.6, 1.7, 1.8, 1.9 => 2
   * 2.5 => 2
   */
  ROUND_HALF_EVEN = 2,
  UNRECOGNIZED = -1,
}

export function tableFieldSchema_RoundingModeFromJSON(object: any): TableFieldSchema_RoundingMode {
  switch (object) {
    case 0:
    case "ROUNDING_MODE_UNSPECIFIED":
      return TableFieldSchema_RoundingMode.ROUNDING_MODE_UNSPECIFIED;
    case 1:
    case "ROUND_HALF_AWAY_FROM_ZERO":
      return TableFieldSchema_RoundingMode.ROUND_HALF_AWAY_FROM_ZERO;
    case 2:
    case "ROUND_HALF_EVEN":
      return TableFieldSchema_RoundingMode.ROUND_HALF_EVEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TableFieldSchema_RoundingMode.UNRECOGNIZED;
  }
}

export function tableFieldSchema_RoundingModeToJSON(object: TableFieldSchema_RoundingMode): string {
  switch (object) {
    case TableFieldSchema_RoundingMode.ROUNDING_MODE_UNSPECIFIED:
      return "ROUNDING_MODE_UNSPECIFIED";
    case TableFieldSchema_RoundingMode.ROUND_HALF_AWAY_FROM_ZERO:
      return "ROUND_HALF_AWAY_FROM_ZERO";
    case TableFieldSchema_RoundingMode.ROUND_HALF_EVEN:
      return "ROUND_HALF_EVEN";
    case TableFieldSchema_RoundingMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TableFieldSchema_PolicyTagList {
  /**
   * A list of policy tag resource names. For example,
   * "projects/1/locations/eu/taxonomies/2/policyTags/3". At most 1 policy tag
   * is currently allowed.
   */
  names: string[];
}

/** Represents the type of a field element. */
export interface TableFieldSchema_FieldElementType {
  /**
   * Required. The type of a field element. For more information, see
   * [TableFieldSchema.type][google.cloud.bigquery.v2.TableFieldSchema.type].
   */
  type: string;
}

function createBaseTableSchema(): TableSchema {
  return { fields: [], foreignTypeInfo: undefined };
}

export const TableSchema: MessageFns<TableSchema> = {
  encode(message: TableSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      TableFieldSchema.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.foreignTypeInfo !== undefined) {
      ForeignTypeInfo.encode(message.foreignTypeInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fields.push(TableFieldSchema.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.foreignTypeInfo = ForeignTypeInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableSchema {
    return {
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => TableFieldSchema.fromJSON(e))
        : [],
      foreignTypeInfo: isSet(object.foreignTypeInfo) ? ForeignTypeInfo.fromJSON(object.foreignTypeInfo) : undefined,
    };
  },

  toJSON(message: TableSchema): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => TableFieldSchema.toJSON(e));
    }
    if (message.foreignTypeInfo !== undefined) {
      obj.foreignTypeInfo = ForeignTypeInfo.toJSON(message.foreignTypeInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<TableSchema>): TableSchema {
    return TableSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableSchema>): TableSchema {
    const message = createBaseTableSchema();
    message.fields = object.fields?.map((e) => TableFieldSchema.fromPartial(e)) || [];
    message.foreignTypeInfo = (object.foreignTypeInfo !== undefined && object.foreignTypeInfo !== null)
      ? ForeignTypeInfo.fromPartial(object.foreignTypeInfo)
      : undefined;
    return message;
  },
};

function createBaseForeignTypeInfo(): ForeignTypeInfo {
  return { typeSystem: 0 };
}

export const ForeignTypeInfo: MessageFns<ForeignTypeInfo> = {
  encode(message: ForeignTypeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.typeSystem !== 0) {
      writer.uint32(8).int32(message.typeSystem);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForeignTypeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForeignTypeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.typeSystem = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForeignTypeInfo {
    return { typeSystem: isSet(object.typeSystem) ? foreignTypeInfo_TypeSystemFromJSON(object.typeSystem) : 0 };
  },

  toJSON(message: ForeignTypeInfo): unknown {
    const obj: any = {};
    if (message.typeSystem !== 0) {
      obj.typeSystem = foreignTypeInfo_TypeSystemToJSON(message.typeSystem);
    }
    return obj;
  },

  create(base?: DeepPartial<ForeignTypeInfo>): ForeignTypeInfo {
    return ForeignTypeInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForeignTypeInfo>): ForeignTypeInfo {
    const message = createBaseForeignTypeInfo();
    message.typeSystem = object.typeSystem ?? 0;
    return message;
  },
};

function createBaseDataPolicyOption(): DataPolicyOption {
  return { name: undefined };
}

export const DataPolicyOption: MessageFns<DataPolicyOption> = {
  encode(message: DataPolicyOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataPolicyOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataPolicyOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataPolicyOption {
    return { name: isSet(object.name) ? globalThis.String(object.name) : undefined };
  },

  toJSON(message: DataPolicyOption): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DataPolicyOption>): DataPolicyOption {
    return DataPolicyOption.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataPolicyOption>): DataPolicyOption {
    const message = createBaseDataPolicyOption();
    message.name = object.name ?? undefined;
    return message;
  },
};

function createBaseTableFieldSchema(): TableFieldSchema {
  return {
    name: "",
    type: "",
    mode: "",
    fields: [],
    description: undefined,
    policyTags: undefined,
    dataPolicies: [],
    maxLength: Long.ZERO,
    precision: Long.ZERO,
    scale: Long.ZERO,
    roundingMode: 0,
    collation: undefined,
    defaultValueExpression: undefined,
    rangeElementType: undefined,
    foreignTypeDefinition: "",
  };
}

export const TableFieldSchema: MessageFns<TableFieldSchema> = {
  encode(message: TableFieldSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.mode !== "") {
      writer.uint32(26).string(message.mode);
    }
    for (const v of message.fields) {
      TableFieldSchema.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.description !== undefined) {
      StringValue.encode({ value: message.description! }, writer.uint32(50).fork()).join();
    }
    if (message.policyTags !== undefined) {
      TableFieldSchema_PolicyTagList.encode(message.policyTags, writer.uint32(74).fork()).join();
    }
    for (const v of message.dataPolicies) {
      DataPolicyOption.encode(v!, writer.uint32(170).fork()).join();
    }
    if (!message.maxLength.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.maxLength.toString());
    }
    if (!message.precision.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.precision.toString());
    }
    if (!message.scale.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.scale.toString());
    }
    if (message.roundingMode !== 0) {
      writer.uint32(120).int32(message.roundingMode);
    }
    if (message.collation !== undefined) {
      StringValue.encode({ value: message.collation! }, writer.uint32(106).fork()).join();
    }
    if (message.defaultValueExpression !== undefined) {
      StringValue.encode({ value: message.defaultValueExpression! }, writer.uint32(114).fork()).join();
    }
    if (message.rangeElementType !== undefined) {
      TableFieldSchema_FieldElementType.encode(message.rangeElementType, writer.uint32(146).fork()).join();
    }
    if (message.foreignTypeDefinition !== "") {
      writer.uint32(186).string(message.foreignTypeDefinition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableFieldSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableFieldSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mode = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fields.push(TableFieldSchema.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.policyTags = TableFieldSchema_PolicyTagList.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.dataPolicies.push(DataPolicyOption.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.maxLength = Long.fromString(reader.int64().toString());
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.precision = Long.fromString(reader.int64().toString());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.scale = Long.fromString(reader.int64().toString());
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.roundingMode = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.collation = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.defaultValueExpression = StringValue.decode(reader, reader.uint32()).value;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.rangeElementType = TableFieldSchema_FieldElementType.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.foreignTypeDefinition = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableFieldSchema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => TableFieldSchema.fromJSON(e))
        : [],
      description: isSet(object.description) ? String(object.description) : undefined,
      policyTags: isSet(object.policyTags) ? TableFieldSchema_PolicyTagList.fromJSON(object.policyTags) : undefined,
      dataPolicies: globalThis.Array.isArray(object?.dataPolicies)
        ? object.dataPolicies.map((e: any) => DataPolicyOption.fromJSON(e))
        : [],
      maxLength: isSet(object.maxLength) ? Long.fromValue(object.maxLength) : Long.ZERO,
      precision: isSet(object.precision) ? Long.fromValue(object.precision) : Long.ZERO,
      scale: isSet(object.scale) ? Long.fromValue(object.scale) : Long.ZERO,
      roundingMode: isSet(object.roundingMode) ? tableFieldSchema_RoundingModeFromJSON(object.roundingMode) : 0,
      collation: isSet(object.collation) ? String(object.collation) : undefined,
      defaultValueExpression: isSet(object.defaultValueExpression) ? String(object.defaultValueExpression) : undefined,
      rangeElementType: isSet(object.rangeElementType)
        ? TableFieldSchema_FieldElementType.fromJSON(object.rangeElementType)
        : undefined,
      foreignTypeDefinition: isSet(object.foreignTypeDefinition) ? globalThis.String(object.foreignTypeDefinition) : "",
    };
  },

  toJSON(message: TableFieldSchema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => TableFieldSchema.toJSON(e));
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.policyTags !== undefined) {
      obj.policyTags = TableFieldSchema_PolicyTagList.toJSON(message.policyTags);
    }
    if (message.dataPolicies?.length) {
      obj.dataPolicies = message.dataPolicies.map((e) => DataPolicyOption.toJSON(e));
    }
    if (!message.maxLength.equals(Long.ZERO)) {
      obj.maxLength = (message.maxLength || Long.ZERO).toString();
    }
    if (!message.precision.equals(Long.ZERO)) {
      obj.precision = (message.precision || Long.ZERO).toString();
    }
    if (!message.scale.equals(Long.ZERO)) {
      obj.scale = (message.scale || Long.ZERO).toString();
    }
    if (message.roundingMode !== 0) {
      obj.roundingMode = tableFieldSchema_RoundingModeToJSON(message.roundingMode);
    }
    if (message.collation !== undefined) {
      obj.collation = message.collation;
    }
    if (message.defaultValueExpression !== undefined) {
      obj.defaultValueExpression = message.defaultValueExpression;
    }
    if (message.rangeElementType !== undefined) {
      obj.rangeElementType = TableFieldSchema_FieldElementType.toJSON(message.rangeElementType);
    }
    if (message.foreignTypeDefinition !== "") {
      obj.foreignTypeDefinition = message.foreignTypeDefinition;
    }
    return obj;
  },

  create(base?: DeepPartial<TableFieldSchema>): TableFieldSchema {
    return TableFieldSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableFieldSchema>): TableFieldSchema {
    const message = createBaseTableFieldSchema();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.mode = object.mode ?? "";
    message.fields = object.fields?.map((e) => TableFieldSchema.fromPartial(e)) || [];
    message.description = object.description ?? undefined;
    message.policyTags = (object.policyTags !== undefined && object.policyTags !== null)
      ? TableFieldSchema_PolicyTagList.fromPartial(object.policyTags)
      : undefined;
    message.dataPolicies = object.dataPolicies?.map((e) => DataPolicyOption.fromPartial(e)) || [];
    message.maxLength = (object.maxLength !== undefined && object.maxLength !== null)
      ? Long.fromValue(object.maxLength)
      : Long.ZERO;
    message.precision = (object.precision !== undefined && object.precision !== null)
      ? Long.fromValue(object.precision)
      : Long.ZERO;
    message.scale = (object.scale !== undefined && object.scale !== null) ? Long.fromValue(object.scale) : Long.ZERO;
    message.roundingMode = object.roundingMode ?? 0;
    message.collation = object.collation ?? undefined;
    message.defaultValueExpression = object.defaultValueExpression ?? undefined;
    message.rangeElementType = (object.rangeElementType !== undefined && object.rangeElementType !== null)
      ? TableFieldSchema_FieldElementType.fromPartial(object.rangeElementType)
      : undefined;
    message.foreignTypeDefinition = object.foreignTypeDefinition ?? "";
    return message;
  },
};

function createBaseTableFieldSchema_PolicyTagList(): TableFieldSchema_PolicyTagList {
  return { names: [] };
}

export const TableFieldSchema_PolicyTagList: MessageFns<TableFieldSchema_PolicyTagList> = {
  encode(message: TableFieldSchema_PolicyTagList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.names) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableFieldSchema_PolicyTagList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableFieldSchema_PolicyTagList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.names.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableFieldSchema_PolicyTagList {
    return { names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: TableFieldSchema_PolicyTagList): unknown {
    const obj: any = {};
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create(base?: DeepPartial<TableFieldSchema_PolicyTagList>): TableFieldSchema_PolicyTagList {
    return TableFieldSchema_PolicyTagList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableFieldSchema_PolicyTagList>): TableFieldSchema_PolicyTagList {
    const message = createBaseTableFieldSchema_PolicyTagList();
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

function createBaseTableFieldSchema_FieldElementType(): TableFieldSchema_FieldElementType {
  return { type: "" };
}

export const TableFieldSchema_FieldElementType: MessageFns<TableFieldSchema_FieldElementType> = {
  encode(message: TableFieldSchema_FieldElementType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableFieldSchema_FieldElementType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableFieldSchema_FieldElementType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableFieldSchema_FieldElementType {
    return { type: isSet(object.type) ? globalThis.String(object.type) : "" };
  },

  toJSON(message: TableFieldSchema_FieldElementType): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<TableFieldSchema_FieldElementType>): TableFieldSchema_FieldElementType {
    return TableFieldSchema_FieldElementType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableFieldSchema_FieldElementType>): TableFieldSchema_FieldElementType {
    const message = createBaseTableFieldSchema_FieldElementType();
    message.type = object.type ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
