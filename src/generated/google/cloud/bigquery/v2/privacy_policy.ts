// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/v2/privacy_policy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.bigquery.v2";

/** Represents privacy policy associated with "aggregation threshold" method. */
export interface AggregationThresholdPolicy {
  /** Optional. The threshold for the "aggregation threshold" policy. */
  threshold?:
    | Long
    | undefined;
  /**
   * Optional. The privacy unit column(s) associated with this policy.
   * For now, only one column per data source object (table, view) is allowed as
   * a privacy unit column.
   * Representing as a repeated field in metadata for extensibility to
   * multiple columns in future.
   * Duplicates and Repeated struct fields are not allowed.
   * For nested fields, use dot notation ("outer.inner")
   */
  privacyUnitColumns: string[];
}

/** Represents privacy policy associated with "differential privacy" method. */
export interface DifferentialPrivacyPolicy {
  /**
   * Optional. The maximum epsilon value that a query can consume. If the
   * subscriber specifies epsilon as a parameter in a SELECT query, it must be
   * less than or equal to this value. The epsilon parameter controls the amount
   * of noise that is added to the groups â€” a higher epsilon means less noise.
   */
  maxEpsilonPerQuery?:
    | number
    | undefined;
  /**
   * Optional. The delta value that is used per query. Delta represents the
   * probability that any row will fail to be epsilon differentially private.
   * Indicates the risk associated with exposing aggregate rows in the result of
   * a query.
   */
  deltaPerQuery?:
    | number
    | undefined;
  /**
   * Optional. The maximum groups contributed value that is used per query.
   * Represents the maximum number of groups to which each protected entity can
   * contribute. Changing this value does not improve or worsen privacy. The
   * best value for accuracy and utility depends on the query and data.
   */
  maxGroupsContributed?:
    | Long
    | undefined;
  /**
   * Optional. The privacy unit column associated with this policy. Differential
   * privacy policies can only have one privacy unit column per data source
   * object (table, view).
   */
  privacyUnitColumn?:
    | string
    | undefined;
  /**
   * Optional. The total epsilon budget for all queries against the
   * privacy-protected view. Each subscriber query against this view charges the
   * amount of epsilon they request in their query. If there is sufficient
   * budget, then the subscriber query attempts to complete. It might still fail
   * due to other reasons, in which case the charge is refunded. If there is
   * insufficient budget the query is rejected. There might be multiple charge
   * attempts if a single query references multiple views. In this case there
   * must be sufficient budget for all charges or the query is rejected and
   * charges are refunded in best effort. The budget does not have a refresh
   * policy and can only be updated via ALTER VIEW or circumvented by creating a
   * new view that can be queried with a fresh budget.
   */
  epsilonBudget?:
    | number
    | undefined;
  /**
   * Optional. The total delta budget for all queries against the
   * privacy-protected view. Each subscriber query against this view charges the
   * amount of delta that is pre-defined by the contributor through the privacy
   * policy delta_per_query field. If there is sufficient budget, then the
   * subscriber query attempts to complete. It might still fail due to other
   * reasons, in which case the charge is refunded. If there is insufficient
   * budget the query is rejected. There might be multiple charge attempts if a
   * single query references multiple views. In this case there must be
   * sufficient budget for all charges or the query is rejected and charges are
   * refunded in best effort. The budget does not have a refresh policy and can
   * only be updated via ALTER VIEW or circumvented by creating a new view that
   * can be queried with a fresh budget.
   */
  deltaBudget?:
    | number
    | undefined;
  /**
   * Output only. The epsilon budget remaining. If budget is exhausted, no more
   * queries are allowed. Note that the budget for queries that are in progress
   * is deducted before the query executes. If the query fails or is cancelled
   * then the budget is refunded. In this case the amount of budget remaining
   * can increase.
   */
  epsilonBudgetRemaining?:
    | number
    | undefined;
  /**
   * Output only. The delta budget remaining. If budget is exhausted, no more
   * queries are allowed. Note that the budget for queries that are in progress
   * is deducted before the query executes. If the query fails or is cancelled
   * then the budget is refunded. In this case the amount of budget remaining
   * can increase.
   */
  deltaBudgetRemaining?: number | undefined;
}

/**
 * Represents privacy policy associated with "join restrictions". Join
 * restriction gives data providers the ability to enforce joins on the
 * 'join_allowed_columns' when data is queried from a privacy protected view.
 */
export interface JoinRestrictionPolicy {
  /**
   * Optional. Specifies if a join is required or not on queries for the view.
   * Default is JOIN_CONDITION_UNSPECIFIED.
   */
  joinCondition?:
    | JoinRestrictionPolicy_JoinCondition
    | undefined;
  /**
   * Optional. The only columns that joins are allowed on.
   * This field is must be specified for join_conditions JOIN_ANY and JOIN_ALL
   * and it cannot be set for JOIN_BLOCKED.
   */
  joinAllowedColumns: string[];
}

/** Enum for Join Restrictions policy. */
export enum JoinRestrictionPolicy_JoinCondition {
  /** JOIN_CONDITION_UNSPECIFIED - A join is neither required nor restricted on any column. Default value. */
  JOIN_CONDITION_UNSPECIFIED = 0,
  /** JOIN_ANY - A join is required on at least one of the specified columns. */
  JOIN_ANY = 1,
  /** JOIN_ALL - A join is required on all specified columns. */
  JOIN_ALL = 2,
  /**
   * JOIN_NOT_REQUIRED - A join is not required, but if present it is only permitted on
   * 'join_allowed_columns'
   */
  JOIN_NOT_REQUIRED = 3,
  /** JOIN_BLOCKED - Joins are blocked for all queries. */
  JOIN_BLOCKED = 4,
  UNRECOGNIZED = -1,
}

export function joinRestrictionPolicy_JoinConditionFromJSON(object: any): JoinRestrictionPolicy_JoinCondition {
  switch (object) {
    case 0:
    case "JOIN_CONDITION_UNSPECIFIED":
      return JoinRestrictionPolicy_JoinCondition.JOIN_CONDITION_UNSPECIFIED;
    case 1:
    case "JOIN_ANY":
      return JoinRestrictionPolicy_JoinCondition.JOIN_ANY;
    case 2:
    case "JOIN_ALL":
      return JoinRestrictionPolicy_JoinCondition.JOIN_ALL;
    case 3:
    case "JOIN_NOT_REQUIRED":
      return JoinRestrictionPolicy_JoinCondition.JOIN_NOT_REQUIRED;
    case 4:
    case "JOIN_BLOCKED":
      return JoinRestrictionPolicy_JoinCondition.JOIN_BLOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JoinRestrictionPolicy_JoinCondition.UNRECOGNIZED;
  }
}

export function joinRestrictionPolicy_JoinConditionToJSON(object: JoinRestrictionPolicy_JoinCondition): string {
  switch (object) {
    case JoinRestrictionPolicy_JoinCondition.JOIN_CONDITION_UNSPECIFIED:
      return "JOIN_CONDITION_UNSPECIFIED";
    case JoinRestrictionPolicy_JoinCondition.JOIN_ANY:
      return "JOIN_ANY";
    case JoinRestrictionPolicy_JoinCondition.JOIN_ALL:
      return "JOIN_ALL";
    case JoinRestrictionPolicy_JoinCondition.JOIN_NOT_REQUIRED:
      return "JOIN_NOT_REQUIRED";
    case JoinRestrictionPolicy_JoinCondition.JOIN_BLOCKED:
      return "JOIN_BLOCKED";
    case JoinRestrictionPolicy_JoinCondition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents privacy policy that contains the privacy requirements specified by
 * the data owner. Currently, this is only supported on views.
 */
export interface PrivacyPolicy {
  /** Optional. Policy used for aggregation thresholds. */
  aggregationThresholdPolicy?:
    | AggregationThresholdPolicy
    | undefined;
  /** Optional. Policy used for differential privacy. */
  differentialPrivacyPolicy?:
    | DifferentialPrivacyPolicy
    | undefined;
  /**
   * Optional. Join restriction policy is outside of the one of policies, since
   * this policy can be set along with other policies. This policy gives data
   * providers the ability to enforce joins on the 'join_allowed_columns' when
   * data is queried from a privacy protected view.
   */
  joinRestrictionPolicy?: JoinRestrictionPolicy | undefined;
}

function createBaseAggregationThresholdPolicy(): AggregationThresholdPolicy {
  return { threshold: undefined, privacyUnitColumns: [] };
}

export const AggregationThresholdPolicy: MessageFns<AggregationThresholdPolicy> = {
  encode(message: AggregationThresholdPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.threshold !== undefined) {
      writer.uint32(8).int64(message.threshold.toString());
    }
    for (const v of message.privacyUnitColumns) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregationThresholdPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregationThresholdPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.threshold = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.privacyUnitColumns.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregationThresholdPolicy {
    return {
      threshold: isSet(object.threshold) ? Long.fromValue(object.threshold) : undefined,
      privacyUnitColumns: globalThis.Array.isArray(object?.privacyUnitColumns)
        ? object.privacyUnitColumns.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AggregationThresholdPolicy): unknown {
    const obj: any = {};
    if (message.threshold !== undefined) {
      obj.threshold = (message.threshold || Long.ZERO).toString();
    }
    if (message.privacyUnitColumns?.length) {
      obj.privacyUnitColumns = message.privacyUnitColumns;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregationThresholdPolicy>): AggregationThresholdPolicy {
    return AggregationThresholdPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregationThresholdPolicy>): AggregationThresholdPolicy {
    const message = createBaseAggregationThresholdPolicy();
    message.threshold = (object.threshold !== undefined && object.threshold !== null)
      ? Long.fromValue(object.threshold)
      : undefined;
    message.privacyUnitColumns = object.privacyUnitColumns?.map((e) => e) || [];
    return message;
  },
};

function createBaseDifferentialPrivacyPolicy(): DifferentialPrivacyPolicy {
  return {
    maxEpsilonPerQuery: undefined,
    deltaPerQuery: undefined,
    maxGroupsContributed: undefined,
    privacyUnitColumn: undefined,
    epsilonBudget: undefined,
    deltaBudget: undefined,
    epsilonBudgetRemaining: undefined,
    deltaBudgetRemaining: undefined,
  };
}

export const DifferentialPrivacyPolicy: MessageFns<DifferentialPrivacyPolicy> = {
  encode(message: DifferentialPrivacyPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxEpsilonPerQuery !== undefined) {
      writer.uint32(9).double(message.maxEpsilonPerQuery);
    }
    if (message.deltaPerQuery !== undefined) {
      writer.uint32(17).double(message.deltaPerQuery);
    }
    if (message.maxGroupsContributed !== undefined) {
      writer.uint32(24).int64(message.maxGroupsContributed.toString());
    }
    if (message.privacyUnitColumn !== undefined) {
      writer.uint32(34).string(message.privacyUnitColumn);
    }
    if (message.epsilonBudget !== undefined) {
      writer.uint32(41).double(message.epsilonBudget);
    }
    if (message.deltaBudget !== undefined) {
      writer.uint32(49).double(message.deltaBudget);
    }
    if (message.epsilonBudgetRemaining !== undefined) {
      writer.uint32(57).double(message.epsilonBudgetRemaining);
    }
    if (message.deltaBudgetRemaining !== undefined) {
      writer.uint32(65).double(message.deltaBudgetRemaining);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DifferentialPrivacyPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDifferentialPrivacyPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.maxEpsilonPerQuery = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.deltaPerQuery = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxGroupsContributed = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.privacyUnitColumn = reader.string();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.epsilonBudget = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.deltaBudget = reader.double();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.epsilonBudgetRemaining = reader.double();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.deltaBudgetRemaining = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DifferentialPrivacyPolicy {
    return {
      maxEpsilonPerQuery: isSet(object.maxEpsilonPerQuery) ? globalThis.Number(object.maxEpsilonPerQuery) : undefined,
      deltaPerQuery: isSet(object.deltaPerQuery) ? globalThis.Number(object.deltaPerQuery) : undefined,
      maxGroupsContributed: isSet(object.maxGroupsContributed)
        ? Long.fromValue(object.maxGroupsContributed)
        : undefined,
      privacyUnitColumn: isSet(object.privacyUnitColumn) ? globalThis.String(object.privacyUnitColumn) : undefined,
      epsilonBudget: isSet(object.epsilonBudget) ? globalThis.Number(object.epsilonBudget) : undefined,
      deltaBudget: isSet(object.deltaBudget) ? globalThis.Number(object.deltaBudget) : undefined,
      epsilonBudgetRemaining: isSet(object.epsilonBudgetRemaining)
        ? globalThis.Number(object.epsilonBudgetRemaining)
        : undefined,
      deltaBudgetRemaining: isSet(object.deltaBudgetRemaining)
        ? globalThis.Number(object.deltaBudgetRemaining)
        : undefined,
    };
  },

  toJSON(message: DifferentialPrivacyPolicy): unknown {
    const obj: any = {};
    if (message.maxEpsilonPerQuery !== undefined) {
      obj.maxEpsilonPerQuery = message.maxEpsilonPerQuery;
    }
    if (message.deltaPerQuery !== undefined) {
      obj.deltaPerQuery = message.deltaPerQuery;
    }
    if (message.maxGroupsContributed !== undefined) {
      obj.maxGroupsContributed = (message.maxGroupsContributed || Long.ZERO).toString();
    }
    if (message.privacyUnitColumn !== undefined) {
      obj.privacyUnitColumn = message.privacyUnitColumn;
    }
    if (message.epsilonBudget !== undefined) {
      obj.epsilonBudget = message.epsilonBudget;
    }
    if (message.deltaBudget !== undefined) {
      obj.deltaBudget = message.deltaBudget;
    }
    if (message.epsilonBudgetRemaining !== undefined) {
      obj.epsilonBudgetRemaining = message.epsilonBudgetRemaining;
    }
    if (message.deltaBudgetRemaining !== undefined) {
      obj.deltaBudgetRemaining = message.deltaBudgetRemaining;
    }
    return obj;
  },

  create(base?: DeepPartial<DifferentialPrivacyPolicy>): DifferentialPrivacyPolicy {
    return DifferentialPrivacyPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DifferentialPrivacyPolicy>): DifferentialPrivacyPolicy {
    const message = createBaseDifferentialPrivacyPolicy();
    message.maxEpsilonPerQuery = object.maxEpsilonPerQuery ?? undefined;
    message.deltaPerQuery = object.deltaPerQuery ?? undefined;
    message.maxGroupsContributed = (object.maxGroupsContributed !== undefined && object.maxGroupsContributed !== null)
      ? Long.fromValue(object.maxGroupsContributed)
      : undefined;
    message.privacyUnitColumn = object.privacyUnitColumn ?? undefined;
    message.epsilonBudget = object.epsilonBudget ?? undefined;
    message.deltaBudget = object.deltaBudget ?? undefined;
    message.epsilonBudgetRemaining = object.epsilonBudgetRemaining ?? undefined;
    message.deltaBudgetRemaining = object.deltaBudgetRemaining ?? undefined;
    return message;
  },
};

function createBaseJoinRestrictionPolicy(): JoinRestrictionPolicy {
  return { joinCondition: undefined, joinAllowedColumns: [] };
}

export const JoinRestrictionPolicy: MessageFns<JoinRestrictionPolicy> = {
  encode(message: JoinRestrictionPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.joinCondition !== undefined) {
      writer.uint32(8).int32(message.joinCondition);
    }
    for (const v of message.joinAllowedColumns) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinRestrictionPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinRestrictionPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.joinCondition = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.joinAllowedColumns.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinRestrictionPolicy {
    return {
      joinCondition: isSet(object.joinCondition)
        ? joinRestrictionPolicy_JoinConditionFromJSON(object.joinCondition)
        : undefined,
      joinAllowedColumns: globalThis.Array.isArray(object?.joinAllowedColumns)
        ? object.joinAllowedColumns.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: JoinRestrictionPolicy): unknown {
    const obj: any = {};
    if (message.joinCondition !== undefined) {
      obj.joinCondition = joinRestrictionPolicy_JoinConditionToJSON(message.joinCondition);
    }
    if (message.joinAllowedColumns?.length) {
      obj.joinAllowedColumns = message.joinAllowedColumns;
    }
    return obj;
  },

  create(base?: DeepPartial<JoinRestrictionPolicy>): JoinRestrictionPolicy {
    return JoinRestrictionPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JoinRestrictionPolicy>): JoinRestrictionPolicy {
    const message = createBaseJoinRestrictionPolicy();
    message.joinCondition = object.joinCondition ?? undefined;
    message.joinAllowedColumns = object.joinAllowedColumns?.map((e) => e) || [];
    return message;
  },
};

function createBasePrivacyPolicy(): PrivacyPolicy {
  return {
    aggregationThresholdPolicy: undefined,
    differentialPrivacyPolicy: undefined,
    joinRestrictionPolicy: undefined,
  };
}

export const PrivacyPolicy: MessageFns<PrivacyPolicy> = {
  encode(message: PrivacyPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aggregationThresholdPolicy !== undefined) {
      AggregationThresholdPolicy.encode(message.aggregationThresholdPolicy, writer.uint32(18).fork()).join();
    }
    if (message.differentialPrivacyPolicy !== undefined) {
      DifferentialPrivacyPolicy.encode(message.differentialPrivacyPolicy, writer.uint32(26).fork()).join();
    }
    if (message.joinRestrictionPolicy !== undefined) {
      JoinRestrictionPolicy.encode(message.joinRestrictionPolicy, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrivacyPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrivacyPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.aggregationThresholdPolicy = AggregationThresholdPolicy.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.differentialPrivacyPolicy = DifferentialPrivacyPolicy.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.joinRestrictionPolicy = JoinRestrictionPolicy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrivacyPolicy {
    return {
      aggregationThresholdPolicy: isSet(object.aggregationThresholdPolicy)
        ? AggregationThresholdPolicy.fromJSON(object.aggregationThresholdPolicy)
        : undefined,
      differentialPrivacyPolicy: isSet(object.differentialPrivacyPolicy)
        ? DifferentialPrivacyPolicy.fromJSON(object.differentialPrivacyPolicy)
        : undefined,
      joinRestrictionPolicy: isSet(object.joinRestrictionPolicy)
        ? JoinRestrictionPolicy.fromJSON(object.joinRestrictionPolicy)
        : undefined,
    };
  },

  toJSON(message: PrivacyPolicy): unknown {
    const obj: any = {};
    if (message.aggregationThresholdPolicy !== undefined) {
      obj.aggregationThresholdPolicy = AggregationThresholdPolicy.toJSON(message.aggregationThresholdPolicy);
    }
    if (message.differentialPrivacyPolicy !== undefined) {
      obj.differentialPrivacyPolicy = DifferentialPrivacyPolicy.toJSON(message.differentialPrivacyPolicy);
    }
    if (message.joinRestrictionPolicy !== undefined) {
      obj.joinRestrictionPolicy = JoinRestrictionPolicy.toJSON(message.joinRestrictionPolicy);
    }
    return obj;
  },

  create(base?: DeepPartial<PrivacyPolicy>): PrivacyPolicy {
    return PrivacyPolicy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PrivacyPolicy>): PrivacyPolicy {
    const message = createBasePrivacyPolicy();
    message.aggregationThresholdPolicy =
      (object.aggregationThresholdPolicy !== undefined && object.aggregationThresholdPolicy !== null)
        ? AggregationThresholdPolicy.fromPartial(object.aggregationThresholdPolicy)
        : undefined;
    message.differentialPrivacyPolicy =
      (object.differentialPrivacyPolicy !== undefined && object.differentialPrivacyPolicy !== null)
        ? DifferentialPrivacyPolicy.fromPartial(object.differentialPrivacyPolicy)
        : undefined;
    message.joinRestrictionPolicy =
      (object.joinRestrictionPolicy !== undefined && object.joinRestrictionPolicy !== null)
        ? JoinRestrictionPolicy.fromPartial(object.joinRestrictionPolicy)
        : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
