// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/bigquery/storage/v1/table.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.bigquery.storage.v1";

/**
 * Schema of a table. This schema is a subset of
 * google.cloud.bigquery.v2.TableSchema containing information necessary to
 * generate valid message to write to BigQuery.
 */
export interface TableSchema {
  /** Describes the fields in a table. */
  fields: TableFieldSchema[];
}

/** TableFieldSchema defines a single field/column within a table schema. */
export interface TableFieldSchema {
  /**
   * Required. The field name. The name must contain only letters (a-z, A-Z),
   * numbers (0-9), or underscores (_), and must start with a letter or
   * underscore. The maximum length is 128 characters.
   */
  name: string;
  /** Required. The field data type. */
  type: TableFieldSchema_Type;
  /** Optional. The field mode. The default value is NULLABLE. */
  mode: TableFieldSchema_Mode;
  /**
   * Optional. Describes the nested schema fields if the type property is set to
   * STRUCT.
   */
  fields: TableFieldSchema[];
  /** Optional. The field description. The maximum length is 1,024 characters. */
  description: string;
  /**
   * Optional. Maximum length of values of this field for STRINGS or BYTES.
   *
   * If max_length is not specified, no maximum length constraint is imposed
   * on this field.
   *
   * If type = "STRING", then max_length represents the maximum UTF-8
   * length of strings in this field.
   *
   * If type = "BYTES", then max_length represents the maximum number of
   * bytes in this field.
   *
   * It is invalid to set this field if type is not "STRING" or "BYTES".
   */
  maxLength: Long;
  /**
   * Optional. Precision (maximum number of total digits in base 10) and scale
   * (maximum number of digits in the fractional part in base 10) constraints
   * for values of this field for NUMERIC or BIGNUMERIC.
   *
   * It is invalid to set precision or scale if type is not "NUMERIC" or
   * "BIGNUMERIC".
   *
   * If precision and scale are not specified, no value range constraint is
   * imposed on this field insofar as values are permitted by the type.
   *
   * Values of this NUMERIC or BIGNUMERIC field must be in this range when:
   *
   * * Precision (P) and scale (S) are specified:
   *   [-10^(P-S) + 10^(-S), 10^(P-S) - 10^(-S)]
   * * Precision (P) is specified but not scale (and thus scale is
   *   interpreted to be equal to zero):
   *   [-10^P + 1, 10^P - 1].
   *
   * Acceptable values for precision and scale if both are specified:
   *
   * * If type = "NUMERIC":
   *   1 <= precision - scale <= 29 and 0 <= scale <= 9.
   * * If type = "BIGNUMERIC":
   *   1 <= precision - scale <= 38 and 0 <= scale <= 38.
   *
   * Acceptable values for precision if only precision is specified but not
   * scale (and thus scale is interpreted to be equal to zero):
   *
   * * If type = "NUMERIC": 1 <= precision <= 29.
   * * If type = "BIGNUMERIC": 1 <= precision <= 38.
   *
   * If scale is specified but not precision, then it is invalid.
   */
  precision: Long;
  /** Optional. See documentation for precision. */
  scale: Long;
  /**
   * Optional. A SQL expression to specify the [default value]
   * (https://cloud.google.com/bigquery/docs/default-values) for this field.
   */
  defaultValueExpression: string;
  /**
   * Optional. The subtype of the RANGE, if the type of this field is RANGE. If
   * the type is RANGE, this field is required. Possible values for the field
   * element type of a RANGE include:
   * * DATE
   * * DATETIME
   * * TIMESTAMP
   */
  rangeElementType: TableFieldSchema_FieldElementType | undefined;
}

export enum TableFieldSchema_Type {
  /** TYPE_UNSPECIFIED - Illegal value */
  TYPE_UNSPECIFIED = 0,
  /** STRING - 64K, UTF8 */
  STRING = 1,
  /** INT64 - 64-bit signed */
  INT64 = 2,
  /** DOUBLE - 64-bit IEEE floating point */
  DOUBLE = 3,
  /** STRUCT - Aggregate type */
  STRUCT = 4,
  /** BYTES - 64K, Binary */
  BYTES = 5,
  /** BOOL - 2-valued */
  BOOL = 6,
  /** TIMESTAMP - 64-bit signed usec since UTC epoch */
  TIMESTAMP = 7,
  /** DATE - Civil date - Year, Month, Day */
  DATE = 8,
  /** TIME - Civil time - Hour, Minute, Second, Microseconds */
  TIME = 9,
  /** DATETIME - Combination of civil date and civil time */
  DATETIME = 10,
  /** GEOGRAPHY - Geography object */
  GEOGRAPHY = 11,
  /** NUMERIC - Numeric value */
  NUMERIC = 12,
  /** BIGNUMERIC - BigNumeric value */
  BIGNUMERIC = 13,
  /** INTERVAL - Interval */
  INTERVAL = 14,
  /** JSON - JSON, String */
  JSON = 15,
  /** RANGE - RANGE */
  RANGE = 16,
  UNRECOGNIZED = -1,
}

export function tableFieldSchema_TypeFromJSON(object: any): TableFieldSchema_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return TableFieldSchema_Type.TYPE_UNSPECIFIED;
    case 1:
    case "STRING":
      return TableFieldSchema_Type.STRING;
    case 2:
    case "INT64":
      return TableFieldSchema_Type.INT64;
    case 3:
    case "DOUBLE":
      return TableFieldSchema_Type.DOUBLE;
    case 4:
    case "STRUCT":
      return TableFieldSchema_Type.STRUCT;
    case 5:
    case "BYTES":
      return TableFieldSchema_Type.BYTES;
    case 6:
    case "BOOL":
      return TableFieldSchema_Type.BOOL;
    case 7:
    case "TIMESTAMP":
      return TableFieldSchema_Type.TIMESTAMP;
    case 8:
    case "DATE":
      return TableFieldSchema_Type.DATE;
    case 9:
    case "TIME":
      return TableFieldSchema_Type.TIME;
    case 10:
    case "DATETIME":
      return TableFieldSchema_Type.DATETIME;
    case 11:
    case "GEOGRAPHY":
      return TableFieldSchema_Type.GEOGRAPHY;
    case 12:
    case "NUMERIC":
      return TableFieldSchema_Type.NUMERIC;
    case 13:
    case "BIGNUMERIC":
      return TableFieldSchema_Type.BIGNUMERIC;
    case 14:
    case "INTERVAL":
      return TableFieldSchema_Type.INTERVAL;
    case 15:
    case "JSON":
      return TableFieldSchema_Type.JSON;
    case 16:
    case "RANGE":
      return TableFieldSchema_Type.RANGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TableFieldSchema_Type.UNRECOGNIZED;
  }
}

export function tableFieldSchema_TypeToJSON(object: TableFieldSchema_Type): string {
  switch (object) {
    case TableFieldSchema_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case TableFieldSchema_Type.STRING:
      return "STRING";
    case TableFieldSchema_Type.INT64:
      return "INT64";
    case TableFieldSchema_Type.DOUBLE:
      return "DOUBLE";
    case TableFieldSchema_Type.STRUCT:
      return "STRUCT";
    case TableFieldSchema_Type.BYTES:
      return "BYTES";
    case TableFieldSchema_Type.BOOL:
      return "BOOL";
    case TableFieldSchema_Type.TIMESTAMP:
      return "TIMESTAMP";
    case TableFieldSchema_Type.DATE:
      return "DATE";
    case TableFieldSchema_Type.TIME:
      return "TIME";
    case TableFieldSchema_Type.DATETIME:
      return "DATETIME";
    case TableFieldSchema_Type.GEOGRAPHY:
      return "GEOGRAPHY";
    case TableFieldSchema_Type.NUMERIC:
      return "NUMERIC";
    case TableFieldSchema_Type.BIGNUMERIC:
      return "BIGNUMERIC";
    case TableFieldSchema_Type.INTERVAL:
      return "INTERVAL";
    case TableFieldSchema_Type.JSON:
      return "JSON";
    case TableFieldSchema_Type.RANGE:
      return "RANGE";
    case TableFieldSchema_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TableFieldSchema_Mode {
  /** MODE_UNSPECIFIED - Illegal value */
  MODE_UNSPECIFIED = 0,
  NULLABLE = 1,
  REQUIRED = 2,
  REPEATED = 3,
  UNRECOGNIZED = -1,
}

export function tableFieldSchema_ModeFromJSON(object: any): TableFieldSchema_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return TableFieldSchema_Mode.MODE_UNSPECIFIED;
    case 1:
    case "NULLABLE":
      return TableFieldSchema_Mode.NULLABLE;
    case 2:
    case "REQUIRED":
      return TableFieldSchema_Mode.REQUIRED;
    case 3:
    case "REPEATED":
      return TableFieldSchema_Mode.REPEATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TableFieldSchema_Mode.UNRECOGNIZED;
  }
}

export function tableFieldSchema_ModeToJSON(object: TableFieldSchema_Mode): string {
  switch (object) {
    case TableFieldSchema_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case TableFieldSchema_Mode.NULLABLE:
      return "NULLABLE";
    case TableFieldSchema_Mode.REQUIRED:
      return "REQUIRED";
    case TableFieldSchema_Mode.REPEATED:
      return "REPEATED";
    case TableFieldSchema_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents the type of a field element. */
export interface TableFieldSchema_FieldElementType {
  /** Required. The type of a field element. */
  type: TableFieldSchema_Type;
}

function createBaseTableSchema(): TableSchema {
  return { fields: [] };
}

export const TableSchema: MessageFns<TableSchema> = {
  encode(message: TableSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      TableFieldSchema.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fields.push(TableFieldSchema.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableSchema {
    return {
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => TableFieldSchema.fromJSON(e))
        : [],
    };
  },

  toJSON(message: TableSchema): unknown {
    const obj: any = {};
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => TableFieldSchema.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TableSchema>): TableSchema {
    return TableSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableSchema>): TableSchema {
    const message = createBaseTableSchema();
    message.fields = object.fields?.map((e) => TableFieldSchema.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTableFieldSchema(): TableFieldSchema {
  return {
    name: "",
    type: 0,
    mode: 0,
    fields: [],
    description: "",
    maxLength: Long.ZERO,
    precision: Long.ZERO,
    scale: Long.ZERO,
    defaultValueExpression: "",
    rangeElementType: undefined,
  };
}

export const TableFieldSchema: MessageFns<TableFieldSchema> = {
  encode(message: TableFieldSchema, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.mode !== 0) {
      writer.uint32(24).int32(message.mode);
    }
    for (const v of message.fields) {
      TableFieldSchema.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (!message.maxLength.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.maxLength.toString());
    }
    if (!message.precision.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.precision.toString());
    }
    if (!message.scale.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.scale.toString());
    }
    if (message.defaultValueExpression !== "") {
      writer.uint32(82).string(message.defaultValueExpression);
    }
    if (message.rangeElementType !== undefined) {
      TableFieldSchema_FieldElementType.encode(message.rangeElementType, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableFieldSchema {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableFieldSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.fields.push(TableFieldSchema.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maxLength = Long.fromString(reader.int64().toString());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.precision = Long.fromString(reader.int64().toString());
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.scale = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.defaultValueExpression = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.rangeElementType = TableFieldSchema_FieldElementType.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableFieldSchema {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? tableFieldSchema_TypeFromJSON(object.type) : 0,
      mode: isSet(object.mode) ? tableFieldSchema_ModeFromJSON(object.mode) : 0,
      fields: globalThis.Array.isArray(object?.fields)
        ? object.fields.map((e: any) => TableFieldSchema.fromJSON(e))
        : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      maxLength: isSet(object.maxLength) ? Long.fromValue(object.maxLength) : Long.ZERO,
      precision: isSet(object.precision) ? Long.fromValue(object.precision) : Long.ZERO,
      scale: isSet(object.scale) ? Long.fromValue(object.scale) : Long.ZERO,
      defaultValueExpression: isSet(object.defaultValueExpression)
        ? globalThis.String(object.defaultValueExpression)
        : "",
      rangeElementType: isSet(object.rangeElementType)
        ? TableFieldSchema_FieldElementType.fromJSON(object.rangeElementType)
        : undefined,
    };
  },

  toJSON(message: TableFieldSchema): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = tableFieldSchema_TypeToJSON(message.type);
    }
    if (message.mode !== 0) {
      obj.mode = tableFieldSchema_ModeToJSON(message.mode);
    }
    if (message.fields?.length) {
      obj.fields = message.fields.map((e) => TableFieldSchema.toJSON(e));
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (!message.maxLength.equals(Long.ZERO)) {
      obj.maxLength = (message.maxLength || Long.ZERO).toString();
    }
    if (!message.precision.equals(Long.ZERO)) {
      obj.precision = (message.precision || Long.ZERO).toString();
    }
    if (!message.scale.equals(Long.ZERO)) {
      obj.scale = (message.scale || Long.ZERO).toString();
    }
    if (message.defaultValueExpression !== "") {
      obj.defaultValueExpression = message.defaultValueExpression;
    }
    if (message.rangeElementType !== undefined) {
      obj.rangeElementType = TableFieldSchema_FieldElementType.toJSON(message.rangeElementType);
    }
    return obj;
  },

  create(base?: DeepPartial<TableFieldSchema>): TableFieldSchema {
    return TableFieldSchema.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableFieldSchema>): TableFieldSchema {
    const message = createBaseTableFieldSchema();
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.mode = object.mode ?? 0;
    message.fields = object.fields?.map((e) => TableFieldSchema.fromPartial(e)) || [];
    message.description = object.description ?? "";
    message.maxLength = (object.maxLength !== undefined && object.maxLength !== null)
      ? Long.fromValue(object.maxLength)
      : Long.ZERO;
    message.precision = (object.precision !== undefined && object.precision !== null)
      ? Long.fromValue(object.precision)
      : Long.ZERO;
    message.scale = (object.scale !== undefined && object.scale !== null) ? Long.fromValue(object.scale) : Long.ZERO;
    message.defaultValueExpression = object.defaultValueExpression ?? "";
    message.rangeElementType = (object.rangeElementType !== undefined && object.rangeElementType !== null)
      ? TableFieldSchema_FieldElementType.fromPartial(object.rangeElementType)
      : undefined;
    return message;
  },
};

function createBaseTableFieldSchema_FieldElementType(): TableFieldSchema_FieldElementType {
  return { type: 0 };
}

export const TableFieldSchema_FieldElementType: MessageFns<TableFieldSchema_FieldElementType> = {
  encode(message: TableFieldSchema_FieldElementType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableFieldSchema_FieldElementType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableFieldSchema_FieldElementType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableFieldSchema_FieldElementType {
    return { type: isSet(object.type) ? tableFieldSchema_TypeFromJSON(object.type) : 0 };
  },

  toJSON(message: TableFieldSchema_FieldElementType): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = tableFieldSchema_TypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<TableFieldSchema_FieldElementType>): TableFieldSchema_FieldElementType {
    return TableFieldSchema_FieldElementType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableFieldSchema_FieldElementType>): TableFieldSchema_FieldElementType {
    const message = createBaseTableFieldSchema_FieldElementType();
    message.type = object.type ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
