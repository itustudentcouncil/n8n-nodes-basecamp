// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/domains/v1alpha2/domains.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Money } from "../../../type/money.js";
import { PostalAddress } from "../../../type/postal_address.js";

export const protobufPackage = "google.cloud.domains.v1alpha2";

/**
 * Defines a set of possible contact privacy settings for a `Registration`.
 *
 * [ICANN](https://icann.org/) maintains the WHOIS database, a publicly
 * accessible mapping from domain name to contact information, and requires that
 * each domain name have an entry. Choose from these options to control how much
 * information in your `ContactSettings` is published.
 */
export enum ContactPrivacy {
  /** CONTACT_PRIVACY_UNSPECIFIED - The contact privacy settings are undefined. */
  CONTACT_PRIVACY_UNSPECIFIED = 0,
  /**
   * PUBLIC_CONTACT_DATA - All the data from `ContactSettings` is publicly available. When setting
   * this option, you must also provide a
   * `PUBLIC_CONTACT_DATA_ACKNOWLEDGEMENT` in the `contact_notices` field of the
   * request.
   */
  PUBLIC_CONTACT_DATA = 1,
  /**
   * PRIVATE_CONTACT_DATA - None of the data from `ContactSettings` is publicly available. Instead,
   * proxy contact data is published for your domain. Email sent to the proxy
   * email address is forwarded to the registrant's email address. Cloud Domains
   * provides this privacy proxy service at no additional cost.
   */
  PRIVATE_CONTACT_DATA = 2,
  /**
   * REDACTED_CONTACT_DATA - Some data from `ContactSettings` is publicly available. The actual
   * information redacted depends on the domain. For details, see [the
   * registration privacy
   * article](https://support.google.com/domains/answer/3251242).
   */
  REDACTED_CONTACT_DATA = 3,
  UNRECOGNIZED = -1,
}

export function contactPrivacyFromJSON(object: any): ContactPrivacy {
  switch (object) {
    case 0:
    case "CONTACT_PRIVACY_UNSPECIFIED":
      return ContactPrivacy.CONTACT_PRIVACY_UNSPECIFIED;
    case 1:
    case "PUBLIC_CONTACT_DATA":
      return ContactPrivacy.PUBLIC_CONTACT_DATA;
    case 2:
    case "PRIVATE_CONTACT_DATA":
      return ContactPrivacy.PRIVATE_CONTACT_DATA;
    case 3:
    case "REDACTED_CONTACT_DATA":
      return ContactPrivacy.REDACTED_CONTACT_DATA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ContactPrivacy.UNRECOGNIZED;
  }
}

export function contactPrivacyToJSON(object: ContactPrivacy): string {
  switch (object) {
    case ContactPrivacy.CONTACT_PRIVACY_UNSPECIFIED:
      return "CONTACT_PRIVACY_UNSPECIFIED";
    case ContactPrivacy.PUBLIC_CONTACT_DATA:
      return "PUBLIC_CONTACT_DATA";
    case ContactPrivacy.PRIVATE_CONTACT_DATA:
      return "PRIVATE_CONTACT_DATA";
    case ContactPrivacy.REDACTED_CONTACT_DATA:
      return "REDACTED_CONTACT_DATA";
    case ContactPrivacy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Notices about special properties of certain domains. */
export enum DomainNotice {
  /** DOMAIN_NOTICE_UNSPECIFIED - The notice is undefined. */
  DOMAIN_NOTICE_UNSPECIFIED = 0,
  /**
   * HSTS_PRELOADED - Indicates that the domain is preloaded on the HTTP Strict Transport
   * Security list in browsers. Serving a website on such domain requires
   * an SSL certificate. For details, see
   * [how to get an SSL
   * certificate](https://support.google.com/domains/answer/7638036).
   */
  HSTS_PRELOADED = 1,
  UNRECOGNIZED = -1,
}

export function domainNoticeFromJSON(object: any): DomainNotice {
  switch (object) {
    case 0:
    case "DOMAIN_NOTICE_UNSPECIFIED":
      return DomainNotice.DOMAIN_NOTICE_UNSPECIFIED;
    case 1:
    case "HSTS_PRELOADED":
      return DomainNotice.HSTS_PRELOADED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DomainNotice.UNRECOGNIZED;
  }
}

export function domainNoticeToJSON(object: DomainNotice): string {
  switch (object) {
    case DomainNotice.DOMAIN_NOTICE_UNSPECIFIED:
      return "DOMAIN_NOTICE_UNSPECIFIED";
    case DomainNotice.HSTS_PRELOADED:
      return "HSTS_PRELOADED";
    case DomainNotice.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Notices related to contact information. */
export enum ContactNotice {
  /** CONTACT_NOTICE_UNSPECIFIED - The notice is undefined. */
  CONTACT_NOTICE_UNSPECIFIED = 0,
  /**
   * PUBLIC_CONTACT_DATA_ACKNOWLEDGEMENT - Required when setting the `privacy` field of `ContactSettings` to
   * `PUBLIC_CONTACT_DATA`, which exposes contact data publicly.
   */
  PUBLIC_CONTACT_DATA_ACKNOWLEDGEMENT = 1,
  UNRECOGNIZED = -1,
}

export function contactNoticeFromJSON(object: any): ContactNotice {
  switch (object) {
    case 0:
    case "CONTACT_NOTICE_UNSPECIFIED":
      return ContactNotice.CONTACT_NOTICE_UNSPECIFIED;
    case 1:
    case "PUBLIC_CONTACT_DATA_ACKNOWLEDGEMENT":
      return ContactNotice.PUBLIC_CONTACT_DATA_ACKNOWLEDGEMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ContactNotice.UNRECOGNIZED;
  }
}

export function contactNoticeToJSON(object: ContactNotice): string {
  switch (object) {
    case ContactNotice.CONTACT_NOTICE_UNSPECIFIED:
      return "CONTACT_NOTICE_UNSPECIFIED";
    case ContactNotice.PUBLIC_CONTACT_DATA_ACKNOWLEDGEMENT:
      return "PUBLIC_CONTACT_DATA_ACKNOWLEDGEMENT";
    case ContactNotice.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible states of a `Registration`'s transfer lock. */
export enum TransferLockState {
  /** TRANSFER_LOCK_STATE_UNSPECIFIED - The state is unspecified. */
  TRANSFER_LOCK_STATE_UNSPECIFIED = 0,
  /** UNLOCKED - The domain is unlocked and can be transferred to another registrar. */
  UNLOCKED = 1,
  /** LOCKED - The domain is locked and cannot be transferred to another registrar. */
  LOCKED = 2,
  UNRECOGNIZED = -1,
}

export function transferLockStateFromJSON(object: any): TransferLockState {
  switch (object) {
    case 0:
    case "TRANSFER_LOCK_STATE_UNSPECIFIED":
      return TransferLockState.TRANSFER_LOCK_STATE_UNSPECIFIED;
    case 1:
    case "UNLOCKED":
      return TransferLockState.UNLOCKED;
    case 2:
    case "LOCKED":
      return TransferLockState.LOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferLockState.UNRECOGNIZED;
  }
}

export function transferLockStateToJSON(object: TransferLockState): string {
  switch (object) {
    case TransferLockState.TRANSFER_LOCK_STATE_UNSPECIFIED:
      return "TRANSFER_LOCK_STATE_UNSPECIFIED";
    case TransferLockState.UNLOCKED:
      return "UNLOCKED";
    case TransferLockState.LOCKED:
      return "LOCKED";
    case TransferLockState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * The `Registration` resource facilitates managing and configuring domain name
 * registrations.
 *
 * There are several ways to create a new `Registration` resource:
 *
 * To create a new `Registration` resource, find a suitable domain name by
 * calling the `SearchDomains` method with a query to see available domain name
 * options. After choosing a name, call `RetrieveRegisterParameters` to
 * ensure availability and obtain information like pricing, which is needed to
 * build a call to `RegisterDomain`.
 *
 * Another way to create a new `Registration` is to transfer an existing
 * domain from another registrar. First, go to the current registrar to unlock
 * the domain for transfer and retrieve the domain's transfer authorization
 * code. Then call `RetrieveTransferParameters` to confirm that the domain is
 * unlocked and to get values needed to build a call to `TransferDomain`.
 */
export interface Registration {
  /**
   * Output only. Name of the `Registration` resource, in the format
   * `projects/* /locations/* /registrations/<domain_name>`.
   */
  name: string;
  /** Required. Immutable. The domain name. Unicode domain names must be expressed in Punycode format. */
  domainName: string;
  /** Output only. The creation timestamp of the `Registration` resource. */
  createTime:
    | Date
    | undefined;
  /** Output only. The expiration timestamp of the `Registration`. */
  expireTime:
    | Date
    | undefined;
  /** Output only. The state of the `Registration` */
  state: Registration_State;
  /** Output only. The set of issues with the `Registration` that require attention. */
  issues: Registration_Issue[];
  /** Set of labels associated with the `Registration`. */
  labels: { [key: string]: string };
  /**
   * Settings for management of the `Registration`, including renewal, billing,
   * and transfer. You cannot update these with the `UpdateRegistration`
   * method. To update these settings, use the `ConfigureManagementSettings`
   * method.
   */
  managementSettings:
    | ManagementSettings
    | undefined;
  /**
   * Settings controlling the DNS configuration of the `Registration`. You
   * cannot update these with the `UpdateRegistration` method. To update these
   * settings, use the `ConfigureDnsSettings` method.
   */
  dnsSettings:
    | DnsSettings
    | undefined;
  /**
   * Required. Settings for contact information linked to the `Registration`. You cannot
   * update these with the `UpdateRegistration` method. To update these
   * settings, use the `ConfigureContactSettings` method.
   */
  contactSettings:
    | ContactSettings
    | undefined;
  /**
   * Output only. Pending contact settings for the `Registration`. Updates to the
   * `contact_settings` field that change its `registrant_contact` or `privacy`
   * fields require email confirmation by the `registrant_contact`
   * before taking effect. This field is set only if there are pending updates
   * to the `contact_settings` that have not been confirmed. To confirm the
   * changes, the `registrant_contact` must follow the instructions in the
   * email they receive.
   */
  pendingContactSettings:
    | ContactSettings
    | undefined;
  /**
   * Output only. Set of options for the `contact_settings.privacy` field that this
   * `Registration` supports.
   */
  supportedPrivacy: ContactPrivacy[];
}

/** Possible states of a `Registration`. */
export enum Registration_State {
  /** STATE_UNSPECIFIED - The state is undefined. */
  STATE_UNSPECIFIED = 0,
  /** REGISTRATION_PENDING - The domain is being registered. */
  REGISTRATION_PENDING = 1,
  /**
   * REGISTRATION_FAILED - The domain registration failed. You can delete resources in this state
   * to allow registration to be retried.
   */
  REGISTRATION_FAILED = 2,
  /** TRANSFER_PENDING - The domain is being transferred from another registrar to Cloud Domains. */
  TRANSFER_PENDING = 3,
  /**
   * TRANSFER_FAILED - The attempt to transfer the domain from another registrar to
   * Cloud Domains failed. You can delete resources in this state and retry
   * the transfer.
   */
  TRANSFER_FAILED = 4,
  /**
   * ACTIVE - The domain is registered and operational. The domain renews automatically
   * as long as it remains in this state.
   */
  ACTIVE = 6,
  /**
   * SUSPENDED - The domain is suspended and inoperative. For more details, see the
   * `issues` field.
   */
  SUSPENDED = 7,
  /**
   * EXPORTED - The domain is no longer managed with Cloud Domains. It may have been
   * transferred to another registrar or exported for management in
   * [Google Domains](https://domains.google/). You can no longer update it
   * with this API, and information shown about it may be stale. Domains in
   * this state are not automatically renewed by Cloud Domains.
   */
  EXPORTED = 8,
  UNRECOGNIZED = -1,
}

export function registration_StateFromJSON(object: any): Registration_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Registration_State.STATE_UNSPECIFIED;
    case 1:
    case "REGISTRATION_PENDING":
      return Registration_State.REGISTRATION_PENDING;
    case 2:
    case "REGISTRATION_FAILED":
      return Registration_State.REGISTRATION_FAILED;
    case 3:
    case "TRANSFER_PENDING":
      return Registration_State.TRANSFER_PENDING;
    case 4:
    case "TRANSFER_FAILED":
      return Registration_State.TRANSFER_FAILED;
    case 6:
    case "ACTIVE":
      return Registration_State.ACTIVE;
    case 7:
    case "SUSPENDED":
      return Registration_State.SUSPENDED;
    case 8:
    case "EXPORTED":
      return Registration_State.EXPORTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Registration_State.UNRECOGNIZED;
  }
}

export function registration_StateToJSON(object: Registration_State): string {
  switch (object) {
    case Registration_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Registration_State.REGISTRATION_PENDING:
      return "REGISTRATION_PENDING";
    case Registration_State.REGISTRATION_FAILED:
      return "REGISTRATION_FAILED";
    case Registration_State.TRANSFER_PENDING:
      return "TRANSFER_PENDING";
    case Registration_State.TRANSFER_FAILED:
      return "TRANSFER_FAILED";
    case Registration_State.ACTIVE:
      return "ACTIVE";
    case Registration_State.SUSPENDED:
      return "SUSPENDED";
    case Registration_State.EXPORTED:
      return "EXPORTED";
    case Registration_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Possible issues with a `Registration` that require attention. */
export enum Registration_Issue {
  /** ISSUE_UNSPECIFIED - The issue is undefined. */
  ISSUE_UNSPECIFIED = 0,
  /** CONTACT_SUPPORT - Contact the Cloud Support team to resolve a problem with this domain. */
  CONTACT_SUPPORT = 1,
  /**
   * UNVERIFIED_EMAIL - [ICANN](https://icann.org/) requires verification of the email address
   * in the `Registration`'s `contact_settings.registrant_contact` field. To
   * verify the email address, follow the
   * instructions in the email the `registrant_contact` receives following
   * registration. If you do not complete email verification within
   * 15 days of registration, the domain is suspended. To resend the
   * verification email, call ConfigureContactSettings and provide the current
   * `registrant_contact.email`.
   */
  UNVERIFIED_EMAIL = 2,
  UNRECOGNIZED = -1,
}

export function registration_IssueFromJSON(object: any): Registration_Issue {
  switch (object) {
    case 0:
    case "ISSUE_UNSPECIFIED":
      return Registration_Issue.ISSUE_UNSPECIFIED;
    case 1:
    case "CONTACT_SUPPORT":
      return Registration_Issue.CONTACT_SUPPORT;
    case 2:
    case "UNVERIFIED_EMAIL":
      return Registration_Issue.UNVERIFIED_EMAIL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Registration_Issue.UNRECOGNIZED;
  }
}

export function registration_IssueToJSON(object: Registration_Issue): string {
  switch (object) {
    case Registration_Issue.ISSUE_UNSPECIFIED:
      return "ISSUE_UNSPECIFIED";
    case Registration_Issue.CONTACT_SUPPORT:
      return "CONTACT_SUPPORT";
    case Registration_Issue.UNVERIFIED_EMAIL:
      return "UNVERIFIED_EMAIL";
    case Registration_Issue.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Registration_LabelsEntry {
  key: string;
  value: string;
}

/** Defines renewal, billing, and transfer settings for a `Registration`. */
export interface ManagementSettings {
  /** Output only. The renewal method for this `Registration`. */
  renewalMethod: ManagementSettings_RenewalMethod;
  /** Controls whether the domain can be transferred to another registrar. */
  transferLockState: TransferLockState;
}

/** Defines how the `Registration` is renewed. */
export enum ManagementSettings_RenewalMethod {
  /** RENEWAL_METHOD_UNSPECIFIED - The renewal method is undefined. */
  RENEWAL_METHOD_UNSPECIFIED = 0,
  /**
   * AUTOMATIC_RENEWAL - The domain is automatically renewed each year .
   *
   * To disable automatic renewals, delete the resource by calling
   * `DeleteRegistration` or export it by calling `ExportRegistration`.
   */
  AUTOMATIC_RENEWAL = 1,
  /**
   * MANUAL_RENEWAL - The domain must be explicitly renewed each year before its
   * `expire_time`. This option is only available when the `Registration`
   * is in state `EXPORTED`.
   *
   * To manage the domain's current billing and
   * renewal settings, go to [Google Domains](https://domains.google/).
   */
  MANUAL_RENEWAL = 2,
  UNRECOGNIZED = -1,
}

export function managementSettings_RenewalMethodFromJSON(object: any): ManagementSettings_RenewalMethod {
  switch (object) {
    case 0:
    case "RENEWAL_METHOD_UNSPECIFIED":
      return ManagementSettings_RenewalMethod.RENEWAL_METHOD_UNSPECIFIED;
    case 1:
    case "AUTOMATIC_RENEWAL":
      return ManagementSettings_RenewalMethod.AUTOMATIC_RENEWAL;
    case 2:
    case "MANUAL_RENEWAL":
      return ManagementSettings_RenewalMethod.MANUAL_RENEWAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ManagementSettings_RenewalMethod.UNRECOGNIZED;
  }
}

export function managementSettings_RenewalMethodToJSON(object: ManagementSettings_RenewalMethod): string {
  switch (object) {
    case ManagementSettings_RenewalMethod.RENEWAL_METHOD_UNSPECIFIED:
      return "RENEWAL_METHOD_UNSPECIFIED";
    case ManagementSettings_RenewalMethod.AUTOMATIC_RENEWAL:
      return "AUTOMATIC_RENEWAL";
    case ManagementSettings_RenewalMethod.MANUAL_RENEWAL:
      return "MANUAL_RENEWAL";
    case ManagementSettings_RenewalMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Defines the DNS configuration of a `Registration`, including name servers,
 * DNSSEC, and glue records.
 */
export interface DnsSettings {
  /** An arbitrary DNS provider identified by its name servers. */
  customDns?:
    | DnsSettings_CustomDns
    | undefined;
  /**
   * The free DNS zone provided by
   * [Google Domains](https://domains.google/).
   */
  googleDomainsDns?:
    | DnsSettings_GoogleDomainsDns
    | undefined;
  /** The list of glue records for this `Registration`. Commonly empty. */
  glueRecords: DnsSettings_GlueRecord[];
}

/** The publication state of DS records for a `Registration`. */
export enum DnsSettings_DsState {
  /** DS_STATE_UNSPECIFIED - DS state is unspecified. */
  DS_STATE_UNSPECIFIED = 0,
  /**
   * DS_RECORDS_UNPUBLISHED - DNSSEC is disabled for this domain. No DS records for this domain are
   * published in the parent DNS zone.
   */
  DS_RECORDS_UNPUBLISHED = 1,
  /**
   * DS_RECORDS_PUBLISHED - DNSSEC is enabled for this domain. Appropriate DS records for this domain
   * are published in the parent DNS zone. This option is valid only if the
   * DNS zone referenced in the `Registration`'s `dns_provider` field is
   * already DNSSEC-signed.
   */
  DS_RECORDS_PUBLISHED = 2,
  UNRECOGNIZED = -1,
}

export function dnsSettings_DsStateFromJSON(object: any): DnsSettings_DsState {
  switch (object) {
    case 0:
    case "DS_STATE_UNSPECIFIED":
      return DnsSettings_DsState.DS_STATE_UNSPECIFIED;
    case 1:
    case "DS_RECORDS_UNPUBLISHED":
      return DnsSettings_DsState.DS_RECORDS_UNPUBLISHED;
    case 2:
    case "DS_RECORDS_PUBLISHED":
      return DnsSettings_DsState.DS_RECORDS_PUBLISHED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DnsSettings_DsState.UNRECOGNIZED;
  }
}

export function dnsSettings_DsStateToJSON(object: DnsSettings_DsState): string {
  switch (object) {
    case DnsSettings_DsState.DS_STATE_UNSPECIFIED:
      return "DS_STATE_UNSPECIFIED";
    case DnsSettings_DsState.DS_RECORDS_UNPUBLISHED:
      return "DS_RECORDS_UNPUBLISHED";
    case DnsSettings_DsState.DS_RECORDS_PUBLISHED:
      return "DS_RECORDS_PUBLISHED";
    case DnsSettings_DsState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration for an arbitrary DNS provider. */
export interface DnsSettings_CustomDns {
  /**
   * Required. A list of name servers that store the DNS zone for this domain. Each name
   * server is a domain name, with Unicode domain names expressed in
   * Punycode format.
   */
  nameServers: string[];
  /**
   * The list of DS records for this domain, which are used to enable DNSSEC.
   * The domain's DNS provider can provide the values to set here. If this
   * field is empty, DNSSEC is disabled.
   */
  dsRecords: DnsSettings_DsRecord[];
}

/**
 * Configuration for using the free DNS zone provided by Google Domains as a
 * `Registration`'s `dns_provider`. You cannot configure the DNS zone itself
 * using the API. To configure the DNS zone, go to
 * [Google Domains](https://domains.google/).
 */
export interface DnsSettings_GoogleDomainsDns {
  /**
   * Output only. A list of name servers that store the DNS zone for this domain. Each name
   * server is a domain name, with Unicode domain names expressed in
   * Punycode format. This field is automatically populated with the name
   * servers assigned to the Google Domains DNS zone.
   */
  nameServers: string[];
  /**
   * Required. The state of DS records for this domain. Used to enable or disable
   * automatic DNSSEC.
   */
  dsState: DnsSettings_DsState;
  /**
   * Output only. The list of DS records published for this domain. The list is
   * automatically populated when `ds_state` is `DS_RECORDS_PUBLISHED`,
   * otherwise it remains empty.
   */
  dsRecords: DnsSettings_DsRecord[];
}

/**
 * Defines a Delegation Signer (DS) record, which is needed to enable DNSSEC
 * for a domain. It contains a digest (hash) of a DNSKEY record that must be
 * present in the domain's DNS zone.
 */
export interface DnsSettings_DsRecord {
  /** The key tag of the record. Must be set in range 0 -- 65535. */
  keyTag: number;
  /** The algorithm used to generate the referenced DNSKEY. */
  algorithm: DnsSettings_DsRecord_Algorithm;
  /** The hash function used to generate the digest of the referenced DNSKEY. */
  digestType: DnsSettings_DsRecord_DigestType;
  /** The digest generated from the referenced DNSKEY. */
  digest: string;
}

/**
 * List of algorithms used to create a DNSKEY. Certain
 * algorithms are not supported for particular domains.
 */
export enum DnsSettings_DsRecord_Algorithm {
  /** ALGORITHM_UNSPECIFIED - The algorithm is unspecified. */
  ALGORITHM_UNSPECIFIED = 0,
  /** RSAMD5 - RSA/MD5. Cannot be used for new deployments. */
  RSAMD5 = 1,
  /** DH - Diffie-Hellman. Cannot be used for new deployments. */
  DH = 2,
  /** DSA - DSA/SHA1. Not recommended for new deployments. */
  DSA = 3,
  /** ECC - ECC. Not recommended for new deployments. */
  ECC = 4,
  /** RSASHA1 - RSA/SHA-1. Not recommended for new deployments. */
  RSASHA1 = 5,
  /** DSANSEC3SHA1 - DSA-NSEC3-SHA1. Not recommended for new deployments. */
  DSANSEC3SHA1 = 6,
  /** RSASHA1NSEC3SHA1 - RSA/SHA1-NSEC3-SHA1. Not recommended for new deployments. */
  RSASHA1NSEC3SHA1 = 7,
  /** RSASHA256 - RSA/SHA-256. */
  RSASHA256 = 8,
  /** RSASHA512 - RSA/SHA-512. */
  RSASHA512 = 10,
  /** ECCGOST - GOST R 34.10-2001. */
  ECCGOST = 12,
  /** ECDSAP256SHA256 - ECDSA Curve P-256 with SHA-256. */
  ECDSAP256SHA256 = 13,
  /** ECDSAP384SHA384 - ECDSA Curve P-384 with SHA-384. */
  ECDSAP384SHA384 = 14,
  /** ED25519 - Ed25519. */
  ED25519 = 15,
  /** ED448 - Ed448. */
  ED448 = 16,
  /** INDIRECT - Reserved for Indirect Keys. Cannot be used for new deployments. */
  INDIRECT = 252,
  /** PRIVATEDNS - Private algorithm. Cannot be used for new deployments. */
  PRIVATEDNS = 253,
  /** PRIVATEOID - Private algorithm OID. Cannot be used for new deployments. */
  PRIVATEOID = 254,
  UNRECOGNIZED = -1,
}

export function dnsSettings_DsRecord_AlgorithmFromJSON(object: any): DnsSettings_DsRecord_Algorithm {
  switch (object) {
    case 0:
    case "ALGORITHM_UNSPECIFIED":
      return DnsSettings_DsRecord_Algorithm.ALGORITHM_UNSPECIFIED;
    case 1:
    case "RSAMD5":
      return DnsSettings_DsRecord_Algorithm.RSAMD5;
    case 2:
    case "DH":
      return DnsSettings_DsRecord_Algorithm.DH;
    case 3:
    case "DSA":
      return DnsSettings_DsRecord_Algorithm.DSA;
    case 4:
    case "ECC":
      return DnsSettings_DsRecord_Algorithm.ECC;
    case 5:
    case "RSASHA1":
      return DnsSettings_DsRecord_Algorithm.RSASHA1;
    case 6:
    case "DSANSEC3SHA1":
      return DnsSettings_DsRecord_Algorithm.DSANSEC3SHA1;
    case 7:
    case "RSASHA1NSEC3SHA1":
      return DnsSettings_DsRecord_Algorithm.RSASHA1NSEC3SHA1;
    case 8:
    case "RSASHA256":
      return DnsSettings_DsRecord_Algorithm.RSASHA256;
    case 10:
    case "RSASHA512":
      return DnsSettings_DsRecord_Algorithm.RSASHA512;
    case 12:
    case "ECCGOST":
      return DnsSettings_DsRecord_Algorithm.ECCGOST;
    case 13:
    case "ECDSAP256SHA256":
      return DnsSettings_DsRecord_Algorithm.ECDSAP256SHA256;
    case 14:
    case "ECDSAP384SHA384":
      return DnsSettings_DsRecord_Algorithm.ECDSAP384SHA384;
    case 15:
    case "ED25519":
      return DnsSettings_DsRecord_Algorithm.ED25519;
    case 16:
    case "ED448":
      return DnsSettings_DsRecord_Algorithm.ED448;
    case 252:
    case "INDIRECT":
      return DnsSettings_DsRecord_Algorithm.INDIRECT;
    case 253:
    case "PRIVATEDNS":
      return DnsSettings_DsRecord_Algorithm.PRIVATEDNS;
    case 254:
    case "PRIVATEOID":
      return DnsSettings_DsRecord_Algorithm.PRIVATEOID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DnsSettings_DsRecord_Algorithm.UNRECOGNIZED;
  }
}

export function dnsSettings_DsRecord_AlgorithmToJSON(object: DnsSettings_DsRecord_Algorithm): string {
  switch (object) {
    case DnsSettings_DsRecord_Algorithm.ALGORITHM_UNSPECIFIED:
      return "ALGORITHM_UNSPECIFIED";
    case DnsSettings_DsRecord_Algorithm.RSAMD5:
      return "RSAMD5";
    case DnsSettings_DsRecord_Algorithm.DH:
      return "DH";
    case DnsSettings_DsRecord_Algorithm.DSA:
      return "DSA";
    case DnsSettings_DsRecord_Algorithm.ECC:
      return "ECC";
    case DnsSettings_DsRecord_Algorithm.RSASHA1:
      return "RSASHA1";
    case DnsSettings_DsRecord_Algorithm.DSANSEC3SHA1:
      return "DSANSEC3SHA1";
    case DnsSettings_DsRecord_Algorithm.RSASHA1NSEC3SHA1:
      return "RSASHA1NSEC3SHA1";
    case DnsSettings_DsRecord_Algorithm.RSASHA256:
      return "RSASHA256";
    case DnsSettings_DsRecord_Algorithm.RSASHA512:
      return "RSASHA512";
    case DnsSettings_DsRecord_Algorithm.ECCGOST:
      return "ECCGOST";
    case DnsSettings_DsRecord_Algorithm.ECDSAP256SHA256:
      return "ECDSAP256SHA256";
    case DnsSettings_DsRecord_Algorithm.ECDSAP384SHA384:
      return "ECDSAP384SHA384";
    case DnsSettings_DsRecord_Algorithm.ED25519:
      return "ED25519";
    case DnsSettings_DsRecord_Algorithm.ED448:
      return "ED448";
    case DnsSettings_DsRecord_Algorithm.INDIRECT:
      return "INDIRECT";
    case DnsSettings_DsRecord_Algorithm.PRIVATEDNS:
      return "PRIVATEDNS";
    case DnsSettings_DsRecord_Algorithm.PRIVATEOID:
      return "PRIVATEOID";
    case DnsSettings_DsRecord_Algorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * List of hash functions that may have been used to generate a digest of a
 * DNSKEY.
 */
export enum DnsSettings_DsRecord_DigestType {
  /** DIGEST_TYPE_UNSPECIFIED - The DigestType is unspecified. */
  DIGEST_TYPE_UNSPECIFIED = 0,
  /** SHA1 - SHA-1. Not recommended for new deployments. */
  SHA1 = 1,
  /** SHA256 - SHA-256. */
  SHA256 = 2,
  /** GOST3411 - GOST R 34.11-94. */
  GOST3411 = 3,
  /** SHA384 - SHA-384. */
  SHA384 = 4,
  UNRECOGNIZED = -1,
}

export function dnsSettings_DsRecord_DigestTypeFromJSON(object: any): DnsSettings_DsRecord_DigestType {
  switch (object) {
    case 0:
    case "DIGEST_TYPE_UNSPECIFIED":
      return DnsSettings_DsRecord_DigestType.DIGEST_TYPE_UNSPECIFIED;
    case 1:
    case "SHA1":
      return DnsSettings_DsRecord_DigestType.SHA1;
    case 2:
    case "SHA256":
      return DnsSettings_DsRecord_DigestType.SHA256;
    case 3:
    case "GOST3411":
      return DnsSettings_DsRecord_DigestType.GOST3411;
    case 4:
    case "SHA384":
      return DnsSettings_DsRecord_DigestType.SHA384;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DnsSettings_DsRecord_DigestType.UNRECOGNIZED;
  }
}

export function dnsSettings_DsRecord_DigestTypeToJSON(object: DnsSettings_DsRecord_DigestType): string {
  switch (object) {
    case DnsSettings_DsRecord_DigestType.DIGEST_TYPE_UNSPECIFIED:
      return "DIGEST_TYPE_UNSPECIFIED";
    case DnsSettings_DsRecord_DigestType.SHA1:
      return "SHA1";
    case DnsSettings_DsRecord_DigestType.SHA256:
      return "SHA256";
    case DnsSettings_DsRecord_DigestType.GOST3411:
      return "GOST3411";
    case DnsSettings_DsRecord_DigestType.SHA384:
      return "SHA384";
    case DnsSettings_DsRecord_DigestType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Defines a host on your domain that is a DNS name server for your domain
 * and/or other domains. Glue records are a way of making the IP address of a
 * name server known, even when it serves DNS queries for its parent domain.
 * For example, when `ns.example.com` is a name server for `example.com`, the
 * host `ns.example.com` must have a glue record to break the circular DNS
 * reference.
 */
export interface DnsSettings_GlueRecord {
  /** Required. Domain name of the host in Punycode format. */
  hostName: string;
  /**
   * List of IPv4 addresses corresponding to this host in the standard decimal
   * format (e.g. `198.51.100.1`). At least one of `ipv4_address` and
   * `ipv6_address` must be set.
   */
  ipv4Addresses: string[];
  /**
   * List of IPv6 addresses corresponding to this host in the standard
   * hexadecimal format (e.g. `2001:db8::`). At least one of
   * `ipv4_address` and `ipv6_address` must be set.
   */
  ipv6Addresses: string[];
}

/**
 * Defines the contact information associated with a `Registration`.
 *
 * [ICANN](https://icann.org/) requires all domain names to have associated
 * contact information. The `registrant_contact` is considered the
 * domain's legal owner, and often the other contacts are identical.
 */
export interface ContactSettings {
  /** Required. Privacy setting for the contacts associated with the `Registration`. */
  privacy: ContactPrivacy;
  /**
   * Required. The registrant contact for the `Registration`.
   *
   * *Caution: Anyone with access to this email address, phone number,
   * and/or postal address can take control of the domain.*
   *
   * *Warning: For new `Registration`s, the registrant receives an email
   * confirmation that they must complete within 15 days to avoid domain
   * suspension.*
   */
  registrantContact:
    | ContactSettings_Contact
    | undefined;
  /** Required. The administrative contact for the `Registration`. */
  adminContact:
    | ContactSettings_Contact
    | undefined;
  /** Required. The technical contact for the `Registration`. */
  technicalContact: ContactSettings_Contact | undefined;
}

/** Details required for a contact associated with a `Registration`. */
export interface ContactSettings_Contact {
  /** Required. Postal address of the contact. */
  postalAddress:
    | PostalAddress
    | undefined;
  /** Required. Email address of the contact. */
  email: string;
  /**
   * Required. Phone number of the contact in international format. For example,
   * `"+1-800-555-0123"`.
   */
  phoneNumber: string;
  /**
   * Fax number of the contact in international format. For example,
   * `"+1-800-555-0123"`.
   */
  faxNumber: string;
}

/** Request for the `SearchDomains` method. */
export interface SearchDomainsRequest {
  /** Required. String used to search for available domain names. */
  query: string;
  /** Required. The location. Must be in the format `projects/* /locations/*`. */
  location: string;
}

/** Response for the `SearchDomains` method. */
export interface SearchDomainsResponse {
  /** Results of the domain name search. */
  registerParameters: RegisterParameters[];
}

/** Request for the `RetrieveRegisterParameters` method. */
export interface RetrieveRegisterParametersRequest {
  /** Required. The domain name. Unicode domain names must be expressed in Punycode format. */
  domainName: string;
  /** Required. The location. Must be in the format `projects/* /locations/*`. */
  location: string;
}

/** Response for the `RetrieveRegisterParameters` method. */
export interface RetrieveRegisterParametersResponse {
  /** Parameters to use when calling the `RegisterDomain` method. */
  registerParameters: RegisterParameters | undefined;
}

/** Request for the `RegisterDomain` method. */
export interface RegisterDomainRequest {
  /**
   * Required. The parent resource of the `Registration`. Must be in the
   * format `projects/* /locations/*`.
   */
  parent: string;
  /** Required. The complete `Registration` resource to be created. */
  registration:
    | Registration
    | undefined;
  /**
   * The list of domain notices that you acknowledge. Call
   * `RetrieveRegisterParameters` to see the notices that need acknowledgement.
   */
  domainNotices: DomainNotice[];
  /**
   * The list of contact notices that the caller acknowledges. The notices
   * needed here depend on the values specified in
   * `registration.contact_settings`.
   */
  contactNotices: ContactNotice[];
  /**
   * Required. Yearly price to register or renew the domain.
   * The value that should be put here can be obtained from
   * RetrieveRegisterParameters or SearchDomains calls.
   */
  yearlyPrice:
    | Money
    | undefined;
  /**
   * When true, only validation is performed, without actually registering
   * the domain. Follows:
   * https://cloud.google.com/apis/design/design_patterns#request_validation
   */
  validateOnly: boolean;
}

/** Request for the `RetrieveTransferParameters` method. */
export interface RetrieveTransferParametersRequest {
  /** Required. The domain name. Unicode domain names must be expressed in Punycode format. */
  domainName: string;
  /** Required. The location. Must be in the format `projects/* /locations/*`. */
  location: string;
}

/** Response for the `RetrieveTransferParameters` method. */
export interface RetrieveTransferParametersResponse {
  /** Parameters to use when calling the `TransferDomain` method. */
  transferParameters: TransferParameters | undefined;
}

/** Request for the `TransferDomain` method. */
export interface TransferDomainRequest {
  /**
   * Required. The parent resource of the `Registration`. Must be in the
   * format `projects/* /locations/*`.
   */
  parent: string;
  /**
   * Required. The complete `Registration` resource to be created.
   *
   * You can leave `registration.dns_settings` unset to import the
   * domain's current DNS configuration from its current registrar. Use this
   * option only if you are sure that the domain's current DNS service
   * does not cease upon transfer, as is often the case for DNS services
   * provided for free by the registrar.
   */
  registration:
    | Registration
    | undefined;
  /**
   * The list of contact notices that you acknowledge. The notices
   * needed here depend on the values specified in
   * `registration.contact_settings`.
   */
  contactNotices: ContactNotice[];
  /**
   * Required. Acknowledgement of the price to transfer or renew the domain for one year.
   * Call `RetrieveTransferParameters` to obtain the price, which you must
   * acknowledge.
   */
  yearlyPrice:
    | Money
    | undefined;
  /**
   * The domain's transfer authorization code. You can obtain this from the
   * domain's current registrar.
   */
  authorizationCode:
    | AuthorizationCode
    | undefined;
  /** Validate the request without actually transferring the domain. */
  validateOnly: boolean;
}

/** Request for the `ListRegistrations` method. */
export interface ListRegistrationsRequest {
  /**
   * Required. The project and location from which to list `Registration`s, specified in
   * the format `projects/* /locations/*`.
   */
  parent: string;
  /** Maximum number of results to return. */
  pageSize: number;
  /**
   * When set to the `next_page_token` from a prior response, provides the next
   * page of results.
   */
  pageToken: string;
  /**
   * Filter expression to restrict the `Registration`s returned.
   *
   * The expression must specify the field name, a comparison operator, and the
   * value that you want to use for filtering. The value must be a string, a
   * number, a boolean, or an enum value. The comparison operator should be one
   * of =, !=, >, <, >=, <=, or : for prefix or wildcard matches.
   *
   * For example, to filter to a specific domain name, use an expression like
   * `domainName="example.com"`. You can also check for the existence of a
   * field; for example, to find domains using custom DNS settings, use an
   * expression like `dnsSettings.customDns:*`.
   *
   * You can also create compound filters by combining expressions with the
   * `AND` and `OR` operators. For example, to find domains that are suspended
   * or have specific issues flagged, use an expression like
   * `(state=SUSPENDED) OR (issue:*)`.
   */
  filter: string;
}

/** Response for the `ListRegistrations` method. */
export interface ListRegistrationsResponse {
  /** A list of `Registration`s. */
  registrations: Registration[];
  /**
   * When present, there are more results to retrieve. Set `page_token` to this
   * value on a subsequent call to get the next page of results.
   */
  nextPageToken: string;
}

/** Request for the `GetRegistration` method. */
export interface GetRegistrationRequest {
  /**
   * Required. The name of the `Registration` to get, in the format
   * `projects/* /locations/* /registrations/*`.
   */
  name: string;
}

/** Request for the `UpdateRegistration` method. */
export interface UpdateRegistrationRequest {
  /** Fields of the `Registration` to update. */
  registration:
    | Registration
    | undefined;
  /**
   * Required. The field mask describing which fields to update as a comma-separated list.
   * For example, if only the labels are being updated, the `update_mask` is
   * `"labels"`.
   */
  updateMask: string[] | undefined;
}

/** Request for the `ConfigureManagementSettings` method. */
export interface ConfigureManagementSettingsRequest {
  /**
   * Required. The name of the `Registration` whose management settings are being updated,
   * in the format `projects/* /locations/* /registrations/*`.
   */
  registration: string;
  /** Fields of the `ManagementSettings` to update. */
  managementSettings:
    | ManagementSettings
    | undefined;
  /**
   * Required. The field mask describing which fields to update as a comma-separated list.
   * For example, if only the transfer lock is being updated, the `update_mask`
   * is `"transfer_lock_state"`.
   */
  updateMask: string[] | undefined;
}

/** Request for the `ConfigureDnsSettings` method. */
export interface ConfigureDnsSettingsRequest {
  /**
   * Required. The name of the `Registration` whose DNS settings are being updated,
   * in the format `projects/* /locations/* /registrations/*`.
   */
  registration: string;
  /** Fields of the `DnsSettings` to update. */
  dnsSettings:
    | DnsSettings
    | undefined;
  /**
   * Required. The field mask describing which fields to update as a comma-separated list.
   * For example, if only the name servers are being updated for an existing
   * Custom DNS configuration, the `update_mask` is
   * `"custom_dns.name_servers"`.
   *
   * When changing the DNS provider from one type to another, pass the new
   * provider's field name as part of the field mask. For example, when changing
   * from a Google Domains DNS configuration to a Custom DNS configuration, the
   * `update_mask` is `"custom_dns"`. //
   */
  updateMask:
    | string[]
    | undefined;
  /** Validate the request without actually updating the DNS settings. */
  validateOnly: boolean;
}

/** Request for the `ConfigureContactSettings` method. */
export interface ConfigureContactSettingsRequest {
  /**
   * Required. The name of the `Registration` whose contact settings are being updated,
   * in the format `projects/* /locations/* /registrations/*`.
   */
  registration: string;
  /** Fields of the `ContactSettings` to update. */
  contactSettings:
    | ContactSettings
    | undefined;
  /**
   * Required. The field mask describing which fields to update as a comma-separated list.
   * For example, if only the registrant contact is being updated, the
   * `update_mask` is `"registrant_contact"`.
   */
  updateMask:
    | string[]
    | undefined;
  /**
   * The list of contact notices that the caller acknowledges. The notices
   * needed here depend on the values specified in `contact_settings`.
   */
  contactNotices: ContactNotice[];
  /** Validate the request without actually updating the contact settings. */
  validateOnly: boolean;
}

/** Request for the `ExportRegistration` method. */
export interface ExportRegistrationRequest {
  /**
   * Required. The name of the `Registration` to export,
   * in the format `projects/* /locations/* /registrations/*`.
   */
  name: string;
}

/** Request for the `DeleteRegistration` method. */
export interface DeleteRegistrationRequest {
  /**
   * Required. The name of the `Registration` to delete,
   * in the format `projects/* /locations/* /registrations/*`.
   */
  name: string;
}

/** Request for the `RetrieveAuthorizationCode` method. */
export interface RetrieveAuthorizationCodeRequest {
  /**
   * Required. The name of the `Registration` whose authorization code is being retrieved,
   * in the format `projects/* /locations/* /registrations/*`.
   */
  registration: string;
}

/** Request for the `ResetAuthorizationCode` method. */
export interface ResetAuthorizationCodeRequest {
  /**
   * Required. The name of the `Registration` whose authorization code is being reset,
   * in the format `projects/* /locations/* /registrations/*`.
   */
  registration: string;
}

/** Parameters required to register a new domain. */
export interface RegisterParameters {
  /** The domain name. Unicode domain names are expressed in Punycode format. */
  domainName: string;
  /**
   * Indicates whether the domain is available for registration. This value is
   * accurate when obtained by calling `RetrieveRegisterParameters`, but is
   * approximate when obtained by calling `SearchDomains`.
   */
  availability: RegisterParameters_Availability;
  /** Contact privacy options that the domain supports. */
  supportedPrivacy: ContactPrivacy[];
  /** Notices about special properties of the domain. */
  domainNotices: DomainNotice[];
  /** Price to register or renew the domain for one year. */
  yearlyPrice: Money | undefined;
}

/** Possible availability states of a domain name. */
export enum RegisterParameters_Availability {
  /** AVAILABILITY_UNSPECIFIED - The availability is unspecified. */
  AVAILABILITY_UNSPECIFIED = 0,
  /** AVAILABLE - The domain is available for registration. */
  AVAILABLE = 1,
  /**
   * UNAVAILABLE - The domain is not available for registration. Generally this means it is
   * already registered to another party.
   */
  UNAVAILABLE = 2,
  /**
   * UNSUPPORTED - The domain is not currently supported by Cloud Domains, but may
   * be available elsewhere.
   */
  UNSUPPORTED = 3,
  /**
   * UNKNOWN - Cloud Domains is unable to determine domain availability, generally
   * due to system maintenance at the domain name registry.
   */
  UNKNOWN = 4,
  UNRECOGNIZED = -1,
}

export function registerParameters_AvailabilityFromJSON(object: any): RegisterParameters_Availability {
  switch (object) {
    case 0:
    case "AVAILABILITY_UNSPECIFIED":
      return RegisterParameters_Availability.AVAILABILITY_UNSPECIFIED;
    case 1:
    case "AVAILABLE":
      return RegisterParameters_Availability.AVAILABLE;
    case 2:
    case "UNAVAILABLE":
      return RegisterParameters_Availability.UNAVAILABLE;
    case 3:
    case "UNSUPPORTED":
      return RegisterParameters_Availability.UNSUPPORTED;
    case 4:
    case "UNKNOWN":
      return RegisterParameters_Availability.UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RegisterParameters_Availability.UNRECOGNIZED;
  }
}

export function registerParameters_AvailabilityToJSON(object: RegisterParameters_Availability): string {
  switch (object) {
    case RegisterParameters_Availability.AVAILABILITY_UNSPECIFIED:
      return "AVAILABILITY_UNSPECIFIED";
    case RegisterParameters_Availability.AVAILABLE:
      return "AVAILABLE";
    case RegisterParameters_Availability.UNAVAILABLE:
      return "UNAVAILABLE";
    case RegisterParameters_Availability.UNSUPPORTED:
      return "UNSUPPORTED";
    case RegisterParameters_Availability.UNKNOWN:
      return "UNKNOWN";
    case RegisterParameters_Availability.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Parameters required to transfer a domain from another registrar. */
export interface TransferParameters {
  /** The domain name. Unicode domain names are expressed in Punycode format. */
  domainName: string;
  /** The registrar that currently manages the domain. */
  currentRegistrar: string;
  /** The name servers that currently store the configuration of the domain. */
  nameServers: string[];
  /**
   * Indicates whether the domain is protected by a transfer lock. For a
   * transfer to succeed, this must show `UNLOCKED`. To unlock a domain,
   * go to its current registrar.
   */
  transferLockState: TransferLockState;
  /** Contact privacy options that the domain supports. */
  supportedPrivacy: ContactPrivacy[];
  /** Price to transfer or renew the domain for one year. */
  yearlyPrice: Money | undefined;
}

/** Defines an authorization code. */
export interface AuthorizationCode {
  /**
   * The Authorization Code in ASCII. It can be used to transfer the domain
   * to or from another registrar.
   */
  code: string;
}

/** Represents the metadata of the long-running operation. Output only. */
export interface OperationMetadata {
  /** The time the operation was created. */
  createTime:
    | Date
    | undefined;
  /** The time the operation finished running. */
  endTime:
    | Date
    | undefined;
  /** Server-defined resource path for the target of the operation. */
  target: string;
  /** Name of the verb executed by the operation. */
  verb: string;
  /** Human-readable status of the operation, if any. */
  statusDetail: string;
  /** API version used to start the operation. */
  apiVersion: string;
}

function createBaseRegistration(): Registration {
  return {
    name: "",
    domainName: "",
    createTime: undefined,
    expireTime: undefined,
    state: 0,
    issues: [],
    labels: {},
    managementSettings: undefined,
    dnsSettings: undefined,
    contactSettings: undefined,
    pendingContactSettings: undefined,
    supportedPrivacy: [],
  };
}

export const Registration: MessageFns<Registration> = {
  encode(message: Registration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.domainName !== "") {
      writer.uint32(18).string(message.domainName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(50).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    writer.uint32(66).fork();
    for (const v of message.issues) {
      writer.int32(v);
    }
    writer.join();
    Object.entries(message.labels).forEach(([key, value]) => {
      Registration_LabelsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    if (message.managementSettings !== undefined) {
      ManagementSettings.encode(message.managementSettings, writer.uint32(82).fork()).join();
    }
    if (message.dnsSettings !== undefined) {
      DnsSettings.encode(message.dnsSettings, writer.uint32(90).fork()).join();
    }
    if (message.contactSettings !== undefined) {
      ContactSettings.encode(message.contactSettings, writer.uint32(98).fork()).join();
    }
    if (message.pendingContactSettings !== undefined) {
      ContactSettings.encode(message.pendingContactSettings, writer.uint32(106).fork()).join();
    }
    writer.uint32(114).fork();
    for (const v of message.supportedPrivacy) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Registration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegistration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.domainName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag === 64) {
            message.issues.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.issues.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = Registration_LabelsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.labels[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.managementSettings = ManagementSettings.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.dnsSettings = DnsSettings.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.contactSettings = ContactSettings.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.pendingContactSettings = ContactSettings.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag === 112) {
            message.supportedPrivacy.push(reader.int32() as any);

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedPrivacy.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Registration {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      domainName: isSet(object.domainName) ? globalThis.String(object.domainName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      state: isSet(object.state) ? registration_StateFromJSON(object.state) : 0,
      issues: globalThis.Array.isArray(object?.issues)
        ? object.issues.map((e: any) => registration_IssueFromJSON(e))
        : [],
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      managementSettings: isSet(object.managementSettings)
        ? ManagementSettings.fromJSON(object.managementSettings)
        : undefined,
      dnsSettings: isSet(object.dnsSettings) ? DnsSettings.fromJSON(object.dnsSettings) : undefined,
      contactSettings: isSet(object.contactSettings) ? ContactSettings.fromJSON(object.contactSettings) : undefined,
      pendingContactSettings: isSet(object.pendingContactSettings)
        ? ContactSettings.fromJSON(object.pendingContactSettings)
        : undefined,
      supportedPrivacy: globalThis.Array.isArray(object?.supportedPrivacy)
        ? object.supportedPrivacy.map((e: any) => contactPrivacyFromJSON(e))
        : [],
    };
  },

  toJSON(message: Registration): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.domainName !== "") {
      obj.domainName = message.domainName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = registration_StateToJSON(message.state);
    }
    if (message.issues?.length) {
      obj.issues = message.issues.map((e) => registration_IssueToJSON(e));
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.managementSettings !== undefined) {
      obj.managementSettings = ManagementSettings.toJSON(message.managementSettings);
    }
    if (message.dnsSettings !== undefined) {
      obj.dnsSettings = DnsSettings.toJSON(message.dnsSettings);
    }
    if (message.contactSettings !== undefined) {
      obj.contactSettings = ContactSettings.toJSON(message.contactSettings);
    }
    if (message.pendingContactSettings !== undefined) {
      obj.pendingContactSettings = ContactSettings.toJSON(message.pendingContactSettings);
    }
    if (message.supportedPrivacy?.length) {
      obj.supportedPrivacy = message.supportedPrivacy.map((e) => contactPrivacyToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Registration>): Registration {
    return Registration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Registration>): Registration {
    const message = createBaseRegistration();
    message.name = object.name ?? "";
    message.domainName = object.domainName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.state = object.state ?? 0;
    message.issues = object.issues?.map((e) => e) || [];
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.managementSettings = (object.managementSettings !== undefined && object.managementSettings !== null)
      ? ManagementSettings.fromPartial(object.managementSettings)
      : undefined;
    message.dnsSettings = (object.dnsSettings !== undefined && object.dnsSettings !== null)
      ? DnsSettings.fromPartial(object.dnsSettings)
      : undefined;
    message.contactSettings = (object.contactSettings !== undefined && object.contactSettings !== null)
      ? ContactSettings.fromPartial(object.contactSettings)
      : undefined;
    message.pendingContactSettings =
      (object.pendingContactSettings !== undefined && object.pendingContactSettings !== null)
        ? ContactSettings.fromPartial(object.pendingContactSettings)
        : undefined;
    message.supportedPrivacy = object.supportedPrivacy?.map((e) => e) || [];
    return message;
  },
};

function createBaseRegistration_LabelsEntry(): Registration_LabelsEntry {
  return { key: "", value: "" };
}

export const Registration_LabelsEntry: MessageFns<Registration_LabelsEntry> = {
  encode(message: Registration_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Registration_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegistration_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Registration_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Registration_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Registration_LabelsEntry>): Registration_LabelsEntry {
    return Registration_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Registration_LabelsEntry>): Registration_LabelsEntry {
    const message = createBaseRegistration_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseManagementSettings(): ManagementSettings {
  return { renewalMethod: 0, transferLockState: 0 };
}

export const ManagementSettings: MessageFns<ManagementSettings> = {
  encode(message: ManagementSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.renewalMethod !== 0) {
      writer.uint32(24).int32(message.renewalMethod);
    }
    if (message.transferLockState !== 0) {
      writer.uint32(32).int32(message.transferLockState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManagementSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManagementSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.renewalMethod = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.transferLockState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManagementSettings {
    return {
      renewalMethod: isSet(object.renewalMethod) ? managementSettings_RenewalMethodFromJSON(object.renewalMethod) : 0,
      transferLockState: isSet(object.transferLockState) ? transferLockStateFromJSON(object.transferLockState) : 0,
    };
  },

  toJSON(message: ManagementSettings): unknown {
    const obj: any = {};
    if (message.renewalMethod !== 0) {
      obj.renewalMethod = managementSettings_RenewalMethodToJSON(message.renewalMethod);
    }
    if (message.transferLockState !== 0) {
      obj.transferLockState = transferLockStateToJSON(message.transferLockState);
    }
    return obj;
  },

  create(base?: DeepPartial<ManagementSettings>): ManagementSettings {
    return ManagementSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ManagementSettings>): ManagementSettings {
    const message = createBaseManagementSettings();
    message.renewalMethod = object.renewalMethod ?? 0;
    message.transferLockState = object.transferLockState ?? 0;
    return message;
  },
};

function createBaseDnsSettings(): DnsSettings {
  return { customDns: undefined, googleDomainsDns: undefined, glueRecords: [] };
}

export const DnsSettings: MessageFns<DnsSettings> = {
  encode(message: DnsSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customDns !== undefined) {
      DnsSettings_CustomDns.encode(message.customDns, writer.uint32(10).fork()).join();
    }
    if (message.googleDomainsDns !== undefined) {
      DnsSettings_GoogleDomainsDns.encode(message.googleDomainsDns, writer.uint32(18).fork()).join();
    }
    for (const v of message.glueRecords) {
      DnsSettings_GlueRecord.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.customDns = DnsSettings_CustomDns.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.googleDomainsDns = DnsSettings_GoogleDomainsDns.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.glueRecords.push(DnsSettings_GlueRecord.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsSettings {
    return {
      customDns: isSet(object.customDns) ? DnsSettings_CustomDns.fromJSON(object.customDns) : undefined,
      googleDomainsDns: isSet(object.googleDomainsDns)
        ? DnsSettings_GoogleDomainsDns.fromJSON(object.googleDomainsDns)
        : undefined,
      glueRecords: globalThis.Array.isArray(object?.glueRecords)
        ? object.glueRecords.map((e: any) => DnsSettings_GlueRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DnsSettings): unknown {
    const obj: any = {};
    if (message.customDns !== undefined) {
      obj.customDns = DnsSettings_CustomDns.toJSON(message.customDns);
    }
    if (message.googleDomainsDns !== undefined) {
      obj.googleDomainsDns = DnsSettings_GoogleDomainsDns.toJSON(message.googleDomainsDns);
    }
    if (message.glueRecords?.length) {
      obj.glueRecords = message.glueRecords.map((e) => DnsSettings_GlueRecord.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DnsSettings>): DnsSettings {
    return DnsSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsSettings>): DnsSettings {
    const message = createBaseDnsSettings();
    message.customDns = (object.customDns !== undefined && object.customDns !== null)
      ? DnsSettings_CustomDns.fromPartial(object.customDns)
      : undefined;
    message.googleDomainsDns = (object.googleDomainsDns !== undefined && object.googleDomainsDns !== null)
      ? DnsSettings_GoogleDomainsDns.fromPartial(object.googleDomainsDns)
      : undefined;
    message.glueRecords = object.glueRecords?.map((e) => DnsSettings_GlueRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDnsSettings_CustomDns(): DnsSettings_CustomDns {
  return { nameServers: [], dsRecords: [] };
}

export const DnsSettings_CustomDns: MessageFns<DnsSettings_CustomDns> = {
  encode(message: DnsSettings_CustomDns, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nameServers) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.dsRecords) {
      DnsSettings_DsRecord.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsSettings_CustomDns {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsSettings_CustomDns();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nameServers.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dsRecords.push(DnsSettings_DsRecord.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsSettings_CustomDns {
    return {
      nameServers: globalThis.Array.isArray(object?.nameServers)
        ? object.nameServers.map((e: any) => globalThis.String(e))
        : [],
      dsRecords: globalThis.Array.isArray(object?.dsRecords)
        ? object.dsRecords.map((e: any) => DnsSettings_DsRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DnsSettings_CustomDns): unknown {
    const obj: any = {};
    if (message.nameServers?.length) {
      obj.nameServers = message.nameServers;
    }
    if (message.dsRecords?.length) {
      obj.dsRecords = message.dsRecords.map((e) => DnsSettings_DsRecord.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DnsSettings_CustomDns>): DnsSettings_CustomDns {
    return DnsSettings_CustomDns.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsSettings_CustomDns>): DnsSettings_CustomDns {
    const message = createBaseDnsSettings_CustomDns();
    message.nameServers = object.nameServers?.map((e) => e) || [];
    message.dsRecords = object.dsRecords?.map((e) => DnsSettings_DsRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDnsSettings_GoogleDomainsDns(): DnsSettings_GoogleDomainsDns {
  return { nameServers: [], dsState: 0, dsRecords: [] };
}

export const DnsSettings_GoogleDomainsDns: MessageFns<DnsSettings_GoogleDomainsDns> = {
  encode(message: DnsSettings_GoogleDomainsDns, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nameServers) {
      writer.uint32(10).string(v!);
    }
    if (message.dsState !== 0) {
      writer.uint32(16).int32(message.dsState);
    }
    for (const v of message.dsRecords) {
      DnsSettings_DsRecord.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsSettings_GoogleDomainsDns {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsSettings_GoogleDomainsDns();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nameServers.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.dsState = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.dsRecords.push(DnsSettings_DsRecord.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsSettings_GoogleDomainsDns {
    return {
      nameServers: globalThis.Array.isArray(object?.nameServers)
        ? object.nameServers.map((e: any) => globalThis.String(e))
        : [],
      dsState: isSet(object.dsState) ? dnsSettings_DsStateFromJSON(object.dsState) : 0,
      dsRecords: globalThis.Array.isArray(object?.dsRecords)
        ? object.dsRecords.map((e: any) => DnsSettings_DsRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DnsSettings_GoogleDomainsDns): unknown {
    const obj: any = {};
    if (message.nameServers?.length) {
      obj.nameServers = message.nameServers;
    }
    if (message.dsState !== 0) {
      obj.dsState = dnsSettings_DsStateToJSON(message.dsState);
    }
    if (message.dsRecords?.length) {
      obj.dsRecords = message.dsRecords.map((e) => DnsSettings_DsRecord.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DnsSettings_GoogleDomainsDns>): DnsSettings_GoogleDomainsDns {
    return DnsSettings_GoogleDomainsDns.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsSettings_GoogleDomainsDns>): DnsSettings_GoogleDomainsDns {
    const message = createBaseDnsSettings_GoogleDomainsDns();
    message.nameServers = object.nameServers?.map((e) => e) || [];
    message.dsState = object.dsState ?? 0;
    message.dsRecords = object.dsRecords?.map((e) => DnsSettings_DsRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDnsSettings_DsRecord(): DnsSettings_DsRecord {
  return { keyTag: 0, algorithm: 0, digestType: 0, digest: "" };
}

export const DnsSettings_DsRecord: MessageFns<DnsSettings_DsRecord> = {
  encode(message: DnsSettings_DsRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyTag !== 0) {
      writer.uint32(8).int32(message.keyTag);
    }
    if (message.algorithm !== 0) {
      writer.uint32(16).int32(message.algorithm);
    }
    if (message.digestType !== 0) {
      writer.uint32(24).int32(message.digestType);
    }
    if (message.digest !== "") {
      writer.uint32(34).string(message.digest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsSettings_DsRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsSettings_DsRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.keyTag = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.digestType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.digest = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsSettings_DsRecord {
    return {
      keyTag: isSet(object.keyTag) ? globalThis.Number(object.keyTag) : 0,
      algorithm: isSet(object.algorithm) ? dnsSettings_DsRecord_AlgorithmFromJSON(object.algorithm) : 0,
      digestType: isSet(object.digestType) ? dnsSettings_DsRecord_DigestTypeFromJSON(object.digestType) : 0,
      digest: isSet(object.digest) ? globalThis.String(object.digest) : "",
    };
  },

  toJSON(message: DnsSettings_DsRecord): unknown {
    const obj: any = {};
    if (message.keyTag !== 0) {
      obj.keyTag = Math.round(message.keyTag);
    }
    if (message.algorithm !== 0) {
      obj.algorithm = dnsSettings_DsRecord_AlgorithmToJSON(message.algorithm);
    }
    if (message.digestType !== 0) {
      obj.digestType = dnsSettings_DsRecord_DigestTypeToJSON(message.digestType);
    }
    if (message.digest !== "") {
      obj.digest = message.digest;
    }
    return obj;
  },

  create(base?: DeepPartial<DnsSettings_DsRecord>): DnsSettings_DsRecord {
    return DnsSettings_DsRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsSettings_DsRecord>): DnsSettings_DsRecord {
    const message = createBaseDnsSettings_DsRecord();
    message.keyTag = object.keyTag ?? 0;
    message.algorithm = object.algorithm ?? 0;
    message.digestType = object.digestType ?? 0;
    message.digest = object.digest ?? "";
    return message;
  },
};

function createBaseDnsSettings_GlueRecord(): DnsSettings_GlueRecord {
  return { hostName: "", ipv4Addresses: [], ipv6Addresses: [] };
}

export const DnsSettings_GlueRecord: MessageFns<DnsSettings_GlueRecord> = {
  encode(message: DnsSettings_GlueRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostName !== "") {
      writer.uint32(10).string(message.hostName);
    }
    for (const v of message.ipv4Addresses) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.ipv6Addresses) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DnsSettings_GlueRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDnsSettings_GlueRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.hostName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ipv4Addresses.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipv6Addresses.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DnsSettings_GlueRecord {
    return {
      hostName: isSet(object.hostName) ? globalThis.String(object.hostName) : "",
      ipv4Addresses: globalThis.Array.isArray(object?.ipv4Addresses)
        ? object.ipv4Addresses.map((e: any) => globalThis.String(e))
        : [],
      ipv6Addresses: globalThis.Array.isArray(object?.ipv6Addresses)
        ? object.ipv6Addresses.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: DnsSettings_GlueRecord): unknown {
    const obj: any = {};
    if (message.hostName !== "") {
      obj.hostName = message.hostName;
    }
    if (message.ipv4Addresses?.length) {
      obj.ipv4Addresses = message.ipv4Addresses;
    }
    if (message.ipv6Addresses?.length) {
      obj.ipv6Addresses = message.ipv6Addresses;
    }
    return obj;
  },

  create(base?: DeepPartial<DnsSettings_GlueRecord>): DnsSettings_GlueRecord {
    return DnsSettings_GlueRecord.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DnsSettings_GlueRecord>): DnsSettings_GlueRecord {
    const message = createBaseDnsSettings_GlueRecord();
    message.hostName = object.hostName ?? "";
    message.ipv4Addresses = object.ipv4Addresses?.map((e) => e) || [];
    message.ipv6Addresses = object.ipv6Addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseContactSettings(): ContactSettings {
  return { privacy: 0, registrantContact: undefined, adminContact: undefined, technicalContact: undefined };
}

export const ContactSettings: MessageFns<ContactSettings> = {
  encode(message: ContactSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.privacy !== 0) {
      writer.uint32(8).int32(message.privacy);
    }
    if (message.registrantContact !== undefined) {
      ContactSettings_Contact.encode(message.registrantContact, writer.uint32(18).fork()).join();
    }
    if (message.adminContact !== undefined) {
      ContactSettings_Contact.encode(message.adminContact, writer.uint32(26).fork()).join();
    }
    if (message.technicalContact !== undefined) {
      ContactSettings_Contact.encode(message.technicalContact, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContactSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContactSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.privacy = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.registrantContact = ContactSettings_Contact.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.adminContact = ContactSettings_Contact.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.technicalContact = ContactSettings_Contact.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContactSettings {
    return {
      privacy: isSet(object.privacy) ? contactPrivacyFromJSON(object.privacy) : 0,
      registrantContact: isSet(object.registrantContact)
        ? ContactSettings_Contact.fromJSON(object.registrantContact)
        : undefined,
      adminContact: isSet(object.adminContact) ? ContactSettings_Contact.fromJSON(object.adminContact) : undefined,
      technicalContact: isSet(object.technicalContact)
        ? ContactSettings_Contact.fromJSON(object.technicalContact)
        : undefined,
    };
  },

  toJSON(message: ContactSettings): unknown {
    const obj: any = {};
    if (message.privacy !== 0) {
      obj.privacy = contactPrivacyToJSON(message.privacy);
    }
    if (message.registrantContact !== undefined) {
      obj.registrantContact = ContactSettings_Contact.toJSON(message.registrantContact);
    }
    if (message.adminContact !== undefined) {
      obj.adminContact = ContactSettings_Contact.toJSON(message.adminContact);
    }
    if (message.technicalContact !== undefined) {
      obj.technicalContact = ContactSettings_Contact.toJSON(message.technicalContact);
    }
    return obj;
  },

  create(base?: DeepPartial<ContactSettings>): ContactSettings {
    return ContactSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContactSettings>): ContactSettings {
    const message = createBaseContactSettings();
    message.privacy = object.privacy ?? 0;
    message.registrantContact = (object.registrantContact !== undefined && object.registrantContact !== null)
      ? ContactSettings_Contact.fromPartial(object.registrantContact)
      : undefined;
    message.adminContact = (object.adminContact !== undefined && object.adminContact !== null)
      ? ContactSettings_Contact.fromPartial(object.adminContact)
      : undefined;
    message.technicalContact = (object.technicalContact !== undefined && object.technicalContact !== null)
      ? ContactSettings_Contact.fromPartial(object.technicalContact)
      : undefined;
    return message;
  },
};

function createBaseContactSettings_Contact(): ContactSettings_Contact {
  return { postalAddress: undefined, email: "", phoneNumber: "", faxNumber: "" };
}

export const ContactSettings_Contact: MessageFns<ContactSettings_Contact> = {
  encode(message: ContactSettings_Contact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.postalAddress !== undefined) {
      PostalAddress.encode(message.postalAddress, writer.uint32(10).fork()).join();
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.phoneNumber !== "") {
      writer.uint32(26).string(message.phoneNumber);
    }
    if (message.faxNumber !== "") {
      writer.uint32(34).string(message.faxNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContactSettings_Contact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContactSettings_Contact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.postalAddress = PostalAddress.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.faxNumber = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContactSettings_Contact {
    return {
      postalAddress: isSet(object.postalAddress) ? PostalAddress.fromJSON(object.postalAddress) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      phoneNumber: isSet(object.phoneNumber) ? globalThis.String(object.phoneNumber) : "",
      faxNumber: isSet(object.faxNumber) ? globalThis.String(object.faxNumber) : "",
    };
  },

  toJSON(message: ContactSettings_Contact): unknown {
    const obj: any = {};
    if (message.postalAddress !== undefined) {
      obj.postalAddress = PostalAddress.toJSON(message.postalAddress);
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.phoneNumber !== "") {
      obj.phoneNumber = message.phoneNumber;
    }
    if (message.faxNumber !== "") {
      obj.faxNumber = message.faxNumber;
    }
    return obj;
  },

  create(base?: DeepPartial<ContactSettings_Contact>): ContactSettings_Contact {
    return ContactSettings_Contact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContactSettings_Contact>): ContactSettings_Contact {
    const message = createBaseContactSettings_Contact();
    message.postalAddress = (object.postalAddress !== undefined && object.postalAddress !== null)
      ? PostalAddress.fromPartial(object.postalAddress)
      : undefined;
    message.email = object.email ?? "";
    message.phoneNumber = object.phoneNumber ?? "";
    message.faxNumber = object.faxNumber ?? "";
    return message;
  },
};

function createBaseSearchDomainsRequest(): SearchDomainsRequest {
  return { query: "", location: "" };
}

export const SearchDomainsRequest: MessageFns<SearchDomainsRequest> = {
  encode(message: SearchDomainsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchDomainsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchDomainsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchDomainsRequest {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: SearchDomainsRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchDomainsRequest>): SearchDomainsRequest {
    return SearchDomainsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchDomainsRequest>): SearchDomainsRequest {
    const message = createBaseSearchDomainsRequest();
    message.query = object.query ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseSearchDomainsResponse(): SearchDomainsResponse {
  return { registerParameters: [] };
}

export const SearchDomainsResponse: MessageFns<SearchDomainsResponse> = {
  encode(message: SearchDomainsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.registerParameters) {
      RegisterParameters.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchDomainsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchDomainsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.registerParameters.push(RegisterParameters.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchDomainsResponse {
    return {
      registerParameters: globalThis.Array.isArray(object?.registerParameters)
        ? object.registerParameters.map((e: any) => RegisterParameters.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchDomainsResponse): unknown {
    const obj: any = {};
    if (message.registerParameters?.length) {
      obj.registerParameters = message.registerParameters.map((e) => RegisterParameters.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchDomainsResponse>): SearchDomainsResponse {
    return SearchDomainsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchDomainsResponse>): SearchDomainsResponse {
    const message = createBaseSearchDomainsResponse();
    message.registerParameters = object.registerParameters?.map((e) => RegisterParameters.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRetrieveRegisterParametersRequest(): RetrieveRegisterParametersRequest {
  return { domainName: "", location: "" };
}

export const RetrieveRegisterParametersRequest: MessageFns<RetrieveRegisterParametersRequest> = {
  encode(message: RetrieveRegisterParametersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domainName !== "") {
      writer.uint32(10).string(message.domainName);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrieveRegisterParametersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieveRegisterParametersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domainName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrieveRegisterParametersRequest {
    return {
      domainName: isSet(object.domainName) ? globalThis.String(object.domainName) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: RetrieveRegisterParametersRequest): unknown {
    const obj: any = {};
    if (message.domainName !== "") {
      obj.domainName = message.domainName;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<RetrieveRegisterParametersRequest>): RetrieveRegisterParametersRequest {
    return RetrieveRegisterParametersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetrieveRegisterParametersRequest>): RetrieveRegisterParametersRequest {
    const message = createBaseRetrieveRegisterParametersRequest();
    message.domainName = object.domainName ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseRetrieveRegisterParametersResponse(): RetrieveRegisterParametersResponse {
  return { registerParameters: undefined };
}

export const RetrieveRegisterParametersResponse: MessageFns<RetrieveRegisterParametersResponse> = {
  encode(message: RetrieveRegisterParametersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registerParameters !== undefined) {
      RegisterParameters.encode(message.registerParameters, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrieveRegisterParametersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieveRegisterParametersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.registerParameters = RegisterParameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrieveRegisterParametersResponse {
    return {
      registerParameters: isSet(object.registerParameters)
        ? RegisterParameters.fromJSON(object.registerParameters)
        : undefined,
    };
  },

  toJSON(message: RetrieveRegisterParametersResponse): unknown {
    const obj: any = {};
    if (message.registerParameters !== undefined) {
      obj.registerParameters = RegisterParameters.toJSON(message.registerParameters);
    }
    return obj;
  },

  create(base?: DeepPartial<RetrieveRegisterParametersResponse>): RetrieveRegisterParametersResponse {
    return RetrieveRegisterParametersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetrieveRegisterParametersResponse>): RetrieveRegisterParametersResponse {
    const message = createBaseRetrieveRegisterParametersResponse();
    message.registerParameters = (object.registerParameters !== undefined && object.registerParameters !== null)
      ? RegisterParameters.fromPartial(object.registerParameters)
      : undefined;
    return message;
  },
};

function createBaseRegisterDomainRequest(): RegisterDomainRequest {
  return {
    parent: "",
    registration: undefined,
    domainNotices: [],
    contactNotices: [],
    yearlyPrice: undefined,
    validateOnly: false,
  };
}

export const RegisterDomainRequest: MessageFns<RegisterDomainRequest> = {
  encode(message: RegisterDomainRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.registration !== undefined) {
      Registration.encode(message.registration, writer.uint32(18).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v of message.domainNotices) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.contactNotices) {
      writer.int32(v);
    }
    writer.join();
    if (message.yearlyPrice !== undefined) {
      Money.encode(message.yearlyPrice, writer.uint32(42).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(48).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterDomainRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterDomainRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.registration = Registration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag === 24) {
            message.domainNotices.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.domainNotices.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.contactNotices.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contactNotices.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.yearlyPrice = Money.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterDomainRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      registration: isSet(object.registration) ? Registration.fromJSON(object.registration) : undefined,
      domainNotices: globalThis.Array.isArray(object?.domainNotices)
        ? object.domainNotices.map((e: any) => domainNoticeFromJSON(e))
        : [],
      contactNotices: globalThis.Array.isArray(object?.contactNotices)
        ? object.contactNotices.map((e: any) => contactNoticeFromJSON(e))
        : [],
      yearlyPrice: isSet(object.yearlyPrice) ? Money.fromJSON(object.yearlyPrice) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: RegisterDomainRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.registration !== undefined) {
      obj.registration = Registration.toJSON(message.registration);
    }
    if (message.domainNotices?.length) {
      obj.domainNotices = message.domainNotices.map((e) => domainNoticeToJSON(e));
    }
    if (message.contactNotices?.length) {
      obj.contactNotices = message.contactNotices.map((e) => contactNoticeToJSON(e));
    }
    if (message.yearlyPrice !== undefined) {
      obj.yearlyPrice = Money.toJSON(message.yearlyPrice);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<RegisterDomainRequest>): RegisterDomainRequest {
    return RegisterDomainRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterDomainRequest>): RegisterDomainRequest {
    const message = createBaseRegisterDomainRequest();
    message.parent = object.parent ?? "";
    message.registration = (object.registration !== undefined && object.registration !== null)
      ? Registration.fromPartial(object.registration)
      : undefined;
    message.domainNotices = object.domainNotices?.map((e) => e) || [];
    message.contactNotices = object.contactNotices?.map((e) => e) || [];
    message.yearlyPrice = (object.yearlyPrice !== undefined && object.yearlyPrice !== null)
      ? Money.fromPartial(object.yearlyPrice)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseRetrieveTransferParametersRequest(): RetrieveTransferParametersRequest {
  return { domainName: "", location: "" };
}

export const RetrieveTransferParametersRequest: MessageFns<RetrieveTransferParametersRequest> = {
  encode(message: RetrieveTransferParametersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domainName !== "") {
      writer.uint32(10).string(message.domainName);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrieveTransferParametersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieveTransferParametersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domainName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrieveTransferParametersRequest {
    return {
      domainName: isSet(object.domainName) ? globalThis.String(object.domainName) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: RetrieveTransferParametersRequest): unknown {
    const obj: any = {};
    if (message.domainName !== "") {
      obj.domainName = message.domainName;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<RetrieveTransferParametersRequest>): RetrieveTransferParametersRequest {
    return RetrieveTransferParametersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetrieveTransferParametersRequest>): RetrieveTransferParametersRequest {
    const message = createBaseRetrieveTransferParametersRequest();
    message.domainName = object.domainName ?? "";
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseRetrieveTransferParametersResponse(): RetrieveTransferParametersResponse {
  return { transferParameters: undefined };
}

export const RetrieveTransferParametersResponse: MessageFns<RetrieveTransferParametersResponse> = {
  encode(message: RetrieveTransferParametersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferParameters !== undefined) {
      TransferParameters.encode(message.transferParameters, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrieveTransferParametersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieveTransferParametersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.transferParameters = TransferParameters.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrieveTransferParametersResponse {
    return {
      transferParameters: isSet(object.transferParameters)
        ? TransferParameters.fromJSON(object.transferParameters)
        : undefined,
    };
  },

  toJSON(message: RetrieveTransferParametersResponse): unknown {
    const obj: any = {};
    if (message.transferParameters !== undefined) {
      obj.transferParameters = TransferParameters.toJSON(message.transferParameters);
    }
    return obj;
  },

  create(base?: DeepPartial<RetrieveTransferParametersResponse>): RetrieveTransferParametersResponse {
    return RetrieveTransferParametersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetrieveTransferParametersResponse>): RetrieveTransferParametersResponse {
    const message = createBaseRetrieveTransferParametersResponse();
    message.transferParameters = (object.transferParameters !== undefined && object.transferParameters !== null)
      ? TransferParameters.fromPartial(object.transferParameters)
      : undefined;
    return message;
  },
};

function createBaseTransferDomainRequest(): TransferDomainRequest {
  return {
    parent: "",
    registration: undefined,
    contactNotices: [],
    yearlyPrice: undefined,
    authorizationCode: undefined,
    validateOnly: false,
  };
}

export const TransferDomainRequest: MessageFns<TransferDomainRequest> = {
  encode(message: TransferDomainRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.registration !== undefined) {
      Registration.encode(message.registration, writer.uint32(18).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v of message.contactNotices) {
      writer.int32(v);
    }
    writer.join();
    if (message.yearlyPrice !== undefined) {
      Money.encode(message.yearlyPrice, writer.uint32(34).fork()).join();
    }
    if (message.authorizationCode !== undefined) {
      AuthorizationCode.encode(message.authorizationCode, writer.uint32(42).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(48).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferDomainRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferDomainRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.registration = Registration.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag === 24) {
            message.contactNotices.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contactNotices.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.yearlyPrice = Money.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.authorizationCode = AuthorizationCode.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferDomainRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      registration: isSet(object.registration) ? Registration.fromJSON(object.registration) : undefined,
      contactNotices: globalThis.Array.isArray(object?.contactNotices)
        ? object.contactNotices.map((e: any) => contactNoticeFromJSON(e))
        : [],
      yearlyPrice: isSet(object.yearlyPrice) ? Money.fromJSON(object.yearlyPrice) : undefined,
      authorizationCode: isSet(object.authorizationCode)
        ? AuthorizationCode.fromJSON(object.authorizationCode)
        : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: TransferDomainRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.registration !== undefined) {
      obj.registration = Registration.toJSON(message.registration);
    }
    if (message.contactNotices?.length) {
      obj.contactNotices = message.contactNotices.map((e) => contactNoticeToJSON(e));
    }
    if (message.yearlyPrice !== undefined) {
      obj.yearlyPrice = Money.toJSON(message.yearlyPrice);
    }
    if (message.authorizationCode !== undefined) {
      obj.authorizationCode = AuthorizationCode.toJSON(message.authorizationCode);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<TransferDomainRequest>): TransferDomainRequest {
    return TransferDomainRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferDomainRequest>): TransferDomainRequest {
    const message = createBaseTransferDomainRequest();
    message.parent = object.parent ?? "";
    message.registration = (object.registration !== undefined && object.registration !== null)
      ? Registration.fromPartial(object.registration)
      : undefined;
    message.contactNotices = object.contactNotices?.map((e) => e) || [];
    message.yearlyPrice = (object.yearlyPrice !== undefined && object.yearlyPrice !== null)
      ? Money.fromPartial(object.yearlyPrice)
      : undefined;
    message.authorizationCode = (object.authorizationCode !== undefined && object.authorizationCode !== null)
      ? AuthorizationCode.fromPartial(object.authorizationCode)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseListRegistrationsRequest(): ListRegistrationsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListRegistrationsRequest: MessageFns<ListRegistrationsRequest> = {
  encode(message: ListRegistrationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRegistrationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRegistrationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRegistrationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListRegistrationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRegistrationsRequest>): ListRegistrationsRequest {
    return ListRegistrationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRegistrationsRequest>): ListRegistrationsRequest {
    const message = createBaseListRegistrationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListRegistrationsResponse(): ListRegistrationsResponse {
  return { registrations: [], nextPageToken: "" };
}

export const ListRegistrationsResponse: MessageFns<ListRegistrationsResponse> = {
  encode(message: ListRegistrationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.registrations) {
      Registration.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRegistrationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRegistrationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.registrations.push(Registration.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRegistrationsResponse {
    return {
      registrations: globalThis.Array.isArray(object?.registrations)
        ? object.registrations.map((e: any) => Registration.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListRegistrationsResponse): unknown {
    const obj: any = {};
    if (message.registrations?.length) {
      obj.registrations = message.registrations.map((e) => Registration.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRegistrationsResponse>): ListRegistrationsResponse {
    return ListRegistrationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRegistrationsResponse>): ListRegistrationsResponse {
    const message = createBaseListRegistrationsResponse();
    message.registrations = object.registrations?.map((e) => Registration.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetRegistrationRequest(): GetRegistrationRequest {
  return { name: "" };
}

export const GetRegistrationRequest: MessageFns<GetRegistrationRequest> = {
  encode(message: GetRegistrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRegistrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRegistrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRegistrationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetRegistrationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRegistrationRequest>): GetRegistrationRequest {
    return GetRegistrationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRegistrationRequest>): GetRegistrationRequest {
    const message = createBaseGetRegistrationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateRegistrationRequest(): UpdateRegistrationRequest {
  return { registration: undefined, updateMask: undefined };
}

export const UpdateRegistrationRequest: MessageFns<UpdateRegistrationRequest> = {
  encode(message: UpdateRegistrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registration !== undefined) {
      Registration.encode(message.registration, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRegistrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRegistrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.registration = Registration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRegistrationRequest {
    return {
      registration: isSet(object.registration) ? Registration.fromJSON(object.registration) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: UpdateRegistrationRequest): unknown {
    const obj: any = {};
    if (message.registration !== undefined) {
      obj.registration = Registration.toJSON(message.registration);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateRegistrationRequest>): UpdateRegistrationRequest {
    return UpdateRegistrationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateRegistrationRequest>): UpdateRegistrationRequest {
    const message = createBaseUpdateRegistrationRequest();
    message.registration = (object.registration !== undefined && object.registration !== null)
      ? Registration.fromPartial(object.registration)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseConfigureManagementSettingsRequest(): ConfigureManagementSettingsRequest {
  return { registration: "", managementSettings: undefined, updateMask: undefined };
}

export const ConfigureManagementSettingsRequest: MessageFns<ConfigureManagementSettingsRequest> = {
  encode(message: ConfigureManagementSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registration !== "") {
      writer.uint32(10).string(message.registration);
    }
    if (message.managementSettings !== undefined) {
      ManagementSettings.encode(message.managementSettings, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigureManagementSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigureManagementSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.registration = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.managementSettings = ManagementSettings.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigureManagementSettingsRequest {
    return {
      registration: isSet(object.registration) ? globalThis.String(object.registration) : "",
      managementSettings: isSet(object.managementSettings)
        ? ManagementSettings.fromJSON(object.managementSettings)
        : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
    };
  },

  toJSON(message: ConfigureManagementSettingsRequest): unknown {
    const obj: any = {};
    if (message.registration !== "") {
      obj.registration = message.registration;
    }
    if (message.managementSettings !== undefined) {
      obj.managementSettings = ManagementSettings.toJSON(message.managementSettings);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigureManagementSettingsRequest>): ConfigureManagementSettingsRequest {
    return ConfigureManagementSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigureManagementSettingsRequest>): ConfigureManagementSettingsRequest {
    const message = createBaseConfigureManagementSettingsRequest();
    message.registration = object.registration ?? "";
    message.managementSettings = (object.managementSettings !== undefined && object.managementSettings !== null)
      ? ManagementSettings.fromPartial(object.managementSettings)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    return message;
  },
};

function createBaseConfigureDnsSettingsRequest(): ConfigureDnsSettingsRequest {
  return { registration: "", dnsSettings: undefined, updateMask: undefined, validateOnly: false };
}

export const ConfigureDnsSettingsRequest: MessageFns<ConfigureDnsSettingsRequest> = {
  encode(message: ConfigureDnsSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registration !== "") {
      writer.uint32(10).string(message.registration);
    }
    if (message.dnsSettings !== undefined) {
      DnsSettings.encode(message.dnsSettings, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigureDnsSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigureDnsSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.registration = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dnsSettings = DnsSettings.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigureDnsSettingsRequest {
    return {
      registration: isSet(object.registration) ? globalThis.String(object.registration) : "",
      dnsSettings: isSet(object.dnsSettings) ? DnsSettings.fromJSON(object.dnsSettings) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: ConfigureDnsSettingsRequest): unknown {
    const obj: any = {};
    if (message.registration !== "") {
      obj.registration = message.registration;
    }
    if (message.dnsSettings !== undefined) {
      obj.dnsSettings = DnsSettings.toJSON(message.dnsSettings);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigureDnsSettingsRequest>): ConfigureDnsSettingsRequest {
    return ConfigureDnsSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigureDnsSettingsRequest>): ConfigureDnsSettingsRequest {
    const message = createBaseConfigureDnsSettingsRequest();
    message.registration = object.registration ?? "";
    message.dnsSettings = (object.dnsSettings !== undefined && object.dnsSettings !== null)
      ? DnsSettings.fromPartial(object.dnsSettings)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseConfigureContactSettingsRequest(): ConfigureContactSettingsRequest {
  return {
    registration: "",
    contactSettings: undefined,
    updateMask: undefined,
    contactNotices: [],
    validateOnly: false,
  };
}

export const ConfigureContactSettingsRequest: MessageFns<ConfigureContactSettingsRequest> = {
  encode(message: ConfigureContactSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registration !== "") {
      writer.uint32(10).string(message.registration);
    }
    if (message.contactSettings !== undefined) {
      ContactSettings.encode(message.contactSettings, writer.uint32(18).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.contactNotices) {
      writer.int32(v);
    }
    writer.join();
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigureContactSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigureContactSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.registration = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contactSettings = ContactSettings.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag === 32) {
            message.contactNotices.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contactNotices.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigureContactSettingsRequest {
    return {
      registration: isSet(object.registration) ? globalThis.String(object.registration) : "",
      contactSettings: isSet(object.contactSettings) ? ContactSettings.fromJSON(object.contactSettings) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      contactNotices: globalThis.Array.isArray(object?.contactNotices)
        ? object.contactNotices.map((e: any) => contactNoticeFromJSON(e))
        : [],
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: ConfigureContactSettingsRequest): unknown {
    const obj: any = {};
    if (message.registration !== "") {
      obj.registration = message.registration;
    }
    if (message.contactSettings !== undefined) {
      obj.contactSettings = ContactSettings.toJSON(message.contactSettings);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.contactNotices?.length) {
      obj.contactNotices = message.contactNotices.map((e) => contactNoticeToJSON(e));
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<ConfigureContactSettingsRequest>): ConfigureContactSettingsRequest {
    return ConfigureContactSettingsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfigureContactSettingsRequest>): ConfigureContactSettingsRequest {
    const message = createBaseConfigureContactSettingsRequest();
    message.registration = object.registration ?? "";
    message.contactSettings = (object.contactSettings !== undefined && object.contactSettings !== null)
      ? ContactSettings.fromPartial(object.contactSettings)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.contactNotices = object.contactNotices?.map((e) => e) || [];
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseExportRegistrationRequest(): ExportRegistrationRequest {
  return { name: "" };
}

export const ExportRegistrationRequest: MessageFns<ExportRegistrationRequest> = {
  encode(message: ExportRegistrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportRegistrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportRegistrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportRegistrationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: ExportRegistrationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportRegistrationRequest>): ExportRegistrationRequest {
    return ExportRegistrationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportRegistrationRequest>): ExportRegistrationRequest {
    const message = createBaseExportRegistrationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteRegistrationRequest(): DeleteRegistrationRequest {
  return { name: "" };
}

export const DeleteRegistrationRequest: MessageFns<DeleteRegistrationRequest> = {
  encode(message: DeleteRegistrationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRegistrationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRegistrationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRegistrationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteRegistrationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteRegistrationRequest>): DeleteRegistrationRequest {
    return DeleteRegistrationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteRegistrationRequest>): DeleteRegistrationRequest {
    const message = createBaseDeleteRegistrationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseRetrieveAuthorizationCodeRequest(): RetrieveAuthorizationCodeRequest {
  return { registration: "" };
}

export const RetrieveAuthorizationCodeRequest: MessageFns<RetrieveAuthorizationCodeRequest> = {
  encode(message: RetrieveAuthorizationCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registration !== "") {
      writer.uint32(10).string(message.registration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrieveAuthorizationCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieveAuthorizationCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.registration = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrieveAuthorizationCodeRequest {
    return { registration: isSet(object.registration) ? globalThis.String(object.registration) : "" };
  },

  toJSON(message: RetrieveAuthorizationCodeRequest): unknown {
    const obj: any = {};
    if (message.registration !== "") {
      obj.registration = message.registration;
    }
    return obj;
  },

  create(base?: DeepPartial<RetrieveAuthorizationCodeRequest>): RetrieveAuthorizationCodeRequest {
    return RetrieveAuthorizationCodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RetrieveAuthorizationCodeRequest>): RetrieveAuthorizationCodeRequest {
    const message = createBaseRetrieveAuthorizationCodeRequest();
    message.registration = object.registration ?? "";
    return message;
  },
};

function createBaseResetAuthorizationCodeRequest(): ResetAuthorizationCodeRequest {
  return { registration: "" };
}

export const ResetAuthorizationCodeRequest: MessageFns<ResetAuthorizationCodeRequest> = {
  encode(message: ResetAuthorizationCodeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.registration !== "") {
      writer.uint32(10).string(message.registration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetAuthorizationCodeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetAuthorizationCodeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.registration = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetAuthorizationCodeRequest {
    return { registration: isSet(object.registration) ? globalThis.String(object.registration) : "" };
  },

  toJSON(message: ResetAuthorizationCodeRequest): unknown {
    const obj: any = {};
    if (message.registration !== "") {
      obj.registration = message.registration;
    }
    return obj;
  },

  create(base?: DeepPartial<ResetAuthorizationCodeRequest>): ResetAuthorizationCodeRequest {
    return ResetAuthorizationCodeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResetAuthorizationCodeRequest>): ResetAuthorizationCodeRequest {
    const message = createBaseResetAuthorizationCodeRequest();
    message.registration = object.registration ?? "";
    return message;
  },
};

function createBaseRegisterParameters(): RegisterParameters {
  return { domainName: "", availability: 0, supportedPrivacy: [], domainNotices: [], yearlyPrice: undefined };
}

export const RegisterParameters: MessageFns<RegisterParameters> = {
  encode(message: RegisterParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domainName !== "") {
      writer.uint32(10).string(message.domainName);
    }
    if (message.availability !== 0) {
      writer.uint32(16).int32(message.availability);
    }
    writer.uint32(26).fork();
    for (const v of message.supportedPrivacy) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.domainNotices) {
      writer.int32(v);
    }
    writer.join();
    if (message.yearlyPrice !== undefined) {
      Money.encode(message.yearlyPrice, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domainName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.availability = reader.int32() as any;
          continue;
        case 3:
          if (tag === 24) {
            message.supportedPrivacy.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedPrivacy.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 4:
          if (tag === 32) {
            message.domainNotices.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.domainNotices.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.yearlyPrice = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterParameters {
    return {
      domainName: isSet(object.domainName) ? globalThis.String(object.domainName) : "",
      availability: isSet(object.availability) ? registerParameters_AvailabilityFromJSON(object.availability) : 0,
      supportedPrivacy: globalThis.Array.isArray(object?.supportedPrivacy)
        ? object.supportedPrivacy.map((e: any) => contactPrivacyFromJSON(e))
        : [],
      domainNotices: globalThis.Array.isArray(object?.domainNotices)
        ? object.domainNotices.map((e: any) => domainNoticeFromJSON(e))
        : [],
      yearlyPrice: isSet(object.yearlyPrice) ? Money.fromJSON(object.yearlyPrice) : undefined,
    };
  },

  toJSON(message: RegisterParameters): unknown {
    const obj: any = {};
    if (message.domainName !== "") {
      obj.domainName = message.domainName;
    }
    if (message.availability !== 0) {
      obj.availability = registerParameters_AvailabilityToJSON(message.availability);
    }
    if (message.supportedPrivacy?.length) {
      obj.supportedPrivacy = message.supportedPrivacy.map((e) => contactPrivacyToJSON(e));
    }
    if (message.domainNotices?.length) {
      obj.domainNotices = message.domainNotices.map((e) => domainNoticeToJSON(e));
    }
    if (message.yearlyPrice !== undefined) {
      obj.yearlyPrice = Money.toJSON(message.yearlyPrice);
    }
    return obj;
  },

  create(base?: DeepPartial<RegisterParameters>): RegisterParameters {
    return RegisterParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegisterParameters>): RegisterParameters {
    const message = createBaseRegisterParameters();
    message.domainName = object.domainName ?? "";
    message.availability = object.availability ?? 0;
    message.supportedPrivacy = object.supportedPrivacy?.map((e) => e) || [];
    message.domainNotices = object.domainNotices?.map((e) => e) || [];
    message.yearlyPrice = (object.yearlyPrice !== undefined && object.yearlyPrice !== null)
      ? Money.fromPartial(object.yearlyPrice)
      : undefined;
    return message;
  },
};

function createBaseTransferParameters(): TransferParameters {
  return {
    domainName: "",
    currentRegistrar: "",
    nameServers: [],
    transferLockState: 0,
    supportedPrivacy: [],
    yearlyPrice: undefined,
  };
}

export const TransferParameters: MessageFns<TransferParameters> = {
  encode(message: TransferParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.domainName !== "") {
      writer.uint32(10).string(message.domainName);
    }
    if (message.currentRegistrar !== "") {
      writer.uint32(18).string(message.currentRegistrar);
    }
    for (const v of message.nameServers) {
      writer.uint32(26).string(v!);
    }
    if (message.transferLockState !== 0) {
      writer.uint32(32).int32(message.transferLockState);
    }
    writer.uint32(42).fork();
    for (const v of message.supportedPrivacy) {
      writer.int32(v);
    }
    writer.join();
    if (message.yearlyPrice !== undefined) {
      Money.encode(message.yearlyPrice, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.domainName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currentRegistrar = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nameServers.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.transferLockState = reader.int32() as any;
          continue;
        case 5:
          if (tag === 40) {
            message.supportedPrivacy.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedPrivacy.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.yearlyPrice = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferParameters {
    return {
      domainName: isSet(object.domainName) ? globalThis.String(object.domainName) : "",
      currentRegistrar: isSet(object.currentRegistrar) ? globalThis.String(object.currentRegistrar) : "",
      nameServers: globalThis.Array.isArray(object?.nameServers)
        ? object.nameServers.map((e: any) => globalThis.String(e))
        : [],
      transferLockState: isSet(object.transferLockState) ? transferLockStateFromJSON(object.transferLockState) : 0,
      supportedPrivacy: globalThis.Array.isArray(object?.supportedPrivacy)
        ? object.supportedPrivacy.map((e: any) => contactPrivacyFromJSON(e))
        : [],
      yearlyPrice: isSet(object.yearlyPrice) ? Money.fromJSON(object.yearlyPrice) : undefined,
    };
  },

  toJSON(message: TransferParameters): unknown {
    const obj: any = {};
    if (message.domainName !== "") {
      obj.domainName = message.domainName;
    }
    if (message.currentRegistrar !== "") {
      obj.currentRegistrar = message.currentRegistrar;
    }
    if (message.nameServers?.length) {
      obj.nameServers = message.nameServers;
    }
    if (message.transferLockState !== 0) {
      obj.transferLockState = transferLockStateToJSON(message.transferLockState);
    }
    if (message.supportedPrivacy?.length) {
      obj.supportedPrivacy = message.supportedPrivacy.map((e) => contactPrivacyToJSON(e));
    }
    if (message.yearlyPrice !== undefined) {
      obj.yearlyPrice = Money.toJSON(message.yearlyPrice);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferParameters>): TransferParameters {
    return TransferParameters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferParameters>): TransferParameters {
    const message = createBaseTransferParameters();
    message.domainName = object.domainName ?? "";
    message.currentRegistrar = object.currentRegistrar ?? "";
    message.nameServers = object.nameServers?.map((e) => e) || [];
    message.transferLockState = object.transferLockState ?? 0;
    message.supportedPrivacy = object.supportedPrivacy?.map((e) => e) || [];
    message.yearlyPrice = (object.yearlyPrice !== undefined && object.yearlyPrice !== null)
      ? Money.fromPartial(object.yearlyPrice)
      : undefined;
    return message;
  },
};

function createBaseAuthorizationCode(): AuthorizationCode {
  return { code: "" };
}

export const AuthorizationCode: MessageFns<AuthorizationCode> = {
  encode(message: AuthorizationCode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationCode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationCode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizationCode {
    return { code: isSet(object.code) ? globalThis.String(object.code) : "" };
  },

  toJSON(message: AuthorizationCode): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    return obj;
  },

  create(base?: DeepPartial<AuthorizationCode>): AuthorizationCode {
    return AuthorizationCode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthorizationCode>): AuthorizationCode {
    const message = createBaseAuthorizationCode();
    message.code = object.code ?? "";
    return message;
  },
};

function createBaseOperationMetadata(): OperationMetadata {
  return { createTime: undefined, endTime: undefined, target: "", verb: "", statusDetail: "", apiVersion: "" };
}

export const OperationMetadata: MessageFns<OperationMetadata> = {
  encode(message: OperationMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(18).fork()).join();
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.verb !== "") {
      writer.uint32(34).string(message.verb);
    }
    if (message.statusDetail !== "") {
      writer.uint32(42).string(message.statusDetail);
    }
    if (message.apiVersion !== "") {
      writer.uint32(50).string(message.apiVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.verb = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.statusDetail = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OperationMetadata {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      verb: isSet(object.verb) ? globalThis.String(object.verb) : "",
      statusDetail: isSet(object.statusDetail) ? globalThis.String(object.statusDetail) : "",
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : "",
    };
  },

  toJSON(message: OperationMetadata): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.verb !== "") {
      obj.verb = message.verb;
    }
    if (message.statusDetail !== "") {
      obj.statusDetail = message.statusDetail;
    }
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<OperationMetadata>): OperationMetadata {
    return OperationMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationMetadata>): OperationMetadata {
    const message = createBaseOperationMetadata();
    message.createTime = object.createTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.target = object.target ?? "";
    message.verb = object.verb ?? "";
    message.statusDetail = object.statusDetail ?? "";
    message.apiVersion = object.apiVersion ?? "";
    return message;
  },
};

/** The Cloud Domains API enables management and configuration of domain names. */
export type DomainsDefinition = typeof DomainsDefinition;
export const DomainsDefinition = {
  name: "Domains",
  fullName: "google.cloud.domains.v1alpha2.Domains",
  methods: {
    /**
     * Searches for available domain names similar to the provided query.
     *
     * Availability results from this method are approximate; call
     * `RetrieveRegisterParameters` on a domain before registering to confirm
     * availability.
     */
    searchDomains: {
      name: "SearchDomains",
      requestType: SearchDomainsRequest,
      requestStream: false,
      responseType: SearchDomainsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([14, 108, 111, 99, 97, 116, 105, 111, 110, 44, 113, 117, 101, 114, 121])],
          578365826: [
            Buffer.from([
              73,
              18,
              71,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              68,
              111,
              109,
              97,
              105,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Gets parameters needed to register a new domain name, including price and
     * up-to-date availability. Use the returned values to call `RegisterDomain`.
     */
    retrieveRegisterParameters: {
      name: "RetrieveRegisterParameters",
      requestType: RetrieveRegisterParametersRequest,
      requestStream: false,
      responseType: RetrieveRegisterParametersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              44,
              100,
              111,
              109,
              97,
              105,
              110,
              95,
              110,
              97,
              109,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              86,
              18,
              84,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              58,
              114,
              101,
              116,
              114,
              105,
              101,
              118,
              101,
              82,
              101,
              103,
              105,
              115,
              116,
              101,
              114,
              80,
              97,
              114,
              97,
              109,
              101,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Registers a new domain name and creates a corresponding `Registration`
     * resource.
     *
     * Call `RetrieveRegisterParameters` first to check availability of the domain
     * name and determine parameters like price that are needed to build a call to
     * this method.
     *
     * A successful call creates a `Registration` resource in state
     * `REGISTRATION_PENDING`, which resolves to `ACTIVE` within 1-2
     * minutes, indicating that the domain was successfully registered. If the
     * resource ends up in state `REGISTRATION_FAILED`, it indicates that the
     * domain was not registered successfully, and you can safely delete the
     * resource and retry registration.
     */
    registerDomain: {
      name: "RegisterDomain",
      requestType: RegisterDomainRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              82,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              32,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              44,
              121,
              101,
              97,
              114,
              108,
              121,
              95,
              112,
              114,
              105,
              99,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              58,
              114,
              101,
              103,
              105,
              115,
              116,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /**
     * Gets parameters needed to transfer a domain name from another registrar to
     * Cloud Domains. For domains managed by Google Domains, transferring to Cloud
     * Domains is not supported.
     *
     * Use the returned values to call `TransferDomain`.
     */
    retrieveTransferParameters: {
      name: "RetrieveTransferParameters",
      requestType: RetrieveTransferParametersRequest,
      requestStream: false,
      responseType: RetrieveTransferParametersResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              20,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              44,
              100,
              111,
              109,
              97,
              105,
              110,
              95,
              110,
              97,
              109,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              86,
              18,
              84,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              58,
              114,
              101,
              116,
              114,
              105,
              101,
              118,
              101,
              84,
              114,
              97,
              110,
              115,
              102,
              101,
              114,
              80,
              97,
              114,
              97,
              109,
              101,
              116,
              101,
              114,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Transfers a domain name from another registrar to Cloud Domains.  For
     * domains managed by Google Domains, transferring to Cloud Domains is not
     * supported.
     *
     * Before calling this method, go to the domain's current registrar to unlock
     * the domain for transfer and retrieve the domain's transfer authorization
     * code. Then call `RetrieveTransferParameters` to confirm that the domain is
     * unlocked and to get values needed to build a call to this method.
     *
     * A successful call creates a `Registration` resource in state
     * `TRANSFER_PENDING`. It can take several days to complete the transfer
     * process. The registrant can often speed up this process by approving the
     * transfer through the current registrar, either by clicking a link in an
     * email from the registrar or by visiting the registrar's website.
     *
     * A few minutes after transfer approval, the resource transitions to state
     * `ACTIVE`, indicating that the transfer was successful. If the transfer is
     * rejected or the request expires without being approved, the resource can
     * end up in state `TRANSFER_FAILED`. If transfer fails, you can safely delete
     * the resource and retry the transfer.
     */
    transferDomain: {
      name: "TransferDomain",
      requestType: TransferDomainRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              82,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              51,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              44,
              121,
              101,
              97,
              114,
              108,
              121,
              95,
              112,
              114,
              105,
              99,
              101,
              44,
              97,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              111,
              100,
              101,
            ]),
          ],
          578365826: [
            Buffer.from([
              69,
              58,
              1,
              42,
              34,
              64,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              58,
              116,
              114,
              97,
              110,
              115,
              102,
              101,
              114,
            ]),
          ],
        },
      },
    },
    /** Lists the `Registration` resources in a project. */
    listRegistrations: {
      name: "ListRegistrations",
      requestType: ListRegistrationsRequest,
      requestStream: false,
      responseType: ListRegistrationsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              57,
              18,
              55,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets the details of a `Registration` resource. */
    getRegistration: {
      name: "GetRegistration",
      requestType: GetRegistrationRequest,
      requestStream: false,
      responseType: Registration,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              57,
              18,
              55,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Updates select fields of a `Registration` resource, notably `labels`. To
     * update other fields, use the appropriate custom update method:
     *
     * * To update management settings, see `ConfigureManagementSettings`
     * * To update DNS configuration, see `ConfigureDnsSettings`
     * * To update contact information, see `ConfigureContactSettings`
     */
    updateRegistration: {
      name: "UpdateRegistration",
      requestType: UpdateRegistrationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              82,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              24,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              84,
              58,
              12,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              50,
              68,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Updates a `Registration`'s management settings. */
    configureManagementSettings: {
      name: "ConfigureManagementSettings",
      requestType: ConfigureManagementSettingsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              82,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              44,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              44,
              109,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              95,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              96,
              58,
              1,
              42,
              34,
              91,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              77,
              97,
              110,
              97,
              103,
              101,
              109,
              101,
              110,
              116,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a `Registration`'s DNS settings. */
    configureDnsSettings: {
      name: "ConfigureDnsSettings",
      requestType: ConfigureDnsSettingsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              82,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              37,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              44,
              100,
              110,
              115,
              95,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              89,
              58,
              1,
              42,
              34,
              84,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              68,
              110,
              115,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Updates a `Registration`'s contact settings. Some changes require
     * confirmation by the domain's registrant contact .
     */
    configureContactSettings: {
      name: "ConfigureContactSettings",
      requestType: ConfigureContactSettingsRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              82,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              41,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              44,
              99,
              111,
              110,
              116,
              97,
              99,
              116,
              95,
              115,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              93,
              58,
              1,
              42,
              34,
              88,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              110,
              102,
              105,
              103,
              117,
              114,
              101,
              67,
              111,
              110,
              116,
              97,
              99,
              116,
              83,
              101,
              116,
              116,
              105,
              110,
              103,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Exports a `Registration` resource, such that it is no longer managed by
     * Cloud Domains.
     *
     * When an active domain is successfully exported, you can continue to use the
     * domain in [Google Domains](https://domains.google/) until it expires. The
     * calling user becomes the domain's sole owner in Google Domains, and
     * permissions for the domain are subsequently managed there. The domain does
     * not renew automatically unless the new owner sets up billing in Google
     * Domains.
     */
    exportRegistration: {
      name: "ExportRegistration",
      requestType: ExportRegistrationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              33,
              10,
              12,
              82,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              67,
              58,
              1,
              42,
              34,
              62,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              101,
              120,
              112,
              111,
              114,
              116,
            ]),
          ],
        },
      },
    },
    /**
     * Deletes a `Registration` resource.
     *
     * This method works on any `Registration` resource using [Subscription or
     * Commitment billing](/domains/pricing#billing-models), provided that the
     * resource was created at least 1 day in the past.
     *
     * For `Registration` resources using
     * [Monthly billing](/domains/pricing#billing-models), this method works if:
     *
     * * `state` is `EXPORTED` with `expire_time` in the past
     * * `state` is `REGISTRATION_FAILED`
     * * `state` is `TRANSFER_FAILED`
     *
     * When an active registration is successfully deleted, you can continue to
     * use the domain in [Google Domains](https://domains.google/) until it
     * expires. The calling user becomes the domain's sole owner in Google
     * Domains, and permissions for the domain are subsequently managed there. The
     * domain does not renew automatically unless the new owner sets up billing in
     * Google Domains.
     */
    deleteRegistration: {
      name: "DeleteRegistration",
      requestType: DeleteRegistrationRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              57,
              42,
              55,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /**
     * Gets the authorization code of the `Registration` for the purpose of
     * transferring the domain to another registrar.
     *
     * You can call this method only after 60 days have elapsed since the initial
     * domain registration.
     */
    retrieveAuthorizationCode: {
      name: "RetrieveAuthorizationCode",
      requestType: RetrieveAuthorizationCodeRequest,
      requestStream: false,
      responseType: AuthorizationCode,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 114, 101, 103, 105, 115, 116, 114, 97, 116, 105, 111, 110])],
          578365826: [
            Buffer.from([
              91,
              18,
              89,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              116,
              114,
              105,
              101,
              118,
              101,
              65,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              100,
              101,
            ]),
          ],
        },
      },
    },
    /**
     * Resets the authorization code of the `Registration` to a new random string.
     *
     * You can call this method only after 60 days have elapsed since the initial
     * domain registration.
     */
    resetAuthorizationCode: {
      name: "ResetAuthorizationCode",
      requestType: ResetAuthorizationCodeRequest,
      requestStream: false,
      responseType: AuthorizationCode,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([12, 114, 101, 103, 105, 115, 116, 114, 97, 116, 105, 111, 110])],
          578365826: [
            Buffer.from([
              91,
              58,
              1,
              42,
              34,
              86,
              47,
              118,
              49,
              97,
              108,
              112,
              104,
              97,
              50,
              47,
              123,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              114,
              101,
              103,
              105,
              115,
              116,
              114,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              114,
              101,
              115,
              101,
              116,
              65,
              117,
              116,
              104,
              111,
              114,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              67,
              111,
              100,
              101,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface DomainsServiceImplementation<CallContextExt = {}> {
  /**
   * Searches for available domain names similar to the provided query.
   *
   * Availability results from this method are approximate; call
   * `RetrieveRegisterParameters` on a domain before registering to confirm
   * availability.
   */
  searchDomains(
    request: SearchDomainsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchDomainsResponse>>;
  /**
   * Gets parameters needed to register a new domain name, including price and
   * up-to-date availability. Use the returned values to call `RegisterDomain`.
   */
  retrieveRegisterParameters(
    request: RetrieveRegisterParametersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RetrieveRegisterParametersResponse>>;
  /**
   * Registers a new domain name and creates a corresponding `Registration`
   * resource.
   *
   * Call `RetrieveRegisterParameters` first to check availability of the domain
   * name and determine parameters like price that are needed to build a call to
   * this method.
   *
   * A successful call creates a `Registration` resource in state
   * `REGISTRATION_PENDING`, which resolves to `ACTIVE` within 1-2
   * minutes, indicating that the domain was successfully registered. If the
   * resource ends up in state `REGISTRATION_FAILED`, it indicates that the
   * domain was not registered successfully, and you can safely delete the
   * resource and retry registration.
   */
  registerDomain(
    request: RegisterDomainRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Gets parameters needed to transfer a domain name from another registrar to
   * Cloud Domains. For domains managed by Google Domains, transferring to Cloud
   * Domains is not supported.
   *
   * Use the returned values to call `TransferDomain`.
   */
  retrieveTransferParameters(
    request: RetrieveTransferParametersRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<RetrieveTransferParametersResponse>>;
  /**
   * Transfers a domain name from another registrar to Cloud Domains.  For
   * domains managed by Google Domains, transferring to Cloud Domains is not
   * supported.
   *
   * Before calling this method, go to the domain's current registrar to unlock
   * the domain for transfer and retrieve the domain's transfer authorization
   * code. Then call `RetrieveTransferParameters` to confirm that the domain is
   * unlocked and to get values needed to build a call to this method.
   *
   * A successful call creates a `Registration` resource in state
   * `TRANSFER_PENDING`. It can take several days to complete the transfer
   * process. The registrant can often speed up this process by approving the
   * transfer through the current registrar, either by clicking a link in an
   * email from the registrar or by visiting the registrar's website.
   *
   * A few minutes after transfer approval, the resource transitions to state
   * `ACTIVE`, indicating that the transfer was successful. If the transfer is
   * rejected or the request expires without being approved, the resource can
   * end up in state `TRANSFER_FAILED`. If transfer fails, you can safely delete
   * the resource and retry the transfer.
   */
  transferDomain(
    request: TransferDomainRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists the `Registration` resources in a project. */
  listRegistrations(
    request: ListRegistrationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListRegistrationsResponse>>;
  /** Gets the details of a `Registration` resource. */
  getRegistration(
    request: GetRegistrationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Registration>>;
  /**
   * Updates select fields of a `Registration` resource, notably `labels`. To
   * update other fields, use the appropriate custom update method:
   *
   * * To update management settings, see `ConfigureManagementSettings`
   * * To update DNS configuration, see `ConfigureDnsSettings`
   * * To update contact information, see `ConfigureContactSettings`
   */
  updateRegistration(
    request: UpdateRegistrationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates a `Registration`'s management settings. */
  configureManagementSettings(
    request: ConfigureManagementSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates a `Registration`'s DNS settings. */
  configureDnsSettings(
    request: ConfigureDnsSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Updates a `Registration`'s contact settings. Some changes require
   * confirmation by the domain's registrant contact .
   */
  configureContactSettings(
    request: ConfigureContactSettingsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Exports a `Registration` resource, such that it is no longer managed by
   * Cloud Domains.
   *
   * When an active domain is successfully exported, you can continue to use the
   * domain in [Google Domains](https://domains.google/) until it expires. The
   * calling user becomes the domain's sole owner in Google Domains, and
   * permissions for the domain are subsequently managed there. The domain does
   * not renew automatically unless the new owner sets up billing in Google
   * Domains.
   */
  exportRegistration(
    request: ExportRegistrationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Deletes a `Registration` resource.
   *
   * This method works on any `Registration` resource using [Subscription or
   * Commitment billing](/domains/pricing#billing-models), provided that the
   * resource was created at least 1 day in the past.
   *
   * For `Registration` resources using
   * [Monthly billing](/domains/pricing#billing-models), this method works if:
   *
   * * `state` is `EXPORTED` with `expire_time` in the past
   * * `state` is `REGISTRATION_FAILED`
   * * `state` is `TRANSFER_FAILED`
   *
   * When an active registration is successfully deleted, you can continue to
   * use the domain in [Google Domains](https://domains.google/) until it
   * expires. The calling user becomes the domain's sole owner in Google
   * Domains, and permissions for the domain are subsequently managed there. The
   * domain does not renew automatically unless the new owner sets up billing in
   * Google Domains.
   */
  deleteRegistration(
    request: DeleteRegistrationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /**
   * Gets the authorization code of the `Registration` for the purpose of
   * transferring the domain to another registrar.
   *
   * You can call this method only after 60 days have elapsed since the initial
   * domain registration.
   */
  retrieveAuthorizationCode(
    request: RetrieveAuthorizationCodeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AuthorizationCode>>;
  /**
   * Resets the authorization code of the `Registration` to a new random string.
   *
   * You can call this method only after 60 days have elapsed since the initial
   * domain registration.
   */
  resetAuthorizationCode(
    request: ResetAuthorizationCodeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<AuthorizationCode>>;
}

export interface DomainsClient<CallOptionsExt = {}> {
  /**
   * Searches for available domain names similar to the provided query.
   *
   * Availability results from this method are approximate; call
   * `RetrieveRegisterParameters` on a domain before registering to confirm
   * availability.
   */
  searchDomains(
    request: DeepPartial<SearchDomainsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchDomainsResponse>;
  /**
   * Gets parameters needed to register a new domain name, including price and
   * up-to-date availability. Use the returned values to call `RegisterDomain`.
   */
  retrieveRegisterParameters(
    request: DeepPartial<RetrieveRegisterParametersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RetrieveRegisterParametersResponse>;
  /**
   * Registers a new domain name and creates a corresponding `Registration`
   * resource.
   *
   * Call `RetrieveRegisterParameters` first to check availability of the domain
   * name and determine parameters like price that are needed to build a call to
   * this method.
   *
   * A successful call creates a `Registration` resource in state
   * `REGISTRATION_PENDING`, which resolves to `ACTIVE` within 1-2
   * minutes, indicating that the domain was successfully registered. If the
   * resource ends up in state `REGISTRATION_FAILED`, it indicates that the
   * domain was not registered successfully, and you can safely delete the
   * resource and retry registration.
   */
  registerDomain(
    request: DeepPartial<RegisterDomainRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Gets parameters needed to transfer a domain name from another registrar to
   * Cloud Domains. For domains managed by Google Domains, transferring to Cloud
   * Domains is not supported.
   *
   * Use the returned values to call `TransferDomain`.
   */
  retrieveTransferParameters(
    request: DeepPartial<RetrieveTransferParametersRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<RetrieveTransferParametersResponse>;
  /**
   * Transfers a domain name from another registrar to Cloud Domains.  For
   * domains managed by Google Domains, transferring to Cloud Domains is not
   * supported.
   *
   * Before calling this method, go to the domain's current registrar to unlock
   * the domain for transfer and retrieve the domain's transfer authorization
   * code. Then call `RetrieveTransferParameters` to confirm that the domain is
   * unlocked and to get values needed to build a call to this method.
   *
   * A successful call creates a `Registration` resource in state
   * `TRANSFER_PENDING`. It can take several days to complete the transfer
   * process. The registrant can often speed up this process by approving the
   * transfer through the current registrar, either by clicking a link in an
   * email from the registrar or by visiting the registrar's website.
   *
   * A few minutes after transfer approval, the resource transitions to state
   * `ACTIVE`, indicating that the transfer was successful. If the transfer is
   * rejected or the request expires without being approved, the resource can
   * end up in state `TRANSFER_FAILED`. If transfer fails, you can safely delete
   * the resource and retry the transfer.
   */
  transferDomain(
    request: DeepPartial<TransferDomainRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists the `Registration` resources in a project. */
  listRegistrations(
    request: DeepPartial<ListRegistrationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListRegistrationsResponse>;
  /** Gets the details of a `Registration` resource. */
  getRegistration(
    request: DeepPartial<GetRegistrationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Registration>;
  /**
   * Updates select fields of a `Registration` resource, notably `labels`. To
   * update other fields, use the appropriate custom update method:
   *
   * * To update management settings, see `ConfigureManagementSettings`
   * * To update DNS configuration, see `ConfigureDnsSettings`
   * * To update contact information, see `ConfigureContactSettings`
   */
  updateRegistration(
    request: DeepPartial<UpdateRegistrationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates a `Registration`'s management settings. */
  configureManagementSettings(
    request: DeepPartial<ConfigureManagementSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates a `Registration`'s DNS settings. */
  configureDnsSettings(
    request: DeepPartial<ConfigureDnsSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Updates a `Registration`'s contact settings. Some changes require
   * confirmation by the domain's registrant contact .
   */
  configureContactSettings(
    request: DeepPartial<ConfigureContactSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Exports a `Registration` resource, such that it is no longer managed by
   * Cloud Domains.
   *
   * When an active domain is successfully exported, you can continue to use the
   * domain in [Google Domains](https://domains.google/) until it expires. The
   * calling user becomes the domain's sole owner in Google Domains, and
   * permissions for the domain are subsequently managed there. The domain does
   * not renew automatically unless the new owner sets up billing in Google
   * Domains.
   */
  exportRegistration(
    request: DeepPartial<ExportRegistrationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Deletes a `Registration` resource.
   *
   * This method works on any `Registration` resource using [Subscription or
   * Commitment billing](/domains/pricing#billing-models), provided that the
   * resource was created at least 1 day in the past.
   *
   * For `Registration` resources using
   * [Monthly billing](/domains/pricing#billing-models), this method works if:
   *
   * * `state` is `EXPORTED` with `expire_time` in the past
   * * `state` is `REGISTRATION_FAILED`
   * * `state` is `TRANSFER_FAILED`
   *
   * When an active registration is successfully deleted, you can continue to
   * use the domain in [Google Domains](https://domains.google/) until it
   * expires. The calling user becomes the domain's sole owner in Google
   * Domains, and permissions for the domain are subsequently managed there. The
   * domain does not renew automatically unless the new owner sets up billing in
   * Google Domains.
   */
  deleteRegistration(
    request: DeepPartial<DeleteRegistrationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /**
   * Gets the authorization code of the `Registration` for the purpose of
   * transferring the domain to another registrar.
   *
   * You can call this method only after 60 days have elapsed since the initial
   * domain registration.
   */
  retrieveAuthorizationCode(
    request: DeepPartial<RetrieveAuthorizationCodeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AuthorizationCode>;
  /**
   * Resets the authorization code of the `Registration` to a new random string.
   *
   * You can call this method only after 60 days have elapsed since the initial
   * domain registration.
   */
  resetAuthorizationCode(
    request: DeepPartial<ResetAuthorizationCodeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AuthorizationCode>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
