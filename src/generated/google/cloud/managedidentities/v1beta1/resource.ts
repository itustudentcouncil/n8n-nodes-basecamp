// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/managedidentities/v1beta1/resource.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.managedidentities.v1beta1";

/**
 * Represents a managed Microsoft Active Directory domain.
 * If the domain is being changed, it will be placed into the UPDATING state,
 * which indicates that the resource is being reconciled. At this point, Get
 * will reflect an intermediate state.
 */
export interface Domain {
  /**
   * Output only. The unique name of the domain using the form:
   * `projects/{project_id}/locations/global/domains/{domain_name}`.
   */
  name: string;
  /** Optional. Resource labels that can contain user-provided metadata. */
  labels: { [key: string]: string };
  /**
   * Optional. The full names of the Google Compute Engine
   * [networks](/compute/docs/networks-and-firewalls#networks) the domain
   * instance is connected to. Networks can be added using UpdateDomain.
   * The domain is only available on networks listed in `authorized_networks`.
   * If CIDR subnets overlap between networks, domain creation will fail.
   */
  authorizedNetworks: string[];
  /**
   * Required. The CIDR range of internal addresses that are reserved for this
   * domain. Reserved networks must be /24 or larger. Ranges must be
   * unique and non-overlapping with existing subnets in
   * [Domain].[authorized_networks].
   */
  reservedIpRange: string;
  /**
   * Required. Locations where domain needs to be provisioned.
   * [regions][compute/docs/regions-zones/]
   * e.g. us-west1 or us-east4
   * Service supports up to 4 locations at once. Each location will use a /26
   * block.
   */
  locations: string[];
  /**
   * Optional. The name of delegated administrator account used to perform
   * Active Directory operations. If not specified, `setupadmin` will be used.
   */
  admin: string;
  /**
   * Output only. The fully-qualified domain name of the exposed domain used by
   * clients to connect to the service. Similar to what would be chosen for an
   * Active Directory set up on an internal network.
   */
  fqdn: string;
  /** Output only. The time the instance was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The last update time. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The current state of this domain. */
  state: Domain_State;
  /**
   * Output only. Additional information about the current status of this
   * domain, if available.
   */
  statusMessage: string;
  /** Output only. The current trusts associated with the domain. */
  trusts: Trust[];
}

/** Represents the different states of a managed domain. */
export enum Domain_State {
  /** STATE_UNSPECIFIED - Not set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The domain is being created. */
  CREATING = 1,
  /** READY - The domain has been created and is fully usable. */
  READY = 2,
  /** UPDATING - The domain's configuration is being updated. */
  UPDATING = 3,
  /** DELETING - The domain is being deleted. */
  DELETING = 4,
  /**
   * REPAIRING - The domain is being repaired and may be unusable. Details
   * can be found in the `status_message` field.
   */
  REPAIRING = 5,
  /** PERFORMING_MAINTENANCE - The domain is undergoing maintenance. */
  PERFORMING_MAINTENANCE = 6,
  /** UNAVAILABLE - The domain is not serving requests. */
  UNAVAILABLE = 7,
  UNRECOGNIZED = -1,
}

export function domain_StateFromJSON(object: any): Domain_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Domain_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Domain_State.CREATING;
    case 2:
    case "READY":
      return Domain_State.READY;
    case 3:
    case "UPDATING":
      return Domain_State.UPDATING;
    case 4:
    case "DELETING":
      return Domain_State.DELETING;
    case 5:
    case "REPAIRING":
      return Domain_State.REPAIRING;
    case 6:
    case "PERFORMING_MAINTENANCE":
      return Domain_State.PERFORMING_MAINTENANCE;
    case 7:
    case "UNAVAILABLE":
      return Domain_State.UNAVAILABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Domain_State.UNRECOGNIZED;
  }
}

export function domain_StateToJSON(object: Domain_State): string {
  switch (object) {
    case Domain_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Domain_State.CREATING:
      return "CREATING";
    case Domain_State.READY:
      return "READY";
    case Domain_State.UPDATING:
      return "UPDATING";
    case Domain_State.DELETING:
      return "DELETING";
    case Domain_State.REPAIRING:
      return "REPAIRING";
    case Domain_State.PERFORMING_MAINTENANCE:
      return "PERFORMING_MAINTENANCE";
    case Domain_State.UNAVAILABLE:
      return "UNAVAILABLE";
    case Domain_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Domain_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Represents a relationship between two domains. This allows a controller in
 * one domain to authenticate a user in another domain.
 */
export interface Trust {
  /**
   * The fully qualified target domain name which will be in trust with the
   * current domain.
   */
  targetDomainName: string;
  /** The type of trust represented by the trust resource. */
  trustType: Trust_TrustType;
  /**
   * The trust direction, which decides if the current domain is trusted,
   * trusting, or both.
   */
  trustDirection: Trust_TrustDirection;
  /**
   * The trust authentication type, which decides whether the trusted side has
   * forest/domain wide access or selective access to an approved set of
   * resources.
   */
  selectiveAuthentication: boolean;
  /**
   * The target DNS server IP addresses which can resolve the remote domain
   * involved in the trust.
   */
  targetDnsIpAddresses: string[];
  /**
   * Input only. The trust secret used for the handshake
   * with the target domain. It will not be stored.
   */
  trustHandshakeSecret: string;
  /** Output only. The time the instance was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The last update time. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The current state of the trust. */
  state: Trust_State;
  /**
   * Output only. Additional information about the current state of the
   * trust, if available.
   */
  stateDescription: string;
  /**
   * Output only. The last heartbeat time when the trust was known to be
   * connected.
   */
  lastTrustHeartbeatTime: Date | undefined;
}

/** Represents the different states of a domain trust. */
export enum Trust_State {
  /** STATE_UNSPECIFIED - Not set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The domain trust is being created. */
  CREATING = 1,
  /** UPDATING - The domain trust is being updated. */
  UPDATING = 2,
  /** DELETING - The domain trust is being deleted. */
  DELETING = 3,
  /** CONNECTED - The domain trust is connected. */
  CONNECTED = 4,
  /** DISCONNECTED - The domain trust is disconnected. */
  DISCONNECTED = 5,
  UNRECOGNIZED = -1,
}

export function trust_StateFromJSON(object: any): Trust_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Trust_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Trust_State.CREATING;
    case 2:
    case "UPDATING":
      return Trust_State.UPDATING;
    case 3:
    case "DELETING":
      return Trust_State.DELETING;
    case 4:
    case "CONNECTED":
      return Trust_State.CONNECTED;
    case 5:
    case "DISCONNECTED":
      return Trust_State.DISCONNECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Trust_State.UNRECOGNIZED;
  }
}

export function trust_StateToJSON(object: Trust_State): string {
  switch (object) {
    case Trust_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Trust_State.CREATING:
      return "CREATING";
    case Trust_State.UPDATING:
      return "UPDATING";
    case Trust_State.DELETING:
      return "DELETING";
    case Trust_State.CONNECTED:
      return "CONNECTED";
    case Trust_State.DISCONNECTED:
      return "DISCONNECTED";
    case Trust_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents the different inter-forest trust types. */
export enum Trust_TrustType {
  /** TRUST_TYPE_UNSPECIFIED - Not set. */
  TRUST_TYPE_UNSPECIFIED = 0,
  /** FOREST - The forest trust. */
  FOREST = 1,
  /** EXTERNAL - The external domain trust. */
  EXTERNAL = 2,
  UNRECOGNIZED = -1,
}

export function trust_TrustTypeFromJSON(object: any): Trust_TrustType {
  switch (object) {
    case 0:
    case "TRUST_TYPE_UNSPECIFIED":
      return Trust_TrustType.TRUST_TYPE_UNSPECIFIED;
    case 1:
    case "FOREST":
      return Trust_TrustType.FOREST;
    case 2:
    case "EXTERNAL":
      return Trust_TrustType.EXTERNAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Trust_TrustType.UNRECOGNIZED;
  }
}

export function trust_TrustTypeToJSON(object: Trust_TrustType): string {
  switch (object) {
    case Trust_TrustType.TRUST_TYPE_UNSPECIFIED:
      return "TRUST_TYPE_UNSPECIFIED";
    case Trust_TrustType.FOREST:
      return "FOREST";
    case Trust_TrustType.EXTERNAL:
      return "EXTERNAL";
    case Trust_TrustType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents the direction of trust.
 * See
 * [System.DirectoryServices.ActiveDirectory.TrustDirection](https://docs.microsoft.com/en-us/dotnet/api/system.directoryservices.activedirectory.trustdirection?view=netframework-4.7.2)
 * for more information.
 */
export enum Trust_TrustDirection {
  /** TRUST_DIRECTION_UNSPECIFIED - Not set. */
  TRUST_DIRECTION_UNSPECIFIED = 0,
  /** INBOUND - The inbound direction represents the trusting side. */
  INBOUND = 1,
  /** OUTBOUND - The outboud direction represents the trusted side. */
  OUTBOUND = 2,
  /** BIDIRECTIONAL - The bidirectional direction represents the trusted / trusting side. */
  BIDIRECTIONAL = 3,
  UNRECOGNIZED = -1,
}

export function trust_TrustDirectionFromJSON(object: any): Trust_TrustDirection {
  switch (object) {
    case 0:
    case "TRUST_DIRECTION_UNSPECIFIED":
      return Trust_TrustDirection.TRUST_DIRECTION_UNSPECIFIED;
    case 1:
    case "INBOUND":
      return Trust_TrustDirection.INBOUND;
    case 2:
    case "OUTBOUND":
      return Trust_TrustDirection.OUTBOUND;
    case 3:
    case "BIDIRECTIONAL":
      return Trust_TrustDirection.BIDIRECTIONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Trust_TrustDirection.UNRECOGNIZED;
  }
}

export function trust_TrustDirectionToJSON(object: Trust_TrustDirection): string {
  switch (object) {
    case Trust_TrustDirection.TRUST_DIRECTION_UNSPECIFIED:
      return "TRUST_DIRECTION_UNSPECIFIED";
    case Trust_TrustDirection.INBOUND:
      return "INBOUND";
    case Trust_TrustDirection.OUTBOUND:
      return "OUTBOUND";
    case Trust_TrustDirection.BIDIRECTIONAL:
      return "BIDIRECTIONAL";
    case Trust_TrustDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseDomain(): Domain {
  return {
    name: "",
    labels: {},
    authorizedNetworks: [],
    reservedIpRange: "",
    locations: [],
    admin: "",
    fqdn: "",
    createTime: undefined,
    updateTime: undefined,
    state: 0,
    statusMessage: "",
    trusts: [],
  };
}

export const Domain: MessageFns<Domain> = {
  encode(message: Domain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Domain_LabelsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    for (const v of message.authorizedNetworks) {
      writer.uint32(26).string(v!);
    }
    if (message.reservedIpRange !== "") {
      writer.uint32(34).string(message.reservedIpRange);
    }
    for (const v of message.locations) {
      writer.uint32(42).string(v!);
    }
    if (message.admin !== "") {
      writer.uint32(50).string(message.admin);
    }
    if (message.fqdn !== "") {
      writer.uint32(82).string(message.fqdn);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(90).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(98).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(104).int32(message.state);
    }
    if (message.statusMessage !== "") {
      writer.uint32(114).string(message.statusMessage);
    }
    for (const v of message.trusts) {
      Trust.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Domain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Domain_LabelsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.labels[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.authorizedNetworks.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.reservedIpRange = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.locations.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.admin = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.fqdn = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.trusts.push(Trust.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Domain {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      authorizedNetworks: globalThis.Array.isArray(object?.authorizedNetworks)
        ? object.authorizedNetworks.map((e: any) => globalThis.String(e))
        : [],
      reservedIpRange: isSet(object.reservedIpRange) ? globalThis.String(object.reservedIpRange) : "",
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => globalThis.String(e))
        : [],
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      fqdn: isSet(object.fqdn) ? globalThis.String(object.fqdn) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? domain_StateFromJSON(object.state) : 0,
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      trusts: globalThis.Array.isArray(object?.trusts)
        ? object.trusts.map((e: any) => Trust.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Domain): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.authorizedNetworks?.length) {
      obj.authorizedNetworks = message.authorizedNetworks;
    }
    if (message.reservedIpRange !== "") {
      obj.reservedIpRange = message.reservedIpRange;
    }
    if (message.locations?.length) {
      obj.locations = message.locations;
    }
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.fqdn !== "") {
      obj.fqdn = message.fqdn;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = domain_StateToJSON(message.state);
    }
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.trusts?.length) {
      obj.trusts = message.trusts.map((e) => Trust.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Domain>): Domain {
    return Domain.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Domain>): Domain {
    const message = createBaseDomain();
    message.name = object.name ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.authorizedNetworks = object.authorizedNetworks?.map((e) => e) || [];
    message.reservedIpRange = object.reservedIpRange ?? "";
    message.locations = object.locations?.map((e) => e) || [];
    message.admin = object.admin ?? "";
    message.fqdn = object.fqdn ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    message.trusts = object.trusts?.map((e) => Trust.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDomain_LabelsEntry(): Domain_LabelsEntry {
  return { key: "", value: "" };
}

export const Domain_LabelsEntry: MessageFns<Domain_LabelsEntry> = {
  encode(message: Domain_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Domain_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDomain_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Domain_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Domain_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Domain_LabelsEntry>): Domain_LabelsEntry {
    return Domain_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Domain_LabelsEntry>): Domain_LabelsEntry {
    const message = createBaseDomain_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTrust(): Trust {
  return {
    targetDomainName: "",
    trustType: 0,
    trustDirection: 0,
    selectiveAuthentication: false,
    targetDnsIpAddresses: [],
    trustHandshakeSecret: "",
    createTime: undefined,
    updateTime: undefined,
    state: 0,
    stateDescription: "",
    lastTrustHeartbeatTime: undefined,
  };
}

export const Trust: MessageFns<Trust> = {
  encode(message: Trust, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetDomainName !== "") {
      writer.uint32(10).string(message.targetDomainName);
    }
    if (message.trustType !== 0) {
      writer.uint32(16).int32(message.trustType);
    }
    if (message.trustDirection !== 0) {
      writer.uint32(24).int32(message.trustDirection);
    }
    if (message.selectiveAuthentication !== false) {
      writer.uint32(32).bool(message.selectiveAuthentication);
    }
    for (const v of message.targetDnsIpAddresses) {
      writer.uint32(42).string(v!);
    }
    if (message.trustHandshakeSecret !== "") {
      writer.uint32(50).string(message.trustHandshakeSecret);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(58).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(66).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(72).int32(message.state);
    }
    if (message.stateDescription !== "") {
      writer.uint32(90).string(message.stateDescription);
    }
    if (message.lastTrustHeartbeatTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastTrustHeartbeatTime), writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trust {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrust();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetDomainName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.trustType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.trustDirection = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.selectiveAuthentication = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetDnsIpAddresses.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.trustHandshakeSecret = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.stateDescription = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.lastTrustHeartbeatTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trust {
    return {
      targetDomainName: isSet(object.targetDomainName) ? globalThis.String(object.targetDomainName) : "",
      trustType: isSet(object.trustType) ? trust_TrustTypeFromJSON(object.trustType) : 0,
      trustDirection: isSet(object.trustDirection) ? trust_TrustDirectionFromJSON(object.trustDirection) : 0,
      selectiveAuthentication: isSet(object.selectiveAuthentication)
        ? globalThis.Boolean(object.selectiveAuthentication)
        : false,
      targetDnsIpAddresses: globalThis.Array.isArray(object?.targetDnsIpAddresses)
        ? object.targetDnsIpAddresses.map((e: any) => globalThis.String(e))
        : [],
      trustHandshakeSecret: isSet(object.trustHandshakeSecret) ? globalThis.String(object.trustHandshakeSecret) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? trust_StateFromJSON(object.state) : 0,
      stateDescription: isSet(object.stateDescription) ? globalThis.String(object.stateDescription) : "",
      lastTrustHeartbeatTime: isSet(object.lastTrustHeartbeatTime)
        ? fromJsonTimestamp(object.lastTrustHeartbeatTime)
        : undefined,
    };
  },

  toJSON(message: Trust): unknown {
    const obj: any = {};
    if (message.targetDomainName !== "") {
      obj.targetDomainName = message.targetDomainName;
    }
    if (message.trustType !== 0) {
      obj.trustType = trust_TrustTypeToJSON(message.trustType);
    }
    if (message.trustDirection !== 0) {
      obj.trustDirection = trust_TrustDirectionToJSON(message.trustDirection);
    }
    if (message.selectiveAuthentication !== false) {
      obj.selectiveAuthentication = message.selectiveAuthentication;
    }
    if (message.targetDnsIpAddresses?.length) {
      obj.targetDnsIpAddresses = message.targetDnsIpAddresses;
    }
    if (message.trustHandshakeSecret !== "") {
      obj.trustHandshakeSecret = message.trustHandshakeSecret;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = trust_StateToJSON(message.state);
    }
    if (message.stateDescription !== "") {
      obj.stateDescription = message.stateDescription;
    }
    if (message.lastTrustHeartbeatTime !== undefined) {
      obj.lastTrustHeartbeatTime = message.lastTrustHeartbeatTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<Trust>): Trust {
    return Trust.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trust>): Trust {
    const message = createBaseTrust();
    message.targetDomainName = object.targetDomainName ?? "";
    message.trustType = object.trustType ?? 0;
    message.trustDirection = object.trustDirection ?? 0;
    message.selectiveAuthentication = object.selectiveAuthentication ?? false;
    message.targetDnsIpAddresses = object.targetDnsIpAddresses?.map((e) => e) || [];
    message.trustHandshakeSecret = object.trustHandshakeSecret ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    message.stateDescription = object.stateDescription ?? "";
    message.lastTrustHeartbeatTime = object.lastTrustHeartbeatTime ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
