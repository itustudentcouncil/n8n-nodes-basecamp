// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/run/v2/vendor_settings.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.run.v2";

/** Allowed ingress traffic for the Container. */
export enum IngressTraffic {
  /** INGRESS_TRAFFIC_UNSPECIFIED - Unspecified */
  INGRESS_TRAFFIC_UNSPECIFIED = 0,
  /** INGRESS_TRAFFIC_ALL - All inbound traffic is allowed. */
  INGRESS_TRAFFIC_ALL = 1,
  /** INGRESS_TRAFFIC_INTERNAL_ONLY - Only internal traffic is allowed. */
  INGRESS_TRAFFIC_INTERNAL_ONLY = 2,
  /** INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER - Both internal and Google Cloud Load Balancer traffic is allowed. */
  INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER = 3,
  UNRECOGNIZED = -1,
}

export function ingressTrafficFromJSON(object: any): IngressTraffic {
  switch (object) {
    case 0:
    case "INGRESS_TRAFFIC_UNSPECIFIED":
      return IngressTraffic.INGRESS_TRAFFIC_UNSPECIFIED;
    case 1:
    case "INGRESS_TRAFFIC_ALL":
      return IngressTraffic.INGRESS_TRAFFIC_ALL;
    case 2:
    case "INGRESS_TRAFFIC_INTERNAL_ONLY":
      return IngressTraffic.INGRESS_TRAFFIC_INTERNAL_ONLY;
    case 3:
    case "INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER":
      return IngressTraffic.INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IngressTraffic.UNRECOGNIZED;
  }
}

export function ingressTrafficToJSON(object: IngressTraffic): string {
  switch (object) {
    case IngressTraffic.INGRESS_TRAFFIC_UNSPECIFIED:
      return "INGRESS_TRAFFIC_UNSPECIFIED";
    case IngressTraffic.INGRESS_TRAFFIC_ALL:
      return "INGRESS_TRAFFIC_ALL";
    case IngressTraffic.INGRESS_TRAFFIC_INTERNAL_ONLY:
      return "INGRESS_TRAFFIC_INTERNAL_ONLY";
    case IngressTraffic.INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER:
      return "INGRESS_TRAFFIC_INTERNAL_LOAD_BALANCER";
    case IngressTraffic.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Alternatives for execution environments. */
export enum ExecutionEnvironment {
  /** EXECUTION_ENVIRONMENT_UNSPECIFIED - Unspecified */
  EXECUTION_ENVIRONMENT_UNSPECIFIED = 0,
  /** EXECUTION_ENVIRONMENT_GEN1 - Uses the First Generation environment. */
  EXECUTION_ENVIRONMENT_GEN1 = 1,
  /** EXECUTION_ENVIRONMENT_GEN2 - Uses Second Generation environment. */
  EXECUTION_ENVIRONMENT_GEN2 = 2,
  UNRECOGNIZED = -1,
}

export function executionEnvironmentFromJSON(object: any): ExecutionEnvironment {
  switch (object) {
    case 0:
    case "EXECUTION_ENVIRONMENT_UNSPECIFIED":
      return ExecutionEnvironment.EXECUTION_ENVIRONMENT_UNSPECIFIED;
    case 1:
    case "EXECUTION_ENVIRONMENT_GEN1":
      return ExecutionEnvironment.EXECUTION_ENVIRONMENT_GEN1;
    case 2:
    case "EXECUTION_ENVIRONMENT_GEN2":
      return ExecutionEnvironment.EXECUTION_ENVIRONMENT_GEN2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExecutionEnvironment.UNRECOGNIZED;
  }
}

export function executionEnvironmentToJSON(object: ExecutionEnvironment): string {
  switch (object) {
    case ExecutionEnvironment.EXECUTION_ENVIRONMENT_UNSPECIFIED:
      return "EXECUTION_ENVIRONMENT_UNSPECIFIED";
    case ExecutionEnvironment.EXECUTION_ENVIRONMENT_GEN1:
      return "EXECUTION_ENVIRONMENT_GEN1";
    case ExecutionEnvironment.EXECUTION_ENVIRONMENT_GEN2:
      return "EXECUTION_ENVIRONMENT_GEN2";
    case ExecutionEnvironment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies behavior if an encryption key used by a resource is revoked. */
export enum EncryptionKeyRevocationAction {
  /** ENCRYPTION_KEY_REVOCATION_ACTION_UNSPECIFIED - Unspecified */
  ENCRYPTION_KEY_REVOCATION_ACTION_UNSPECIFIED = 0,
  /** PREVENT_NEW - Prevents the creation of new instances. */
  PREVENT_NEW = 1,
  /** SHUTDOWN - Shuts down existing instances, and prevents creation of new ones. */
  SHUTDOWN = 2,
  UNRECOGNIZED = -1,
}

export function encryptionKeyRevocationActionFromJSON(object: any): EncryptionKeyRevocationAction {
  switch (object) {
    case 0:
    case "ENCRYPTION_KEY_REVOCATION_ACTION_UNSPECIFIED":
      return EncryptionKeyRevocationAction.ENCRYPTION_KEY_REVOCATION_ACTION_UNSPECIFIED;
    case 1:
    case "PREVENT_NEW":
      return EncryptionKeyRevocationAction.PREVENT_NEW;
    case 2:
    case "SHUTDOWN":
      return EncryptionKeyRevocationAction.SHUTDOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EncryptionKeyRevocationAction.UNRECOGNIZED;
  }
}

export function encryptionKeyRevocationActionToJSON(object: EncryptionKeyRevocationAction): string {
  switch (object) {
    case EncryptionKeyRevocationAction.ENCRYPTION_KEY_REVOCATION_ACTION_UNSPECIFIED:
      return "ENCRYPTION_KEY_REVOCATION_ACTION_UNSPECIFIED";
    case EncryptionKeyRevocationAction.PREVENT_NEW:
      return "PREVENT_NEW";
    case EncryptionKeyRevocationAction.SHUTDOWN:
      return "SHUTDOWN";
    case EncryptionKeyRevocationAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * VPC Access settings. For more information on sending traffic to a VPC
 * network, visit https://cloud.google.com/run/docs/configuring/connecting-vpc.
 */
export interface VpcAccess {
  /**
   * VPC Access connector name.
   * Format: projects/{project}/locations/{location}/connectors/{connector},
   * where {project} can be project id or number.
   * For more information on sending traffic to a VPC network via a connector,
   * visit https://cloud.google.com/run/docs/configuring/vpc-connectors.
   */
  connector: string;
  /**
   * Optional. Traffic VPC egress settings. If not provided, it defaults to
   * PRIVATE_RANGES_ONLY.
   */
  egress: VpcAccess_VpcEgress;
  /**
   * Optional. Direct VPC egress settings. Currently only single network
   * interface is supported.
   */
  networkInterfaces: VpcAccess_NetworkInterface[];
}

/** Egress options for VPC access. */
export enum VpcAccess_VpcEgress {
  /** VPC_EGRESS_UNSPECIFIED - Unspecified */
  VPC_EGRESS_UNSPECIFIED = 0,
  /** ALL_TRAFFIC - All outbound traffic is routed through the VPC connector. */
  ALL_TRAFFIC = 1,
  /** PRIVATE_RANGES_ONLY - Only private IP ranges are routed through the VPC connector. */
  PRIVATE_RANGES_ONLY = 2,
  UNRECOGNIZED = -1,
}

export function vpcAccess_VpcEgressFromJSON(object: any): VpcAccess_VpcEgress {
  switch (object) {
    case 0:
    case "VPC_EGRESS_UNSPECIFIED":
      return VpcAccess_VpcEgress.VPC_EGRESS_UNSPECIFIED;
    case 1:
    case "ALL_TRAFFIC":
      return VpcAccess_VpcEgress.ALL_TRAFFIC;
    case 2:
    case "PRIVATE_RANGES_ONLY":
      return VpcAccess_VpcEgress.PRIVATE_RANGES_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VpcAccess_VpcEgress.UNRECOGNIZED;
  }
}

export function vpcAccess_VpcEgressToJSON(object: VpcAccess_VpcEgress): string {
  switch (object) {
    case VpcAccess_VpcEgress.VPC_EGRESS_UNSPECIFIED:
      return "VPC_EGRESS_UNSPECIFIED";
    case VpcAccess_VpcEgress.ALL_TRAFFIC:
      return "ALL_TRAFFIC";
    case VpcAccess_VpcEgress.PRIVATE_RANGES_ONLY:
      return "PRIVATE_RANGES_ONLY";
    case VpcAccess_VpcEgress.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Direct VPC egress settings. */
export interface VpcAccess_NetworkInterface {
  /**
   * Optional. The VPC network that the Cloud Run resource will be able to
   * send traffic to. At least one of network or subnetwork must be specified.
   * If both network and subnetwork are specified, the given VPC subnetwork
   * must belong to the given VPC network. If network is not specified, it
   * will be looked up from the subnetwork.
   */
  network: string;
  /**
   * Optional. The VPC subnetwork that the Cloud Run resource will get IPs
   * from. At least one of network or subnetwork must be specified. If both
   * network and subnetwork are specified, the given VPC subnetwork must
   * belong to the given VPC network. If subnetwork is not specified, the
   * subnetwork with the same name with the network will be used.
   */
  subnetwork: string;
  /** Optional. Network tags applied to this Cloud Run resource. */
  tags: string[];
}

/** Settings for Binary Authorization feature. */
export interface BinaryAuthorization {
  /**
   * Optional. If True, indicates to use the default project's binary
   * authorization policy. If False, binary authorization will be disabled.
   */
  useDefault?:
    | boolean
    | undefined;
  /**
   * Optional. The path to a binary authorization policy.
   * Format: projects/{project}/platforms/cloudRun/{policy-name}
   */
  policy?:
    | string
    | undefined;
  /**
   * Optional. If present, indicates to use Breakglass using this justification.
   * If use_default is False, then it must be empty.
   * For more information on breakglass, see
   * https://cloud.google.com/binary-authorization/docs/using-breakglass
   */
  breakglassJustification: string;
}

/** Settings for revision-level scaling settings. */
export interface RevisionScaling {
  /**
   * Optional. Minimum number of serving instances that this resource should
   * have.
   */
  minInstanceCount: number;
  /**
   * Optional. Maximum number of serving instances that this resource should
   * have.
   */
  maxInstanceCount: number;
}

/**
 * Scaling settings applied at the service level rather than
 * at the revision level.
 */
export interface ServiceScaling {
  /**
   * Optional. total min instances for the service. This number of instances is
   * divided among all revisions with specified traffic based on the percent
   * of traffic they are receiving. (BETA)
   */
  minInstanceCount: number;
}

function createBaseVpcAccess(): VpcAccess {
  return { connector: "", egress: 0, networkInterfaces: [] };
}

export const VpcAccess: MessageFns<VpcAccess> = {
  encode(message: VpcAccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connector !== "") {
      writer.uint32(10).string(message.connector);
    }
    if (message.egress !== 0) {
      writer.uint32(16).int32(message.egress);
    }
    for (const v of message.networkInterfaces) {
      VpcAccess_NetworkInterface.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpcAccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpcAccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.connector = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.egress = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.networkInterfaces.push(VpcAccess_NetworkInterface.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpcAccess {
    return {
      connector: isSet(object.connector) ? globalThis.String(object.connector) : "",
      egress: isSet(object.egress) ? vpcAccess_VpcEgressFromJSON(object.egress) : 0,
      networkInterfaces: globalThis.Array.isArray(object?.networkInterfaces)
        ? object.networkInterfaces.map((e: any) => VpcAccess_NetworkInterface.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VpcAccess): unknown {
    const obj: any = {};
    if (message.connector !== "") {
      obj.connector = message.connector;
    }
    if (message.egress !== 0) {
      obj.egress = vpcAccess_VpcEgressToJSON(message.egress);
    }
    if (message.networkInterfaces?.length) {
      obj.networkInterfaces = message.networkInterfaces.map((e) => VpcAccess_NetworkInterface.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VpcAccess>): VpcAccess {
    return VpcAccess.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpcAccess>): VpcAccess {
    const message = createBaseVpcAccess();
    message.connector = object.connector ?? "";
    message.egress = object.egress ?? 0;
    message.networkInterfaces = object.networkInterfaces?.map((e) => VpcAccess_NetworkInterface.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVpcAccess_NetworkInterface(): VpcAccess_NetworkInterface {
  return { network: "", subnetwork: "", tags: [] };
}

export const VpcAccess_NetworkInterface: MessageFns<VpcAccess_NetworkInterface> = {
  encode(message: VpcAccess_NetworkInterface, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.subnetwork !== "") {
      writer.uint32(18).string(message.subnetwork);
    }
    for (const v of message.tags) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VpcAccess_NetworkInterface {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVpcAccess_NetworkInterface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tags.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VpcAccess_NetworkInterface {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : "",
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: VpcAccess_NetworkInterface): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.subnetwork !== "") {
      obj.subnetwork = message.subnetwork;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create(base?: DeepPartial<VpcAccess_NetworkInterface>): VpcAccess_NetworkInterface {
    return VpcAccess_NetworkInterface.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VpcAccess_NetworkInterface>): VpcAccess_NetworkInterface {
    const message = createBaseVpcAccess_NetworkInterface();
    message.network = object.network ?? "";
    message.subnetwork = object.subnetwork ?? "";
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseBinaryAuthorization(): BinaryAuthorization {
  return { useDefault: undefined, policy: undefined, breakglassJustification: "" };
}

export const BinaryAuthorization: MessageFns<BinaryAuthorization> = {
  encode(message: BinaryAuthorization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.useDefault !== undefined) {
      writer.uint32(8).bool(message.useDefault);
    }
    if (message.policy !== undefined) {
      writer.uint32(26).string(message.policy);
    }
    if (message.breakglassJustification !== "") {
      writer.uint32(18).string(message.breakglassJustification);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BinaryAuthorization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryAuthorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.useDefault = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.policy = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.breakglassJustification = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BinaryAuthorization {
    return {
      useDefault: isSet(object.useDefault) ? globalThis.Boolean(object.useDefault) : undefined,
      policy: isSet(object.policy) ? globalThis.String(object.policy) : undefined,
      breakglassJustification: isSet(object.breakglassJustification)
        ? globalThis.String(object.breakglassJustification)
        : "",
    };
  },

  toJSON(message: BinaryAuthorization): unknown {
    const obj: any = {};
    if (message.useDefault !== undefined) {
      obj.useDefault = message.useDefault;
    }
    if (message.policy !== undefined) {
      obj.policy = message.policy;
    }
    if (message.breakglassJustification !== "") {
      obj.breakglassJustification = message.breakglassJustification;
    }
    return obj;
  },

  create(base?: DeepPartial<BinaryAuthorization>): BinaryAuthorization {
    return BinaryAuthorization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BinaryAuthorization>): BinaryAuthorization {
    const message = createBaseBinaryAuthorization();
    message.useDefault = object.useDefault ?? undefined;
    message.policy = object.policy ?? undefined;
    message.breakglassJustification = object.breakglassJustification ?? "";
    return message;
  },
};

function createBaseRevisionScaling(): RevisionScaling {
  return { minInstanceCount: 0, maxInstanceCount: 0 };
}

export const RevisionScaling: MessageFns<RevisionScaling> = {
  encode(message: RevisionScaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minInstanceCount !== 0) {
      writer.uint32(8).int32(message.minInstanceCount);
    }
    if (message.maxInstanceCount !== 0) {
      writer.uint32(16).int32(message.maxInstanceCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RevisionScaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRevisionScaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.minInstanceCount = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxInstanceCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RevisionScaling {
    return {
      minInstanceCount: isSet(object.minInstanceCount) ? globalThis.Number(object.minInstanceCount) : 0,
      maxInstanceCount: isSet(object.maxInstanceCount) ? globalThis.Number(object.maxInstanceCount) : 0,
    };
  },

  toJSON(message: RevisionScaling): unknown {
    const obj: any = {};
    if (message.minInstanceCount !== 0) {
      obj.minInstanceCount = Math.round(message.minInstanceCount);
    }
    if (message.maxInstanceCount !== 0) {
      obj.maxInstanceCount = Math.round(message.maxInstanceCount);
    }
    return obj;
  },

  create(base?: DeepPartial<RevisionScaling>): RevisionScaling {
    return RevisionScaling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RevisionScaling>): RevisionScaling {
    const message = createBaseRevisionScaling();
    message.minInstanceCount = object.minInstanceCount ?? 0;
    message.maxInstanceCount = object.maxInstanceCount ?? 0;
    return message;
  },
};

function createBaseServiceScaling(): ServiceScaling {
  return { minInstanceCount: 0 };
}

export const ServiceScaling: MessageFns<ServiceScaling> = {
  encode(message: ServiceScaling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minInstanceCount !== 0) {
      writer.uint32(8).int32(message.minInstanceCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceScaling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceScaling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.minInstanceCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceScaling {
    return { minInstanceCount: isSet(object.minInstanceCount) ? globalThis.Number(object.minInstanceCount) : 0 };
  },

  toJSON(message: ServiceScaling): unknown {
    const obj: any = {};
    if (message.minInstanceCount !== 0) {
      obj.minInstanceCount = Math.round(message.minInstanceCount);
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceScaling>): ServiceScaling {
    return ServiceScaling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceScaling>): ServiceScaling {
    const message = createBaseServiceScaling();
    message.minInstanceCount = object.minInstanceCount ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
