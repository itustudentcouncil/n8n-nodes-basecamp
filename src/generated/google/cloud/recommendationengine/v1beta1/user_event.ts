// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/recommendationengine/v1beta1/user_event.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  CatalogItem_CategoryHierarchy,
  ProductCatalogItem_StockState,
  productCatalogItem_StockStateFromJSON,
  productCatalogItem_StockStateToJSON,
} from "./catalog.js";
import { FeatureMap } from "./common.js";

export const protobufPackage = "google.cloud.recommendationengine.v1beta1";

/**
 * UserEvent captures all metadata information recommendation engine needs to
 * know about how end users interact with customers' website.
 */
export interface UserEvent {
  /**
   * Required. User event type. Allowed values are:
   *
   * * `add-to-cart` Products being added to cart.
   * * `add-to-list` Items being added to a list (shopping list, favorites
   *   etc).
   * * `category-page-view` Special pages such as sale or promotion pages
   *   viewed.
   * * `checkout-start` User starting a checkout process.
   * * `detail-page-view` Products detail page viewed.
   * * `home-page-view` Homepage viewed.
   * * `page-visit` Generic page visits not included in the event types above.
   * * `purchase-complete` User finishing a purchase.
   * * `refund` Purchased items being refunded or returned.
   * * `remove-from-cart` Products being removed from cart.
   * * `remove-from-list` Items being removed from a list.
   * * `search` Product search.
   * * `shopping-cart-page-view` User viewing a shopping cart.
   * * `impression` List of items displayed. Used by Google Tag Manager.
   */
  eventType: string;
  /** Required. User information. */
  userInfo:
    | UserInfo
    | undefined;
  /**
   * Optional. User event detailed information common across different
   * recommendation types.
   */
  eventDetail:
    | EventDetail
    | undefined;
  /**
   * Optional. Retail product specific user event metadata.
   *
   * This field is required for the following event types:
   *
   * * `add-to-cart`
   * * `add-to-list`
   * * `category-page-view`
   * * `checkout-start`
   * * `detail-page-view`
   * * `purchase-complete`
   * * `refund`
   * * `remove-from-cart`
   * * `remove-from-list`
   * * `search`
   *
   * This field is optional for the following event types:
   *
   * * `page-visit`
   * * `shopping-cart-page-view` - note that 'product_event_detail' should be
   *   set for this unless the shopping cart is empty.
   *
   * This field is not allowed for the following event types:
   *
   * * `home-page-view`
   */
  productEventDetail:
    | ProductEventDetail
    | undefined;
  /**
   * Optional. Only required for ImportUserEvents method. Timestamp of user
   * event created.
   */
  eventTime:
    | Date
    | undefined;
  /**
   * Optional. This field should *not* be set when using JavaScript pixel
   * or the Recommendations AI Tag. Defaults to `EVENT_SOURCE_UNSPECIFIED`.
   */
  eventSource: UserEvent_EventSource;
}

/** User event source. */
export enum UserEvent_EventSource {
  /** EVENT_SOURCE_UNSPECIFIED - Unspecified event source. */
  EVENT_SOURCE_UNSPECIFIED = 0,
  /**
   * AUTOML - The event is ingested via a javascript pixel or Recommendations AI Tag
   * through automl datalayer or JS Macros.
   */
  AUTOML = 1,
  /**
   * ECOMMERCE - The event is ingested via Recommendations AI Tag through Enhanced
   * Ecommerce datalayer.
   */
  ECOMMERCE = 2,
  /** BATCH_UPLOAD - The event is ingested via Import user events API. */
  BATCH_UPLOAD = 3,
  UNRECOGNIZED = -1,
}

export function userEvent_EventSourceFromJSON(object: any): UserEvent_EventSource {
  switch (object) {
    case 0:
    case "EVENT_SOURCE_UNSPECIFIED":
      return UserEvent_EventSource.EVENT_SOURCE_UNSPECIFIED;
    case 1:
    case "AUTOML":
      return UserEvent_EventSource.AUTOML;
    case 2:
    case "ECOMMERCE":
      return UserEvent_EventSource.ECOMMERCE;
    case 3:
    case "BATCH_UPLOAD":
      return UserEvent_EventSource.BATCH_UPLOAD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserEvent_EventSource.UNRECOGNIZED;
  }
}

export function userEvent_EventSourceToJSON(object: UserEvent_EventSource): string {
  switch (object) {
    case UserEvent_EventSource.EVENT_SOURCE_UNSPECIFIED:
      return "EVENT_SOURCE_UNSPECIFIED";
    case UserEvent_EventSource.AUTOML:
      return "AUTOML";
    case UserEvent_EventSource.ECOMMERCE:
      return "ECOMMERCE";
    case UserEvent_EventSource.BATCH_UPLOAD:
      return "BATCH_UPLOAD";
    case UserEvent_EventSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information of end users. */
export interface UserInfo {
  /**
   * Required. A unique identifier for tracking visitors with a length limit of
   * 128 bytes.
   *
   * For example, this could be implemented with a http cookie, which should be
   * able to uniquely identify a visitor on a single device. This unique
   * identifier should not change if the visitor log in/out of the website.
   * Maximum length 128 bytes. Cannot be empty.
   */
  visitorId: string;
  /**
   * Optional. Unique identifier for logged-in user with a length limit of 128
   * bytes. Required only for logged-in users.
   */
  userId: string;
  /**
   * Optional. IP address of the user. This could be either IPv4 (e.g. 104.133.9.80) or
   * IPv6 (e.g. 2001:0db8:85a3:0000:0000:8a2e:0370:7334). This should *not* be
   * set when using the javascript pixel or if `direct_user_request` is set.
   * Used to extract location information for personalization.
   */
  ipAddress: string;
  /**
   * Optional. User agent as included in the HTTP header. UTF-8 encoded string
   * with a length limit of 1 KiB.
   *
   * This should *not* be set when using the JavaScript pixel or if
   * `directUserRequest` is set.
   */
  userAgent: string;
  /**
   * Optional. Indicates if the request is made directly from the end user
   * in which case the user_agent and ip_address fields can be populated
   * from the HTTP request. This should *not* be set when using the javascript
   * pixel. This flag should be set only if the API request is made directly
   * from the end user such as a mobile app (and not if a gateway or a server is
   * processing and pushing the user events).
   */
  directUserRequest: boolean;
}

/** User event details shared by all recommendation types. */
export interface EventDetail {
  /**
   * Optional. Complete url (window.location.href) of the user's current page.
   * When using the JavaScript pixel, this value is filled in automatically.
   * Maximum length 5KB.
   */
  uri: string;
  /**
   * Optional. The referrer url of the current page. When using
   * the JavaScript pixel, this value is filled in automatically.
   */
  referrerUri: string;
  /**
   * Optional. A unique id of a web page view.
   * This should be kept the same for all user events triggered from the same
   * pageview. For example, an item detail page view could trigger multiple
   * events as the user is browsing the page.
   * The `pageViewId` property should be kept the same for all these events so
   * that they can be grouped together properly. This `pageViewId` will be
   * automatically generated if using the JavaScript pixel.
   */
  pageViewId: string;
  /**
   * Optional. A list of identifiers for the independent experiment groups
   * this user event belongs to. This is used to distinguish between user events
   * associated with different experiment setups (e.g. using Recommendation
   * Engine system, using different recommendation models).
   */
  experimentIds: string[];
  /**
   * Optional. Recommendation token included in the recommendation prediction
   * response.
   *
   * This field enables accurate attribution of recommendation model
   * performance.
   *
   * This token enables us to accurately attribute page view or purchase back to
   * the event and the particular predict response containing this
   * clicked/purchased item. If user clicks on product K in the recommendation
   * results, pass the `PredictResponse.recommendationToken` property as a url
   * parameter to product K's page. When recording events on product K's page,
   * log the PredictResponse.recommendation_token to this field.
   *
   * Optional, but highly encouraged for user events that are the result of a
   * recommendation prediction query.
   */
  recommendationToken: string;
  /**
   * Optional. Extra user event features to include in the recommendation
   * model.
   *
   * For product recommendation, an example of extra user information is
   * traffic_channel, i.e. how user arrives at the site. Users can arrive
   * at the site by coming to the site directly, or coming through Google
   * search, and etc.
   */
  eventAttributes: FeatureMap | undefined;
}

/**
 * ProductEventDetail captures user event information specific to retail
 * products.
 */
export interface ProductEventDetail {
  /**
   * Required for `search` events. Other event types should not set this field.
   * The user's search query as UTF-8 encoded text with a length limit of 5 KiB.
   */
  searchQuery: string;
  /**
   * Required for `category-page-view` events. Other event types should not set
   * this field.
   * The categories associated with a category page.
   * Category pages include special pages such as sales or promotions. For
   * instance, a special sale page may have the category hierarchy:
   * categories : ["Sales", "2017 Black Friday Deals"].
   */
  pageCategories: CatalogItem_CategoryHierarchy[];
  /**
   * The main product details related to the event.
   *
   * This field is required for the following event types:
   *
   * * `add-to-cart`
   * * `add-to-list`
   * * `checkout-start`
   * * `detail-page-view`
   * * `purchase-complete`
   * * `refund`
   * * `remove-from-cart`
   * * `remove-from-list`
   *
   * This field is optional for the following event types:
   *
   * * `page-visit`
   * * `shopping-cart-page-view` - note that 'product_details' should be set for
   *   this unless the shopping cart is empty.
   *
   * This field is not allowed for the following event types:
   *
   * * `category-page-view`
   * * `home-page-view`
   * * `search`
   */
  productDetails: ProductDetail[];
  /**
   * Required for `add-to-list` and `remove-from-list` events. The id or name of
   * the list that the item is being added to or removed from. Other event types
   * should not set this field.
   */
  listId: string;
  /**
   * Optional. The id or name of the associated shopping cart. This id is used
   * to associate multiple items added or present in the cart before purchase.
   *
   * This can only be set for `add-to-cart`, `remove-from-cart`,
   * `checkout-start`, `purchase-complete`, or `shopping-cart-page-view` events.
   */
  cartId: string;
  /**
   * Optional. A transaction represents the entire purchase transaction.
   * Required for `purchase-complete` events. Optional for `checkout-start`
   * events. Other event types should not set this field.
   */
  purchaseTransaction: PurchaseTransaction | undefined;
}

/** A transaction represents the entire purchase transaction. */
export interface PurchaseTransaction {
  /** Optional. The transaction ID with a length limit of 128 bytes. */
  id: string;
  /**
   * Required. Total revenue or grand total associated with the transaction.
   * This value include shipping, tax, or other adjustments to total revenue
   * that you want to include as part of your revenue calculations. This field
   * is not required if the event type is `refund`.
   */
  revenue: number;
  /** Optional. All the taxes associated with the transaction. */
  taxes: { [key: string]: number };
  /**
   * Optional. All the costs associated with the product. These can be
   * manufacturing costs, shipping expenses not borne by the end user, or any
   * other costs.
   *
   * Total product cost such that
   *   profit = revenue - (sum(taxes) + sum(costs))
   * If product_cost is not set, then
   *   profit = revenue - tax - shipping - sum(CatalogItem.costs).
   *
   * If CatalogItem.cost is not specified for one of the items, CatalogItem.cost
   * based profit *cannot* be calculated for this Transaction.
   */
  costs: { [key: string]: number };
  /**
   * Required. Currency code. Use three-character ISO-4217 code. This field
   * is not required if the event type is `refund`.
   */
  currencyCode: string;
}

export interface PurchaseTransaction_TaxesEntry {
  key: string;
  value: number;
}

export interface PurchaseTransaction_CostsEntry {
  key: string;
  value: number;
}

/** Detailed product information associated with a user event. */
export interface ProductDetail {
  /**
   * Required. Catalog item ID. UTF-8 encoded string with a length limit of 128
   * characters.
   */
  id: string;
  /**
   * Optional. Currency code for price/costs. Use three-character ISO-4217
   * code. Required only if originalPrice or displayPrice is set.
   */
  currencyCode: string;
  /**
   * Optional. Original price of the product. If provided, this will override
   * the original price in Catalog for this product.
   */
  originalPrice: number;
  /**
   * Optional. Display price of the product (e.g. discounted price). If
   * provided, this will override the display price in Catalog for this product.
   */
  displayPrice: number;
  /**
   * Optional. Item stock state. If provided, this overrides the stock state
   * in Catalog for items in this event.
   */
  stockState: ProductCatalogItem_StockState;
  /**
   * Optional. Quantity of the product associated with the user event. For
   * example, this field will be 2 if two products are added to the shopping
   * cart for `add-to-cart` event. Required for `add-to-cart`, `add-to-list`,
   * `remove-from-cart`, `checkout-start`, `purchase-complete`, `refund` event
   * types.
   */
  quantity: number;
  /**
   * Optional. Quantity of the products in stock when a user event happens.
   * Optional. If provided, this overrides the available quantity in Catalog for
   * this event. and can only be set if `stock_status` is set to `IN_STOCK`.
   *
   * Note that if an item is out of stock, you must set the `stock_state` field
   * to be `OUT_OF_STOCK`. Leaving this field unspecified / as zero is not
   * sufficient to mark the item out of stock.
   */
  availableQuantity: number;
  /** Optional. Extra features associated with a product in the user event. */
  itemAttributes: FeatureMap | undefined;
}

function createBaseUserEvent(): UserEvent {
  return {
    eventType: "",
    userInfo: undefined,
    eventDetail: undefined,
    productEventDetail: undefined,
    eventTime: undefined,
    eventSource: 0,
  };
}

export const UserEvent: MessageFns<UserEvent> = {
  encode(message: UserEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventType !== "") {
      writer.uint32(10).string(message.eventType);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(18).fork()).join();
    }
    if (message.eventDetail !== undefined) {
      EventDetail.encode(message.eventDetail, writer.uint32(26).fork()).join();
    }
    if (message.productEventDetail !== undefined) {
      ProductEventDetail.encode(message.productEventDetail, writer.uint32(34).fork()).join();
    }
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(42).fork()).join();
    }
    if (message.eventSource !== 0) {
      writer.uint32(48).int32(message.eventSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.eventType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.eventDetail = EventDetail.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.productEventDetail = ProductEventDetail.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.eventSource = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserEvent {
    return {
      eventType: isSet(object.eventType) ? globalThis.String(object.eventType) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
      eventDetail: isSet(object.eventDetail) ? EventDetail.fromJSON(object.eventDetail) : undefined,
      productEventDetail: isSet(object.productEventDetail)
        ? ProductEventDetail.fromJSON(object.productEventDetail)
        : undefined,
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
      eventSource: isSet(object.eventSource) ? userEvent_EventSourceFromJSON(object.eventSource) : 0,
    };
  },

  toJSON(message: UserEvent): unknown {
    const obj: any = {};
    if (message.eventType !== "") {
      obj.eventType = message.eventType;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    if (message.eventDetail !== undefined) {
      obj.eventDetail = EventDetail.toJSON(message.eventDetail);
    }
    if (message.productEventDetail !== undefined) {
      obj.productEventDetail = ProductEventDetail.toJSON(message.productEventDetail);
    }
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    if (message.eventSource !== 0) {
      obj.eventSource = userEvent_EventSourceToJSON(message.eventSource);
    }
    return obj;
  },

  create(base?: DeepPartial<UserEvent>): UserEvent {
    return UserEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserEvent>): UserEvent {
    const message = createBaseUserEvent();
    message.eventType = object.eventType ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    message.eventDetail = (object.eventDetail !== undefined && object.eventDetail !== null)
      ? EventDetail.fromPartial(object.eventDetail)
      : undefined;
    message.productEventDetail = (object.productEventDetail !== undefined && object.productEventDetail !== null)
      ? ProductEventDetail.fromPartial(object.productEventDetail)
      : undefined;
    message.eventTime = object.eventTime ?? undefined;
    message.eventSource = object.eventSource ?? 0;
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { visitorId: "", userId: "", ipAddress: "", userAgent: "", directUserRequest: false };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.visitorId !== "") {
      writer.uint32(10).string(message.visitorId);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.ipAddress !== "") {
      writer.uint32(26).string(message.ipAddress);
    }
    if (message.userAgent !== "") {
      writer.uint32(34).string(message.userAgent);
    }
    if (message.directUserRequest !== false) {
      writer.uint32(40).bool(message.directUserRequest);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.visitorId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.directUserRequest = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      visitorId: isSet(object.visitorId) ? globalThis.String(object.visitorId) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      directUserRequest: isSet(object.directUserRequest) ? globalThis.Boolean(object.directUserRequest) : false,
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.visitorId !== "") {
      obj.visitorId = message.visitorId;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.ipAddress !== "") {
      obj.ipAddress = message.ipAddress;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.directUserRequest !== false) {
      obj.directUserRequest = message.directUserRequest;
    }
    return obj;
  },

  create(base?: DeepPartial<UserInfo>): UserInfo {
    return UserInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UserInfo>): UserInfo {
    const message = createBaseUserInfo();
    message.visitorId = object.visitorId ?? "";
    message.userId = object.userId ?? "";
    message.ipAddress = object.ipAddress ?? "";
    message.userAgent = object.userAgent ?? "";
    message.directUserRequest = object.directUserRequest ?? false;
    return message;
  },
};

function createBaseEventDetail(): EventDetail {
  return {
    uri: "",
    referrerUri: "",
    pageViewId: "",
    experimentIds: [],
    recommendationToken: "",
    eventAttributes: undefined,
  };
}

export const EventDetail: MessageFns<EventDetail> = {
  encode(message: EventDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uri !== "") {
      writer.uint32(10).string(message.uri);
    }
    if (message.referrerUri !== "") {
      writer.uint32(50).string(message.referrerUri);
    }
    if (message.pageViewId !== "") {
      writer.uint32(18).string(message.pageViewId);
    }
    for (const v of message.experimentIds) {
      writer.uint32(26).string(v!);
    }
    if (message.recommendationToken !== "") {
      writer.uint32(34).string(message.recommendationToken);
    }
    if (message.eventAttributes !== undefined) {
      FeatureMap.encode(message.eventAttributes, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.referrerUri = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageViewId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.experimentIds.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.recommendationToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.eventAttributes = FeatureMap.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventDetail {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      referrerUri: isSet(object.referrerUri) ? globalThis.String(object.referrerUri) : "",
      pageViewId: isSet(object.pageViewId) ? globalThis.String(object.pageViewId) : "",
      experimentIds: globalThis.Array.isArray(object?.experimentIds)
        ? object.experimentIds.map((e: any) => globalThis.String(e))
        : [],
      recommendationToken: isSet(object.recommendationToken) ? globalThis.String(object.recommendationToken) : "",
      eventAttributes: isSet(object.eventAttributes) ? FeatureMap.fromJSON(object.eventAttributes) : undefined,
    };
  },

  toJSON(message: EventDetail): unknown {
    const obj: any = {};
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.referrerUri !== "") {
      obj.referrerUri = message.referrerUri;
    }
    if (message.pageViewId !== "") {
      obj.pageViewId = message.pageViewId;
    }
    if (message.experimentIds?.length) {
      obj.experimentIds = message.experimentIds;
    }
    if (message.recommendationToken !== "") {
      obj.recommendationToken = message.recommendationToken;
    }
    if (message.eventAttributes !== undefined) {
      obj.eventAttributes = FeatureMap.toJSON(message.eventAttributes);
    }
    return obj;
  },

  create(base?: DeepPartial<EventDetail>): EventDetail {
    return EventDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EventDetail>): EventDetail {
    const message = createBaseEventDetail();
    message.uri = object.uri ?? "";
    message.referrerUri = object.referrerUri ?? "";
    message.pageViewId = object.pageViewId ?? "";
    message.experimentIds = object.experimentIds?.map((e) => e) || [];
    message.recommendationToken = object.recommendationToken ?? "";
    message.eventAttributes = (object.eventAttributes !== undefined && object.eventAttributes !== null)
      ? FeatureMap.fromPartial(object.eventAttributes)
      : undefined;
    return message;
  },
};

function createBaseProductEventDetail(): ProductEventDetail {
  return {
    searchQuery: "",
    pageCategories: [],
    productDetails: [],
    listId: "",
    cartId: "",
    purchaseTransaction: undefined,
  };
}

export const ProductEventDetail: MessageFns<ProductEventDetail> = {
  encode(message: ProductEventDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.searchQuery !== "") {
      writer.uint32(10).string(message.searchQuery);
    }
    for (const v of message.pageCategories) {
      CatalogItem_CategoryHierarchy.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.productDetails) {
      ProductDetail.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.listId !== "") {
      writer.uint32(34).string(message.listId);
    }
    if (message.cartId !== "") {
      writer.uint32(42).string(message.cartId);
    }
    if (message.purchaseTransaction !== undefined) {
      PurchaseTransaction.encode(message.purchaseTransaction, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductEventDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductEventDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.searchQuery = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageCategories.push(CatalogItem_CategoryHierarchy.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.productDetails.push(ProductDetail.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.listId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cartId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.purchaseTransaction = PurchaseTransaction.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductEventDetail {
    return {
      searchQuery: isSet(object.searchQuery) ? globalThis.String(object.searchQuery) : "",
      pageCategories: globalThis.Array.isArray(object?.pageCategories)
        ? object.pageCategories.map((e: any) => CatalogItem_CategoryHierarchy.fromJSON(e))
        : [],
      productDetails: globalThis.Array.isArray(object?.productDetails)
        ? object.productDetails.map((e: any) => ProductDetail.fromJSON(e))
        : [],
      listId: isSet(object.listId) ? globalThis.String(object.listId) : "",
      cartId: isSet(object.cartId) ? globalThis.String(object.cartId) : "",
      purchaseTransaction: isSet(object.purchaseTransaction)
        ? PurchaseTransaction.fromJSON(object.purchaseTransaction)
        : undefined,
    };
  },

  toJSON(message: ProductEventDetail): unknown {
    const obj: any = {};
    if (message.searchQuery !== "") {
      obj.searchQuery = message.searchQuery;
    }
    if (message.pageCategories?.length) {
      obj.pageCategories = message.pageCategories.map((e) => CatalogItem_CategoryHierarchy.toJSON(e));
    }
    if (message.productDetails?.length) {
      obj.productDetails = message.productDetails.map((e) => ProductDetail.toJSON(e));
    }
    if (message.listId !== "") {
      obj.listId = message.listId;
    }
    if (message.cartId !== "") {
      obj.cartId = message.cartId;
    }
    if (message.purchaseTransaction !== undefined) {
      obj.purchaseTransaction = PurchaseTransaction.toJSON(message.purchaseTransaction);
    }
    return obj;
  },

  create(base?: DeepPartial<ProductEventDetail>): ProductEventDetail {
    return ProductEventDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductEventDetail>): ProductEventDetail {
    const message = createBaseProductEventDetail();
    message.searchQuery = object.searchQuery ?? "";
    message.pageCategories = object.pageCategories?.map((e) => CatalogItem_CategoryHierarchy.fromPartial(e)) || [];
    message.productDetails = object.productDetails?.map((e) => ProductDetail.fromPartial(e)) || [];
    message.listId = object.listId ?? "";
    message.cartId = object.cartId ?? "";
    message.purchaseTransaction = (object.purchaseTransaction !== undefined && object.purchaseTransaction !== null)
      ? PurchaseTransaction.fromPartial(object.purchaseTransaction)
      : undefined;
    return message;
  },
};

function createBasePurchaseTransaction(): PurchaseTransaction {
  return { id: "", revenue: 0, taxes: {}, costs: {}, currencyCode: "" };
}

export const PurchaseTransaction: MessageFns<PurchaseTransaction> = {
  encode(message: PurchaseTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.revenue !== 0) {
      writer.uint32(21).float(message.revenue);
    }
    Object.entries(message.taxes).forEach(([key, value]) => {
      PurchaseTransaction_TaxesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    Object.entries(message.costs).forEach(([key, value]) => {
      PurchaseTransaction_CostsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.currencyCode !== "") {
      writer.uint32(50).string(message.currencyCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurchaseTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurchaseTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.revenue = reader.float();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = PurchaseTransaction_TaxesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.taxes[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = PurchaseTransaction_CostsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.costs[entry4.key] = entry4.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurchaseTransaction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      revenue: isSet(object.revenue) ? globalThis.Number(object.revenue) : 0,
      taxes: isObject(object.taxes)
        ? Object.entries(object.taxes).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      costs: isObject(object.costs)
        ? Object.entries(object.costs).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
    };
  },

  toJSON(message: PurchaseTransaction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.revenue !== 0) {
      obj.revenue = message.revenue;
    }
    if (message.taxes) {
      const entries = Object.entries(message.taxes);
      if (entries.length > 0) {
        obj.taxes = {};
        entries.forEach(([k, v]) => {
          obj.taxes[k] = v;
        });
      }
    }
    if (message.costs) {
      const entries = Object.entries(message.costs);
      if (entries.length > 0) {
        obj.costs = {};
        entries.forEach(([k, v]) => {
          obj.costs[k] = v;
        });
      }
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    return obj;
  },

  create(base?: DeepPartial<PurchaseTransaction>): PurchaseTransaction {
    return PurchaseTransaction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurchaseTransaction>): PurchaseTransaction {
    const message = createBasePurchaseTransaction();
    message.id = object.id ?? "";
    message.revenue = object.revenue ?? 0;
    message.taxes = Object.entries(object.taxes ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.costs = Object.entries(object.costs ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.currencyCode = object.currencyCode ?? "";
    return message;
  },
};

function createBasePurchaseTransaction_TaxesEntry(): PurchaseTransaction_TaxesEntry {
  return { key: "", value: 0 };
}

export const PurchaseTransaction_TaxesEntry: MessageFns<PurchaseTransaction_TaxesEntry> = {
  encode(message: PurchaseTransaction_TaxesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurchaseTransaction_TaxesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurchaseTransaction_TaxesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurchaseTransaction_TaxesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: PurchaseTransaction_TaxesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PurchaseTransaction_TaxesEntry>): PurchaseTransaction_TaxesEntry {
    return PurchaseTransaction_TaxesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurchaseTransaction_TaxesEntry>): PurchaseTransaction_TaxesEntry {
    const message = createBasePurchaseTransaction_TaxesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBasePurchaseTransaction_CostsEntry(): PurchaseTransaction_CostsEntry {
  return { key: "", value: 0 };
}

export const PurchaseTransaction_CostsEntry: MessageFns<PurchaseTransaction_CostsEntry> = {
  encode(message: PurchaseTransaction_CostsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PurchaseTransaction_CostsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePurchaseTransaction_CostsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PurchaseTransaction_CostsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: PurchaseTransaction_CostsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<PurchaseTransaction_CostsEntry>): PurchaseTransaction_CostsEntry {
    return PurchaseTransaction_CostsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PurchaseTransaction_CostsEntry>): PurchaseTransaction_CostsEntry {
    const message = createBasePurchaseTransaction_CostsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseProductDetail(): ProductDetail {
  return {
    id: "",
    currencyCode: "",
    originalPrice: 0,
    displayPrice: 0,
    stockState: 0,
    quantity: 0,
    availableQuantity: 0,
    itemAttributes: undefined,
  };
}

export const ProductDetail: MessageFns<ProductDetail> = {
  encode(message: ProductDetail, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.currencyCode !== "") {
      writer.uint32(18).string(message.currencyCode);
    }
    if (message.originalPrice !== 0) {
      writer.uint32(29).float(message.originalPrice);
    }
    if (message.displayPrice !== 0) {
      writer.uint32(37).float(message.displayPrice);
    }
    if (message.stockState !== 0) {
      writer.uint32(40).int32(message.stockState);
    }
    if (message.quantity !== 0) {
      writer.uint32(48).int32(message.quantity);
    }
    if (message.availableQuantity !== 0) {
      writer.uint32(56).int32(message.availableQuantity);
    }
    if (message.itemAttributes !== undefined) {
      FeatureMap.encode(message.itemAttributes, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductDetail {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currencyCode = reader.string();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.originalPrice = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.displayPrice = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.stockState = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.availableQuantity = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.itemAttributes = FeatureMap.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductDetail {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      currencyCode: isSet(object.currencyCode) ? globalThis.String(object.currencyCode) : "",
      originalPrice: isSet(object.originalPrice) ? globalThis.Number(object.originalPrice) : 0,
      displayPrice: isSet(object.displayPrice) ? globalThis.Number(object.displayPrice) : 0,
      stockState: isSet(object.stockState) ? productCatalogItem_StockStateFromJSON(object.stockState) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
      availableQuantity: isSet(object.availableQuantity) ? globalThis.Number(object.availableQuantity) : 0,
      itemAttributes: isSet(object.itemAttributes) ? FeatureMap.fromJSON(object.itemAttributes) : undefined,
    };
  },

  toJSON(message: ProductDetail): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.currencyCode !== "") {
      obj.currencyCode = message.currencyCode;
    }
    if (message.originalPrice !== 0) {
      obj.originalPrice = message.originalPrice;
    }
    if (message.displayPrice !== 0) {
      obj.displayPrice = message.displayPrice;
    }
    if (message.stockState !== 0) {
      obj.stockState = productCatalogItem_StockStateToJSON(message.stockState);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.availableQuantity !== 0) {
      obj.availableQuantity = Math.round(message.availableQuantity);
    }
    if (message.itemAttributes !== undefined) {
      obj.itemAttributes = FeatureMap.toJSON(message.itemAttributes);
    }
    return obj;
  },

  create(base?: DeepPartial<ProductDetail>): ProductDetail {
    return ProductDetail.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductDetail>): ProductDetail {
    const message = createBaseProductDetail();
    message.id = object.id ?? "";
    message.currencyCode = object.currencyCode ?? "";
    message.originalPrice = object.originalPrice ?? 0;
    message.displayPrice = object.displayPrice ?? 0;
    message.stockState = object.stockState ?? 0;
    message.quantity = object.quantity ?? 0;
    message.availableQuantity = object.availableQuantity ?? 0;
    message.itemAttributes = (object.itemAttributes !== undefined && object.itemAttributes !== null)
      ? FeatureMap.fromPartial(object.itemAttributes)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
