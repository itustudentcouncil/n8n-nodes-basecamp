// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/pubsublite/v1/subscriber.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Cursor, SequencedMessage } from "./common.js";

export const protobufPackage = "google.cloud.pubsublite.v1";

/**
 * The first request that must be sent on a newly-opened stream. The client must
 * wait for the response before sending subsequent requests on the stream.
 */
export interface InitialSubscribeRequest {
  /** The subscription from which to receive messages. */
  subscription: string;
  /**
   * The partition from which to receive messages. Partitions are zero indexed,
   * so `partition` must be in the range [0, topic.num_partitions).
   */
  partition: Long;
  /**
   * Optional. Initial target location within the message backlog. If not set,
   * messages will be delivered from the commit cursor for the given
   * subscription and partition.
   */
  initialLocation: SeekRequest | undefined;
}

/** Response to an InitialSubscribeRequest. */
export interface InitialSubscribeResponse {
  /**
   * The cursor from which the subscriber will start receiving messages once
   * flow control tokens become available.
   */
  cursor: Cursor | undefined;
}

/**
 * Request to update the stream's delivery cursor based on the given target.
 * Resets the server available tokens to 0. SeekRequests past head result in
 * stream breakage.
 *
 * SeekRequests may not be sent while another SeekRequest is outstanding (i.e.,
 * has not received a SeekResponse) on the same stream.
 */
export interface SeekRequest {
  /** A named target. */
  namedTarget?:
    | SeekRequest_NamedTarget
    | undefined;
  /**
   * A target corresponding to the cursor, pointing to anywhere in the
   * topic partition.
   */
  cursor?: Cursor | undefined;
}

/** A special target in the partition that takes no other parameters. */
export enum SeekRequest_NamedTarget {
  /** NAMED_TARGET_UNSPECIFIED - Default value. This value is unused. */
  NAMED_TARGET_UNSPECIFIED = 0,
  /**
   * HEAD - A target corresponding to the most recently published message in the
   * partition.
   */
  HEAD = 1,
  /**
   * COMMITTED_CURSOR - A target corresponding to the committed cursor for the given subscription
   * and topic partition.
   */
  COMMITTED_CURSOR = 2,
  UNRECOGNIZED = -1,
}

export function seekRequest_NamedTargetFromJSON(object: any): SeekRequest_NamedTarget {
  switch (object) {
    case 0:
    case "NAMED_TARGET_UNSPECIFIED":
      return SeekRequest_NamedTarget.NAMED_TARGET_UNSPECIFIED;
    case 1:
    case "HEAD":
      return SeekRequest_NamedTarget.HEAD;
    case 2:
    case "COMMITTED_CURSOR":
      return SeekRequest_NamedTarget.COMMITTED_CURSOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SeekRequest_NamedTarget.UNRECOGNIZED;
  }
}

export function seekRequest_NamedTargetToJSON(object: SeekRequest_NamedTarget): string {
  switch (object) {
    case SeekRequest_NamedTarget.NAMED_TARGET_UNSPECIFIED:
      return "NAMED_TARGET_UNSPECIFIED";
    case SeekRequest_NamedTarget.HEAD:
      return "HEAD";
    case SeekRequest_NamedTarget.COMMITTED_CURSOR:
      return "COMMITTED_CURSOR";
    case SeekRequest_NamedTarget.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Response to a SeekRequest. */
export interface SeekResponse {
  /** The new delivery cursor for the current stream. */
  cursor: Cursor | undefined;
}

/**
 * Request to grant tokens to the server, requesting delivery of messages when
 * they become available.
 */
export interface FlowControlRequest {
  /** The number of message tokens to grant. Must be greater than or equal to 0. */
  allowedMessages: Long;
  /** The number of byte tokens to grant. Must be greater than or equal to 0. */
  allowedBytes: Long;
}

/** A request sent from the client to the server on a stream. */
export interface SubscribeRequest {
  /** Initial request on the stream. */
  initial?:
    | InitialSubscribeRequest
    | undefined;
  /** Request to update the stream's delivery cursor. */
  seek?:
    | SeekRequest
    | undefined;
  /** Request to grant tokens to the server, */
  flowControl?: FlowControlRequest | undefined;
}

/**
 * Response containing a list of messages. Upon delivering a MessageResponse to
 * the client, the server:
 * *  Updates the stream's delivery cursor to one greater than the cursor of the
 *    last message in the list.
 * *  Subtracts the total number of bytes and messages from the tokens available
 *    to the server.
 */
export interface MessageResponse {
  /** Messages from the topic partition. */
  messages: SequencedMessage[];
}

/** Response to SubscribeRequest. */
export interface SubscribeResponse {
  /** Initial response on the stream. */
  initial?:
    | InitialSubscribeResponse
    | undefined;
  /** Response to a Seek operation. */
  seek?:
    | SeekResponse
    | undefined;
  /** Response containing messages from the topic partition. */
  messages?: MessageResponse | undefined;
}

/**
 * The first request that must be sent on a newly-opened stream. The client must
 * wait for the response before sending subsequent requests on the stream.
 */
export interface InitialPartitionAssignmentRequest {
  /**
   * The subscription name. Structured like:
   * projects/<project number>/locations/<zone name>/subscriptions/<subscription
   * id>
   */
  subscription: string;
  /**
   * An opaque, unique client identifier. This field must be exactly 16 bytes
   * long and is interpreted as an unsigned 128 bit integer. Other size values
   * will be rejected and the stream will be failed with a non-retryable error.
   *
   * This field is large enough to fit a uuid from standard uuid algorithms like
   * uuid1 or uuid4, which should be used to generate this number. The same
   * identifier should be reused following disconnections with retryable stream
   * errors.
   */
  clientId: Buffer;
}

/**
 * PartitionAssignments should not race with acknowledgements. There
 * should be exactly one unacknowledged PartitionAssignment at a time. If not,
 * the client must break the stream.
 */
export interface PartitionAssignment {
  /** The list of partition numbers this subscriber is assigned to. */
  partitions: Long[];
}

/**
 * Acknowledge receipt and handling of the previous assignment.
 * If not sent within a short period after receiving the assignment,
 * partitions may remain unassigned for a period of time until the
 * client is known to be inactive, after which time the server will break the
 * stream.
 */
export interface PartitionAssignmentAck {
}

/** A request on the PartitionAssignment stream. */
export interface PartitionAssignmentRequest {
  /** Initial request on the stream. */
  initial?:
    | InitialPartitionAssignmentRequest
    | undefined;
  /** Acknowledgement of a partition assignment. */
  ack?: PartitionAssignmentAck | undefined;
}

function createBaseInitialSubscribeRequest(): InitialSubscribeRequest {
  return { subscription: "", partition: Long.ZERO, initialLocation: undefined };
}

export const InitialSubscribeRequest: MessageFns<InitialSubscribeRequest> = {
  encode(message: InitialSubscribeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscription !== "") {
      writer.uint32(10).string(message.subscription);
    }
    if (!message.partition.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.partition.toString());
    }
    if (message.initialLocation !== undefined) {
      SeekRequest.encode(message.initialLocation, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitialSubscribeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscription = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.partition = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.initialLocation = SeekRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialSubscribeRequest {
    return {
      subscription: isSet(object.subscription) ? globalThis.String(object.subscription) : "",
      partition: isSet(object.partition) ? Long.fromValue(object.partition) : Long.ZERO,
      initialLocation: isSet(object.initialLocation) ? SeekRequest.fromJSON(object.initialLocation) : undefined,
    };
  },

  toJSON(message: InitialSubscribeRequest): unknown {
    const obj: any = {};
    if (message.subscription !== "") {
      obj.subscription = message.subscription;
    }
    if (!message.partition.equals(Long.ZERO)) {
      obj.partition = (message.partition || Long.ZERO).toString();
    }
    if (message.initialLocation !== undefined) {
      obj.initialLocation = SeekRequest.toJSON(message.initialLocation);
    }
    return obj;
  },

  create(base?: DeepPartial<InitialSubscribeRequest>): InitialSubscribeRequest {
    return InitialSubscribeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitialSubscribeRequest>): InitialSubscribeRequest {
    const message = createBaseInitialSubscribeRequest();
    message.subscription = object.subscription ?? "";
    message.partition = (object.partition !== undefined && object.partition !== null)
      ? Long.fromValue(object.partition)
      : Long.ZERO;
    message.initialLocation = (object.initialLocation !== undefined && object.initialLocation !== null)
      ? SeekRequest.fromPartial(object.initialLocation)
      : undefined;
    return message;
  },
};

function createBaseInitialSubscribeResponse(): InitialSubscribeResponse {
  return { cursor: undefined };
}

export const InitialSubscribeResponse: MessageFns<InitialSubscribeResponse> = {
  encode(message: InitialSubscribeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitialSubscribeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialSubscribeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialSubscribeResponse {
    return { cursor: isSet(object.cursor) ? Cursor.fromJSON(object.cursor) : undefined };
  },

  toJSON(message: InitialSubscribeResponse): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<InitialSubscribeResponse>): InitialSubscribeResponse {
    return InitialSubscribeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitialSubscribeResponse>): InitialSubscribeResponse {
    const message = createBaseInitialSubscribeResponse();
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseSeekRequest(): SeekRequest {
  return { namedTarget: undefined, cursor: undefined };
}

export const SeekRequest: MessageFns<SeekRequest> = {
  encode(message: SeekRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namedTarget !== undefined) {
      writer.uint32(8).int32(message.namedTarget);
    }
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SeekRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeekRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.namedTarget = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SeekRequest {
    return {
      namedTarget: isSet(object.namedTarget) ? seekRequest_NamedTargetFromJSON(object.namedTarget) : undefined,
      cursor: isSet(object.cursor) ? Cursor.fromJSON(object.cursor) : undefined,
    };
  },

  toJSON(message: SeekRequest): unknown {
    const obj: any = {};
    if (message.namedTarget !== undefined) {
      obj.namedTarget = seekRequest_NamedTargetToJSON(message.namedTarget);
    }
    if (message.cursor !== undefined) {
      obj.cursor = Cursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<SeekRequest>): SeekRequest {
    return SeekRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SeekRequest>): SeekRequest {
    const message = createBaseSeekRequest();
    message.namedTarget = object.namedTarget ?? undefined;
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseSeekResponse(): SeekResponse {
  return { cursor: undefined };
}

export const SeekResponse: MessageFns<SeekResponse> = {
  encode(message: SeekResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SeekResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSeekResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SeekResponse {
    return { cursor: isSet(object.cursor) ? Cursor.fromJSON(object.cursor) : undefined };
  },

  toJSON(message: SeekResponse): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<SeekResponse>): SeekResponse {
    return SeekResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SeekResponse>): SeekResponse {
    const message = createBaseSeekResponse();
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseFlowControlRequest(): FlowControlRequest {
  return { allowedMessages: Long.ZERO, allowedBytes: Long.ZERO };
}

export const FlowControlRequest: MessageFns<FlowControlRequest> = {
  encode(message: FlowControlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.allowedMessages.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.allowedMessages.toString());
    }
    if (!message.allowedBytes.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.allowedBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FlowControlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFlowControlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.allowedMessages = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.allowedBytes = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FlowControlRequest {
    return {
      allowedMessages: isSet(object.allowedMessages) ? Long.fromValue(object.allowedMessages) : Long.ZERO,
      allowedBytes: isSet(object.allowedBytes) ? Long.fromValue(object.allowedBytes) : Long.ZERO,
    };
  },

  toJSON(message: FlowControlRequest): unknown {
    const obj: any = {};
    if (!message.allowedMessages.equals(Long.ZERO)) {
      obj.allowedMessages = (message.allowedMessages || Long.ZERO).toString();
    }
    if (!message.allowedBytes.equals(Long.ZERO)) {
      obj.allowedBytes = (message.allowedBytes || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<FlowControlRequest>): FlowControlRequest {
    return FlowControlRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FlowControlRequest>): FlowControlRequest {
    const message = createBaseFlowControlRequest();
    message.allowedMessages = (object.allowedMessages !== undefined && object.allowedMessages !== null)
      ? Long.fromValue(object.allowedMessages)
      : Long.ZERO;
    message.allowedBytes = (object.allowedBytes !== undefined && object.allowedBytes !== null)
      ? Long.fromValue(object.allowedBytes)
      : Long.ZERO;
    return message;
  },
};

function createBaseSubscribeRequest(): SubscribeRequest {
  return { initial: undefined, seek: undefined, flowControl: undefined };
}

export const SubscribeRequest: MessageFns<SubscribeRequest> = {
  encode(message: SubscribeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initial !== undefined) {
      InitialSubscribeRequest.encode(message.initial, writer.uint32(10).fork()).join();
    }
    if (message.seek !== undefined) {
      SeekRequest.encode(message.seek, writer.uint32(18).fork()).join();
    }
    if (message.flowControl !== undefined) {
      FlowControlRequest.encode(message.flowControl, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.initial = InitialSubscribeRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.seek = SeekRequest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.flowControl = FlowControlRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeRequest {
    return {
      initial: isSet(object.initial) ? InitialSubscribeRequest.fromJSON(object.initial) : undefined,
      seek: isSet(object.seek) ? SeekRequest.fromJSON(object.seek) : undefined,
      flowControl: isSet(object.flowControl) ? FlowControlRequest.fromJSON(object.flowControl) : undefined,
    };
  },

  toJSON(message: SubscribeRequest): unknown {
    const obj: any = {};
    if (message.initial !== undefined) {
      obj.initial = InitialSubscribeRequest.toJSON(message.initial);
    }
    if (message.seek !== undefined) {
      obj.seek = SeekRequest.toJSON(message.seek);
    }
    if (message.flowControl !== undefined) {
      obj.flowControl = FlowControlRequest.toJSON(message.flowControl);
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeRequest>): SubscribeRequest {
    return SubscribeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeRequest>): SubscribeRequest {
    const message = createBaseSubscribeRequest();
    message.initial = (object.initial !== undefined && object.initial !== null)
      ? InitialSubscribeRequest.fromPartial(object.initial)
      : undefined;
    message.seek = (object.seek !== undefined && object.seek !== null)
      ? SeekRequest.fromPartial(object.seek)
      : undefined;
    message.flowControl = (object.flowControl !== undefined && object.flowControl !== null)
      ? FlowControlRequest.fromPartial(object.flowControl)
      : undefined;
    return message;
  },
};

function createBaseMessageResponse(): MessageResponse {
  return { messages: [] };
}

export const MessageResponse: MessageFns<MessageResponse> = {
  encode(message: MessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      SequencedMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.messages.push(SequencedMessage.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => SequencedMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MessageResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => SequencedMessage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MessageResponse>): MessageResponse {
    return MessageResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MessageResponse>): MessageResponse {
    const message = createBaseMessageResponse();
    message.messages = object.messages?.map((e) => SequencedMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubscribeResponse(): SubscribeResponse {
  return { initial: undefined, seek: undefined, messages: undefined };
}

export const SubscribeResponse: MessageFns<SubscribeResponse> = {
  encode(message: SubscribeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initial !== undefined) {
      InitialSubscribeResponse.encode(message.initial, writer.uint32(10).fork()).join();
    }
    if (message.seek !== undefined) {
      SeekResponse.encode(message.seek, writer.uint32(18).fork()).join();
    }
    if (message.messages !== undefined) {
      MessageResponse.encode(message.messages, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.initial = InitialSubscribeResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.seek = SeekResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.messages = MessageResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeResponse {
    return {
      initial: isSet(object.initial) ? InitialSubscribeResponse.fromJSON(object.initial) : undefined,
      seek: isSet(object.seek) ? SeekResponse.fromJSON(object.seek) : undefined,
      messages: isSet(object.messages) ? MessageResponse.fromJSON(object.messages) : undefined,
    };
  },

  toJSON(message: SubscribeResponse): unknown {
    const obj: any = {};
    if (message.initial !== undefined) {
      obj.initial = InitialSubscribeResponse.toJSON(message.initial);
    }
    if (message.seek !== undefined) {
      obj.seek = SeekResponse.toJSON(message.seek);
    }
    if (message.messages !== undefined) {
      obj.messages = MessageResponse.toJSON(message.messages);
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribeResponse>): SubscribeResponse {
    return SubscribeResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeResponse>): SubscribeResponse {
    const message = createBaseSubscribeResponse();
    message.initial = (object.initial !== undefined && object.initial !== null)
      ? InitialSubscribeResponse.fromPartial(object.initial)
      : undefined;
    message.seek = (object.seek !== undefined && object.seek !== null)
      ? SeekResponse.fromPartial(object.seek)
      : undefined;
    message.messages = (object.messages !== undefined && object.messages !== null)
      ? MessageResponse.fromPartial(object.messages)
      : undefined;
    return message;
  },
};

function createBaseInitialPartitionAssignmentRequest(): InitialPartitionAssignmentRequest {
  return { subscription: "", clientId: Buffer.alloc(0) };
}

export const InitialPartitionAssignmentRequest: MessageFns<InitialPartitionAssignmentRequest> = {
  encode(message: InitialPartitionAssignmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscription !== "") {
      writer.uint32(10).string(message.subscription);
    }
    if (message.clientId.length !== 0) {
      writer.uint32(18).bytes(message.clientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitialPartitionAssignmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialPartitionAssignmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscription = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.clientId = Buffer.from(reader.bytes());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialPartitionAssignmentRequest {
    return {
      subscription: isSet(object.subscription) ? globalThis.String(object.subscription) : "",
      clientId: isSet(object.clientId) ? Buffer.from(bytesFromBase64(object.clientId)) : Buffer.alloc(0),
    };
  },

  toJSON(message: InitialPartitionAssignmentRequest): unknown {
    const obj: any = {};
    if (message.subscription !== "") {
      obj.subscription = message.subscription;
    }
    if (message.clientId.length !== 0) {
      obj.clientId = base64FromBytes(message.clientId);
    }
    return obj;
  },

  create(base?: DeepPartial<InitialPartitionAssignmentRequest>): InitialPartitionAssignmentRequest {
    return InitialPartitionAssignmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitialPartitionAssignmentRequest>): InitialPartitionAssignmentRequest {
    const message = createBaseInitialPartitionAssignmentRequest();
    message.subscription = object.subscription ?? "";
    message.clientId = object.clientId ?? Buffer.alloc(0);
    return message;
  },
};

function createBasePartitionAssignment(): PartitionAssignment {
  return { partitions: [] };
}

export const PartitionAssignment: MessageFns<PartitionAssignment> = {
  encode(message: PartitionAssignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.partitions) {
      writer.int64(v.toString());
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartitionAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.partitions.push(Long.fromString(reader.int64().toString()));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.partitions.push(Long.fromString(reader.int64().toString()));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionAssignment {
    return {
      partitions: globalThis.Array.isArray(object?.partitions)
        ? object.partitions.map((e: any) => Long.fromValue(e))
        : [],
    };
  },

  toJSON(message: PartitionAssignment): unknown {
    const obj: any = {};
    if (message.partitions?.length) {
      obj.partitions = message.partitions.map((e) => (e || Long.ZERO).toString());
    }
    return obj;
  },

  create(base?: DeepPartial<PartitionAssignment>): PartitionAssignment {
    return PartitionAssignment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PartitionAssignment>): PartitionAssignment {
    const message = createBasePartitionAssignment();
    message.partitions = object.partitions?.map((e) => Long.fromValue(e)) || [];
    return message;
  },
};

function createBasePartitionAssignmentAck(): PartitionAssignmentAck {
  return {};
}

export const PartitionAssignmentAck: MessageFns<PartitionAssignmentAck> = {
  encode(_: PartitionAssignmentAck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartitionAssignmentAck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionAssignmentAck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PartitionAssignmentAck {
    return {};
  },

  toJSON(_: PartitionAssignmentAck): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<PartitionAssignmentAck>): PartitionAssignmentAck {
    return PartitionAssignmentAck.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<PartitionAssignmentAck>): PartitionAssignmentAck {
    const message = createBasePartitionAssignmentAck();
    return message;
  },
};

function createBasePartitionAssignmentRequest(): PartitionAssignmentRequest {
  return { initial: undefined, ack: undefined };
}

export const PartitionAssignmentRequest: MessageFns<PartitionAssignmentRequest> = {
  encode(message: PartitionAssignmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initial !== undefined) {
      InitialPartitionAssignmentRequest.encode(message.initial, writer.uint32(10).fork()).join();
    }
    if (message.ack !== undefined) {
      PartitionAssignmentAck.encode(message.ack, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartitionAssignmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionAssignmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.initial = InitialPartitionAssignmentRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ack = PartitionAssignmentAck.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionAssignmentRequest {
    return {
      initial: isSet(object.initial) ? InitialPartitionAssignmentRequest.fromJSON(object.initial) : undefined,
      ack: isSet(object.ack) ? PartitionAssignmentAck.fromJSON(object.ack) : undefined,
    };
  },

  toJSON(message: PartitionAssignmentRequest): unknown {
    const obj: any = {};
    if (message.initial !== undefined) {
      obj.initial = InitialPartitionAssignmentRequest.toJSON(message.initial);
    }
    if (message.ack !== undefined) {
      obj.ack = PartitionAssignmentAck.toJSON(message.ack);
    }
    return obj;
  },

  create(base?: DeepPartial<PartitionAssignmentRequest>): PartitionAssignmentRequest {
    return PartitionAssignmentRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PartitionAssignmentRequest>): PartitionAssignmentRequest {
    const message = createBasePartitionAssignmentRequest();
    message.initial = (object.initial !== undefined && object.initial !== null)
      ? InitialPartitionAssignmentRequest.fromPartial(object.initial)
      : undefined;
    message.ack = (object.ack !== undefined && object.ack !== null)
      ? PartitionAssignmentAck.fromPartial(object.ack)
      : undefined;
    return message;
  },
};

/**
 * The service that a subscriber client application uses to receive messages
 * from subscriptions.
 */
export type SubscriberServiceDefinition = typeof SubscriberServiceDefinition;
export const SubscriberServiceDefinition = {
  name: "SubscriberService",
  fullName: "google.cloud.pubsublite.v1.SubscriberService",
  methods: {
    /** Establishes a stream with the server for receiving messages. */
    subscribe: {
      name: "Subscribe",
      requestType: SubscribeRequest,
      requestStream: true,
      responseType: SubscribeResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface SubscriberServiceImplementation<CallContextExt = {}> {
  /** Establishes a stream with the server for receiving messages. */
  subscribe(
    request: AsyncIterable<SubscribeRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<SubscribeResponse>>;
}

export interface SubscriberServiceClient<CallOptionsExt = {}> {
  /** Establishes a stream with the server for receiving messages. */
  subscribe(
    request: AsyncIterable<DeepPartial<SubscribeRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<SubscribeResponse>;
}

/**
 * The service that a subscriber client application uses to determine which
 * partitions it should connect to.
 */
export type PartitionAssignmentServiceDefinition = typeof PartitionAssignmentServiceDefinition;
export const PartitionAssignmentServiceDefinition = {
  name: "PartitionAssignmentService",
  fullName: "google.cloud.pubsublite.v1.PartitionAssignmentService",
  methods: {
    /**
     * Assign partitions for this client to handle for the specified subscription.
     *
     * The client must send an InitialPartitionAssignmentRequest first.
     * The server will then send at most one unacknowledged PartitionAssignment
     * outstanding on the stream at a time.
     * The client should send a PartitionAssignmentAck after updating the
     * partitions it is connected to to reflect the new assignment.
     */
    assignPartitions: {
      name: "AssignPartitions",
      requestType: PartitionAssignmentRequest,
      requestStream: true,
      responseType: PartitionAssignment,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface PartitionAssignmentServiceImplementation<CallContextExt = {}> {
  /**
   * Assign partitions for this client to handle for the specified subscription.
   *
   * The client must send an InitialPartitionAssignmentRequest first.
   * The server will then send at most one unacknowledged PartitionAssignment
   * outstanding on the stream at a time.
   * The client should send a PartitionAssignmentAck after updating the
   * partitions it is connected to to reflect the new assignment.
   */
  assignPartitions(
    request: AsyncIterable<PartitionAssignmentRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<PartitionAssignment>>;
}

export interface PartitionAssignmentServiceClient<CallOptionsExt = {}> {
  /**
   * Assign partitions for this client to handle for the specified subscription.
   *
   * The client must send an InitialPartitionAssignmentRequest first.
   * The server will then send at most one unacknowledged PartitionAssignment
   * outstanding on the stream at a time.
   * The client should send a PartitionAssignmentAck after updating the
   * partitions it is connected to to reflect the new assignment.
   */
  assignPartitions(
    request: AsyncIterable<DeepPartial<PartitionAssignmentRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<PartitionAssignment>;
}

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
