// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/pubsublite/v1/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.pubsublite.v1";

/** The values associated with a key of an attribute. */
export interface AttributeValues {
  /** The list of values associated with a key. */
  values: Buffer[];
}

/** A message that is published by publishers and delivered to subscribers. */
export interface PubSubMessage {
  /**
   * The key used for routing messages to partitions or for compaction (e.g.,
   * keep the last N messages per key). If the key is empty, the message is
   * routed to an arbitrary partition.
   */
  key: Buffer;
  /** The payload of the message. */
  data: Buffer;
  /** Optional attributes that can be used for message metadata/headers. */
  attributes: { [key: string]: AttributeValues };
  /** An optional, user-specified event time. */
  eventTime: Date | undefined;
}

export interface PubSubMessage_AttributesEntry {
  key: string;
  value: AttributeValues | undefined;
}

/** A cursor that describes the position of a message within a topic partition. */
export interface Cursor {
  /**
   * The offset of a message within a topic partition. Must be greater than or
   * equal 0.
   */
  offset: Long;
}

/** A message that has been stored and sequenced by the Pub/Sub Lite system. */
export interface SequencedMessage {
  /** The position of a message within the partition where it is stored. */
  cursor:
    | Cursor
    | undefined;
  /**
   * The time when the message was received by the server when it was first
   * published.
   */
  publishTime:
    | Date
    | undefined;
  /** The user message. */
  message:
    | PubSubMessage
    | undefined;
  /** The size in bytes of this message for flow control and quota purposes. */
  sizeBytes: Long;
}

/** Metadata about a reservation resource. */
export interface Reservation {
  /**
   * The name of the reservation.
   * Structured like:
   * projects/{project_number}/locations/{location}/reservations/{reservation_id}
   */
  name: string;
  /**
   * The reserved throughput capacity. Every unit of throughput capacity is
   * equivalent to 1 MiB/s of published messages or 2 MiB/s of subscribed
   * messages.
   *
   * Any topics which are declared as using capacity from a Reservation will
   * consume resources from this reservation instead of being charged
   * individually.
   */
  throughputCapacity: Long;
}

/** Metadata about a topic resource. */
export interface Topic {
  /**
   * The name of the topic.
   * Structured like:
   * projects/{project_number}/locations/{location}/topics/{topic_id}
   */
  name: string;
  /** The settings for this topic's partitions. */
  partitionConfig:
    | Topic_PartitionConfig
    | undefined;
  /** The settings for this topic's message retention. */
  retentionConfig:
    | Topic_RetentionConfig
    | undefined;
  /** The settings for this topic's Reservation usage. */
  reservationConfig: Topic_ReservationConfig | undefined;
}

/** The settings for a topic's partitions. */
export interface Topic_PartitionConfig {
  /**
   * The number of partitions in the topic. Must be at least 1.
   *
   * Once a topic has been created the number of partitions can be increased
   * but not decreased. Message ordering is not guaranteed across a topic
   * resize. For more information see
   * https://cloud.google.com/pubsub/lite/docs/topics#scaling_capacity
   */
  count: Long;
  /**
   * DEPRECATED: Use capacity instead which can express a superset of
   * configurations.
   *
   * Every partition in the topic is allocated throughput equivalent to
   * `scale` times the standard partition throughput (4 MiB/s). This is also
   * reflected in the cost of this topic; a topic with `scale` of 2 and
   * count of 10 is charged for 20 partitions. This value must be in the
   * range [1,4].
   *
   * @deprecated
   */
  scale?:
    | number
    | undefined;
  /** The capacity configuration. */
  capacity?: Topic_PartitionConfig_Capacity | undefined;
}

/** The throughput capacity configuration for each partition. */
export interface Topic_PartitionConfig_Capacity {
  /**
   * Publish throughput capacity per partition in MiB/s.
   * Must be >= 4 and <= 16.
   */
  publishMibPerSec: number;
  /**
   * Subscribe throughput capacity per partition in MiB/s.
   * Must be >= 4 and <= 32.
   */
  subscribeMibPerSec: number;
}

/** The settings for a topic's message retention. */
export interface Topic_RetentionConfig {
  /**
   * The provisioned storage, in bytes, per partition. If the number of bytes
   * stored in any of the topic's partitions grows beyond this value, older
   * messages will be dropped to make room for newer ones, regardless of the
   * value of `period`.
   */
  perPartitionBytes: Long;
  /**
   * How long a published message is retained. If unset, messages will be
   * retained as long as the bytes retained for each partition is below
   * `per_partition_bytes`.
   */
  period: Duration | undefined;
}

/** The settings for this topic's Reservation usage. */
export interface Topic_ReservationConfig {
  /**
   * The Reservation to use for this topic's throughput capacity.
   * Structured like:
   * projects/{project_number}/locations/{location}/reservations/{reservation_id}
   */
  throughputReservation: string;
}

/** Metadata about a subscription resource. */
export interface Subscription {
  /**
   * The name of the subscription.
   * Structured like:
   * projects/{project_number}/locations/{location}/subscriptions/{subscription_id}
   */
  name: string;
  /**
   * The name of the topic this subscription is attached to.
   * Structured like:
   * projects/{project_number}/locations/{location}/topics/{topic_id}
   */
  topic: string;
  /** The settings for this subscription's message delivery. */
  deliveryConfig:
    | Subscription_DeliveryConfig
    | undefined;
  /**
   * If present, messages are automatically written from the Pub/Sub Lite topic
   * associated with this subscription to a destination.
   */
  exportConfig: ExportConfig | undefined;
}

/** The settings for a subscription's message delivery. */
export interface Subscription_DeliveryConfig {
  /** The DeliveryRequirement for this subscription. */
  deliveryRequirement: Subscription_DeliveryConfig_DeliveryRequirement;
}

/**
 * When this subscription should send messages to subscribers relative to
 * messages persistence in storage. For details, see [Creating Lite
 * subscriptions](https://cloud.google.com/pubsub/lite/docs/subscriptions#creating_lite_subscriptions).
 */
export enum Subscription_DeliveryConfig_DeliveryRequirement {
  /** DELIVERY_REQUIREMENT_UNSPECIFIED - Default value. This value is unused. */
  DELIVERY_REQUIREMENT_UNSPECIFIED = 0,
  /**
   * DELIVER_IMMEDIATELY - The server does not wait for a published message to be successfully
   * written to storage before delivering it to subscribers.
   */
  DELIVER_IMMEDIATELY = 1,
  /**
   * DELIVER_AFTER_STORED - The server will not deliver a published message to subscribers until
   * the message has been successfully written to storage. This will result
   * in higher end-to-end latency, but consistent delivery.
   */
  DELIVER_AFTER_STORED = 2,
  UNRECOGNIZED = -1,
}

export function subscription_DeliveryConfig_DeliveryRequirementFromJSON(
  object: any,
): Subscription_DeliveryConfig_DeliveryRequirement {
  switch (object) {
    case 0:
    case "DELIVERY_REQUIREMENT_UNSPECIFIED":
      return Subscription_DeliveryConfig_DeliveryRequirement.DELIVERY_REQUIREMENT_UNSPECIFIED;
    case 1:
    case "DELIVER_IMMEDIATELY":
      return Subscription_DeliveryConfig_DeliveryRequirement.DELIVER_IMMEDIATELY;
    case 2:
    case "DELIVER_AFTER_STORED":
      return Subscription_DeliveryConfig_DeliveryRequirement.DELIVER_AFTER_STORED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Subscription_DeliveryConfig_DeliveryRequirement.UNRECOGNIZED;
  }
}

export function subscription_DeliveryConfig_DeliveryRequirementToJSON(
  object: Subscription_DeliveryConfig_DeliveryRequirement,
): string {
  switch (object) {
    case Subscription_DeliveryConfig_DeliveryRequirement.DELIVERY_REQUIREMENT_UNSPECIFIED:
      return "DELIVERY_REQUIREMENT_UNSPECIFIED";
    case Subscription_DeliveryConfig_DeliveryRequirement.DELIVER_IMMEDIATELY:
      return "DELIVER_IMMEDIATELY";
    case Subscription_DeliveryConfig_DeliveryRequirement.DELIVER_AFTER_STORED:
      return "DELIVER_AFTER_STORED";
    case Subscription_DeliveryConfig_DeliveryRequirement.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Configuration for a Pub/Sub Lite subscription that writes messages to a
 * destination. User subscriber clients must not connect to this subscription.
 */
export interface ExportConfig {
  /**
   * The desired state of this export. Setting this to values other than
   * `ACTIVE` and `PAUSED` will result in an error.
   */
  desiredState: ExportConfig_State;
  /**
   * Output only. The current state of the export, which may be different to the
   * desired state due to errors. This field is output only.
   */
  currentState: ExportConfig_State;
  /**
   * Optional. The name of an optional Pub/Sub Lite topic to publish messages
   * that can not be exported to the destination. For example, the message can
   * not be published to the Pub/Sub service because it does not satisfy the
   * constraints documented at https://cloud.google.com/pubsub/docs/publisher.
   *
   * Structured like:
   * projects/{project_number}/locations/{location}/topics/{topic_id}.
   * Must be within the same project and location as the subscription. The topic
   * may be changed or removed.
   */
  deadLetterTopic: string;
  /**
   * Messages are automatically written from the Pub/Sub Lite topic associated
   * with this subscription to a Pub/Sub topic.
   */
  pubsubConfig?: ExportConfig_PubSubConfig | undefined;
}

/** The desired export state. */
export enum ExportConfig_State {
  /** STATE_UNSPECIFIED - Default value. This value is unused. */
  STATE_UNSPECIFIED = 0,
  /** ACTIVE - Messages are being exported. */
  ACTIVE = 1,
  /** PAUSED - Exporting messages is suspended. */
  PAUSED = 2,
  /** PERMISSION_DENIED - Messages cannot be exported due to permission denied errors. Output only. */
  PERMISSION_DENIED = 3,
  /** NOT_FOUND - Messages cannot be exported due to missing resources. Output only. */
  NOT_FOUND = 4,
  UNRECOGNIZED = -1,
}

export function exportConfig_StateFromJSON(object: any): ExportConfig_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return ExportConfig_State.STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return ExportConfig_State.ACTIVE;
    case 2:
    case "PAUSED":
      return ExportConfig_State.PAUSED;
    case 3:
    case "PERMISSION_DENIED":
      return ExportConfig_State.PERMISSION_DENIED;
    case 4:
    case "NOT_FOUND":
      return ExportConfig_State.NOT_FOUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExportConfig_State.UNRECOGNIZED;
  }
}

export function exportConfig_StateToJSON(object: ExportConfig_State): string {
  switch (object) {
    case ExportConfig_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case ExportConfig_State.ACTIVE:
      return "ACTIVE";
    case ExportConfig_State.PAUSED:
      return "PAUSED";
    case ExportConfig_State.PERMISSION_DENIED:
      return "PERMISSION_DENIED";
    case ExportConfig_State.NOT_FOUND:
      return "NOT_FOUND";
    case ExportConfig_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration for exporting to a Pub/Sub topic. */
export interface ExportConfig_PubSubConfig {
  /**
   * The name of the Pub/Sub topic.
   * Structured like: projects/{project_number}/topics/{topic_id}.
   * The topic may be changed.
   */
  topic: string;
}

/**
 * A target publish or event time. Can be used for seeking to or retrieving the
 * corresponding cursor.
 */
export interface TimeTarget {
  /**
   * Request the cursor of the first message with publish time greater than or
   * equal to `publish_time`. All messages thereafter are guaranteed to have
   * publish times >= `publish_time`.
   */
  publishTime?:
    | Date
    | undefined;
  /**
   * Request the cursor of the first message with event time greater than or
   * equal to `event_time`. If messages are missing an event time, the publish
   * time is used as a fallback. As event times are user supplied, subsequent
   * messages may have event times less than `event_time` and should be
   * filtered by the client, if necessary.
   */
  eventTime?: Date | undefined;
}

function createBaseAttributeValues(): AttributeValues {
  return { values: [] };
}

export const AttributeValues: MessageFns<AttributeValues> = {
  encode(message: AttributeValues, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributeValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(Buffer.from(reader.bytes()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributeValues {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => Buffer.from(bytesFromBase64(e)))
        : [],
    };
  },

  toJSON(message: AttributeValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AttributeValues>): AttributeValues {
    return AttributeValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttributeValues>): AttributeValues {
    const message = createBaseAttributeValues();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBasePubSubMessage(): PubSubMessage {
  return { key: Buffer.alloc(0), data: Buffer.alloc(0), attributes: {}, eventTime: undefined };
}

export const PubSubMessage: MessageFns<PubSubMessage> = {
  encode(message: PubSubMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      PubSubMessage_AttributesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubSubMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubSubMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = Buffer.from(reader.bytes());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = PubSubMessage_AttributesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.attributes[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubSubMessage {
    return {
      key: isSet(object.key) ? Buffer.from(bytesFromBase64(object.key)) : Buffer.alloc(0),
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: AttributeValues }>((acc, [key, value]) => {
          acc[key] = AttributeValues.fromJSON(value);
          return acc;
        }, {})
        : {},
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
    };
  },

  toJSON(message: PubSubMessage): unknown {
    const obj: any = {};
    if (message.key.length !== 0) {
      obj.key = base64FromBytes(message.key);
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = AttributeValues.toJSON(v);
        });
      }
    }
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<PubSubMessage>): PubSubMessage {
    return PubSubMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PubSubMessage>): PubSubMessage {
    const message = createBasePubSubMessage();
    message.key = object.key ?? Buffer.alloc(0);
    message.data = object.data ?? Buffer.alloc(0);
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: AttributeValues }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AttributeValues.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.eventTime = object.eventTime ?? undefined;
    return message;
  },
};

function createBasePubSubMessage_AttributesEntry(): PubSubMessage_AttributesEntry {
  return { key: "", value: undefined };
}

export const PubSubMessage_AttributesEntry: MessageFns<PubSubMessage_AttributesEntry> = {
  encode(message: PubSubMessage_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AttributeValues.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PubSubMessage_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePubSubMessage_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AttributeValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PubSubMessage_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AttributeValues.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PubSubMessage_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AttributeValues.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<PubSubMessage_AttributesEntry>): PubSubMessage_AttributesEntry {
    return PubSubMessage_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PubSubMessage_AttributesEntry>): PubSubMessage_AttributesEntry {
    const message = createBasePubSubMessage_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AttributeValues.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCursor(): Cursor {
  return { offset: Long.ZERO };
}

export const Cursor: MessageFns<Cursor> = {
  encode(message: Cursor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.offset.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.offset.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cursor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCursor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.offset = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cursor {
    return { offset: isSet(object.offset) ? Long.fromValue(object.offset) : Long.ZERO };
  },

  toJSON(message: Cursor): unknown {
    const obj: any = {};
    if (!message.offset.equals(Long.ZERO)) {
      obj.offset = (message.offset || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Cursor>): Cursor {
    return Cursor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cursor>): Cursor {
    const message = createBaseCursor();
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Long.fromValue(object.offset)
      : Long.ZERO;
    return message;
  },
};

function createBaseSequencedMessage(): SequencedMessage {
  return { cursor: undefined, publishTime: undefined, message: undefined, sizeBytes: Long.ZERO };
}

export const SequencedMessage: MessageFns<SequencedMessage> = {
  encode(message: SequencedMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(10).fork()).join();
    }
    if (message.publishTime !== undefined) {
      Timestamp.encode(toTimestamp(message.publishTime), writer.uint32(18).fork()).join();
    }
    if (message.message !== undefined) {
      PubSubMessage.encode(message.message, writer.uint32(26).fork()).join();
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.sizeBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SequencedMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSequencedMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.publishTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.message = PubSubMessage.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.sizeBytes = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SequencedMessage {
    return {
      cursor: isSet(object.cursor) ? Cursor.fromJSON(object.cursor) : undefined,
      publishTime: isSet(object.publishTime) ? fromJsonTimestamp(object.publishTime) : undefined,
      message: isSet(object.message) ? PubSubMessage.fromJSON(object.message) : undefined,
      sizeBytes: isSet(object.sizeBytes) ? Long.fromValue(object.sizeBytes) : Long.ZERO,
    };
  },

  toJSON(message: SequencedMessage): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor.toJSON(message.cursor);
    }
    if (message.publishTime !== undefined) {
      obj.publishTime = message.publishTime.toISOString();
    }
    if (message.message !== undefined) {
      obj.message = PubSubMessage.toJSON(message.message);
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      obj.sizeBytes = (message.sizeBytes || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SequencedMessage>): SequencedMessage {
    return SequencedMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SequencedMessage>): SequencedMessage {
    const message = createBaseSequencedMessage();
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    message.publishTime = object.publishTime ?? undefined;
    message.message = (object.message !== undefined && object.message !== null)
      ? PubSubMessage.fromPartial(object.message)
      : undefined;
    message.sizeBytes = (object.sizeBytes !== undefined && object.sizeBytes !== null)
      ? Long.fromValue(object.sizeBytes)
      : Long.ZERO;
    return message;
  },
};

function createBaseReservation(): Reservation {
  return { name: "", throughputCapacity: Long.ZERO };
}

export const Reservation: MessageFns<Reservation> = {
  encode(message: Reservation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (!message.throughputCapacity.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.throughputCapacity.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reservation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReservation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.throughputCapacity = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reservation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      throughputCapacity: isSet(object.throughputCapacity) ? Long.fromValue(object.throughputCapacity) : Long.ZERO,
    };
  },

  toJSON(message: Reservation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.throughputCapacity.equals(Long.ZERO)) {
      obj.throughputCapacity = (message.throughputCapacity || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Reservation>): Reservation {
    return Reservation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Reservation>): Reservation {
    const message = createBaseReservation();
    message.name = object.name ?? "";
    message.throughputCapacity = (object.throughputCapacity !== undefined && object.throughputCapacity !== null)
      ? Long.fromValue(object.throughputCapacity)
      : Long.ZERO;
    return message;
  },
};

function createBaseTopic(): Topic {
  return { name: "", partitionConfig: undefined, retentionConfig: undefined, reservationConfig: undefined };
}

export const Topic: MessageFns<Topic> = {
  encode(message: Topic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.partitionConfig !== undefined) {
      Topic_PartitionConfig.encode(message.partitionConfig, writer.uint32(18).fork()).join();
    }
    if (message.retentionConfig !== undefined) {
      Topic_RetentionConfig.encode(message.retentionConfig, writer.uint32(26).fork()).join();
    }
    if (message.reservationConfig !== undefined) {
      Topic_ReservationConfig.encode(message.reservationConfig, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Topic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partitionConfig = Topic_PartitionConfig.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.retentionConfig = Topic_RetentionConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.reservationConfig = Topic_ReservationConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Topic {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      partitionConfig: isSet(object.partitionConfig)
        ? Topic_PartitionConfig.fromJSON(object.partitionConfig)
        : undefined,
      retentionConfig: isSet(object.retentionConfig)
        ? Topic_RetentionConfig.fromJSON(object.retentionConfig)
        : undefined,
      reservationConfig: isSet(object.reservationConfig)
        ? Topic_ReservationConfig.fromJSON(object.reservationConfig)
        : undefined,
    };
  },

  toJSON(message: Topic): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.partitionConfig !== undefined) {
      obj.partitionConfig = Topic_PartitionConfig.toJSON(message.partitionConfig);
    }
    if (message.retentionConfig !== undefined) {
      obj.retentionConfig = Topic_RetentionConfig.toJSON(message.retentionConfig);
    }
    if (message.reservationConfig !== undefined) {
      obj.reservationConfig = Topic_ReservationConfig.toJSON(message.reservationConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Topic>): Topic {
    return Topic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Topic>): Topic {
    const message = createBaseTopic();
    message.name = object.name ?? "";
    message.partitionConfig = (object.partitionConfig !== undefined && object.partitionConfig !== null)
      ? Topic_PartitionConfig.fromPartial(object.partitionConfig)
      : undefined;
    message.retentionConfig = (object.retentionConfig !== undefined && object.retentionConfig !== null)
      ? Topic_RetentionConfig.fromPartial(object.retentionConfig)
      : undefined;
    message.reservationConfig = (object.reservationConfig !== undefined && object.reservationConfig !== null)
      ? Topic_ReservationConfig.fromPartial(object.reservationConfig)
      : undefined;
    return message;
  },
};

function createBaseTopic_PartitionConfig(): Topic_PartitionConfig {
  return { count: Long.ZERO, scale: undefined, capacity: undefined };
}

export const Topic_PartitionConfig: MessageFns<Topic_PartitionConfig> = {
  encode(message: Topic_PartitionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.count.toString());
    }
    if (message.scale !== undefined) {
      writer.uint32(16).int32(message.scale);
    }
    if (message.capacity !== undefined) {
      Topic_PartitionConfig_Capacity.encode(message.capacity, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Topic_PartitionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopic_PartitionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.scale = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.capacity = Topic_PartitionConfig_Capacity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Topic_PartitionConfig {
    return {
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : undefined,
      capacity: isSet(object.capacity) ? Topic_PartitionConfig_Capacity.fromJSON(object.capacity) : undefined,
    };
  },

  toJSON(message: Topic_PartitionConfig): unknown {
    const obj: any = {};
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    if (message.scale !== undefined) {
      obj.scale = Math.round(message.scale);
    }
    if (message.capacity !== undefined) {
      obj.capacity = Topic_PartitionConfig_Capacity.toJSON(message.capacity);
    }
    return obj;
  },

  create(base?: DeepPartial<Topic_PartitionConfig>): Topic_PartitionConfig {
    return Topic_PartitionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Topic_PartitionConfig>): Topic_PartitionConfig {
    const message = createBaseTopic_PartitionConfig();
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    message.scale = object.scale ?? undefined;
    message.capacity = (object.capacity !== undefined && object.capacity !== null)
      ? Topic_PartitionConfig_Capacity.fromPartial(object.capacity)
      : undefined;
    return message;
  },
};

function createBaseTopic_PartitionConfig_Capacity(): Topic_PartitionConfig_Capacity {
  return { publishMibPerSec: 0, subscribeMibPerSec: 0 };
}

export const Topic_PartitionConfig_Capacity: MessageFns<Topic_PartitionConfig_Capacity> = {
  encode(message: Topic_PartitionConfig_Capacity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publishMibPerSec !== 0) {
      writer.uint32(8).int32(message.publishMibPerSec);
    }
    if (message.subscribeMibPerSec !== 0) {
      writer.uint32(16).int32(message.subscribeMibPerSec);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Topic_PartitionConfig_Capacity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopic_PartitionConfig_Capacity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.publishMibPerSec = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.subscribeMibPerSec = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Topic_PartitionConfig_Capacity {
    return {
      publishMibPerSec: isSet(object.publishMibPerSec) ? globalThis.Number(object.publishMibPerSec) : 0,
      subscribeMibPerSec: isSet(object.subscribeMibPerSec) ? globalThis.Number(object.subscribeMibPerSec) : 0,
    };
  },

  toJSON(message: Topic_PartitionConfig_Capacity): unknown {
    const obj: any = {};
    if (message.publishMibPerSec !== 0) {
      obj.publishMibPerSec = Math.round(message.publishMibPerSec);
    }
    if (message.subscribeMibPerSec !== 0) {
      obj.subscribeMibPerSec = Math.round(message.subscribeMibPerSec);
    }
    return obj;
  },

  create(base?: DeepPartial<Topic_PartitionConfig_Capacity>): Topic_PartitionConfig_Capacity {
    return Topic_PartitionConfig_Capacity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Topic_PartitionConfig_Capacity>): Topic_PartitionConfig_Capacity {
    const message = createBaseTopic_PartitionConfig_Capacity();
    message.publishMibPerSec = object.publishMibPerSec ?? 0;
    message.subscribeMibPerSec = object.subscribeMibPerSec ?? 0;
    return message;
  },
};

function createBaseTopic_RetentionConfig(): Topic_RetentionConfig {
  return { perPartitionBytes: Long.ZERO, period: undefined };
}

export const Topic_RetentionConfig: MessageFns<Topic_RetentionConfig> = {
  encode(message: Topic_RetentionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.perPartitionBytes.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.perPartitionBytes.toString());
    }
    if (message.period !== undefined) {
      Duration.encode(message.period, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Topic_RetentionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopic_RetentionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.perPartitionBytes = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.period = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Topic_RetentionConfig {
    return {
      perPartitionBytes: isSet(object.perPartitionBytes) ? Long.fromValue(object.perPartitionBytes) : Long.ZERO,
      period: isSet(object.period) ? Duration.fromJSON(object.period) : undefined,
    };
  },

  toJSON(message: Topic_RetentionConfig): unknown {
    const obj: any = {};
    if (!message.perPartitionBytes.equals(Long.ZERO)) {
      obj.perPartitionBytes = (message.perPartitionBytes || Long.ZERO).toString();
    }
    if (message.period !== undefined) {
      obj.period = Duration.toJSON(message.period);
    }
    return obj;
  },

  create(base?: DeepPartial<Topic_RetentionConfig>): Topic_RetentionConfig {
    return Topic_RetentionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Topic_RetentionConfig>): Topic_RetentionConfig {
    const message = createBaseTopic_RetentionConfig();
    message.perPartitionBytes = (object.perPartitionBytes !== undefined && object.perPartitionBytes !== null)
      ? Long.fromValue(object.perPartitionBytes)
      : Long.ZERO;
    message.period = (object.period !== undefined && object.period !== null)
      ? Duration.fromPartial(object.period)
      : undefined;
    return message;
  },
};

function createBaseTopic_ReservationConfig(): Topic_ReservationConfig {
  return { throughputReservation: "" };
}

export const Topic_ReservationConfig: MessageFns<Topic_ReservationConfig> = {
  encode(message: Topic_ReservationConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.throughputReservation !== "") {
      writer.uint32(10).string(message.throughputReservation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Topic_ReservationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopic_ReservationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.throughputReservation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Topic_ReservationConfig {
    return {
      throughputReservation: isSet(object.throughputReservation) ? globalThis.String(object.throughputReservation) : "",
    };
  },

  toJSON(message: Topic_ReservationConfig): unknown {
    const obj: any = {};
    if (message.throughputReservation !== "") {
      obj.throughputReservation = message.throughputReservation;
    }
    return obj;
  },

  create(base?: DeepPartial<Topic_ReservationConfig>): Topic_ReservationConfig {
    return Topic_ReservationConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Topic_ReservationConfig>): Topic_ReservationConfig {
    const message = createBaseTopic_ReservationConfig();
    message.throughputReservation = object.throughputReservation ?? "";
    return message;
  },
};

function createBaseSubscription(): Subscription {
  return { name: "", topic: "", deliveryConfig: undefined, exportConfig: undefined };
}

export const Subscription: MessageFns<Subscription> = {
  encode(message: Subscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.topic !== "") {
      writer.uint32(18).string(message.topic);
    }
    if (message.deliveryConfig !== undefined) {
      Subscription_DeliveryConfig.encode(message.deliveryConfig, writer.uint32(26).fork()).join();
    }
    if (message.exportConfig !== undefined) {
      ExportConfig.encode(message.exportConfig, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deliveryConfig = Subscription_DeliveryConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.exportConfig = ExportConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subscription {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      deliveryConfig: isSet(object.deliveryConfig)
        ? Subscription_DeliveryConfig.fromJSON(object.deliveryConfig)
        : undefined,
      exportConfig: isSet(object.exportConfig) ? ExportConfig.fromJSON(object.exportConfig) : undefined,
    };
  },

  toJSON(message: Subscription): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.deliveryConfig !== undefined) {
      obj.deliveryConfig = Subscription_DeliveryConfig.toJSON(message.deliveryConfig);
    }
    if (message.exportConfig !== undefined) {
      obj.exportConfig = ExportConfig.toJSON(message.exportConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Subscription>): Subscription {
    return Subscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subscription>): Subscription {
    const message = createBaseSubscription();
    message.name = object.name ?? "";
    message.topic = object.topic ?? "";
    message.deliveryConfig = (object.deliveryConfig !== undefined && object.deliveryConfig !== null)
      ? Subscription_DeliveryConfig.fromPartial(object.deliveryConfig)
      : undefined;
    message.exportConfig = (object.exportConfig !== undefined && object.exportConfig !== null)
      ? ExportConfig.fromPartial(object.exportConfig)
      : undefined;
    return message;
  },
};

function createBaseSubscription_DeliveryConfig(): Subscription_DeliveryConfig {
  return { deliveryRequirement: 0 };
}

export const Subscription_DeliveryConfig: MessageFns<Subscription_DeliveryConfig> = {
  encode(message: Subscription_DeliveryConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deliveryRequirement !== 0) {
      writer.uint32(24).int32(message.deliveryRequirement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subscription_DeliveryConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscription_DeliveryConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 24) {
            break;
          }

          message.deliveryRequirement = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subscription_DeliveryConfig {
    return {
      deliveryRequirement: isSet(object.deliveryRequirement)
        ? subscription_DeliveryConfig_DeliveryRequirementFromJSON(object.deliveryRequirement)
        : 0,
    };
  },

  toJSON(message: Subscription_DeliveryConfig): unknown {
    const obj: any = {};
    if (message.deliveryRequirement !== 0) {
      obj.deliveryRequirement = subscription_DeliveryConfig_DeliveryRequirementToJSON(message.deliveryRequirement);
    }
    return obj;
  },

  create(base?: DeepPartial<Subscription_DeliveryConfig>): Subscription_DeliveryConfig {
    return Subscription_DeliveryConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subscription_DeliveryConfig>): Subscription_DeliveryConfig {
    const message = createBaseSubscription_DeliveryConfig();
    message.deliveryRequirement = object.deliveryRequirement ?? 0;
    return message;
  },
};

function createBaseExportConfig(): ExportConfig {
  return { desiredState: 0, currentState: 0, deadLetterTopic: "", pubsubConfig: undefined };
}

export const ExportConfig: MessageFns<ExportConfig> = {
  encode(message: ExportConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.desiredState !== 0) {
      writer.uint32(8).int32(message.desiredState);
    }
    if (message.currentState !== 0) {
      writer.uint32(48).int32(message.currentState);
    }
    if (message.deadLetterTopic !== "") {
      writer.uint32(42).string(message.deadLetterTopic);
    }
    if (message.pubsubConfig !== undefined) {
      ExportConfig_PubSubConfig.encode(message.pubsubConfig, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.desiredState = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.currentState = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.deadLetterTopic = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pubsubConfig = ExportConfig_PubSubConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportConfig {
    return {
      desiredState: isSet(object.desiredState) ? exportConfig_StateFromJSON(object.desiredState) : 0,
      currentState: isSet(object.currentState) ? exportConfig_StateFromJSON(object.currentState) : 0,
      deadLetterTopic: isSet(object.deadLetterTopic) ? globalThis.String(object.deadLetterTopic) : "",
      pubsubConfig: isSet(object.pubsubConfig) ? ExportConfig_PubSubConfig.fromJSON(object.pubsubConfig) : undefined,
    };
  },

  toJSON(message: ExportConfig): unknown {
    const obj: any = {};
    if (message.desiredState !== 0) {
      obj.desiredState = exportConfig_StateToJSON(message.desiredState);
    }
    if (message.currentState !== 0) {
      obj.currentState = exportConfig_StateToJSON(message.currentState);
    }
    if (message.deadLetterTopic !== "") {
      obj.deadLetterTopic = message.deadLetterTopic;
    }
    if (message.pubsubConfig !== undefined) {
      obj.pubsubConfig = ExportConfig_PubSubConfig.toJSON(message.pubsubConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<ExportConfig>): ExportConfig {
    return ExportConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportConfig>): ExportConfig {
    const message = createBaseExportConfig();
    message.desiredState = object.desiredState ?? 0;
    message.currentState = object.currentState ?? 0;
    message.deadLetterTopic = object.deadLetterTopic ?? "";
    message.pubsubConfig = (object.pubsubConfig !== undefined && object.pubsubConfig !== null)
      ? ExportConfig_PubSubConfig.fromPartial(object.pubsubConfig)
      : undefined;
    return message;
  },
};

function createBaseExportConfig_PubSubConfig(): ExportConfig_PubSubConfig {
  return { topic: "" };
}

export const ExportConfig_PubSubConfig: MessageFns<ExportConfig_PubSubConfig> = {
  encode(message: ExportConfig_PubSubConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportConfig_PubSubConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportConfig_PubSubConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportConfig_PubSubConfig {
    return { topic: isSet(object.topic) ? globalThis.String(object.topic) : "" };
  },

  toJSON(message: ExportConfig_PubSubConfig): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    return obj;
  },

  create(base?: DeepPartial<ExportConfig_PubSubConfig>): ExportConfig_PubSubConfig {
    return ExportConfig_PubSubConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExportConfig_PubSubConfig>): ExportConfig_PubSubConfig {
    const message = createBaseExportConfig_PubSubConfig();
    message.topic = object.topic ?? "";
    return message;
  },
};

function createBaseTimeTarget(): TimeTarget {
  return { publishTime: undefined, eventTime: undefined };
}

export const TimeTarget: MessageFns<TimeTarget> = {
  encode(message: TimeTarget, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publishTime !== undefined) {
      Timestamp.encode(toTimestamp(message.publishTime), writer.uint32(10).fork()).join();
    }
    if (message.eventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.eventTime), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeTarget {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.publishTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.eventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeTarget {
    return {
      publishTime: isSet(object.publishTime) ? fromJsonTimestamp(object.publishTime) : undefined,
      eventTime: isSet(object.eventTime) ? fromJsonTimestamp(object.eventTime) : undefined,
    };
  },

  toJSON(message: TimeTarget): unknown {
    const obj: any = {};
    if (message.publishTime !== undefined) {
      obj.publishTime = message.publishTime.toISOString();
    }
    if (message.eventTime !== undefined) {
      obj.eventTime = message.eventTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<TimeTarget>): TimeTarget {
    return TimeTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimeTarget>): TimeTarget {
    const message = createBaseTimeTarget();
    message.publishTime = object.publishTime ?? undefined;
    message.eventTime = object.eventTime ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
