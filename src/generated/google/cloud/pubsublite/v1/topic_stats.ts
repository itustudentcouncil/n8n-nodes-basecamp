// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/pubsublite/v1/topic_stats.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Cursor, TimeTarget } from "./common.js";

export const protobufPackage = "google.cloud.pubsublite.v1";

/** Compute statistics about a range of messages in a given topic and partition. */
export interface ComputeMessageStatsRequest {
  /** Required. The topic for which we should compute message stats. */
  topic: string;
  /** Required. The partition for which we should compute message stats. */
  partition: Long;
  /** The inclusive start of the range. */
  startCursor:
    | Cursor
    | undefined;
  /**
   * The exclusive end of the range. The range is empty if end_cursor <=
   * start_cursor. Specifying a start_cursor before the first message and an
   * end_cursor after the last message will retrieve all messages.
   */
  endCursor: Cursor | undefined;
}

/** Response containing stats for messages in the requested topic and partition. */
export interface ComputeMessageStatsResponse {
  /** The count of messages. */
  messageCount: Long;
  /** The number of quota bytes accounted to these messages. */
  messageBytes: Long;
  /**
   * The minimum publish timestamp across these messages. Note that publish
   * timestamps within a partition are not guaranteed to be non-decreasing. The
   * timestamp will be unset if there are no messages.
   */
  minimumPublishTime:
    | Date
    | undefined;
  /**
   * The minimum event timestamp across these messages. For the purposes of this
   * computation, if a message does not have an event time, we use the publish
   * time. The timestamp will be unset if there are no messages.
   */
  minimumEventTime: Date | undefined;
}

/** Compute the current head cursor for a partition. */
export interface ComputeHeadCursorRequest {
  /** Required. The topic for which we should compute the head cursor. */
  topic: string;
  /** Required. The partition for which we should compute the head cursor. */
  partition: Long;
}

/** Response containing the head cursor for the requested topic and partition. */
export interface ComputeHeadCursorResponse {
  /** The head cursor. */
  headCursor: Cursor | undefined;
}

/**
 * Compute the corresponding cursor for a publish or event time in a topic
 * partition.
 */
export interface ComputeTimeCursorRequest {
  /** Required. The topic for which we should compute the cursor. */
  topic: string;
  /** Required. The partition for which we should compute the cursor. */
  partition: Long;
  /**
   * Required. The target publish or event time. Specifying a future time will
   * return an unset cursor.
   */
  target: TimeTarget | undefined;
}

/**
 * Response containing the cursor corresponding to a publish or event time in a
 * topic partition.
 */
export interface ComputeTimeCursorResponse {
  /**
   * If present, the cursor references the first message with time greater than
   * or equal to the specified target time. If such a message cannot be found,
   * the cursor will be unset (i.e. `cursor` is not present).
   */
  cursor: Cursor | undefined;
}

function createBaseComputeMessageStatsRequest(): ComputeMessageStatsRequest {
  return { topic: "", partition: Long.ZERO, startCursor: undefined, endCursor: undefined };
}

export const ComputeMessageStatsRequest: MessageFns<ComputeMessageStatsRequest> = {
  encode(message: ComputeMessageStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (!message.partition.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.partition.toString());
    }
    if (message.startCursor !== undefined) {
      Cursor.encode(message.startCursor, writer.uint32(26).fork()).join();
    }
    if (message.endCursor !== undefined) {
      Cursor.encode(message.endCursor, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeMessageStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeMessageStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.partition = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.startCursor = Cursor.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.endCursor = Cursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeMessageStatsRequest {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      partition: isSet(object.partition) ? Long.fromValue(object.partition) : Long.ZERO,
      startCursor: isSet(object.startCursor) ? Cursor.fromJSON(object.startCursor) : undefined,
      endCursor: isSet(object.endCursor) ? Cursor.fromJSON(object.endCursor) : undefined,
    };
  },

  toJSON(message: ComputeMessageStatsRequest): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (!message.partition.equals(Long.ZERO)) {
      obj.partition = (message.partition || Long.ZERO).toString();
    }
    if (message.startCursor !== undefined) {
      obj.startCursor = Cursor.toJSON(message.startCursor);
    }
    if (message.endCursor !== undefined) {
      obj.endCursor = Cursor.toJSON(message.endCursor);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeMessageStatsRequest>): ComputeMessageStatsRequest {
    return ComputeMessageStatsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeMessageStatsRequest>): ComputeMessageStatsRequest {
    const message = createBaseComputeMessageStatsRequest();
    message.topic = object.topic ?? "";
    message.partition = (object.partition !== undefined && object.partition !== null)
      ? Long.fromValue(object.partition)
      : Long.ZERO;
    message.startCursor = (object.startCursor !== undefined && object.startCursor !== null)
      ? Cursor.fromPartial(object.startCursor)
      : undefined;
    message.endCursor = (object.endCursor !== undefined && object.endCursor !== null)
      ? Cursor.fromPartial(object.endCursor)
      : undefined;
    return message;
  },
};

function createBaseComputeMessageStatsResponse(): ComputeMessageStatsResponse {
  return {
    messageCount: Long.ZERO,
    messageBytes: Long.ZERO,
    minimumPublishTime: undefined,
    minimumEventTime: undefined,
  };
}

export const ComputeMessageStatsResponse: MessageFns<ComputeMessageStatsResponse> = {
  encode(message: ComputeMessageStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.messageCount.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.messageCount.toString());
    }
    if (!message.messageBytes.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.messageBytes.toString());
    }
    if (message.minimumPublishTime !== undefined) {
      Timestamp.encode(toTimestamp(message.minimumPublishTime), writer.uint32(26).fork()).join();
    }
    if (message.minimumEventTime !== undefined) {
      Timestamp.encode(toTimestamp(message.minimumEventTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeMessageStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeMessageStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.messageCount = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.messageBytes = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.minimumPublishTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.minimumEventTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeMessageStatsResponse {
    return {
      messageCount: isSet(object.messageCount) ? Long.fromValue(object.messageCount) : Long.ZERO,
      messageBytes: isSet(object.messageBytes) ? Long.fromValue(object.messageBytes) : Long.ZERO,
      minimumPublishTime: isSet(object.minimumPublishTime) ? fromJsonTimestamp(object.minimumPublishTime) : undefined,
      minimumEventTime: isSet(object.minimumEventTime) ? fromJsonTimestamp(object.minimumEventTime) : undefined,
    };
  },

  toJSON(message: ComputeMessageStatsResponse): unknown {
    const obj: any = {};
    if (!message.messageCount.equals(Long.ZERO)) {
      obj.messageCount = (message.messageCount || Long.ZERO).toString();
    }
    if (!message.messageBytes.equals(Long.ZERO)) {
      obj.messageBytes = (message.messageBytes || Long.ZERO).toString();
    }
    if (message.minimumPublishTime !== undefined) {
      obj.minimumPublishTime = message.minimumPublishTime.toISOString();
    }
    if (message.minimumEventTime !== undefined) {
      obj.minimumEventTime = message.minimumEventTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeMessageStatsResponse>): ComputeMessageStatsResponse {
    return ComputeMessageStatsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeMessageStatsResponse>): ComputeMessageStatsResponse {
    const message = createBaseComputeMessageStatsResponse();
    message.messageCount = (object.messageCount !== undefined && object.messageCount !== null)
      ? Long.fromValue(object.messageCount)
      : Long.ZERO;
    message.messageBytes = (object.messageBytes !== undefined && object.messageBytes !== null)
      ? Long.fromValue(object.messageBytes)
      : Long.ZERO;
    message.minimumPublishTime = object.minimumPublishTime ?? undefined;
    message.minimumEventTime = object.minimumEventTime ?? undefined;
    return message;
  },
};

function createBaseComputeHeadCursorRequest(): ComputeHeadCursorRequest {
  return { topic: "", partition: Long.ZERO };
}

export const ComputeHeadCursorRequest: MessageFns<ComputeHeadCursorRequest> = {
  encode(message: ComputeHeadCursorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (!message.partition.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.partition.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeHeadCursorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeHeadCursorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.partition = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeHeadCursorRequest {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      partition: isSet(object.partition) ? Long.fromValue(object.partition) : Long.ZERO,
    };
  },

  toJSON(message: ComputeHeadCursorRequest): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (!message.partition.equals(Long.ZERO)) {
      obj.partition = (message.partition || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeHeadCursorRequest>): ComputeHeadCursorRequest {
    return ComputeHeadCursorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeHeadCursorRequest>): ComputeHeadCursorRequest {
    const message = createBaseComputeHeadCursorRequest();
    message.topic = object.topic ?? "";
    message.partition = (object.partition !== undefined && object.partition !== null)
      ? Long.fromValue(object.partition)
      : Long.ZERO;
    return message;
  },
};

function createBaseComputeHeadCursorResponse(): ComputeHeadCursorResponse {
  return { headCursor: undefined };
}

export const ComputeHeadCursorResponse: MessageFns<ComputeHeadCursorResponse> = {
  encode(message: ComputeHeadCursorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.headCursor !== undefined) {
      Cursor.encode(message.headCursor, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeHeadCursorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeHeadCursorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.headCursor = Cursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeHeadCursorResponse {
    return { headCursor: isSet(object.headCursor) ? Cursor.fromJSON(object.headCursor) : undefined };
  },

  toJSON(message: ComputeHeadCursorResponse): unknown {
    const obj: any = {};
    if (message.headCursor !== undefined) {
      obj.headCursor = Cursor.toJSON(message.headCursor);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeHeadCursorResponse>): ComputeHeadCursorResponse {
    return ComputeHeadCursorResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeHeadCursorResponse>): ComputeHeadCursorResponse {
    const message = createBaseComputeHeadCursorResponse();
    message.headCursor = (object.headCursor !== undefined && object.headCursor !== null)
      ? Cursor.fromPartial(object.headCursor)
      : undefined;
    return message;
  },
};

function createBaseComputeTimeCursorRequest(): ComputeTimeCursorRequest {
  return { topic: "", partition: Long.ZERO, target: undefined };
}

export const ComputeTimeCursorRequest: MessageFns<ComputeTimeCursorRequest> = {
  encode(message: ComputeTimeCursorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (!message.partition.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.partition.toString());
    }
    if (message.target !== undefined) {
      TimeTarget.encode(message.target, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeTimeCursorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeTimeCursorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.partition = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.target = TimeTarget.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeTimeCursorRequest {
    return {
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      partition: isSet(object.partition) ? Long.fromValue(object.partition) : Long.ZERO,
      target: isSet(object.target) ? TimeTarget.fromJSON(object.target) : undefined,
    };
  },

  toJSON(message: ComputeTimeCursorRequest): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (!message.partition.equals(Long.ZERO)) {
      obj.partition = (message.partition || Long.ZERO).toString();
    }
    if (message.target !== undefined) {
      obj.target = TimeTarget.toJSON(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeTimeCursorRequest>): ComputeTimeCursorRequest {
    return ComputeTimeCursorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeTimeCursorRequest>): ComputeTimeCursorRequest {
    const message = createBaseComputeTimeCursorRequest();
    message.topic = object.topic ?? "";
    message.partition = (object.partition !== undefined && object.partition !== null)
      ? Long.fromValue(object.partition)
      : Long.ZERO;
    message.target = (object.target !== undefined && object.target !== null)
      ? TimeTarget.fromPartial(object.target)
      : undefined;
    return message;
  },
};

function createBaseComputeTimeCursorResponse(): ComputeTimeCursorResponse {
  return { cursor: undefined };
}

export const ComputeTimeCursorResponse: MessageFns<ComputeTimeCursorResponse> = {
  encode(message: ComputeTimeCursorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeTimeCursorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeTimeCursorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeTimeCursorResponse {
    return { cursor: isSet(object.cursor) ? Cursor.fromJSON(object.cursor) : undefined };
  },

  toJSON(message: ComputeTimeCursorResponse): unknown {
    const obj: any = {};
    if (message.cursor !== undefined) {
      obj.cursor = Cursor.toJSON(message.cursor);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeTimeCursorResponse>): ComputeTimeCursorResponse {
    return ComputeTimeCursorResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeTimeCursorResponse>): ComputeTimeCursorResponse {
    const message = createBaseComputeTimeCursorResponse();
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

/** This service allows users to get stats about messages in their topic. */
export type TopicStatsServiceDefinition = typeof TopicStatsServiceDefinition;
export const TopicStatsServiceDefinition = {
  name: "TopicStatsService",
  fullName: "google.cloud.pubsublite.v1.TopicStatsService",
  methods: {
    /**
     * Compute statistics about a range of messages in a given topic and
     * partition.
     */
    computeMessageStats: {
      name: "ComputeMessageStats",
      requestType: ComputeMessageStatsRequest,
      requestStream: false,
      responseType: ComputeMessageStatsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              79,
              58,
              1,
              42,
              34,
              74,
              47,
              118,
              49,
              47,
              116,
              111,
              112,
              105,
              99,
              83,
              116,
              97,
              116,
              115,
              47,
              123,
              116,
              111,
              112,
              105,
              99,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              111,
              112,
              105,
              99,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              109,
              112,
              117,
              116,
              101,
              77,
              101,
              115,
              115,
              97,
              103,
              101,
              83,
              116,
              97,
              116,
              115,
            ]),
          ],
        },
      },
    },
    /**
     * Compute the head cursor for the partition.
     * The head cursor's offset is guaranteed to be less than or equal to all
     * messages which have not yet been acknowledged as published, and
     * greater than the offset of any message whose publish has already
     * been acknowledged. It is zero if there have never been messages in the
     * partition.
     */
    computeHeadCursor: {
      name: "ComputeHeadCursor",
      requestType: ComputeHeadCursorRequest,
      requestStream: false,
      responseType: ComputeHeadCursorResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              77,
              58,
              1,
              42,
              34,
              72,
              47,
              118,
              49,
              47,
              116,
              111,
              112,
              105,
              99,
              83,
              116,
              97,
              116,
              115,
              47,
              123,
              116,
              111,
              112,
              105,
              99,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              111,
              112,
              105,
              99,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              109,
              112,
              117,
              116,
              101,
              72,
              101,
              97,
              100,
              67,
              117,
              114,
              115,
              111,
              114,
            ]),
          ],
        },
      },
    },
    /**
     * Compute the corresponding cursor for a publish or event time in a topic
     * partition.
     */
    computeTimeCursor: {
      name: "ComputeTimeCursor",
      requestType: ComputeTimeCursorRequest,
      requestStream: false,
      responseType: ComputeTimeCursorResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              77,
              58,
              1,
              42,
              34,
              72,
              47,
              118,
              49,
              47,
              116,
              111,
              112,
              105,
              99,
              83,
              116,
              97,
              116,
              115,
              47,
              123,
              116,
              111,
              112,
              105,
              99,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              116,
              111,
              112,
              105,
              99,
              115,
              47,
              42,
              125,
              58,
              99,
              111,
              109,
              112,
              117,
              116,
              101,
              84,
              105,
              109,
              101,
              67,
              117,
              114,
              115,
              111,
              114,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface TopicStatsServiceImplementation<CallContextExt = {}> {
  /**
   * Compute statistics about a range of messages in a given topic and
   * partition.
   */
  computeMessageStats(
    request: ComputeMessageStatsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ComputeMessageStatsResponse>>;
  /**
   * Compute the head cursor for the partition.
   * The head cursor's offset is guaranteed to be less than or equal to all
   * messages which have not yet been acknowledged as published, and
   * greater than the offset of any message whose publish has already
   * been acknowledged. It is zero if there have never been messages in the
   * partition.
   */
  computeHeadCursor(
    request: ComputeHeadCursorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ComputeHeadCursorResponse>>;
  /**
   * Compute the corresponding cursor for a publish or event time in a topic
   * partition.
   */
  computeTimeCursor(
    request: ComputeTimeCursorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ComputeTimeCursorResponse>>;
}

export interface TopicStatsServiceClient<CallOptionsExt = {}> {
  /**
   * Compute statistics about a range of messages in a given topic and
   * partition.
   */
  computeMessageStats(
    request: DeepPartial<ComputeMessageStatsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ComputeMessageStatsResponse>;
  /**
   * Compute the head cursor for the partition.
   * The head cursor's offset is guaranteed to be less than or equal to all
   * messages which have not yet been acknowledged as published, and
   * greater than the offset of any message whose publish has already
   * been acknowledged. It is zero if there have never been messages in the
   * partition.
   */
  computeHeadCursor(
    request: DeepPartial<ComputeHeadCursorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ComputeHeadCursorResponse>;
  /**
   * Compute the corresponding cursor for a publish or event time in a topic
   * partition.
   */
  computeTimeCursor(
    request: DeepPartial<ComputeTimeCursorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ComputeTimeCursorResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
