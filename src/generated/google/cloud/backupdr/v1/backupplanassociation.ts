// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/backupdr/v1/backupplanassociation.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";

export const protobufPackage = "google.cloud.backupdr.v1";

/**
 * A BackupPlanAssociation represents a single BackupPlanAssociation which
 * contains details like workload, backup plan etc
 */
export interface BackupPlanAssociation {
  /**
   * Output only. Identifier. The resource name of BackupPlanAssociation in
   * below format Format :
   * projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}
   */
  name: string;
  /** Optional. Resource type of workload on which backupplan is applied */
  resourceType: string;
  /**
   * Required. Immutable. Resource name of workload on which backupplan is
   * applied
   */
  resource: string;
  /**
   * Required. Resource name of backup plan which needs to be applied on
   * workload. Format:
   * projects/{project}/locations/{location}/backupPlans/{backupPlanId}
   */
  backupPlan: string;
  /** Output only. The time when the instance was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the instance was updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. The BackupPlanAssociation resource state. */
  state: BackupPlanAssociation_State;
  /** Output only. The config info related to backup rules. */
  rulesConfigInfo: RuleConfigInfo[];
  /**
   * Output only. Output Only.
   *
   * Resource name of data source which will be used as storage location for
   * backups taken.
   * Format :
   * projects/{project}/locations/{location}/backupVaults/{backupvault}/dataSources/{datasource}
   */
  dataSource: string;
}

/** Enum for State of BackupPlan Association */
export enum BackupPlanAssociation_State {
  /** STATE_UNSPECIFIED - State not set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The resource is being created. */
  CREATING = 1,
  /** ACTIVE - The resource has been created and is fully usable. */
  ACTIVE = 2,
  /** DELETING - The resource is being deleted. */
  DELETING = 3,
  /** INACTIVE - The resource has been created but is not usable. */
  INACTIVE = 4,
  UNRECOGNIZED = -1,
}

export function backupPlanAssociation_StateFromJSON(object: any): BackupPlanAssociation_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return BackupPlanAssociation_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return BackupPlanAssociation_State.CREATING;
    case 2:
    case "ACTIVE":
      return BackupPlanAssociation_State.ACTIVE;
    case 3:
    case "DELETING":
      return BackupPlanAssociation_State.DELETING;
    case 4:
    case "INACTIVE":
      return BackupPlanAssociation_State.INACTIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackupPlanAssociation_State.UNRECOGNIZED;
  }
}

export function backupPlanAssociation_StateToJSON(object: BackupPlanAssociation_State): string {
  switch (object) {
    case BackupPlanAssociation_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case BackupPlanAssociation_State.CREATING:
      return "CREATING";
    case BackupPlanAssociation_State.ACTIVE:
      return "ACTIVE";
    case BackupPlanAssociation_State.DELETING:
      return "DELETING";
    case BackupPlanAssociation_State.INACTIVE:
      return "INACTIVE";
    case BackupPlanAssociation_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message for rules config info. */
export interface RuleConfigInfo {
  /**
   * Output only. Output Only.
   *
   * Backup Rule id fetched from backup plan.
   */
  ruleId: string;
  /** Output only. The last backup state for rule. */
  lastBackupState: RuleConfigInfo_LastBackupState;
  /**
   * Output only. Output Only.
   *
   * google.rpc.Status object to store the last backup error.
   */
  lastBackupError:
    | Status
    | undefined;
  /**
   * Output only. The point in time when the last successful backup was captured
   * from the source.
   */
  lastSuccessfulBackupConsistencyTime: Date | undefined;
}

/** Enum for LastBackupState */
export enum RuleConfigInfo_LastBackupState {
  /** LAST_BACKUP_STATE_UNSPECIFIED - State not set. */
  LAST_BACKUP_STATE_UNSPECIFIED = 0,
  /** FIRST_BACKUP_PENDING - The first backup is pending. */
  FIRST_BACKUP_PENDING = 1,
  /**
   * PERMISSION_DENIED - The most recent backup could not be run/failed because of the lack of
   * permissions.
   */
  PERMISSION_DENIED = 2,
  /** SUCCEEDED - The last backup operation succeeded. */
  SUCCEEDED = 3,
  /** FAILED - The last backup operation failed. */
  FAILED = 4,
  UNRECOGNIZED = -1,
}

export function ruleConfigInfo_LastBackupStateFromJSON(object: any): RuleConfigInfo_LastBackupState {
  switch (object) {
    case 0:
    case "LAST_BACKUP_STATE_UNSPECIFIED":
      return RuleConfigInfo_LastBackupState.LAST_BACKUP_STATE_UNSPECIFIED;
    case 1:
    case "FIRST_BACKUP_PENDING":
      return RuleConfigInfo_LastBackupState.FIRST_BACKUP_PENDING;
    case 2:
    case "PERMISSION_DENIED":
      return RuleConfigInfo_LastBackupState.PERMISSION_DENIED;
    case 3:
    case "SUCCEEDED":
      return RuleConfigInfo_LastBackupState.SUCCEEDED;
    case 4:
    case "FAILED":
      return RuleConfigInfo_LastBackupState.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RuleConfigInfo_LastBackupState.UNRECOGNIZED;
  }
}

export function ruleConfigInfo_LastBackupStateToJSON(object: RuleConfigInfo_LastBackupState): string {
  switch (object) {
    case RuleConfigInfo_LastBackupState.LAST_BACKUP_STATE_UNSPECIFIED:
      return "LAST_BACKUP_STATE_UNSPECIFIED";
    case RuleConfigInfo_LastBackupState.FIRST_BACKUP_PENDING:
      return "FIRST_BACKUP_PENDING";
    case RuleConfigInfo_LastBackupState.PERMISSION_DENIED:
      return "PERMISSION_DENIED";
    case RuleConfigInfo_LastBackupState.SUCCEEDED:
      return "SUCCEEDED";
    case RuleConfigInfo_LastBackupState.FAILED:
      return "FAILED";
    case RuleConfigInfo_LastBackupState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request message for creating a backup plan. */
export interface CreateBackupPlanAssociationRequest {
  /**
   * Required. The backup plan association project and location in the format
   * `projects/{project_id}/locations/{location}`. In Cloud BackupDR locations
   * map to GCP regions, for example **us-central1**.
   */
  parent: string;
  /**
   * Required. The name of the backup plan association to create. The name must
   * be unique for the specified project and location.
   */
  backupPlanAssociationId: string;
  /** Required. The resource being created */
  backupPlanAssociation:
    | BackupPlanAssociation
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and t
   * he request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for List BackupPlanAssociation */
export interface ListBackupPlanAssociationsRequest {
  /**
   * Required. The project and location for which to retrieve backup Plan
   * Associations information, in the format
   * `projects/{project_id}/locations/{location}`. In Cloud BackupDR, locations
   * map to GCP regions, for example **us-central1**. To retrieve backup plan
   * associations for all locations, use "-" for the
   * `{location}` value.
   */
  parent: string;
  /**
   * Optional. Requested page size. Server may return fewer items than
   * requested. If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** Optional. A token identifying a page of results the server should return. */
  pageToken: string;
  /** Optional. Filtering results */
  filter: string;
}

/** Response message for List BackupPlanAssociation */
export interface ListBackupPlanAssociationsResponse {
  /**
   * The list of Backup Plan Associations in the project for the specified
   * location.
   *
   * If the `{location}` value in the request is "-", the response contains a
   * list of instances from all locations. In case any location is unreachable,
   * the response will only return backup plan associations in reachable
   * locations and the 'unreachable' field will be populated with a list of
   * unreachable locations.
   */
  backupPlanAssociations: BackupPlanAssociation[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for getting a BackupPlanAssociation resource. */
export interface GetBackupPlanAssociationRequest {
  /**
   * Required. Name of the backup plan association resource, in the format
   * `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
   */
  name: string;
}

/** Request message for deleting a backup plan association. */
export interface DeleteBackupPlanAssociationRequest {
  /**
   * Required. Name of the backup plan association resource, in the format
   * `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
   */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for triggering a backup. */
export interface TriggerBackupRequest {
  /**
   * Required. Name of the backup plan association resource, in the format
   * `projects/{project}/locations/{location}/backupPlanAssociations/{backupPlanAssociationId}`
   */
  name: string;
  /** Required. backup rule_id for which a backup needs to be triggered. */
  ruleId: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

function createBaseBackupPlanAssociation(): BackupPlanAssociation {
  return {
    name: "",
    resourceType: "",
    resource: "",
    backupPlan: "",
    createTime: undefined,
    updateTime: undefined,
    state: 0,
    rulesConfigInfo: [],
    dataSource: "",
  };
}

export const BackupPlanAssociation: MessageFns<BackupPlanAssociation> = {
  encode(message: BackupPlanAssociation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.resourceType !== "") {
      writer.uint32(18).string(message.resourceType);
    }
    if (message.resource !== "") {
      writer.uint32(26).string(message.resource);
    }
    if (message.backupPlan !== "") {
      writer.uint32(34).string(message.backupPlan);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    for (const v of message.rulesConfigInfo) {
      RuleConfigInfo.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.dataSource !== "") {
      writer.uint32(74).string(message.dataSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupPlanAssociation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupPlanAssociation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resourceType = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.backupPlan = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.rulesConfigInfo.push(RuleConfigInfo.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.dataSource = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupPlanAssociation {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      resourceType: isSet(object.resourceType) ? globalThis.String(object.resourceType) : "",
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      backupPlan: isSet(object.backupPlan) ? globalThis.String(object.backupPlan) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      state: isSet(object.state) ? backupPlanAssociation_StateFromJSON(object.state) : 0,
      rulesConfigInfo: globalThis.Array.isArray(object?.rulesConfigInfo)
        ? object.rulesConfigInfo.map((e: any) => RuleConfigInfo.fromJSON(e))
        : [],
      dataSource: isSet(object.dataSource) ? globalThis.String(object.dataSource) : "",
    };
  },

  toJSON(message: BackupPlanAssociation): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.resourceType !== "") {
      obj.resourceType = message.resourceType;
    }
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.backupPlan !== "") {
      obj.backupPlan = message.backupPlan;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = backupPlanAssociation_StateToJSON(message.state);
    }
    if (message.rulesConfigInfo?.length) {
      obj.rulesConfigInfo = message.rulesConfigInfo.map((e) => RuleConfigInfo.toJSON(e));
    }
    if (message.dataSource !== "") {
      obj.dataSource = message.dataSource;
    }
    return obj;
  },

  create(base?: DeepPartial<BackupPlanAssociation>): BackupPlanAssociation {
    return BackupPlanAssociation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupPlanAssociation>): BackupPlanAssociation {
    const message = createBaseBackupPlanAssociation();
    message.name = object.name ?? "";
    message.resourceType = object.resourceType ?? "";
    message.resource = object.resource ?? "";
    message.backupPlan = object.backupPlan ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.state = object.state ?? 0;
    message.rulesConfigInfo = object.rulesConfigInfo?.map((e) => RuleConfigInfo.fromPartial(e)) || [];
    message.dataSource = object.dataSource ?? "";
    return message;
  },
};

function createBaseRuleConfigInfo(): RuleConfigInfo {
  return { ruleId: "", lastBackupState: 0, lastBackupError: undefined, lastSuccessfulBackupConsistencyTime: undefined };
}

export const RuleConfigInfo: MessageFns<RuleConfigInfo> = {
  encode(message: RuleConfigInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ruleId !== "") {
      writer.uint32(10).string(message.ruleId);
    }
    if (message.lastBackupState !== 0) {
      writer.uint32(24).int32(message.lastBackupState);
    }
    if (message.lastBackupError !== undefined) {
      Status.encode(message.lastBackupError, writer.uint32(34).fork()).join();
    }
    if (message.lastSuccessfulBackupConsistencyTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastSuccessfulBackupConsistencyTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RuleConfigInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRuleConfigInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ruleId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lastBackupState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.lastBackupError = Status.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lastSuccessfulBackupConsistencyTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RuleConfigInfo {
    return {
      ruleId: isSet(object.ruleId) ? globalThis.String(object.ruleId) : "",
      lastBackupState: isSet(object.lastBackupState)
        ? ruleConfigInfo_LastBackupStateFromJSON(object.lastBackupState)
        : 0,
      lastBackupError: isSet(object.lastBackupError) ? Status.fromJSON(object.lastBackupError) : undefined,
      lastSuccessfulBackupConsistencyTime: isSet(object.lastSuccessfulBackupConsistencyTime)
        ? fromJsonTimestamp(object.lastSuccessfulBackupConsistencyTime)
        : undefined,
    };
  },

  toJSON(message: RuleConfigInfo): unknown {
    const obj: any = {};
    if (message.ruleId !== "") {
      obj.ruleId = message.ruleId;
    }
    if (message.lastBackupState !== 0) {
      obj.lastBackupState = ruleConfigInfo_LastBackupStateToJSON(message.lastBackupState);
    }
    if (message.lastBackupError !== undefined) {
      obj.lastBackupError = Status.toJSON(message.lastBackupError);
    }
    if (message.lastSuccessfulBackupConsistencyTime !== undefined) {
      obj.lastSuccessfulBackupConsistencyTime = message.lastSuccessfulBackupConsistencyTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<RuleConfigInfo>): RuleConfigInfo {
    return RuleConfigInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RuleConfigInfo>): RuleConfigInfo {
    const message = createBaseRuleConfigInfo();
    message.ruleId = object.ruleId ?? "";
    message.lastBackupState = object.lastBackupState ?? 0;
    message.lastBackupError = (object.lastBackupError !== undefined && object.lastBackupError !== null)
      ? Status.fromPartial(object.lastBackupError)
      : undefined;
    message.lastSuccessfulBackupConsistencyTime = object.lastSuccessfulBackupConsistencyTime ?? undefined;
    return message;
  },
};

function createBaseCreateBackupPlanAssociationRequest(): CreateBackupPlanAssociationRequest {
  return { parent: "", backupPlanAssociationId: "", backupPlanAssociation: undefined, requestId: "" };
}

export const CreateBackupPlanAssociationRequest: MessageFns<CreateBackupPlanAssociationRequest> = {
  encode(message: CreateBackupPlanAssociationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.backupPlanAssociationId !== "") {
      writer.uint32(18).string(message.backupPlanAssociationId);
    }
    if (message.backupPlanAssociation !== undefined) {
      BackupPlanAssociation.encode(message.backupPlanAssociation, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBackupPlanAssociationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBackupPlanAssociationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backupPlanAssociationId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupPlanAssociation = BackupPlanAssociation.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBackupPlanAssociationRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      backupPlanAssociationId: isSet(object.backupPlanAssociationId)
        ? globalThis.String(object.backupPlanAssociationId)
        : "",
      backupPlanAssociation: isSet(object.backupPlanAssociation)
        ? BackupPlanAssociation.fromJSON(object.backupPlanAssociation)
        : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: CreateBackupPlanAssociationRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.backupPlanAssociationId !== "") {
      obj.backupPlanAssociationId = message.backupPlanAssociationId;
    }
    if (message.backupPlanAssociation !== undefined) {
      obj.backupPlanAssociation = BackupPlanAssociation.toJSON(message.backupPlanAssociation);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBackupPlanAssociationRequest>): CreateBackupPlanAssociationRequest {
    return CreateBackupPlanAssociationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBackupPlanAssociationRequest>): CreateBackupPlanAssociationRequest {
    const message = createBaseCreateBackupPlanAssociationRequest();
    message.parent = object.parent ?? "";
    message.backupPlanAssociationId = object.backupPlanAssociationId ?? "";
    message.backupPlanAssociation =
      (object.backupPlanAssociation !== undefined && object.backupPlanAssociation !== null)
        ? BackupPlanAssociation.fromPartial(object.backupPlanAssociation)
        : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseListBackupPlanAssociationsRequest(): ListBackupPlanAssociationsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListBackupPlanAssociationsRequest: MessageFns<ListBackupPlanAssociationsRequest> = {
  encode(message: ListBackupPlanAssociationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBackupPlanAssociationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBackupPlanAssociationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBackupPlanAssociationsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListBackupPlanAssociationsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBackupPlanAssociationsRequest>): ListBackupPlanAssociationsRequest {
    return ListBackupPlanAssociationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBackupPlanAssociationsRequest>): ListBackupPlanAssociationsRequest {
    const message = createBaseListBackupPlanAssociationsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListBackupPlanAssociationsResponse(): ListBackupPlanAssociationsResponse {
  return { backupPlanAssociations: [], nextPageToken: "", unreachable: [] };
}

export const ListBackupPlanAssociationsResponse: MessageFns<ListBackupPlanAssociationsResponse> = {
  encode(message: ListBackupPlanAssociationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.backupPlanAssociations) {
      BackupPlanAssociation.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBackupPlanAssociationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBackupPlanAssociationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backupPlanAssociations.push(BackupPlanAssociation.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBackupPlanAssociationsResponse {
    return {
      backupPlanAssociations: globalThis.Array.isArray(object?.backupPlanAssociations)
        ? object.backupPlanAssociations.map((e: any) => BackupPlanAssociation.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListBackupPlanAssociationsResponse): unknown {
    const obj: any = {};
    if (message.backupPlanAssociations?.length) {
      obj.backupPlanAssociations = message.backupPlanAssociations.map((e) => BackupPlanAssociation.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBackupPlanAssociationsResponse>): ListBackupPlanAssociationsResponse {
    return ListBackupPlanAssociationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBackupPlanAssociationsResponse>): ListBackupPlanAssociationsResponse {
    const message = createBaseListBackupPlanAssociationsResponse();
    message.backupPlanAssociations = object.backupPlanAssociations?.map((e) => BackupPlanAssociation.fromPartial(e)) ||
      [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetBackupPlanAssociationRequest(): GetBackupPlanAssociationRequest {
  return { name: "" };
}

export const GetBackupPlanAssociationRequest: MessageFns<GetBackupPlanAssociationRequest> = {
  encode(message: GetBackupPlanAssociationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBackupPlanAssociationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBackupPlanAssociationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBackupPlanAssociationRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetBackupPlanAssociationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBackupPlanAssociationRequest>): GetBackupPlanAssociationRequest {
    return GetBackupPlanAssociationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBackupPlanAssociationRequest>): GetBackupPlanAssociationRequest {
    const message = createBaseGetBackupPlanAssociationRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteBackupPlanAssociationRequest(): DeleteBackupPlanAssociationRequest {
  return { name: "", requestId: "" };
}

export const DeleteBackupPlanAssociationRequest: MessageFns<DeleteBackupPlanAssociationRequest> = {
  encode(message: DeleteBackupPlanAssociationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteBackupPlanAssociationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBackupPlanAssociationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteBackupPlanAssociationRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteBackupPlanAssociationRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteBackupPlanAssociationRequest>): DeleteBackupPlanAssociationRequest {
    return DeleteBackupPlanAssociationRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteBackupPlanAssociationRequest>): DeleteBackupPlanAssociationRequest {
    const message = createBaseDeleteBackupPlanAssociationRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseTriggerBackupRequest(): TriggerBackupRequest {
  return { name: "", ruleId: "", requestId: "" };
}

export const TriggerBackupRequest: MessageFns<TriggerBackupRequest> = {
  encode(message: TriggerBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.ruleId !== "") {
      writer.uint32(18).string(message.ruleId);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TriggerBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTriggerBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ruleId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TriggerBackupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      ruleId: isSet(object.ruleId) ? globalThis.String(object.ruleId) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: TriggerBackupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.ruleId !== "") {
      obj.ruleId = message.ruleId;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<TriggerBackupRequest>): TriggerBackupRequest {
    return TriggerBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TriggerBackupRequest>): TriggerBackupRequest {
    const message = createBaseTriggerBackupRequest();
    message.name = object.name ?? "";
    message.ruleId = object.ruleId ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
