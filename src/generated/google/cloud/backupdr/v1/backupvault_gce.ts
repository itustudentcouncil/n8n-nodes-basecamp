// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/backupdr/v1/backupvault_gce.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "google.cloud.backupdr.v1";

/**
 * Specifies whether the virtual machine instance will be shut down on key
 * revocation. It is currently used in instance, instance properties and GMI
 * protos
 */
export enum KeyRevocationActionType {
  /** KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED - Default value. This value is unused. */
  KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED = 0,
  /** NONE - Indicates user chose no operation. */
  NONE = 1,
  /** STOP - Indicates user chose to opt for VM shutdown on key revocation. */
  STOP = 2,
  UNRECOGNIZED = -1,
}

export function keyRevocationActionTypeFromJSON(object: any): KeyRevocationActionType {
  switch (object) {
    case 0:
    case "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED":
      return KeyRevocationActionType.KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED;
    case 1:
    case "NONE":
      return KeyRevocationActionType.NONE;
    case 2:
    case "STOP":
      return KeyRevocationActionType.STOP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KeyRevocationActionType.UNRECOGNIZED;
  }
}

export function keyRevocationActionTypeToJSON(object: KeyRevocationActionType): string {
  switch (object) {
    case KeyRevocationActionType.KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED:
      return "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED";
    case KeyRevocationActionType.NONE:
      return "NONE";
    case KeyRevocationActionType.STOP:
      return "STOP";
    case KeyRevocationActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * ComputeInstanceBackupProperties represents Compute Engine instance backup
 * properties.
 */
export interface ComputeInstanceBackupProperties {
  /**
   * An optional text description for the instances that are created from these
   * properties.
   */
  description?:
    | string
    | undefined;
  /**
   * A list of tags to apply to the instances that are created from these
   * properties. The tags identify valid sources or targets for network
   * firewalls. The setTags method can modify this list of tags. Each tag within
   * the list must comply with RFC1035 (https://www.ietf.org/rfc/rfc1035.txt).
   */
  tags?:
    | Tags
    | undefined;
  /**
   * The machine type to use for instances that are created from these
   * properties.
   */
  machineType?:
    | string
    | undefined;
  /**
   * Enables instances created based on these properties to send packets with
   * source IP addresses other than their own and receive packets with
   * destination IP addresses other than their own. If these instances will be
   * used as an IP gateway or it will be set as the next-hop in a Route
   * resource, specify `true`. If unsure, leave this set to `false`. See the
   * https://cloud.google.com/vpc/docs/using-routes#canipforward
   * documentation for more information.
   */
  canIpForward?:
    | boolean
    | undefined;
  /** An array of network access configurations for this interface. */
  networkInterface: NetworkInterface[];
  /**
   * An array of disks that are associated with the instances that are created
   * from these properties.
   */
  disk: AttachedDisk[];
  /**
   * The metadata key/value pairs to assign to instances that are created from
   * these properties. These pairs can consist of custom metadata or predefined
   * keys. See https://cloud.google.com/compute/docs/metadata/overview for more
   * information.
   */
  metadata?:
    | Metadata
    | undefined;
  /**
   * A list of service accounts with specified scopes. Access tokens for these
   * service accounts are available to the instances that are created from
   * these properties. Use metadata queries to obtain the access tokens for
   * these instances.
   */
  serviceAccount: ServiceAccount[];
  /**
   * Specifies the scheduling options for the instances that are created from
   * these properties.
   */
  scheduling?:
    | Scheduling
    | undefined;
  /**
   * A list of guest accelerator cards' type and count to use for instances
   * created from these properties.
   */
  guestAccelerator: AcceleratorConfig[];
  /**
   * Minimum cpu/platform to be used by instances. The instance may be
   * scheduled on the specified or newer cpu/platform. Applicable values are the
   * friendly names of CPU platforms, such as
   * `minCpuPlatform: Intel Haswell` or `minCpuPlatform: Intel Sandy Bridge`.
   * For more information, read
   * https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform.
   */
  minCpuPlatform?:
    | string
    | undefined;
  /**
   * KeyRevocationActionType of the instance. Supported options are "STOP" and
   * "NONE". The default value is "NONE" if it is not specified.
   */
  keyRevocationActionType?:
    | KeyRevocationActionType
    | undefined;
  /**
   * The source instance used to create this backup. This can be a partial or
   * full URL to the resource. For example, the following are valid values:
   *   -https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
   *   -projects/project/zones/zone/instances/instance
   */
  sourceInstance?:
    | string
    | undefined;
  /** Labels to apply to instances that are created from these properties. */
  labels: { [key: string]: string };
}

export interface ComputeInstanceBackupProperties_LabelsEntry {
  key: string;
  value: string;
}

/**
 * ComputeInstanceRestoreProperties represents Compute Engine instance
 * properties to be overridden during restore.
 */
export interface ComputeInstanceRestoreProperties {
  /** Required. Name of the compute instance. */
  name?:
    | string
    | undefined;
  /** Optional. Controls for advanced machine-related behavior features. */
  advancedMachineFeatures?:
    | AdvancedMachineFeatures
    | undefined;
  /**
   * Optional. Allows this instance to send and receive packets with
   * non-matching destination or source IPs.
   */
  canIpForward?:
    | boolean
    | undefined;
  /** Optional. Controls Confidential compute options on the instance */
  confidentialInstanceConfig?:
    | ConfidentialInstanceConfig
    | undefined;
  /** Optional. Whether the resource should be protected against deletion. */
  deletionProtection?:
    | boolean
    | undefined;
  /**
   * Optional. An optional description of this resource. Provide this property
   * when you create the resource.
   */
  description?:
    | string
    | undefined;
  /**
   * Optional. Array of disks associated with this instance. Persistent disks
   * must be created before you can assign them.
   */
  disks: AttachedDisk[];
  /** Optional. Enables display device for the instance. */
  displayDevice?:
    | DisplayDevice
    | undefined;
  /**
   * Optional. A list of the type and count of accelerator cards attached to the
   * instance.
   */
  guestAccelerators: AcceleratorConfig[];
  /**
   * Optional. Specifies the hostname of the instance. The specified hostname
   * must be RFC1035 compliant. If hostname is not specified, the default
   * hostname is [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global
   * DNS, and [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal
   * DNS.
   */
  hostname?:
    | string
    | undefined;
  /**
   * Optional. Encrypts suspended data for an instance with a
   * customer-managed encryption key.
   */
  instanceEncryptionKey?:
    | CustomerEncryptionKey
    | undefined;
  /** Optional. KeyRevocationActionType of the instance. */
  keyRevocationActionType?:
    | KeyRevocationActionType
    | undefined;
  /** Optional. Labels to apply to this instance. */
  labels: { [key: string]: string };
  /**
   * Optional. Full or partial URL of the machine type resource to use for this
   * instance.
   */
  machineType?:
    | string
    | undefined;
  /** Optional. This includes custom metadata and predefined keys. */
  metadata?:
    | Metadata
    | undefined;
  /** Optional. Minimum CPU platform to use for this instance. */
  minCpuPlatform?:
    | string
    | undefined;
  /**
   * Optional. An array of network configurations for this instance. These
   * specify how interfaces are configured to interact with other network
   * services, such as connecting to the internet. Multiple interfaces are
   * supported per instance.
   */
  networkInterfaces: NetworkInterface[];
  /** Optional. Configure network performance such as egress bandwidth tier. */
  networkPerformanceConfig?:
    | NetworkPerformanceConfig
    | undefined;
  /**
   * Input only. Additional params passed with the request, but not persisted
   * as part of resource payload.
   */
  params?:
    | InstanceParams
    | undefined;
  /**
   * Optional. The private IPv6 google access type for the VM.
   * If not specified, use INHERIT_FROM_SUBNETWORK as default.
   */
  privateIpv6GoogleAccess?:
    | ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess
    | undefined;
  /** Optional. Specifies the reservations that this instance can consume from. */
  allocationAffinity?:
    | AllocationAffinity
    | undefined;
  /** Optional. Resource policies applied to this instance. */
  resourcePolicies: string[];
  /** Optional. Sets the scheduling options for this instance. */
  scheduling?:
    | Scheduling
    | undefined;
  /**
   * Optional. A list of service accounts, with their specified scopes,
   * authorized for this instance. Only one service account per VM instance is
   * supported.
   */
  serviceAccounts: ServiceAccount[];
  /**
   * Optional. Tags to apply to this instance. Tags are used to identify valid
   * sources or targets for network firewalls and are specified by the client
   * during instance creation.
   */
  tags?: Tags | undefined;
}

/** The private IPv6 google access type for the VMs. */
export enum ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess {
  /** INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED - Default value. This value is unused. */
  INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED = 0,
  /**
   * INHERIT_FROM_SUBNETWORK - Each network interface inherits PrivateIpv6GoogleAccess from its
   * subnetwork.
   */
  INHERIT_FROM_SUBNETWORK = 1,
  /**
   * ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE - Outbound private IPv6 access from VMs in this subnet to Google services.
   * If specified, the subnetwork who is attached to the instance's default
   * network interface will be assigned an internal IPv6 prefix if it doesn't
   * have before.
   */
  ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE = 2,
  /**
   * ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE - Bidirectional private IPv6 access to/from Google services. If
   * specified, the subnetwork who is attached to the instance's default
   * network interface will be assigned an internal IPv6 prefix if it doesn't
   * have before.
   */
  ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE = 3,
  UNRECOGNIZED = -1,
}

export function computeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccessFromJSON(
  object: any,
): ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess {
  switch (object) {
    case 0:
    case "INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED":
      return ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess
        .INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED;
    case 1:
    case "INHERIT_FROM_SUBNETWORK":
      return ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess.INHERIT_FROM_SUBNETWORK;
    case 2:
    case "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE":
      return ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess.ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE;
    case 3:
    case "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE":
      return ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess.ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess.UNRECOGNIZED;
  }
}

export function computeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccessToJSON(
  object: ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess,
): string {
  switch (object) {
    case ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess
      .INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED:
      return "INSTANCE_PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED";
    case ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess.INHERIT_FROM_SUBNETWORK:
      return "INHERIT_FROM_SUBNETWORK";
    case ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess.ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE:
      return "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE";
    case ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess.ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE:
      return "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE";
    case ComputeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccess.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ComputeInstanceRestoreProperties_LabelsEntry {
  key: string;
  value: string;
}

/**
 * ComputeInstanceTargetEnvironment represents Compute Engine target
 * environment to be used during restore.
 */
export interface ComputeInstanceTargetEnvironment {
  /** Required. Target project for the Compute Engine instance. */
  project: string;
  /** Required. The zone of the Compute Engine instance. */
  zone: string;
}

/**
 * ComputeInstanceDataSourceProperties represents the properties of a
 * ComputeEngine resource that are stored in the DataSource.
 */
export interface ComputeInstanceDataSourceProperties {
  /** Name of the compute instance backed up by the datasource. */
  name: string;
  /** The description of the Compute Engine instance. */
  description: string;
  /** The machine type of the instance. */
  machineType: string;
  /** The total number of disks attached to the Instance. */
  totalDiskCount: Long;
  /** The sum of all the disk sizes. */
  totalDiskSizeGb: Long;
}

/** Specifies options for controlling advanced machine features. */
export interface AdvancedMachineFeatures {
  /**
   * Optional. Whether to enable nested virtualization or not (default is
   * false).
   */
  enableNestedVirtualization?:
    | boolean
    | undefined;
  /**
   * Optional. The number of threads per physical core. To disable simultaneous
   * multithreading (SMT) set this to 1. If unset, the maximum number
   * of threads supported per core by the underlying processor is
   * assumed.
   */
  threadsPerCore?:
    | number
    | undefined;
  /**
   * Optional. The number of physical cores to expose to an instance. Multiply
   * by the number of threads per core to compute the total number of virtual
   * CPUs to expose to the instance. If unset, the number of cores is
   * inferred from the instance's nominal CPU count and the underlying
   * platform's SMT width.
   */
  visibleCoreCount?:
    | number
    | undefined;
  /** Optional. Whether to enable UEFI networking for instance creation. */
  enableUefiNetworking?: boolean | undefined;
}

/** A set of Confidential Instance options. */
export interface ConfidentialInstanceConfig {
  /**
   * Optional. Defines whether the instance should have confidential compute
   * enabled.
   */
  enableConfidentialCompute?: boolean | undefined;
}

/** A set of Display Device options */
export interface DisplayDevice {
  /** Optional. Enables display for the Compute Engine VM */
  enableDisplay?: boolean | undefined;
}

/**
 * A specification of the type and number of accelerator cards attached to the
 * instance.
 */
export interface AcceleratorConfig {
  /**
   * Optional. Full or partial URL of the accelerator type resource to attach to
   * this instance.
   */
  acceleratorType?:
    | string
    | undefined;
  /**
   * Optional. The number of the guest accelerator cards exposed to this
   * instance.
   */
  acceleratorCount?: number | undefined;
}

/** A customer-supplied encryption key. */
export interface CustomerEncryptionKey {
  /**
   * Optional. Specifies a 256-bit customer-supplied
   * encryption key.
   */
  rawKey?:
    | string
    | undefined;
  /**
   * Optional. RSA-wrapped 2048-bit
   * customer-supplied encryption key to either encrypt or decrypt this
   * resource.
   */
  rsaEncryptedKey?:
    | string
    | undefined;
  /**
   * Optional. The name of the encryption key that is stored in Google Cloud
   * KMS.
   */
  kmsKeyName?:
    | string
    | undefined;
  /**
   * Optional. The service account being used for the encryption request for the
   * given KMS key. If absent, the Compute Engine default service account is
   * used.
   */
  kmsKeyServiceAccount?: string | undefined;
}

/** A key/value pair to be used for storing metadata. */
export interface Entry {
  /** Optional. Key for the metadata entry. */
  key?:
    | string
    | undefined;
  /**
   * Optional. Value for the metadata entry. These are free-form strings, and
   * only have meaning as interpreted by the image running in the instance. The
   * only restriction placed on values is that their size must be less than
   * or equal to 262144 bytes (256 KiB).
   */
  value?: string | undefined;
}

/** A metadata key/value entry. */
export interface Metadata {
  /**
   * Optional. Array of key/value pairs. The total size of all keys and values
   * must be less than 512 KB.
   */
  items: Entry[];
}

/**
 * A network interface resource attached to an instance.
 * s
 */
export interface NetworkInterface {
  /** Optional. URL of the VPC network resource for this instance. */
  network?:
    | string
    | undefined;
  /** Optional. The URL of the Subnetwork resource for this instance. */
  subnetwork?:
    | string
    | undefined;
  /**
   * Optional. An IPv4 internal IP address to assign to the instance for this
   * network interface. If not specified by the user, an unused internal IP is
   * assigned by the system.
   */
  ipAddress?:
    | string
    | undefined;
  /**
   * Optional. An IPv6 internal network address for this network interface. To
   * use a static internal IP address, it must be unused and in the same region
   * as the instance's zone. If not specified, Google Cloud will automatically
   * assign an internal IPv6 address from the instance's subnetwork.
   */
  ipv6Address?:
    | string
    | undefined;
  /** Optional. The prefix length of the primary internal IPv6 range. */
  internalIpv6PrefixLength?:
    | number
    | undefined;
  /**
   * Output only. [Output Only] The name of the network interface, which is
   * generated by the server.
   */
  name?:
    | string
    | undefined;
  /**
   * Optional. An array of configurations for this interface. Currently, only
   * one access config,ONE_TO_ONE_NAT is supported. If there are no
   * accessConfigs specified, then this instance will have
   * no external internet access.
   */
  accessConfigs: AccessConfig[];
  /**
   * Optional. An array of IPv6 access configurations for this interface.
   * Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there
   * is no ipv6AccessConfig specified, then this instance will
   * have no external IPv6 Internet access.
   */
  ipv6AccessConfigs: AccessConfig[];
  /**
   * Optional. An array of alias IP ranges for this network interface.
   * You can only specify this field for network interfaces in VPC networks.
   */
  aliasIpRanges: AliasIpRange[];
  /** The stack type for this network interface. */
  stackType?:
    | NetworkInterface_StackType
    | undefined;
  /**
   * Optional. [Output Only] One of EXTERNAL, INTERNAL to indicate whether the
   * IP can be accessed from the Internet. This field is always inherited from
   * its subnetwork.
   */
  ipv6AccessType?:
    | NetworkInterface_Ipv6AccessType
    | undefined;
  /**
   * Optional. The networking queue count that's specified by users for the
   * network interface. Both Rx and Tx queues will be set to this number. It'll
   * be empty if not specified by the users.
   */
  queueCount?:
    | number
    | undefined;
  /**
   * Optional. The type of vNIC to be used on this interface. This may be gVNIC
   * or VirtioNet.
   */
  nicType?:
    | NetworkInterface_NicType
    | undefined;
  /**
   * Optional. The URL of the network attachment that this interface should
   * connect to in the following format:
   * projects/{project_number}/regions/{region_name}/networkAttachments/{network_attachment_name}.
   */
  networkAttachment?: string | undefined;
}

/** Stack type for this network interface. */
export enum NetworkInterface_StackType {
  /** STACK_TYPE_UNSPECIFIED - Default should be STACK_TYPE_UNSPECIFIED. */
  STACK_TYPE_UNSPECIFIED = 0,
  /** IPV4_ONLY - The network interface will be assigned IPv4 address. */
  IPV4_ONLY = 1,
  /** IPV4_IPV6 - The network interface can have both IPv4 and IPv6 addresses. */
  IPV4_IPV6 = 2,
  UNRECOGNIZED = -1,
}

export function networkInterface_StackTypeFromJSON(object: any): NetworkInterface_StackType {
  switch (object) {
    case 0:
    case "STACK_TYPE_UNSPECIFIED":
      return NetworkInterface_StackType.STACK_TYPE_UNSPECIFIED;
    case 1:
    case "IPV4_ONLY":
      return NetworkInterface_StackType.IPV4_ONLY;
    case 2:
    case "IPV4_IPV6":
      return NetworkInterface_StackType.IPV4_IPV6;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkInterface_StackType.UNRECOGNIZED;
  }
}

export function networkInterface_StackTypeToJSON(object: NetworkInterface_StackType): string {
  switch (object) {
    case NetworkInterface_StackType.STACK_TYPE_UNSPECIFIED:
      return "STACK_TYPE_UNSPECIFIED";
    case NetworkInterface_StackType.IPV4_ONLY:
      return "IPV4_ONLY";
    case NetworkInterface_StackType.IPV4_IPV6:
      return "IPV4_IPV6";
    case NetworkInterface_StackType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** IPv6 access type for this network interface. */
export enum NetworkInterface_Ipv6AccessType {
  /**
   * UNSPECIFIED_IPV6_ACCESS_TYPE - IPv6 access type not set. Means this network interface hasn't been
   * turned on IPv6 yet.
   */
  UNSPECIFIED_IPV6_ACCESS_TYPE = 0,
  /** INTERNAL - This network interface can have internal IPv6. */
  INTERNAL = 1,
  /** EXTERNAL - This network interface can have external IPv6. */
  EXTERNAL = 2,
  UNRECOGNIZED = -1,
}

export function networkInterface_Ipv6AccessTypeFromJSON(object: any): NetworkInterface_Ipv6AccessType {
  switch (object) {
    case 0:
    case "UNSPECIFIED_IPV6_ACCESS_TYPE":
      return NetworkInterface_Ipv6AccessType.UNSPECIFIED_IPV6_ACCESS_TYPE;
    case 1:
    case "INTERNAL":
      return NetworkInterface_Ipv6AccessType.INTERNAL;
    case 2:
    case "EXTERNAL":
      return NetworkInterface_Ipv6AccessType.EXTERNAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkInterface_Ipv6AccessType.UNRECOGNIZED;
  }
}

export function networkInterface_Ipv6AccessTypeToJSON(object: NetworkInterface_Ipv6AccessType): string {
  switch (object) {
    case NetworkInterface_Ipv6AccessType.UNSPECIFIED_IPV6_ACCESS_TYPE:
      return "UNSPECIFIED_IPV6_ACCESS_TYPE";
    case NetworkInterface_Ipv6AccessType.INTERNAL:
      return "INTERNAL";
    case NetworkInterface_Ipv6AccessType.EXTERNAL:
      return "EXTERNAL";
    case NetworkInterface_Ipv6AccessType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Nic type for this network interface. */
export enum NetworkInterface_NicType {
  /** NIC_TYPE_UNSPECIFIED - Default should be NIC_TYPE_UNSPECIFIED. */
  NIC_TYPE_UNSPECIFIED = 0,
  /** VIRTIO_NET - VIRTIO */
  VIRTIO_NET = 1,
  /** GVNIC - GVNIC */
  GVNIC = 2,
  UNRECOGNIZED = -1,
}

export function networkInterface_NicTypeFromJSON(object: any): NetworkInterface_NicType {
  switch (object) {
    case 0:
    case "NIC_TYPE_UNSPECIFIED":
      return NetworkInterface_NicType.NIC_TYPE_UNSPECIFIED;
    case 1:
    case "VIRTIO_NET":
      return NetworkInterface_NicType.VIRTIO_NET;
    case 2:
    case "GVNIC":
      return NetworkInterface_NicType.GVNIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkInterface_NicType.UNRECOGNIZED;
  }
}

export function networkInterface_NicTypeToJSON(object: NetworkInterface_NicType): string {
  switch (object) {
    case NetworkInterface_NicType.NIC_TYPE_UNSPECIFIED:
      return "NIC_TYPE_UNSPECIFIED";
    case NetworkInterface_NicType.VIRTIO_NET:
      return "VIRTIO_NET";
    case NetworkInterface_NicType.GVNIC:
      return "GVNIC";
    case NetworkInterface_NicType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Network performance configuration. */
export interface NetworkPerformanceConfig {
  /** Optional. The tier of the total egress bandwidth. */
  totalEgressBandwidthTier?: NetworkPerformanceConfig_Tier | undefined;
}

/** Network performance tier. */
export enum NetworkPerformanceConfig_Tier {
  /** TIER_UNSPECIFIED - This value is unused. */
  TIER_UNSPECIFIED = 0,
  /** DEFAULT - Default network performance config. */
  DEFAULT = 1,
  /** TIER_1 - Tier 1 network performance config. */
  TIER_1 = 2,
  UNRECOGNIZED = -1,
}

export function networkPerformanceConfig_TierFromJSON(object: any): NetworkPerformanceConfig_Tier {
  switch (object) {
    case 0:
    case "TIER_UNSPECIFIED":
      return NetworkPerformanceConfig_Tier.TIER_UNSPECIFIED;
    case 1:
    case "DEFAULT":
      return NetworkPerformanceConfig_Tier.DEFAULT;
    case 2:
    case "TIER_1":
      return NetworkPerformanceConfig_Tier.TIER_1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NetworkPerformanceConfig_Tier.UNRECOGNIZED;
  }
}

export function networkPerformanceConfig_TierToJSON(object: NetworkPerformanceConfig_Tier): string {
  switch (object) {
    case NetworkPerformanceConfig_Tier.TIER_UNSPECIFIED:
      return "TIER_UNSPECIFIED";
    case NetworkPerformanceConfig_Tier.DEFAULT:
      return "DEFAULT";
    case NetworkPerformanceConfig_Tier.TIER_1:
      return "TIER_1";
    case NetworkPerformanceConfig_Tier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * An access configuration attached to an instance's network interface.
 * Only one access config per instance is supported.
 */
export interface AccessConfig {
  /**
   * Optional. In accessConfigs (IPv4), the
   *  default and only option is ONE_TO_ONE_NAT. In
   *  ipv6AccessConfigs, the default and only option is
   *  DIRECT_IPV6.
   */
  type?:
    | AccessConfig_AccessType
    | undefined;
  /** Optional. The name of this access configuration. */
  name?:
    | string
    | undefined;
  /** Optional. The external IP address of this access configuration. */
  externalIp?:
    | string
    | undefined;
  /** Optional. The external IPv6 address of this access configuration. */
  externalIpv6?:
    | string
    | undefined;
  /** Optional. The prefix length of the external IPv6 range. */
  externalIpv6PrefixLength?:
    | number
    | undefined;
  /**
   * Optional. Specifies whether a public DNS 'PTR' record should be created to
   * map the external IP address of the instance to a DNS domain name.
   */
  setPublicPtr?:
    | boolean
    | undefined;
  /** Optional. The DNS domain name for the public PTR record. */
  publicPtrDomainName?:
    | string
    | undefined;
  /**
   * Optional. This signifies the networking tier used for configuring this
   * access
   */
  networkTier?: AccessConfig_NetworkTier | undefined;
}

/** The type of configuration. */
export enum AccessConfig_AccessType {
  /** ACCESS_TYPE_UNSPECIFIED - Default value. This value is unused. */
  ACCESS_TYPE_UNSPECIFIED = 0,
  /** ONE_TO_ONE_NAT - ONE_TO_ONE_NAT */
  ONE_TO_ONE_NAT = 1,
  /** DIRECT_IPV6 - Direct IPv6 access. */
  DIRECT_IPV6 = 2,
  UNRECOGNIZED = -1,
}

export function accessConfig_AccessTypeFromJSON(object: any): AccessConfig_AccessType {
  switch (object) {
    case 0:
    case "ACCESS_TYPE_UNSPECIFIED":
      return AccessConfig_AccessType.ACCESS_TYPE_UNSPECIFIED;
    case 1:
    case "ONE_TO_ONE_NAT":
      return AccessConfig_AccessType.ONE_TO_ONE_NAT;
    case 2:
    case "DIRECT_IPV6":
      return AccessConfig_AccessType.DIRECT_IPV6;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessConfig_AccessType.UNRECOGNIZED;
  }
}

export function accessConfig_AccessTypeToJSON(object: AccessConfig_AccessType): string {
  switch (object) {
    case AccessConfig_AccessType.ACCESS_TYPE_UNSPECIFIED:
      return "ACCESS_TYPE_UNSPECIFIED";
    case AccessConfig_AccessType.ONE_TO_ONE_NAT:
      return "ONE_TO_ONE_NAT";
    case AccessConfig_AccessType.DIRECT_IPV6:
      return "DIRECT_IPV6";
    case AccessConfig_AccessType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Network tier property used by addresses, instances and forwarding rules. */
export enum AccessConfig_NetworkTier {
  /** NETWORK_TIER_UNSPECIFIED - Default value. This value is unused. */
  NETWORK_TIER_UNSPECIFIED = 0,
  /**
   * PREMIUM - High quality, Google-grade network tier, support for all networking
   * products.
   */
  PREMIUM = 1,
  /**
   * STANDARD - Public internet quality, only limited support for other networking
   * products.
   */
  STANDARD = 2,
  UNRECOGNIZED = -1,
}

export function accessConfig_NetworkTierFromJSON(object: any): AccessConfig_NetworkTier {
  switch (object) {
    case 0:
    case "NETWORK_TIER_UNSPECIFIED":
      return AccessConfig_NetworkTier.NETWORK_TIER_UNSPECIFIED;
    case 1:
    case "PREMIUM":
      return AccessConfig_NetworkTier.PREMIUM;
    case 2:
    case "STANDARD":
      return AccessConfig_NetworkTier.STANDARD;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccessConfig_NetworkTier.UNRECOGNIZED;
  }
}

export function accessConfig_NetworkTierToJSON(object: AccessConfig_NetworkTier): string {
  switch (object) {
    case AccessConfig_NetworkTier.NETWORK_TIER_UNSPECIFIED:
      return "NETWORK_TIER_UNSPECIFIED";
    case AccessConfig_NetworkTier.PREMIUM:
      return "PREMIUM";
    case AccessConfig_NetworkTier.STANDARD:
      return "STANDARD";
    case AccessConfig_NetworkTier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An alias IP range attached to an instance's network interface. */
export interface AliasIpRange {
  /** Optional. The IP alias ranges to allocate for this interface. */
  ipCidrRange?:
    | string
    | undefined;
  /**
   * Optional. The name of a subnetwork secondary IP range from which to
   * allocate an IP alias range. If not specified, the primary range of the
   * subnetwork is used.
   */
  subnetworkRangeName?: string | undefined;
}

/** Additional instance params. */
export interface InstanceParams {
  /** Optional. Resource manager tags to be bound to the instance. */
  resourceManagerTags: { [key: string]: string };
}

export interface InstanceParams_ResourceManagerTagsEntry {
  key: string;
  value: string;
}

/** Specifies the reservations that this instance can consume from. */
export interface AllocationAffinity {
  /**
   * Optional. Specifies the type of reservation from which this instance can
   * consume
   */
  consumeAllocationType?:
    | AllocationAffinity_Type
    | undefined;
  /** Optional. Corresponds to the label key of a reservation resource. */
  key?:
    | string
    | undefined;
  /** Optional. Corresponds to the label values of a reservation resource. */
  values: string[];
}

/** Indicates whether to consume from a reservation or not. */
export enum AllocationAffinity_Type {
  /** TYPE_UNSPECIFIED - Default value. This value is unused. */
  TYPE_UNSPECIFIED = 0,
  /** NO_RESERVATION - Do not consume from any allocated capacity. */
  NO_RESERVATION = 1,
  /** ANY_RESERVATION - Consume any allocation available. */
  ANY_RESERVATION = 2,
  /**
   * SPECIFIC_RESERVATION - Must consume from a specific reservation. Must specify key value fields
   * for specifying the reservations.
   */
  SPECIFIC_RESERVATION = 3,
  UNRECOGNIZED = -1,
}

export function allocationAffinity_TypeFromJSON(object: any): AllocationAffinity_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return AllocationAffinity_Type.TYPE_UNSPECIFIED;
    case 1:
    case "NO_RESERVATION":
      return AllocationAffinity_Type.NO_RESERVATION;
    case 2:
    case "ANY_RESERVATION":
      return AllocationAffinity_Type.ANY_RESERVATION;
    case 3:
    case "SPECIFIC_RESERVATION":
      return AllocationAffinity_Type.SPECIFIC_RESERVATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AllocationAffinity_Type.UNRECOGNIZED;
  }
}

export function allocationAffinity_TypeToJSON(object: AllocationAffinity_Type): string {
  switch (object) {
    case AllocationAffinity_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case AllocationAffinity_Type.NO_RESERVATION:
      return "NO_RESERVATION";
    case AllocationAffinity_Type.ANY_RESERVATION:
      return "ANY_RESERVATION";
    case AllocationAffinity_Type.SPECIFIC_RESERVATION:
      return "SPECIFIC_RESERVATION";
    case AllocationAffinity_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Sets the scheduling options for an Instance. */
export interface Scheduling {
  /** Optional. Defines the maintenance behavior for this instance. */
  onHostMaintenance?:
    | Scheduling_OnHostMaintenance
    | undefined;
  /**
   * Optional. Specifies whether the instance should be automatically restarted
   * if it is terminated by Compute Engine (not terminated by a user).
   */
  automaticRestart?:
    | boolean
    | undefined;
  /** Optional. Defines whether the instance is preemptible. */
  preemptible?:
    | boolean
    | undefined;
  /**
   * Optional. A set of node affinity and anti-affinity configurations.
   * Overrides reservationAffinity.
   */
  nodeAffinities: Scheduling_NodeAffinity[];
  /**
   * Optional. The minimum number of virtual CPUs this instance will consume
   * when running on a sole-tenant node.
   */
  minNodeCpus?:
    | number
    | undefined;
  /** Optional. Specifies the provisioning model of the instance. */
  provisioningModel?:
    | Scheduling_ProvisioningModel
    | undefined;
  /** Optional. Specifies the termination action for the instance. */
  instanceTerminationAction?:
    | Scheduling_InstanceTerminationAction
    | undefined;
  /**
   * Optional. Specifies the maximum amount of time a Local Ssd Vm should wait
   * while recovery of the Local Ssd state is attempted. Its value should be in
   * between 0 and 168 hours with hour granularity and the default value being 1
   * hour.
   */
  localSsdRecoveryTimeout?: SchedulingDuration | undefined;
}

/** Defines the maintenance behavior for this instance= */
export enum Scheduling_OnHostMaintenance {
  /** ON_HOST_MAINTENANCE_UNSPECIFIED - Default value. This value is unused. */
  ON_HOST_MAINTENANCE_UNSPECIFIED = 0,
  /**
   * TERMINATE - Tells Compute Engine to terminate and (optionally) restart the instance
   * away from the maintenance activity.
   */
  TERMINATE = 1,
  /**
   * MIGRATE - Default, Allows Compute Engine to automatically migrate instances
   * out of the way of maintenance events.
   */
  MIGRATE = 1000,
  UNRECOGNIZED = -1,
}

export function scheduling_OnHostMaintenanceFromJSON(object: any): Scheduling_OnHostMaintenance {
  switch (object) {
    case 0:
    case "ON_HOST_MAINTENANCE_UNSPECIFIED":
      return Scheduling_OnHostMaintenance.ON_HOST_MAINTENANCE_UNSPECIFIED;
    case 1:
    case "TERMINATE":
      return Scheduling_OnHostMaintenance.TERMINATE;
    case 1000:
    case "MIGRATE":
      return Scheduling_OnHostMaintenance.MIGRATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Scheduling_OnHostMaintenance.UNRECOGNIZED;
  }
}

export function scheduling_OnHostMaintenanceToJSON(object: Scheduling_OnHostMaintenance): string {
  switch (object) {
    case Scheduling_OnHostMaintenance.ON_HOST_MAINTENANCE_UNSPECIFIED:
      return "ON_HOST_MAINTENANCE_UNSPECIFIED";
    case Scheduling_OnHostMaintenance.TERMINATE:
      return "TERMINATE";
    case Scheduling_OnHostMaintenance.MIGRATE:
      return "MIGRATE";
    case Scheduling_OnHostMaintenance.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines the provisioning model for an instance. */
export enum Scheduling_ProvisioningModel {
  /** PROVISIONING_MODEL_UNSPECIFIED - Default value. This value is not used. */
  PROVISIONING_MODEL_UNSPECIFIED = 0,
  /** STANDARD - Standard provisioning with user controlled runtime, no discounts. */
  STANDARD = 1,
  /** SPOT - Heavily discounted, no guaranteed runtime. */
  SPOT = 2,
  UNRECOGNIZED = -1,
}

export function scheduling_ProvisioningModelFromJSON(object: any): Scheduling_ProvisioningModel {
  switch (object) {
    case 0:
    case "PROVISIONING_MODEL_UNSPECIFIED":
      return Scheduling_ProvisioningModel.PROVISIONING_MODEL_UNSPECIFIED;
    case 1:
    case "STANDARD":
      return Scheduling_ProvisioningModel.STANDARD;
    case 2:
    case "SPOT":
      return Scheduling_ProvisioningModel.SPOT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Scheduling_ProvisioningModel.UNRECOGNIZED;
  }
}

export function scheduling_ProvisioningModelToJSON(object: Scheduling_ProvisioningModel): string {
  switch (object) {
    case Scheduling_ProvisioningModel.PROVISIONING_MODEL_UNSPECIFIED:
      return "PROVISIONING_MODEL_UNSPECIFIED";
    case Scheduling_ProvisioningModel.STANDARD:
      return "STANDARD";
    case Scheduling_ProvisioningModel.SPOT:
      return "SPOT";
    case Scheduling_ProvisioningModel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Defines the supported termination actions for an instance. */
export enum Scheduling_InstanceTerminationAction {
  /** INSTANCE_TERMINATION_ACTION_UNSPECIFIED - Default value. This value is unused. */
  INSTANCE_TERMINATION_ACTION_UNSPECIFIED = 0,
  /** DELETE - Delete the VM. */
  DELETE = 1,
  /** STOP - Stop the VM without storing in-memory content. default action. */
  STOP = 2,
  UNRECOGNIZED = -1,
}

export function scheduling_InstanceTerminationActionFromJSON(object: any): Scheduling_InstanceTerminationAction {
  switch (object) {
    case 0:
    case "INSTANCE_TERMINATION_ACTION_UNSPECIFIED":
      return Scheduling_InstanceTerminationAction.INSTANCE_TERMINATION_ACTION_UNSPECIFIED;
    case 1:
    case "DELETE":
      return Scheduling_InstanceTerminationAction.DELETE;
    case 2:
    case "STOP":
      return Scheduling_InstanceTerminationAction.STOP;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Scheduling_InstanceTerminationAction.UNRECOGNIZED;
  }
}

export function scheduling_InstanceTerminationActionToJSON(object: Scheduling_InstanceTerminationAction): string {
  switch (object) {
    case Scheduling_InstanceTerminationAction.INSTANCE_TERMINATION_ACTION_UNSPECIFIED:
      return "INSTANCE_TERMINATION_ACTION_UNSPECIFIED";
    case Scheduling_InstanceTerminationAction.DELETE:
      return "DELETE";
    case Scheduling_InstanceTerminationAction.STOP:
      return "STOP";
    case Scheduling_InstanceTerminationAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Node Affinity: the configuration of desired nodes onto which this Instance
 * could be scheduled.
 */
export interface Scheduling_NodeAffinity {
  /** Optional. Corresponds to the label key of Node resource. */
  key?:
    | string
    | undefined;
  /** Optional. Defines the operation of node selection. */
  operator?:
    | Scheduling_NodeAffinity_Operator
    | undefined;
  /** Optional. Corresponds to the label values of Node resource. */
  values: string[];
}

/** Defines the type of node selections. */
export enum Scheduling_NodeAffinity_Operator {
  /** OPERATOR_UNSPECIFIED - Default value. This value is unused. */
  OPERATOR_UNSPECIFIED = 0,
  /** IN - Requires Compute Engine to seek for matched nodes. */
  IN = 1,
  /** NOT_IN - Requires Compute Engine to avoid certain nodes. */
  NOT_IN = 2,
  UNRECOGNIZED = -1,
}

export function scheduling_NodeAffinity_OperatorFromJSON(object: any): Scheduling_NodeAffinity_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return Scheduling_NodeAffinity_Operator.OPERATOR_UNSPECIFIED;
    case 1:
    case "IN":
      return Scheduling_NodeAffinity_Operator.IN;
    case 2:
    case "NOT_IN":
      return Scheduling_NodeAffinity_Operator.NOT_IN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Scheduling_NodeAffinity_Operator.UNRECOGNIZED;
  }
}

export function scheduling_NodeAffinity_OperatorToJSON(object: Scheduling_NodeAffinity_Operator): string {
  switch (object) {
    case Scheduling_NodeAffinity_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case Scheduling_NodeAffinity_Operator.IN:
      return "IN";
    case Scheduling_NodeAffinity_Operator.NOT_IN:
      return "NOT_IN";
    case Scheduling_NodeAffinity_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * A SchedulingDuration represents a fixed-length span of time represented
 * as a count of seconds and fractions of seconds at nanosecond
 * resolution. It is independent of any calendar and concepts like "day"
 * or "month". Range is approximately 10,000 years.
 */
export interface SchedulingDuration {
  /** Optional. Span of time at a resolution of a second. */
  seconds?:
    | Long
    | undefined;
  /**
   * Optional. Span of time that's a fraction of a second at nanosecond
   * resolution.
   */
  nanos?: number | undefined;
}

/** A service account. */
export interface ServiceAccount {
  /** Optional. Email address of the service account. */
  email?:
    | string
    | undefined;
  /** Optional. The list of scopes to be made available for this service account. */
  scopes: string[];
}

/** A set of instance tags. */
export interface Tags {
  /**
   * Optional. An array of tags. Each tag must be 1-63 characters long, and
   * comply with RFC1035.
   */
  items: string[];
}

/** An instance-attached disk resource. */
export interface AttachedDisk {
  /** Optional. Specifies the parameters to initialize this disk. */
  initializeParams?:
    | AttachedDisk_InitializeParams
    | undefined;
  /**
   * Optional. This is used as an identifier for the disks. This is the unique
   * name has to provided to modify disk parameters like disk_name and
   * replica_zones (in case of RePDs)
   */
  deviceName?:
    | string
    | undefined;
  /** Optional. Type of the resource. */
  kind?:
    | string
    | undefined;
  /**
   * Specifies the type of the disk.
   *
   * @deprecated
   */
  diskTypeDeprecated?:
    | AttachedDisk_DiskType
    | undefined;
  /** Optional. The mode in which to attach this disk. */
  mode?:
    | AttachedDisk_DiskMode
    | undefined;
  /**
   * Optional. Specifies a valid partial or full URL to an existing Persistent
   * Disk resource.
   */
  source?:
    | string
    | undefined;
  /**
   * Optional. A zero-based index to this disk, where 0 is reserved for the
   * boot disk.
   */
  index?:
    | Long
    | undefined;
  /**
   * Optional. Indicates that this is a boot disk. The virtual machine will use
   * the first partition of the disk for its root filesystem.
   */
  boot?:
    | boolean
    | undefined;
  /**
   * Optional. Specifies whether the disk will be auto-deleted when the instance
   * is deleted (but not when the disk is detached from the instance).
   */
  autoDelete?:
    | boolean
    | undefined;
  /** Optional. Any valid publicly visible licenses. */
  license: string[];
  /** Optional. Specifies the disk interface to use for attaching this disk. */
  diskInterface?:
    | AttachedDisk_DiskInterface
    | undefined;
  /**
   * Optional. A list of features to enable on the guest operating system.
   * Applicable only for bootable images.
   */
  guestOsFeature: GuestOsFeature[];
  /**
   * Optional. Encrypts or decrypts a disk using a customer-supplied
   * encryption key.
   */
  diskEncryptionKey?:
    | CustomerEncryptionKey
    | undefined;
  /** Optional. The size of the disk in GB. */
  diskSizeGb?:
    | Long
    | undefined;
  /** Optional. Output only. The state of the disk. */
  savedState?:
    | AttachedDisk_DiskSavedState
    | undefined;
  /**
   * Optional. Output only. The URI of the disk type resource. For example:
   * projects/project/zones/zone/diskTypes/pd-standard or pd-ssd
   */
  diskType?:
    | string
    | undefined;
  /** Optional. Specifies the type of the disk. */
  type?: AttachedDisk_DiskType | undefined;
}

/** List of the Disk Types. */
export enum AttachedDisk_DiskType {
  /** DISK_TYPE_UNSPECIFIED - Default value, which is unused. */
  DISK_TYPE_UNSPECIFIED = 0,
  /** SCRATCH - A scratch disk type. */
  SCRATCH = 1,
  /** PERSISTENT - A persistent disk type. */
  PERSISTENT = 2,
  UNRECOGNIZED = -1,
}

export function attachedDisk_DiskTypeFromJSON(object: any): AttachedDisk_DiskType {
  switch (object) {
    case 0:
    case "DISK_TYPE_UNSPECIFIED":
      return AttachedDisk_DiskType.DISK_TYPE_UNSPECIFIED;
    case 1:
    case "SCRATCH":
      return AttachedDisk_DiskType.SCRATCH;
    case 2:
    case "PERSISTENT":
      return AttachedDisk_DiskType.PERSISTENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttachedDisk_DiskType.UNRECOGNIZED;
  }
}

export function attachedDisk_DiskTypeToJSON(object: AttachedDisk_DiskType): string {
  switch (object) {
    case AttachedDisk_DiskType.DISK_TYPE_UNSPECIFIED:
      return "DISK_TYPE_UNSPECIFIED";
    case AttachedDisk_DiskType.SCRATCH:
      return "SCRATCH";
    case AttachedDisk_DiskType.PERSISTENT:
      return "PERSISTENT";
    case AttachedDisk_DiskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** List of the Disk Modes. */
export enum AttachedDisk_DiskMode {
  /** DISK_MODE_UNSPECIFIED - Default value, which is unused. */
  DISK_MODE_UNSPECIFIED = 0,
  /**
   * READ_WRITE - Attaches this disk in read-write mode. Only one
   * virtual machine at a time can be attached to a disk in read-write mode.
   */
  READ_WRITE = 1,
  /**
   * READ_ONLY - Attaches this disk in read-only mode. Multiple virtual machines can use
   * a disk in read-only mode at a time.
   */
  READ_ONLY = 2,
  /**
   * LOCKED - The disk is locked for administrative reasons. Nobody else
   * can use the disk. This mode is used (for example) when taking
   * a snapshot of a disk to prevent mounting the disk while it is
   * being snapshotted.
   */
  LOCKED = 3,
  UNRECOGNIZED = -1,
}

export function attachedDisk_DiskModeFromJSON(object: any): AttachedDisk_DiskMode {
  switch (object) {
    case 0:
    case "DISK_MODE_UNSPECIFIED":
      return AttachedDisk_DiskMode.DISK_MODE_UNSPECIFIED;
    case 1:
    case "READ_WRITE":
      return AttachedDisk_DiskMode.READ_WRITE;
    case 2:
    case "READ_ONLY":
      return AttachedDisk_DiskMode.READ_ONLY;
    case 3:
    case "LOCKED":
      return AttachedDisk_DiskMode.LOCKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttachedDisk_DiskMode.UNRECOGNIZED;
  }
}

export function attachedDisk_DiskModeToJSON(object: AttachedDisk_DiskMode): string {
  switch (object) {
    case AttachedDisk_DiskMode.DISK_MODE_UNSPECIFIED:
      return "DISK_MODE_UNSPECIFIED";
    case AttachedDisk_DiskMode.READ_WRITE:
      return "READ_WRITE";
    case AttachedDisk_DiskMode.READ_ONLY:
      return "READ_ONLY";
    case AttachedDisk_DiskMode.LOCKED:
      return "LOCKED";
    case AttachedDisk_DiskMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** List of the Disk Interfaces. */
export enum AttachedDisk_DiskInterface {
  /** DISK_INTERFACE_UNSPECIFIED - Default value, which is unused. */
  DISK_INTERFACE_UNSPECIFIED = 0,
  /** SCSI - SCSI Disk Interface. */
  SCSI = 1,
  /** NVME - NVME Disk Interface. */
  NVME = 2,
  /** NVDIMM - NVDIMM Disk Interface. */
  NVDIMM = 3,
  /** ISCSI - ISCSI Disk Interface. */
  ISCSI = 4,
  UNRECOGNIZED = -1,
}

export function attachedDisk_DiskInterfaceFromJSON(object: any): AttachedDisk_DiskInterface {
  switch (object) {
    case 0:
    case "DISK_INTERFACE_UNSPECIFIED":
      return AttachedDisk_DiskInterface.DISK_INTERFACE_UNSPECIFIED;
    case 1:
    case "SCSI":
      return AttachedDisk_DiskInterface.SCSI;
    case 2:
    case "NVME":
      return AttachedDisk_DiskInterface.NVME;
    case 3:
    case "NVDIMM":
      return AttachedDisk_DiskInterface.NVDIMM;
    case 4:
    case "ISCSI":
      return AttachedDisk_DiskInterface.ISCSI;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttachedDisk_DiskInterface.UNRECOGNIZED;
  }
}

export function attachedDisk_DiskInterfaceToJSON(object: AttachedDisk_DiskInterface): string {
  switch (object) {
    case AttachedDisk_DiskInterface.DISK_INTERFACE_UNSPECIFIED:
      return "DISK_INTERFACE_UNSPECIFIED";
    case AttachedDisk_DiskInterface.SCSI:
      return "SCSI";
    case AttachedDisk_DiskInterface.NVME:
      return "NVME";
    case AttachedDisk_DiskInterface.NVDIMM:
      return "NVDIMM";
    case AttachedDisk_DiskInterface.ISCSI:
      return "ISCSI";
    case AttachedDisk_DiskInterface.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** List of the states of the Disk. */
export enum AttachedDisk_DiskSavedState {
  /** DISK_SAVED_STATE_UNSPECIFIED - Default Disk state has not been preserved. */
  DISK_SAVED_STATE_UNSPECIFIED = 0,
  /** PRESERVED - Disk state has been preserved. */
  PRESERVED = 1,
  UNRECOGNIZED = -1,
}

export function attachedDisk_DiskSavedStateFromJSON(object: any): AttachedDisk_DiskSavedState {
  switch (object) {
    case 0:
    case "DISK_SAVED_STATE_UNSPECIFIED":
      return AttachedDisk_DiskSavedState.DISK_SAVED_STATE_UNSPECIFIED;
    case 1:
    case "PRESERVED":
      return AttachedDisk_DiskSavedState.PRESERVED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttachedDisk_DiskSavedState.UNRECOGNIZED;
  }
}

export function attachedDisk_DiskSavedStateToJSON(object: AttachedDisk_DiskSavedState): string {
  switch (object) {
    case AttachedDisk_DiskSavedState.DISK_SAVED_STATE_UNSPECIFIED:
      return "DISK_SAVED_STATE_UNSPECIFIED";
    case AttachedDisk_DiskSavedState.PRESERVED:
      return "PRESERVED";
    case AttachedDisk_DiskSavedState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies the parameters to initialize this disk. */
export interface AttachedDisk_InitializeParams {
  /**
   * Optional. Specifies the disk name. If not specified, the default is to
   * use the name of the instance.
   */
  diskName?:
    | string
    | undefined;
  /**
   * Optional. URL of the zone where the disk should be created.
   * Required for each regional disk associated with the instance.
   */
  replicaZones: string[];
}

/** Feature type of the Guest OS. */
export interface GuestOsFeature {
  /** The ID of a supported feature. */
  type?: GuestOsFeature_FeatureType | undefined;
}

/** List of the Feature Types. */
export enum GuestOsFeature_FeatureType {
  /** FEATURE_TYPE_UNSPECIFIED - Default value, which is unused. */
  FEATURE_TYPE_UNSPECIFIED = 0,
  /** VIRTIO_SCSI_MULTIQUEUE - VIRTIO_SCSI_MULTIQUEUE feature type. */
  VIRTIO_SCSI_MULTIQUEUE = 1,
  /** WINDOWS - WINDOWS feature type. */
  WINDOWS = 2,
  /** MULTI_IP_SUBNET - MULTI_IP_SUBNET feature type. */
  MULTI_IP_SUBNET = 3,
  /** UEFI_COMPATIBLE - UEFI_COMPATIBLE feature type. */
  UEFI_COMPATIBLE = 4,
  /** SECURE_BOOT - SECURE_BOOT feature type. */
  SECURE_BOOT = 5,
  /** GVNIC - GVNIC feature type. */
  GVNIC = 6,
  /** SEV_CAPABLE - SEV_CAPABLE feature type. */
  SEV_CAPABLE = 7,
  /** BARE_METAL_LINUX_COMPATIBLE - BARE_METAL_LINUX_COMPATIBLE feature type. */
  BARE_METAL_LINUX_COMPATIBLE = 8,
  /** SUSPEND_RESUME_COMPATIBLE - SUSPEND_RESUME_COMPATIBLE feature type. */
  SUSPEND_RESUME_COMPATIBLE = 9,
  /** SEV_LIVE_MIGRATABLE - SEV_LIVE_MIGRATABLE feature type. */
  SEV_LIVE_MIGRATABLE = 10,
  /** SEV_SNP_CAPABLE - SEV_SNP_CAPABLE feature type. */
  SEV_SNP_CAPABLE = 11,
  /** TDX_CAPABLE - TDX_CAPABLE feature type. */
  TDX_CAPABLE = 12,
  /** IDPF - IDPF feature type. */
  IDPF = 13,
  /** SEV_LIVE_MIGRATABLE_V2 - SEV_LIVE_MIGRATABLE_V2 feature type. */
  SEV_LIVE_MIGRATABLE_V2 = 14,
  UNRECOGNIZED = -1,
}

export function guestOsFeature_FeatureTypeFromJSON(object: any): GuestOsFeature_FeatureType {
  switch (object) {
    case 0:
    case "FEATURE_TYPE_UNSPECIFIED":
      return GuestOsFeature_FeatureType.FEATURE_TYPE_UNSPECIFIED;
    case 1:
    case "VIRTIO_SCSI_MULTIQUEUE":
      return GuestOsFeature_FeatureType.VIRTIO_SCSI_MULTIQUEUE;
    case 2:
    case "WINDOWS":
      return GuestOsFeature_FeatureType.WINDOWS;
    case 3:
    case "MULTI_IP_SUBNET":
      return GuestOsFeature_FeatureType.MULTI_IP_SUBNET;
    case 4:
    case "UEFI_COMPATIBLE":
      return GuestOsFeature_FeatureType.UEFI_COMPATIBLE;
    case 5:
    case "SECURE_BOOT":
      return GuestOsFeature_FeatureType.SECURE_BOOT;
    case 6:
    case "GVNIC":
      return GuestOsFeature_FeatureType.GVNIC;
    case 7:
    case "SEV_CAPABLE":
      return GuestOsFeature_FeatureType.SEV_CAPABLE;
    case 8:
    case "BARE_METAL_LINUX_COMPATIBLE":
      return GuestOsFeature_FeatureType.BARE_METAL_LINUX_COMPATIBLE;
    case 9:
    case "SUSPEND_RESUME_COMPATIBLE":
      return GuestOsFeature_FeatureType.SUSPEND_RESUME_COMPATIBLE;
    case 10:
    case "SEV_LIVE_MIGRATABLE":
      return GuestOsFeature_FeatureType.SEV_LIVE_MIGRATABLE;
    case 11:
    case "SEV_SNP_CAPABLE":
      return GuestOsFeature_FeatureType.SEV_SNP_CAPABLE;
    case 12:
    case "TDX_CAPABLE":
      return GuestOsFeature_FeatureType.TDX_CAPABLE;
    case 13:
    case "IDPF":
      return GuestOsFeature_FeatureType.IDPF;
    case 14:
    case "SEV_LIVE_MIGRATABLE_V2":
      return GuestOsFeature_FeatureType.SEV_LIVE_MIGRATABLE_V2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GuestOsFeature_FeatureType.UNRECOGNIZED;
  }
}

export function guestOsFeature_FeatureTypeToJSON(object: GuestOsFeature_FeatureType): string {
  switch (object) {
    case GuestOsFeature_FeatureType.FEATURE_TYPE_UNSPECIFIED:
      return "FEATURE_TYPE_UNSPECIFIED";
    case GuestOsFeature_FeatureType.VIRTIO_SCSI_MULTIQUEUE:
      return "VIRTIO_SCSI_MULTIQUEUE";
    case GuestOsFeature_FeatureType.WINDOWS:
      return "WINDOWS";
    case GuestOsFeature_FeatureType.MULTI_IP_SUBNET:
      return "MULTI_IP_SUBNET";
    case GuestOsFeature_FeatureType.UEFI_COMPATIBLE:
      return "UEFI_COMPATIBLE";
    case GuestOsFeature_FeatureType.SECURE_BOOT:
      return "SECURE_BOOT";
    case GuestOsFeature_FeatureType.GVNIC:
      return "GVNIC";
    case GuestOsFeature_FeatureType.SEV_CAPABLE:
      return "SEV_CAPABLE";
    case GuestOsFeature_FeatureType.BARE_METAL_LINUX_COMPATIBLE:
      return "BARE_METAL_LINUX_COMPATIBLE";
    case GuestOsFeature_FeatureType.SUSPEND_RESUME_COMPATIBLE:
      return "SUSPEND_RESUME_COMPATIBLE";
    case GuestOsFeature_FeatureType.SEV_LIVE_MIGRATABLE:
      return "SEV_LIVE_MIGRATABLE";
    case GuestOsFeature_FeatureType.SEV_SNP_CAPABLE:
      return "SEV_SNP_CAPABLE";
    case GuestOsFeature_FeatureType.TDX_CAPABLE:
      return "TDX_CAPABLE";
    case GuestOsFeature_FeatureType.IDPF:
      return "IDPF";
    case GuestOsFeature_FeatureType.SEV_LIVE_MIGRATABLE_V2:
      return "SEV_LIVE_MIGRATABLE_V2";
    case GuestOsFeature_FeatureType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseComputeInstanceBackupProperties(): ComputeInstanceBackupProperties {
  return {
    description: undefined,
    tags: undefined,
    machineType: undefined,
    canIpForward: undefined,
    networkInterface: [],
    disk: [],
    metadata: undefined,
    serviceAccount: [],
    scheduling: undefined,
    guestAccelerator: [],
    minCpuPlatform: undefined,
    keyRevocationActionType: undefined,
    sourceInstance: undefined,
    labels: {},
  };
}

export const ComputeInstanceBackupProperties: MessageFns<ComputeInstanceBackupProperties> = {
  encode(message: ComputeInstanceBackupProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== undefined) {
      writer.uint32(10).string(message.description);
    }
    if (message.tags !== undefined) {
      Tags.encode(message.tags, writer.uint32(18).fork()).join();
    }
    if (message.machineType !== undefined) {
      writer.uint32(26).string(message.machineType);
    }
    if (message.canIpForward !== undefined) {
      writer.uint32(32).bool(message.canIpForward);
    }
    for (const v of message.networkInterface) {
      NetworkInterface.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.disk) {
      AttachedDisk.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(58).fork()).join();
    }
    for (const v of message.serviceAccount) {
      ServiceAccount.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.scheduling !== undefined) {
      Scheduling.encode(message.scheduling, writer.uint32(74).fork()).join();
    }
    for (const v of message.guestAccelerator) {
      AcceleratorConfig.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.minCpuPlatform !== undefined) {
      writer.uint32(90).string(message.minCpuPlatform);
    }
    if (message.keyRevocationActionType !== undefined) {
      writer.uint32(96).int32(message.keyRevocationActionType);
    }
    if (message.sourceInstance !== undefined) {
      writer.uint32(106).string(message.sourceInstance);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ComputeInstanceBackupProperties_LabelsEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeInstanceBackupProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeInstanceBackupProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tags = Tags.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.canIpForward = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.networkInterface.push(NetworkInterface.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.disk.push(AttachedDisk.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.serviceAccount.push(ServiceAccount.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.scheduling = Scheduling.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.guestAccelerator.push(AcceleratorConfig.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.minCpuPlatform = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.keyRevocationActionType = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.sourceInstance = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          const entry14 = ComputeInstanceBackupProperties_LabelsEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.labels[entry14.key] = entry14.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeInstanceBackupProperties {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      tags: isSet(object.tags) ? Tags.fromJSON(object.tags) : undefined,
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : undefined,
      canIpForward: isSet(object.canIpForward) ? globalThis.Boolean(object.canIpForward) : undefined,
      networkInterface: globalThis.Array.isArray(object?.networkInterface)
        ? object.networkInterface.map((e: any) => NetworkInterface.fromJSON(e))
        : [],
      disk: globalThis.Array.isArray(object?.disk) ? object.disk.map((e: any) => AttachedDisk.fromJSON(e)) : [],
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      serviceAccount: globalThis.Array.isArray(object?.serviceAccount)
        ? object.serviceAccount.map((e: any) => ServiceAccount.fromJSON(e))
        : [],
      scheduling: isSet(object.scheduling) ? Scheduling.fromJSON(object.scheduling) : undefined,
      guestAccelerator: globalThis.Array.isArray(object?.guestAccelerator)
        ? object.guestAccelerator.map((e: any) => AcceleratorConfig.fromJSON(e))
        : [],
      minCpuPlatform: isSet(object.minCpuPlatform) ? globalThis.String(object.minCpuPlatform) : undefined,
      keyRevocationActionType: isSet(object.keyRevocationActionType)
        ? keyRevocationActionTypeFromJSON(object.keyRevocationActionType)
        : undefined,
      sourceInstance: isSet(object.sourceInstance) ? globalThis.String(object.sourceInstance) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ComputeInstanceBackupProperties): unknown {
    const obj: any = {};
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.tags !== undefined) {
      obj.tags = Tags.toJSON(message.tags);
    }
    if (message.machineType !== undefined) {
      obj.machineType = message.machineType;
    }
    if (message.canIpForward !== undefined) {
      obj.canIpForward = message.canIpForward;
    }
    if (message.networkInterface?.length) {
      obj.networkInterface = message.networkInterface.map((e) => NetworkInterface.toJSON(e));
    }
    if (message.disk?.length) {
      obj.disk = message.disk.map((e) => AttachedDisk.toJSON(e));
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.serviceAccount?.length) {
      obj.serviceAccount = message.serviceAccount.map((e) => ServiceAccount.toJSON(e));
    }
    if (message.scheduling !== undefined) {
      obj.scheduling = Scheduling.toJSON(message.scheduling);
    }
    if (message.guestAccelerator?.length) {
      obj.guestAccelerator = message.guestAccelerator.map((e) => AcceleratorConfig.toJSON(e));
    }
    if (message.minCpuPlatform !== undefined) {
      obj.minCpuPlatform = message.minCpuPlatform;
    }
    if (message.keyRevocationActionType !== undefined) {
      obj.keyRevocationActionType = keyRevocationActionTypeToJSON(message.keyRevocationActionType);
    }
    if (message.sourceInstance !== undefined) {
      obj.sourceInstance = message.sourceInstance;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeInstanceBackupProperties>): ComputeInstanceBackupProperties {
    return ComputeInstanceBackupProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeInstanceBackupProperties>): ComputeInstanceBackupProperties {
    const message = createBaseComputeInstanceBackupProperties();
    message.description = object.description ?? undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? Tags.fromPartial(object.tags) : undefined;
    message.machineType = object.machineType ?? undefined;
    message.canIpForward = object.canIpForward ?? undefined;
    message.networkInterface = object.networkInterface?.map((e) => NetworkInterface.fromPartial(e)) || [];
    message.disk = object.disk?.map((e) => AttachedDisk.fromPartial(e)) || [];
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.serviceAccount = object.serviceAccount?.map((e) => ServiceAccount.fromPartial(e)) || [];
    message.scheduling = (object.scheduling !== undefined && object.scheduling !== null)
      ? Scheduling.fromPartial(object.scheduling)
      : undefined;
    message.guestAccelerator = object.guestAccelerator?.map((e) => AcceleratorConfig.fromPartial(e)) || [];
    message.minCpuPlatform = object.minCpuPlatform ?? undefined;
    message.keyRevocationActionType = object.keyRevocationActionType ?? undefined;
    message.sourceInstance = object.sourceInstance ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseComputeInstanceBackupProperties_LabelsEntry(): ComputeInstanceBackupProperties_LabelsEntry {
  return { key: "", value: "" };
}

export const ComputeInstanceBackupProperties_LabelsEntry: MessageFns<ComputeInstanceBackupProperties_LabelsEntry> = {
  encode(
    message: ComputeInstanceBackupProperties_LabelsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeInstanceBackupProperties_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeInstanceBackupProperties_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeInstanceBackupProperties_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ComputeInstanceBackupProperties_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeInstanceBackupProperties_LabelsEntry>): ComputeInstanceBackupProperties_LabelsEntry {
    return ComputeInstanceBackupProperties_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ComputeInstanceBackupProperties_LabelsEntry>,
  ): ComputeInstanceBackupProperties_LabelsEntry {
    const message = createBaseComputeInstanceBackupProperties_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseComputeInstanceRestoreProperties(): ComputeInstanceRestoreProperties {
  return {
    name: undefined,
    advancedMachineFeatures: undefined,
    canIpForward: undefined,
    confidentialInstanceConfig: undefined,
    deletionProtection: undefined,
    description: undefined,
    disks: [],
    displayDevice: undefined,
    guestAccelerators: [],
    hostname: undefined,
    instanceEncryptionKey: undefined,
    keyRevocationActionType: undefined,
    labels: {},
    machineType: undefined,
    metadata: undefined,
    minCpuPlatform: undefined,
    networkInterfaces: [],
    networkPerformanceConfig: undefined,
    params: undefined,
    privateIpv6GoogleAccess: undefined,
    allocationAffinity: undefined,
    resourcePolicies: [],
    scheduling: undefined,
    serviceAccounts: [],
    tags: undefined,
  };
}

export const ComputeInstanceRestoreProperties: MessageFns<ComputeInstanceRestoreProperties> = {
  encode(message: ComputeInstanceRestoreProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.advancedMachineFeatures !== undefined) {
      AdvancedMachineFeatures.encode(message.advancedMachineFeatures, writer.uint32(18).fork()).join();
    }
    if (message.canIpForward !== undefined) {
      writer.uint32(24).bool(message.canIpForward);
    }
    if (message.confidentialInstanceConfig !== undefined) {
      ConfidentialInstanceConfig.encode(message.confidentialInstanceConfig, writer.uint32(34).fork()).join();
    }
    if (message.deletionProtection !== undefined) {
      writer.uint32(40).bool(message.deletionProtection);
    }
    if (message.description !== undefined) {
      writer.uint32(50).string(message.description);
    }
    for (const v of message.disks) {
      AttachedDisk.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.displayDevice !== undefined) {
      DisplayDevice.encode(message.displayDevice, writer.uint32(66).fork()).join();
    }
    for (const v of message.guestAccelerators) {
      AcceleratorConfig.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.hostname !== undefined) {
      writer.uint32(82).string(message.hostname);
    }
    if (message.instanceEncryptionKey !== undefined) {
      CustomerEncryptionKey.encode(message.instanceEncryptionKey, writer.uint32(90).fork()).join();
    }
    if (message.keyRevocationActionType !== undefined) {
      writer.uint32(96).int32(message.keyRevocationActionType);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ComputeInstanceRestoreProperties_LabelsEntry.encode({ key: key as any, value }, writer.uint32(106).fork()).join();
    });
    if (message.machineType !== undefined) {
      writer.uint32(114).string(message.machineType);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(122).fork()).join();
    }
    if (message.minCpuPlatform !== undefined) {
      writer.uint32(130).string(message.minCpuPlatform);
    }
    for (const v of message.networkInterfaces) {
      NetworkInterface.encode(v!, writer.uint32(138).fork()).join();
    }
    if (message.networkPerformanceConfig !== undefined) {
      NetworkPerformanceConfig.encode(message.networkPerformanceConfig, writer.uint32(146).fork()).join();
    }
    if (message.params !== undefined) {
      InstanceParams.encode(message.params, writer.uint32(154).fork()).join();
    }
    if (message.privateIpv6GoogleAccess !== undefined) {
      writer.uint32(160).int32(message.privateIpv6GoogleAccess);
    }
    if (message.allocationAffinity !== undefined) {
      AllocationAffinity.encode(message.allocationAffinity, writer.uint32(170).fork()).join();
    }
    for (const v of message.resourcePolicies) {
      writer.uint32(178).string(v!);
    }
    if (message.scheduling !== undefined) {
      Scheduling.encode(message.scheduling, writer.uint32(186).fork()).join();
    }
    for (const v of message.serviceAccounts) {
      ServiceAccount.encode(v!, writer.uint32(194).fork()).join();
    }
    if (message.tags !== undefined) {
      Tags.encode(message.tags, writer.uint32(210).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeInstanceRestoreProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeInstanceRestoreProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.advancedMachineFeatures = AdvancedMachineFeatures.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.canIpForward = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.confidentialInstanceConfig = ConfidentialInstanceConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.deletionProtection = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.disks.push(AttachedDisk.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.displayDevice = DisplayDevice.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.guestAccelerators.push(AcceleratorConfig.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.instanceEncryptionKey = CustomerEncryptionKey.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.keyRevocationActionType = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          const entry13 = ComputeInstanceRestoreProperties_LabelsEntry.decode(reader, reader.uint32());
          if (entry13.value !== undefined) {
            message.labels[entry13.key] = entry13.value;
          }
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.minCpuPlatform = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.networkInterfaces.push(NetworkInterface.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.networkPerformanceConfig = NetworkPerformanceConfig.decode(reader, reader.uint32());
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.params = InstanceParams.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.privateIpv6GoogleAccess = reader.int32() as any;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.allocationAffinity = AllocationAffinity.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.resourcePolicies.push(reader.string());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.scheduling = Scheduling.decode(reader, reader.uint32());
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.serviceAccounts.push(ServiceAccount.decode(reader, reader.uint32()));
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.tags = Tags.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeInstanceRestoreProperties {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      advancedMachineFeatures: isSet(object.advancedMachineFeatures)
        ? AdvancedMachineFeatures.fromJSON(object.advancedMachineFeatures)
        : undefined,
      canIpForward: isSet(object.canIpForward) ? globalThis.Boolean(object.canIpForward) : undefined,
      confidentialInstanceConfig: isSet(object.confidentialInstanceConfig)
        ? ConfidentialInstanceConfig.fromJSON(object.confidentialInstanceConfig)
        : undefined,
      deletionProtection: isSet(object.deletionProtection) ? globalThis.Boolean(object.deletionProtection) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      disks: globalThis.Array.isArray(object?.disks) ? object.disks.map((e: any) => AttachedDisk.fromJSON(e)) : [],
      displayDevice: isSet(object.displayDevice) ? DisplayDevice.fromJSON(object.displayDevice) : undefined,
      guestAccelerators: globalThis.Array.isArray(object?.guestAccelerators)
        ? object.guestAccelerators.map((e: any) => AcceleratorConfig.fromJSON(e))
        : [],
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : undefined,
      instanceEncryptionKey: isSet(object.instanceEncryptionKey)
        ? CustomerEncryptionKey.fromJSON(object.instanceEncryptionKey)
        : undefined,
      keyRevocationActionType: isSet(object.keyRevocationActionType)
        ? keyRevocationActionTypeFromJSON(object.keyRevocationActionType)
        : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      minCpuPlatform: isSet(object.minCpuPlatform) ? globalThis.String(object.minCpuPlatform) : undefined,
      networkInterfaces: globalThis.Array.isArray(object?.networkInterfaces)
        ? object.networkInterfaces.map((e: any) => NetworkInterface.fromJSON(e))
        : [],
      networkPerformanceConfig: isSet(object.networkPerformanceConfig)
        ? NetworkPerformanceConfig.fromJSON(object.networkPerformanceConfig)
        : undefined,
      params: isSet(object.params) ? InstanceParams.fromJSON(object.params) : undefined,
      privateIpv6GoogleAccess: isSet(object.privateIpv6GoogleAccess)
        ? computeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccessFromJSON(object.privateIpv6GoogleAccess)
        : undefined,
      allocationAffinity: isSet(object.allocationAffinity)
        ? AllocationAffinity.fromJSON(object.allocationAffinity)
        : undefined,
      resourcePolicies: globalThis.Array.isArray(object?.resourcePolicies)
        ? object.resourcePolicies.map((e: any) => globalThis.String(e))
        : [],
      scheduling: isSet(object.scheduling) ? Scheduling.fromJSON(object.scheduling) : undefined,
      serviceAccounts: globalThis.Array.isArray(object?.serviceAccounts)
        ? object.serviceAccounts.map((e: any) => ServiceAccount.fromJSON(e))
        : [],
      tags: isSet(object.tags) ? Tags.fromJSON(object.tags) : undefined,
    };
  },

  toJSON(message: ComputeInstanceRestoreProperties): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.advancedMachineFeatures !== undefined) {
      obj.advancedMachineFeatures = AdvancedMachineFeatures.toJSON(message.advancedMachineFeatures);
    }
    if (message.canIpForward !== undefined) {
      obj.canIpForward = message.canIpForward;
    }
    if (message.confidentialInstanceConfig !== undefined) {
      obj.confidentialInstanceConfig = ConfidentialInstanceConfig.toJSON(message.confidentialInstanceConfig);
    }
    if (message.deletionProtection !== undefined) {
      obj.deletionProtection = message.deletionProtection;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.disks?.length) {
      obj.disks = message.disks.map((e) => AttachedDisk.toJSON(e));
    }
    if (message.displayDevice !== undefined) {
      obj.displayDevice = DisplayDevice.toJSON(message.displayDevice);
    }
    if (message.guestAccelerators?.length) {
      obj.guestAccelerators = message.guestAccelerators.map((e) => AcceleratorConfig.toJSON(e));
    }
    if (message.hostname !== undefined) {
      obj.hostname = message.hostname;
    }
    if (message.instanceEncryptionKey !== undefined) {
      obj.instanceEncryptionKey = CustomerEncryptionKey.toJSON(message.instanceEncryptionKey);
    }
    if (message.keyRevocationActionType !== undefined) {
      obj.keyRevocationActionType = keyRevocationActionTypeToJSON(message.keyRevocationActionType);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.machineType !== undefined) {
      obj.machineType = message.machineType;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.minCpuPlatform !== undefined) {
      obj.minCpuPlatform = message.minCpuPlatform;
    }
    if (message.networkInterfaces?.length) {
      obj.networkInterfaces = message.networkInterfaces.map((e) => NetworkInterface.toJSON(e));
    }
    if (message.networkPerformanceConfig !== undefined) {
      obj.networkPerformanceConfig = NetworkPerformanceConfig.toJSON(message.networkPerformanceConfig);
    }
    if (message.params !== undefined) {
      obj.params = InstanceParams.toJSON(message.params);
    }
    if (message.privateIpv6GoogleAccess !== undefined) {
      obj.privateIpv6GoogleAccess = computeInstanceRestoreProperties_InstancePrivateIpv6GoogleAccessToJSON(
        message.privateIpv6GoogleAccess,
      );
    }
    if (message.allocationAffinity !== undefined) {
      obj.allocationAffinity = AllocationAffinity.toJSON(message.allocationAffinity);
    }
    if (message.resourcePolicies?.length) {
      obj.resourcePolicies = message.resourcePolicies;
    }
    if (message.scheduling !== undefined) {
      obj.scheduling = Scheduling.toJSON(message.scheduling);
    }
    if (message.serviceAccounts?.length) {
      obj.serviceAccounts = message.serviceAccounts.map((e) => ServiceAccount.toJSON(e));
    }
    if (message.tags !== undefined) {
      obj.tags = Tags.toJSON(message.tags);
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeInstanceRestoreProperties>): ComputeInstanceRestoreProperties {
    return ComputeInstanceRestoreProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeInstanceRestoreProperties>): ComputeInstanceRestoreProperties {
    const message = createBaseComputeInstanceRestoreProperties();
    message.name = object.name ?? undefined;
    message.advancedMachineFeatures =
      (object.advancedMachineFeatures !== undefined && object.advancedMachineFeatures !== null)
        ? AdvancedMachineFeatures.fromPartial(object.advancedMachineFeatures)
        : undefined;
    message.canIpForward = object.canIpForward ?? undefined;
    message.confidentialInstanceConfig =
      (object.confidentialInstanceConfig !== undefined && object.confidentialInstanceConfig !== null)
        ? ConfidentialInstanceConfig.fromPartial(object.confidentialInstanceConfig)
        : undefined;
    message.deletionProtection = object.deletionProtection ?? undefined;
    message.description = object.description ?? undefined;
    message.disks = object.disks?.map((e) => AttachedDisk.fromPartial(e)) || [];
    message.displayDevice = (object.displayDevice !== undefined && object.displayDevice !== null)
      ? DisplayDevice.fromPartial(object.displayDevice)
      : undefined;
    message.guestAccelerators = object.guestAccelerators?.map((e) => AcceleratorConfig.fromPartial(e)) || [];
    message.hostname = object.hostname ?? undefined;
    message.instanceEncryptionKey =
      (object.instanceEncryptionKey !== undefined && object.instanceEncryptionKey !== null)
        ? CustomerEncryptionKey.fromPartial(object.instanceEncryptionKey)
        : undefined;
    message.keyRevocationActionType = object.keyRevocationActionType ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.machineType = object.machineType ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.minCpuPlatform = object.minCpuPlatform ?? undefined;
    message.networkInterfaces = object.networkInterfaces?.map((e) => NetworkInterface.fromPartial(e)) || [];
    message.networkPerformanceConfig =
      (object.networkPerformanceConfig !== undefined && object.networkPerformanceConfig !== null)
        ? NetworkPerformanceConfig.fromPartial(object.networkPerformanceConfig)
        : undefined;
    message.params = (object.params !== undefined && object.params !== null)
      ? InstanceParams.fromPartial(object.params)
      : undefined;
    message.privateIpv6GoogleAccess = object.privateIpv6GoogleAccess ?? undefined;
    message.allocationAffinity = (object.allocationAffinity !== undefined && object.allocationAffinity !== null)
      ? AllocationAffinity.fromPartial(object.allocationAffinity)
      : undefined;
    message.resourcePolicies = object.resourcePolicies?.map((e) => e) || [];
    message.scheduling = (object.scheduling !== undefined && object.scheduling !== null)
      ? Scheduling.fromPartial(object.scheduling)
      : undefined;
    message.serviceAccounts = object.serviceAccounts?.map((e) => ServiceAccount.fromPartial(e)) || [];
    message.tags = (object.tags !== undefined && object.tags !== null) ? Tags.fromPartial(object.tags) : undefined;
    return message;
  },
};

function createBaseComputeInstanceRestoreProperties_LabelsEntry(): ComputeInstanceRestoreProperties_LabelsEntry {
  return { key: "", value: "" };
}

export const ComputeInstanceRestoreProperties_LabelsEntry: MessageFns<ComputeInstanceRestoreProperties_LabelsEntry> = {
  encode(
    message: ComputeInstanceRestoreProperties_LabelsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeInstanceRestoreProperties_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeInstanceRestoreProperties_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeInstanceRestoreProperties_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ComputeInstanceRestoreProperties_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<ComputeInstanceRestoreProperties_LabelsEntry>,
  ): ComputeInstanceRestoreProperties_LabelsEntry {
    return ComputeInstanceRestoreProperties_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<ComputeInstanceRestoreProperties_LabelsEntry>,
  ): ComputeInstanceRestoreProperties_LabelsEntry {
    const message = createBaseComputeInstanceRestoreProperties_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseComputeInstanceTargetEnvironment(): ComputeInstanceTargetEnvironment {
  return { project: "", zone: "" };
}

export const ComputeInstanceTargetEnvironment: MessageFns<ComputeInstanceTargetEnvironment> = {
  encode(message: ComputeInstanceTargetEnvironment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.project !== "") {
      writer.uint32(10).string(message.project);
    }
    if (message.zone !== "") {
      writer.uint32(18).string(message.zone);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeInstanceTargetEnvironment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeInstanceTargetEnvironment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.project = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.zone = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeInstanceTargetEnvironment {
    return {
      project: isSet(object.project) ? globalThis.String(object.project) : "",
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
    };
  },

  toJSON(message: ComputeInstanceTargetEnvironment): unknown {
    const obj: any = {};
    if (message.project !== "") {
      obj.project = message.project;
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeInstanceTargetEnvironment>): ComputeInstanceTargetEnvironment {
    return ComputeInstanceTargetEnvironment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeInstanceTargetEnvironment>): ComputeInstanceTargetEnvironment {
    const message = createBaseComputeInstanceTargetEnvironment();
    message.project = object.project ?? "";
    message.zone = object.zone ?? "";
    return message;
  },
};

function createBaseComputeInstanceDataSourceProperties(): ComputeInstanceDataSourceProperties {
  return { name: "", description: "", machineType: "", totalDiskCount: Long.ZERO, totalDiskSizeGb: Long.ZERO };
}

export const ComputeInstanceDataSourceProperties: MessageFns<ComputeInstanceDataSourceProperties> = {
  encode(message: ComputeInstanceDataSourceProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.machineType !== "") {
      writer.uint32(26).string(message.machineType);
    }
    if (!message.totalDiskCount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.totalDiskCount.toString());
    }
    if (!message.totalDiskSizeGb.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.totalDiskSizeGb.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComputeInstanceDataSourceProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComputeInstanceDataSourceProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.machineType = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalDiskCount = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalDiskSizeGb = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComputeInstanceDataSourceProperties {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      machineType: isSet(object.machineType) ? globalThis.String(object.machineType) : "",
      totalDiskCount: isSet(object.totalDiskCount) ? Long.fromValue(object.totalDiskCount) : Long.ZERO,
      totalDiskSizeGb: isSet(object.totalDiskSizeGb) ? Long.fromValue(object.totalDiskSizeGb) : Long.ZERO,
    };
  },

  toJSON(message: ComputeInstanceDataSourceProperties): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.machineType !== "") {
      obj.machineType = message.machineType;
    }
    if (!message.totalDiskCount.equals(Long.ZERO)) {
      obj.totalDiskCount = (message.totalDiskCount || Long.ZERO).toString();
    }
    if (!message.totalDiskSizeGb.equals(Long.ZERO)) {
      obj.totalDiskSizeGb = (message.totalDiskSizeGb || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ComputeInstanceDataSourceProperties>): ComputeInstanceDataSourceProperties {
    return ComputeInstanceDataSourceProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ComputeInstanceDataSourceProperties>): ComputeInstanceDataSourceProperties {
    const message = createBaseComputeInstanceDataSourceProperties();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.machineType = object.machineType ?? "";
    message.totalDiskCount = (object.totalDiskCount !== undefined && object.totalDiskCount !== null)
      ? Long.fromValue(object.totalDiskCount)
      : Long.ZERO;
    message.totalDiskSizeGb = (object.totalDiskSizeGb !== undefined && object.totalDiskSizeGb !== null)
      ? Long.fromValue(object.totalDiskSizeGb)
      : Long.ZERO;
    return message;
  },
};

function createBaseAdvancedMachineFeatures(): AdvancedMachineFeatures {
  return {
    enableNestedVirtualization: undefined,
    threadsPerCore: undefined,
    visibleCoreCount: undefined,
    enableUefiNetworking: undefined,
  };
}

export const AdvancedMachineFeatures: MessageFns<AdvancedMachineFeatures> = {
  encode(message: AdvancedMachineFeatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableNestedVirtualization !== undefined) {
      writer.uint32(8).bool(message.enableNestedVirtualization);
    }
    if (message.threadsPerCore !== undefined) {
      writer.uint32(16).int32(message.threadsPerCore);
    }
    if (message.visibleCoreCount !== undefined) {
      writer.uint32(24).int32(message.visibleCoreCount);
    }
    if (message.enableUefiNetworking !== undefined) {
      writer.uint32(32).bool(message.enableUefiNetworking);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AdvancedMachineFeatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvancedMachineFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableNestedVirtualization = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.threadsPerCore = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.visibleCoreCount = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enableUefiNetworking = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AdvancedMachineFeatures {
    return {
      enableNestedVirtualization: isSet(object.enableNestedVirtualization)
        ? globalThis.Boolean(object.enableNestedVirtualization)
        : undefined,
      threadsPerCore: isSet(object.threadsPerCore) ? globalThis.Number(object.threadsPerCore) : undefined,
      visibleCoreCount: isSet(object.visibleCoreCount) ? globalThis.Number(object.visibleCoreCount) : undefined,
      enableUefiNetworking: isSet(object.enableUefiNetworking)
        ? globalThis.Boolean(object.enableUefiNetworking)
        : undefined,
    };
  },

  toJSON(message: AdvancedMachineFeatures): unknown {
    const obj: any = {};
    if (message.enableNestedVirtualization !== undefined) {
      obj.enableNestedVirtualization = message.enableNestedVirtualization;
    }
    if (message.threadsPerCore !== undefined) {
      obj.threadsPerCore = Math.round(message.threadsPerCore);
    }
    if (message.visibleCoreCount !== undefined) {
      obj.visibleCoreCount = Math.round(message.visibleCoreCount);
    }
    if (message.enableUefiNetworking !== undefined) {
      obj.enableUefiNetworking = message.enableUefiNetworking;
    }
    return obj;
  },

  create(base?: DeepPartial<AdvancedMachineFeatures>): AdvancedMachineFeatures {
    return AdvancedMachineFeatures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AdvancedMachineFeatures>): AdvancedMachineFeatures {
    const message = createBaseAdvancedMachineFeatures();
    message.enableNestedVirtualization = object.enableNestedVirtualization ?? undefined;
    message.threadsPerCore = object.threadsPerCore ?? undefined;
    message.visibleCoreCount = object.visibleCoreCount ?? undefined;
    message.enableUefiNetworking = object.enableUefiNetworking ?? undefined;
    return message;
  },
};

function createBaseConfidentialInstanceConfig(): ConfidentialInstanceConfig {
  return { enableConfidentialCompute: undefined };
}

export const ConfidentialInstanceConfig: MessageFns<ConfidentialInstanceConfig> = {
  encode(message: ConfidentialInstanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableConfidentialCompute !== undefined) {
      writer.uint32(8).bool(message.enableConfidentialCompute);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfidentialInstanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfidentialInstanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableConfidentialCompute = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfidentialInstanceConfig {
    return {
      enableConfidentialCompute: isSet(object.enableConfidentialCompute)
        ? globalThis.Boolean(object.enableConfidentialCompute)
        : undefined,
    };
  },

  toJSON(message: ConfidentialInstanceConfig): unknown {
    const obj: any = {};
    if (message.enableConfidentialCompute !== undefined) {
      obj.enableConfidentialCompute = message.enableConfidentialCompute;
    }
    return obj;
  },

  create(base?: DeepPartial<ConfidentialInstanceConfig>): ConfidentialInstanceConfig {
    return ConfidentialInstanceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConfidentialInstanceConfig>): ConfidentialInstanceConfig {
    const message = createBaseConfidentialInstanceConfig();
    message.enableConfidentialCompute = object.enableConfidentialCompute ?? undefined;
    return message;
  },
};

function createBaseDisplayDevice(): DisplayDevice {
  return { enableDisplay: undefined };
}

export const DisplayDevice: MessageFns<DisplayDevice> = {
  encode(message: DisplayDevice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableDisplay !== undefined) {
      writer.uint32(8).bool(message.enableDisplay);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DisplayDevice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisplayDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.enableDisplay = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DisplayDevice {
    return { enableDisplay: isSet(object.enableDisplay) ? globalThis.Boolean(object.enableDisplay) : undefined };
  },

  toJSON(message: DisplayDevice): unknown {
    const obj: any = {};
    if (message.enableDisplay !== undefined) {
      obj.enableDisplay = message.enableDisplay;
    }
    return obj;
  },

  create(base?: DeepPartial<DisplayDevice>): DisplayDevice {
    return DisplayDevice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DisplayDevice>): DisplayDevice {
    const message = createBaseDisplayDevice();
    message.enableDisplay = object.enableDisplay ?? undefined;
    return message;
  },
};

function createBaseAcceleratorConfig(): AcceleratorConfig {
  return { acceleratorType: undefined, acceleratorCount: undefined };
}

export const AcceleratorConfig: MessageFns<AcceleratorConfig> = {
  encode(message: AcceleratorConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.acceleratorType !== undefined) {
      writer.uint32(10).string(message.acceleratorType);
    }
    if (message.acceleratorCount !== undefined) {
      writer.uint32(16).int32(message.acceleratorCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AcceleratorConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAcceleratorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.acceleratorType = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.acceleratorCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AcceleratorConfig {
    return {
      acceleratorType: isSet(object.acceleratorType) ? globalThis.String(object.acceleratorType) : undefined,
      acceleratorCount: isSet(object.acceleratorCount) ? globalThis.Number(object.acceleratorCount) : undefined,
    };
  },

  toJSON(message: AcceleratorConfig): unknown {
    const obj: any = {};
    if (message.acceleratorType !== undefined) {
      obj.acceleratorType = message.acceleratorType;
    }
    if (message.acceleratorCount !== undefined) {
      obj.acceleratorCount = Math.round(message.acceleratorCount);
    }
    return obj;
  },

  create(base?: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    return AcceleratorConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AcceleratorConfig>): AcceleratorConfig {
    const message = createBaseAcceleratorConfig();
    message.acceleratorType = object.acceleratorType ?? undefined;
    message.acceleratorCount = object.acceleratorCount ?? undefined;
    return message;
  },
};

function createBaseCustomerEncryptionKey(): CustomerEncryptionKey {
  return { rawKey: undefined, rsaEncryptedKey: undefined, kmsKeyName: undefined, kmsKeyServiceAccount: undefined };
}

export const CustomerEncryptionKey: MessageFns<CustomerEncryptionKey> = {
  encode(message: CustomerEncryptionKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rawKey !== undefined) {
      writer.uint32(10).string(message.rawKey);
    }
    if (message.rsaEncryptedKey !== undefined) {
      writer.uint32(18).string(message.rsaEncryptedKey);
    }
    if (message.kmsKeyName !== undefined) {
      writer.uint32(26).string(message.kmsKeyName);
    }
    if (message.kmsKeyServiceAccount !== undefined) {
      writer.uint32(34).string(message.kmsKeyServiceAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CustomerEncryptionKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCustomerEncryptionKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rawKey = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rsaEncryptedKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.kmsKeyName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.kmsKeyServiceAccount = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CustomerEncryptionKey {
    return {
      rawKey: isSet(object.rawKey) ? globalThis.String(object.rawKey) : undefined,
      rsaEncryptedKey: isSet(object.rsaEncryptedKey) ? globalThis.String(object.rsaEncryptedKey) : undefined,
      kmsKeyName: isSet(object.kmsKeyName) ? globalThis.String(object.kmsKeyName) : undefined,
      kmsKeyServiceAccount: isSet(object.kmsKeyServiceAccount)
        ? globalThis.String(object.kmsKeyServiceAccount)
        : undefined,
    };
  },

  toJSON(message: CustomerEncryptionKey): unknown {
    const obj: any = {};
    if (message.rawKey !== undefined) {
      obj.rawKey = message.rawKey;
    }
    if (message.rsaEncryptedKey !== undefined) {
      obj.rsaEncryptedKey = message.rsaEncryptedKey;
    }
    if (message.kmsKeyName !== undefined) {
      obj.kmsKeyName = message.kmsKeyName;
    }
    if (message.kmsKeyServiceAccount !== undefined) {
      obj.kmsKeyServiceAccount = message.kmsKeyServiceAccount;
    }
    return obj;
  },

  create(base?: DeepPartial<CustomerEncryptionKey>): CustomerEncryptionKey {
    return CustomerEncryptionKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CustomerEncryptionKey>): CustomerEncryptionKey {
    const message = createBaseCustomerEncryptionKey();
    message.rawKey = object.rawKey ?? undefined;
    message.rsaEncryptedKey = object.rsaEncryptedKey ?? undefined;
    message.kmsKeyName = object.kmsKeyName ?? undefined;
    message.kmsKeyServiceAccount = object.kmsKeyServiceAccount ?? undefined;
    return message;
  },
};

function createBaseEntry(): Entry {
  return { key: undefined, value: undefined };
}

export const Entry: MessageFns<Entry> = {
  encode(message: Entry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
    };
  },

  toJSON(message: Entry): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Entry>): Entry {
    return Entry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entry>): Entry {
    const message = createBaseEntry();
    message.key = object.key ?? undefined;
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return { items: [] };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Entry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(Entry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Entry.fromJSON(e)) : [] };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Entry.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Metadata>): Metadata {
    return Metadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Metadata>): Metadata {
    const message = createBaseMetadata();
    message.items = object.items?.map((e) => Entry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNetworkInterface(): NetworkInterface {
  return {
    network: undefined,
    subnetwork: undefined,
    ipAddress: undefined,
    ipv6Address: undefined,
    internalIpv6PrefixLength: undefined,
    name: undefined,
    accessConfigs: [],
    ipv6AccessConfigs: [],
    aliasIpRanges: [],
    stackType: undefined,
    ipv6AccessType: undefined,
    queueCount: undefined,
    nicType: undefined,
    networkAttachment: undefined,
  };
}

export const NetworkInterface: MessageFns<NetworkInterface> = {
  encode(message: NetworkInterface, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== undefined) {
      writer.uint32(10).string(message.network);
    }
    if (message.subnetwork !== undefined) {
      writer.uint32(18).string(message.subnetwork);
    }
    if (message.ipAddress !== undefined) {
      writer.uint32(26).string(message.ipAddress);
    }
    if (message.ipv6Address !== undefined) {
      writer.uint32(34).string(message.ipv6Address);
    }
    if (message.internalIpv6PrefixLength !== undefined) {
      writer.uint32(40).int32(message.internalIpv6PrefixLength);
    }
    if (message.name !== undefined) {
      writer.uint32(50).string(message.name);
    }
    for (const v of message.accessConfigs) {
      AccessConfig.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.ipv6AccessConfigs) {
      AccessConfig.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.aliasIpRanges) {
      AliasIpRange.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.stackType !== undefined) {
      writer.uint32(80).int32(message.stackType);
    }
    if (message.ipv6AccessType !== undefined) {
      writer.uint32(88).int32(message.ipv6AccessType);
    }
    if (message.queueCount !== undefined) {
      writer.uint32(96).int32(message.queueCount);
    }
    if (message.nicType !== undefined) {
      writer.uint32(104).int32(message.nicType);
    }
    if (message.networkAttachment !== undefined) {
      writer.uint32(114).string(message.networkAttachment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkInterface {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkInterface();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnetwork = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ipAddress = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.ipv6Address = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.internalIpv6PrefixLength = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.accessConfigs.push(AccessConfig.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ipv6AccessConfigs.push(AccessConfig.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.aliasIpRanges.push(AliasIpRange.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.stackType = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.ipv6AccessType = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.queueCount = reader.int32();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.nicType = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.networkAttachment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkInterface {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : undefined,
      subnetwork: isSet(object.subnetwork) ? globalThis.String(object.subnetwork) : undefined,
      ipAddress: isSet(object.ipAddress) ? globalThis.String(object.ipAddress) : undefined,
      ipv6Address: isSet(object.ipv6Address) ? globalThis.String(object.ipv6Address) : undefined,
      internalIpv6PrefixLength: isSet(object.internalIpv6PrefixLength)
        ? globalThis.Number(object.internalIpv6PrefixLength)
        : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      accessConfigs: globalThis.Array.isArray(object?.accessConfigs)
        ? object.accessConfigs.map((e: any) => AccessConfig.fromJSON(e))
        : [],
      ipv6AccessConfigs: globalThis.Array.isArray(object?.ipv6AccessConfigs)
        ? object.ipv6AccessConfigs.map((e: any) => AccessConfig.fromJSON(e))
        : [],
      aliasIpRanges: globalThis.Array.isArray(object?.aliasIpRanges)
        ? object.aliasIpRanges.map((e: any) => AliasIpRange.fromJSON(e))
        : [],
      stackType: isSet(object.stackType) ? networkInterface_StackTypeFromJSON(object.stackType) : undefined,
      ipv6AccessType: isSet(object.ipv6AccessType)
        ? networkInterface_Ipv6AccessTypeFromJSON(object.ipv6AccessType)
        : undefined,
      queueCount: isSet(object.queueCount) ? globalThis.Number(object.queueCount) : undefined,
      nicType: isSet(object.nicType) ? networkInterface_NicTypeFromJSON(object.nicType) : undefined,
      networkAttachment: isSet(object.networkAttachment) ? globalThis.String(object.networkAttachment) : undefined,
    };
  },

  toJSON(message: NetworkInterface): unknown {
    const obj: any = {};
    if (message.network !== undefined) {
      obj.network = message.network;
    }
    if (message.subnetwork !== undefined) {
      obj.subnetwork = message.subnetwork;
    }
    if (message.ipAddress !== undefined) {
      obj.ipAddress = message.ipAddress;
    }
    if (message.ipv6Address !== undefined) {
      obj.ipv6Address = message.ipv6Address;
    }
    if (message.internalIpv6PrefixLength !== undefined) {
      obj.internalIpv6PrefixLength = Math.round(message.internalIpv6PrefixLength);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.accessConfigs?.length) {
      obj.accessConfigs = message.accessConfigs.map((e) => AccessConfig.toJSON(e));
    }
    if (message.ipv6AccessConfigs?.length) {
      obj.ipv6AccessConfigs = message.ipv6AccessConfigs.map((e) => AccessConfig.toJSON(e));
    }
    if (message.aliasIpRanges?.length) {
      obj.aliasIpRanges = message.aliasIpRanges.map((e) => AliasIpRange.toJSON(e));
    }
    if (message.stackType !== undefined) {
      obj.stackType = networkInterface_StackTypeToJSON(message.stackType);
    }
    if (message.ipv6AccessType !== undefined) {
      obj.ipv6AccessType = networkInterface_Ipv6AccessTypeToJSON(message.ipv6AccessType);
    }
    if (message.queueCount !== undefined) {
      obj.queueCount = Math.round(message.queueCount);
    }
    if (message.nicType !== undefined) {
      obj.nicType = networkInterface_NicTypeToJSON(message.nicType);
    }
    if (message.networkAttachment !== undefined) {
      obj.networkAttachment = message.networkAttachment;
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkInterface>): NetworkInterface {
    return NetworkInterface.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkInterface>): NetworkInterface {
    const message = createBaseNetworkInterface();
    message.network = object.network ?? undefined;
    message.subnetwork = object.subnetwork ?? undefined;
    message.ipAddress = object.ipAddress ?? undefined;
    message.ipv6Address = object.ipv6Address ?? undefined;
    message.internalIpv6PrefixLength = object.internalIpv6PrefixLength ?? undefined;
    message.name = object.name ?? undefined;
    message.accessConfigs = object.accessConfigs?.map((e) => AccessConfig.fromPartial(e)) || [];
    message.ipv6AccessConfigs = object.ipv6AccessConfigs?.map((e) => AccessConfig.fromPartial(e)) || [];
    message.aliasIpRanges = object.aliasIpRanges?.map((e) => AliasIpRange.fromPartial(e)) || [];
    message.stackType = object.stackType ?? undefined;
    message.ipv6AccessType = object.ipv6AccessType ?? undefined;
    message.queueCount = object.queueCount ?? undefined;
    message.nicType = object.nicType ?? undefined;
    message.networkAttachment = object.networkAttachment ?? undefined;
    return message;
  },
};

function createBaseNetworkPerformanceConfig(): NetworkPerformanceConfig {
  return { totalEgressBandwidthTier: undefined };
}

export const NetworkPerformanceConfig: MessageFns<NetworkPerformanceConfig> = {
  encode(message: NetworkPerformanceConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalEgressBandwidthTier !== undefined) {
      writer.uint32(8).int32(message.totalEgressBandwidthTier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetworkPerformanceConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetworkPerformanceConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalEgressBandwidthTier = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetworkPerformanceConfig {
    return {
      totalEgressBandwidthTier: isSet(object.totalEgressBandwidthTier)
        ? networkPerformanceConfig_TierFromJSON(object.totalEgressBandwidthTier)
        : undefined,
    };
  },

  toJSON(message: NetworkPerformanceConfig): unknown {
    const obj: any = {};
    if (message.totalEgressBandwidthTier !== undefined) {
      obj.totalEgressBandwidthTier = networkPerformanceConfig_TierToJSON(message.totalEgressBandwidthTier);
    }
    return obj;
  },

  create(base?: DeepPartial<NetworkPerformanceConfig>): NetworkPerformanceConfig {
    return NetworkPerformanceConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NetworkPerformanceConfig>): NetworkPerformanceConfig {
    const message = createBaseNetworkPerformanceConfig();
    message.totalEgressBandwidthTier = object.totalEgressBandwidthTier ?? undefined;
    return message;
  },
};

function createBaseAccessConfig(): AccessConfig {
  return {
    type: undefined,
    name: undefined,
    externalIp: undefined,
    externalIpv6: undefined,
    externalIpv6PrefixLength: undefined,
    setPublicPtr: undefined,
    publicPtrDomainName: undefined,
    networkTier: undefined,
  };
}

export const AccessConfig: MessageFns<AccessConfig> = {
  encode(message: AccessConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined) {
      writer.uint32(8).int32(message.type);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.externalIp !== undefined) {
      writer.uint32(26).string(message.externalIp);
    }
    if (message.externalIpv6 !== undefined) {
      writer.uint32(34).string(message.externalIpv6);
    }
    if (message.externalIpv6PrefixLength !== undefined) {
      writer.uint32(40).int32(message.externalIpv6PrefixLength);
    }
    if (message.setPublicPtr !== undefined) {
      writer.uint32(48).bool(message.setPublicPtr);
    }
    if (message.publicPtrDomainName !== undefined) {
      writer.uint32(58).string(message.publicPtrDomainName);
    }
    if (message.networkTier !== undefined) {
      writer.uint32(64).int32(message.networkTier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.externalIp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.externalIpv6 = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.externalIpv6PrefixLength = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.setPublicPtr = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.publicPtrDomainName = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.networkTier = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessConfig {
    return {
      type: isSet(object.type) ? accessConfig_AccessTypeFromJSON(object.type) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      externalIp: isSet(object.externalIp) ? globalThis.String(object.externalIp) : undefined,
      externalIpv6: isSet(object.externalIpv6) ? globalThis.String(object.externalIpv6) : undefined,
      externalIpv6PrefixLength: isSet(object.externalIpv6PrefixLength)
        ? globalThis.Number(object.externalIpv6PrefixLength)
        : undefined,
      setPublicPtr: isSet(object.setPublicPtr) ? globalThis.Boolean(object.setPublicPtr) : undefined,
      publicPtrDomainName: isSet(object.publicPtrDomainName)
        ? globalThis.String(object.publicPtrDomainName)
        : undefined,
      networkTier: isSet(object.networkTier) ? accessConfig_NetworkTierFromJSON(object.networkTier) : undefined,
    };
  },

  toJSON(message: AccessConfig): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = accessConfig_AccessTypeToJSON(message.type);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.externalIp !== undefined) {
      obj.externalIp = message.externalIp;
    }
    if (message.externalIpv6 !== undefined) {
      obj.externalIpv6 = message.externalIpv6;
    }
    if (message.externalIpv6PrefixLength !== undefined) {
      obj.externalIpv6PrefixLength = Math.round(message.externalIpv6PrefixLength);
    }
    if (message.setPublicPtr !== undefined) {
      obj.setPublicPtr = message.setPublicPtr;
    }
    if (message.publicPtrDomainName !== undefined) {
      obj.publicPtrDomainName = message.publicPtrDomainName;
    }
    if (message.networkTier !== undefined) {
      obj.networkTier = accessConfig_NetworkTierToJSON(message.networkTier);
    }
    return obj;
  },

  create(base?: DeepPartial<AccessConfig>): AccessConfig {
    return AccessConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccessConfig>): AccessConfig {
    const message = createBaseAccessConfig();
    message.type = object.type ?? undefined;
    message.name = object.name ?? undefined;
    message.externalIp = object.externalIp ?? undefined;
    message.externalIpv6 = object.externalIpv6 ?? undefined;
    message.externalIpv6PrefixLength = object.externalIpv6PrefixLength ?? undefined;
    message.setPublicPtr = object.setPublicPtr ?? undefined;
    message.publicPtrDomainName = object.publicPtrDomainName ?? undefined;
    message.networkTier = object.networkTier ?? undefined;
    return message;
  },
};

function createBaseAliasIpRange(): AliasIpRange {
  return { ipCidrRange: undefined, subnetworkRangeName: undefined };
}

export const AliasIpRange: MessageFns<AliasIpRange> = {
  encode(message: AliasIpRange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ipCidrRange !== undefined) {
      writer.uint32(10).string(message.ipCidrRange);
    }
    if (message.subnetworkRangeName !== undefined) {
      writer.uint32(18).string(message.subnetworkRangeName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AliasIpRange {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAliasIpRange();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ipCidrRange = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.subnetworkRangeName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AliasIpRange {
    return {
      ipCidrRange: isSet(object.ipCidrRange) ? globalThis.String(object.ipCidrRange) : undefined,
      subnetworkRangeName: isSet(object.subnetworkRangeName)
        ? globalThis.String(object.subnetworkRangeName)
        : undefined,
    };
  },

  toJSON(message: AliasIpRange): unknown {
    const obj: any = {};
    if (message.ipCidrRange !== undefined) {
      obj.ipCidrRange = message.ipCidrRange;
    }
    if (message.subnetworkRangeName !== undefined) {
      obj.subnetworkRangeName = message.subnetworkRangeName;
    }
    return obj;
  },

  create(base?: DeepPartial<AliasIpRange>): AliasIpRange {
    return AliasIpRange.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AliasIpRange>): AliasIpRange {
    const message = createBaseAliasIpRange();
    message.ipCidrRange = object.ipCidrRange ?? undefined;
    message.subnetworkRangeName = object.subnetworkRangeName ?? undefined;
    return message;
  },
};

function createBaseInstanceParams(): InstanceParams {
  return { resourceManagerTags: {} };
}

export const InstanceParams: MessageFns<InstanceParams> = {
  encode(message: InstanceParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.resourceManagerTags).forEach(([key, value]) => {
      InstanceParams_ResourceManagerTagsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = InstanceParams_ResourceManagerTagsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.resourceManagerTags[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceParams {
    return {
      resourceManagerTags: isObject(object.resourceManagerTags)
        ? Object.entries(object.resourceManagerTags).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: InstanceParams): unknown {
    const obj: any = {};
    if (message.resourceManagerTags) {
      const entries = Object.entries(message.resourceManagerTags);
      if (entries.length > 0) {
        obj.resourceManagerTags = {};
        entries.forEach(([k, v]) => {
          obj.resourceManagerTags[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<InstanceParams>): InstanceParams {
    return InstanceParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstanceParams>): InstanceParams {
    const message = createBaseInstanceParams();
    message.resourceManagerTags = Object.entries(object.resourceManagerTags ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseInstanceParams_ResourceManagerTagsEntry(): InstanceParams_ResourceManagerTagsEntry {
  return { key: "", value: "" };
}

export const InstanceParams_ResourceManagerTagsEntry: MessageFns<InstanceParams_ResourceManagerTagsEntry> = {
  encode(message: InstanceParams_ResourceManagerTagsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceParams_ResourceManagerTagsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceParams_ResourceManagerTagsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceParams_ResourceManagerTagsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: InstanceParams_ResourceManagerTagsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<InstanceParams_ResourceManagerTagsEntry>): InstanceParams_ResourceManagerTagsEntry {
    return InstanceParams_ResourceManagerTagsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstanceParams_ResourceManagerTagsEntry>): InstanceParams_ResourceManagerTagsEntry {
    const message = createBaseInstanceParams_ResourceManagerTagsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAllocationAffinity(): AllocationAffinity {
  return { consumeAllocationType: undefined, key: undefined, values: [] };
}

export const AllocationAffinity: MessageFns<AllocationAffinity> = {
  encode(message: AllocationAffinity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumeAllocationType !== undefined) {
      writer.uint32(8).int32(message.consumeAllocationType);
    }
    if (message.key !== undefined) {
      writer.uint32(18).string(message.key);
    }
    for (const v of message.values) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AllocationAffinity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAllocationAffinity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.consumeAllocationType = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.key = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AllocationAffinity {
    return {
      consumeAllocationType: isSet(object.consumeAllocationType)
        ? allocationAffinity_TypeFromJSON(object.consumeAllocationType)
        : undefined,
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: AllocationAffinity): unknown {
    const obj: any = {};
    if (message.consumeAllocationType !== undefined) {
      obj.consumeAllocationType = allocationAffinity_TypeToJSON(message.consumeAllocationType);
    }
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<AllocationAffinity>): AllocationAffinity {
    return AllocationAffinity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AllocationAffinity>): AllocationAffinity {
    const message = createBaseAllocationAffinity();
    message.consumeAllocationType = object.consumeAllocationType ?? undefined;
    message.key = object.key ?? undefined;
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseScheduling(): Scheduling {
  return {
    onHostMaintenance: undefined,
    automaticRestart: undefined,
    preemptible: undefined,
    nodeAffinities: [],
    minNodeCpus: undefined,
    provisioningModel: undefined,
    instanceTerminationAction: undefined,
    localSsdRecoveryTimeout: undefined,
  };
}

export const Scheduling: MessageFns<Scheduling> = {
  encode(message: Scheduling, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.onHostMaintenance !== undefined) {
      writer.uint32(8).int32(message.onHostMaintenance);
    }
    if (message.automaticRestart !== undefined) {
      writer.uint32(16).bool(message.automaticRestart);
    }
    if (message.preemptible !== undefined) {
      writer.uint32(24).bool(message.preemptible);
    }
    for (const v of message.nodeAffinities) {
      Scheduling_NodeAffinity.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.minNodeCpus !== undefined) {
      writer.uint32(40).int32(message.minNodeCpus);
    }
    if (message.provisioningModel !== undefined) {
      writer.uint32(48).int32(message.provisioningModel);
    }
    if (message.instanceTerminationAction !== undefined) {
      writer.uint32(56).int32(message.instanceTerminationAction);
    }
    if (message.localSsdRecoveryTimeout !== undefined) {
      SchedulingDuration.encode(message.localSsdRecoveryTimeout, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scheduling {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduling();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.onHostMaintenance = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.automaticRestart = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.preemptible = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.nodeAffinities.push(Scheduling_NodeAffinity.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.minNodeCpus = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.provisioningModel = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.instanceTerminationAction = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.localSsdRecoveryTimeout = SchedulingDuration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scheduling {
    return {
      onHostMaintenance: isSet(object.onHostMaintenance)
        ? scheduling_OnHostMaintenanceFromJSON(object.onHostMaintenance)
        : undefined,
      automaticRestart: isSet(object.automaticRestart) ? globalThis.Boolean(object.automaticRestart) : undefined,
      preemptible: isSet(object.preemptible) ? globalThis.Boolean(object.preemptible) : undefined,
      nodeAffinities: globalThis.Array.isArray(object?.nodeAffinities)
        ? object.nodeAffinities.map((e: any) => Scheduling_NodeAffinity.fromJSON(e))
        : [],
      minNodeCpus: isSet(object.minNodeCpus) ? globalThis.Number(object.minNodeCpus) : undefined,
      provisioningModel: isSet(object.provisioningModel)
        ? scheduling_ProvisioningModelFromJSON(object.provisioningModel)
        : undefined,
      instanceTerminationAction: isSet(object.instanceTerminationAction)
        ? scheduling_InstanceTerminationActionFromJSON(object.instanceTerminationAction)
        : undefined,
      localSsdRecoveryTimeout: isSet(object.localSsdRecoveryTimeout)
        ? SchedulingDuration.fromJSON(object.localSsdRecoveryTimeout)
        : undefined,
    };
  },

  toJSON(message: Scheduling): unknown {
    const obj: any = {};
    if (message.onHostMaintenance !== undefined) {
      obj.onHostMaintenance = scheduling_OnHostMaintenanceToJSON(message.onHostMaintenance);
    }
    if (message.automaticRestart !== undefined) {
      obj.automaticRestart = message.automaticRestart;
    }
    if (message.preemptible !== undefined) {
      obj.preemptible = message.preemptible;
    }
    if (message.nodeAffinities?.length) {
      obj.nodeAffinities = message.nodeAffinities.map((e) => Scheduling_NodeAffinity.toJSON(e));
    }
    if (message.minNodeCpus !== undefined) {
      obj.minNodeCpus = Math.round(message.minNodeCpus);
    }
    if (message.provisioningModel !== undefined) {
      obj.provisioningModel = scheduling_ProvisioningModelToJSON(message.provisioningModel);
    }
    if (message.instanceTerminationAction !== undefined) {
      obj.instanceTerminationAction = scheduling_InstanceTerminationActionToJSON(message.instanceTerminationAction);
    }
    if (message.localSsdRecoveryTimeout !== undefined) {
      obj.localSsdRecoveryTimeout = SchedulingDuration.toJSON(message.localSsdRecoveryTimeout);
    }
    return obj;
  },

  create(base?: DeepPartial<Scheduling>): Scheduling {
    return Scheduling.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Scheduling>): Scheduling {
    const message = createBaseScheduling();
    message.onHostMaintenance = object.onHostMaintenance ?? undefined;
    message.automaticRestart = object.automaticRestart ?? undefined;
    message.preemptible = object.preemptible ?? undefined;
    message.nodeAffinities = object.nodeAffinities?.map((e) => Scheduling_NodeAffinity.fromPartial(e)) || [];
    message.minNodeCpus = object.minNodeCpus ?? undefined;
    message.provisioningModel = object.provisioningModel ?? undefined;
    message.instanceTerminationAction = object.instanceTerminationAction ?? undefined;
    message.localSsdRecoveryTimeout =
      (object.localSsdRecoveryTimeout !== undefined && object.localSsdRecoveryTimeout !== null)
        ? SchedulingDuration.fromPartial(object.localSsdRecoveryTimeout)
        : undefined;
    return message;
  },
};

function createBaseScheduling_NodeAffinity(): Scheduling_NodeAffinity {
  return { key: undefined, operator: undefined, values: [] };
}

export const Scheduling_NodeAffinity: MessageFns<Scheduling_NodeAffinity> = {
  encode(message: Scheduling_NodeAffinity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      writer.uint32(10).string(message.key);
    }
    if (message.operator !== undefined) {
      writer.uint32(16).int32(message.operator);
    }
    for (const v of message.values) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Scheduling_NodeAffinity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScheduling_NodeAffinity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scheduling_NodeAffinity {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : undefined,
      operator: isSet(object.operator) ? scheduling_NodeAffinity_OperatorFromJSON(object.operator) : undefined,
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Scheduling_NodeAffinity): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = message.key;
    }
    if (message.operator !== undefined) {
      obj.operator = scheduling_NodeAffinity_OperatorToJSON(message.operator);
    }
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<Scheduling_NodeAffinity>): Scheduling_NodeAffinity {
    return Scheduling_NodeAffinity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Scheduling_NodeAffinity>): Scheduling_NodeAffinity {
    const message = createBaseScheduling_NodeAffinity();
    message.key = object.key ?? undefined;
    message.operator = object.operator ?? undefined;
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseSchedulingDuration(): SchedulingDuration {
  return { seconds: undefined, nanos: undefined };
}

export const SchedulingDuration: MessageFns<SchedulingDuration> = {
  encode(message: SchedulingDuration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seconds !== undefined) {
      writer.uint32(8).int64(message.seconds.toString());
    }
    if (message.nanos !== undefined) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchedulingDuration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedulingDuration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.seconds = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nanos = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchedulingDuration {
    return {
      seconds: isSet(object.seconds) ? Long.fromValue(object.seconds) : undefined,
      nanos: isSet(object.nanos) ? globalThis.Number(object.nanos) : undefined,
    };
  },

  toJSON(message: SchedulingDuration): unknown {
    const obj: any = {};
    if (message.seconds !== undefined) {
      obj.seconds = (message.seconds || Long.ZERO).toString();
    }
    if (message.nanos !== undefined) {
      obj.nanos = Math.round(message.nanos);
    }
    return obj;
  },

  create(base?: DeepPartial<SchedulingDuration>): SchedulingDuration {
    return SchedulingDuration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SchedulingDuration>): SchedulingDuration {
    const message = createBaseSchedulingDuration();
    message.seconds = (object.seconds !== undefined && object.seconds !== null)
      ? Long.fromValue(object.seconds)
      : undefined;
    message.nanos = object.nanos ?? undefined;
    return message;
  },
};

function createBaseServiceAccount(): ServiceAccount {
  return { email: undefined, scopes: [] };
}

export const ServiceAccount: MessageFns<ServiceAccount> = {
  encode(message: ServiceAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== undefined) {
      writer.uint32(10).string(message.email);
    }
    for (const v of message.scopes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scopes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceAccount {
    return {
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ServiceAccount): unknown {
    const obj: any = {};
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceAccount>): ServiceAccount {
    return ServiceAccount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceAccount>): ServiceAccount {
    const message = createBaseServiceAccount();
    message.email = object.email ?? undefined;
    message.scopes = object.scopes?.map((e) => e) || [];
    return message;
  },
};

function createBaseTags(): Tags {
  return { items: [] };
}

export const Tags: MessageFns<Tags> = {
  encode(message: Tags, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tags {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTags();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tags {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: Tags): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items;
    }
    return obj;
  },

  create(base?: DeepPartial<Tags>): Tags {
    return Tags.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tags>): Tags {
    const message = createBaseTags();
    message.items = object.items?.map((e) => e) || [];
    return message;
  },
};

function createBaseAttachedDisk(): AttachedDisk {
  return {
    initializeParams: undefined,
    deviceName: undefined,
    kind: undefined,
    diskTypeDeprecated: undefined,
    mode: undefined,
    source: undefined,
    index: undefined,
    boot: undefined,
    autoDelete: undefined,
    license: [],
    diskInterface: undefined,
    guestOsFeature: [],
    diskEncryptionKey: undefined,
    diskSizeGb: undefined,
    savedState: undefined,
    diskType: undefined,
    type: undefined,
  };
}

export const AttachedDisk: MessageFns<AttachedDisk> = {
  encode(message: AttachedDisk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initializeParams !== undefined) {
      AttachedDisk_InitializeParams.encode(message.initializeParams, writer.uint32(10).fork()).join();
    }
    if (message.deviceName !== undefined) {
      writer.uint32(34).string(message.deviceName);
    }
    if (message.kind !== undefined) {
      writer.uint32(42).string(message.kind);
    }
    if (message.diskTypeDeprecated !== undefined) {
      writer.uint32(48).int32(message.diskTypeDeprecated);
    }
    if (message.mode !== undefined) {
      writer.uint32(56).int32(message.mode);
    }
    if (message.source !== undefined) {
      writer.uint32(66).string(message.source);
    }
    if (message.index !== undefined) {
      writer.uint32(72).int64(message.index.toString());
    }
    if (message.boot !== undefined) {
      writer.uint32(80).bool(message.boot);
    }
    if (message.autoDelete !== undefined) {
      writer.uint32(88).bool(message.autoDelete);
    }
    for (const v of message.license) {
      writer.uint32(98).string(v!);
    }
    if (message.diskInterface !== undefined) {
      writer.uint32(104).int32(message.diskInterface);
    }
    for (const v of message.guestOsFeature) {
      GuestOsFeature.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.diskEncryptionKey !== undefined) {
      CustomerEncryptionKey.encode(message.diskEncryptionKey, writer.uint32(122).fork()).join();
    }
    if (message.diskSizeGb !== undefined) {
      writer.uint32(128).int64(message.diskSizeGb.toString());
    }
    if (message.savedState !== undefined) {
      writer.uint32(136).int32(message.savedState);
    }
    if (message.diskType !== undefined) {
      writer.uint32(146).string(message.diskType);
    }
    if (message.type !== undefined) {
      writer.uint32(152).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttachedDisk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachedDisk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.initializeParams = AttachedDisk_InitializeParams.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.deviceName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.kind = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.diskTypeDeprecated = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.source = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.index = Long.fromString(reader.int64().toString());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.boot = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.autoDelete = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.license.push(reader.string());
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.diskInterface = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.guestOsFeature.push(GuestOsFeature.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.diskEncryptionKey = CustomerEncryptionKey.decode(reader, reader.uint32());
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.diskSizeGb = Long.fromString(reader.int64().toString());
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.savedState = reader.int32() as any;
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.diskType = reader.string();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttachedDisk {
    return {
      initializeParams: isSet(object.initializeParams)
        ? AttachedDisk_InitializeParams.fromJSON(object.initializeParams)
        : undefined,
      deviceName: isSet(object.deviceName) ? globalThis.String(object.deviceName) : undefined,
      kind: isSet(object.kind) ? globalThis.String(object.kind) : undefined,
      diskTypeDeprecated: isSet(object.diskTypeDeprecated)
        ? attachedDisk_DiskTypeFromJSON(object.diskTypeDeprecated)
        : undefined,
      mode: isSet(object.mode) ? attachedDisk_DiskModeFromJSON(object.mode) : undefined,
      source: isSet(object.source) ? globalThis.String(object.source) : undefined,
      index: isSet(object.index) ? Long.fromValue(object.index) : undefined,
      boot: isSet(object.boot) ? globalThis.Boolean(object.boot) : undefined,
      autoDelete: isSet(object.autoDelete) ? globalThis.Boolean(object.autoDelete) : undefined,
      license: globalThis.Array.isArray(object?.license) ? object.license.map((e: any) => globalThis.String(e)) : [],
      diskInterface: isSet(object.diskInterface) ? attachedDisk_DiskInterfaceFromJSON(object.diskInterface) : undefined,
      guestOsFeature: globalThis.Array.isArray(object?.guestOsFeature)
        ? object.guestOsFeature.map((e: any) => GuestOsFeature.fromJSON(e))
        : [],
      diskEncryptionKey: isSet(object.diskEncryptionKey)
        ? CustomerEncryptionKey.fromJSON(object.diskEncryptionKey)
        : undefined,
      diskSizeGb: isSet(object.diskSizeGb) ? Long.fromValue(object.diskSizeGb) : undefined,
      savedState: isSet(object.savedState) ? attachedDisk_DiskSavedStateFromJSON(object.savedState) : undefined,
      diskType: isSet(object.diskType) ? globalThis.String(object.diskType) : undefined,
      type: isSet(object.type) ? attachedDisk_DiskTypeFromJSON(object.type) : undefined,
    };
  },

  toJSON(message: AttachedDisk): unknown {
    const obj: any = {};
    if (message.initializeParams !== undefined) {
      obj.initializeParams = AttachedDisk_InitializeParams.toJSON(message.initializeParams);
    }
    if (message.deviceName !== undefined) {
      obj.deviceName = message.deviceName;
    }
    if (message.kind !== undefined) {
      obj.kind = message.kind;
    }
    if (message.diskTypeDeprecated !== undefined) {
      obj.diskTypeDeprecated = attachedDisk_DiskTypeToJSON(message.diskTypeDeprecated);
    }
    if (message.mode !== undefined) {
      obj.mode = attachedDisk_DiskModeToJSON(message.mode);
    }
    if (message.source !== undefined) {
      obj.source = message.source;
    }
    if (message.index !== undefined) {
      obj.index = (message.index || Long.ZERO).toString();
    }
    if (message.boot !== undefined) {
      obj.boot = message.boot;
    }
    if (message.autoDelete !== undefined) {
      obj.autoDelete = message.autoDelete;
    }
    if (message.license?.length) {
      obj.license = message.license;
    }
    if (message.diskInterface !== undefined) {
      obj.diskInterface = attachedDisk_DiskInterfaceToJSON(message.diskInterface);
    }
    if (message.guestOsFeature?.length) {
      obj.guestOsFeature = message.guestOsFeature.map((e) => GuestOsFeature.toJSON(e));
    }
    if (message.diskEncryptionKey !== undefined) {
      obj.diskEncryptionKey = CustomerEncryptionKey.toJSON(message.diskEncryptionKey);
    }
    if (message.diskSizeGb !== undefined) {
      obj.diskSizeGb = (message.diskSizeGb || Long.ZERO).toString();
    }
    if (message.savedState !== undefined) {
      obj.savedState = attachedDisk_DiskSavedStateToJSON(message.savedState);
    }
    if (message.diskType !== undefined) {
      obj.diskType = message.diskType;
    }
    if (message.type !== undefined) {
      obj.type = attachedDisk_DiskTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<AttachedDisk>): AttachedDisk {
    return AttachedDisk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttachedDisk>): AttachedDisk {
    const message = createBaseAttachedDisk();
    message.initializeParams = (object.initializeParams !== undefined && object.initializeParams !== null)
      ? AttachedDisk_InitializeParams.fromPartial(object.initializeParams)
      : undefined;
    message.deviceName = object.deviceName ?? undefined;
    message.kind = object.kind ?? undefined;
    message.diskTypeDeprecated = object.diskTypeDeprecated ?? undefined;
    message.mode = object.mode ?? undefined;
    message.source = object.source ?? undefined;
    message.index = (object.index !== undefined && object.index !== null) ? Long.fromValue(object.index) : undefined;
    message.boot = object.boot ?? undefined;
    message.autoDelete = object.autoDelete ?? undefined;
    message.license = object.license?.map((e) => e) || [];
    message.diskInterface = object.diskInterface ?? undefined;
    message.guestOsFeature = object.guestOsFeature?.map((e) => GuestOsFeature.fromPartial(e)) || [];
    message.diskEncryptionKey = (object.diskEncryptionKey !== undefined && object.diskEncryptionKey !== null)
      ? CustomerEncryptionKey.fromPartial(object.diskEncryptionKey)
      : undefined;
    message.diskSizeGb = (object.diskSizeGb !== undefined && object.diskSizeGb !== null)
      ? Long.fromValue(object.diskSizeGb)
      : undefined;
    message.savedState = object.savedState ?? undefined;
    message.diskType = object.diskType ?? undefined;
    message.type = object.type ?? undefined;
    return message;
  },
};

function createBaseAttachedDisk_InitializeParams(): AttachedDisk_InitializeParams {
  return { diskName: undefined, replicaZones: [] };
}

export const AttachedDisk_InitializeParams: MessageFns<AttachedDisk_InitializeParams> = {
  encode(message: AttachedDisk_InitializeParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.diskName !== undefined) {
      writer.uint32(10).string(message.diskName);
    }
    for (const v of message.replicaZones) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttachedDisk_InitializeParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachedDisk_InitializeParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.diskName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.replicaZones.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttachedDisk_InitializeParams {
    return {
      diskName: isSet(object.diskName) ? globalThis.String(object.diskName) : undefined,
      replicaZones: globalThis.Array.isArray(object?.replicaZones)
        ? object.replicaZones.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AttachedDisk_InitializeParams): unknown {
    const obj: any = {};
    if (message.diskName !== undefined) {
      obj.diskName = message.diskName;
    }
    if (message.replicaZones?.length) {
      obj.replicaZones = message.replicaZones;
    }
    return obj;
  },

  create(base?: DeepPartial<AttachedDisk_InitializeParams>): AttachedDisk_InitializeParams {
    return AttachedDisk_InitializeParams.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttachedDisk_InitializeParams>): AttachedDisk_InitializeParams {
    const message = createBaseAttachedDisk_InitializeParams();
    message.diskName = object.diskName ?? undefined;
    message.replicaZones = object.replicaZones?.map((e) => e) || [];
    return message;
  },
};

function createBaseGuestOsFeature(): GuestOsFeature {
  return { type: undefined };
}

export const GuestOsFeature: MessageFns<GuestOsFeature> = {
  encode(message: GuestOsFeature, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GuestOsFeature {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGuestOsFeature();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GuestOsFeature {
    return { type: isSet(object.type) ? guestOsFeature_FeatureTypeFromJSON(object.type) : undefined };
  },

  toJSON(message: GuestOsFeature): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = guestOsFeature_FeatureTypeToJSON(message.type);
    }
    return obj;
  },

  create(base?: DeepPartial<GuestOsFeature>): GuestOsFeature {
    return GuestOsFeature.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GuestOsFeature>): GuestOsFeature {
    const message = createBaseGuestOsFeature();
    message.type = object.type ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
