// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/backupdr/v1/backupvault.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Status } from "../../../rpc/status.js";
import { BackupApplianceBackupProperties } from "./backupvault_ba.js";
import {
  ComputeInstanceBackupProperties,
  ComputeInstanceDataSourceProperties,
  ComputeInstanceRestoreProperties,
  ComputeInstanceTargetEnvironment,
} from "./backupvault_gce.js";

export const protobufPackage = "google.cloud.backupdr.v1";

/** Backup configuration state. Is the resource configured for backup? */
export enum BackupConfigState {
  /**
   * BACKUP_CONFIG_STATE_UNSPECIFIED - The possible states of backupÂ configuration.
   * Status not set.
   */
  BACKUP_CONFIG_STATE_UNSPECIFIED = 0,
  /**
   * ACTIVE - The data source is actively protected (i.e. there is a
   * BackupPlanAssociation or Appliance SLA pointing to it)
   */
  ACTIVE = 1,
  /** PASSIVE - The data source is no longer protected (but may have backups under it) */
  PASSIVE = 2,
  UNRECOGNIZED = -1,
}

export function backupConfigStateFromJSON(object: any): BackupConfigState {
  switch (object) {
    case 0:
    case "BACKUP_CONFIG_STATE_UNSPECIFIED":
      return BackupConfigState.BACKUP_CONFIG_STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return BackupConfigState.ACTIVE;
    case 2:
    case "PASSIVE":
      return BackupConfigState.PASSIVE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackupConfigState.UNRECOGNIZED;
  }
}

export function backupConfigStateToJSON(object: BackupConfigState): string {
  switch (object) {
    case BackupConfigState.BACKUP_CONFIG_STATE_UNSPECIFIED:
      return "BACKUP_CONFIG_STATE_UNSPECIFIED";
    case BackupConfigState.ACTIVE:
      return "ACTIVE";
    case BackupConfigState.PASSIVE:
      return "PASSIVE";
    case BackupConfigState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** BackupView contains enum options for Partial and Full view. */
export enum BackupView {
  /** BACKUP_VIEW_UNSPECIFIED - If the value is not set, the default 'FULL' view is used. */
  BACKUP_VIEW_UNSPECIFIED = 0,
  /** BACKUP_VIEW_BASIC - Includes basic data about the Backup, but not the full contents. */
  BACKUP_VIEW_BASIC = 1,
  /**
   * BACKUP_VIEW_FULL - Includes all data about the Backup.
   * This is the default value (for both ListBackups and GetBackup).
   */
  BACKUP_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function backupViewFromJSON(object: any): BackupView {
  switch (object) {
    case 0:
    case "BACKUP_VIEW_UNSPECIFIED":
      return BackupView.BACKUP_VIEW_UNSPECIFIED;
    case 1:
    case "BACKUP_VIEW_BASIC":
      return BackupView.BACKUP_VIEW_BASIC;
    case 2:
    case "BACKUP_VIEW_FULL":
      return BackupView.BACKUP_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackupView.UNRECOGNIZED;
  }
}

export function backupViewToJSON(object: BackupView): string {
  switch (object) {
    case BackupView.BACKUP_VIEW_UNSPECIFIED:
      return "BACKUP_VIEW_UNSPECIFIED";
    case BackupView.BACKUP_VIEW_BASIC:
      return "BACKUP_VIEW_BASIC";
    case BackupView.BACKUP_VIEW_FULL:
      return "BACKUP_VIEW_FULL";
    case BackupView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** BackupVaultView contains enum options for Partial and Full view. */
export enum BackupVaultView {
  /** BACKUP_VAULT_VIEW_UNSPECIFIED - If the value is not set, the default 'FULL' view is used. */
  BACKUP_VAULT_VIEW_UNSPECIFIED = 0,
  /** BACKUP_VAULT_VIEW_BASIC - Includes basic data about the Backup Vault, but not the full contents. */
  BACKUP_VAULT_VIEW_BASIC = 1,
  /**
   * BACKUP_VAULT_VIEW_FULL - Includes all data about the Backup Vault.
   * This is the default value (for both ListBackupVaults and GetBackupVault).
   */
  BACKUP_VAULT_VIEW_FULL = 2,
  UNRECOGNIZED = -1,
}

export function backupVaultViewFromJSON(object: any): BackupVaultView {
  switch (object) {
    case 0:
    case "BACKUP_VAULT_VIEW_UNSPECIFIED":
      return BackupVaultView.BACKUP_VAULT_VIEW_UNSPECIFIED;
    case 1:
    case "BACKUP_VAULT_VIEW_BASIC":
      return BackupVaultView.BACKUP_VAULT_VIEW_BASIC;
    case 2:
    case "BACKUP_VAULT_VIEW_FULL":
      return BackupVaultView.BACKUP_VAULT_VIEW_FULL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackupVaultView.UNRECOGNIZED;
  }
}

export function backupVaultViewToJSON(object: BackupVaultView): string {
  switch (object) {
    case BackupVaultView.BACKUP_VAULT_VIEW_UNSPECIFIED:
      return "BACKUP_VAULT_VIEW_UNSPECIFIED";
    case BackupVaultView.BACKUP_VAULT_VIEW_BASIC:
      return "BACKUP_VAULT_VIEW_BASIC";
    case BackupVaultView.BACKUP_VAULT_VIEW_FULL:
      return "BACKUP_VAULT_VIEW_FULL";
    case BackupVaultView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message describing a BackupVault object. */
export interface BackupVault {
  /**
   * Output only. Identifier. Name of the backup vault to create. It must have
   * the
   * format`"projects/{project}/locations/{location}/backupVaults/{backupvault}"`.
   * `{backupvault}` cannot be changed after creation. It must be between 3-63
   * characters long and must be unique within the project and location.
   */
  name: string;
  /**
   * Optional. The description of the BackupVault instance (2048 characters or
   * less).
   */
  description?:
    | string
    | undefined;
  /**
   * Optional. Resource labels to represent user provided metadata.
   * No labels currently defined:
   */
  labels: { [key: string]: string };
  /** Output only. The time when the instance was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time when the instance was updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Required. The default and minimum enforced retention for each backup within
   * the backup vault.  The enforced retention for each backup can be extended.
   */
  backupMinimumEnforcedRetentionDuration?:
    | Duration
    | undefined;
  /**
   * Output only. Set to true when there are no backups nested under this
   * resource.
   */
  deletable?:
    | boolean
    | undefined;
  /**
   * Optional. Server specified ETag for the backup vault resource to
   * prevent simultaneous updates from overwiting each other.
   */
  etag?:
    | string
    | undefined;
  /** Output only. The BackupVault resource instance state. */
  state: BackupVault_State;
  /** Optional. Time after which the BackupVault resource is locked. */
  effectiveTime?:
    | Date
    | undefined;
  /** Output only. The number of backups in this backup vault. */
  backupCount: Long;
  /**
   * Output only. Service account used by the BackupVault Service for this
   * BackupVault.  The user should grant this account permissions in their
   * workload project to enable the service to run backups and restores there.
   */
  serviceAccount: string;
  /** Output only. Total size of the storage used by all backup resources. */
  totalStoredBytes: Long;
  /**
   * Output only. Output only
   * Immutable after resource creation until resource deletion.
   */
  uid: string;
  /**
   * Optional. User annotations. See https://google.aip.dev/128#annotations
   * Stores small amounts of arbitrary data.
   */
  annotations: { [key: string]: string };
  /**
   * Optional. Note: This field is added for future use case and will not be
   * supported in the current release.
   *
   * Optional.
   *
   * Access restriction for the backup vault.
   * Default value is WITHIN_ORGANIZATION if not provided during creation.
   */
  accessRestriction: BackupVault_AccessRestriction;
}

/** Holds the state of the backup vault resource. */
export enum BackupVault_State {
  /** STATE_UNSPECIFIED - State not set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The backup vault is being created. */
  CREATING = 1,
  /** ACTIVE - The backup vault has been created and is fully usable. */
  ACTIVE = 2,
  /** DELETING - The backup vault is being deleted. */
  DELETING = 3,
  /** ERROR - The backup vault is experiencing an issue and might be unusable. */
  ERROR = 4,
  UNRECOGNIZED = -1,
}

export function backupVault_StateFromJSON(object: any): BackupVault_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return BackupVault_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return BackupVault_State.CREATING;
    case 2:
    case "ACTIVE":
      return BackupVault_State.ACTIVE;
    case 3:
    case "DELETING":
      return BackupVault_State.DELETING;
    case 4:
    case "ERROR":
      return BackupVault_State.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackupVault_State.UNRECOGNIZED;
  }
}

export function backupVault_StateToJSON(object: BackupVault_State): string {
  switch (object) {
    case BackupVault_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case BackupVault_State.CREATING:
      return "CREATING";
    case BackupVault_State.ACTIVE:
      return "ACTIVE";
    case BackupVault_State.DELETING:
      return "DELETING";
    case BackupVault_State.ERROR:
      return "ERROR";
    case BackupVault_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Holds the access restriction for the backup vault. */
export enum BackupVault_AccessRestriction {
  /** ACCESS_RESTRICTION_UNSPECIFIED - Access restriction not set. */
  ACCESS_RESTRICTION_UNSPECIFIED = 0,
  /** WITHIN_PROJECT - Access to or from resources outside your current project will be denied. */
  WITHIN_PROJECT = 1,
  /**
   * WITHIN_ORGANIZATION - Access to or from resources outside your current organization will be
   * denied.
   */
  WITHIN_ORGANIZATION = 2,
  /** UNRESTRICTED - No access restriction. */
  UNRESTRICTED = 3,
  UNRECOGNIZED = -1,
}

export function backupVault_AccessRestrictionFromJSON(object: any): BackupVault_AccessRestriction {
  switch (object) {
    case 0:
    case "ACCESS_RESTRICTION_UNSPECIFIED":
      return BackupVault_AccessRestriction.ACCESS_RESTRICTION_UNSPECIFIED;
    case 1:
    case "WITHIN_PROJECT":
      return BackupVault_AccessRestriction.WITHIN_PROJECT;
    case 2:
    case "WITHIN_ORGANIZATION":
      return BackupVault_AccessRestriction.WITHIN_ORGANIZATION;
    case 3:
    case "UNRESTRICTED":
      return BackupVault_AccessRestriction.UNRESTRICTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackupVault_AccessRestriction.UNRECOGNIZED;
  }
}

export function backupVault_AccessRestrictionToJSON(object: BackupVault_AccessRestriction): string {
  switch (object) {
    case BackupVault_AccessRestriction.ACCESS_RESTRICTION_UNSPECIFIED:
      return "ACCESS_RESTRICTION_UNSPECIFIED";
    case BackupVault_AccessRestriction.WITHIN_PROJECT:
      return "WITHIN_PROJECT";
    case BackupVault_AccessRestriction.WITHIN_ORGANIZATION:
      return "WITHIN_ORGANIZATION";
    case BackupVault_AccessRestriction.UNRESTRICTED:
      return "UNRESTRICTED";
    case BackupVault_AccessRestriction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface BackupVault_LabelsEntry {
  key: string;
  value: string;
}

export interface BackupVault_AnnotationsEntry {
  key: string;
  value: string;
}

/**
 * Message describing a DataSource object.
 * Datasource object used to represent Datasource details for both admin and
 * basic view.
 */
export interface DataSource {
  /**
   * Output only. Identifier. Name of the datasource to create.
   * It must have the
   * format`"projects/{project}/locations/{location}/backupVaults/{backupvault}/dataSources/{datasource}"`.
   * `{datasource}` cannot be changed after creation. It must be between 3-63
   * characters long and must be unique within the backup vault.
   */
  name: string;
  /** Output only. The DataSource resource instance state. */
  state: DataSource_State;
  /**
   * Optional. Resource labels to represent user provided metadata.
   * No labels currently defined:
   */
  labels: { [key: string]: string };
  /** Output only. The time when the instance was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time when the instance was updated. */
  updateTime?:
    | Date
    | undefined;
  /** Number of backups in the data source. */
  backupCount?:
    | Long
    | undefined;
  /**
   * Server specified ETag for the ManagementServer resource to prevent
   * simultaneous updates from overwiting each other.
   */
  etag?:
    | string
    | undefined;
  /** The number of bytes (metadata and data) stored in this datasource. */
  totalStoredBytes?:
    | Long
    | undefined;
  /** Output only. The backup configuration state. */
  configState: BackupConfigState;
  /** Output only. Details of how the resource is configured for backup. */
  backupConfigInfo:
    | BackupConfigInfo
    | undefined;
  /**
   * The backed up resource is a Google Cloud resource.
   * The word 'DataSource' was included in the names to indicate that this is
   * the representation of the Google Cloud resource used within the
   * DataSource object.
   */
  dataSourceGcpResource?:
    | DataSourceGcpResource
    | undefined;
  /** The backed up resource is a backup appliance application. */
  dataSourceBackupApplianceApplication?: DataSourceBackupApplianceApplication | undefined;
}

/** Holds the state of the data source resource. */
export enum DataSource_State {
  /** STATE_UNSPECIFIED - State not set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The data source is being created. */
  CREATING = 1,
  /** ACTIVE - The data source has been created and is fully usable. */
  ACTIVE = 2,
  /** DELETING - The data source is being deleted. */
  DELETING = 3,
  /** ERROR - The data source is experiencing an issue and might be unusable. */
  ERROR = 4,
  UNRECOGNIZED = -1,
}

export function dataSource_StateFromJSON(object: any): DataSource_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return DataSource_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return DataSource_State.CREATING;
    case 2:
    case "ACTIVE":
      return DataSource_State.ACTIVE;
    case 3:
    case "DELETING":
      return DataSource_State.DELETING;
    case 4:
    case "ERROR":
      return DataSource_State.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSource_State.UNRECOGNIZED;
  }
}

export function dataSource_StateToJSON(object: DataSource_State): string {
  switch (object) {
    case DataSource_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case DataSource_State.CREATING:
      return "CREATING";
    case DataSource_State.ACTIVE:
      return "ACTIVE";
    case DataSource_State.DELETING:
      return "DELETING";
    case DataSource_State.ERROR:
      return "ERROR";
    case DataSource_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DataSource_LabelsEntry {
  key: string;
  value: string;
}

/**
 * BackupConfigInfo has information about how the resource is configured
 * for Backup and about the most recent backup to this vault.
 */
export interface BackupConfigInfo {
  /** Output only. The status of the last backup to this BackupVault */
  lastBackupState: BackupConfigInfo_LastBackupState;
  /**
   * Output only. If the last backup were successful, this field has the
   * consistency date.
   */
  lastSuccessfulBackupConsistencyTime:
    | Date
    | undefined;
  /** Output only. If the last backup failed, this field has the error message. */
  lastBackupError:
    | Status
    | undefined;
  /** Configuration for a Google Cloud resource. */
  gcpBackupConfig?:
    | GcpBackupConfig
    | undefined;
  /** Configuration for an application backed up by a Backup Appliance. */
  backupApplianceBackupConfig?: BackupApplianceBackupConfig | undefined;
}

/**
 * LastBackupstate tracks whether the last backup was not yet started,
 * successful, failed, or could not be run because of the lack of permissions.
 */
export enum BackupConfigInfo_LastBackupState {
  /** LAST_BACKUP_STATE_UNSPECIFIED - Status not set. */
  LAST_BACKUP_STATE_UNSPECIFIED = 0,
  /** FIRST_BACKUP_PENDING - The first backup has not yet completed */
  FIRST_BACKUP_PENDING = 1,
  /** SUCCEEDED - The most recent backup was successful */
  SUCCEEDED = 2,
  /** FAILED - The most recent backup failed */
  FAILED = 3,
  /**
   * PERMISSION_DENIED - The most recent backup could not be run/failed because of the lack of
   * permissions
   */
  PERMISSION_DENIED = 4,
  UNRECOGNIZED = -1,
}

export function backupConfigInfo_LastBackupStateFromJSON(object: any): BackupConfigInfo_LastBackupState {
  switch (object) {
    case 0:
    case "LAST_BACKUP_STATE_UNSPECIFIED":
      return BackupConfigInfo_LastBackupState.LAST_BACKUP_STATE_UNSPECIFIED;
    case 1:
    case "FIRST_BACKUP_PENDING":
      return BackupConfigInfo_LastBackupState.FIRST_BACKUP_PENDING;
    case 2:
    case "SUCCEEDED":
      return BackupConfigInfo_LastBackupState.SUCCEEDED;
    case 3:
    case "FAILED":
      return BackupConfigInfo_LastBackupState.FAILED;
    case 4:
    case "PERMISSION_DENIED":
      return BackupConfigInfo_LastBackupState.PERMISSION_DENIED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BackupConfigInfo_LastBackupState.UNRECOGNIZED;
  }
}

export function backupConfigInfo_LastBackupStateToJSON(object: BackupConfigInfo_LastBackupState): string {
  switch (object) {
    case BackupConfigInfo_LastBackupState.LAST_BACKUP_STATE_UNSPECIFIED:
      return "LAST_BACKUP_STATE_UNSPECIFIED";
    case BackupConfigInfo_LastBackupState.FIRST_BACKUP_PENDING:
      return "FIRST_BACKUP_PENDING";
    case BackupConfigInfo_LastBackupState.SUCCEEDED:
      return "SUCCEEDED";
    case BackupConfigInfo_LastBackupState.FAILED:
      return "FAILED";
    case BackupConfigInfo_LastBackupState.PERMISSION_DENIED:
      return "PERMISSION_DENIED";
    case BackupConfigInfo_LastBackupState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * GcpBackupConfig captures the Backup configuration details for Google Cloud
 * resources. All Google Cloud resources regardless of type are protected with
 * backup plan associations.
 */
export interface GcpBackupConfig {
  /** The name of the backup plan. */
  backupPlan: string;
  /** The description of the backup plan. */
  backupPlanDescription: string;
  /** The name of the backup plan association. */
  backupPlanAssociation: string;
  /** The names of the backup plan rules which point to this backupvault */
  backupPlanRules: string[];
}

/**
 * BackupApplianceBackupConfig captures the backup configuration for
 * applications that are protected by Backup Appliances.
 */
export interface BackupApplianceBackupConfig {
  /** The name of the backup appliance. */
  backupApplianceName: string;
  /** The ID of the backup appliance. */
  backupApplianceId: Long;
  /** The ID of the SLA of this application. */
  slaId: Long;
  /** The name of the application. */
  applicationName: string;
  /** The name of the host where the application is running. */
  hostName: string;
  /** The name of the SLT associated with the application. */
  sltName: string;
  /** The name of the SLP associated with the application. */
  slpName: string;
}

/**
 * DataSourceGcpResource is used for protected resources that are Google Cloud
 * Resources. This name is easeier to understand than GcpResourceDataSource or
 * GcpDataSourceResource
 */
export interface DataSourceGcpResource {
  /**
   * Output only. Full resource pathname URL of the source Google Cloud
   * resource.
   */
  gcpResourcename: string;
  /** Location of the resource: <region>/<zone>/"global"/"unspecified". */
  location: string;
  /**
   * The type of the Google Cloud resource. Use the Unified Resource Type,
   * eg. compute.googleapis.com/Instance.
   */
  type: string;
  /**
   * ComputeInstanceDataSourceProperties has a subset of Compute Instance
   * properties that are useful at the Datasource level.
   */
  computeInstanceDatasourceProperties?: ComputeInstanceDataSourceProperties | undefined;
}

/**
 * BackupApplianceApplication describes a Source Resource when it is an
 * application backed up by a BackupAppliance.
 */
export interface DataSourceBackupApplianceApplication {
  /** The name of the Application as known to the Backup Appliance. */
  applicationName: string;
  /** Appliance name. */
  backupAppliance: string;
  /** Appliance Id of the Backup Appliance. */
  applianceId: Long;
  /** The type of the application. e.g. VMBackup */
  type: string;
  /** The appid field of the application within the Backup Appliance. */
  applicationId: Long;
  /** Hostname of the host where the application is running. */
  hostname: string;
  /** Hostid of the application host. */
  hostId: Long;
}

/**
 * ServiceLockInfo represents the details of a lock taken by the service on a
 * Backup resource.
 */
export interface ServiceLockInfo {
  /**
   * Output only. The name of the operation that created this lock.
   * The lock will automatically be released when the operation completes.
   */
  operation: string;
}

/**
 * BackupApplianceLockInfo contains metadata about the backupappliance that
 * created the lock.
 */
export interface BackupApplianceLockInfo {
  /** Required. The ID of the backup/recovery appliance that created this lock. */
  backupApplianceId: Long;
  /** Required. The name of the backup/recovery appliance that created this lock. */
  backupApplianceName: string;
  /**
   * Required. The reason for the lock: e.g. MOUNT/RESTORE/BACKUP/etc.  The
   * value of this string is only meaningful to the client and it is not
   * interpreted by the BackupVault service.
   */
  lockReason: string;
  /** The job name on the backup/recovery appliance that created this lock. */
  jobName?:
    | string
    | undefined;
  /** The image name that depends on this Backup. */
  backupImage?:
    | string
    | undefined;
  /** The SLA on the backup/recovery appliance that owns the lock. */
  slaId?: Long | undefined;
}

/**
 * BackupLock represents a single lock on a Backup resource.  An unexpired
 * lock on a Backup prevents the Backup from being deleted.
 */
export interface BackupLock {
  /**
   * Required. The time after which this lock is not considered valid and will
   * no longer protect the Backup from deletion.
   */
  lockUntilTime:
    | Date
    | undefined;
  /**
   * If the client is a backup and recovery appliance, this
   * contains metadata about why the lock exists.
   */
  backupApplianceLockInfo?:
    | BackupApplianceLockInfo
    | undefined;
  /**
   * Output only. Contains metadata about the lock exist for Google Cloud
   * native backups.
   */
  serviceLockInfo?: ServiceLockInfo | undefined;
}

/** Message describing a Backup object. */
export interface Backup {
  /**
   * Output only. Identifier. Name of the backup to create. It must have the
   * format`"projects/<project>/locations/<location>/backupVaults/<backupvault>/dataSources/{datasource}/backups/{backup}"`.
   * `{backup}` cannot be changed after creation. It must be between 3-63
   * characters long and must be unique within the datasource.
   */
  name: string;
  /**
   * Output only. The description of the Backup instance (2048 characters or
   * less).
   */
  description?:
    | string
    | undefined;
  /** Output only. The time when the instance was created. */
  createTime?:
    | Date
    | undefined;
  /** Output only. The time when the instance was updated. */
  updateTime?:
    | Date
    | undefined;
  /**
   * Optional. Resource labels to represent user provided metadata.
   * No labels currently defined.
   */
  labels: { [key: string]: string };
  /** Optional. The backup can not be deleted before this time. */
  enforcedRetentionEndTime?:
    | Date
    | undefined;
  /** Optional. When this backup is automatically expired. */
  expireTime?:
    | Date
    | undefined;
  /**
   * Output only. The point in time when this backup was captured from the
   * source.
   */
  consistencyTime?:
    | Date
    | undefined;
  /**
   * Optional. Server specified ETag to prevent updates from overwriting each
   * other.
   */
  etag?:
    | string
    | undefined;
  /** Output only. The Backup resource instance state. */
  state: Backup_State;
  /**
   * Output only. The list of BackupLocks taken by the service to prevent the
   * deletion of the backup.
   */
  serviceLocks: BackupLock[];
  /** Optional. The list of BackupLocks taken by the accessor Backup Appliance. */
  backupApplianceLocks: BackupLock[];
  /** Output only. Compute Engine specific backup properties. */
  computeInstanceBackupProperties?:
    | ComputeInstanceBackupProperties
    | undefined;
  /** Output only. Backup Appliance specific backup properties. */
  backupApplianceBackupProperties?:
    | BackupApplianceBackupProperties
    | undefined;
  /** Output only. Type of the backup, unspecified, scheduled or ondemand. */
  backupType: Backup_BackupType;
  /** Output only. Configuration for a Google Cloud resource. */
  gcpBackupPlanInfo?:
    | Backup_GCPBackupPlanInfo
    | undefined;
  /** Output only. source resource size in bytes at the time of the backup. */
  resourceSizeBytes: Long;
}

/** Holds the state of the backup resource. */
export enum Backup_State {
  /** STATE_UNSPECIFIED - State not set. */
  STATE_UNSPECIFIED = 0,
  /** CREATING - The backup is being created. */
  CREATING = 1,
  /** ACTIVE - The backup has been created and is fully usable. */
  ACTIVE = 2,
  /** DELETING - The backup is being deleted. */
  DELETING = 3,
  /** ERROR - The backup is experiencing an issue and might be unusable. */
  ERROR = 4,
  UNRECOGNIZED = -1,
}

export function backup_StateFromJSON(object: any): Backup_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Backup_State.STATE_UNSPECIFIED;
    case 1:
    case "CREATING":
      return Backup_State.CREATING;
    case 2:
    case "ACTIVE":
      return Backup_State.ACTIVE;
    case 3:
    case "DELETING":
      return Backup_State.DELETING;
    case 4:
    case "ERROR":
      return Backup_State.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Backup_State.UNRECOGNIZED;
  }
}

export function backup_StateToJSON(object: Backup_State): string {
  switch (object) {
    case Backup_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Backup_State.CREATING:
      return "CREATING";
    case Backup_State.ACTIVE:
      return "ACTIVE";
    case Backup_State.DELETING:
      return "DELETING";
    case Backup_State.ERROR:
      return "ERROR";
    case Backup_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type of the backup, scheduled or ondemand. */
export enum Backup_BackupType {
  /** BACKUP_TYPE_UNSPECIFIED - Backup type is unspecified. */
  BACKUP_TYPE_UNSPECIFIED = 0,
  /** SCHEDULED - Scheduled backup. */
  SCHEDULED = 1,
  /** ON_DEMAND - On demand backup. */
  ON_DEMAND = 2,
  UNRECOGNIZED = -1,
}

export function backup_BackupTypeFromJSON(object: any): Backup_BackupType {
  switch (object) {
    case 0:
    case "BACKUP_TYPE_UNSPECIFIED":
      return Backup_BackupType.BACKUP_TYPE_UNSPECIFIED;
    case 1:
    case "SCHEDULED":
      return Backup_BackupType.SCHEDULED;
    case 2:
    case "ON_DEMAND":
      return Backup_BackupType.ON_DEMAND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Backup_BackupType.UNRECOGNIZED;
  }
}

export function backup_BackupTypeToJSON(object: Backup_BackupType): string {
  switch (object) {
    case Backup_BackupType.BACKUP_TYPE_UNSPECIFIED:
      return "BACKUP_TYPE_UNSPECIFIED";
    case Backup_BackupType.SCHEDULED:
      return "SCHEDULED";
    case Backup_BackupType.ON_DEMAND:
      return "ON_DEMAND";
    case Backup_BackupType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * GCPBackupPlanInfo captures the plan configuration details of Google Cloud
 * resources at the time of backup.
 */
export interface Backup_GCPBackupPlanInfo {
  /**
   * Resource name of backup plan by which workload is protected at the time
   * of the backup.
   * Format:
   * projects/{project}/locations/{location}/backupPlans/{backupPlanId}
   */
  backupPlan: string;
  /**
   * The rule id of the backup plan which triggered this backup in case of
   * scheduled backup or used for
   */
  backupPlanRuleId: string;
}

export interface Backup_LabelsEntry {
  key: string;
  value: string;
}

/** Message for creating a BackupVault. */
export interface CreateBackupVaultRequest {
  /** Required. Value for parent. */
  parent: string;
  /**
   * Required. ID of the requesting object
   * If auto-generating ID server-side, remove this field and
   * backup_vault_id from the method_signature of Create RPC
   */
  backupVaultId: string;
  /** Required. The resource being created */
  backupVault:
    | BackupVault
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. Only validate the request, but do not perform mutations.
   * The default is 'false'.
   */
  validateOnly: boolean;
}

/** Request message for listing backupvault stores. */
export interface ListBackupVaultsRequest {
  /**
   * Required. The project and location for which to retrieve backupvault stores
   * information, in the format 'projects/{project_id}/locations/{location}'. In
   * Cloud Backup and DR, locations map to Google Cloud regions, for example
   * **us-central1**.
   * To retrieve backupvault stores for all locations, use "-" for the
   * '{location}' value.
   */
  parent: string;
  /**
   * Optional. Requested page size. Server may return fewer items than
   * requested. If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** Optional. A token identifying a page of results the server should return. */
  pageToken: string;
  /** Optional. Filtering results. */
  filter: string;
  /** Optional. Hint for how to order the results. */
  orderBy: string;
  /**
   * Optional. Reserved for future use to provide a BASIC & FULL view of Backup
   * Vault.
   */
  view: BackupVaultView;
}

/** Response message for listing BackupVaults. */
export interface ListBackupVaultsResponse {
  /**
   * The list of BackupVault instances in the project for the specified
   * location.
   *
   * If the '{location}' value in the request is "-", the response contains a
   * list of instances from all locations. In case any location is unreachable,
   * the response will only return backup vaults in reachable locations and
   * the 'unreachable' field will be populated with a list of unreachable
   * locations.
   */
  backupVaults: BackupVault[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for fetching usable BackupVaults. */
export interface FetchUsableBackupVaultsRequest {
  /**
   * Required. The project and location for which to retrieve backupvault stores
   * information, in the format 'projects/{project_id}/locations/{location}'. In
   * Cloud Backup and DR, locations map to Google Cloud regions, for example
   * **us-central1**.
   * To retrieve backupvault stores for all locations, use "-" for the
   * '{location}' value.
   */
  parent: string;
  /**
   * Optional. Requested page size. Server may return fewer items than
   * requested. If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** Optional. A token identifying a page of results the server should return. */
  pageToken: string;
  /** Optional. Filtering results. */
  filter: string;
  /** Optional. Hint for how to order the results. */
  orderBy: string;
}

/** Response message for fetching usable BackupVaults. */
export interface FetchUsableBackupVaultsResponse {
  /**
   * The list of BackupVault instances in the project for the specified
   * location.
   *
   * If the '{location}' value in the request is "-", the response contains a
   * list of instances from all locations. In case any location is unreachable,
   * the response will only return backup vaults in reachable locations and
   * the 'unreachable' field will be populated with a list of unreachable
   * locations.
   */
  backupVaults: BackupVault[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for getting a BackupVault. */
export interface GetBackupVaultRequest {
  /**
   * Required. Name of the backupvault store resource name, in the format
   * 'projects/{project_id}/locations/{location}/backupVaults/{resource_name}'
   */
  name: string;
  /**
   * Optional. Reserved for future use to provide a BASIC & FULL view of Backup
   * Vault
   */
  view: BackupVaultView;
}

/** Request message for updating a BackupVault. */
export interface UpdateBackupVaultRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * BackupVault resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then the request will fail.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated */
  backupVault:
    | BackupVault
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. Only validate the request, but do not perform mutations.
   * The default is 'false'.
   */
  validateOnly: boolean;
  /**
   * Optional. If set to true, will not check plan duration against backup vault
   * enforcement duration.
   */
  force: boolean;
}

/** Message for deleting a BackupVault. */
export interface DeleteBackupVaultRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Optional. If set to true, any data source from this backup vault will also
   * be deleted.
   */
  force: boolean;
  /**
   * The current etag of the backup vault.
   * If an etag is provided and does not match the current etag of the
   * connection, deletion will be blocked.
   */
  etag: string;
  /**
   * Optional. Only validate the request, but do not perform mutations.
   * The default is 'false'.
   */
  validateOnly: boolean;
  /**
   * Optional. If true and the BackupVault is not found, the request will
   * succeed but no action will be taken.
   */
  allowMissing: boolean;
}

/** Request message for listing DataSources. */
export interface ListDataSourcesRequest {
  /**
   * Required. The project and location for which to retrieve data
   * sources information, in the format
   * 'projects/{project_id}/locations/{location}'. In Cloud Backup and DR,
   * locations map to Google Cloud regions, for example **us-central1**.
   * To retrieve data sources for all locations, use "-" for the
   * '{location}' value.
   */
  parent: string;
  /**
   * Optional. Requested page size. Server may return fewer items than
   * requested. If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** Optional. A token identifying a page of results the server should return. */
  pageToken: string;
  /** Optional. Filtering results. */
  filter: string;
  /** Optional. Hint for how to order the results. */
  orderBy: string;
}

/** Response message for listing DataSources. */
export interface ListDataSourcesResponse {
  /**
   * The list of DataSource instances in the project for the specified
   * location.
   *
   * If the '{location}' value in the request is "-", the response contains a
   * list of instances from all locations. In case any location is unreachable,
   * the response will only return data sources in reachable locations
   * and the 'unreachable' field will be populated with a list of unreachable
   * locations.
   */
  dataSources: DataSource[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for getting a DataSource instance. */
export interface GetDataSourceRequest {
  /**
   * Required. Name of the data source resource name, in the format
   * 'projects/{project_id}/locations/{location}/backupVaults/{resource_name}/dataSource/{resource_name}'
   */
  name: string;
}

/** Request message for updating a data source instance. */
export interface UpdateDataSourceRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * DataSource resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then the request will fail.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated */
  dataSource:
    | DataSource
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /** Optional. Enable upsert. */
  allowMissing: boolean;
}

/** Message for deleting a DataSource. */
export interface RemoveDataSourceRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for SetStatusInternal method. */
export interface SetInternalStatusRequest {
  /**
   * Required. The resource name of the instance, in the format
   * 'projects/* /locations/* /backupVaults/* /dataSources/'.
   */
  dataSource: string;
  /**
   * Required. The value required for this method to work.  This field must be
   * the 32-byte SHA256 hash of the DataSourceID.  The DataSourceID used here is
   * only the final piece of the fully qualified resource path for this
   * DataSource (i.e. the part after '.../dataSources/'). This field exists to
   * make this method difficult to call since it is intended for use only by
   * Backup Appliances.
   */
  value: Buffer;
  /** Required. Output only. The new BackupConfigState to set for the DataSource. */
  backupConfigState: BackupConfigState;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request. The request
   * ID must be a valid UUID with the exception that zero UUID is not supported
   * (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Response message from SetStatusInternal method. */
export interface SetInternalStatusResponse {
}

/** request message for InitiateBackup. */
export interface InitiateBackupRequest {
  /**
   * Required. The resource name of the instance, in the format
   * 'projects/* /locations/* /backupVaults/* /dataSources/'.
   */
  dataSource: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /** Required. Resource ID of the Backup resource. */
  backupId: string;
}

/** Response message for InitiateBackup. */
export interface InitiateBackupResponse {
  /** The name of the backup that was created. */
  backup: string;
  /** The generation id of the new backup. */
  newBackupGenerationId: number;
  /**
   * The generation id of the base backup. It is needed for the incremental
   * backups.
   */
  baseBackupGenerationId: number;
}

/** request message for AbandonBackup. */
export interface AbandonBackupRequest {
  /**
   * Required. The resource name of the instance, in the format
   * 'projects/* /locations/* /backupVaults/* /dataSources/'.
   */
  dataSource: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for finalizing a Backup. */
export interface FinalizeBackupRequest {
  /**
   * Required. The resource name of the instance, in the format
   * 'projects/* /locations/* /backupVaults/* /dataSources/'.
   */
  dataSource: string;
  /** This will be assigned to the description field of the newly created Backup. */
  description?:
    | string
    | undefined;
  /**
   * The point in time when this backup was captured from the source.  This will
   * be assigned to the consistency_time field of the newly created Backup.
   */
  consistencyTime?:
    | Date
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /**
   * Required. Resource ID of the Backup resource to be finalized.  This must be
   * the same backup_id that was used in the InitiateBackupRequest.
   */
  backupId: string;
  /**
   * The earliest timestamp of data available in this Backup.  This will set on
   * the newly created Backup.
   */
  recoveryRangeStartTime?:
    | Date
    | undefined;
  /**
   * The latest timestamp of data available in this Backup.  This will be set on
   * the newly created Backup.
   */
  recoveryRangeEndTime?:
    | Date
    | undefined;
  /**
   * The ExpireTime on the backup will be set to FinalizeTime plus this
   * duration.  If the resulting ExpireTime is less than
   * EnforcedRetentionEndTime, then ExpireTime is set to
   * EnforcedRetentionEndTime.
   */
  retentionDuration?: Duration | undefined;
}

/** Request message for FetchAccessToken. */
export interface FetchAccessTokenRequest {
  /**
   * Required. The resource name for the location for which static IPs should be
   * returned.
   * Must be in the format
   * 'projects/* /locations/* /backupVaults/* /dataSources'.
   */
  name: string;
  /** Required. The generation of the backup to update. */
  generationId: number;
}

/** Response message for FetchAccessToken. */
export interface FetchAccessTokenResponse {
  /** The location in bucket that can be used for reading. */
  readLocation: string;
  /** The location in bucket that can be used for writing. */
  writeLocation: string;
  /** The downscoped token that was created. */
  token: string;
  /** The token is valid until this time. */
  expireTime: Date | undefined;
}

/** Request message for listing Backups. */
export interface ListBackupsRequest {
  /**
   * Required. The project and location for which to retrieve backup
   * information, in the format
   * 'projects/{project_id}/locations/{location}'. In Cloud Backup and DR,
   * locations map to Google Cloud regions, for example **us-central1**.
   * To retrieve data sources for all locations, use "-" for the
   * '{location}' value.
   */
  parent: string;
  /**
   * Optional. Requested page size. Server may return fewer items than
   * requested. If unspecified, server will pick an appropriate default.
   */
  pageSize: number;
  /** Optional. A token identifying a page of results the server should return. */
  pageToken: string;
  /** Optional. Filtering results. */
  filter: string;
  /** Optional. Hint for how to order the results. */
  orderBy: string;
  /**
   * Optional. Reserved for future use to provide a BASIC & FULL view of Backup
   * resource.
   */
  view: BackupView;
}

/** Response message for listing Backups. */
export interface ListBackupsResponse {
  /**
   * The list of Backup instances in the project for the specified
   * location.
   *
   * If the '{location}' value in the request is "-", the response contains a
   * list of instances from all locations. In case any location is unreachable,
   * the response will only return data sources in reachable locations
   * and the 'unreachable' field will be populated with a list of unreachable
   * locations.
   */
  backups: Backup[];
  /** A token identifying a page of results the server should return. */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachable: string[];
}

/** Request message for getting a Backup. */
export interface GetBackupRequest {
  /**
   * Required. Name of the data source resource name, in the format
   * 'projects/{project_id}/locations/{location}/backupVaults/{backupVault}/dataSources/{datasource}/backups/{backup}'
   */
  name: string;
  /**
   * Optional. Reserved for future use to provide a BASIC & FULL view of Backup
   * resource.
   */
  view: BackupView;
}

/** Request message for updating a Backup. */
export interface UpdateBackupRequest {
  /**
   * Required. Field mask is used to specify the fields to be overwritten in the
   * Backup resource by the update.
   * The fields specified in the update_mask are relative to the resource, not
   * the full request. A field will be overwritten if it is in the mask. If the
   * user does not provide a mask then the request will fail.
   */
  updateMask:
    | string[]
    | undefined;
  /** Required. The resource being updated */
  backup:
    | Backup
    | undefined;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes since the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Message for deleting a Backup. */
export interface DeleteBackupRequest {
  /** Required. Name of the resource. */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
}

/** Request message for restoring from a Backup. */
export interface RestoreBackupRequest {
  /**
   * Required. The resource name of the Backup instance, in the format
   * 'projects/* /locations/* /backupVaults/* /dataSources/* /backups/'.
   */
  name: string;
  /**
   * Optional. An optional request ID to identify requests. Specify a unique
   * request ID so that if you must retry your request, the server will know to
   * ignore the request if it has already been completed. The server will
   * guarantee that for at least 60 minutes after the first request.
   *
   * For example, consider a situation where you make an initial request and
   * the request times out. If you make the request again with the same request
   * ID, the server can check if original operation with the same request ID
   * was received, and if so, will ignore the second request. This prevents
   * clients from accidentally creating duplicate commitments.
   *
   * The request ID must be a valid UUID with the exception that zero UUID is
   * not supported (00000000-0000-0000-0000-000000000000).
   */
  requestId: string;
  /** Compute Engine target environment to be used during restore. */
  computeInstanceTargetEnvironment?:
    | ComputeInstanceTargetEnvironment
    | undefined;
  /** Compute Engine instance properties to be overridden during restore. */
  computeInstanceRestoreProperties?: ComputeInstanceRestoreProperties | undefined;
}

/** Response message for restoring from a Backup. */
export interface RestoreBackupResponse {
  /** Details of the target resource created/modified as part of restore. */
  targetResource: TargetResource | undefined;
}

/** Details of the target resource created/modified as part of restore. */
export interface TargetResource {
  /** Details of the native Google Cloud resource created as part of restore. */
  gcpResource?: GcpResource | undefined;
}

/** Minimum details to identify a Google Cloud resource */
export interface GcpResource {
  /** Name of the Google Cloud resource. */
  gcpResourcename: string;
  /** Location of the resource: <region>/<zone>/"global"/"unspecified". */
  location: string;
  /**
   * Type of the resource. Use the Unified Resource Type,
   * eg. compute.googleapis.com/Instance.
   */
  type: string;
}

function createBaseBackupVault(): BackupVault {
  return {
    name: "",
    description: undefined,
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    backupMinimumEnforcedRetentionDuration: undefined,
    deletable: undefined,
    etag: undefined,
    state: 0,
    effectiveTime: undefined,
    backupCount: Long.ZERO,
    serviceAccount: "",
    totalStoredBytes: Long.ZERO,
    uid: "",
    annotations: {},
    accessRestriction: 0,
  };
}

export const BackupVault: MessageFns<BackupVault> = {
  encode(message: BackupVault, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      BackupVault_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    if (message.backupMinimumEnforcedRetentionDuration !== undefined) {
      Duration.encode(message.backupMinimumEnforcedRetentionDuration, writer.uint32(162).fork()).join();
    }
    if (message.deletable !== undefined) {
      writer.uint32(64).bool(message.deletable);
    }
    if (message.etag !== undefined) {
      writer.uint32(74).string(message.etag);
    }
    if (message.state !== 0) {
      writer.uint32(80).int32(message.state);
    }
    if (message.effectiveTime !== undefined) {
      Timestamp.encode(toTimestamp(message.effectiveTime), writer.uint32(98).fork()).join();
    }
    if (!message.backupCount.equals(Long.ZERO)) {
      writer.uint32(136).int64(message.backupCount.toString());
    }
    if (message.serviceAccount !== "") {
      writer.uint32(146).string(message.serviceAccount);
    }
    if (!message.totalStoredBytes.equals(Long.ZERO)) {
      writer.uint32(152).int64(message.totalStoredBytes.toString());
    }
    if (message.uid !== "") {
      writer.uint32(170).string(message.uid);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      BackupVault_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(178).fork()).join();
    });
    if (message.accessRestriction !== 0) {
      writer.uint32(192).int32(message.accessRestriction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupVault {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupVault();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = BackupVault_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.backupMinimumEnforcedRetentionDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.deletable = reader.bool();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.effectiveTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.backupCount = Long.fromString(reader.int64().toString());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.totalStoredBytes = Long.fromString(reader.int64().toString());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          const entry22 = BackupVault_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry22.value !== undefined) {
            message.annotations[entry22.key] = entry22.value;
          }
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.accessRestriction = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupVault {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      backupMinimumEnforcedRetentionDuration: isSet(object.backupMinimumEnforcedRetentionDuration)
        ? Duration.fromJSON(object.backupMinimumEnforcedRetentionDuration)
        : undefined,
      deletable: isSet(object.deletable) ? globalThis.Boolean(object.deletable) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : undefined,
      state: isSet(object.state) ? backupVault_StateFromJSON(object.state) : 0,
      effectiveTime: isSet(object.effectiveTime) ? fromJsonTimestamp(object.effectiveTime) : undefined,
      backupCount: isSet(object.backupCount) ? Long.fromValue(object.backupCount) : Long.ZERO,
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      totalStoredBytes: isSet(object.totalStoredBytes) ? Long.fromValue(object.totalStoredBytes) : Long.ZERO,
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      accessRestriction: isSet(object.accessRestriction)
        ? backupVault_AccessRestrictionFromJSON(object.accessRestriction)
        : 0,
    };
  },

  toJSON(message: BackupVault): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.backupMinimumEnforcedRetentionDuration !== undefined) {
      obj.backupMinimumEnforcedRetentionDuration = Duration.toJSON(message.backupMinimumEnforcedRetentionDuration);
    }
    if (message.deletable !== undefined) {
      obj.deletable = message.deletable;
    }
    if (message.etag !== undefined) {
      obj.etag = message.etag;
    }
    if (message.state !== 0) {
      obj.state = backupVault_StateToJSON(message.state);
    }
    if (message.effectiveTime !== undefined) {
      obj.effectiveTime = message.effectiveTime.toISOString();
    }
    if (!message.backupCount.equals(Long.ZERO)) {
      obj.backupCount = (message.backupCount || Long.ZERO).toString();
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (!message.totalStoredBytes.equals(Long.ZERO)) {
      obj.totalStoredBytes = (message.totalStoredBytes || Long.ZERO).toString();
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.accessRestriction !== 0) {
      obj.accessRestriction = backupVault_AccessRestrictionToJSON(message.accessRestriction);
    }
    return obj;
  },

  create(base?: DeepPartial<BackupVault>): BackupVault {
    return BackupVault.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupVault>): BackupVault {
    const message = createBaseBackupVault();
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.backupMinimumEnforcedRetentionDuration =
      (object.backupMinimumEnforcedRetentionDuration !== undefined &&
          object.backupMinimumEnforcedRetentionDuration !== null)
        ? Duration.fromPartial(object.backupMinimumEnforcedRetentionDuration)
        : undefined;
    message.deletable = object.deletable ?? undefined;
    message.etag = object.etag ?? undefined;
    message.state = object.state ?? 0;
    message.effectiveTime = object.effectiveTime ?? undefined;
    message.backupCount = (object.backupCount !== undefined && object.backupCount !== null)
      ? Long.fromValue(object.backupCount)
      : Long.ZERO;
    message.serviceAccount = object.serviceAccount ?? "";
    message.totalStoredBytes = (object.totalStoredBytes !== undefined && object.totalStoredBytes !== null)
      ? Long.fromValue(object.totalStoredBytes)
      : Long.ZERO;
    message.uid = object.uid ?? "";
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.accessRestriction = object.accessRestriction ?? 0;
    return message;
  },
};

function createBaseBackupVault_LabelsEntry(): BackupVault_LabelsEntry {
  return { key: "", value: "" };
}

export const BackupVault_LabelsEntry: MessageFns<BackupVault_LabelsEntry> = {
  encode(message: BackupVault_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupVault_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupVault_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupVault_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BackupVault_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BackupVault_LabelsEntry>): BackupVault_LabelsEntry {
    return BackupVault_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupVault_LabelsEntry>): BackupVault_LabelsEntry {
    const message = createBaseBackupVault_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBackupVault_AnnotationsEntry(): BackupVault_AnnotationsEntry {
  return { key: "", value: "" };
}

export const BackupVault_AnnotationsEntry: MessageFns<BackupVault_AnnotationsEntry> = {
  encode(message: BackupVault_AnnotationsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupVault_AnnotationsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupVault_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupVault_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BackupVault_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<BackupVault_AnnotationsEntry>): BackupVault_AnnotationsEntry {
    return BackupVault_AnnotationsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupVault_AnnotationsEntry>): BackupVault_AnnotationsEntry {
    const message = createBaseBackupVault_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDataSource(): DataSource {
  return {
    name: "",
    state: 0,
    labels: {},
    createTime: undefined,
    updateTime: undefined,
    backupCount: undefined,
    etag: undefined,
    totalStoredBytes: undefined,
    configState: 0,
    backupConfigInfo: undefined,
    dataSourceGcpResource: undefined,
    dataSourceBackupApplianceApplication: undefined,
  };
}

export const DataSource: MessageFns<DataSource> = {
  encode(message: DataSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.state !== 0) {
      writer.uint32(168).int32(message.state);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      DataSource_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.backupCount !== undefined) {
      writer.uint32(56).int64(message.backupCount.toString());
    }
    if (message.etag !== undefined) {
      writer.uint32(114).string(message.etag);
    }
    if (message.totalStoredBytes !== undefined) {
      writer.uint32(184).int64(message.totalStoredBytes.toString());
    }
    if (message.configState !== 0) {
      writer.uint32(192).int32(message.configState);
    }
    if (message.backupConfigInfo !== undefined) {
      BackupConfigInfo.encode(message.backupConfigInfo, writer.uint32(202).fork()).join();
    }
    if (message.dataSourceGcpResource !== undefined) {
      DataSourceGcpResource.encode(message.dataSourceGcpResource, writer.uint32(210).fork()).join();
    }
    if (message.dataSourceBackupApplianceApplication !== undefined) {
      DataSourceBackupApplianceApplication.encode(
        message.dataSourceBackupApplianceApplication,
        writer.uint32(218).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 21:
          if (tag !== 168) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = DataSource_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.backupCount = Long.fromString(reader.int64().toString());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.totalStoredBytes = Long.fromString(reader.int64().toString());
          continue;
        case 24:
          if (tag !== 192) {
            break;
          }

          message.configState = reader.int32() as any;
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.backupConfigInfo = BackupConfigInfo.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.dataSourceGcpResource = DataSourceGcpResource.decode(reader, reader.uint32());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.dataSourceBackupApplianceApplication = DataSourceBackupApplianceApplication.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      state: isSet(object.state) ? dataSource_StateFromJSON(object.state) : 0,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      backupCount: isSet(object.backupCount) ? Long.fromValue(object.backupCount) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : undefined,
      totalStoredBytes: isSet(object.totalStoredBytes) ? Long.fromValue(object.totalStoredBytes) : undefined,
      configState: isSet(object.configState) ? backupConfigStateFromJSON(object.configState) : 0,
      backupConfigInfo: isSet(object.backupConfigInfo) ? BackupConfigInfo.fromJSON(object.backupConfigInfo) : undefined,
      dataSourceGcpResource: isSet(object.dataSourceGcpResource)
        ? DataSourceGcpResource.fromJSON(object.dataSourceGcpResource)
        : undefined,
      dataSourceBackupApplianceApplication: isSet(object.dataSourceBackupApplianceApplication)
        ? DataSourceBackupApplianceApplication.fromJSON(object.dataSourceBackupApplianceApplication)
        : undefined,
    };
  },

  toJSON(message: DataSource): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.state !== 0) {
      obj.state = dataSource_StateToJSON(message.state);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.backupCount !== undefined) {
      obj.backupCount = (message.backupCount || Long.ZERO).toString();
    }
    if (message.etag !== undefined) {
      obj.etag = message.etag;
    }
    if (message.totalStoredBytes !== undefined) {
      obj.totalStoredBytes = (message.totalStoredBytes || Long.ZERO).toString();
    }
    if (message.configState !== 0) {
      obj.configState = backupConfigStateToJSON(message.configState);
    }
    if (message.backupConfigInfo !== undefined) {
      obj.backupConfigInfo = BackupConfigInfo.toJSON(message.backupConfigInfo);
    }
    if (message.dataSourceGcpResource !== undefined) {
      obj.dataSourceGcpResource = DataSourceGcpResource.toJSON(message.dataSourceGcpResource);
    }
    if (message.dataSourceBackupApplianceApplication !== undefined) {
      obj.dataSourceBackupApplianceApplication = DataSourceBackupApplianceApplication.toJSON(
        message.dataSourceBackupApplianceApplication,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<DataSource>): DataSource {
    return DataSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSource>): DataSource {
    const message = createBaseDataSource();
    message.name = object.name ?? "";
    message.state = object.state ?? 0;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.backupCount = (object.backupCount !== undefined && object.backupCount !== null)
      ? Long.fromValue(object.backupCount)
      : undefined;
    message.etag = object.etag ?? undefined;
    message.totalStoredBytes = (object.totalStoredBytes !== undefined && object.totalStoredBytes !== null)
      ? Long.fromValue(object.totalStoredBytes)
      : undefined;
    message.configState = object.configState ?? 0;
    message.backupConfigInfo = (object.backupConfigInfo !== undefined && object.backupConfigInfo !== null)
      ? BackupConfigInfo.fromPartial(object.backupConfigInfo)
      : undefined;
    message.dataSourceGcpResource =
      (object.dataSourceGcpResource !== undefined && object.dataSourceGcpResource !== null)
        ? DataSourceGcpResource.fromPartial(object.dataSourceGcpResource)
        : undefined;
    message.dataSourceBackupApplianceApplication =
      (object.dataSourceBackupApplianceApplication !== undefined &&
          object.dataSourceBackupApplianceApplication !== null)
        ? DataSourceBackupApplianceApplication.fromPartial(object.dataSourceBackupApplianceApplication)
        : undefined;
    return message;
  },
};

function createBaseDataSource_LabelsEntry(): DataSource_LabelsEntry {
  return { key: "", value: "" };
}

export const DataSource_LabelsEntry: MessageFns<DataSource_LabelsEntry> = {
  encode(message: DataSource_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSource_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSource_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSource_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: DataSource_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<DataSource_LabelsEntry>): DataSource_LabelsEntry {
    return DataSource_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSource_LabelsEntry>): DataSource_LabelsEntry {
    const message = createBaseDataSource_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBackupConfigInfo(): BackupConfigInfo {
  return {
    lastBackupState: 0,
    lastSuccessfulBackupConsistencyTime: undefined,
    lastBackupError: undefined,
    gcpBackupConfig: undefined,
    backupApplianceBackupConfig: undefined,
  };
}

export const BackupConfigInfo: MessageFns<BackupConfigInfo> = {
  encode(message: BackupConfigInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastBackupState !== 0) {
      writer.uint32(8).int32(message.lastBackupState);
    }
    if (message.lastSuccessfulBackupConsistencyTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastSuccessfulBackupConsistencyTime), writer.uint32(18).fork()).join();
    }
    if (message.lastBackupError !== undefined) {
      Status.encode(message.lastBackupError, writer.uint32(26).fork()).join();
    }
    if (message.gcpBackupConfig !== undefined) {
      GcpBackupConfig.encode(message.gcpBackupConfig, writer.uint32(34).fork()).join();
    }
    if (message.backupApplianceBackupConfig !== undefined) {
      BackupApplianceBackupConfig.encode(message.backupApplianceBackupConfig, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupConfigInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupConfigInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.lastBackupState = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.lastSuccessfulBackupConsistencyTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.lastBackupError = Status.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.gcpBackupConfig = GcpBackupConfig.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.backupApplianceBackupConfig = BackupApplianceBackupConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupConfigInfo {
    return {
      lastBackupState: isSet(object.lastBackupState)
        ? backupConfigInfo_LastBackupStateFromJSON(object.lastBackupState)
        : 0,
      lastSuccessfulBackupConsistencyTime: isSet(object.lastSuccessfulBackupConsistencyTime)
        ? fromJsonTimestamp(object.lastSuccessfulBackupConsistencyTime)
        : undefined,
      lastBackupError: isSet(object.lastBackupError) ? Status.fromJSON(object.lastBackupError) : undefined,
      gcpBackupConfig: isSet(object.gcpBackupConfig) ? GcpBackupConfig.fromJSON(object.gcpBackupConfig) : undefined,
      backupApplianceBackupConfig: isSet(object.backupApplianceBackupConfig)
        ? BackupApplianceBackupConfig.fromJSON(object.backupApplianceBackupConfig)
        : undefined,
    };
  },

  toJSON(message: BackupConfigInfo): unknown {
    const obj: any = {};
    if (message.lastBackupState !== 0) {
      obj.lastBackupState = backupConfigInfo_LastBackupStateToJSON(message.lastBackupState);
    }
    if (message.lastSuccessfulBackupConsistencyTime !== undefined) {
      obj.lastSuccessfulBackupConsistencyTime = message.lastSuccessfulBackupConsistencyTime.toISOString();
    }
    if (message.lastBackupError !== undefined) {
      obj.lastBackupError = Status.toJSON(message.lastBackupError);
    }
    if (message.gcpBackupConfig !== undefined) {
      obj.gcpBackupConfig = GcpBackupConfig.toJSON(message.gcpBackupConfig);
    }
    if (message.backupApplianceBackupConfig !== undefined) {
      obj.backupApplianceBackupConfig = BackupApplianceBackupConfig.toJSON(message.backupApplianceBackupConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<BackupConfigInfo>): BackupConfigInfo {
    return BackupConfigInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupConfigInfo>): BackupConfigInfo {
    const message = createBaseBackupConfigInfo();
    message.lastBackupState = object.lastBackupState ?? 0;
    message.lastSuccessfulBackupConsistencyTime = object.lastSuccessfulBackupConsistencyTime ?? undefined;
    message.lastBackupError = (object.lastBackupError !== undefined && object.lastBackupError !== null)
      ? Status.fromPartial(object.lastBackupError)
      : undefined;
    message.gcpBackupConfig = (object.gcpBackupConfig !== undefined && object.gcpBackupConfig !== null)
      ? GcpBackupConfig.fromPartial(object.gcpBackupConfig)
      : undefined;
    message.backupApplianceBackupConfig =
      (object.backupApplianceBackupConfig !== undefined && object.backupApplianceBackupConfig !== null)
        ? BackupApplianceBackupConfig.fromPartial(object.backupApplianceBackupConfig)
        : undefined;
    return message;
  },
};

function createBaseGcpBackupConfig(): GcpBackupConfig {
  return { backupPlan: "", backupPlanDescription: "", backupPlanAssociation: "", backupPlanRules: [] };
}

export const GcpBackupConfig: MessageFns<GcpBackupConfig> = {
  encode(message: GcpBackupConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backupPlan !== "") {
      writer.uint32(10).string(message.backupPlan);
    }
    if (message.backupPlanDescription !== "") {
      writer.uint32(18).string(message.backupPlanDescription);
    }
    if (message.backupPlanAssociation !== "") {
      writer.uint32(26).string(message.backupPlanAssociation);
    }
    for (const v of message.backupPlanRules) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcpBackupConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcpBackupConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backupPlan = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backupPlanDescription = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupPlanAssociation = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.backupPlanRules.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcpBackupConfig {
    return {
      backupPlan: isSet(object.backupPlan) ? globalThis.String(object.backupPlan) : "",
      backupPlanDescription: isSet(object.backupPlanDescription) ? globalThis.String(object.backupPlanDescription) : "",
      backupPlanAssociation: isSet(object.backupPlanAssociation) ? globalThis.String(object.backupPlanAssociation) : "",
      backupPlanRules: globalThis.Array.isArray(object?.backupPlanRules)
        ? object.backupPlanRules.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GcpBackupConfig): unknown {
    const obj: any = {};
    if (message.backupPlan !== "") {
      obj.backupPlan = message.backupPlan;
    }
    if (message.backupPlanDescription !== "") {
      obj.backupPlanDescription = message.backupPlanDescription;
    }
    if (message.backupPlanAssociation !== "") {
      obj.backupPlanAssociation = message.backupPlanAssociation;
    }
    if (message.backupPlanRules?.length) {
      obj.backupPlanRules = message.backupPlanRules;
    }
    return obj;
  },

  create(base?: DeepPartial<GcpBackupConfig>): GcpBackupConfig {
    return GcpBackupConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcpBackupConfig>): GcpBackupConfig {
    const message = createBaseGcpBackupConfig();
    message.backupPlan = object.backupPlan ?? "";
    message.backupPlanDescription = object.backupPlanDescription ?? "";
    message.backupPlanAssociation = object.backupPlanAssociation ?? "";
    message.backupPlanRules = object.backupPlanRules?.map((e) => e) || [];
    return message;
  },
};

function createBaseBackupApplianceBackupConfig(): BackupApplianceBackupConfig {
  return {
    backupApplianceName: "",
    backupApplianceId: Long.ZERO,
    slaId: Long.ZERO,
    applicationName: "",
    hostName: "",
    sltName: "",
    slpName: "",
  };
}

export const BackupApplianceBackupConfig: MessageFns<BackupApplianceBackupConfig> = {
  encode(message: BackupApplianceBackupConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backupApplianceName !== "") {
      writer.uint32(10).string(message.backupApplianceName);
    }
    if (!message.backupApplianceId.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.backupApplianceId.toString());
    }
    if (!message.slaId.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.slaId.toString());
    }
    if (message.applicationName !== "") {
      writer.uint32(34).string(message.applicationName);
    }
    if (message.hostName !== "") {
      writer.uint32(42).string(message.hostName);
    }
    if (message.sltName !== "") {
      writer.uint32(50).string(message.sltName);
    }
    if (message.slpName !== "") {
      writer.uint32(58).string(message.slpName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupApplianceBackupConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupApplianceBackupConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backupApplianceName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.backupApplianceId = Long.fromString(reader.int64().toString());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.slaId = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.applicationName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.hostName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sltName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.slpName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupApplianceBackupConfig {
    return {
      backupApplianceName: isSet(object.backupApplianceName) ? globalThis.String(object.backupApplianceName) : "",
      backupApplianceId: isSet(object.backupApplianceId) ? Long.fromValue(object.backupApplianceId) : Long.ZERO,
      slaId: isSet(object.slaId) ? Long.fromValue(object.slaId) : Long.ZERO,
      applicationName: isSet(object.applicationName) ? globalThis.String(object.applicationName) : "",
      hostName: isSet(object.hostName) ? globalThis.String(object.hostName) : "",
      sltName: isSet(object.sltName) ? globalThis.String(object.sltName) : "",
      slpName: isSet(object.slpName) ? globalThis.String(object.slpName) : "",
    };
  },

  toJSON(message: BackupApplianceBackupConfig): unknown {
    const obj: any = {};
    if (message.backupApplianceName !== "") {
      obj.backupApplianceName = message.backupApplianceName;
    }
    if (!message.backupApplianceId.equals(Long.ZERO)) {
      obj.backupApplianceId = (message.backupApplianceId || Long.ZERO).toString();
    }
    if (!message.slaId.equals(Long.ZERO)) {
      obj.slaId = (message.slaId || Long.ZERO).toString();
    }
    if (message.applicationName !== "") {
      obj.applicationName = message.applicationName;
    }
    if (message.hostName !== "") {
      obj.hostName = message.hostName;
    }
    if (message.sltName !== "") {
      obj.sltName = message.sltName;
    }
    if (message.slpName !== "") {
      obj.slpName = message.slpName;
    }
    return obj;
  },

  create(base?: DeepPartial<BackupApplianceBackupConfig>): BackupApplianceBackupConfig {
    return BackupApplianceBackupConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupApplianceBackupConfig>): BackupApplianceBackupConfig {
    const message = createBaseBackupApplianceBackupConfig();
    message.backupApplianceName = object.backupApplianceName ?? "";
    message.backupApplianceId = (object.backupApplianceId !== undefined && object.backupApplianceId !== null)
      ? Long.fromValue(object.backupApplianceId)
      : Long.ZERO;
    message.slaId = (object.slaId !== undefined && object.slaId !== null) ? Long.fromValue(object.slaId) : Long.ZERO;
    message.applicationName = object.applicationName ?? "";
    message.hostName = object.hostName ?? "";
    message.sltName = object.sltName ?? "";
    message.slpName = object.slpName ?? "";
    return message;
  },
};

function createBaseDataSourceGcpResource(): DataSourceGcpResource {
  return { gcpResourcename: "", location: "", type: "", computeInstanceDatasourceProperties: undefined };
}

export const DataSourceGcpResource: MessageFns<DataSourceGcpResource> = {
  encode(message: DataSourceGcpResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcpResourcename !== "") {
      writer.uint32(10).string(message.gcpResourcename);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.computeInstanceDatasourceProperties !== undefined) {
      ComputeInstanceDataSourceProperties.encode(message.computeInstanceDatasourceProperties, writer.uint32(34).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSourceGcpResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSourceGcpResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcpResourcename = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.computeInstanceDatasourceProperties = ComputeInstanceDataSourceProperties.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSourceGcpResource {
    return {
      gcpResourcename: isSet(object.gcpResourcename) ? globalThis.String(object.gcpResourcename) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      computeInstanceDatasourceProperties: isSet(object.computeInstanceDatasourceProperties)
        ? ComputeInstanceDataSourceProperties.fromJSON(object.computeInstanceDatasourceProperties)
        : undefined,
    };
  },

  toJSON(message: DataSourceGcpResource): unknown {
    const obj: any = {};
    if (message.gcpResourcename !== "") {
      obj.gcpResourcename = message.gcpResourcename;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.computeInstanceDatasourceProperties !== undefined) {
      obj.computeInstanceDatasourceProperties = ComputeInstanceDataSourceProperties.toJSON(
        message.computeInstanceDatasourceProperties,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<DataSourceGcpResource>): DataSourceGcpResource {
    return DataSourceGcpResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSourceGcpResource>): DataSourceGcpResource {
    const message = createBaseDataSourceGcpResource();
    message.gcpResourcename = object.gcpResourcename ?? "";
    message.location = object.location ?? "";
    message.type = object.type ?? "";
    message.computeInstanceDatasourceProperties =
      (object.computeInstanceDatasourceProperties !== undefined && object.computeInstanceDatasourceProperties !== null)
        ? ComputeInstanceDataSourceProperties.fromPartial(object.computeInstanceDatasourceProperties)
        : undefined;
    return message;
  },
};

function createBaseDataSourceBackupApplianceApplication(): DataSourceBackupApplianceApplication {
  return {
    applicationName: "",
    backupAppliance: "",
    applianceId: Long.ZERO,
    type: "",
    applicationId: Long.ZERO,
    hostname: "",
    hostId: Long.ZERO,
  };
}

export const DataSourceBackupApplianceApplication: MessageFns<DataSourceBackupApplianceApplication> = {
  encode(message: DataSourceBackupApplianceApplication, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applicationName !== "") {
      writer.uint32(10).string(message.applicationName);
    }
    if (message.backupAppliance !== "") {
      writer.uint32(18).string(message.backupAppliance);
    }
    if (!message.applianceId.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.applianceId.toString());
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (!message.applicationId.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.applicationId.toString());
    }
    if (message.hostname !== "") {
      writer.uint32(50).string(message.hostname);
    }
    if (!message.hostId.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.hostId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataSourceBackupApplianceApplication {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataSourceBackupApplianceApplication();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.applicationName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backupAppliance = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.applianceId = Long.fromString(reader.int64().toString());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.applicationId = Long.fromString(reader.int64().toString());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.hostname = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.hostId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataSourceBackupApplianceApplication {
    return {
      applicationName: isSet(object.applicationName) ? globalThis.String(object.applicationName) : "",
      backupAppliance: isSet(object.backupAppliance) ? globalThis.String(object.backupAppliance) : "",
      applianceId: isSet(object.applianceId) ? Long.fromValue(object.applianceId) : Long.ZERO,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      applicationId: isSet(object.applicationId) ? Long.fromValue(object.applicationId) : Long.ZERO,
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      hostId: isSet(object.hostId) ? Long.fromValue(object.hostId) : Long.ZERO,
    };
  },

  toJSON(message: DataSourceBackupApplianceApplication): unknown {
    const obj: any = {};
    if (message.applicationName !== "") {
      obj.applicationName = message.applicationName;
    }
    if (message.backupAppliance !== "") {
      obj.backupAppliance = message.backupAppliance;
    }
    if (!message.applianceId.equals(Long.ZERO)) {
      obj.applianceId = (message.applianceId || Long.ZERO).toString();
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (!message.applicationId.equals(Long.ZERO)) {
      obj.applicationId = (message.applicationId || Long.ZERO).toString();
    }
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (!message.hostId.equals(Long.ZERO)) {
      obj.hostId = (message.hostId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<DataSourceBackupApplianceApplication>): DataSourceBackupApplianceApplication {
    return DataSourceBackupApplianceApplication.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataSourceBackupApplianceApplication>): DataSourceBackupApplianceApplication {
    const message = createBaseDataSourceBackupApplianceApplication();
    message.applicationName = object.applicationName ?? "";
    message.backupAppliance = object.backupAppliance ?? "";
    message.applianceId = (object.applianceId !== undefined && object.applianceId !== null)
      ? Long.fromValue(object.applianceId)
      : Long.ZERO;
    message.type = object.type ?? "";
    message.applicationId = (object.applicationId !== undefined && object.applicationId !== null)
      ? Long.fromValue(object.applicationId)
      : Long.ZERO;
    message.hostname = object.hostname ?? "";
    message.hostId = (object.hostId !== undefined && object.hostId !== null)
      ? Long.fromValue(object.hostId)
      : Long.ZERO;
    return message;
  },
};

function createBaseServiceLockInfo(): ServiceLockInfo {
  return { operation: "" };
}

export const ServiceLockInfo: MessageFns<ServiceLockInfo> = {
  encode(message: ServiceLockInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== "") {
      writer.uint32(10).string(message.operation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceLockInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServiceLockInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServiceLockInfo {
    return { operation: isSet(object.operation) ? globalThis.String(object.operation) : "" };
  },

  toJSON(message: ServiceLockInfo): unknown {
    const obj: any = {};
    if (message.operation !== "") {
      obj.operation = message.operation;
    }
    return obj;
  },

  create(base?: DeepPartial<ServiceLockInfo>): ServiceLockInfo {
    return ServiceLockInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ServiceLockInfo>): ServiceLockInfo {
    const message = createBaseServiceLockInfo();
    message.operation = object.operation ?? "";
    return message;
  },
};

function createBaseBackupApplianceLockInfo(): BackupApplianceLockInfo {
  return {
    backupApplianceId: Long.ZERO,
    backupApplianceName: "",
    lockReason: "",
    jobName: undefined,
    backupImage: undefined,
    slaId: undefined,
  };
}

export const BackupApplianceLockInfo: MessageFns<BackupApplianceLockInfo> = {
  encode(message: BackupApplianceLockInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.backupApplianceId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.backupApplianceId.toString());
    }
    if (message.backupApplianceName !== "") {
      writer.uint32(18).string(message.backupApplianceName);
    }
    if (message.lockReason !== "") {
      writer.uint32(42).string(message.lockReason);
    }
    if (message.jobName !== undefined) {
      writer.uint32(50).string(message.jobName);
    }
    if (message.backupImage !== undefined) {
      writer.uint32(58).string(message.backupImage);
    }
    if (message.slaId !== undefined) {
      writer.uint32(64).int64(message.slaId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupApplianceLockInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupApplianceLockInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.backupApplianceId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backupApplianceName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.lockReason = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.jobName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.backupImage = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.slaId = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupApplianceLockInfo {
    return {
      backupApplianceId: isSet(object.backupApplianceId) ? Long.fromValue(object.backupApplianceId) : Long.ZERO,
      backupApplianceName: isSet(object.backupApplianceName) ? globalThis.String(object.backupApplianceName) : "",
      lockReason: isSet(object.lockReason) ? globalThis.String(object.lockReason) : "",
      jobName: isSet(object.jobName) ? globalThis.String(object.jobName) : undefined,
      backupImage: isSet(object.backupImage) ? globalThis.String(object.backupImage) : undefined,
      slaId: isSet(object.slaId) ? Long.fromValue(object.slaId) : undefined,
    };
  },

  toJSON(message: BackupApplianceLockInfo): unknown {
    const obj: any = {};
    if (!message.backupApplianceId.equals(Long.ZERO)) {
      obj.backupApplianceId = (message.backupApplianceId || Long.ZERO).toString();
    }
    if (message.backupApplianceName !== "") {
      obj.backupApplianceName = message.backupApplianceName;
    }
    if (message.lockReason !== "") {
      obj.lockReason = message.lockReason;
    }
    if (message.jobName !== undefined) {
      obj.jobName = message.jobName;
    }
    if (message.backupImage !== undefined) {
      obj.backupImage = message.backupImage;
    }
    if (message.slaId !== undefined) {
      obj.slaId = (message.slaId || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<BackupApplianceLockInfo>): BackupApplianceLockInfo {
    return BackupApplianceLockInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupApplianceLockInfo>): BackupApplianceLockInfo {
    const message = createBaseBackupApplianceLockInfo();
    message.backupApplianceId = (object.backupApplianceId !== undefined && object.backupApplianceId !== null)
      ? Long.fromValue(object.backupApplianceId)
      : Long.ZERO;
    message.backupApplianceName = object.backupApplianceName ?? "";
    message.lockReason = object.lockReason ?? "";
    message.jobName = object.jobName ?? undefined;
    message.backupImage = object.backupImage ?? undefined;
    message.slaId = (object.slaId !== undefined && object.slaId !== null) ? Long.fromValue(object.slaId) : undefined;
    return message;
  },
};

function createBaseBackupLock(): BackupLock {
  return { lockUntilTime: undefined, backupApplianceLockInfo: undefined, serviceLockInfo: undefined };
}

export const BackupLock: MessageFns<BackupLock> = {
  encode(message: BackupLock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lockUntilTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lockUntilTime), writer.uint32(10).fork()).join();
    }
    if (message.backupApplianceLockInfo !== undefined) {
      BackupApplianceLockInfo.encode(message.backupApplianceLockInfo, writer.uint32(26).fork()).join();
    }
    if (message.serviceLockInfo !== undefined) {
      ServiceLockInfo.encode(message.serviceLockInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackupLock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackupLock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.lockUntilTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupApplianceLockInfo = BackupApplianceLockInfo.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.serviceLockInfo = ServiceLockInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackupLock {
    return {
      lockUntilTime: isSet(object.lockUntilTime) ? fromJsonTimestamp(object.lockUntilTime) : undefined,
      backupApplianceLockInfo: isSet(object.backupApplianceLockInfo)
        ? BackupApplianceLockInfo.fromJSON(object.backupApplianceLockInfo)
        : undefined,
      serviceLockInfo: isSet(object.serviceLockInfo) ? ServiceLockInfo.fromJSON(object.serviceLockInfo) : undefined,
    };
  },

  toJSON(message: BackupLock): unknown {
    const obj: any = {};
    if (message.lockUntilTime !== undefined) {
      obj.lockUntilTime = message.lockUntilTime.toISOString();
    }
    if (message.backupApplianceLockInfo !== undefined) {
      obj.backupApplianceLockInfo = BackupApplianceLockInfo.toJSON(message.backupApplianceLockInfo);
    }
    if (message.serviceLockInfo !== undefined) {
      obj.serviceLockInfo = ServiceLockInfo.toJSON(message.serviceLockInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<BackupLock>): BackupLock {
    return BackupLock.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BackupLock>): BackupLock {
    const message = createBaseBackupLock();
    message.lockUntilTime = object.lockUntilTime ?? undefined;
    message.backupApplianceLockInfo =
      (object.backupApplianceLockInfo !== undefined && object.backupApplianceLockInfo !== null)
        ? BackupApplianceLockInfo.fromPartial(object.backupApplianceLockInfo)
        : undefined;
    message.serviceLockInfo = (object.serviceLockInfo !== undefined && object.serviceLockInfo !== null)
      ? ServiceLockInfo.fromPartial(object.serviceLockInfo)
      : undefined;
    return message;
  },
};

function createBaseBackup(): Backup {
  return {
    name: "",
    description: undefined,
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    enforcedRetentionEndTime: undefined,
    expireTime: undefined,
    consistencyTime: undefined,
    etag: undefined,
    state: 0,
    serviceLocks: [],
    backupApplianceLocks: [],
    computeInstanceBackupProperties: undefined,
    backupApplianceBackupProperties: undefined,
    backupType: 0,
    gcpBackupPlanInfo: undefined,
    resourceSizeBytes: Long.ZERO,
  };
}

export const Backup: MessageFns<Backup> = {
  encode(message: Backup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Backup_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.enforcedRetentionEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.enforcedRetentionEndTime), writer.uint32(50).fork()).join();
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(58).fork()).join();
    }
    if (message.consistencyTime !== undefined) {
      Timestamp.encode(toTimestamp(message.consistencyTime), writer.uint32(74).fork()).join();
    }
    if (message.etag !== undefined) {
      writer.uint32(90).string(message.etag);
    }
    if (message.state !== 0) {
      writer.uint32(120).int32(message.state);
    }
    for (const v of message.serviceLocks) {
      BackupLock.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.backupApplianceLocks) {
      BackupLock.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.computeInstanceBackupProperties !== undefined) {
      ComputeInstanceBackupProperties.encode(message.computeInstanceBackupProperties, writer.uint32(154).fork()).join();
    }
    if (message.backupApplianceBackupProperties !== undefined) {
      BackupApplianceBackupProperties.encode(message.backupApplianceBackupProperties, writer.uint32(170).fork()).join();
    }
    if (message.backupType !== 0) {
      writer.uint32(160).int32(message.backupType);
    }
    if (message.gcpBackupPlanInfo !== undefined) {
      Backup_GCPBackupPlanInfo.encode(message.gcpBackupPlanInfo, writer.uint32(178).fork()).join();
    }
    if (!message.resourceSizeBytes.equals(Long.ZERO)) {
      writer.uint32(184).int64(message.resourceSizeBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Backup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Backup_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.enforcedRetentionEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.consistencyTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.serviceLocks.push(BackupLock.decode(reader, reader.uint32()));
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.backupApplianceLocks.push(BackupLock.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.computeInstanceBackupProperties = ComputeInstanceBackupProperties.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.backupApplianceBackupProperties = BackupApplianceBackupProperties.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.backupType = reader.int32() as any;
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.gcpBackupPlanInfo = Backup_GCPBackupPlanInfo.decode(reader, reader.uint32());
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.resourceSizeBytes = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Backup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      enforcedRetentionEndTime: isSet(object.enforcedRetentionEndTime)
        ? fromJsonTimestamp(object.enforcedRetentionEndTime)
        : undefined,
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      consistencyTime: isSet(object.consistencyTime) ? fromJsonTimestamp(object.consistencyTime) : undefined,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : undefined,
      state: isSet(object.state) ? backup_StateFromJSON(object.state) : 0,
      serviceLocks: globalThis.Array.isArray(object?.serviceLocks)
        ? object.serviceLocks.map((e: any) => BackupLock.fromJSON(e))
        : [],
      backupApplianceLocks: globalThis.Array.isArray(object?.backupApplianceLocks)
        ? object.backupApplianceLocks.map((e: any) => BackupLock.fromJSON(e))
        : [],
      computeInstanceBackupProperties: isSet(object.computeInstanceBackupProperties)
        ? ComputeInstanceBackupProperties.fromJSON(object.computeInstanceBackupProperties)
        : undefined,
      backupApplianceBackupProperties: isSet(object.backupApplianceBackupProperties)
        ? BackupApplianceBackupProperties.fromJSON(object.backupApplianceBackupProperties)
        : undefined,
      backupType: isSet(object.backupType) ? backup_BackupTypeFromJSON(object.backupType) : 0,
      gcpBackupPlanInfo: isSet(object.gcpBackupPlanInfo)
        ? Backup_GCPBackupPlanInfo.fromJSON(object.gcpBackupPlanInfo)
        : undefined,
      resourceSizeBytes: isSet(object.resourceSizeBytes) ? Long.fromValue(object.resourceSizeBytes) : Long.ZERO,
    };
  },

  toJSON(message: Backup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.enforcedRetentionEndTime !== undefined) {
      obj.enforcedRetentionEndTime = message.enforcedRetentionEndTime.toISOString();
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.consistencyTime !== undefined) {
      obj.consistencyTime = message.consistencyTime.toISOString();
    }
    if (message.etag !== undefined) {
      obj.etag = message.etag;
    }
    if (message.state !== 0) {
      obj.state = backup_StateToJSON(message.state);
    }
    if (message.serviceLocks?.length) {
      obj.serviceLocks = message.serviceLocks.map((e) => BackupLock.toJSON(e));
    }
    if (message.backupApplianceLocks?.length) {
      obj.backupApplianceLocks = message.backupApplianceLocks.map((e) => BackupLock.toJSON(e));
    }
    if (message.computeInstanceBackupProperties !== undefined) {
      obj.computeInstanceBackupProperties = ComputeInstanceBackupProperties.toJSON(
        message.computeInstanceBackupProperties,
      );
    }
    if (message.backupApplianceBackupProperties !== undefined) {
      obj.backupApplianceBackupProperties = BackupApplianceBackupProperties.toJSON(
        message.backupApplianceBackupProperties,
      );
    }
    if (message.backupType !== 0) {
      obj.backupType = backup_BackupTypeToJSON(message.backupType);
    }
    if (message.gcpBackupPlanInfo !== undefined) {
      obj.gcpBackupPlanInfo = Backup_GCPBackupPlanInfo.toJSON(message.gcpBackupPlanInfo);
    }
    if (!message.resourceSizeBytes.equals(Long.ZERO)) {
      obj.resourceSizeBytes = (message.resourceSizeBytes || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<Backup>): Backup {
    return Backup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Backup>): Backup {
    const message = createBaseBackup();
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.enforcedRetentionEndTime = object.enforcedRetentionEndTime ?? undefined;
    message.expireTime = object.expireTime ?? undefined;
    message.consistencyTime = object.consistencyTime ?? undefined;
    message.etag = object.etag ?? undefined;
    message.state = object.state ?? 0;
    message.serviceLocks = object.serviceLocks?.map((e) => BackupLock.fromPartial(e)) || [];
    message.backupApplianceLocks = object.backupApplianceLocks?.map((e) => BackupLock.fromPartial(e)) || [];
    message.computeInstanceBackupProperties =
      (object.computeInstanceBackupProperties !== undefined && object.computeInstanceBackupProperties !== null)
        ? ComputeInstanceBackupProperties.fromPartial(object.computeInstanceBackupProperties)
        : undefined;
    message.backupApplianceBackupProperties =
      (object.backupApplianceBackupProperties !== undefined && object.backupApplianceBackupProperties !== null)
        ? BackupApplianceBackupProperties.fromPartial(object.backupApplianceBackupProperties)
        : undefined;
    message.backupType = object.backupType ?? 0;
    message.gcpBackupPlanInfo = (object.gcpBackupPlanInfo !== undefined && object.gcpBackupPlanInfo !== null)
      ? Backup_GCPBackupPlanInfo.fromPartial(object.gcpBackupPlanInfo)
      : undefined;
    message.resourceSizeBytes = (object.resourceSizeBytes !== undefined && object.resourceSizeBytes !== null)
      ? Long.fromValue(object.resourceSizeBytes)
      : Long.ZERO;
    return message;
  },
};

function createBaseBackup_GCPBackupPlanInfo(): Backup_GCPBackupPlanInfo {
  return { backupPlan: "", backupPlanRuleId: "" };
}

export const Backup_GCPBackupPlanInfo: MessageFns<Backup_GCPBackupPlanInfo> = {
  encode(message: Backup_GCPBackupPlanInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backupPlan !== "") {
      writer.uint32(10).string(message.backupPlan);
    }
    if (message.backupPlanRuleId !== "") {
      writer.uint32(18).string(message.backupPlanRuleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Backup_GCPBackupPlanInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackup_GCPBackupPlanInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backupPlan = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backupPlanRuleId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Backup_GCPBackupPlanInfo {
    return {
      backupPlan: isSet(object.backupPlan) ? globalThis.String(object.backupPlan) : "",
      backupPlanRuleId: isSet(object.backupPlanRuleId) ? globalThis.String(object.backupPlanRuleId) : "",
    };
  },

  toJSON(message: Backup_GCPBackupPlanInfo): unknown {
    const obj: any = {};
    if (message.backupPlan !== "") {
      obj.backupPlan = message.backupPlan;
    }
    if (message.backupPlanRuleId !== "") {
      obj.backupPlanRuleId = message.backupPlanRuleId;
    }
    return obj;
  },

  create(base?: DeepPartial<Backup_GCPBackupPlanInfo>): Backup_GCPBackupPlanInfo {
    return Backup_GCPBackupPlanInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Backup_GCPBackupPlanInfo>): Backup_GCPBackupPlanInfo {
    const message = createBaseBackup_GCPBackupPlanInfo();
    message.backupPlan = object.backupPlan ?? "";
    message.backupPlanRuleId = object.backupPlanRuleId ?? "";
    return message;
  },
};

function createBaseBackup_LabelsEntry(): Backup_LabelsEntry {
  return { key: "", value: "" };
}

export const Backup_LabelsEntry: MessageFns<Backup_LabelsEntry> = {
  encode(message: Backup_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Backup_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackup_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Backup_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Backup_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Backup_LabelsEntry>): Backup_LabelsEntry {
    return Backup_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Backup_LabelsEntry>): Backup_LabelsEntry {
    const message = createBaseBackup_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateBackupVaultRequest(): CreateBackupVaultRequest {
  return { parent: "", backupVaultId: "", backupVault: undefined, requestId: "", validateOnly: false };
}

export const CreateBackupVaultRequest: MessageFns<CreateBackupVaultRequest> = {
  encode(message: CreateBackupVaultRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.backupVaultId !== "") {
      writer.uint32(18).string(message.backupVaultId);
    }
    if (message.backupVault !== undefined) {
      BackupVault.encode(message.backupVault, writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBackupVaultRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBackupVaultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backupVaultId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.backupVault = BackupVault.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBackupVaultRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      backupVaultId: isSet(object.backupVaultId) ? globalThis.String(object.backupVaultId) : "",
      backupVault: isSet(object.backupVault) ? BackupVault.fromJSON(object.backupVault) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateBackupVaultRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.backupVaultId !== "") {
      obj.backupVaultId = message.backupVaultId;
    }
    if (message.backupVault !== undefined) {
      obj.backupVault = BackupVault.toJSON(message.backupVault);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBackupVaultRequest>): CreateBackupVaultRequest {
    return CreateBackupVaultRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBackupVaultRequest>): CreateBackupVaultRequest {
    const message = createBaseCreateBackupVaultRequest();
    message.parent = object.parent ?? "";
    message.backupVaultId = object.backupVaultId ?? "";
    message.backupVault = (object.backupVault !== undefined && object.backupVault !== null)
      ? BackupVault.fromPartial(object.backupVault)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseListBackupVaultsRequest(): ListBackupVaultsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "", view: 0 };
}

export const ListBackupVaultsRequest: MessageFns<ListBackupVaultsRequest> = {
  encode(message: ListBackupVaultsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    if (message.view !== 0) {
      writer.uint32(48).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBackupVaultsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBackupVaultsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBackupVaultsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      view: isSet(object.view) ? backupVaultViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListBackupVaultsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.view !== 0) {
      obj.view = backupVaultViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListBackupVaultsRequest>): ListBackupVaultsRequest {
    return ListBackupVaultsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBackupVaultsRequest>): ListBackupVaultsRequest {
    const message = createBaseListBackupVaultsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListBackupVaultsResponse(): ListBackupVaultsResponse {
  return { backupVaults: [], nextPageToken: "", unreachable: [] };
}

export const ListBackupVaultsResponse: MessageFns<ListBackupVaultsResponse> = {
  encode(message: ListBackupVaultsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.backupVaults) {
      BackupVault.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBackupVaultsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBackupVaultsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backupVaults.push(BackupVault.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBackupVaultsResponse {
    return {
      backupVaults: globalThis.Array.isArray(object?.backupVaults)
        ? object.backupVaults.map((e: any) => BackupVault.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListBackupVaultsResponse): unknown {
    const obj: any = {};
    if (message.backupVaults?.length) {
      obj.backupVaults = message.backupVaults.map((e) => BackupVault.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBackupVaultsResponse>): ListBackupVaultsResponse {
    return ListBackupVaultsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBackupVaultsResponse>): ListBackupVaultsResponse {
    const message = createBaseListBackupVaultsResponse();
    message.backupVaults = object.backupVaults?.map((e) => BackupVault.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseFetchUsableBackupVaultsRequest(): FetchUsableBackupVaultsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const FetchUsableBackupVaultsRequest: MessageFns<FetchUsableBackupVaultsRequest> = {
  encode(message: FetchUsableBackupVaultsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchUsableBackupVaultsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchUsableBackupVaultsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchUsableBackupVaultsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: FetchUsableBackupVaultsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchUsableBackupVaultsRequest>): FetchUsableBackupVaultsRequest {
    return FetchUsableBackupVaultsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchUsableBackupVaultsRequest>): FetchUsableBackupVaultsRequest {
    const message = createBaseFetchUsableBackupVaultsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseFetchUsableBackupVaultsResponse(): FetchUsableBackupVaultsResponse {
  return { backupVaults: [], nextPageToken: "", unreachable: [] };
}

export const FetchUsableBackupVaultsResponse: MessageFns<FetchUsableBackupVaultsResponse> = {
  encode(message: FetchUsableBackupVaultsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.backupVaults) {
      BackupVault.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchUsableBackupVaultsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchUsableBackupVaultsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backupVaults.push(BackupVault.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchUsableBackupVaultsResponse {
    return {
      backupVaults: globalThis.Array.isArray(object?.backupVaults)
        ? object.backupVaults.map((e: any) => BackupVault.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FetchUsableBackupVaultsResponse): unknown {
    const obj: any = {};
    if (message.backupVaults?.length) {
      obj.backupVaults = message.backupVaults.map((e) => BackupVault.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<FetchUsableBackupVaultsResponse>): FetchUsableBackupVaultsResponse {
    return FetchUsableBackupVaultsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchUsableBackupVaultsResponse>): FetchUsableBackupVaultsResponse {
    const message = createBaseFetchUsableBackupVaultsResponse();
    message.backupVaults = object.backupVaults?.map((e) => BackupVault.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetBackupVaultRequest(): GetBackupVaultRequest {
  return { name: "", view: 0 };
}

export const GetBackupVaultRequest: MessageFns<GetBackupVaultRequest> = {
  encode(message: GetBackupVaultRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBackupVaultRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBackupVaultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBackupVaultRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? backupVaultViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetBackupVaultRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = backupVaultViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBackupVaultRequest>): GetBackupVaultRequest {
    return GetBackupVaultRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBackupVaultRequest>): GetBackupVaultRequest {
    const message = createBaseGetBackupVaultRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseUpdateBackupVaultRequest(): UpdateBackupVaultRequest {
  return { updateMask: undefined, backupVault: undefined, requestId: "", validateOnly: false, force: false };
}

export const UpdateBackupVaultRequest: MessageFns<UpdateBackupVaultRequest> = {
  encode(message: UpdateBackupVaultRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.backupVault !== undefined) {
      BackupVault.encode(message.backupVault, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    if (message.force !== false) {
      writer.uint32(40).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBackupVaultRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBackupVaultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backupVault = BackupVault.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.force = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBackupVaultRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      backupVault: isSet(object.backupVault) ? BackupVault.fromJSON(object.backupVault) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: UpdateBackupVaultRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.backupVault !== undefined) {
      obj.backupVault = BackupVault.toJSON(message.backupVault);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateBackupVaultRequest>): UpdateBackupVaultRequest {
    return UpdateBackupVaultRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateBackupVaultRequest>): UpdateBackupVaultRequest {
    const message = createBaseUpdateBackupVaultRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.backupVault = (object.backupVault !== undefined && object.backupVault !== null)
      ? BackupVault.fromPartial(object.backupVault)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseDeleteBackupVaultRequest(): DeleteBackupVaultRequest {
  return { name: "", requestId: "", force: false, etag: "", validateOnly: false, allowMissing: false };
}

export const DeleteBackupVaultRequest: MessageFns<DeleteBackupVaultRequest> = {
  encode(message: DeleteBackupVaultRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    if (message.etag !== "") {
      writer.uint32(34).string(message.etag);
    }
    if (message.validateOnly !== false) {
      writer.uint32(40).bool(message.validateOnly);
    }
    if (message.allowMissing !== false) {
      writer.uint32(48).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteBackupVaultRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBackupVaultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteBackupVaultRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: DeleteBackupVaultRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteBackupVaultRequest>): DeleteBackupVaultRequest {
    return DeleteBackupVaultRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteBackupVaultRequest>): DeleteBackupVaultRequest {
    const message = createBaseDeleteBackupVaultRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.force = object.force ?? false;
    message.etag = object.etag ?? "";
    message.validateOnly = object.validateOnly ?? false;
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseListDataSourcesRequest(): ListDataSourcesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListDataSourcesRequest: MessageFns<ListDataSourcesRequest> = {
  encode(message: ListDataSourcesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDataSourcesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDataSourcesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDataSourcesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListDataSourcesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDataSourcesRequest>): ListDataSourcesRequest {
    return ListDataSourcesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDataSourcesRequest>): ListDataSourcesRequest {
    const message = createBaseListDataSourcesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListDataSourcesResponse(): ListDataSourcesResponse {
  return { dataSources: [], nextPageToken: "", unreachable: [] };
}

export const ListDataSourcesResponse: MessageFns<ListDataSourcesResponse> = {
  encode(message: ListDataSourcesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dataSources) {
      DataSource.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDataSourcesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDataSourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSources.push(DataSource.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDataSourcesResponse {
    return {
      dataSources: globalThis.Array.isArray(object?.dataSources)
        ? object.dataSources.map((e: any) => DataSource.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListDataSourcesResponse): unknown {
    const obj: any = {};
    if (message.dataSources?.length) {
      obj.dataSources = message.dataSources.map((e) => DataSource.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListDataSourcesResponse>): ListDataSourcesResponse {
    return ListDataSourcesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListDataSourcesResponse>): ListDataSourcesResponse {
    const message = createBaseListDataSourcesResponse();
    message.dataSources = object.dataSources?.map((e) => DataSource.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetDataSourceRequest(): GetDataSourceRequest {
  return { name: "" };
}

export const GetDataSourceRequest: MessageFns<GetDataSourceRequest> = {
  encode(message: GetDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDataSourceRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDataSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetDataSourceRequest>): GetDataSourceRequest {
    return GetDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDataSourceRequest>): GetDataSourceRequest {
    const message = createBaseGetDataSourceRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseUpdateDataSourceRequest(): UpdateDataSourceRequest {
  return { updateMask: undefined, dataSource: undefined, requestId: "", allowMissing: false };
}

export const UpdateDataSourceRequest: MessageFns<UpdateDataSourceRequest> = {
  encode(message: UpdateDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.dataSource !== undefined) {
      DataSource.encode(message.dataSource, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.allowMissing !== false) {
      writer.uint32(32).bool(message.allowMissing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.dataSource = DataSource.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateDataSourceRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      dataSource: isSet(object.dataSource) ? DataSource.fromJSON(object.dataSource) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
    };
  },

  toJSON(message: UpdateDataSourceRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.dataSource !== undefined) {
      obj.dataSource = DataSource.toJSON(message.dataSource);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateDataSourceRequest>): UpdateDataSourceRequest {
    return UpdateDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateDataSourceRequest>): UpdateDataSourceRequest {
    const message = createBaseUpdateDataSourceRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.dataSource = (object.dataSource !== undefined && object.dataSource !== null)
      ? DataSource.fromPartial(object.dataSource)
      : undefined;
    message.requestId = object.requestId ?? "";
    message.allowMissing = object.allowMissing ?? false;
    return message;
  },
};

function createBaseRemoveDataSourceRequest(): RemoveDataSourceRequest {
  return { name: "", requestId: "" };
}

export const RemoveDataSourceRequest: MessageFns<RemoveDataSourceRequest> = {
  encode(message: RemoveDataSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveDataSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveDataSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveDataSourceRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: RemoveDataSourceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<RemoveDataSourceRequest>): RemoveDataSourceRequest {
    return RemoveDataSourceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoveDataSourceRequest>): RemoveDataSourceRequest {
    const message = createBaseRemoveDataSourceRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseSetInternalStatusRequest(): SetInternalStatusRequest {
  return { dataSource: "", value: Buffer.alloc(0), backupConfigState: 0, requestId: "" };
}

export const SetInternalStatusRequest: MessageFns<SetInternalStatusRequest> = {
  encode(message: SetInternalStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataSource !== "") {
      writer.uint32(10).string(message.dataSource);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    if (message.backupConfigState !== 0) {
      writer.uint32(24).int32(message.backupConfigState);
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetInternalStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetInternalStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Buffer.from(reader.bytes());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.backupConfigState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetInternalStatusRequest {
    return {
      dataSource: isSet(object.dataSource) ? globalThis.String(object.dataSource) : "",
      value: isSet(object.value) ? Buffer.from(bytesFromBase64(object.value)) : Buffer.alloc(0),
      backupConfigState: isSet(object.backupConfigState) ? backupConfigStateFromJSON(object.backupConfigState) : 0,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: SetInternalStatusRequest): unknown {
    const obj: any = {};
    if (message.dataSource !== "") {
      obj.dataSource = message.dataSource;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    if (message.backupConfigState !== 0) {
      obj.backupConfigState = backupConfigStateToJSON(message.backupConfigState);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<SetInternalStatusRequest>): SetInternalStatusRequest {
    return SetInternalStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetInternalStatusRequest>): SetInternalStatusRequest {
    const message = createBaseSetInternalStatusRequest();
    message.dataSource = object.dataSource ?? "";
    message.value = object.value ?? Buffer.alloc(0);
    message.backupConfigState = object.backupConfigState ?? 0;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseSetInternalStatusResponse(): SetInternalStatusResponse {
  return {};
}

export const SetInternalStatusResponse: MessageFns<SetInternalStatusResponse> = {
  encode(_: SetInternalStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetInternalStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetInternalStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SetInternalStatusResponse {
    return {};
  },

  toJSON(_: SetInternalStatusResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SetInternalStatusResponse>): SetInternalStatusResponse {
    return SetInternalStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SetInternalStatusResponse>): SetInternalStatusResponse {
    const message = createBaseSetInternalStatusResponse();
    return message;
  },
};

function createBaseInitiateBackupRequest(): InitiateBackupRequest {
  return { dataSource: "", requestId: "", backupId: "" };
}

export const InitiateBackupRequest: MessageFns<InitiateBackupRequest> = {
  encode(message: InitiateBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataSource !== "") {
      writer.uint32(10).string(message.dataSource);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.backupId !== "") {
      writer.uint32(42).string(message.backupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.backupId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateBackupRequest {
    return {
      dataSource: isSet(object.dataSource) ? globalThis.String(object.dataSource) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      backupId: isSet(object.backupId) ? globalThis.String(object.backupId) : "",
    };
  },

  toJSON(message: InitiateBackupRequest): unknown {
    const obj: any = {};
    if (message.dataSource !== "") {
      obj.dataSource = message.dataSource;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.backupId !== "") {
      obj.backupId = message.backupId;
    }
    return obj;
  },

  create(base?: DeepPartial<InitiateBackupRequest>): InitiateBackupRequest {
    return InitiateBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitiateBackupRequest>): InitiateBackupRequest {
    const message = createBaseInitiateBackupRequest();
    message.dataSource = object.dataSource ?? "";
    message.requestId = object.requestId ?? "";
    message.backupId = object.backupId ?? "";
    return message;
  },
};

function createBaseInitiateBackupResponse(): InitiateBackupResponse {
  return { backup: "", newBackupGenerationId: 0, baseBackupGenerationId: 0 };
}

export const InitiateBackupResponse: MessageFns<InitiateBackupResponse> = {
  encode(message: InitiateBackupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.backup !== "") {
      writer.uint32(10).string(message.backup);
    }
    if (message.newBackupGenerationId !== 0) {
      writer.uint32(16).int32(message.newBackupGenerationId);
    }
    if (message.baseBackupGenerationId !== 0) {
      writer.uint32(24).int32(message.baseBackupGenerationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitiateBackupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitiateBackupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backup = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.newBackupGenerationId = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.baseBackupGenerationId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitiateBackupResponse {
    return {
      backup: isSet(object.backup) ? globalThis.String(object.backup) : "",
      newBackupGenerationId: isSet(object.newBackupGenerationId) ? globalThis.Number(object.newBackupGenerationId) : 0,
      baseBackupGenerationId: isSet(object.baseBackupGenerationId)
        ? globalThis.Number(object.baseBackupGenerationId)
        : 0,
    };
  },

  toJSON(message: InitiateBackupResponse): unknown {
    const obj: any = {};
    if (message.backup !== "") {
      obj.backup = message.backup;
    }
    if (message.newBackupGenerationId !== 0) {
      obj.newBackupGenerationId = Math.round(message.newBackupGenerationId);
    }
    if (message.baseBackupGenerationId !== 0) {
      obj.baseBackupGenerationId = Math.round(message.baseBackupGenerationId);
    }
    return obj;
  },

  create(base?: DeepPartial<InitiateBackupResponse>): InitiateBackupResponse {
    return InitiateBackupResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InitiateBackupResponse>): InitiateBackupResponse {
    const message = createBaseInitiateBackupResponse();
    message.backup = object.backup ?? "";
    message.newBackupGenerationId = object.newBackupGenerationId ?? 0;
    message.baseBackupGenerationId = object.baseBackupGenerationId ?? 0;
    return message;
  },
};

function createBaseAbandonBackupRequest(): AbandonBackupRequest {
  return { dataSource: "", requestId: "" };
}

export const AbandonBackupRequest: MessageFns<AbandonBackupRequest> = {
  encode(message: AbandonBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataSource !== "") {
      writer.uint32(10).string(message.dataSource);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AbandonBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAbandonBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AbandonBackupRequest {
    return {
      dataSource: isSet(object.dataSource) ? globalThis.String(object.dataSource) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: AbandonBackupRequest): unknown {
    const obj: any = {};
    if (message.dataSource !== "") {
      obj.dataSource = message.dataSource;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<AbandonBackupRequest>): AbandonBackupRequest {
    return AbandonBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AbandonBackupRequest>): AbandonBackupRequest {
    const message = createBaseAbandonBackupRequest();
    message.dataSource = object.dataSource ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseFinalizeBackupRequest(): FinalizeBackupRequest {
  return {
    dataSource: "",
    description: undefined,
    consistencyTime: undefined,
    requestId: "",
    backupId: "",
    recoveryRangeStartTime: undefined,
    recoveryRangeEndTime: undefined,
    retentionDuration: undefined,
  };
}

export const FinalizeBackupRequest: MessageFns<FinalizeBackupRequest> = {
  encode(message: FinalizeBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataSource !== "") {
      writer.uint32(10).string(message.dataSource);
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    if (message.consistencyTime !== undefined) {
      Timestamp.encode(toTimestamp(message.consistencyTime), writer.uint32(26).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(34).string(message.requestId);
    }
    if (message.backupId !== "") {
      writer.uint32(42).string(message.backupId);
    }
    if (message.recoveryRangeStartTime !== undefined) {
      Timestamp.encode(toTimestamp(message.recoveryRangeStartTime), writer.uint32(50).fork()).join();
    }
    if (message.recoveryRangeEndTime !== undefined) {
      Timestamp.encode(toTimestamp(message.recoveryRangeEndTime), writer.uint32(58).fork()).join();
    }
    if (message.retentionDuration !== undefined) {
      Duration.encode(message.retentionDuration, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataSource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.consistencyTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.backupId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.recoveryRangeStartTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.recoveryRangeEndTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.retentionDuration = Duration.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeBackupRequest {
    return {
      dataSource: isSet(object.dataSource) ? globalThis.String(object.dataSource) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      consistencyTime: isSet(object.consistencyTime) ? fromJsonTimestamp(object.consistencyTime) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      backupId: isSet(object.backupId) ? globalThis.String(object.backupId) : "",
      recoveryRangeStartTime: isSet(object.recoveryRangeStartTime)
        ? fromJsonTimestamp(object.recoveryRangeStartTime)
        : undefined,
      recoveryRangeEndTime: isSet(object.recoveryRangeEndTime)
        ? fromJsonTimestamp(object.recoveryRangeEndTime)
        : undefined,
      retentionDuration: isSet(object.retentionDuration) ? Duration.fromJSON(object.retentionDuration) : undefined,
    };
  },

  toJSON(message: FinalizeBackupRequest): unknown {
    const obj: any = {};
    if (message.dataSource !== "") {
      obj.dataSource = message.dataSource;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.consistencyTime !== undefined) {
      obj.consistencyTime = message.consistencyTime.toISOString();
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.backupId !== "") {
      obj.backupId = message.backupId;
    }
    if (message.recoveryRangeStartTime !== undefined) {
      obj.recoveryRangeStartTime = message.recoveryRangeStartTime.toISOString();
    }
    if (message.recoveryRangeEndTime !== undefined) {
      obj.recoveryRangeEndTime = message.recoveryRangeEndTime.toISOString();
    }
    if (message.retentionDuration !== undefined) {
      obj.retentionDuration = Duration.toJSON(message.retentionDuration);
    }
    return obj;
  },

  create(base?: DeepPartial<FinalizeBackupRequest>): FinalizeBackupRequest {
    return FinalizeBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FinalizeBackupRequest>): FinalizeBackupRequest {
    const message = createBaseFinalizeBackupRequest();
    message.dataSource = object.dataSource ?? "";
    message.description = object.description ?? undefined;
    message.consistencyTime = object.consistencyTime ?? undefined;
    message.requestId = object.requestId ?? "";
    message.backupId = object.backupId ?? "";
    message.recoveryRangeStartTime = object.recoveryRangeStartTime ?? undefined;
    message.recoveryRangeEndTime = object.recoveryRangeEndTime ?? undefined;
    message.retentionDuration = (object.retentionDuration !== undefined && object.retentionDuration !== null)
      ? Duration.fromPartial(object.retentionDuration)
      : undefined;
    return message;
  },
};

function createBaseFetchAccessTokenRequest(): FetchAccessTokenRequest {
  return { name: "", generationId: 0 };
}

export const FetchAccessTokenRequest: MessageFns<FetchAccessTokenRequest> = {
  encode(message: FetchAccessTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.generationId !== 0) {
      writer.uint32(16).int32(message.generationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchAccessTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchAccessTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.generationId = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchAccessTokenRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      generationId: isSet(object.generationId) ? globalThis.Number(object.generationId) : 0,
    };
  },

  toJSON(message: FetchAccessTokenRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.generationId !== 0) {
      obj.generationId = Math.round(message.generationId);
    }
    return obj;
  },

  create(base?: DeepPartial<FetchAccessTokenRequest>): FetchAccessTokenRequest {
    return FetchAccessTokenRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchAccessTokenRequest>): FetchAccessTokenRequest {
    const message = createBaseFetchAccessTokenRequest();
    message.name = object.name ?? "";
    message.generationId = object.generationId ?? 0;
    return message;
  },
};

function createBaseFetchAccessTokenResponse(): FetchAccessTokenResponse {
  return { readLocation: "", writeLocation: "", token: "", expireTime: undefined };
}

export const FetchAccessTokenResponse: MessageFns<FetchAccessTokenResponse> = {
  encode(message: FetchAccessTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.readLocation !== "") {
      writer.uint32(10).string(message.readLocation);
    }
    if (message.writeLocation !== "") {
      writer.uint32(18).string(message.writeLocation);
    }
    if (message.token !== "") {
      writer.uint32(26).string(message.token);
    }
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FetchAccessTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetchAccessTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.readLocation = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.writeLocation = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FetchAccessTokenResponse {
    return {
      readLocation: isSet(object.readLocation) ? globalThis.String(object.readLocation) : "",
      writeLocation: isSet(object.writeLocation) ? globalThis.String(object.writeLocation) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
    };
  },

  toJSON(message: FetchAccessTokenResponse): unknown {
    const obj: any = {};
    if (message.readLocation !== "") {
      obj.readLocation = message.readLocation;
    }
    if (message.writeLocation !== "") {
      obj.writeLocation = message.writeLocation;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<FetchAccessTokenResponse>): FetchAccessTokenResponse {
    return FetchAccessTokenResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FetchAccessTokenResponse>): FetchAccessTokenResponse {
    const message = createBaseFetchAccessTokenResponse();
    message.readLocation = object.readLocation ?? "";
    message.writeLocation = object.writeLocation ?? "";
    message.token = object.token ?? "";
    message.expireTime = object.expireTime ?? undefined;
    return message;
  },
};

function createBaseListBackupsRequest(): ListBackupsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "", view: 0 };
}

export const ListBackupsRequest: MessageFns<ListBackupsRequest> = {
  encode(message: ListBackupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    if (message.view !== 0) {
      writer.uint32(48).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBackupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBackupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBackupsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      view: isSet(object.view) ? backupViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: ListBackupsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.view !== 0) {
      obj.view = backupViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<ListBackupsRequest>): ListBackupsRequest {
    return ListBackupsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBackupsRequest>): ListBackupsRequest {
    const message = createBaseListBackupsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseListBackupsResponse(): ListBackupsResponse {
  return { backups: [], nextPageToken: "", unreachable: [] };
}

export const ListBackupsResponse: MessageFns<ListBackupsResponse> = {
  encode(message: ListBackupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.backups) {
      Backup.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListBackupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListBackupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.backups.push(Backup.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListBackupsResponse {
    return {
      backups: globalThis.Array.isArray(object?.backups) ? object.backups.map((e: any) => Backup.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListBackupsResponse): unknown {
    const obj: any = {};
    if (message.backups?.length) {
      obj.backups = message.backups.map((e) => Backup.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<ListBackupsResponse>): ListBackupsResponse {
    return ListBackupsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListBackupsResponse>): ListBackupsResponse {
    const message = createBaseListBackupsResponse();
    message.backups = object.backups?.map((e) => Backup.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetBackupRequest(): GetBackupRequest {
  return { name: "", view: 0 };
}

export const GetBackupRequest: MessageFns<GetBackupRequest> = {
  encode(message: GetBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBackupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? backupViewFromJSON(object.view) : 0,
    };
  },

  toJSON(message: GetBackupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = backupViewToJSON(message.view);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBackupRequest>): GetBackupRequest {
    return GetBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBackupRequest>): GetBackupRequest {
    const message = createBaseGetBackupRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    return message;
  },
};

function createBaseUpdateBackupRequest(): UpdateBackupRequest {
  return { updateMask: undefined, backup: undefined, requestId: "" };
}

export const UpdateBackupRequest: MessageFns<UpdateBackupRequest> = {
  encode(message: UpdateBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(10).fork()).join();
    }
    if (message.backup !== undefined) {
      Backup.encode(message.backup, writer.uint32(18).fork()).join();
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.backup = Backup.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBackupRequest {
    return {
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      backup: isSet(object.backup) ? Backup.fromJSON(object.backup) : undefined,
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: UpdateBackupRequest): unknown {
    const obj: any = {};
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.backup !== undefined) {
      obj.backup = Backup.toJSON(message.backup);
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateBackupRequest>): UpdateBackupRequest {
    return UpdateBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateBackupRequest>): UpdateBackupRequest {
    const message = createBaseUpdateBackupRequest();
    message.updateMask = object.updateMask ?? undefined;
    message.backup = (object.backup !== undefined && object.backup !== null)
      ? Backup.fromPartial(object.backup)
      : undefined;
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseDeleteBackupRequest(): DeleteBackupRequest {
  return { name: "", requestId: "" };
}

export const DeleteBackupRequest: MessageFns<DeleteBackupRequest> = {
  encode(message: DeleteBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteBackupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
    };
  },

  toJSON(message: DeleteBackupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteBackupRequest>): DeleteBackupRequest {
    return DeleteBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteBackupRequest>): DeleteBackupRequest {
    const message = createBaseDeleteBackupRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseRestoreBackupRequest(): RestoreBackupRequest {
  return {
    name: "",
    requestId: "",
    computeInstanceTargetEnvironment: undefined,
    computeInstanceRestoreProperties: undefined,
  };
}

export const RestoreBackupRequest: MessageFns<RestoreBackupRequest> = {
  encode(message: RestoreBackupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.requestId !== "") {
      writer.uint32(18).string(message.requestId);
    }
    if (message.computeInstanceTargetEnvironment !== undefined) {
      ComputeInstanceTargetEnvironment.encode(message.computeInstanceTargetEnvironment, writer.uint32(26).fork())
        .join();
    }
    if (message.computeInstanceRestoreProperties !== undefined) {
      ComputeInstanceRestoreProperties.encode(message.computeInstanceRestoreProperties, writer.uint32(34).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreBackupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreBackupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.computeInstanceTargetEnvironment = ComputeInstanceTargetEnvironment.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.computeInstanceRestoreProperties = ComputeInstanceRestoreProperties.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreBackupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      computeInstanceTargetEnvironment: isSet(object.computeInstanceTargetEnvironment)
        ? ComputeInstanceTargetEnvironment.fromJSON(object.computeInstanceTargetEnvironment)
        : undefined,
      computeInstanceRestoreProperties: isSet(object.computeInstanceRestoreProperties)
        ? ComputeInstanceRestoreProperties.fromJSON(object.computeInstanceRestoreProperties)
        : undefined,
    };
  },

  toJSON(message: RestoreBackupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.computeInstanceTargetEnvironment !== undefined) {
      obj.computeInstanceTargetEnvironment = ComputeInstanceTargetEnvironment.toJSON(
        message.computeInstanceTargetEnvironment,
      );
    }
    if (message.computeInstanceRestoreProperties !== undefined) {
      obj.computeInstanceRestoreProperties = ComputeInstanceRestoreProperties.toJSON(
        message.computeInstanceRestoreProperties,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<RestoreBackupRequest>): RestoreBackupRequest {
    return RestoreBackupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestoreBackupRequest>): RestoreBackupRequest {
    const message = createBaseRestoreBackupRequest();
    message.name = object.name ?? "";
    message.requestId = object.requestId ?? "";
    message.computeInstanceTargetEnvironment =
      (object.computeInstanceTargetEnvironment !== undefined && object.computeInstanceTargetEnvironment !== null)
        ? ComputeInstanceTargetEnvironment.fromPartial(object.computeInstanceTargetEnvironment)
        : undefined;
    message.computeInstanceRestoreProperties =
      (object.computeInstanceRestoreProperties !== undefined && object.computeInstanceRestoreProperties !== null)
        ? ComputeInstanceRestoreProperties.fromPartial(object.computeInstanceRestoreProperties)
        : undefined;
    return message;
  },
};

function createBaseRestoreBackupResponse(): RestoreBackupResponse {
  return { targetResource: undefined };
}

export const RestoreBackupResponse: MessageFns<RestoreBackupResponse> = {
  encode(message: RestoreBackupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetResource !== undefined) {
      TargetResource.encode(message.targetResource, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreBackupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreBackupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetResource = TargetResource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreBackupResponse {
    return {
      targetResource: isSet(object.targetResource) ? TargetResource.fromJSON(object.targetResource) : undefined,
    };
  },

  toJSON(message: RestoreBackupResponse): unknown {
    const obj: any = {};
    if (message.targetResource !== undefined) {
      obj.targetResource = TargetResource.toJSON(message.targetResource);
    }
    return obj;
  },

  create(base?: DeepPartial<RestoreBackupResponse>): RestoreBackupResponse {
    return RestoreBackupResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RestoreBackupResponse>): RestoreBackupResponse {
    const message = createBaseRestoreBackupResponse();
    message.targetResource = (object.targetResource !== undefined && object.targetResource !== null)
      ? TargetResource.fromPartial(object.targetResource)
      : undefined;
    return message;
  },
};

function createBaseTargetResource(): TargetResource {
  return { gcpResource: undefined };
}

export const TargetResource: MessageFns<TargetResource> = {
  encode(message: TargetResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcpResource !== undefined) {
      GcpResource.encode(message.gcpResource, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TargetResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargetResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcpResource = GcpResource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TargetResource {
    return { gcpResource: isSet(object.gcpResource) ? GcpResource.fromJSON(object.gcpResource) : undefined };
  },

  toJSON(message: TargetResource): unknown {
    const obj: any = {};
    if (message.gcpResource !== undefined) {
      obj.gcpResource = GcpResource.toJSON(message.gcpResource);
    }
    return obj;
  },

  create(base?: DeepPartial<TargetResource>): TargetResource {
    return TargetResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TargetResource>): TargetResource {
    const message = createBaseTargetResource();
    message.gcpResource = (object.gcpResource !== undefined && object.gcpResource !== null)
      ? GcpResource.fromPartial(object.gcpResource)
      : undefined;
    return message;
  },
};

function createBaseGcpResource(): GcpResource {
  return { gcpResourcename: "", location: "", type: "" };
}

export const GcpResource: MessageFns<GcpResource> = {
  encode(message: GcpResource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gcpResourcename !== "") {
      writer.uint32(10).string(message.gcpResourcename);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GcpResource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGcpResource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.gcpResourcename = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GcpResource {
    return {
      gcpResourcename: isSet(object.gcpResourcename) ? globalThis.String(object.gcpResourcename) : "",
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: GcpResource): unknown {
    const obj: any = {};
    if (message.gcpResourcename !== "") {
      obj.gcpResourcename = message.gcpResourcename;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<GcpResource>): GcpResource {
    return GcpResource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GcpResource>): GcpResource {
    const message = createBaseGcpResource();
    message.gcpResourcename = object.gcpResourcename ?? "";
    message.location = object.location ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
