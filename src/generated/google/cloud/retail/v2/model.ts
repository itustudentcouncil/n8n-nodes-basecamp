// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/retail/v2/model.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  RecommendationsFilteringOption,
  recommendationsFilteringOptionFromJSON,
  recommendationsFilteringOptionToJSON,
} from "./common.js";

export const protobufPackage = "google.cloud.retail.v2";

/**
 * Metadata that describes the training and serving parameters of a
 * [Model][google.cloud.retail.v2.Model]. A
 * [Model][google.cloud.retail.v2.Model] can be associated with a
 * [ServingConfig][google.cloud.retail.v2.ServingConfig] and then queried
 * through the Predict API.
 */
export interface Model {
  /**
   * Required. The fully qualified resource name of the model.
   *
   * Format:
   * `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/models/{model_id}`
   * catalog_id has char limit of 50.
   * recommendation_model_id has char limit of 40.
   */
  name: string;
  /**
   * Required. The display name of the model.
   *
   * Should be human readable, used to display Recommendation Models in the
   * Retail Cloud Console Dashboard. UTF-8 encoded string with limit of 1024
   * characters.
   */
  displayName: string;
  /**
   * Optional. The training state that the model is in (e.g.
   * `TRAINING` or `PAUSED`).
   *
   * Since part of the cost of running the service
   * is frequency of training - this can be used to determine when to train
   * model in order to control cost. If not specified: the default value for
   * `CreateModel` method is `TRAINING`. The default value for
   * `UpdateModel` method is to keep the state the same as before.
   */
  trainingState: Model_TrainingState;
  /** Output only. The serving state of the model: `ACTIVE`, `NOT_ACTIVE`. */
  servingState: Model_ServingState;
  /** Output only. Timestamp the Recommendation Model was created at. */
  createTime:
    | Date
    | undefined;
  /**
   * Output only. Timestamp the Recommendation Model was last updated. E.g.
   * if a Recommendation Model was paused - this would be the time the pause was
   * initiated.
   */
  updateTime:
    | Date
    | undefined;
  /**
   * Required. The type of model e.g. `home-page`.
   *
   * Currently supported values: `recommended-for-you`, `others-you-may-like`,
   * `frequently-bought-together`, `page-optimization`, `similar-items`,
   * `buy-it-again`, `on-sale-items`, and `recently-viewed`(readonly value).
   *
   * This field together with
   * [optimization_objective][google.cloud.retail.v2.Model.optimization_objective]
   * describe model metadata to use to control model training and serving.
   * See https://cloud.google.com/retail/docs/models
   * for more details on what the model metadata control and which combination
   * of parameters are valid. For invalid combinations of parameters (e.g. type
   * = `frequently-bought-together` and optimization_objective = `ctr`), you
   * receive an error 400 if you try to create/update a recommendation with
   * this set of knobs.
   */
  type: string;
  /**
   * Optional. The optimization objective e.g. `cvr`.
   *
   * Currently supported
   * values: `ctr`, `cvr`, `revenue-per-order`.
   *
   *  If not specified, we choose default based on model type.
   * Default depends on type of recommendation:
   *
   * `recommended-for-you` => `ctr`
   *
   * `others-you-may-like` => `ctr`
   *
   * `frequently-bought-together` => `revenue_per_order`
   *
   * This field together with
   * [optimization_objective][google.cloud.retail.v2.Model.type]
   * describe model metadata to use to control model training and serving.
   * See https://cloud.google.com/retail/docs/models
   * for more details on what the model metadata control and which combination
   * of parameters are valid. For invalid combinations of parameters (e.g. type
   * = `frequently-bought-together` and optimization_objective = `ctr`), you
   * receive an error 400 if you try to create/update a recommendation with
   * this set of knobs.
   */
  optimizationObjective: string;
  /**
   * Optional. The state of periodic tuning.
   *
   * The period we use is 3 months - to do a
   * one-off tune earlier use the `TuneModel` method. Default value
   * is `PERIODIC_TUNING_ENABLED`.
   */
  periodicTuningState: Model_PeriodicTuningState;
  /** Output only. The timestamp when the latest successful tune finished. */
  lastTuneTime:
    | Date
    | undefined;
  /**
   * Output only. The tune operation associated with the model.
   *
   * Can be used to determine if there is an ongoing tune for this
   * recommendation. Empty field implies no tune is goig on.
   */
  tuningOperation: string;
  /**
   * Output only. The state of data requirements for this model: `DATA_OK` and
   * `DATA_ERROR`.
   *
   * Recommendation model cannot be trained if the data is in
   * `DATA_ERROR` state. Recommendation model can have `DATA_ERROR` state even
   * if serving state is `ACTIVE`: models were trained successfully before, but
   * cannot be refreshed because model no longer has sufficient
   * data for training.
   */
  dataState: Model_DataState;
  /**
   * Optional. If `RECOMMENDATIONS_FILTERING_ENABLED`, recommendation filtering
   * by attributes is enabled for the model.
   */
  filteringOption: RecommendationsFilteringOption;
  /**
   * Output only. The list of valid serving configs associated with the
   * PageOptimizationConfig.
   */
  servingConfigLists: Model_ServingConfigList[];
  /** Optional. Additional model features config. */
  modelFeaturesConfig: Model_ModelFeaturesConfig | undefined;
}

/** The serving state of the model. */
export enum Model_ServingState {
  /** SERVING_STATE_UNSPECIFIED - Unspecified serving state. */
  SERVING_STATE_UNSPECIFIED = 0,
  /** INACTIVE - The model is not serving. */
  INACTIVE = 1,
  /** ACTIVE - The model is serving and can be queried. */
  ACTIVE = 2,
  /**
   * TUNED - The model is trained on tuned hyperparameters and can be
   * queried.
   */
  TUNED = 3,
  UNRECOGNIZED = -1,
}

export function model_ServingStateFromJSON(object: any): Model_ServingState {
  switch (object) {
    case 0:
    case "SERVING_STATE_UNSPECIFIED":
      return Model_ServingState.SERVING_STATE_UNSPECIFIED;
    case 1:
    case "INACTIVE":
      return Model_ServingState.INACTIVE;
    case 2:
    case "ACTIVE":
      return Model_ServingState.ACTIVE;
    case 3:
    case "TUNED":
      return Model_ServingState.TUNED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Model_ServingState.UNRECOGNIZED;
  }
}

export function model_ServingStateToJSON(object: Model_ServingState): string {
  switch (object) {
    case Model_ServingState.SERVING_STATE_UNSPECIFIED:
      return "SERVING_STATE_UNSPECIFIED";
    case Model_ServingState.INACTIVE:
      return "INACTIVE";
    case Model_ServingState.ACTIVE:
      return "ACTIVE";
    case Model_ServingState.TUNED:
      return "TUNED";
    case Model_ServingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The training state of the model. */
export enum Model_TrainingState {
  /** TRAINING_STATE_UNSPECIFIED - Unspecified training state. */
  TRAINING_STATE_UNSPECIFIED = 0,
  /** PAUSED - The model training is paused. */
  PAUSED = 1,
  /** TRAINING - The model is training. */
  TRAINING = 2,
  UNRECOGNIZED = -1,
}

export function model_TrainingStateFromJSON(object: any): Model_TrainingState {
  switch (object) {
    case 0:
    case "TRAINING_STATE_UNSPECIFIED":
      return Model_TrainingState.TRAINING_STATE_UNSPECIFIED;
    case 1:
    case "PAUSED":
      return Model_TrainingState.PAUSED;
    case 2:
    case "TRAINING":
      return Model_TrainingState.TRAINING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Model_TrainingState.UNRECOGNIZED;
  }
}

export function model_TrainingStateToJSON(object: Model_TrainingState): string {
  switch (object) {
    case Model_TrainingState.TRAINING_STATE_UNSPECIFIED:
      return "TRAINING_STATE_UNSPECIFIED";
    case Model_TrainingState.PAUSED:
      return "PAUSED";
    case Model_TrainingState.TRAINING:
      return "TRAINING";
    case Model_TrainingState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Describes whether periodic tuning is enabled for this model
 * or not. Periodic tuning is scheduled at most every three months. You can
 * start a tuning process manually by using the `TuneModel`
 * method, which starts a tuning process immediately and resets the quarterly
 * schedule. Enabling or disabling periodic tuning does not affect any
 * current tuning processes.
 */
export enum Model_PeriodicTuningState {
  /** PERIODIC_TUNING_STATE_UNSPECIFIED - Unspecified default value, should never be explicitly set. */
  PERIODIC_TUNING_STATE_UNSPECIFIED = 0,
  /**
   * PERIODIC_TUNING_DISABLED - The model has periodic tuning disabled. Tuning
   * can be reenabled by calling the `EnableModelPeriodicTuning`
   * method or by calling the `TuneModel` method.
   */
  PERIODIC_TUNING_DISABLED = 1,
  /**
   * ALL_TUNING_DISABLED - The model cannot be tuned with periodic tuning OR the
   * `TuneModel` method. Hide the options in customer UI and
   * reject any requests through the backend self serve API.
   */
  ALL_TUNING_DISABLED = 3,
  /**
   * PERIODIC_TUNING_ENABLED - The model has periodic tuning enabled. Tuning
   * can be disabled by calling the `DisableModelPeriodicTuning`
   * method.
   */
  PERIODIC_TUNING_ENABLED = 2,
  UNRECOGNIZED = -1,
}

export function model_PeriodicTuningStateFromJSON(object: any): Model_PeriodicTuningState {
  switch (object) {
    case 0:
    case "PERIODIC_TUNING_STATE_UNSPECIFIED":
      return Model_PeriodicTuningState.PERIODIC_TUNING_STATE_UNSPECIFIED;
    case 1:
    case "PERIODIC_TUNING_DISABLED":
      return Model_PeriodicTuningState.PERIODIC_TUNING_DISABLED;
    case 3:
    case "ALL_TUNING_DISABLED":
      return Model_PeriodicTuningState.ALL_TUNING_DISABLED;
    case 2:
    case "PERIODIC_TUNING_ENABLED":
      return Model_PeriodicTuningState.PERIODIC_TUNING_ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Model_PeriodicTuningState.UNRECOGNIZED;
  }
}

export function model_PeriodicTuningStateToJSON(object: Model_PeriodicTuningState): string {
  switch (object) {
    case Model_PeriodicTuningState.PERIODIC_TUNING_STATE_UNSPECIFIED:
      return "PERIODIC_TUNING_STATE_UNSPECIFIED";
    case Model_PeriodicTuningState.PERIODIC_TUNING_DISABLED:
      return "PERIODIC_TUNING_DISABLED";
    case Model_PeriodicTuningState.ALL_TUNING_DISABLED:
      return "ALL_TUNING_DISABLED";
    case Model_PeriodicTuningState.PERIODIC_TUNING_ENABLED:
      return "PERIODIC_TUNING_ENABLED";
    case Model_PeriodicTuningState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Describes whether this model have sufficient training data
 * to be continuously trained.
 */
export enum Model_DataState {
  /** DATA_STATE_UNSPECIFIED - Unspecified default value, should never be explicitly set. */
  DATA_STATE_UNSPECIFIED = 0,
  /** DATA_OK - The model has sufficient training data. */
  DATA_OK = 1,
  /**
   * DATA_ERROR - The model does not have sufficient training data. Error
   * messages can be queried via Stackdriver.
   */
  DATA_ERROR = 2,
  UNRECOGNIZED = -1,
}

export function model_DataStateFromJSON(object: any): Model_DataState {
  switch (object) {
    case 0:
    case "DATA_STATE_UNSPECIFIED":
      return Model_DataState.DATA_STATE_UNSPECIFIED;
    case 1:
    case "DATA_OK":
      return Model_DataState.DATA_OK;
    case 2:
    case "DATA_ERROR":
      return Model_DataState.DATA_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Model_DataState.UNRECOGNIZED;
  }
}

export function model_DataStateToJSON(object: Model_DataState): string {
  switch (object) {
    case Model_DataState.DATA_STATE_UNSPECIFIED:
      return "DATA_STATE_UNSPECIFIED";
    case Model_DataState.DATA_OK:
      return "DATA_OK";
    case Model_DataState.DATA_ERROR:
      return "DATA_ERROR";
    case Model_DataState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Use single or multiple context products for recommendations. */
export enum Model_ContextProductsType {
  /**
   * CONTEXT_PRODUCTS_TYPE_UNSPECIFIED - Unspecified default value, should never be explicitly set.
   * Defaults to
   * [MULTIPLE_CONTEXT_PRODUCTS][google.cloud.retail.v2.Model.ContextProductsType.MULTIPLE_CONTEXT_PRODUCTS].
   */
  CONTEXT_PRODUCTS_TYPE_UNSPECIFIED = 0,
  /**
   * SINGLE_CONTEXT_PRODUCT - Use only a single product as context for the recommendation. Typically
   * used on pages like add-to-cart or product details.
   */
  SINGLE_CONTEXT_PRODUCT = 1,
  /**
   * MULTIPLE_CONTEXT_PRODUCTS - Use one or multiple products as context for the recommendation. Typically
   * used on shopping cart pages.
   */
  MULTIPLE_CONTEXT_PRODUCTS = 2,
  UNRECOGNIZED = -1,
}

export function model_ContextProductsTypeFromJSON(object: any): Model_ContextProductsType {
  switch (object) {
    case 0:
    case "CONTEXT_PRODUCTS_TYPE_UNSPECIFIED":
      return Model_ContextProductsType.CONTEXT_PRODUCTS_TYPE_UNSPECIFIED;
    case 1:
    case "SINGLE_CONTEXT_PRODUCT":
      return Model_ContextProductsType.SINGLE_CONTEXT_PRODUCT;
    case 2:
    case "MULTIPLE_CONTEXT_PRODUCTS":
      return Model_ContextProductsType.MULTIPLE_CONTEXT_PRODUCTS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Model_ContextProductsType.UNRECOGNIZED;
  }
}

export function model_ContextProductsTypeToJSON(object: Model_ContextProductsType): string {
  switch (object) {
    case Model_ContextProductsType.CONTEXT_PRODUCTS_TYPE_UNSPECIFIED:
      return "CONTEXT_PRODUCTS_TYPE_UNSPECIFIED";
    case Model_ContextProductsType.SINGLE_CONTEXT_PRODUCT:
      return "SINGLE_CONTEXT_PRODUCT";
    case Model_ContextProductsType.MULTIPLE_CONTEXT_PRODUCTS:
      return "MULTIPLE_CONTEXT_PRODUCTS";
    case Model_ContextProductsType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Represents an ordered combination of valid serving configs, which
 * can be used for `PAGE_OPTIMIZATION` recommendations.
 */
export interface Model_ServingConfigList {
  /**
   * Optional. A set of valid serving configs that may be used for
   * `PAGE_OPTIMIZATION`.
   */
  servingConfigIds: string[];
}

/** Additional configs for the frequently-bought-together model type. */
export interface Model_FrequentlyBoughtTogetherFeaturesConfig {
  /**
   * Optional. Specifies the context of the model when it is used in predict
   * requests. Can only be set for the `frequently-bought-together` type. If
   * it isn't specified, it defaults to
   * [MULTIPLE_CONTEXT_PRODUCTS][google.cloud.retail.v2.Model.ContextProductsType.MULTIPLE_CONTEXT_PRODUCTS].
   */
  contextProductsType: Model_ContextProductsType;
}

/** Additional model features config. */
export interface Model_ModelFeaturesConfig {
  /** Additional configs for frequently-bought-together models. */
  frequentlyBoughtTogetherConfig?: Model_FrequentlyBoughtTogetherFeaturesConfig | undefined;
}

function createBaseModel(): Model {
  return {
    name: "",
    displayName: "",
    trainingState: 0,
    servingState: 0,
    createTime: undefined,
    updateTime: undefined,
    type: "",
    optimizationObjective: "",
    periodicTuningState: 0,
    lastTuneTime: undefined,
    tuningOperation: "",
    dataState: 0,
    filteringOption: 0,
    servingConfigLists: [],
    modelFeaturesConfig: undefined,
  };
}

export const Model: MessageFns<Model> = {
  encode(message: Model, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.trainingState !== 0) {
      writer.uint32(24).int32(message.trainingState);
    }
    if (message.servingState !== 0) {
      writer.uint32(32).int32(message.servingState);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(58).string(message.type);
    }
    if (message.optimizationObjective !== "") {
      writer.uint32(66).string(message.optimizationObjective);
    }
    if (message.periodicTuningState !== 0) {
      writer.uint32(88).int32(message.periodicTuningState);
    }
    if (message.lastTuneTime !== undefined) {
      Timestamp.encode(toTimestamp(message.lastTuneTime), writer.uint32(98).fork()).join();
    }
    if (message.tuningOperation !== "") {
      writer.uint32(122).string(message.tuningOperation);
    }
    if (message.dataState !== 0) {
      writer.uint32(128).int32(message.dataState);
    }
    if (message.filteringOption !== 0) {
      writer.uint32(144).int32(message.filteringOption);
    }
    for (const v of message.servingConfigLists) {
      Model_ServingConfigList.encode(v!, writer.uint32(154).fork()).join();
    }
    if (message.modelFeaturesConfig !== undefined) {
      Model_ModelFeaturesConfig.encode(message.modelFeaturesConfig, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Model {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.trainingState = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.servingState = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.type = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.optimizationObjective = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.periodicTuningState = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.lastTuneTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.tuningOperation = reader.string();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.dataState = reader.int32() as any;
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.filteringOption = reader.int32() as any;
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.servingConfigLists.push(Model_ServingConfigList.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.modelFeaturesConfig = Model_ModelFeaturesConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      trainingState: isSet(object.trainingState) ? model_TrainingStateFromJSON(object.trainingState) : 0,
      servingState: isSet(object.servingState) ? model_ServingStateFromJSON(object.servingState) : 0,
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      optimizationObjective: isSet(object.optimizationObjective) ? globalThis.String(object.optimizationObjective) : "",
      periodicTuningState: isSet(object.periodicTuningState)
        ? model_PeriodicTuningStateFromJSON(object.periodicTuningState)
        : 0,
      lastTuneTime: isSet(object.lastTuneTime) ? fromJsonTimestamp(object.lastTuneTime) : undefined,
      tuningOperation: isSet(object.tuningOperation) ? globalThis.String(object.tuningOperation) : "",
      dataState: isSet(object.dataState) ? model_DataStateFromJSON(object.dataState) : 0,
      filteringOption: isSet(object.filteringOption)
        ? recommendationsFilteringOptionFromJSON(object.filteringOption)
        : 0,
      servingConfigLists: globalThis.Array.isArray(object?.servingConfigLists)
        ? object.servingConfigLists.map((e: any) => Model_ServingConfigList.fromJSON(e))
        : [],
      modelFeaturesConfig: isSet(object.modelFeaturesConfig)
        ? Model_ModelFeaturesConfig.fromJSON(object.modelFeaturesConfig)
        : undefined,
    };
  },

  toJSON(message: Model): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.trainingState !== 0) {
      obj.trainingState = model_TrainingStateToJSON(message.trainingState);
    }
    if (message.servingState !== 0) {
      obj.servingState = model_ServingStateToJSON(message.servingState);
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.optimizationObjective !== "") {
      obj.optimizationObjective = message.optimizationObjective;
    }
    if (message.periodicTuningState !== 0) {
      obj.periodicTuningState = model_PeriodicTuningStateToJSON(message.periodicTuningState);
    }
    if (message.lastTuneTime !== undefined) {
      obj.lastTuneTime = message.lastTuneTime.toISOString();
    }
    if (message.tuningOperation !== "") {
      obj.tuningOperation = message.tuningOperation;
    }
    if (message.dataState !== 0) {
      obj.dataState = model_DataStateToJSON(message.dataState);
    }
    if (message.filteringOption !== 0) {
      obj.filteringOption = recommendationsFilteringOptionToJSON(message.filteringOption);
    }
    if (message.servingConfigLists?.length) {
      obj.servingConfigLists = message.servingConfigLists.map((e) => Model_ServingConfigList.toJSON(e));
    }
    if (message.modelFeaturesConfig !== undefined) {
      obj.modelFeaturesConfig = Model_ModelFeaturesConfig.toJSON(message.modelFeaturesConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Model>): Model {
    return Model.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Model>): Model {
    const message = createBaseModel();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.trainingState = object.trainingState ?? 0;
    message.servingState = object.servingState ?? 0;
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.type = object.type ?? "";
    message.optimizationObjective = object.optimizationObjective ?? "";
    message.periodicTuningState = object.periodicTuningState ?? 0;
    message.lastTuneTime = object.lastTuneTime ?? undefined;
    message.tuningOperation = object.tuningOperation ?? "";
    message.dataState = object.dataState ?? 0;
    message.filteringOption = object.filteringOption ?? 0;
    message.servingConfigLists = object.servingConfigLists?.map((e) => Model_ServingConfigList.fromPartial(e)) || [];
    message.modelFeaturesConfig = (object.modelFeaturesConfig !== undefined && object.modelFeaturesConfig !== null)
      ? Model_ModelFeaturesConfig.fromPartial(object.modelFeaturesConfig)
      : undefined;
    return message;
  },
};

function createBaseModel_ServingConfigList(): Model_ServingConfigList {
  return { servingConfigIds: [] };
}

export const Model_ServingConfigList: MessageFns<Model_ServingConfigList> = {
  encode(message: Model_ServingConfigList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.servingConfigIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Model_ServingConfigList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel_ServingConfigList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.servingConfigIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model_ServingConfigList {
    return {
      servingConfigIds: globalThis.Array.isArray(object?.servingConfigIds)
        ? object.servingConfigIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Model_ServingConfigList): unknown {
    const obj: any = {};
    if (message.servingConfigIds?.length) {
      obj.servingConfigIds = message.servingConfigIds;
    }
    return obj;
  },

  create(base?: DeepPartial<Model_ServingConfigList>): Model_ServingConfigList {
    return Model_ServingConfigList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Model_ServingConfigList>): Model_ServingConfigList {
    const message = createBaseModel_ServingConfigList();
    message.servingConfigIds = object.servingConfigIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseModel_FrequentlyBoughtTogetherFeaturesConfig(): Model_FrequentlyBoughtTogetherFeaturesConfig {
  return { contextProductsType: 0 };
}

export const Model_FrequentlyBoughtTogetherFeaturesConfig: MessageFns<Model_FrequentlyBoughtTogetherFeaturesConfig> = {
  encode(
    message: Model_FrequentlyBoughtTogetherFeaturesConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.contextProductsType !== 0) {
      writer.uint32(16).int32(message.contextProductsType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Model_FrequentlyBoughtTogetherFeaturesConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel_FrequentlyBoughtTogetherFeaturesConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 16) {
            break;
          }

          message.contextProductsType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model_FrequentlyBoughtTogetherFeaturesConfig {
    return {
      contextProductsType: isSet(object.contextProductsType)
        ? model_ContextProductsTypeFromJSON(object.contextProductsType)
        : 0,
    };
  },

  toJSON(message: Model_FrequentlyBoughtTogetherFeaturesConfig): unknown {
    const obj: any = {};
    if (message.contextProductsType !== 0) {
      obj.contextProductsType = model_ContextProductsTypeToJSON(message.contextProductsType);
    }
    return obj;
  },

  create(
    base?: DeepPartial<Model_FrequentlyBoughtTogetherFeaturesConfig>,
  ): Model_FrequentlyBoughtTogetherFeaturesConfig {
    return Model_FrequentlyBoughtTogetherFeaturesConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Model_FrequentlyBoughtTogetherFeaturesConfig>,
  ): Model_FrequentlyBoughtTogetherFeaturesConfig {
    const message = createBaseModel_FrequentlyBoughtTogetherFeaturesConfig();
    message.contextProductsType = object.contextProductsType ?? 0;
    return message;
  },
};

function createBaseModel_ModelFeaturesConfig(): Model_ModelFeaturesConfig {
  return { frequentlyBoughtTogetherConfig: undefined };
}

export const Model_ModelFeaturesConfig: MessageFns<Model_ModelFeaturesConfig> = {
  encode(message: Model_ModelFeaturesConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.frequentlyBoughtTogetherConfig !== undefined) {
      Model_FrequentlyBoughtTogetherFeaturesConfig.encode(
        message.frequentlyBoughtTogetherConfig,
        writer.uint32(10).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Model_ModelFeaturesConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel_ModelFeaturesConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.frequentlyBoughtTogetherConfig = Model_FrequentlyBoughtTogetherFeaturesConfig.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model_ModelFeaturesConfig {
    return {
      frequentlyBoughtTogetherConfig: isSet(object.frequentlyBoughtTogetherConfig)
        ? Model_FrequentlyBoughtTogetherFeaturesConfig.fromJSON(object.frequentlyBoughtTogetherConfig)
        : undefined,
    };
  },

  toJSON(message: Model_ModelFeaturesConfig): unknown {
    const obj: any = {};
    if (message.frequentlyBoughtTogetherConfig !== undefined) {
      obj.frequentlyBoughtTogetherConfig = Model_FrequentlyBoughtTogetherFeaturesConfig.toJSON(
        message.frequentlyBoughtTogetherConfig,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<Model_ModelFeaturesConfig>): Model_ModelFeaturesConfig {
    return Model_ModelFeaturesConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Model_ModelFeaturesConfig>): Model_ModelFeaturesConfig {
    const message = createBaseModel_ModelFeaturesConfig();
    message.frequentlyBoughtTogetherConfig =
      (object.frequentlyBoughtTogetherConfig !== undefined && object.frequentlyBoughtTogetherConfig !== null)
        ? Model_FrequentlyBoughtTogetherFeaturesConfig.fromPartial(object.frequentlyBoughtTogetherConfig)
        : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
