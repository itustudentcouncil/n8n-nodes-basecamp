// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/retail/v2alpha/catalog.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import {
  AttributeConfigLevel,
  attributeConfigLevelFromJSON,
  attributeConfigLevelToJSON,
  Interval,
  RecommendationsFilteringOption,
  recommendationsFilteringOptionFromJSON,
  recommendationsFilteringOptionToJSON,
} from "./common.js";
import { CompletionDataInputConfig } from "./import_config.js";

export const protobufPackage = "google.cloud.retail.v2alpha";

/**
 * Configures what level the product should be uploaded with regards to
 * how users will be send events and how predictions will be made.
 */
export interface ProductLevelConfig {
  /**
   * The type of [Product][google.cloud.retail.v2alpha.Product]s allowed to be
   * ingested into the catalog. Acceptable values are:
   *
   * * `primary` (default): You can ingest
   * [Product][google.cloud.retail.v2alpha.Product]s of all types. When
   *   ingesting a [Product][google.cloud.retail.v2alpha.Product], its type will
   *   default to
   *   [Product.Type.PRIMARY][google.cloud.retail.v2alpha.Product.Type.PRIMARY]
   *   if unset.
   * * `variant` (incompatible with Retail Search): You can only
   *   ingest
   *   [Product.Type.VARIANT][google.cloud.retail.v2alpha.Product.Type.VARIANT]
   *   [Product][google.cloud.retail.v2alpha.Product]s. This means
   *   [Product.primary_product_id][google.cloud.retail.v2alpha.Product.primary_product_id]
   *   cannot be empty.
   *
   * If this field is set to an invalid value other than these, an
   * INVALID_ARGUMENT error is returned.
   *
   * If this field is `variant` and
   * [merchant_center_product_id_field][google.cloud.retail.v2alpha.ProductLevelConfig.merchant_center_product_id_field]
   * is `itemGroupId`, an INVALID_ARGUMENT error is returned.
   *
   * See [Product
   * levels](https://cloud.google.com/retail/docs/catalog#product-levels)
   * for more details.
   */
  ingestionProductType: string;
  /**
   * Which field of [Merchant Center
   * Product](/bigquery-transfer/docs/merchant-center-products-schema) should be
   * imported as [Product.id][google.cloud.retail.v2alpha.Product.id].
   * Acceptable values are:
   *
   * * `offerId` (default): Import `offerId` as the product ID.
   * * `itemGroupId`: Import `itemGroupId` as the product ID. Notice that Retail
   *   API will choose one item from the ones with the same `itemGroupId`, and
   *   use it to represent the item group.
   *
   * If this field is set to an invalid value other than these, an
   * INVALID_ARGUMENT error is returned.
   *
   * If this field is `itemGroupId` and
   * [ingestion_product_type][google.cloud.retail.v2alpha.ProductLevelConfig.ingestion_product_type]
   * is `variant`, an INVALID_ARGUMENT error is returned.
   *
   * See [Product
   * levels](https://cloud.google.com/retail/docs/catalog#product-levels)
   * for more details.
   */
  merchantCenterProductIdField: string;
}

/**
 * Catalog level attribute config for an attribute. For example, if customers
 * want to enable/disable facet for a specific attribute.
 */
export interface CatalogAttribute {
  /**
   * Required. Attribute name.
   * For example: `color`, `brands`, `attributes.custom_attribute`, such as
   * `attributes.xyz`.
   * To be indexable, the attribute name can contain only alpha-numeric
   * characters and underscores. For example, an attribute named
   * `attributes.abc_xyz` can be indexed, but an attribute named
   * `attributes.abc-xyz` cannot be indexed.
   *
   * If the attribute key starts with `attributes.`, then the attribute is a
   * custom attribute. Attributes such as `brands`, `patterns`, and `title` are
   * built-in and called system attributes.
   */
  key: string;
  /**
   * Output only. Indicates whether this attribute has been used by any
   * products. `True` if at least one
   * [Product][google.cloud.retail.v2alpha.Product] is using this attribute in
   * [Product.attributes][google.cloud.retail.v2alpha.Product.attributes].
   * Otherwise, this field is `False`.
   *
   * [CatalogAttribute][google.cloud.retail.v2alpha.CatalogAttribute] can be
   * pre-loaded by using
   * [CatalogService.AddCatalogAttribute][google.cloud.retail.v2alpha.CatalogService.AddCatalogAttribute],
   * [CatalogService.ImportCatalogAttributes][google.cloud.retail.v2alpha.CatalogService.ImportCatalogAttributes],
   * or
   * [CatalogService.UpdateAttributesConfig][google.cloud.retail.v2alpha.CatalogService.UpdateAttributesConfig]
   * APIs. This field is `False` for pre-loaded
   * [CatalogAttribute][google.cloud.retail.v2alpha.CatalogAttribute]s.
   *
   * Only pre-loaded [catalog
   * attributes][google.cloud.retail.v2alpha.CatalogAttribute] that are neither
   * in use by products nor predefined can be deleted. [Catalog
   * attributes][google.cloud.retail.v2alpha.CatalogAttribute] that are
   * either in use by products or are predefined attributes cannot be deleted;
   * however, their configuration properties will reset to default values upon
   * removal request.
   *
   * After catalog changes, it takes about 10 minutes for this field to update.
   */
  inUse: boolean;
  /**
   * Output only. The type of this attribute. This is derived from the attribute
   * in [Product.attributes][google.cloud.retail.v2alpha.Product.attributes].
   */
  type: CatalogAttribute_AttributeType;
  /**
   * When
   * [AttributesConfig.attribute_config_level][google.cloud.retail.v2alpha.AttributesConfig.attribute_config_level]
   * is CATALOG_LEVEL_ATTRIBUTE_CONFIG, if INDEXABLE_ENABLED attribute values
   * are indexed so that it can be filtered, faceted, or boosted in
   * [SearchService.Search][google.cloud.retail.v2alpha.SearchService.Search].
   *
   * Must be specified when
   * [AttributesConfig.attribute_config_level][google.cloud.retail.v2alpha.AttributesConfig.attribute_config_level]
   * is CATALOG_LEVEL_ATTRIBUTE_CONFIG, otherwise throws INVALID_FORMAT error.
   */
  indexableOption: CatalogAttribute_IndexableOption;
  /**
   * If DYNAMIC_FACETABLE_ENABLED, attribute values are available for dynamic
   * facet. Could only be DYNAMIC_FACETABLE_DISABLED if
   * [CatalogAttribute.indexable_option][google.cloud.retail.v2alpha.CatalogAttribute.indexable_option]
   * is INDEXABLE_DISABLED. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * Must be specified, otherwise throws INVALID_FORMAT error.
   */
  dynamicFacetableOption: CatalogAttribute_DynamicFacetableOption;
  /**
   * When
   * [AttributesConfig.attribute_config_level][google.cloud.retail.v2alpha.AttributesConfig.attribute_config_level]
   * is CATALOG_LEVEL_ATTRIBUTE_CONFIG, if SEARCHABLE_ENABLED, attribute values
   * are searchable by text queries in
   * [SearchService.Search][google.cloud.retail.v2alpha.SearchService.Search].
   *
   * If SEARCHABLE_ENABLED but attribute type is numerical, attribute values
   * will not be searchable by text queries in
   * [SearchService.Search][google.cloud.retail.v2alpha.SearchService.Search],
   * as there are no text values associated to numerical attributes.
   *
   * Must be specified, when
   * [AttributesConfig.attribute_config_level][google.cloud.retail.v2alpha.AttributesConfig.attribute_config_level]
   * is CATALOG_LEVEL_ATTRIBUTE_CONFIG, otherwise throws INVALID_FORMAT error.
   */
  searchableOption: CatalogAttribute_SearchableOption;
  /**
   * When
   * [AttributesConfig.attribute_config_level][google.cloud.retail.v2alpha.AttributesConfig.attribute_config_level]
   * is CATALOG_LEVEL_ATTRIBUTE_CONFIG, if RECOMMENDATIONS_FILTERING_ENABLED,
   * attribute values are filterable for recommendations.
   * This option works for categorical features only,
   * does not work for numerical features, inventory filtering.
   */
  recommendationsFilteringOption: RecommendationsFilteringOption;
  /**
   * If EXACT_SEARCHABLE_ENABLED, attribute values will be exact searchable.
   * This property only applies to textual custom attributes and requires
   * indexable set to enabled to enable exact-searchable. If unset, the server
   * behavior defaults to
   * [EXACT_SEARCHABLE_DISABLED][google.cloud.retail.v2alpha.CatalogAttribute.ExactSearchableOption.EXACT_SEARCHABLE_DISABLED].
   */
  exactSearchableOption: CatalogAttribute_ExactSearchableOption;
  /**
   * If RETRIEVABLE_ENABLED, attribute values are retrievable in the search
   * results. If unset, the server behavior defaults to
   * [RETRIEVABLE_DISABLED][google.cloud.retail.v2alpha.CatalogAttribute.RetrievableOption.RETRIEVABLE_DISABLED].
   */
  retrievableOption: CatalogAttribute_RetrievableOption;
  /** Contains facet options. */
  facetConfig: CatalogAttribute_FacetConfig | undefined;
}

/** The type of an attribute. */
export enum CatalogAttribute_AttributeType {
  /**
   * UNKNOWN - The type of the attribute is unknown.
   *
   * Used when type cannot be derived from attribute that is not
   * [in_use][google.cloud.retail.v2alpha.CatalogAttribute.in_use].
   */
  UNKNOWN = 0,
  /** TEXTUAL - Textual attribute. */
  TEXTUAL = 1,
  /** NUMERICAL - Numerical attribute. */
  NUMERICAL = 2,
  UNRECOGNIZED = -1,
}

export function catalogAttribute_AttributeTypeFromJSON(object: any): CatalogAttribute_AttributeType {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return CatalogAttribute_AttributeType.UNKNOWN;
    case 1:
    case "TEXTUAL":
      return CatalogAttribute_AttributeType.TEXTUAL;
    case 2:
    case "NUMERICAL":
      return CatalogAttribute_AttributeType.NUMERICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CatalogAttribute_AttributeType.UNRECOGNIZED;
  }
}

export function catalogAttribute_AttributeTypeToJSON(object: CatalogAttribute_AttributeType): string {
  switch (object) {
    case CatalogAttribute_AttributeType.UNKNOWN:
      return "UNKNOWN";
    case CatalogAttribute_AttributeType.TEXTUAL:
      return "TEXTUAL";
    case CatalogAttribute_AttributeType.NUMERICAL:
      return "NUMERICAL";
    case CatalogAttribute_AttributeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The status of the indexable option of a catalog attribute. */
export enum CatalogAttribute_IndexableOption {
  /** INDEXABLE_OPTION_UNSPECIFIED - Value used when unset. */
  INDEXABLE_OPTION_UNSPECIFIED = 0,
  /** INDEXABLE_ENABLED - Indexable option enabled for an attribute. */
  INDEXABLE_ENABLED = 1,
  /** INDEXABLE_DISABLED - Indexable option disabled for an attribute. */
  INDEXABLE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function catalogAttribute_IndexableOptionFromJSON(object: any): CatalogAttribute_IndexableOption {
  switch (object) {
    case 0:
    case "INDEXABLE_OPTION_UNSPECIFIED":
      return CatalogAttribute_IndexableOption.INDEXABLE_OPTION_UNSPECIFIED;
    case 1:
    case "INDEXABLE_ENABLED":
      return CatalogAttribute_IndexableOption.INDEXABLE_ENABLED;
    case 2:
    case "INDEXABLE_DISABLED":
      return CatalogAttribute_IndexableOption.INDEXABLE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CatalogAttribute_IndexableOption.UNRECOGNIZED;
  }
}

export function catalogAttribute_IndexableOptionToJSON(object: CatalogAttribute_IndexableOption): string {
  switch (object) {
    case CatalogAttribute_IndexableOption.INDEXABLE_OPTION_UNSPECIFIED:
      return "INDEXABLE_OPTION_UNSPECIFIED";
    case CatalogAttribute_IndexableOption.INDEXABLE_ENABLED:
      return "INDEXABLE_ENABLED";
    case CatalogAttribute_IndexableOption.INDEXABLE_DISABLED:
      return "INDEXABLE_DISABLED";
    case CatalogAttribute_IndexableOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The status of the dynamic facetable option of a catalog attribute. */
export enum CatalogAttribute_DynamicFacetableOption {
  /** DYNAMIC_FACETABLE_OPTION_UNSPECIFIED - Value used when unset. */
  DYNAMIC_FACETABLE_OPTION_UNSPECIFIED = 0,
  /** DYNAMIC_FACETABLE_ENABLED - Dynamic facetable option enabled for an attribute. */
  DYNAMIC_FACETABLE_ENABLED = 1,
  /** DYNAMIC_FACETABLE_DISABLED - Dynamic facetable option disabled for an attribute. */
  DYNAMIC_FACETABLE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function catalogAttribute_DynamicFacetableOptionFromJSON(object: any): CatalogAttribute_DynamicFacetableOption {
  switch (object) {
    case 0:
    case "DYNAMIC_FACETABLE_OPTION_UNSPECIFIED":
      return CatalogAttribute_DynamicFacetableOption.DYNAMIC_FACETABLE_OPTION_UNSPECIFIED;
    case 1:
    case "DYNAMIC_FACETABLE_ENABLED":
      return CatalogAttribute_DynamicFacetableOption.DYNAMIC_FACETABLE_ENABLED;
    case 2:
    case "DYNAMIC_FACETABLE_DISABLED":
      return CatalogAttribute_DynamicFacetableOption.DYNAMIC_FACETABLE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CatalogAttribute_DynamicFacetableOption.UNRECOGNIZED;
  }
}

export function catalogAttribute_DynamicFacetableOptionToJSON(object: CatalogAttribute_DynamicFacetableOption): string {
  switch (object) {
    case CatalogAttribute_DynamicFacetableOption.DYNAMIC_FACETABLE_OPTION_UNSPECIFIED:
      return "DYNAMIC_FACETABLE_OPTION_UNSPECIFIED";
    case CatalogAttribute_DynamicFacetableOption.DYNAMIC_FACETABLE_ENABLED:
      return "DYNAMIC_FACETABLE_ENABLED";
    case CatalogAttribute_DynamicFacetableOption.DYNAMIC_FACETABLE_DISABLED:
      return "DYNAMIC_FACETABLE_DISABLED";
    case CatalogAttribute_DynamicFacetableOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The status of the searchable option of a catalog attribute. */
export enum CatalogAttribute_SearchableOption {
  /** SEARCHABLE_OPTION_UNSPECIFIED - Value used when unset. */
  SEARCHABLE_OPTION_UNSPECIFIED = 0,
  /** SEARCHABLE_ENABLED - Searchable option enabled for an attribute. */
  SEARCHABLE_ENABLED = 1,
  /** SEARCHABLE_DISABLED - Searchable option disabled for an attribute. */
  SEARCHABLE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function catalogAttribute_SearchableOptionFromJSON(object: any): CatalogAttribute_SearchableOption {
  switch (object) {
    case 0:
    case "SEARCHABLE_OPTION_UNSPECIFIED":
      return CatalogAttribute_SearchableOption.SEARCHABLE_OPTION_UNSPECIFIED;
    case 1:
    case "SEARCHABLE_ENABLED":
      return CatalogAttribute_SearchableOption.SEARCHABLE_ENABLED;
    case 2:
    case "SEARCHABLE_DISABLED":
      return CatalogAttribute_SearchableOption.SEARCHABLE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CatalogAttribute_SearchableOption.UNRECOGNIZED;
  }
}

export function catalogAttribute_SearchableOptionToJSON(object: CatalogAttribute_SearchableOption): string {
  switch (object) {
    case CatalogAttribute_SearchableOption.SEARCHABLE_OPTION_UNSPECIFIED:
      return "SEARCHABLE_OPTION_UNSPECIFIED";
    case CatalogAttribute_SearchableOption.SEARCHABLE_ENABLED:
      return "SEARCHABLE_ENABLED";
    case CatalogAttribute_SearchableOption.SEARCHABLE_DISABLED:
      return "SEARCHABLE_DISABLED";
    case CatalogAttribute_SearchableOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The status of the exact-searchable option of a catalog attribute. */
export enum CatalogAttribute_ExactSearchableOption {
  /** EXACT_SEARCHABLE_OPTION_UNSPECIFIED - Value used when unset. */
  EXACT_SEARCHABLE_OPTION_UNSPECIFIED = 0,
  /** EXACT_SEARCHABLE_ENABLED - Exact searchable option enabled for an attribute. */
  EXACT_SEARCHABLE_ENABLED = 1,
  /** EXACT_SEARCHABLE_DISABLED - Exact searchable option disabled for an attribute. */
  EXACT_SEARCHABLE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function catalogAttribute_ExactSearchableOptionFromJSON(object: any): CatalogAttribute_ExactSearchableOption {
  switch (object) {
    case 0:
    case "EXACT_SEARCHABLE_OPTION_UNSPECIFIED":
      return CatalogAttribute_ExactSearchableOption.EXACT_SEARCHABLE_OPTION_UNSPECIFIED;
    case 1:
    case "EXACT_SEARCHABLE_ENABLED":
      return CatalogAttribute_ExactSearchableOption.EXACT_SEARCHABLE_ENABLED;
    case 2:
    case "EXACT_SEARCHABLE_DISABLED":
      return CatalogAttribute_ExactSearchableOption.EXACT_SEARCHABLE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CatalogAttribute_ExactSearchableOption.UNRECOGNIZED;
  }
}

export function catalogAttribute_ExactSearchableOptionToJSON(object: CatalogAttribute_ExactSearchableOption): string {
  switch (object) {
    case CatalogAttribute_ExactSearchableOption.EXACT_SEARCHABLE_OPTION_UNSPECIFIED:
      return "EXACT_SEARCHABLE_OPTION_UNSPECIFIED";
    case CatalogAttribute_ExactSearchableOption.EXACT_SEARCHABLE_ENABLED:
      return "EXACT_SEARCHABLE_ENABLED";
    case CatalogAttribute_ExactSearchableOption.EXACT_SEARCHABLE_DISABLED:
      return "EXACT_SEARCHABLE_DISABLED";
    case CatalogAttribute_ExactSearchableOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The status of the retrievable option of a catalog attribute. */
export enum CatalogAttribute_RetrievableOption {
  /** RETRIEVABLE_OPTION_UNSPECIFIED - Value used when unset. */
  RETRIEVABLE_OPTION_UNSPECIFIED = 0,
  /** RETRIEVABLE_ENABLED - Retrievable option enabled for an attribute. */
  RETRIEVABLE_ENABLED = 1,
  /** RETRIEVABLE_DISABLED - Retrievable option disabled for an attribute. */
  RETRIEVABLE_DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function catalogAttribute_RetrievableOptionFromJSON(object: any): CatalogAttribute_RetrievableOption {
  switch (object) {
    case 0:
    case "RETRIEVABLE_OPTION_UNSPECIFIED":
      return CatalogAttribute_RetrievableOption.RETRIEVABLE_OPTION_UNSPECIFIED;
    case 1:
    case "RETRIEVABLE_ENABLED":
      return CatalogAttribute_RetrievableOption.RETRIEVABLE_ENABLED;
    case 2:
    case "RETRIEVABLE_DISABLED":
      return CatalogAttribute_RetrievableOption.RETRIEVABLE_DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CatalogAttribute_RetrievableOption.UNRECOGNIZED;
  }
}

export function catalogAttribute_RetrievableOptionToJSON(object: CatalogAttribute_RetrievableOption): string {
  switch (object) {
    case CatalogAttribute_RetrievableOption.RETRIEVABLE_OPTION_UNSPECIFIED:
      return "RETRIEVABLE_OPTION_UNSPECIFIED";
    case CatalogAttribute_RetrievableOption.RETRIEVABLE_ENABLED:
      return "RETRIEVABLE_ENABLED";
    case CatalogAttribute_RetrievableOption.RETRIEVABLE_DISABLED:
      return "RETRIEVABLE_DISABLED";
    case CatalogAttribute_RetrievableOption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Possible options for the facet that corresponds to the current attribute
 * config.
 */
export interface CatalogAttribute_FacetConfig {
  /**
   * If you don't set the facet
   * [SearchRequest.FacetSpec.FacetKey.intervals][google.cloud.retail.v2alpha.SearchRequest.FacetSpec.FacetKey.intervals]
   * in the request to a numerical attribute, then we use the computed
   * intervals with rounded bounds obtained from all its product numerical
   * attribute values. The computed intervals might not be ideal for some
   * attributes. Therefore, we give you the option to overwrite them with the
   * facet_intervals field. The maximum of facet intervals per
   * [CatalogAttribute][google.cloud.retail.v2alpha.CatalogAttribute] is 40.
   * Each interval must have a lower bound or an upper bound. If both bounds
   * are provided, then the lower bound must be smaller or equal than the
   * upper bound.
   */
  facetIntervals: Interval[];
  /**
   * Each instance represents a list of attribute values to ignore as facet
   * values for a specific time range. The maximum number of instances per
   * [CatalogAttribute][google.cloud.retail.v2alpha.CatalogAttribute] is 25.
   */
  ignoredFacetValues: CatalogAttribute_FacetConfig_IgnoredFacetValues[];
  /**
   * Each instance replaces a list of facet values by a merged facet
   * value. If a facet value is not in any list, then it will stay the same.
   * To avoid conflicts, only paths of length 1 are accepted. In other words,
   * if "dark_blue" merged into "BLUE", then the latter can't merge into
   * "blues" because this would create a path of length 2. The maximum number
   * of instances of MergedFacetValue per
   * [CatalogAttribute][google.cloud.retail.v2alpha.CatalogAttribute] is 100.
   * This feature is available only for textual custom attributes.
   */
  mergedFacetValues: CatalogAttribute_FacetConfig_MergedFacetValue[];
  /**
   * Use this field only if you want to merge a facet key into another facet
   * key.
   */
  mergedFacet:
    | CatalogAttribute_FacetConfig_MergedFacet
    | undefined;
  /**
   * Set this field only if you want to rerank based on facet values engaged
   * by the user for the current key. This option is only possible for custom
   * facetable textual keys.
   */
  rerankConfig: CatalogAttribute_FacetConfig_RerankConfig | undefined;
}

/**
 * [Facet values][google.cloud.retail.v2alpha.SearchResponse.Facet.values]
 * to ignore on [facets][google.cloud.retail.v2alpha.SearchResponse.Facet]
 * during the specified time range for the given
 * [SearchResponse.Facet.key][google.cloud.retail.v2alpha.SearchResponse.Facet.key]
 * attribute.
 */
export interface CatalogAttribute_FacetConfig_IgnoredFacetValues {
  /**
   * List of facet values to ignore for the following time range. The facet
   * values are the same as the attribute values. There is a limit of 10
   * values per instance of IgnoredFacetValues. Each value can have at most
   * 128 characters.
   */
  values: string[];
  /**
   * Time range for the current list of facet values to ignore.
   * If multiple time ranges are specified for an facet value for the
   * current attribute, consider all of them. If both are empty, ignore
   * always. If start time and end time are set, then start time
   * must be before end time.
   * If start time is not empty and end time is empty, then will ignore
   * these facet values after the start time.
   */
  startTime:
    | Date
    | undefined;
  /**
   * If start time is empty and end time is not empty, then ignore these
   * facet values before end time.
   */
  endTime: Date | undefined;
}

/**
 * Replaces a set of textual facet values by the same (possibly different)
 * merged facet value. Each facet value should appear at most once as a
 * value per
 * [CatalogAttribute][google.cloud.retail.v2alpha.CatalogAttribute]. This
 * feature is available only for textual custom attributes.
 */
export interface CatalogAttribute_FacetConfig_MergedFacetValue {
  /**
   * All the facet values that are replaces by the same
   * [merged_value][google.cloud.retail.v2alpha.CatalogAttribute.FacetConfig.MergedFacetValue.merged_value]
   * that follows. The maximum number of values per MergedFacetValue is 25.
   * Each value can have up to 128 characters.
   */
  values: string[];
  /**
   * All the previous values are replaced by this merged facet value.
   * This merged_value must be non-empty and can have up to 128 characters.
   */
  mergedValue: string;
}

/**
 * The current facet key (i.e. attribute config) maps into the
 * [merged_facet_key][google.cloud.retail.v2alpha.CatalogAttribute.FacetConfig.MergedFacet.merged_facet_key].
 * A facet key can have at most one child. The current facet key and the
 * merged facet key need both to be textual custom attributes or both
 * numerical custom attributes (same type).
 */
export interface CatalogAttribute_FacetConfig_MergedFacet {
  /**
   * The merged facet key should be a valid facet key that is different than
   * the facet key of the current catalog attribute. We refer this is
   * merged facet key as the child of the current catalog attribute. This
   * merged facet key can't be a parent of another facet key (i.e. no
   * directed path of length 2). This merged facet key needs to be either a
   * textual custom attribute or a numerical custom attribute.
   */
  mergedFacetKey: string;
}

/**
 * Options to rerank based on facet values engaged by the user for the
 * current key. That key needs to be a custom textual key and facetable.
 * To use this control, you also need to pass all the facet keys engaged by
 * the user in the request using the field [SearchRequest.FacetSpec]. In
 * particular, if you don't pass the facet keys engaged that you want to
 * rerank on, this control won't be effective. Moreover, to obtain better
 * results, the facet values that you want to rerank on should be close to
 * English (ideally made of words, underscores, and spaces).
 */
export interface CatalogAttribute_FacetConfig_RerankConfig {
  /**
   * If set to true, then we also rerank the dynamic facets based on the
   * facet values engaged by the user for the current attribute key during
   * serving.
   */
  rerankFacet: boolean;
  /**
   * If empty, rerank on all facet values for the current key. Otherwise,
   * will rerank on the facet values from this list only.
   */
  facetValues: string[];
}

/** Catalog level attribute config. */
export interface AttributesConfig {
  /**
   * Required. Immutable. The fully qualified resource name of the attribute
   * config. Format: `projects/* /locations/* /catalogs/* /attributesConfig`
   */
  name: string;
  /**
   * Enable attribute(s) config at catalog level.
   * For example, indexable, dynamic_facetable, or searchable for each
   * attribute.
   *
   * The key is catalog attribute's name.
   * For example: `color`, `brands`, `attributes.custom_attribute`, such as
   * `attributes.xyz`.
   *
   * The maximum number of catalog attributes allowed in a request is 1000.
   */
  catalogAttributes: { [key: string]: CatalogAttribute };
  /**
   * Output only. The
   * [AttributeConfigLevel][google.cloud.retail.v2alpha.AttributeConfigLevel]
   * used for this catalog.
   */
  attributeConfigLevel: AttributeConfigLevel;
}

export interface AttributesConfig_CatalogAttributesEntry {
  key: string;
  value: CatalogAttribute | undefined;
}

/**
 * Catalog level autocomplete config for customers to customize autocomplete
 * feature's settings.
 */
export interface CompletionConfig {
  /**
   * Required. Immutable. Fully qualified name
   * `projects/* /locations/* /catalogs/* /completionConfig`
   */
  name: string;
  /**
   * Specifies the matching order for autocomplete suggestions, e.g., a query
   * consisting of 'sh' with 'out-of-order' specified would suggest "women's
   * shoes", whereas a query of 'red s' with 'exact-prefix' specified would
   * suggest "red shoes". Currently supported values:
   *
   * * 'out-of-order'
   * * 'exact-prefix'
   *
   * Default value: 'exact-prefix'.
   */
  matchingOrder: string;
  /**
   * The maximum number of autocomplete suggestions returned per term. Default
   * value is 20. If left unset or set to 0, then will fallback to default
   * value.
   *
   * Value range is 1 to 20.
   */
  maxSuggestions: number;
  /**
   * The minimum number of characters needed to be typed in order to get
   * suggestions. Default value is 2. If left unset or set to 0, then will
   * fallback to default value.
   *
   * Value range is 1 to 20.
   */
  minPrefixLength: number;
  /**
   * If set to true, the auto learning function is enabled. Auto learning uses
   * user data to generate suggestions using ML techniques. Default value is
   * false. Only after enabling auto learning can users use `cloud-retail`
   * data in
   * [CompleteQueryRequest][google.cloud.retail.v2alpha.CompleteQueryRequest].
   */
  autoLearning: boolean;
  /**
   * Output only. The source data for the latest import of the autocomplete
   * suggestion phrases.
   */
  suggestionsInputConfig:
    | CompletionDataInputConfig
    | undefined;
  /**
   * Output only. Name of the LRO corresponding to the latest suggestion terms
   * list import.
   *
   * Can use [GetOperation][google.longrunning.Operations.GetOperation] API
   * method to retrieve the latest state of the Long Running Operation.
   */
  lastSuggestionsImportOperation: string;
  /**
   * Output only. The source data for the latest import of the autocomplete
   * denylist phrases.
   */
  denylistInputConfig:
    | CompletionDataInputConfig
    | undefined;
  /**
   * Output only. Name of the LRO corresponding to the latest denylist import.
   *
   * Can use [GetOperation][google.longrunning.Operations.GetOperation] API to
   * retrieve the latest state of the Long Running Operation.
   */
  lastDenylistImportOperation: string;
  /**
   * Output only. The source data for the latest import of the autocomplete
   * allowlist phrases.
   */
  allowlistInputConfig:
    | CompletionDataInputConfig
    | undefined;
  /**
   * Output only. Name of the LRO corresponding to the latest allowlist import.
   *
   * Can use [GetOperation][google.longrunning.Operations.GetOperation] API to
   * retrieve the latest state of the Long Running Operation.
   */
  lastAllowlistImportOperation: string;
}

/**
 * Represents a link between a Merchant Center account and a branch.
 * After a link is established, products from the linked Merchant Center account
 * are streamed to the linked branch.
 */
export interface MerchantCenterLink {
  /**
   * Required. The linked [Merchant Center account
   * ID](https://developers.google.com/shopping-content/guides/accountstatuses).
   * The account must be a standalone account or a sub-account of a MCA.
   */
  merchantCenterAccountId: Long;
  /**
   * The branch ID (e.g. 0/1/2) within this catalog that products from
   * merchant_center_account_id are streamed to. When updating this field, an
   * empty value will use the currently configured default branch. However,
   * changing the default branch later on won't change the linked branch here.
   *
   * A single branch ID can only have one linked Merchant Center account ID.
   */
  branchId: string;
  /**
   * String representing the destination to import for, all if left empty.
   * List of possible values is given in [Included
   * destination](https://support.google.com/merchants/answer/7501026).
   * List of allowed string values:
   * "Shopping_ads", "Buy_on_google_listings", "Display_ads", "Local_inventory
   * _ads", "Free_listings", "Free_local_listings"
   * NOTE: The string values are case sensitive.
   */
  destinations: string[];
  /**
   * Region code of offers to accept. 2-letter Uppercase ISO 3166-1 alpha-2
   * code. List of values can be found
   * [here](https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry)
   * under the `region` tag. If left blank no region filtering will be
   * performed.
   *
   * Example value: `US`.
   */
  regionCode: string;
  /**
   * Language of the title/description and other string attributes. Use language
   * tags defined by [BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).
   * ISO 639-1.
   *
   * This specifies the language of offers in Merchant Center that will be
   * accepted. If  empty no language filtering will be performed.
   *
   * Example value: `en`.
   */
  languageCode: string;
  /**
   * Criteria for the Merchant Center feeds to be ingested via the link.
   * All offers will be ingested if the list is empty.
   * Otherwise the offers will be ingested from selected feeds.
   */
  feeds: MerchantCenterFeedFilter[];
}

/** Merchant Center Feed filter criterion. */
export interface MerchantCenterFeedFilter {
  /** Merchant Center primary feed ID. */
  primaryFeedId: Long;
  /**
   * Merchant Center primary feed name. The name is used for the display
   * purposes only.
   */
  primaryFeedName: string;
}

/**
 * Configures Merchant Center linking.
 * Links contained in the config will be used to sync data from a Merchant
 * Center account to a Cloud Retail branch.
 */
export interface MerchantCenterLinkingConfig {
  /** Links between Merchant Center accounts and branches. */
  links: MerchantCenterLink[];
}

/** The catalog configuration. */
export interface Catalog {
  /** Required. Immutable. The fully qualified resource name of the catalog. */
  name: string;
  /**
   * Required. Immutable. The catalog display name.
   *
   * This field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   */
  displayName: string;
  /** Required. The product level configuration. */
  productLevelConfig:
    | ProductLevelConfig
    | undefined;
  /**
   * The Merchant Center linking configuration.
   * After a link is added, the data stream from Merchant Center to Cloud Retail
   * will be enabled automatically. The requester must have access to the
   * Merchant Center account in order to make changes to this field.
   */
  merchantCenterLinkingConfig: MerchantCenterLinkingConfig | undefined;
}

function createBaseProductLevelConfig(): ProductLevelConfig {
  return { ingestionProductType: "", merchantCenterProductIdField: "" };
}

export const ProductLevelConfig: MessageFns<ProductLevelConfig> = {
  encode(message: ProductLevelConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ingestionProductType !== "") {
      writer.uint32(10).string(message.ingestionProductType);
    }
    if (message.merchantCenterProductIdField !== "") {
      writer.uint32(18).string(message.merchantCenterProductIdField);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProductLevelConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProductLevelConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ingestionProductType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.merchantCenterProductIdField = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProductLevelConfig {
    return {
      ingestionProductType: isSet(object.ingestionProductType) ? globalThis.String(object.ingestionProductType) : "",
      merchantCenterProductIdField: isSet(object.merchantCenterProductIdField)
        ? globalThis.String(object.merchantCenterProductIdField)
        : "",
    };
  },

  toJSON(message: ProductLevelConfig): unknown {
    const obj: any = {};
    if (message.ingestionProductType !== "") {
      obj.ingestionProductType = message.ingestionProductType;
    }
    if (message.merchantCenterProductIdField !== "") {
      obj.merchantCenterProductIdField = message.merchantCenterProductIdField;
    }
    return obj;
  },

  create(base?: DeepPartial<ProductLevelConfig>): ProductLevelConfig {
    return ProductLevelConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ProductLevelConfig>): ProductLevelConfig {
    const message = createBaseProductLevelConfig();
    message.ingestionProductType = object.ingestionProductType ?? "";
    message.merchantCenterProductIdField = object.merchantCenterProductIdField ?? "";
    return message;
  },
};

function createBaseCatalogAttribute(): CatalogAttribute {
  return {
    key: "",
    inUse: false,
    type: 0,
    indexableOption: 0,
    dynamicFacetableOption: 0,
    searchableOption: 0,
    recommendationsFilteringOption: 0,
    exactSearchableOption: 0,
    retrievableOption: 0,
    facetConfig: undefined,
  };
}

export const CatalogAttribute: MessageFns<CatalogAttribute> = {
  encode(message: CatalogAttribute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.inUse !== false) {
      writer.uint32(72).bool(message.inUse);
    }
    if (message.type !== 0) {
      writer.uint32(80).int32(message.type);
    }
    if (message.indexableOption !== 0) {
      writer.uint32(40).int32(message.indexableOption);
    }
    if (message.dynamicFacetableOption !== 0) {
      writer.uint32(48).int32(message.dynamicFacetableOption);
    }
    if (message.searchableOption !== 0) {
      writer.uint32(56).int32(message.searchableOption);
    }
    if (message.recommendationsFilteringOption !== 0) {
      writer.uint32(64).int32(message.recommendationsFilteringOption);
    }
    if (message.exactSearchableOption !== 0) {
      writer.uint32(88).int32(message.exactSearchableOption);
    }
    if (message.retrievableOption !== 0) {
      writer.uint32(96).int32(message.retrievableOption);
    }
    if (message.facetConfig !== undefined) {
      CatalogAttribute_FacetConfig.encode(message.facetConfig, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CatalogAttribute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCatalogAttribute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.inUse = reader.bool();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.indexableOption = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.dynamicFacetableOption = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.searchableOption = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.recommendationsFilteringOption = reader.int32() as any;
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.exactSearchableOption = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.retrievableOption = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.facetConfig = CatalogAttribute_FacetConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CatalogAttribute {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      inUse: isSet(object.inUse) ? globalThis.Boolean(object.inUse) : false,
      type: isSet(object.type) ? catalogAttribute_AttributeTypeFromJSON(object.type) : 0,
      indexableOption: isSet(object.indexableOption)
        ? catalogAttribute_IndexableOptionFromJSON(object.indexableOption)
        : 0,
      dynamicFacetableOption: isSet(object.dynamicFacetableOption)
        ? catalogAttribute_DynamicFacetableOptionFromJSON(object.dynamicFacetableOption)
        : 0,
      searchableOption: isSet(object.searchableOption)
        ? catalogAttribute_SearchableOptionFromJSON(object.searchableOption)
        : 0,
      recommendationsFilteringOption: isSet(object.recommendationsFilteringOption)
        ? recommendationsFilteringOptionFromJSON(object.recommendationsFilteringOption)
        : 0,
      exactSearchableOption: isSet(object.exactSearchableOption)
        ? catalogAttribute_ExactSearchableOptionFromJSON(object.exactSearchableOption)
        : 0,
      retrievableOption: isSet(object.retrievableOption)
        ? catalogAttribute_RetrievableOptionFromJSON(object.retrievableOption)
        : 0,
      facetConfig: isSet(object.facetConfig) ? CatalogAttribute_FacetConfig.fromJSON(object.facetConfig) : undefined,
    };
  },

  toJSON(message: CatalogAttribute): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.inUse !== false) {
      obj.inUse = message.inUse;
    }
    if (message.type !== 0) {
      obj.type = catalogAttribute_AttributeTypeToJSON(message.type);
    }
    if (message.indexableOption !== 0) {
      obj.indexableOption = catalogAttribute_IndexableOptionToJSON(message.indexableOption);
    }
    if (message.dynamicFacetableOption !== 0) {
      obj.dynamicFacetableOption = catalogAttribute_DynamicFacetableOptionToJSON(message.dynamicFacetableOption);
    }
    if (message.searchableOption !== 0) {
      obj.searchableOption = catalogAttribute_SearchableOptionToJSON(message.searchableOption);
    }
    if (message.recommendationsFilteringOption !== 0) {
      obj.recommendationsFilteringOption = recommendationsFilteringOptionToJSON(message.recommendationsFilteringOption);
    }
    if (message.exactSearchableOption !== 0) {
      obj.exactSearchableOption = catalogAttribute_ExactSearchableOptionToJSON(message.exactSearchableOption);
    }
    if (message.retrievableOption !== 0) {
      obj.retrievableOption = catalogAttribute_RetrievableOptionToJSON(message.retrievableOption);
    }
    if (message.facetConfig !== undefined) {
      obj.facetConfig = CatalogAttribute_FacetConfig.toJSON(message.facetConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<CatalogAttribute>): CatalogAttribute {
    return CatalogAttribute.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CatalogAttribute>): CatalogAttribute {
    const message = createBaseCatalogAttribute();
    message.key = object.key ?? "";
    message.inUse = object.inUse ?? false;
    message.type = object.type ?? 0;
    message.indexableOption = object.indexableOption ?? 0;
    message.dynamicFacetableOption = object.dynamicFacetableOption ?? 0;
    message.searchableOption = object.searchableOption ?? 0;
    message.recommendationsFilteringOption = object.recommendationsFilteringOption ?? 0;
    message.exactSearchableOption = object.exactSearchableOption ?? 0;
    message.retrievableOption = object.retrievableOption ?? 0;
    message.facetConfig = (object.facetConfig !== undefined && object.facetConfig !== null)
      ? CatalogAttribute_FacetConfig.fromPartial(object.facetConfig)
      : undefined;
    return message;
  },
};

function createBaseCatalogAttribute_FacetConfig(): CatalogAttribute_FacetConfig {
  return {
    facetIntervals: [],
    ignoredFacetValues: [],
    mergedFacetValues: [],
    mergedFacet: undefined,
    rerankConfig: undefined,
  };
}

export const CatalogAttribute_FacetConfig: MessageFns<CatalogAttribute_FacetConfig> = {
  encode(message: CatalogAttribute_FacetConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.facetIntervals) {
      Interval.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.ignoredFacetValues) {
      CatalogAttribute_FacetConfig_IgnoredFacetValues.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.mergedFacetValues) {
      CatalogAttribute_FacetConfig_MergedFacetValue.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.mergedFacet !== undefined) {
      CatalogAttribute_FacetConfig_MergedFacet.encode(message.mergedFacet, writer.uint32(34).fork()).join();
    }
    if (message.rerankConfig !== undefined) {
      CatalogAttribute_FacetConfig_RerankConfig.encode(message.rerankConfig, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CatalogAttribute_FacetConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCatalogAttribute_FacetConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.facetIntervals.push(Interval.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ignoredFacetValues.push(
            CatalogAttribute_FacetConfig_IgnoredFacetValues.decode(reader, reader.uint32()),
          );
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mergedFacetValues.push(CatalogAttribute_FacetConfig_MergedFacetValue.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mergedFacet = CatalogAttribute_FacetConfig_MergedFacet.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rerankConfig = CatalogAttribute_FacetConfig_RerankConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CatalogAttribute_FacetConfig {
    return {
      facetIntervals: globalThis.Array.isArray(object?.facetIntervals)
        ? object.facetIntervals.map((e: any) => Interval.fromJSON(e))
        : [],
      ignoredFacetValues: globalThis.Array.isArray(object?.ignoredFacetValues)
        ? object.ignoredFacetValues.map((e: any) => CatalogAttribute_FacetConfig_IgnoredFacetValues.fromJSON(e))
        : [],
      mergedFacetValues: globalThis.Array.isArray(object?.mergedFacetValues)
        ? object.mergedFacetValues.map((e: any) => CatalogAttribute_FacetConfig_MergedFacetValue.fromJSON(e))
        : [],
      mergedFacet: isSet(object.mergedFacet)
        ? CatalogAttribute_FacetConfig_MergedFacet.fromJSON(object.mergedFacet)
        : undefined,
      rerankConfig: isSet(object.rerankConfig)
        ? CatalogAttribute_FacetConfig_RerankConfig.fromJSON(object.rerankConfig)
        : undefined,
    };
  },

  toJSON(message: CatalogAttribute_FacetConfig): unknown {
    const obj: any = {};
    if (message.facetIntervals?.length) {
      obj.facetIntervals = message.facetIntervals.map((e) => Interval.toJSON(e));
    }
    if (message.ignoredFacetValues?.length) {
      obj.ignoredFacetValues = message.ignoredFacetValues.map((e) =>
        CatalogAttribute_FacetConfig_IgnoredFacetValues.toJSON(e)
      );
    }
    if (message.mergedFacetValues?.length) {
      obj.mergedFacetValues = message.mergedFacetValues.map((e) =>
        CatalogAttribute_FacetConfig_MergedFacetValue.toJSON(e)
      );
    }
    if (message.mergedFacet !== undefined) {
      obj.mergedFacet = CatalogAttribute_FacetConfig_MergedFacet.toJSON(message.mergedFacet);
    }
    if (message.rerankConfig !== undefined) {
      obj.rerankConfig = CatalogAttribute_FacetConfig_RerankConfig.toJSON(message.rerankConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<CatalogAttribute_FacetConfig>): CatalogAttribute_FacetConfig {
    return CatalogAttribute_FacetConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CatalogAttribute_FacetConfig>): CatalogAttribute_FacetConfig {
    const message = createBaseCatalogAttribute_FacetConfig();
    message.facetIntervals = object.facetIntervals?.map((e) => Interval.fromPartial(e)) || [];
    message.ignoredFacetValues =
      object.ignoredFacetValues?.map((e) => CatalogAttribute_FacetConfig_IgnoredFacetValues.fromPartial(e)) || [];
    message.mergedFacetValues =
      object.mergedFacetValues?.map((e) => CatalogAttribute_FacetConfig_MergedFacetValue.fromPartial(e)) || [];
    message.mergedFacet = (object.mergedFacet !== undefined && object.mergedFacet !== null)
      ? CatalogAttribute_FacetConfig_MergedFacet.fromPartial(object.mergedFacet)
      : undefined;
    message.rerankConfig = (object.rerankConfig !== undefined && object.rerankConfig !== null)
      ? CatalogAttribute_FacetConfig_RerankConfig.fromPartial(object.rerankConfig)
      : undefined;
    return message;
  },
};

function createBaseCatalogAttribute_FacetConfig_IgnoredFacetValues(): CatalogAttribute_FacetConfig_IgnoredFacetValues {
  return { values: [], startTime: undefined, endTime: undefined };
}

export const CatalogAttribute_FacetConfig_IgnoredFacetValues: MessageFns<
  CatalogAttribute_FacetConfig_IgnoredFacetValues
> = {
  encode(
    message: CatalogAttribute_FacetConfig_IgnoredFacetValues,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(18).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CatalogAttribute_FacetConfig_IgnoredFacetValues {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCatalogAttribute_FacetConfig_IgnoredFacetValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CatalogAttribute_FacetConfig_IgnoredFacetValues {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
      startTime: isSet(object.startTime) ? fromJsonTimestamp(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? fromJsonTimestamp(object.endTime) : undefined,
    };
  },

  toJSON(message: CatalogAttribute_FacetConfig_IgnoredFacetValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.startTime !== undefined) {
      obj.startTime = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.endTime = message.endTime.toISOString();
    }
    return obj;
  },

  create(
    base?: DeepPartial<CatalogAttribute_FacetConfig_IgnoredFacetValues>,
  ): CatalogAttribute_FacetConfig_IgnoredFacetValues {
    return CatalogAttribute_FacetConfig_IgnoredFacetValues.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CatalogAttribute_FacetConfig_IgnoredFacetValues>,
  ): CatalogAttribute_FacetConfig_IgnoredFacetValues {
    const message = createBaseCatalogAttribute_FacetConfig_IgnoredFacetValues();
    message.values = object.values?.map((e) => e) || [];
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    return message;
  },
};

function createBaseCatalogAttribute_FacetConfig_MergedFacetValue(): CatalogAttribute_FacetConfig_MergedFacetValue {
  return { values: [], mergedValue: "" };
}

export const CatalogAttribute_FacetConfig_MergedFacetValue: MessageFns<CatalogAttribute_FacetConfig_MergedFacetValue> =
  {
    encode(
      message: CatalogAttribute_FacetConfig_MergedFacetValue,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.values) {
        writer.uint32(10).string(v!);
      }
      if (message.mergedValue !== "") {
        writer.uint32(18).string(message.mergedValue);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): CatalogAttribute_FacetConfig_MergedFacetValue {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCatalogAttribute_FacetConfig_MergedFacetValue();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.values.push(reader.string());
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.mergedValue = reader.string();
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): CatalogAttribute_FacetConfig_MergedFacetValue {
      return {
        values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
        mergedValue: isSet(object.mergedValue) ? globalThis.String(object.mergedValue) : "",
      };
    },

    toJSON(message: CatalogAttribute_FacetConfig_MergedFacetValue): unknown {
      const obj: any = {};
      if (message.values?.length) {
        obj.values = message.values;
      }
      if (message.mergedValue !== "") {
        obj.mergedValue = message.mergedValue;
      }
      return obj;
    },

    create(
      base?: DeepPartial<CatalogAttribute_FacetConfig_MergedFacetValue>,
    ): CatalogAttribute_FacetConfig_MergedFacetValue {
      return CatalogAttribute_FacetConfig_MergedFacetValue.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<CatalogAttribute_FacetConfig_MergedFacetValue>,
    ): CatalogAttribute_FacetConfig_MergedFacetValue {
      const message = createBaseCatalogAttribute_FacetConfig_MergedFacetValue();
      message.values = object.values?.map((e) => e) || [];
      message.mergedValue = object.mergedValue ?? "";
      return message;
    },
  };

function createBaseCatalogAttribute_FacetConfig_MergedFacet(): CatalogAttribute_FacetConfig_MergedFacet {
  return { mergedFacetKey: "" };
}

export const CatalogAttribute_FacetConfig_MergedFacet: MessageFns<CatalogAttribute_FacetConfig_MergedFacet> = {
  encode(message: CatalogAttribute_FacetConfig_MergedFacet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mergedFacetKey !== "") {
      writer.uint32(10).string(message.mergedFacetKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CatalogAttribute_FacetConfig_MergedFacet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCatalogAttribute_FacetConfig_MergedFacet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mergedFacetKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CatalogAttribute_FacetConfig_MergedFacet {
    return { mergedFacetKey: isSet(object.mergedFacetKey) ? globalThis.String(object.mergedFacetKey) : "" };
  },

  toJSON(message: CatalogAttribute_FacetConfig_MergedFacet): unknown {
    const obj: any = {};
    if (message.mergedFacetKey !== "") {
      obj.mergedFacetKey = message.mergedFacetKey;
    }
    return obj;
  },

  create(base?: DeepPartial<CatalogAttribute_FacetConfig_MergedFacet>): CatalogAttribute_FacetConfig_MergedFacet {
    return CatalogAttribute_FacetConfig_MergedFacet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CatalogAttribute_FacetConfig_MergedFacet>): CatalogAttribute_FacetConfig_MergedFacet {
    const message = createBaseCatalogAttribute_FacetConfig_MergedFacet();
    message.mergedFacetKey = object.mergedFacetKey ?? "";
    return message;
  },
};

function createBaseCatalogAttribute_FacetConfig_RerankConfig(): CatalogAttribute_FacetConfig_RerankConfig {
  return { rerankFacet: false, facetValues: [] };
}

export const CatalogAttribute_FacetConfig_RerankConfig: MessageFns<CatalogAttribute_FacetConfig_RerankConfig> = {
  encode(message: CatalogAttribute_FacetConfig_RerankConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rerankFacet !== false) {
      writer.uint32(8).bool(message.rerankFacet);
    }
    for (const v of message.facetValues) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CatalogAttribute_FacetConfig_RerankConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCatalogAttribute_FacetConfig_RerankConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.rerankFacet = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.facetValues.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CatalogAttribute_FacetConfig_RerankConfig {
    return {
      rerankFacet: isSet(object.rerankFacet) ? globalThis.Boolean(object.rerankFacet) : false,
      facetValues: globalThis.Array.isArray(object?.facetValues)
        ? object.facetValues.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CatalogAttribute_FacetConfig_RerankConfig): unknown {
    const obj: any = {};
    if (message.rerankFacet !== false) {
      obj.rerankFacet = message.rerankFacet;
    }
    if (message.facetValues?.length) {
      obj.facetValues = message.facetValues;
    }
    return obj;
  },

  create(base?: DeepPartial<CatalogAttribute_FacetConfig_RerankConfig>): CatalogAttribute_FacetConfig_RerankConfig {
    return CatalogAttribute_FacetConfig_RerankConfig.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CatalogAttribute_FacetConfig_RerankConfig>,
  ): CatalogAttribute_FacetConfig_RerankConfig {
    const message = createBaseCatalogAttribute_FacetConfig_RerankConfig();
    message.rerankFacet = object.rerankFacet ?? false;
    message.facetValues = object.facetValues?.map((e) => e) || [];
    return message;
  },
};

function createBaseAttributesConfig(): AttributesConfig {
  return { name: "", catalogAttributes: {}, attributeConfigLevel: 0 };
}

export const AttributesConfig: MessageFns<AttributesConfig> = {
  encode(message: AttributesConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.catalogAttributes).forEach(([key, value]) => {
      AttributesConfig_CatalogAttributesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.attributeConfigLevel !== 0) {
      writer.uint32(24).int32(message.attributeConfigLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributesConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributesConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = AttributesConfig_CatalogAttributesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.catalogAttributes[entry2.key] = entry2.value;
          }
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.attributeConfigLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributesConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      catalogAttributes: isObject(object.catalogAttributes)
        ? Object.entries(object.catalogAttributes).reduce<{ [key: string]: CatalogAttribute }>((acc, [key, value]) => {
          acc[key] = CatalogAttribute.fromJSON(value);
          return acc;
        }, {})
        : {},
      attributeConfigLevel: isSet(object.attributeConfigLevel)
        ? attributeConfigLevelFromJSON(object.attributeConfigLevel)
        : 0,
    };
  },

  toJSON(message: AttributesConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.catalogAttributes) {
      const entries = Object.entries(message.catalogAttributes);
      if (entries.length > 0) {
        obj.catalogAttributes = {};
        entries.forEach(([k, v]) => {
          obj.catalogAttributes[k] = CatalogAttribute.toJSON(v);
        });
      }
    }
    if (message.attributeConfigLevel !== 0) {
      obj.attributeConfigLevel = attributeConfigLevelToJSON(message.attributeConfigLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<AttributesConfig>): AttributesConfig {
    return AttributesConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttributesConfig>): AttributesConfig {
    const message = createBaseAttributesConfig();
    message.name = object.name ?? "";
    message.catalogAttributes = Object.entries(object.catalogAttributes ?? {}).reduce<
      { [key: string]: CatalogAttribute }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = CatalogAttribute.fromPartial(value);
      }
      return acc;
    }, {});
    message.attributeConfigLevel = object.attributeConfigLevel ?? 0;
    return message;
  },
};

function createBaseAttributesConfig_CatalogAttributesEntry(): AttributesConfig_CatalogAttributesEntry {
  return { key: "", value: undefined };
}

export const AttributesConfig_CatalogAttributesEntry: MessageFns<AttributesConfig_CatalogAttributesEntry> = {
  encode(message: AttributesConfig_CatalogAttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CatalogAttribute.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttributesConfig_CatalogAttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributesConfig_CatalogAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CatalogAttribute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttributesConfig_CatalogAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CatalogAttribute.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AttributesConfig_CatalogAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CatalogAttribute.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<AttributesConfig_CatalogAttributesEntry>): AttributesConfig_CatalogAttributesEntry {
    return AttributesConfig_CatalogAttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AttributesConfig_CatalogAttributesEntry>): AttributesConfig_CatalogAttributesEntry {
    const message = createBaseAttributesConfig_CatalogAttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CatalogAttribute.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCompletionConfig(): CompletionConfig {
  return {
    name: "",
    matchingOrder: "",
    maxSuggestions: 0,
    minPrefixLength: 0,
    autoLearning: false,
    suggestionsInputConfig: undefined,
    lastSuggestionsImportOperation: "",
    denylistInputConfig: undefined,
    lastDenylistImportOperation: "",
    allowlistInputConfig: undefined,
    lastAllowlistImportOperation: "",
  };
}

export const CompletionConfig: MessageFns<CompletionConfig> = {
  encode(message: CompletionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.matchingOrder !== "") {
      writer.uint32(18).string(message.matchingOrder);
    }
    if (message.maxSuggestions !== 0) {
      writer.uint32(24).int32(message.maxSuggestions);
    }
    if (message.minPrefixLength !== 0) {
      writer.uint32(32).int32(message.minPrefixLength);
    }
    if (message.autoLearning !== false) {
      writer.uint32(88).bool(message.autoLearning);
    }
    if (message.suggestionsInputConfig !== undefined) {
      CompletionDataInputConfig.encode(message.suggestionsInputConfig, writer.uint32(42).fork()).join();
    }
    if (message.lastSuggestionsImportOperation !== "") {
      writer.uint32(50).string(message.lastSuggestionsImportOperation);
    }
    if (message.denylistInputConfig !== undefined) {
      CompletionDataInputConfig.encode(message.denylistInputConfig, writer.uint32(58).fork()).join();
    }
    if (message.lastDenylistImportOperation !== "") {
      writer.uint32(66).string(message.lastDenylistImportOperation);
    }
    if (message.allowlistInputConfig !== undefined) {
      CompletionDataInputConfig.encode(message.allowlistInputConfig, writer.uint32(74).fork()).join();
    }
    if (message.lastAllowlistImportOperation !== "") {
      writer.uint32(82).string(message.lastAllowlistImportOperation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompletionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.matchingOrder = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxSuggestions = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.minPrefixLength = reader.int32();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.autoLearning = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.suggestionsInputConfig = CompletionDataInputConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lastSuggestionsImportOperation = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.denylistInputConfig = CompletionDataInputConfig.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.lastDenylistImportOperation = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.allowlistInputConfig = CompletionDataInputConfig.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.lastAllowlistImportOperation = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      matchingOrder: isSet(object.matchingOrder) ? globalThis.String(object.matchingOrder) : "",
      maxSuggestions: isSet(object.maxSuggestions) ? globalThis.Number(object.maxSuggestions) : 0,
      minPrefixLength: isSet(object.minPrefixLength) ? globalThis.Number(object.minPrefixLength) : 0,
      autoLearning: isSet(object.autoLearning) ? globalThis.Boolean(object.autoLearning) : false,
      suggestionsInputConfig: isSet(object.suggestionsInputConfig)
        ? CompletionDataInputConfig.fromJSON(object.suggestionsInputConfig)
        : undefined,
      lastSuggestionsImportOperation: isSet(object.lastSuggestionsImportOperation)
        ? globalThis.String(object.lastSuggestionsImportOperation)
        : "",
      denylistInputConfig: isSet(object.denylistInputConfig)
        ? CompletionDataInputConfig.fromJSON(object.denylistInputConfig)
        : undefined,
      lastDenylistImportOperation: isSet(object.lastDenylistImportOperation)
        ? globalThis.String(object.lastDenylistImportOperation)
        : "",
      allowlistInputConfig: isSet(object.allowlistInputConfig)
        ? CompletionDataInputConfig.fromJSON(object.allowlistInputConfig)
        : undefined,
      lastAllowlistImportOperation: isSet(object.lastAllowlistImportOperation)
        ? globalThis.String(object.lastAllowlistImportOperation)
        : "",
    };
  },

  toJSON(message: CompletionConfig): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.matchingOrder !== "") {
      obj.matchingOrder = message.matchingOrder;
    }
    if (message.maxSuggestions !== 0) {
      obj.maxSuggestions = Math.round(message.maxSuggestions);
    }
    if (message.minPrefixLength !== 0) {
      obj.minPrefixLength = Math.round(message.minPrefixLength);
    }
    if (message.autoLearning !== false) {
      obj.autoLearning = message.autoLearning;
    }
    if (message.suggestionsInputConfig !== undefined) {
      obj.suggestionsInputConfig = CompletionDataInputConfig.toJSON(message.suggestionsInputConfig);
    }
    if (message.lastSuggestionsImportOperation !== "") {
      obj.lastSuggestionsImportOperation = message.lastSuggestionsImportOperation;
    }
    if (message.denylistInputConfig !== undefined) {
      obj.denylistInputConfig = CompletionDataInputConfig.toJSON(message.denylistInputConfig);
    }
    if (message.lastDenylistImportOperation !== "") {
      obj.lastDenylistImportOperation = message.lastDenylistImportOperation;
    }
    if (message.allowlistInputConfig !== undefined) {
      obj.allowlistInputConfig = CompletionDataInputConfig.toJSON(message.allowlistInputConfig);
    }
    if (message.lastAllowlistImportOperation !== "") {
      obj.lastAllowlistImportOperation = message.lastAllowlistImportOperation;
    }
    return obj;
  },

  create(base?: DeepPartial<CompletionConfig>): CompletionConfig {
    return CompletionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CompletionConfig>): CompletionConfig {
    const message = createBaseCompletionConfig();
    message.name = object.name ?? "";
    message.matchingOrder = object.matchingOrder ?? "";
    message.maxSuggestions = object.maxSuggestions ?? 0;
    message.minPrefixLength = object.minPrefixLength ?? 0;
    message.autoLearning = object.autoLearning ?? false;
    message.suggestionsInputConfig =
      (object.suggestionsInputConfig !== undefined && object.suggestionsInputConfig !== null)
        ? CompletionDataInputConfig.fromPartial(object.suggestionsInputConfig)
        : undefined;
    message.lastSuggestionsImportOperation = object.lastSuggestionsImportOperation ?? "";
    message.denylistInputConfig = (object.denylistInputConfig !== undefined && object.denylistInputConfig !== null)
      ? CompletionDataInputConfig.fromPartial(object.denylistInputConfig)
      : undefined;
    message.lastDenylistImportOperation = object.lastDenylistImportOperation ?? "";
    message.allowlistInputConfig = (object.allowlistInputConfig !== undefined && object.allowlistInputConfig !== null)
      ? CompletionDataInputConfig.fromPartial(object.allowlistInputConfig)
      : undefined;
    message.lastAllowlistImportOperation = object.lastAllowlistImportOperation ?? "";
    return message;
  },
};

function createBaseMerchantCenterLink(): MerchantCenterLink {
  return {
    merchantCenterAccountId: Long.ZERO,
    branchId: "",
    destinations: [],
    regionCode: "",
    languageCode: "",
    feeds: [],
  };
}

export const MerchantCenterLink: MessageFns<MerchantCenterLink> = {
  encode(message: MerchantCenterLink, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.merchantCenterAccountId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.merchantCenterAccountId.toString());
    }
    if (message.branchId !== "") {
      writer.uint32(18).string(message.branchId);
    }
    for (const v of message.destinations) {
      writer.uint32(26).string(v!);
    }
    if (message.regionCode !== "") {
      writer.uint32(34).string(message.regionCode);
    }
    if (message.languageCode !== "") {
      writer.uint32(42).string(message.languageCode);
    }
    for (const v of message.feeds) {
      MerchantCenterFeedFilter.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MerchantCenterLink {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMerchantCenterLink();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.merchantCenterAccountId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branchId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destinations.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.feeds.push(MerchantCenterFeedFilter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MerchantCenterLink {
    return {
      merchantCenterAccountId: isSet(object.merchantCenterAccountId)
        ? Long.fromValue(object.merchantCenterAccountId)
        : Long.ZERO,
      branchId: isSet(object.branchId) ? globalThis.String(object.branchId) : "",
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => globalThis.String(e))
        : [],
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      feeds: globalThis.Array.isArray(object?.feeds)
        ? object.feeds.map((e: any) => MerchantCenterFeedFilter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MerchantCenterLink): unknown {
    const obj: any = {};
    if (!message.merchantCenterAccountId.equals(Long.ZERO)) {
      obj.merchantCenterAccountId = (message.merchantCenterAccountId || Long.ZERO).toString();
    }
    if (message.branchId !== "") {
      obj.branchId = message.branchId;
    }
    if (message.destinations?.length) {
      obj.destinations = message.destinations;
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.feeds?.length) {
      obj.feeds = message.feeds.map((e) => MerchantCenterFeedFilter.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MerchantCenterLink>): MerchantCenterLink {
    return MerchantCenterLink.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MerchantCenterLink>): MerchantCenterLink {
    const message = createBaseMerchantCenterLink();
    message.merchantCenterAccountId =
      (object.merchantCenterAccountId !== undefined && object.merchantCenterAccountId !== null)
        ? Long.fromValue(object.merchantCenterAccountId)
        : Long.ZERO;
    message.branchId = object.branchId ?? "";
    message.destinations = object.destinations?.map((e) => e) || [];
    message.regionCode = object.regionCode ?? "";
    message.languageCode = object.languageCode ?? "";
    message.feeds = object.feeds?.map((e) => MerchantCenterFeedFilter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMerchantCenterFeedFilter(): MerchantCenterFeedFilter {
  return { primaryFeedId: Long.ZERO, primaryFeedName: "" };
}

export const MerchantCenterFeedFilter: MessageFns<MerchantCenterFeedFilter> = {
  encode(message: MerchantCenterFeedFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.primaryFeedId.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.primaryFeedId.toString());
    }
    if (message.primaryFeedName !== "") {
      writer.uint32(18).string(message.primaryFeedName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MerchantCenterFeedFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMerchantCenterFeedFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.primaryFeedId = Long.fromString(reader.int64().toString());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.primaryFeedName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MerchantCenterFeedFilter {
    return {
      primaryFeedId: isSet(object.primaryFeedId) ? Long.fromValue(object.primaryFeedId) : Long.ZERO,
      primaryFeedName: isSet(object.primaryFeedName) ? globalThis.String(object.primaryFeedName) : "",
    };
  },

  toJSON(message: MerchantCenterFeedFilter): unknown {
    const obj: any = {};
    if (!message.primaryFeedId.equals(Long.ZERO)) {
      obj.primaryFeedId = (message.primaryFeedId || Long.ZERO).toString();
    }
    if (message.primaryFeedName !== "") {
      obj.primaryFeedName = message.primaryFeedName;
    }
    return obj;
  },

  create(base?: DeepPartial<MerchantCenterFeedFilter>): MerchantCenterFeedFilter {
    return MerchantCenterFeedFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MerchantCenterFeedFilter>): MerchantCenterFeedFilter {
    const message = createBaseMerchantCenterFeedFilter();
    message.primaryFeedId = (object.primaryFeedId !== undefined && object.primaryFeedId !== null)
      ? Long.fromValue(object.primaryFeedId)
      : Long.ZERO;
    message.primaryFeedName = object.primaryFeedName ?? "";
    return message;
  },
};

function createBaseMerchantCenterLinkingConfig(): MerchantCenterLinkingConfig {
  return { links: [] };
}

export const MerchantCenterLinkingConfig: MessageFns<MerchantCenterLinkingConfig> = {
  encode(message: MerchantCenterLinkingConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.links) {
      MerchantCenterLink.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MerchantCenterLinkingConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMerchantCenterLinkingConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.links.push(MerchantCenterLink.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MerchantCenterLinkingConfig {
    return {
      links: globalThis.Array.isArray(object?.links)
        ? object.links.map((e: any) => MerchantCenterLink.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MerchantCenterLinkingConfig): unknown {
    const obj: any = {};
    if (message.links?.length) {
      obj.links = message.links.map((e) => MerchantCenterLink.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MerchantCenterLinkingConfig>): MerchantCenterLinkingConfig {
    return MerchantCenterLinkingConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MerchantCenterLinkingConfig>): MerchantCenterLinkingConfig {
    const message = createBaseMerchantCenterLinkingConfig();
    message.links = object.links?.map((e) => MerchantCenterLink.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCatalog(): Catalog {
  return { name: "", displayName: "", productLevelConfig: undefined, merchantCenterLinkingConfig: undefined };
}

export const Catalog: MessageFns<Catalog> = {
  encode(message: Catalog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.productLevelConfig !== undefined) {
      ProductLevelConfig.encode(message.productLevelConfig, writer.uint32(34).fork()).join();
    }
    if (message.merchantCenterLinkingConfig !== undefined) {
      MerchantCenterLinkingConfig.encode(message.merchantCenterLinkingConfig, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Catalog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCatalog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.productLevelConfig = ProductLevelConfig.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.merchantCenterLinkingConfig = MerchantCenterLinkingConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Catalog {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      productLevelConfig: isSet(object.productLevelConfig)
        ? ProductLevelConfig.fromJSON(object.productLevelConfig)
        : undefined,
      merchantCenterLinkingConfig: isSet(object.merchantCenterLinkingConfig)
        ? MerchantCenterLinkingConfig.fromJSON(object.merchantCenterLinkingConfig)
        : undefined,
    };
  },

  toJSON(message: Catalog): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.productLevelConfig !== undefined) {
      obj.productLevelConfig = ProductLevelConfig.toJSON(message.productLevelConfig);
    }
    if (message.merchantCenterLinkingConfig !== undefined) {
      obj.merchantCenterLinkingConfig = MerchantCenterLinkingConfig.toJSON(message.merchantCenterLinkingConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<Catalog>): Catalog {
    return Catalog.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Catalog>): Catalog {
    const message = createBaseCatalog();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.productLevelConfig = (object.productLevelConfig !== undefined && object.productLevelConfig !== null)
      ? ProductLevelConfig.fromPartial(object.productLevelConfig)
      : undefined;
    message.merchantCenterLinkingConfig =
      (object.merchantCenterLinkingConfig !== undefined && object.merchantCenterLinkingConfig !== null)
        ? MerchantCenterLinkingConfig.fromPartial(object.merchantCenterLinkingConfig)
        : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
