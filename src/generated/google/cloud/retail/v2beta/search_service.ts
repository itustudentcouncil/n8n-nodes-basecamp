// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/retail/v2beta/search_service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Value } from "../../../protobuf/struct.js";
import { Interval, UserInfo } from "./common.js";
import { Product } from "./product.js";

export const protobufPackage = "google.cloud.retail.v2beta";

/**
 * Request message for
 * [SearchService.Search][google.cloud.retail.v2beta.SearchService.Search]
 * method.
 */
export interface SearchRequest {
  /**
   * Required. The resource name of the Retail Search serving config, such as
   * `projects/* /locations/global/catalogs/default_catalog/servingConfigs/default_serving_config`
   * or the name of the legacy placement resource, such as
   * `projects/* /locations/global/catalogs/default_catalog/placements/default_search`.
   * This field is used to identify the serving config name and the set
   * of models that are used to make the search.
   */
  placement: string;
  /**
   * The branch resource name, such as
   * `projects/* /locations/global/catalogs/default_catalog/branches/0`.
   *
   * Use "default_branch" as the branch ID or leave this field empty, to search
   * products under the default branch.
   */
  branch: string;
  /**
   * Raw search query.
   *
   * If this field is empty, the request is considered a category browsing
   * request and returned results are based on
   * [filter][google.cloud.retail.v2beta.SearchRequest.filter] and
   * [page_categories][google.cloud.retail.v2beta.SearchRequest.page_categories].
   */
  query: string;
  /**
   * Required. A unique identifier for tracking visitors. For example, this
   * could be implemented with an HTTP cookie, which should be able to uniquely
   * identify a visitor on a single device. This unique identifier should not
   * change if the visitor logs in or out of the website.
   *
   * This should be the same identifier as
   * [UserEvent.visitor_id][google.cloud.retail.v2beta.UserEvent.visitor_id].
   *
   * The field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   */
  visitorId: string;
  /** User information. */
  userInfo:
    | UserInfo
    | undefined;
  /**
   * Maximum number of [Product][google.cloud.retail.v2beta.Product]s to return.
   * If unspecified, defaults to a reasonable value. The maximum allowed value
   * is 120. Values above 120 will be coerced to 120.
   *
   * If this field is negative, an INVALID_ARGUMENT is returned.
   */
  pageSize: number;
  /**
   * A page token
   * [SearchResponse.next_page_token][google.cloud.retail.v2beta.SearchResponse.next_page_token],
   * received from a previous
   * [SearchService.Search][google.cloud.retail.v2beta.SearchService.Search]
   * call. Provide this to retrieve the subsequent page.
   *
   * When paginating, all other parameters provided to
   * [SearchService.Search][google.cloud.retail.v2beta.SearchService.Search]
   * must match the call that provided the page token. Otherwise, an
   * INVALID_ARGUMENT error is returned.
   */
  pageToken: string;
  /**
   * A 0-indexed integer that specifies the current offset (that is, starting
   * result location, amongst the [Product][google.cloud.retail.v2beta.Product]s
   * deemed by the API as relevant) in search results. This field is only
   * considered if
   * [page_token][google.cloud.retail.v2beta.SearchRequest.page_token] is unset.
   *
   * If this field is negative, an INVALID_ARGUMENT is returned.
   */
  offset: number;
  /**
   * The filter syntax consists of an expression language for constructing a
   * predicate from one or more fields of the products being filtered. Filter
   * expression is case-sensitive. For more information, see
   * [Filter](https://cloud.google.com/retail/docs/filter-and-order#filter).
   *
   * If this field is unrecognizable, an INVALID_ARGUMENT is returned.
   */
  filter: string;
  /**
   * The default filter that is applied when a user performs a search without
   * checking any filters on the search page.
   *
   * The filter applied to every search request when quality improvement such as
   * query expansion is needed. In the case a query does not have a sufficient
   * amount of results this filter will be used to determine whether or not to
   * enable the query expansion flow. The original filter will still be used for
   * the query expanded search.
   * This field is strongly recommended to achieve high search quality.
   *
   * For more information about filter syntax, see
   * [SearchRequest.filter][google.cloud.retail.v2beta.SearchRequest.filter].
   */
  canonicalFilter: string;
  /**
   * The order in which products are returned. Products can be ordered by
   * a field in an [Product][google.cloud.retail.v2beta.Product] object. Leave
   * it unset if ordered by relevance. OrderBy expression is case-sensitive. For
   * more information, see
   * [Order](https://cloud.google.com/retail/docs/filter-and-order#order).
   *
   * If this field is unrecognizable, an INVALID_ARGUMENT is returned.
   */
  orderBy: string;
  /**
   * Facet specifications for faceted search. If empty, no facets are returned.
   *
   * A maximum of 200 values are allowed. Otherwise, an INVALID_ARGUMENT error
   * is returned.
   */
  facetSpecs: SearchRequest_FacetSpec[];
  /**
   * Deprecated. Refer to https://cloud.google.com/retail/docs/configs#dynamic
   * to enable dynamic facets. Do not set this field.
   *
   * The specification for dynamically generated facets. Notice that only
   * textual facets can be dynamically generated.
   *
   * @deprecated
   */
  dynamicFacetSpec:
    | SearchRequest_DynamicFacetSpec
    | undefined;
  /**
   * Boost specification to boost certain products. For more information, see
   * [Boost results](https://cloud.google.com/retail/docs/boosting).
   *
   * Notice that if both
   * [ServingConfig.boost_control_ids][google.cloud.retail.v2beta.ServingConfig.boost_control_ids]
   * and
   * [SearchRequest.boost_spec][google.cloud.retail.v2beta.SearchRequest.boost_spec]
   * are set, the boost conditions from both places are evaluated. If a search
   * request matches multiple boost conditions, the final boost score is equal
   * to the sum of the boost scores from all matched boost conditions.
   */
  boostSpec:
    | SearchRequest_BoostSpec
    | undefined;
  /**
   * The query expansion specification that specifies the conditions under which
   * query expansion occurs. For more information, see [Query
   * expansion](https://cloud.google.com/retail/docs/result-size#query_expansion).
   */
  queryExpansionSpec:
    | SearchRequest_QueryExpansionSpec
    | undefined;
  /**
   * The keys to fetch and rollup the matching
   * [variant][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product]s attributes,
   * [FulfillmentInfo][google.cloud.retail.v2beta.FulfillmentInfo] or
   * [LocalInventory][google.cloud.retail.v2beta.LocalInventory]s attributes.
   * The attributes from all the matching
   * [variant][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product]s or
   * [LocalInventory][google.cloud.retail.v2beta.LocalInventory]s are merged and
   * de-duplicated. Notice that rollup attributes will lead to extra query
   * latency. Maximum number of keys is 30.
   *
   * For [FulfillmentInfo][google.cloud.retail.v2beta.FulfillmentInfo], a
   * fulfillment type and a fulfillment ID must be provided in the format of
   * "fulfillmentType.fulfillmentId". E.g., in "pickupInStore.store123",
   * "pickupInStore" is fulfillment type and "store123" is the store ID.
   *
   * Supported keys are:
   *
   * * colorFamilies
   * * price
   * * originalPrice
   * * discount
   * * variantId
   * * inventory(place_id,price)
   * * inventory(place_id,original_price)
   * * inventory(place_id,attributes.key), where key is any key in the
   *   [Product.local_inventories.attributes][google.cloud.retail.v2beta.LocalInventory.attributes]
   *   map.
   * * attributes.key, where key is any key in the
   *   [Product.attributes][google.cloud.retail.v2beta.Product.attributes] map.
   * * pickupInStore.id, where id is any
   * [FulfillmentInfo.place_ids][google.cloud.retail.v2beta.FulfillmentInfo.place_ids]
   * for [FulfillmentInfo.type][google.cloud.retail.v2beta.FulfillmentInfo.type]
   *   "pickup-in-store".
   * * shipToStore.id, where id is any
   * [FulfillmentInfo.place_ids][google.cloud.retail.v2beta.FulfillmentInfo.place_ids]
   * for [FulfillmentInfo.type][google.cloud.retail.v2beta.FulfillmentInfo.type]
   *   "ship-to-store".
   * * sameDayDelivery.id, where id is any
   * [FulfillmentInfo.place_ids][google.cloud.retail.v2beta.FulfillmentInfo.place_ids]
   * for [FulfillmentInfo.type][google.cloud.retail.v2beta.FulfillmentInfo.type]
   *   "same-day-delivery".
   * * nextDayDelivery.id, where id is any
   * [FulfillmentInfo.place_ids][google.cloud.retail.v2beta.FulfillmentInfo.place_ids]
   * for [FulfillmentInfo.type][google.cloud.retail.v2beta.FulfillmentInfo.type]
   *   "next-day-delivery".
   * * customFulfillment1.id, where id is any
   * [FulfillmentInfo.place_ids][google.cloud.retail.v2beta.FulfillmentInfo.place_ids]
   * for [FulfillmentInfo.type][google.cloud.retail.v2beta.FulfillmentInfo.type]
   *   "custom-type-1".
   * * customFulfillment2.id, where id is any
   * [FulfillmentInfo.place_ids][google.cloud.retail.v2beta.FulfillmentInfo.place_ids]
   * for [FulfillmentInfo.type][google.cloud.retail.v2beta.FulfillmentInfo.type]
   *   "custom-type-2".
   * * customFulfillment3.id, where id is any
   * [FulfillmentInfo.place_ids][google.cloud.retail.v2beta.FulfillmentInfo.place_ids]
   * for [FulfillmentInfo.type][google.cloud.retail.v2beta.FulfillmentInfo.type]
   *   "custom-type-3".
   * * customFulfillment4.id, where id is any
   * [FulfillmentInfo.place_ids][google.cloud.retail.v2beta.FulfillmentInfo.place_ids]
   * for [FulfillmentInfo.type][google.cloud.retail.v2beta.FulfillmentInfo.type]
   *   "custom-type-4".
   * * customFulfillment5.id, where id is any
   * [FulfillmentInfo.place_ids][google.cloud.retail.v2beta.FulfillmentInfo.place_ids]
   * for [FulfillmentInfo.type][google.cloud.retail.v2beta.FulfillmentInfo.type]
   *   "custom-type-5".
   *
   * If this field is set to an invalid value other than these, an
   * INVALID_ARGUMENT error is returned.
   */
  variantRollupKeys: string[];
  /**
   * The categories associated with a category page. Must be set for category
   * navigation queries to achieve good search quality. The format should be
   * the same as
   * [UserEvent.page_categories][google.cloud.retail.v2beta.UserEvent.page_categories];
   *
   * To represent full path of category, use '>' sign to separate different
   * hierarchies. If '>' is part of the category name, replace it with
   * other character(s).
   *
   * Category pages include special pages such as sales or promotions. For
   * instance, a special sale page may have the category hierarchy:
   * "pageCategories" : ["Sales > 2017 Black Friday Deals"].
   */
  pageCategories: string[];
  /**
   * The search mode of the search request. If not specified, a single search
   * request triggers both product search and faceted search.
   */
  searchMode: SearchRequest_SearchMode;
  /**
   * The specification for personalization.
   *
   * Notice that if both
   * [ServingConfig.personalization_spec][google.cloud.retail.v2beta.ServingConfig.personalization_spec]
   * and
   * [SearchRequest.personalization_spec][google.cloud.retail.v2beta.SearchRequest.personalization_spec]
   * are set.
   * [SearchRequest.personalization_spec][google.cloud.retail.v2beta.SearchRequest.personalization_spec]
   * will override
   * [ServingConfig.personalization_spec][google.cloud.retail.v2beta.ServingConfig.personalization_spec].
   */
  personalizationSpec:
    | SearchRequest_PersonalizationSpec
    | undefined;
  /**
   * The labels applied to a resource must meet the following requirements:
   *
   * * Each resource can have multiple labels, up to a maximum of 64.
   * * Each label must be a key-value pair.
   * * Keys have a minimum length of 1 character and a maximum length of 63
   *   characters and cannot be empty. Values can be empty and have a maximum
   *   length of 63 characters.
   * * Keys and values can contain only lowercase letters, numeric characters,
   *   underscores, and dashes. All characters must use UTF-8 encoding, and
   *   international characters are allowed.
   * * The key portion of a label must be unique. However, you can use the same
   *   key with multiple resources.
   * * Keys must start with a lowercase letter or international character.
   *
   * For more information, see [Requirements for
   * labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
   * in the Resource Manager documentation.
   */
  labels: { [key: string]: string };
  /**
   * The spell correction specification that specifies the mode under
   * which spell correction will take effect.
   */
  spellCorrectionSpec?:
    | SearchRequest_SpellCorrectionSpec
    | undefined;
  /**
   * The entity for customers that may run multiple different entities, domains,
   * sites or regions, for example, `Google US`, `Google Ads`, `Waymo`,
   * `google.com`, `youtube.com`, etc.
   * If this is set, it should be exactly matched with
   * [UserEvent.entity][google.cloud.retail.v2beta.UserEvent.entity] to get
   * search results boosted by entity.
   */
  entity: string;
}

/** The search mode of each search request. */
export enum SearchRequest_SearchMode {
  /**
   * SEARCH_MODE_UNSPECIFIED - Default value. In this case both product search and faceted search will
   * be performed. Both
   * [SearchResponse.SearchResult][google.cloud.retail.v2beta.SearchResponse.SearchResult]
   * and
   * [SearchResponse.Facet][google.cloud.retail.v2beta.SearchResponse.Facet]
   * will be returned.
   */
  SEARCH_MODE_UNSPECIFIED = 0,
  /**
   * PRODUCT_SEARCH_ONLY - Only product search will be performed. The faceted search will be
   * disabled.
   *
   * Only
   * [SearchResponse.SearchResult][google.cloud.retail.v2beta.SearchResponse.SearchResult]
   * will be returned.
   * [SearchResponse.Facet][google.cloud.retail.v2beta.SearchResponse.Facet]
   * will not be returned, even if
   * [SearchRequest.facet_specs][google.cloud.retail.v2beta.SearchRequest.facet_specs]
   * or
   * [SearchRequest.dynamic_facet_spec][google.cloud.retail.v2beta.SearchRequest.dynamic_facet_spec]
   * is set.
   */
  PRODUCT_SEARCH_ONLY = 1,
  /**
   * FACETED_SEARCH_ONLY - Only faceted search will be performed. The product search will be
   * disabled.
   *
   * When in this mode, one or both of
   * [SearchRequest.facet_specs][google.cloud.retail.v2beta.SearchRequest.facet_specs]
   * and
   * [SearchRequest.dynamic_facet_spec][google.cloud.retail.v2beta.SearchRequest.dynamic_facet_spec]
   * should be set. Otherwise, an INVALID_ARGUMENT error is returned. Only
   * [SearchResponse.Facet][google.cloud.retail.v2beta.SearchResponse.Facet]
   * will be returned.
   * [SearchResponse.SearchResult][google.cloud.retail.v2beta.SearchResponse.SearchResult]
   * will not be returned.
   */
  FACETED_SEARCH_ONLY = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_SearchModeFromJSON(object: any): SearchRequest_SearchMode {
  switch (object) {
    case 0:
    case "SEARCH_MODE_UNSPECIFIED":
      return SearchRequest_SearchMode.SEARCH_MODE_UNSPECIFIED;
    case 1:
    case "PRODUCT_SEARCH_ONLY":
      return SearchRequest_SearchMode.PRODUCT_SEARCH_ONLY;
    case 2:
    case "FACETED_SEARCH_ONLY":
      return SearchRequest_SearchMode.FACETED_SEARCH_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_SearchMode.UNRECOGNIZED;
  }
}

export function searchRequest_SearchModeToJSON(object: SearchRequest_SearchMode): string {
  switch (object) {
    case SearchRequest_SearchMode.SEARCH_MODE_UNSPECIFIED:
      return "SEARCH_MODE_UNSPECIFIED";
    case SearchRequest_SearchMode.PRODUCT_SEARCH_ONLY:
      return "PRODUCT_SEARCH_ONLY";
    case SearchRequest_SearchMode.FACETED_SEARCH_ONLY:
      return "FACETED_SEARCH_ONLY";
    case SearchRequest_SearchMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A facet specification to perform faceted search. */
export interface SearchRequest_FacetSpec {
  /** Required. The facet key specification. */
  facetKey:
    | SearchRequest_FacetSpec_FacetKey
    | undefined;
  /**
   * Maximum of facet values that should be returned for this facet. If
   * unspecified, defaults to 50. The maximum allowed value is 300. Values
   * above 300 will be coerced to 300.
   *
   * If this field is negative, an INVALID_ARGUMENT is returned.
   */
  limit: number;
  /**
   * List of keys to exclude when faceting.
   *
   * By default,
   * [FacetKey.key][google.cloud.retail.v2beta.SearchRequest.FacetSpec.FacetKey.key]
   * is not excluded from the filter unless it is listed in this field.
   *
   * Listing a facet key in this field allows its values to appear as facet
   * results, even when they are filtered out of search results. Using this
   * field does not affect what search results are returned.
   *
   * For example, suppose there are 100 products with the color facet "Red"
   * and 200 products with the color facet "Blue". A query containing the
   * filter "colorFamilies:ANY("Red")" and having "colorFamilies" as
   * [FacetKey.key][google.cloud.retail.v2beta.SearchRequest.FacetSpec.FacetKey.key]
   * would by default return only "Red" products in the search results, and
   * also return "Red" with count 100 as the only color facet. Although there
   * are also blue products available, "Blue" would not be shown as an
   * available facet value.
   *
   * If "colorFamilies" is listed in "excludedFilterKeys", then the query
   * returns the facet values "Red" with count 100 and "Blue" with count
   * 200, because the "colorFamilies" key is now excluded from the filter.
   * Because this field doesn't affect search results, the search results
   * are still correctly filtered to return only "Red" products.
   *
   * A maximum of 100 values are allowed. Otherwise, an INVALID_ARGUMENT error
   * is returned.
   */
  excludedFilterKeys: string[];
  /**
   * Enables dynamic position for this facet. If set to true, the position of
   * this facet among all facets in the response is determined by Google
   * Retail Search. It is ordered together with dynamic facets if dynamic
   * facets is enabled. If set to false, the position of this facet in the
   * response is the same as in the request, and it is ranked before
   * the facets with dynamic position enable and all dynamic facets.
   *
   * For example, you may always want to have rating facet returned in
   * the response, but it's not necessarily to always display the rating facet
   * at the top. In that case, you can set enable_dynamic_position to true so
   * that the position of rating facet in response is determined by
   * Google Retail Search.
   *
   * Another example, assuming you have the following facets in the request:
   *
   * * "rating", enable_dynamic_position = true
   *
   * * "price", enable_dynamic_position = false
   *
   * * "brands", enable_dynamic_position = false
   *
   * And also you have a dynamic facets enable, which generates a facet
   * "gender". Then, the final order of the facets in the response can be
   * ("price", "brands", "rating", "gender") or ("price", "brands", "gender",
   * "rating") depends on how Google Retail Search orders "gender" and
   * "rating" facets. However, notice that "price" and "brands" are always
   * ranked at first and second position because their enable_dynamic_position
   * values are false.
   */
  enableDynamicPosition: boolean;
}

/** Specifies how a facet is computed. */
export interface SearchRequest_FacetSpec_FacetKey {
  /**
   * Required. Supported textual and numerical facet keys in
   * [Product][google.cloud.retail.v2beta.Product] object, over which the
   * facet values are computed. Facet key is case-sensitive.
   *
   * Allowed facet keys when
   * [FacetKey.query][google.cloud.retail.v2beta.SearchRequest.FacetSpec.FacetKey.query]
   * is not specified:
   *
   * * textual_field =
   *     * "brands"
   *     * "categories"
   *     * "genders"
   *     * "ageGroups"
   *     * "availability"
   *     * "colorFamilies"
   *     * "colors"
   *     * "sizes"
   *     * "materials"
   *     * "patterns"
   *     * "conditions"
   *     * "attributes.key"
   *     * "pickupInStore"
   *     * "shipToStore"
   *     * "sameDayDelivery"
   *     * "nextDayDelivery"
   *     * "customFulfillment1"
   *     * "customFulfillment2"
   *     * "customFulfillment3"
   *     * "customFulfillment4"
   *     * "customFulfillment5"
   *     * "inventory(place_id,attributes.key)"
   *
   * * numerical_field =
   *     * "price"
   *     * "discount"
   *     * "rating"
   *     * "ratingCount"
   *     * "attributes.key"
   *     * "inventory(place_id,price)"
   *     * "inventory(place_id,original_price)"
   *     * "inventory(place_id,attributes.key)"
   */
  key: string;
  /**
   * Set only if values should be bucketized into intervals. Must be set
   * for facets with numerical values. Must not be set for facet with text
   * values. Maximum number of intervals is 40.
   *
   * For all numerical facet keys that appear in the list of products from
   * the catalog, the percentiles 0, 10, 30, 50, 70, 90, and 100 are
   * computed from their distribution weekly. If the model assigns a high
   * score to a numerical facet key and its intervals are not specified in
   * the search request, these percentiles become the bounds
   * for its intervals and are returned in the response. If the
   * facet key intervals are specified in the request, then the specified
   * intervals are returned instead.
   */
  intervals: Interval[];
  /**
   * Only get facet for the given restricted values. For example, when using
   * "pickupInStore" as key and set restricted values to
   * ["store123", "store456"], only facets for "store123" and "store456" are
   * returned. Only supported on predefined textual fields, custom textual
   * attributes and fulfillments. Maximum is 20.
   *
   * Must be set for the fulfillment facet keys:
   *
   * * pickupInStore
   *
   * * shipToStore
   *
   * * sameDayDelivery
   *
   * * nextDayDelivery
   *
   * * customFulfillment1
   *
   * * customFulfillment2
   *
   * * customFulfillment3
   *
   * * customFulfillment4
   *
   * * customFulfillment5
   */
  restrictedValues: string[];
  /**
   * Only get facet values that start with the given string prefix. For
   * example, suppose "categories" has three values "Women > Shoe",
   * "Women > Dress" and "Men > Shoe". If set "prefixes" to "Women", the
   * "categories" facet gives only "Women > Shoe" and "Women > Dress".
   * Only supported on textual fields. Maximum is 10.
   */
  prefixes: string[];
  /**
   * Only get facet values that contains the given strings. For example,
   * suppose "categories" has three values "Women > Shoe",
   * "Women > Dress" and "Men > Shoe". If set "contains" to "Shoe", the
   * "categories" facet gives only "Women > Shoe" and "Men > Shoe".
   * Only supported on textual fields. Maximum is 10.
   */
  contains: string[];
  /**
   * True to make facet keys case insensitive when getting faceting
   * values with prefixes or contains; false otherwise.
   */
  caseInsensitive: boolean;
  /**
   * The order in which
   * [SearchResponse.Facet.values][google.cloud.retail.v2beta.SearchResponse.Facet.values]
   * are returned.
   *
   * Allowed values are:
   *
   * * "count desc", which means order by
   * [SearchResponse.Facet.values.count][google.cloud.retail.v2beta.SearchResponse.Facet.FacetValue.count]
   * descending.
   *
   * * "value desc", which means order by
   * [SearchResponse.Facet.values.value][google.cloud.retail.v2beta.SearchResponse.Facet.FacetValue.value]
   * descending.
   *   Only applies to textual facets.
   *
   * If not set, textual values are sorted in [natural
   * order](https://en.wikipedia.org/wiki/Natural_sort_order); numerical
   * intervals are sorted in the order given by
   * [FacetSpec.FacetKey.intervals][google.cloud.retail.v2beta.SearchRequest.FacetSpec.FacetKey.intervals];
   * [FulfillmentInfo.place_ids][google.cloud.retail.v2beta.FulfillmentInfo.place_ids]
   * are sorted in the order given by
   * [FacetSpec.FacetKey.restricted_values][google.cloud.retail.v2beta.SearchRequest.FacetSpec.FacetKey.restricted_values].
   */
  orderBy: string;
  /**
   * The query that is used to compute facet for the given facet key.
   * When provided, it overrides the default behavior of facet
   * computation. The query syntax is the same as a filter expression. See
   * [SearchRequest.filter][google.cloud.retail.v2beta.SearchRequest.filter]
   * for detail syntax and limitations. Notice that there is no limitation
   * on
   * [FacetKey.key][google.cloud.retail.v2beta.SearchRequest.FacetSpec.FacetKey.key]
   * when query is specified.
   *
   * In the response,
   * [SearchResponse.Facet.values.value][google.cloud.retail.v2beta.SearchResponse.Facet.FacetValue.value]
   * is always "1" and
   * [SearchResponse.Facet.values.count][google.cloud.retail.v2beta.SearchResponse.Facet.FacetValue.count]
   * is the number of results that match the query.
   *
   * For example, you can set a customized facet for "shipToStore",
   * where
   * [FacetKey.key][google.cloud.retail.v2beta.SearchRequest.FacetSpec.FacetKey.key]
   * is "customizedShipToStore", and
   * [FacetKey.query][google.cloud.retail.v2beta.SearchRequest.FacetSpec.FacetKey.query]
   * is "availability: ANY(\"IN_STOCK\") AND shipToStore: ANY(\"123\")".
   * Then the facet counts the products that are both in stock and ship
   * to store "123".
   */
  query: string;
  /**
   * Returns the min and max value for each numerical facet intervals.
   * Ignored for textual facets.
   */
  returnMinMax: boolean;
}

/** The specifications of dynamically generated facets. */
export interface SearchRequest_DynamicFacetSpec {
  /**
   * Mode of the DynamicFacet feature.
   * Defaults to
   * [Mode.DISABLED][google.cloud.retail.v2beta.SearchRequest.DynamicFacetSpec.Mode.DISABLED]
   * if it's unset.
   */
  mode: SearchRequest_DynamicFacetSpec_Mode;
}

/** Enum to control DynamicFacet mode */
export enum SearchRequest_DynamicFacetSpec_Mode {
  /** MODE_UNSPECIFIED - Default value. */
  MODE_UNSPECIFIED = 0,
  /** DISABLED - Disable Dynamic Facet. */
  DISABLED = 1,
  /** ENABLED - Automatic mode built by Google Retail Search. */
  ENABLED = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_DynamicFacetSpec_ModeFromJSON(object: any): SearchRequest_DynamicFacetSpec_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return SearchRequest_DynamicFacetSpec_Mode.MODE_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return SearchRequest_DynamicFacetSpec_Mode.DISABLED;
    case 2:
    case "ENABLED":
      return SearchRequest_DynamicFacetSpec_Mode.ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_DynamicFacetSpec_Mode.UNRECOGNIZED;
  }
}

export function searchRequest_DynamicFacetSpec_ModeToJSON(object: SearchRequest_DynamicFacetSpec_Mode): string {
  switch (object) {
    case SearchRequest_DynamicFacetSpec_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case SearchRequest_DynamicFacetSpec_Mode.DISABLED:
      return "DISABLED";
    case SearchRequest_DynamicFacetSpec_Mode.ENABLED:
      return "ENABLED";
    case SearchRequest_DynamicFacetSpec_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Boost specification to boost certain items. */
export interface SearchRequest_BoostSpec {
  /**
   * Condition boost specifications. If a product matches multiple conditions
   * in the specifictions, boost scores from these specifications are all
   * applied and combined in a non-linear way. Maximum number of
   * specifications is 20.
   */
  conditionBoostSpecs: SearchRequest_BoostSpec_ConditionBoostSpec[];
  /**
   * Whether to skip boostspec validation. If this field is set to true,
   * invalid
   * [BoostSpec.condition_boost_specs][google.cloud.retail.v2beta.SearchRequest.BoostSpec.condition_boost_specs]
   * will be ignored and valid
   * [BoostSpec.condition_boost_specs][google.cloud.retail.v2beta.SearchRequest.BoostSpec.condition_boost_specs]
   * will still be applied.
   */
  skipBoostSpecValidation?: boolean | undefined;
}

/** Boost applies to products which match a condition. */
export interface SearchRequest_BoostSpec_ConditionBoostSpec {
  /**
   * An expression which specifies a boost condition. The syntax and
   * supported fields are the same as a filter expression. See
   * [SearchRequest.filter][google.cloud.retail.v2beta.SearchRequest.filter]
   * for detail syntax and limitations.
   *
   * Examples:
   *
   * * To boost products with product ID "product_1" or "product_2", and
   * color
   *   "Red" or "Blue":
   *     * (id: ANY("product_1", "product_2")) AND (colorFamilies:
   *     ANY("Red","Blue"))
   */
  condition: string;
  /**
   * Strength of the condition boost, which should be in [-1, 1]. Negative
   * boost means demotion. Default is 0.0.
   *
   * Setting to 1.0 gives the item a big promotion. However, it does not
   * necessarily mean that the boosted item will be the top result at all
   * times, nor that other items will be excluded. Results could still be
   * shown even when none of them matches the condition. And results that
   * are significantly more relevant to the search query can still trump
   * your heavily favored but irrelevant items.
   *
   * Setting to -1.0 gives the item a big demotion. However, results that
   * are deeply relevant might still be shown. The item will have an
   * upstream battle to get a fairly high ranking, but it is not blocked out
   * completely.
   *
   * Setting to 0.0 means no boost applied. The boosting condition is
   * ignored.
   */
  boost: number;
}

/**
 * Specification to determine under which conditions query expansion should
 * occur.
 */
export interface SearchRequest_QueryExpansionSpec {
  /**
   * The condition under which query expansion should occur. Default to
   * [Condition.DISABLED][google.cloud.retail.v2beta.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
   */
  condition: SearchRequest_QueryExpansionSpec_Condition;
  /**
   * Whether to pin unexpanded results. If this field is set to true,
   * unexpanded products are always at the top of the search results, followed
   * by the expanded results.
   */
  pinUnexpandedResults: boolean;
}

/** Enum describing under which condition query expansion should occur. */
export enum SearchRequest_QueryExpansionSpec_Condition {
  /**
   * CONDITION_UNSPECIFIED - Unspecified query expansion condition. In this case, server behavior
   * defaults to
   * [Condition.DISABLED][google.cloud.retail.v2beta.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
   */
  CONDITION_UNSPECIFIED = 0,
  /**
   * DISABLED - Disabled query expansion. Only the exact search query is used, even if
   * [SearchResponse.total_size][google.cloud.retail.v2beta.SearchResponse.total_size]
   * is zero.
   */
  DISABLED = 1,
  /** AUTO - Automatic query expansion built by Google Retail Search. */
  AUTO = 3,
  UNRECOGNIZED = -1,
}

export function searchRequest_QueryExpansionSpec_ConditionFromJSON(
  object: any,
): SearchRequest_QueryExpansionSpec_Condition {
  switch (object) {
    case 0:
    case "CONDITION_UNSPECIFIED":
      return SearchRequest_QueryExpansionSpec_Condition.CONDITION_UNSPECIFIED;
    case 1:
    case "DISABLED":
      return SearchRequest_QueryExpansionSpec_Condition.DISABLED;
    case 3:
    case "AUTO":
      return SearchRequest_QueryExpansionSpec_Condition.AUTO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_QueryExpansionSpec_Condition.UNRECOGNIZED;
  }
}

export function searchRequest_QueryExpansionSpec_ConditionToJSON(
  object: SearchRequest_QueryExpansionSpec_Condition,
): string {
  switch (object) {
    case SearchRequest_QueryExpansionSpec_Condition.CONDITION_UNSPECIFIED:
      return "CONDITION_UNSPECIFIED";
    case SearchRequest_QueryExpansionSpec_Condition.DISABLED:
      return "DISABLED";
    case SearchRequest_QueryExpansionSpec_Condition.AUTO:
      return "AUTO";
    case SearchRequest_QueryExpansionSpec_Condition.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The specification for personalization. */
export interface SearchRequest_PersonalizationSpec {
  /**
   * Defaults to
   * [Mode.AUTO][google.cloud.retail.v2beta.SearchRequest.PersonalizationSpec.Mode.AUTO].
   */
  mode: SearchRequest_PersonalizationSpec_Mode;
}

/** The personalization mode of each search request. */
export enum SearchRequest_PersonalizationSpec_Mode {
  /**
   * MODE_UNSPECIFIED - Default value. In this case, server behavior defaults to
   * [Mode.AUTO][google.cloud.retail.v2beta.SearchRequest.PersonalizationSpec.Mode.AUTO].
   */
  MODE_UNSPECIFIED = 0,
  /**
   * AUTO - Let CRS decide whether to use personalization based on quality of user
   * event data.
   */
  AUTO = 1,
  /** DISABLED - Disable personalization. */
  DISABLED = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_PersonalizationSpec_ModeFromJSON(object: any): SearchRequest_PersonalizationSpec_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return SearchRequest_PersonalizationSpec_Mode.MODE_UNSPECIFIED;
    case 1:
    case "AUTO":
      return SearchRequest_PersonalizationSpec_Mode.AUTO;
    case 2:
    case "DISABLED":
      return SearchRequest_PersonalizationSpec_Mode.DISABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_PersonalizationSpec_Mode.UNRECOGNIZED;
  }
}

export function searchRequest_PersonalizationSpec_ModeToJSON(object: SearchRequest_PersonalizationSpec_Mode): string {
  switch (object) {
    case SearchRequest_PersonalizationSpec_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case SearchRequest_PersonalizationSpec_Mode.AUTO:
      return "AUTO";
    case SearchRequest_PersonalizationSpec_Mode.DISABLED:
      return "DISABLED";
    case SearchRequest_PersonalizationSpec_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The specification for query spell correction. */
export interface SearchRequest_SpellCorrectionSpec {
  /**
   * The mode under which spell correction should take effect to
   * replace the original search query. Default to
   * [Mode.AUTO][google.cloud.retail.v2beta.SearchRequest.SpellCorrectionSpec.Mode.AUTO].
   */
  mode: SearchRequest_SpellCorrectionSpec_Mode;
}

/** Enum describing under which mode spell correction should occur. */
export enum SearchRequest_SpellCorrectionSpec_Mode {
  /**
   * MODE_UNSPECIFIED - Unspecified spell correction mode. In this case, server behavior
   * defaults to
   * [Mode.AUTO][google.cloud.retail.v2beta.SearchRequest.SpellCorrectionSpec.Mode.AUTO].
   */
  MODE_UNSPECIFIED = 0,
  /**
   * SUGGESTION_ONLY - Google Retail Search will try to find a spell suggestion if there
   * is any and put in the
   * [SearchResponse.corrected_query][google.cloud.retail.v2beta.SearchResponse.corrected_query].
   * The spell suggestion will not be used as the search query.
   */
  SUGGESTION_ONLY = 1,
  /**
   * AUTO - Automatic spell correction built by Google Retail Search. Search will
   * be based on the corrected query if found.
   */
  AUTO = 2,
  UNRECOGNIZED = -1,
}

export function searchRequest_SpellCorrectionSpec_ModeFromJSON(object: any): SearchRequest_SpellCorrectionSpec_Mode {
  switch (object) {
    case 0:
    case "MODE_UNSPECIFIED":
      return SearchRequest_SpellCorrectionSpec_Mode.MODE_UNSPECIFIED;
    case 1:
    case "SUGGESTION_ONLY":
      return SearchRequest_SpellCorrectionSpec_Mode.SUGGESTION_ONLY;
    case 2:
    case "AUTO":
      return SearchRequest_SpellCorrectionSpec_Mode.AUTO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchRequest_SpellCorrectionSpec_Mode.UNRECOGNIZED;
  }
}

export function searchRequest_SpellCorrectionSpec_ModeToJSON(object: SearchRequest_SpellCorrectionSpec_Mode): string {
  switch (object) {
    case SearchRequest_SpellCorrectionSpec_Mode.MODE_UNSPECIFIED:
      return "MODE_UNSPECIFIED";
    case SearchRequest_SpellCorrectionSpec_Mode.SUGGESTION_ONLY:
      return "SUGGESTION_ONLY";
    case SearchRequest_SpellCorrectionSpec_Mode.AUTO:
      return "AUTO";
    case SearchRequest_SpellCorrectionSpec_Mode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SearchRequest_LabelsEntry {
  key: string;
  value: string;
}

/**
 * Response message for
 * [SearchService.Search][google.cloud.retail.v2beta.SearchService.Search]
 * method.
 */
export interface SearchResponse {
  /** A list of matched items. The order represents the ranking. */
  results: SearchResponse_SearchResult[];
  /** Results of facets requested by user. */
  facets: SearchResponse_Facet[];
  /**
   * The estimated total count of matched items irrespective of pagination. The
   * count of [results][google.cloud.retail.v2beta.SearchResponse.results]
   * returned by pagination may be less than the
   * [total_size][google.cloud.retail.v2beta.SearchResponse.total_size] that
   * matches.
   */
  totalSize: number;
  /**
   * Contains the spell corrected query, if found. If the spell correction type
   * is AUTOMATIC, then the search results are based on corrected_query.
   * Otherwise the original query is used for search.
   */
  correctedQuery: string;
  /**
   * A unique search token. This should be included in the
   * [UserEvent][google.cloud.retail.v2beta.UserEvent] logs resulting from this
   * search, which enables accurate attribution of search model performance.
   */
  attributionToken: string;
  /**
   * A token that can be sent as
   * [SearchRequest.page_token][google.cloud.retail.v2beta.SearchRequest.page_token]
   * to retrieve the next page. If this field is omitted, there are no
   * subsequent pages.
   */
  nextPageToken: string;
  /** Query expansion information for the returned results. */
  queryExpansionInfo:
    | SearchResponse_QueryExpansionInfo
    | undefined;
  /**
   * The URI of a customer-defined redirect page. If redirect action is
   * triggered, no search is performed, and only
   * [redirect_uri][google.cloud.retail.v2beta.SearchResponse.redirect_uri] and
   * [attribution_token][google.cloud.retail.v2beta.SearchResponse.attribution_token]
   * are set in the response.
   */
  redirectUri: string;
  /**
   * The fully qualified resource name of applied
   * [controls](https://cloud.google.com/retail/docs/serving-control-rules).
   */
  appliedControls: string[];
  /**
   * The invalid
   * [SearchRequest.BoostSpec.condition_boost_specs][google.cloud.retail.v2beta.SearchRequest.BoostSpec.condition_boost_specs]
   * that are not applied during serving.
   */
  invalidConditionBoostSpecs: SearchRequest_BoostSpec_ConditionBoostSpec[];
  /**
   * Metadata related to A/B testing [Experiment][] associated with this
   * response. Only exists when an experiment is triggered.
   */
  experimentInfo: ExperimentInfo[];
}

/** Represents the search results. */
export interface SearchResponse_SearchResult {
  /**
   * [Product.id][google.cloud.retail.v2beta.Product.id] of the searched
   * [Product][google.cloud.retail.v2beta.Product].
   */
  id: string;
  /**
   * The product data snippet in the search response. Only
   * [Product.name][google.cloud.retail.v2beta.Product.name] is guaranteed to
   * be populated.
   *
   * [Product.variants][google.cloud.retail.v2beta.Product.variants] contains
   * the product variants that match the search query. If there are multiple
   * product variants matching the query, top 5 most relevant product variants
   * are returned and ordered by relevancy.
   *
   * If relevancy can be deternmined, use
   * [matching_variant_fields][google.cloud.retail.v2beta.SearchResponse.SearchResult.matching_variant_fields]
   * to look up matched product variants fields. If relevancy cannot be
   * determined, e.g. when searching "shoe" all products in a shoe product can
   * be a match, 5 product variants are returned but order is meaningless.
   */
  product:
    | Product
    | undefined;
  /**
   * The count of matched
   * [variant][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product]s.
   */
  matchingVariantCount: number;
  /**
   * If a [variant][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product] matches the search query,
   * this map indicates which [Product][google.cloud.retail.v2beta.Product]
   * fields are matched. The key is the
   * [Product.name][google.cloud.retail.v2beta.Product.name], the value is a
   * field mask of the matched [Product][google.cloud.retail.v2beta.Product]
   * fields. If matched attributes cannot be determined, this map will be
   * empty.
   *
   * For example, a key "sku1" with field mask
   * "products.color_info" indicates there is a match between
   * "sku1" [ColorInfo][google.cloud.retail.v2beta.ColorInfo] and the query.
   */
  matchingVariantFields: { [key: string]: string[] | undefined };
  /**
   * The rollup matching
   * [variant][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product] attributes. The key is one
   * of the
   * [SearchRequest.variant_rollup_keys][google.cloud.retail.v2beta.SearchRequest.variant_rollup_keys].
   * The values are the merged and de-duplicated
   * [Product][google.cloud.retail.v2beta.Product] attributes. Notice that the
   * rollup values are respect filter. For example, when filtering by
   * "colorFamilies:ANY(\"red\")" and rollup "colorFamilies", only "red" is
   * returned.
   *
   * For textual and numerical attributes, the rollup values is a list of
   * string or double values with type
   * [google.protobuf.ListValue][google.protobuf.ListValue]. For example, if
   * there are two variants with colors "red" and "blue", the rollup values
   * are
   *
   *     { key: "colorFamilies"
   *       value {
   *         list_value {
   *           values { string_value: "red" }
   *           values { string_value: "blue" }
   *          }
   *       }
   *     }
   *
   * For [FulfillmentInfo][google.cloud.retail.v2beta.FulfillmentInfo], the
   * rollup values is a double value with type
   * [google.protobuf.Value][google.protobuf.Value]. For example,
   * `{key: "pickupInStore.store1" value { number_value: 10 }}` means a there
   * are 10 variants in this product are available in the store "store1".
   */
  variantRollupValues: { [key: string]: any | undefined };
  /**
   * Specifies previous events related to this product for this user based on
   * [UserEvent][google.cloud.retail.v2beta.UserEvent] with same
   * [SearchRequest.visitor_id][google.cloud.retail.v2beta.SearchRequest.visitor_id]
   * or [UserInfo.user_id][google.cloud.retail.v2beta.UserInfo.user_id].
   *
   * This is set only when
   * [SearchRequest.PersonalizationSpec.mode][google.cloud.retail.v2beta.SearchRequest.PersonalizationSpec.mode]
   * is
   * [SearchRequest.PersonalizationSpec.Mode.AUTO][google.cloud.retail.v2beta.SearchRequest.PersonalizationSpec.Mode.AUTO].
   *
   * Possible values:
   *
   * * `purchased`: Indicates that this product has been purchased before.
   */
  personalLabels: string[];
}

export interface SearchResponse_SearchResult_MatchingVariantFieldsEntry {
  key: string;
  value: string[] | undefined;
}

export interface SearchResponse_SearchResult_VariantRollupValuesEntry {
  key: string;
  value: any | undefined;
}

/** A facet result. */
export interface SearchResponse_Facet {
  /**
   * The key for this facet. E.g., "colorFamilies" or "price" or
   * "attributes.attr1".
   */
  key: string;
  /** The facet values for this field. */
  values: SearchResponse_Facet_FacetValue[];
  /** Whether the facet is dynamically generated. */
  dynamicFacet: boolean;
}

/** A facet value which contains value names and their count. */
export interface SearchResponse_Facet_FacetValue {
  /** Text value of a facet, such as "Black" for facet "colorFamilies". */
  value?:
    | string
    | undefined;
  /** Interval value for a facet, such as [10, 20) for facet "price". */
  interval?:
    | Interval
    | undefined;
  /** Number of items that have this facet value. */
  count: Long;
  /**
   * The minimum value in the
   * [FacetValue.interval][google.cloud.retail.v2beta.SearchResponse.Facet.FacetValue.interval].
   * Only supported on numerical facets and returned if
   * [SearchRequest.FacetSpec.FacetKey.return_min_max][google.cloud.retail.v2beta.SearchRequest.FacetSpec.FacetKey.return_min_max]
   * is true.
   */
  minValue: number;
  /**
   * The maximum value in the
   * [FacetValue.interval][google.cloud.retail.v2beta.SearchResponse.Facet.FacetValue.interval].
   * Only supported on numerical facets and returned if
   * [SearchRequest.FacetSpec.FacetKey.return_min_max][google.cloud.retail.v2beta.SearchRequest.FacetSpec.FacetKey.return_min_max]
   * is true.
   */
  maxValue: number;
}

/**
 * Information describing query expansion including whether expansion has
 * occurred.
 */
export interface SearchResponse_QueryExpansionInfo {
  /** Bool describing whether query expansion has occurred. */
  expandedQuery: boolean;
  /**
   * Number of pinned results. This field will only be set when expansion
   * happens and
   * [SearchRequest.QueryExpansionSpec.pin_unexpanded_results][google.cloud.retail.v2beta.SearchRequest.QueryExpansionSpec.pin_unexpanded_results]
   * is set to true.
   */
  pinnedResultCount: Long;
}

/** Metadata for active A/B testing [Experiment][]. */
export interface ExperimentInfo {
  /**
   * A/B test between existing Cloud Retail Search
   * [ServingConfig][google.cloud.retail.v2beta.ServingConfig]s.
   */
  servingConfigExperiment?:
    | ExperimentInfo_ServingConfigExperiment
    | undefined;
  /**
   * The fully qualified resource name of the experiment that provides the
   * serving config under test, should an active experiment exist. For example:
   * `projects/* /locations/global/catalogs/default_catalog/experiments/experiment_id`
   */
  experiment: string;
}

/** Metadata for active serving config A/B tests. */
export interface ExperimentInfo_ServingConfigExperiment {
  /**
   * The fully qualified resource name of the original
   * [SearchRequest.placement][google.cloud.retail.v2beta.SearchRequest.placement]
   * in the search request prior to reassignment by experiment API. For
   * example: `projects/* /locations/* /catalogs/* /servingConfigs/*`.
   */
  originalServingConfig: string;
  /**
   * The fully qualified resource name of the serving config
   * [Experiment.VariantArm.serving_config_id][] responsible for generating
   * the search response. For example:
   * `projects/* /locations/* /catalogs/* /servingConfigs/*`.
   */
  experimentServingConfig: string;
}

function createBaseSearchRequest(): SearchRequest {
  return {
    placement: "",
    branch: "",
    query: "",
    visitorId: "",
    userInfo: undefined,
    pageSize: 0,
    pageToken: "",
    offset: 0,
    filter: "",
    canonicalFilter: "",
    orderBy: "",
    facetSpecs: [],
    dynamicFacetSpec: undefined,
    boostSpec: undefined,
    queryExpansionSpec: undefined,
    variantRollupKeys: [],
    pageCategories: [],
    searchMode: 0,
    personalizationSpec: undefined,
    labels: {},
    spellCorrectionSpec: undefined,
    entity: "",
  };
}

export const SearchRequest: MessageFns<SearchRequest> = {
  encode(message: SearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.placement !== "") {
      writer.uint32(10).string(message.placement);
    }
    if (message.branch !== "") {
      writer.uint32(18).string(message.branch);
    }
    if (message.query !== "") {
      writer.uint32(26).string(message.query);
    }
    if (message.visitorId !== "") {
      writer.uint32(34).string(message.visitorId);
    }
    if (message.userInfo !== undefined) {
      UserInfo.encode(message.userInfo, writer.uint32(42).fork()).join();
    }
    if (message.pageSize !== 0) {
      writer.uint32(56).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(66).string(message.pageToken);
    }
    if (message.offset !== 0) {
      writer.uint32(72).int32(message.offset);
    }
    if (message.filter !== "") {
      writer.uint32(82).string(message.filter);
    }
    if (message.canonicalFilter !== "") {
      writer.uint32(226).string(message.canonicalFilter);
    }
    if (message.orderBy !== "") {
      writer.uint32(90).string(message.orderBy);
    }
    for (const v of message.facetSpecs) {
      SearchRequest_FacetSpec.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.dynamicFacetSpec !== undefined) {
      SearchRequest_DynamicFacetSpec.encode(message.dynamicFacetSpec, writer.uint32(170).fork()).join();
    }
    if (message.boostSpec !== undefined) {
      SearchRequest_BoostSpec.encode(message.boostSpec, writer.uint32(106).fork()).join();
    }
    if (message.queryExpansionSpec !== undefined) {
      SearchRequest_QueryExpansionSpec.encode(message.queryExpansionSpec, writer.uint32(114).fork()).join();
    }
    for (const v of message.variantRollupKeys) {
      writer.uint32(138).string(v!);
    }
    for (const v of message.pageCategories) {
      writer.uint32(186).string(v!);
    }
    if (message.searchMode !== 0) {
      writer.uint32(248).int32(message.searchMode);
    }
    if (message.personalizationSpec !== undefined) {
      SearchRequest_PersonalizationSpec.encode(message.personalizationSpec, writer.uint32(258).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      SearchRequest_LabelsEntry.encode({ key: key as any, value }, writer.uint32(274).fork()).join();
    });
    if (message.spellCorrectionSpec !== undefined) {
      SearchRequest_SpellCorrectionSpec.encode(message.spellCorrectionSpec, writer.uint32(282).fork()).join();
    }
    if (message.entity !== "") {
      writer.uint32(306).string(message.entity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.placement = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.branch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.query = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.visitorId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.userInfo = UserInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.offset = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.canonicalFilter = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.facetSpecs.push(SearchRequest_FacetSpec.decode(reader, reader.uint32()));
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.dynamicFacetSpec = SearchRequest_DynamicFacetSpec.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.boostSpec = SearchRequest_BoostSpec.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.queryExpansionSpec = SearchRequest_QueryExpansionSpec.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.variantRollupKeys.push(reader.string());
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.pageCategories.push(reader.string());
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.searchMode = reader.int32() as any;
          continue;
        case 32:
          if (tag !== 258) {
            break;
          }

          message.personalizationSpec = SearchRequest_PersonalizationSpec.decode(reader, reader.uint32());
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          const entry34 = SearchRequest_LabelsEntry.decode(reader, reader.uint32());
          if (entry34.value !== undefined) {
            message.labels[entry34.key] = entry34.value;
          }
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.spellCorrectionSpec = SearchRequest_SpellCorrectionSpec.decode(reader, reader.uint32());
          continue;
        case 38:
          if (tag !== 306) {
            break;
          }

          message.entity = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return {
      placement: isSet(object.placement) ? globalThis.String(object.placement) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      visitorId: isSet(object.visitorId) ? globalThis.String(object.visitorId) : "",
      userInfo: isSet(object.userInfo) ? UserInfo.fromJSON(object.userInfo) : undefined,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      canonicalFilter: isSet(object.canonicalFilter) ? globalThis.String(object.canonicalFilter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      facetSpecs: globalThis.Array.isArray(object?.facetSpecs)
        ? object.facetSpecs.map((e: any) => SearchRequest_FacetSpec.fromJSON(e))
        : [],
      dynamicFacetSpec: isSet(object.dynamicFacetSpec)
        ? SearchRequest_DynamicFacetSpec.fromJSON(object.dynamicFacetSpec)
        : undefined,
      boostSpec: isSet(object.boostSpec) ? SearchRequest_BoostSpec.fromJSON(object.boostSpec) : undefined,
      queryExpansionSpec: isSet(object.queryExpansionSpec)
        ? SearchRequest_QueryExpansionSpec.fromJSON(object.queryExpansionSpec)
        : undefined,
      variantRollupKeys: globalThis.Array.isArray(object?.variantRollupKeys)
        ? object.variantRollupKeys.map((e: any) => globalThis.String(e))
        : [],
      pageCategories: globalThis.Array.isArray(object?.pageCategories)
        ? object.pageCategories.map((e: any) => globalThis.String(e))
        : [],
      searchMode: isSet(object.searchMode) ? searchRequest_SearchModeFromJSON(object.searchMode) : 0,
      personalizationSpec: isSet(object.personalizationSpec)
        ? SearchRequest_PersonalizationSpec.fromJSON(object.personalizationSpec)
        : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      spellCorrectionSpec: isSet(object.spellCorrectionSpec)
        ? SearchRequest_SpellCorrectionSpec.fromJSON(object.spellCorrectionSpec)
        : undefined,
      entity: isSet(object.entity) ? globalThis.String(object.entity) : "",
    };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.placement !== "") {
      obj.placement = message.placement;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.visitorId !== "") {
      obj.visitorId = message.visitorId;
    }
    if (message.userInfo !== undefined) {
      obj.userInfo = UserInfo.toJSON(message.userInfo);
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.canonicalFilter !== "") {
      obj.canonicalFilter = message.canonicalFilter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.facetSpecs?.length) {
      obj.facetSpecs = message.facetSpecs.map((e) => SearchRequest_FacetSpec.toJSON(e));
    }
    if (message.dynamicFacetSpec !== undefined) {
      obj.dynamicFacetSpec = SearchRequest_DynamicFacetSpec.toJSON(message.dynamicFacetSpec);
    }
    if (message.boostSpec !== undefined) {
      obj.boostSpec = SearchRequest_BoostSpec.toJSON(message.boostSpec);
    }
    if (message.queryExpansionSpec !== undefined) {
      obj.queryExpansionSpec = SearchRequest_QueryExpansionSpec.toJSON(message.queryExpansionSpec);
    }
    if (message.variantRollupKeys?.length) {
      obj.variantRollupKeys = message.variantRollupKeys;
    }
    if (message.pageCategories?.length) {
      obj.pageCategories = message.pageCategories;
    }
    if (message.searchMode !== 0) {
      obj.searchMode = searchRequest_SearchModeToJSON(message.searchMode);
    }
    if (message.personalizationSpec !== undefined) {
      obj.personalizationSpec = SearchRequest_PersonalizationSpec.toJSON(message.personalizationSpec);
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.spellCorrectionSpec !== undefined) {
      obj.spellCorrectionSpec = SearchRequest_SpellCorrectionSpec.toJSON(message.spellCorrectionSpec);
    }
    if (message.entity !== "") {
      obj.entity = message.entity;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest>): SearchRequest {
    return SearchRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest>): SearchRequest {
    const message = createBaseSearchRequest();
    message.placement = object.placement ?? "";
    message.branch = object.branch ?? "";
    message.query = object.query ?? "";
    message.visitorId = object.visitorId ?? "";
    message.userInfo = (object.userInfo !== undefined && object.userInfo !== null)
      ? UserInfo.fromPartial(object.userInfo)
      : undefined;
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.offset = object.offset ?? 0;
    message.filter = object.filter ?? "";
    message.canonicalFilter = object.canonicalFilter ?? "";
    message.orderBy = object.orderBy ?? "";
    message.facetSpecs = object.facetSpecs?.map((e) => SearchRequest_FacetSpec.fromPartial(e)) || [];
    message.dynamicFacetSpec = (object.dynamicFacetSpec !== undefined && object.dynamicFacetSpec !== null)
      ? SearchRequest_DynamicFacetSpec.fromPartial(object.dynamicFacetSpec)
      : undefined;
    message.boostSpec = (object.boostSpec !== undefined && object.boostSpec !== null)
      ? SearchRequest_BoostSpec.fromPartial(object.boostSpec)
      : undefined;
    message.queryExpansionSpec = (object.queryExpansionSpec !== undefined && object.queryExpansionSpec !== null)
      ? SearchRequest_QueryExpansionSpec.fromPartial(object.queryExpansionSpec)
      : undefined;
    message.variantRollupKeys = object.variantRollupKeys?.map((e) => e) || [];
    message.pageCategories = object.pageCategories?.map((e) => e) || [];
    message.searchMode = object.searchMode ?? 0;
    message.personalizationSpec = (object.personalizationSpec !== undefined && object.personalizationSpec !== null)
      ? SearchRequest_PersonalizationSpec.fromPartial(object.personalizationSpec)
      : undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.spellCorrectionSpec = (object.spellCorrectionSpec !== undefined && object.spellCorrectionSpec !== null)
      ? SearchRequest_SpellCorrectionSpec.fromPartial(object.spellCorrectionSpec)
      : undefined;
    message.entity = object.entity ?? "";
    return message;
  },
};

function createBaseSearchRequest_FacetSpec(): SearchRequest_FacetSpec {
  return { facetKey: undefined, limit: 0, excludedFilterKeys: [], enableDynamicPosition: false };
}

export const SearchRequest_FacetSpec: MessageFns<SearchRequest_FacetSpec> = {
  encode(message: SearchRequest_FacetSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.facetKey !== undefined) {
      SearchRequest_FacetSpec_FacetKey.encode(message.facetKey, writer.uint32(10).fork()).join();
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    for (const v of message.excludedFilterKeys) {
      writer.uint32(26).string(v!);
    }
    if (message.enableDynamicPosition !== false) {
      writer.uint32(32).bool(message.enableDynamicPosition);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_FacetSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_FacetSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.facetKey = SearchRequest_FacetSpec_FacetKey.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.excludedFilterKeys.push(reader.string());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.enableDynamicPosition = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_FacetSpec {
    return {
      facetKey: isSet(object.facetKey) ? SearchRequest_FacetSpec_FacetKey.fromJSON(object.facetKey) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      excludedFilterKeys: globalThis.Array.isArray(object?.excludedFilterKeys)
        ? object.excludedFilterKeys.map((e: any) => globalThis.String(e))
        : [],
      enableDynamicPosition: isSet(object.enableDynamicPosition)
        ? globalThis.Boolean(object.enableDynamicPosition)
        : false,
    };
  },

  toJSON(message: SearchRequest_FacetSpec): unknown {
    const obj: any = {};
    if (message.facetKey !== undefined) {
      obj.facetKey = SearchRequest_FacetSpec_FacetKey.toJSON(message.facetKey);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.excludedFilterKeys?.length) {
      obj.excludedFilterKeys = message.excludedFilterKeys;
    }
    if (message.enableDynamicPosition !== false) {
      obj.enableDynamicPosition = message.enableDynamicPosition;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_FacetSpec>): SearchRequest_FacetSpec {
    return SearchRequest_FacetSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_FacetSpec>): SearchRequest_FacetSpec {
    const message = createBaseSearchRequest_FacetSpec();
    message.facetKey = (object.facetKey !== undefined && object.facetKey !== null)
      ? SearchRequest_FacetSpec_FacetKey.fromPartial(object.facetKey)
      : undefined;
    message.limit = object.limit ?? 0;
    message.excludedFilterKeys = object.excludedFilterKeys?.map((e) => e) || [];
    message.enableDynamicPosition = object.enableDynamicPosition ?? false;
    return message;
  },
};

function createBaseSearchRequest_FacetSpec_FacetKey(): SearchRequest_FacetSpec_FacetKey {
  return {
    key: "",
    intervals: [],
    restrictedValues: [],
    prefixes: [],
    contains: [],
    caseInsensitive: false,
    orderBy: "",
    query: "",
    returnMinMax: false,
  };
}

export const SearchRequest_FacetSpec_FacetKey: MessageFns<SearchRequest_FacetSpec_FacetKey> = {
  encode(message: SearchRequest_FacetSpec_FacetKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.intervals) {
      Interval.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.restrictedValues) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.prefixes) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.contains) {
      writer.uint32(74).string(v!);
    }
    if (message.caseInsensitive !== false) {
      writer.uint32(80).bool(message.caseInsensitive);
    }
    if (message.orderBy !== "") {
      writer.uint32(34).string(message.orderBy);
    }
    if (message.query !== "") {
      writer.uint32(42).string(message.query);
    }
    if (message.returnMinMax !== false) {
      writer.uint32(88).bool(message.returnMinMax);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_FacetSpec_FacetKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_FacetSpec_FacetKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.intervals.push(Interval.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.restrictedValues.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.prefixes.push(reader.string());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.contains.push(reader.string());
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.caseInsensitive = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.query = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.returnMinMax = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_FacetSpec_FacetKey {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      intervals: globalThis.Array.isArray(object?.intervals)
        ? object.intervals.map((e: any) => Interval.fromJSON(e))
        : [],
      restrictedValues: globalThis.Array.isArray(object?.restrictedValues)
        ? object.restrictedValues.map((e: any) => globalThis.String(e))
        : [],
      prefixes: globalThis.Array.isArray(object?.prefixes) ? object.prefixes.map((e: any) => globalThis.String(e)) : [],
      contains: globalThis.Array.isArray(object?.contains) ? object.contains.map((e: any) => globalThis.String(e)) : [],
      caseInsensitive: isSet(object.caseInsensitive) ? globalThis.Boolean(object.caseInsensitive) : false,
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      returnMinMax: isSet(object.returnMinMax) ? globalThis.Boolean(object.returnMinMax) : false,
    };
  },

  toJSON(message: SearchRequest_FacetSpec_FacetKey): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.intervals?.length) {
      obj.intervals = message.intervals.map((e) => Interval.toJSON(e));
    }
    if (message.restrictedValues?.length) {
      obj.restrictedValues = message.restrictedValues;
    }
    if (message.prefixes?.length) {
      obj.prefixes = message.prefixes;
    }
    if (message.contains?.length) {
      obj.contains = message.contains;
    }
    if (message.caseInsensitive !== false) {
      obj.caseInsensitive = message.caseInsensitive;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.returnMinMax !== false) {
      obj.returnMinMax = message.returnMinMax;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_FacetSpec_FacetKey>): SearchRequest_FacetSpec_FacetKey {
    return SearchRequest_FacetSpec_FacetKey.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_FacetSpec_FacetKey>): SearchRequest_FacetSpec_FacetKey {
    const message = createBaseSearchRequest_FacetSpec_FacetKey();
    message.key = object.key ?? "";
    message.intervals = object.intervals?.map((e) => Interval.fromPartial(e)) || [];
    message.restrictedValues = object.restrictedValues?.map((e) => e) || [];
    message.prefixes = object.prefixes?.map((e) => e) || [];
    message.contains = object.contains?.map((e) => e) || [];
    message.caseInsensitive = object.caseInsensitive ?? false;
    message.orderBy = object.orderBy ?? "";
    message.query = object.query ?? "";
    message.returnMinMax = object.returnMinMax ?? false;
    return message;
  },
};

function createBaseSearchRequest_DynamicFacetSpec(): SearchRequest_DynamicFacetSpec {
  return { mode: 0 };
}

export const SearchRequest_DynamicFacetSpec: MessageFns<SearchRequest_DynamicFacetSpec> = {
  encode(message: SearchRequest_DynamicFacetSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_DynamicFacetSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_DynamicFacetSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_DynamicFacetSpec {
    return { mode: isSet(object.mode) ? searchRequest_DynamicFacetSpec_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: SearchRequest_DynamicFacetSpec): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = searchRequest_DynamicFacetSpec_ModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_DynamicFacetSpec>): SearchRequest_DynamicFacetSpec {
    return SearchRequest_DynamicFacetSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_DynamicFacetSpec>): SearchRequest_DynamicFacetSpec {
    const message = createBaseSearchRequest_DynamicFacetSpec();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseSearchRequest_BoostSpec(): SearchRequest_BoostSpec {
  return { conditionBoostSpecs: [], skipBoostSpecValidation: undefined };
}

export const SearchRequest_BoostSpec: MessageFns<SearchRequest_BoostSpec> = {
  encode(message: SearchRequest_BoostSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.conditionBoostSpecs) {
      SearchRequest_BoostSpec_ConditionBoostSpec.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.skipBoostSpecValidation !== undefined) {
      writer.uint32(16).bool(message.skipBoostSpecValidation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_BoostSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_BoostSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conditionBoostSpecs.push(SearchRequest_BoostSpec_ConditionBoostSpec.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.skipBoostSpecValidation = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_BoostSpec {
    return {
      conditionBoostSpecs: globalThis.Array.isArray(object?.conditionBoostSpecs)
        ? object.conditionBoostSpecs.map((e: any) => SearchRequest_BoostSpec_ConditionBoostSpec.fromJSON(e))
        : [],
      skipBoostSpecValidation: isSet(object.skipBoostSpecValidation)
        ? globalThis.Boolean(object.skipBoostSpecValidation)
        : undefined,
    };
  },

  toJSON(message: SearchRequest_BoostSpec): unknown {
    const obj: any = {};
    if (message.conditionBoostSpecs?.length) {
      obj.conditionBoostSpecs = message.conditionBoostSpecs.map((e) =>
        SearchRequest_BoostSpec_ConditionBoostSpec.toJSON(e)
      );
    }
    if (message.skipBoostSpecValidation !== undefined) {
      obj.skipBoostSpecValidation = message.skipBoostSpecValidation;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_BoostSpec>): SearchRequest_BoostSpec {
    return SearchRequest_BoostSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_BoostSpec>): SearchRequest_BoostSpec {
    const message = createBaseSearchRequest_BoostSpec();
    message.conditionBoostSpecs =
      object.conditionBoostSpecs?.map((e) => SearchRequest_BoostSpec_ConditionBoostSpec.fromPartial(e)) || [];
    message.skipBoostSpecValidation = object.skipBoostSpecValidation ?? undefined;
    return message;
  },
};

function createBaseSearchRequest_BoostSpec_ConditionBoostSpec(): SearchRequest_BoostSpec_ConditionBoostSpec {
  return { condition: "", boost: 0 };
}

export const SearchRequest_BoostSpec_ConditionBoostSpec: MessageFns<SearchRequest_BoostSpec_ConditionBoostSpec> = {
  encode(message: SearchRequest_BoostSpec_ConditionBoostSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== "") {
      writer.uint32(10).string(message.condition);
    }
    if (message.boost !== 0) {
      writer.uint32(21).float(message.boost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_BoostSpec_ConditionBoostSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_BoostSpec_ConditionBoostSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.condition = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.boost = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_BoostSpec_ConditionBoostSpec {
    return {
      condition: isSet(object.condition) ? globalThis.String(object.condition) : "",
      boost: isSet(object.boost) ? globalThis.Number(object.boost) : 0,
    };
  },

  toJSON(message: SearchRequest_BoostSpec_ConditionBoostSpec): unknown {
    const obj: any = {};
    if (message.condition !== "") {
      obj.condition = message.condition;
    }
    if (message.boost !== 0) {
      obj.boost = message.boost;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_BoostSpec_ConditionBoostSpec>): SearchRequest_BoostSpec_ConditionBoostSpec {
    return SearchRequest_BoostSpec_ConditionBoostSpec.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchRequest_BoostSpec_ConditionBoostSpec>,
  ): SearchRequest_BoostSpec_ConditionBoostSpec {
    const message = createBaseSearchRequest_BoostSpec_ConditionBoostSpec();
    message.condition = object.condition ?? "";
    message.boost = object.boost ?? 0;
    return message;
  },
};

function createBaseSearchRequest_QueryExpansionSpec(): SearchRequest_QueryExpansionSpec {
  return { condition: 0, pinUnexpandedResults: false };
}

export const SearchRequest_QueryExpansionSpec: MessageFns<SearchRequest_QueryExpansionSpec> = {
  encode(message: SearchRequest_QueryExpansionSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.condition !== 0) {
      writer.uint32(8).int32(message.condition);
    }
    if (message.pinUnexpandedResults !== false) {
      writer.uint32(16).bool(message.pinUnexpandedResults);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_QueryExpansionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_QueryExpansionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.condition = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pinUnexpandedResults = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_QueryExpansionSpec {
    return {
      condition: isSet(object.condition) ? searchRequest_QueryExpansionSpec_ConditionFromJSON(object.condition) : 0,
      pinUnexpandedResults: isSet(object.pinUnexpandedResults)
        ? globalThis.Boolean(object.pinUnexpandedResults)
        : false,
    };
  },

  toJSON(message: SearchRequest_QueryExpansionSpec): unknown {
    const obj: any = {};
    if (message.condition !== 0) {
      obj.condition = searchRequest_QueryExpansionSpec_ConditionToJSON(message.condition);
    }
    if (message.pinUnexpandedResults !== false) {
      obj.pinUnexpandedResults = message.pinUnexpandedResults;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_QueryExpansionSpec>): SearchRequest_QueryExpansionSpec {
    return SearchRequest_QueryExpansionSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_QueryExpansionSpec>): SearchRequest_QueryExpansionSpec {
    const message = createBaseSearchRequest_QueryExpansionSpec();
    message.condition = object.condition ?? 0;
    message.pinUnexpandedResults = object.pinUnexpandedResults ?? false;
    return message;
  },
};

function createBaseSearchRequest_PersonalizationSpec(): SearchRequest_PersonalizationSpec {
  return { mode: 0 };
}

export const SearchRequest_PersonalizationSpec: MessageFns<SearchRequest_PersonalizationSpec> = {
  encode(message: SearchRequest_PersonalizationSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_PersonalizationSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_PersonalizationSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_PersonalizationSpec {
    return { mode: isSet(object.mode) ? searchRequest_PersonalizationSpec_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: SearchRequest_PersonalizationSpec): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = searchRequest_PersonalizationSpec_ModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_PersonalizationSpec>): SearchRequest_PersonalizationSpec {
    return SearchRequest_PersonalizationSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_PersonalizationSpec>): SearchRequest_PersonalizationSpec {
    const message = createBaseSearchRequest_PersonalizationSpec();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseSearchRequest_SpellCorrectionSpec(): SearchRequest_SpellCorrectionSpec {
  return { mode: 0 };
}

export const SearchRequest_SpellCorrectionSpec: MessageFns<SearchRequest_SpellCorrectionSpec> = {
  encode(message: SearchRequest_SpellCorrectionSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mode !== 0) {
      writer.uint32(8).int32(message.mode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_SpellCorrectionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_SpellCorrectionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_SpellCorrectionSpec {
    return { mode: isSet(object.mode) ? searchRequest_SpellCorrectionSpec_ModeFromJSON(object.mode) : 0 };
  },

  toJSON(message: SearchRequest_SpellCorrectionSpec): unknown {
    const obj: any = {};
    if (message.mode !== 0) {
      obj.mode = searchRequest_SpellCorrectionSpec_ModeToJSON(message.mode);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_SpellCorrectionSpec>): SearchRequest_SpellCorrectionSpec {
    return SearchRequest_SpellCorrectionSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_SpellCorrectionSpec>): SearchRequest_SpellCorrectionSpec {
    const message = createBaseSearchRequest_SpellCorrectionSpec();
    message.mode = object.mode ?? 0;
    return message;
  },
};

function createBaseSearchRequest_LabelsEntry(): SearchRequest_LabelsEntry {
  return { key: "", value: "" };
}

export const SearchRequest_LabelsEntry: MessageFns<SearchRequest_LabelsEntry> = {
  encode(message: SearchRequest_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SearchRequest_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest_LabelsEntry>): SearchRequest_LabelsEntry {
    return SearchRequest_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest_LabelsEntry>): SearchRequest_LabelsEntry {
    const message = createBaseSearchRequest_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSearchResponse(): SearchResponse {
  return {
    results: [],
    facets: [],
    totalSize: 0,
    correctedQuery: "",
    attributionToken: "",
    nextPageToken: "",
    queryExpansionInfo: undefined,
    redirectUri: "",
    appliedControls: [],
    invalidConditionBoostSpecs: [],
    experimentInfo: [],
  };
}

export const SearchResponse: MessageFns<SearchResponse> = {
  encode(message: SearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      SearchResponse_SearchResult.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.facets) {
      SearchResponse_Facet.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.totalSize !== 0) {
      writer.uint32(24).int32(message.totalSize);
    }
    if (message.correctedQuery !== "") {
      writer.uint32(34).string(message.correctedQuery);
    }
    if (message.attributionToken !== "") {
      writer.uint32(42).string(message.attributionToken);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(50).string(message.nextPageToken);
    }
    if (message.queryExpansionInfo !== undefined) {
      SearchResponse_QueryExpansionInfo.encode(message.queryExpansionInfo, writer.uint32(58).fork()).join();
    }
    if (message.redirectUri !== "") {
      writer.uint32(82).string(message.redirectUri);
    }
    for (const v of message.appliedControls) {
      writer.uint32(98).string(v!);
    }
    for (const v of message.invalidConditionBoostSpecs) {
      SearchRequest_BoostSpec_ConditionBoostSpec.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.experimentInfo) {
      ExperimentInfo.encode(v!, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(SearchResponse_SearchResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.facets.push(SearchResponse_Facet.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.correctedQuery = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.attributionToken = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.queryExpansionInfo = SearchResponse_QueryExpansionInfo.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.redirectUri = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.appliedControls.push(reader.string());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.invalidConditionBoostSpecs.push(
            SearchRequest_BoostSpec_ConditionBoostSpec.decode(reader, reader.uint32()),
          );
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.experimentInfo.push(ExperimentInfo.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SearchResponse_SearchResult.fromJSON(e))
        : [],
      facets: globalThis.Array.isArray(object?.facets)
        ? object.facets.map((e: any) => SearchResponse_Facet.fromJSON(e))
        : [],
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
      correctedQuery: isSet(object.correctedQuery) ? globalThis.String(object.correctedQuery) : "",
      attributionToken: isSet(object.attributionToken) ? globalThis.String(object.attributionToken) : "",
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      queryExpansionInfo: isSet(object.queryExpansionInfo)
        ? SearchResponse_QueryExpansionInfo.fromJSON(object.queryExpansionInfo)
        : undefined,
      redirectUri: isSet(object.redirectUri) ? globalThis.String(object.redirectUri) : "",
      appliedControls: globalThis.Array.isArray(object?.appliedControls)
        ? object.appliedControls.map((e: any) => globalThis.String(e))
        : [],
      invalidConditionBoostSpecs: globalThis.Array.isArray(object?.invalidConditionBoostSpecs)
        ? object.invalidConditionBoostSpecs.map((e: any) => SearchRequest_BoostSpec_ConditionBoostSpec.fromJSON(e))
        : [],
      experimentInfo: globalThis.Array.isArray(object?.experimentInfo)
        ? object.experimentInfo.map((e: any) => ExperimentInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SearchResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => SearchResponse_SearchResult.toJSON(e));
    }
    if (message.facets?.length) {
      obj.facets = message.facets.map((e) => SearchResponse_Facet.toJSON(e));
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    if (message.correctedQuery !== "") {
      obj.correctedQuery = message.correctedQuery;
    }
    if (message.attributionToken !== "") {
      obj.attributionToken = message.attributionToken;
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.queryExpansionInfo !== undefined) {
      obj.queryExpansionInfo = SearchResponse_QueryExpansionInfo.toJSON(message.queryExpansionInfo);
    }
    if (message.redirectUri !== "") {
      obj.redirectUri = message.redirectUri;
    }
    if (message.appliedControls?.length) {
      obj.appliedControls = message.appliedControls;
    }
    if (message.invalidConditionBoostSpecs?.length) {
      obj.invalidConditionBoostSpecs = message.invalidConditionBoostSpecs.map((e) =>
        SearchRequest_BoostSpec_ConditionBoostSpec.toJSON(e)
      );
    }
    if (message.experimentInfo?.length) {
      obj.experimentInfo = message.experimentInfo.map((e) => ExperimentInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse>): SearchResponse {
    return SearchResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse>): SearchResponse {
    const message = createBaseSearchResponse();
    message.results = object.results?.map((e) => SearchResponse_SearchResult.fromPartial(e)) || [];
    message.facets = object.facets?.map((e) => SearchResponse_Facet.fromPartial(e)) || [];
    message.totalSize = object.totalSize ?? 0;
    message.correctedQuery = object.correctedQuery ?? "";
    message.attributionToken = object.attributionToken ?? "";
    message.nextPageToken = object.nextPageToken ?? "";
    message.queryExpansionInfo = (object.queryExpansionInfo !== undefined && object.queryExpansionInfo !== null)
      ? SearchResponse_QueryExpansionInfo.fromPartial(object.queryExpansionInfo)
      : undefined;
    message.redirectUri = object.redirectUri ?? "";
    message.appliedControls = object.appliedControls?.map((e) => e) || [];
    message.invalidConditionBoostSpecs =
      object.invalidConditionBoostSpecs?.map((e) => SearchRequest_BoostSpec_ConditionBoostSpec.fromPartial(e)) || [];
    message.experimentInfo = object.experimentInfo?.map((e) => ExperimentInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchResponse_SearchResult(): SearchResponse_SearchResult {
  return {
    id: "",
    product: undefined,
    matchingVariantCount: 0,
    matchingVariantFields: {},
    variantRollupValues: {},
    personalLabels: [],
  };
}

export const SearchResponse_SearchResult: MessageFns<SearchResponse_SearchResult> = {
  encode(message: SearchResponse_SearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(18).fork()).join();
    }
    if (message.matchingVariantCount !== 0) {
      writer.uint32(24).int32(message.matchingVariantCount);
    }
    Object.entries(message.matchingVariantFields).forEach(([key, value]) => {
      if (value !== undefined) {
        SearchResponse_SearchResult_MatchingVariantFieldsEntry.encode(
          { key: key as any, value },
          writer.uint32(34).fork(),
        ).join();
      }
    });
    Object.entries(message.variantRollupValues).forEach(([key, value]) => {
      if (value !== undefined) {
        SearchResponse_SearchResult_VariantRollupValuesEntry.encode(
          { key: key as any, value },
          writer.uint32(42).fork(),
        ).join();
      }
    });
    for (const v of message.personalLabels) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_SearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_SearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.matchingVariantCount = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = SearchResponse_SearchResult_MatchingVariantFieldsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.matchingVariantFields[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = SearchResponse_SearchResult_VariantRollupValuesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.variantRollupValues[entry5.key] = entry5.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.personalLabels.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_SearchResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      product: isSet(object.product) ? Product.fromJSON(object.product) : undefined,
      matchingVariantCount: isSet(object.matchingVariantCount) ? globalThis.Number(object.matchingVariantCount) : 0,
      matchingVariantFields: isObject(object.matchingVariantFields)
        ? Object.entries(object.matchingVariantFields).reduce<{ [key: string]: string[] | undefined }>(
          (acc, [key, value]) => {
            acc[key] = value as string[] | undefined;
            return acc;
          },
          {},
        )
        : {},
      variantRollupValues: isObject(object.variantRollupValues)
        ? Object.entries(object.variantRollupValues).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
      personalLabels: globalThis.Array.isArray(object?.personalLabels)
        ? object.personalLabels.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SearchResponse_SearchResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    if (message.matchingVariantCount !== 0) {
      obj.matchingVariantCount = Math.round(message.matchingVariantCount);
    }
    if (message.matchingVariantFields) {
      const entries = Object.entries(message.matchingVariantFields);
      if (entries.length > 0) {
        obj.matchingVariantFields = {};
        entries.forEach(([k, v]) => {
          obj.matchingVariantFields[k] = v;
        });
      }
    }
    if (message.variantRollupValues) {
      const entries = Object.entries(message.variantRollupValues);
      if (entries.length > 0) {
        obj.variantRollupValues = {};
        entries.forEach(([k, v]) => {
          obj.variantRollupValues[k] = v;
        });
      }
    }
    if (message.personalLabels?.length) {
      obj.personalLabels = message.personalLabels;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_SearchResult>): SearchResponse_SearchResult {
    return SearchResponse_SearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_SearchResult>): SearchResponse_SearchResult {
    const message = createBaseSearchResponse_SearchResult();
    message.id = object.id ?? "";
    message.product = (object.product !== undefined && object.product !== null)
      ? Product.fromPartial(object.product)
      : undefined;
    message.matchingVariantCount = object.matchingVariantCount ?? 0;
    message.matchingVariantFields = Object.entries(object.matchingVariantFields ?? {}).reduce<
      { [key: string]: string[] | undefined }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.variantRollupValues = Object.entries(object.variantRollupValues ?? {}).reduce<
      { [key: string]: any | undefined }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.personalLabels = object.personalLabels?.map((e) => e) || [];
    return message;
  },
};

function createBaseSearchResponse_SearchResult_MatchingVariantFieldsEntry(): SearchResponse_SearchResult_MatchingVariantFieldsEntry {
  return { key: "", value: undefined };
}

export const SearchResponse_SearchResult_MatchingVariantFieldsEntry: MessageFns<
  SearchResponse_SearchResult_MatchingVariantFieldsEntry
> = {
  encode(
    message: SearchResponse_SearchResult_MatchingVariantFieldsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_SearchResult_MatchingVariantFieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_SearchResult_MatchingVariantFieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_SearchResult_MatchingVariantFieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? FieldMask.unwrap(FieldMask.fromJSON(object.value)) : undefined,
    };
  },

  toJSON(message: SearchResponse_SearchResult_MatchingVariantFieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = FieldMask.toJSON(FieldMask.wrap(message.value));
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchResponse_SearchResult_MatchingVariantFieldsEntry>,
  ): SearchResponse_SearchResult_MatchingVariantFieldsEntry {
    return SearchResponse_SearchResult_MatchingVariantFieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchResponse_SearchResult_MatchingVariantFieldsEntry>,
  ): SearchResponse_SearchResult_MatchingVariantFieldsEntry {
    const message = createBaseSearchResponse_SearchResult_MatchingVariantFieldsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseSearchResponse_SearchResult_VariantRollupValuesEntry(): SearchResponse_SearchResult_VariantRollupValuesEntry {
  return { key: "", value: undefined };
}

export const SearchResponse_SearchResult_VariantRollupValuesEntry: MessageFns<
  SearchResponse_SearchResult_VariantRollupValuesEntry
> = {
  encode(
    message: SearchResponse_SearchResult_VariantRollupValuesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_SearchResult_VariantRollupValuesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_SearchResult_VariantRollupValuesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_SearchResult_VariantRollupValuesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: SearchResponse_SearchResult_VariantRollupValuesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SearchResponse_SearchResult_VariantRollupValuesEntry>,
  ): SearchResponse_SearchResult_VariantRollupValuesEntry {
    return SearchResponse_SearchResult_VariantRollupValuesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SearchResponse_SearchResult_VariantRollupValuesEntry>,
  ): SearchResponse_SearchResult_VariantRollupValuesEntry {
    const message = createBaseSearchResponse_SearchResult_VariantRollupValuesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseSearchResponse_Facet(): SearchResponse_Facet {
  return { key: "", values: [], dynamicFacet: false };
}

export const SearchResponse_Facet: MessageFns<SearchResponse_Facet> = {
  encode(message: SearchResponse_Facet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    for (const v of message.values) {
      SearchResponse_Facet_FacetValue.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.dynamicFacet !== false) {
      writer.uint32(24).bool(message.dynamicFacet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Facet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Facet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.values.push(SearchResponse_Facet_FacetValue.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.dynamicFacet = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Facet {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => SearchResponse_Facet_FacetValue.fromJSON(e))
        : [],
      dynamicFacet: isSet(object.dynamicFacet) ? globalThis.Boolean(object.dynamicFacet) : false,
    };
  },

  toJSON(message: SearchResponse_Facet): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.values?.length) {
      obj.values = message.values.map((e) => SearchResponse_Facet_FacetValue.toJSON(e));
    }
    if (message.dynamicFacet !== false) {
      obj.dynamicFacet = message.dynamicFacet;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Facet>): SearchResponse_Facet {
    return SearchResponse_Facet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Facet>): SearchResponse_Facet {
    const message = createBaseSearchResponse_Facet();
    message.key = object.key ?? "";
    message.values = object.values?.map((e) => SearchResponse_Facet_FacetValue.fromPartial(e)) || [];
    message.dynamicFacet = object.dynamicFacet ?? false;
    return message;
  },
};

function createBaseSearchResponse_Facet_FacetValue(): SearchResponse_Facet_FacetValue {
  return { value: undefined, interval: undefined, count: Long.ZERO, minValue: 0, maxValue: 0 };
}

export const SearchResponse_Facet_FacetValue: MessageFns<SearchResponse_Facet_FacetValue> = {
  encode(message: SearchResponse_Facet_FacetValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      writer.uint32(10).string(message.value);
    }
    if (message.interval !== undefined) {
      Interval.encode(message.interval, writer.uint32(18).fork()).join();
    }
    if (!message.count.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.count.toString());
    }
    if (message.minValue !== 0) {
      writer.uint32(41).double(message.minValue);
    }
    if (message.maxValue !== 0) {
      writer.uint32(49).double(message.maxValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_Facet_FacetValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_Facet_FacetValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.interval = Interval.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.count = Long.fromString(reader.int64().toString());
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.minValue = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.maxValue = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_Facet_FacetValue {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      interval: isSet(object.interval) ? Interval.fromJSON(object.interval) : undefined,
      count: isSet(object.count) ? Long.fromValue(object.count) : Long.ZERO,
      minValue: isSet(object.minValue) ? globalThis.Number(object.minValue) : 0,
      maxValue: isSet(object.maxValue) ? globalThis.Number(object.maxValue) : 0,
    };
  },

  toJSON(message: SearchResponse_Facet_FacetValue): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.interval !== undefined) {
      obj.interval = Interval.toJSON(message.interval);
    }
    if (!message.count.equals(Long.ZERO)) {
      obj.count = (message.count || Long.ZERO).toString();
    }
    if (message.minValue !== 0) {
      obj.minValue = message.minValue;
    }
    if (message.maxValue !== 0) {
      obj.maxValue = message.maxValue;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_Facet_FacetValue>): SearchResponse_Facet_FacetValue {
    return SearchResponse_Facet_FacetValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_Facet_FacetValue>): SearchResponse_Facet_FacetValue {
    const message = createBaseSearchResponse_Facet_FacetValue();
    message.value = object.value ?? undefined;
    message.interval = (object.interval !== undefined && object.interval !== null)
      ? Interval.fromPartial(object.interval)
      : undefined;
    message.count = (object.count !== undefined && object.count !== null) ? Long.fromValue(object.count) : Long.ZERO;
    message.minValue = object.minValue ?? 0;
    message.maxValue = object.maxValue ?? 0;
    return message;
  },
};

function createBaseSearchResponse_QueryExpansionInfo(): SearchResponse_QueryExpansionInfo {
  return { expandedQuery: false, pinnedResultCount: Long.ZERO };
}

export const SearchResponse_QueryExpansionInfo: MessageFns<SearchResponse_QueryExpansionInfo> = {
  encode(message: SearchResponse_QueryExpansionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expandedQuery !== false) {
      writer.uint32(8).bool(message.expandedQuery);
    }
    if (!message.pinnedResultCount.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.pinnedResultCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse_QueryExpansionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse_QueryExpansionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.expandedQuery = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pinnedResultCount = Long.fromString(reader.int64().toString());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse_QueryExpansionInfo {
    return {
      expandedQuery: isSet(object.expandedQuery) ? globalThis.Boolean(object.expandedQuery) : false,
      pinnedResultCount: isSet(object.pinnedResultCount) ? Long.fromValue(object.pinnedResultCount) : Long.ZERO,
    };
  },

  toJSON(message: SearchResponse_QueryExpansionInfo): unknown {
    const obj: any = {};
    if (message.expandedQuery !== false) {
      obj.expandedQuery = message.expandedQuery;
    }
    if (!message.pinnedResultCount.equals(Long.ZERO)) {
      obj.pinnedResultCount = (message.pinnedResultCount || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResponse_QueryExpansionInfo>): SearchResponse_QueryExpansionInfo {
    return SearchResponse_QueryExpansionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResponse_QueryExpansionInfo>): SearchResponse_QueryExpansionInfo {
    const message = createBaseSearchResponse_QueryExpansionInfo();
    message.expandedQuery = object.expandedQuery ?? false;
    message.pinnedResultCount = (object.pinnedResultCount !== undefined && object.pinnedResultCount !== null)
      ? Long.fromValue(object.pinnedResultCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseExperimentInfo(): ExperimentInfo {
  return { servingConfigExperiment: undefined, experiment: "" };
}

export const ExperimentInfo: MessageFns<ExperimentInfo> = {
  encode(message: ExperimentInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.servingConfigExperiment !== undefined) {
      ExperimentInfo_ServingConfigExperiment.encode(message.servingConfigExperiment, writer.uint32(18).fork()).join();
    }
    if (message.experiment !== "") {
      writer.uint32(10).string(message.experiment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExperimentInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExperimentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          if (tag !== 18) {
            break;
          }

          message.servingConfigExperiment = ExperimentInfo_ServingConfigExperiment.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.experiment = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExperimentInfo {
    return {
      servingConfigExperiment: isSet(object.servingConfigExperiment)
        ? ExperimentInfo_ServingConfigExperiment.fromJSON(object.servingConfigExperiment)
        : undefined,
      experiment: isSet(object.experiment) ? globalThis.String(object.experiment) : "",
    };
  },

  toJSON(message: ExperimentInfo): unknown {
    const obj: any = {};
    if (message.servingConfigExperiment !== undefined) {
      obj.servingConfigExperiment = ExperimentInfo_ServingConfigExperiment.toJSON(message.servingConfigExperiment);
    }
    if (message.experiment !== "") {
      obj.experiment = message.experiment;
    }
    return obj;
  },

  create(base?: DeepPartial<ExperimentInfo>): ExperimentInfo {
    return ExperimentInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExperimentInfo>): ExperimentInfo {
    const message = createBaseExperimentInfo();
    message.servingConfigExperiment =
      (object.servingConfigExperiment !== undefined && object.servingConfigExperiment !== null)
        ? ExperimentInfo_ServingConfigExperiment.fromPartial(object.servingConfigExperiment)
        : undefined;
    message.experiment = object.experiment ?? "";
    return message;
  },
};

function createBaseExperimentInfo_ServingConfigExperiment(): ExperimentInfo_ServingConfigExperiment {
  return { originalServingConfig: "", experimentServingConfig: "" };
}

export const ExperimentInfo_ServingConfigExperiment: MessageFns<ExperimentInfo_ServingConfigExperiment> = {
  encode(message: ExperimentInfo_ServingConfigExperiment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originalServingConfig !== "") {
      writer.uint32(10).string(message.originalServingConfig);
    }
    if (message.experimentServingConfig !== "") {
      writer.uint32(18).string(message.experimentServingConfig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExperimentInfo_ServingConfigExperiment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExperimentInfo_ServingConfigExperiment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.originalServingConfig = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.experimentServingConfig = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExperimentInfo_ServingConfigExperiment {
    return {
      originalServingConfig: isSet(object.originalServingConfig) ? globalThis.String(object.originalServingConfig) : "",
      experimentServingConfig: isSet(object.experimentServingConfig)
        ? globalThis.String(object.experimentServingConfig)
        : "",
    };
  },

  toJSON(message: ExperimentInfo_ServingConfigExperiment): unknown {
    const obj: any = {};
    if (message.originalServingConfig !== "") {
      obj.originalServingConfig = message.originalServingConfig;
    }
    if (message.experimentServingConfig !== "") {
      obj.experimentServingConfig = message.experimentServingConfig;
    }
    return obj;
  },

  create(base?: DeepPartial<ExperimentInfo_ServingConfigExperiment>): ExperimentInfo_ServingConfigExperiment {
    return ExperimentInfo_ServingConfigExperiment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ExperimentInfo_ServingConfigExperiment>): ExperimentInfo_ServingConfigExperiment {
    const message = createBaseExperimentInfo_ServingConfigExperiment();
    message.originalServingConfig = object.originalServingConfig ?? "";
    message.experimentServingConfig = object.experimentServingConfig ?? "";
    return message;
  },
};

/**
 * Service for search.
 *
 * This feature is only available for users who have Retail Search enabled.
 * Enable Retail Search on Cloud Console before using this feature.
 */
export type SearchServiceDefinition = typeof SearchServiceDefinition;
export const SearchServiceDefinition = {
  name: "SearchService",
  fullName: "google.cloud.retail.v2beta.SearchService",
  methods: {
    /**
     * Performs a search.
     *
     * This feature is only available for users who have Retail Search enabled.
     * Enable Retail Search on Cloud Console before using this feature.
     */
    search: {
      name: "Search",
      requestType: SearchRequest,
      requestStream: false,
      responseType: SearchResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              162,
              1,
              58,
              1,
              42,
              90,
              82,
              58,
              1,
              42,
              34,
              77,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              108,
              97,
              99,
              101,
              109,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              97,
              116,
              97,
              108,
              111,
              103,
              115,
              47,
              42,
              47,
              115,
              101,
              114,
              118,
              105,
              110,
              103,
              67,
              111,
              110,
              102,
              105,
              103,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              34,
              73,
              47,
              118,
              50,
              98,
              101,
              116,
              97,
              47,
              123,
              112,
              108,
              97,
              99,
              101,
              109,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              99,
              97,
              116,
              97,
              108,
              111,
              103,
              115,
              47,
              42,
              47,
              112,
              108,
              97,
              99,
              101,
              109,
              101,
              110,
              116,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface SearchServiceImplementation<CallContextExt = {}> {
  /**
   * Performs a search.
   *
   * This feature is only available for users who have Retail Search enabled.
   * Enable Retail Search on Cloud Console before using this feature.
   */
  search(request: SearchRequest, context: CallContext & CallContextExt): Promise<DeepPartial<SearchResponse>>;
}

export interface SearchServiceClient<CallOptionsExt = {}> {
  /**
   * Performs a search.
   *
   * This feature is only available for users who have Retail Search enabled.
   * Enable Retail Search on Cloud Console before using this feature.
   */
  search(request: DeepPartial<SearchRequest>, options?: CallOptions & CallOptionsExt): Promise<SearchResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
