// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/retail/v2beta/control.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  Rule,
  SearchSolutionUseCase,
  searchSolutionUseCaseFromJSON,
  searchSolutionUseCaseToJSON,
  SolutionType,
  solutionTypeFromJSON,
  solutionTypeToJSON,
} from "./common.js";
import { SearchRequest_FacetSpec } from "./search_service.js";

export const protobufPackage = "google.cloud.retail.v2beta";

/**
 * Configures dynamic metadata that can be linked to a
 * [ServingConfig][google.cloud.retail.v2beta.ServingConfig] and affect search
 * or recommendation results at serving time.
 */
export interface Control {
  /**
   * A facet specification to perform faceted search.
   *
   * Note that this field is deprecated and will throw NOT_IMPLEMENTED if
   * used for creating a control.
   *
   * @deprecated
   */
  facetSpec?:
    | SearchRequest_FacetSpec
    | undefined;
  /**
   * A rule control - a condition-action pair.
   * Enacts a set action when the condition is triggered.
   * For example: Boost "gShoe" when query full matches "Running Shoes".
   */
  rule?:
    | Rule
    | undefined;
  /**
   * Immutable. Fully qualified name
   * `projects/* /locations/global/catalogs/* /controls/*`
   */
  name: string;
  /**
   * Required. The human readable control display name. Used in Retail UI.
   *
   * This field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an INVALID_ARGUMENT error is thrown.
   */
  displayName: string;
  /**
   * Output only. List of [serving
   * config][google.cloud.retail.v2beta.ServingConfig] ids that are associated
   * with this control in the same
   * [Catalog][google.cloud.retail.v2beta.Catalog].
   *
   * Note the association is managed via the
   * [ServingConfig][google.cloud.retail.v2beta.ServingConfig], this is an
   * output only denormalized view.
   */
  associatedServingConfigIds: string[];
  /**
   * Required. Immutable. The solution types that the control is used for.
   * Currently we support setting only one type of solution at creation time.
   *
   * Only `SOLUTION_TYPE_SEARCH` value is supported at the moment.
   * If no solution type is provided at creation time, will default to
   * [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2beta.SolutionType.SOLUTION_TYPE_SEARCH].
   */
  solutionTypes: SolutionType[];
  /**
   * Specifies the use case for the control.
   * Affects what condition fields can be set.
   * Only settable by search controls.
   * Will default to
   * [SEARCH_SOLUTION_USE_CASE_SEARCH][google.cloud.retail.v2beta.SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_SEARCH]
   * if not specified. Currently only allow one search_solution_use_case per
   * control.
   */
  searchSolutionUseCase: SearchSolutionUseCase[];
}

function createBaseControl(): Control {
  return {
    facetSpec: undefined,
    rule: undefined,
    name: "",
    displayName: "",
    associatedServingConfigIds: [],
    solutionTypes: [],
    searchSolutionUseCase: [],
  };
}

export const Control: MessageFns<Control> = {
  encode(message: Control, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.facetSpec !== undefined) {
      SearchRequest_FacetSpec.encode(message.facetSpec, writer.uint32(26).fork()).join();
    }
    if (message.rule !== undefined) {
      Rule.encode(message.rule, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    for (const v of message.associatedServingConfigIds) {
      writer.uint32(42).string(v!);
    }
    writer.uint32(50).fork();
    for (const v of message.solutionTypes) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(58).fork();
    for (const v of message.searchSolutionUseCase) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Control {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.facetSpec = SearchRequest_FacetSpec.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rule = Rule.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.associatedServingConfigIds.push(reader.string());
          continue;
        case 6:
          if (tag === 48) {
            message.solutionTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.solutionTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        case 7:
          if (tag === 56) {
            message.searchSolutionUseCase.push(reader.int32() as any);

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.searchSolutionUseCase.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Control {
    return {
      facetSpec: isSet(object.facetSpec) ? SearchRequest_FacetSpec.fromJSON(object.facetSpec) : undefined,
      rule: isSet(object.rule) ? Rule.fromJSON(object.rule) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      associatedServingConfigIds: globalThis.Array.isArray(object?.associatedServingConfigIds)
        ? object.associatedServingConfigIds.map((e: any) => globalThis.String(e))
        : [],
      solutionTypes: globalThis.Array.isArray(object?.solutionTypes)
        ? object.solutionTypes.map((e: any) => solutionTypeFromJSON(e))
        : [],
      searchSolutionUseCase: globalThis.Array.isArray(object?.searchSolutionUseCase)
        ? object.searchSolutionUseCase.map((e: any) => searchSolutionUseCaseFromJSON(e))
        : [],
    };
  },

  toJSON(message: Control): unknown {
    const obj: any = {};
    if (message.facetSpec !== undefined) {
      obj.facetSpec = SearchRequest_FacetSpec.toJSON(message.facetSpec);
    }
    if (message.rule !== undefined) {
      obj.rule = Rule.toJSON(message.rule);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.associatedServingConfigIds?.length) {
      obj.associatedServingConfigIds = message.associatedServingConfigIds;
    }
    if (message.solutionTypes?.length) {
      obj.solutionTypes = message.solutionTypes.map((e) => solutionTypeToJSON(e));
    }
    if (message.searchSolutionUseCase?.length) {
      obj.searchSolutionUseCase = message.searchSolutionUseCase.map((e) => searchSolutionUseCaseToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Control>): Control {
    return Control.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Control>): Control {
    const message = createBaseControl();
    message.facetSpec = (object.facetSpec !== undefined && object.facetSpec !== null)
      ? SearchRequest_FacetSpec.fromPartial(object.facetSpec)
      : undefined;
    message.rule = (object.rule !== undefined && object.rule !== null) ? Rule.fromPartial(object.rule) : undefined;
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.associatedServingConfigIds = object.associatedServingConfigIds?.map((e) => e) || [];
    message.solutionTypes = object.solutionTypes?.map((e) => e) || [];
    message.searchSolutionUseCase = object.searchSolutionUseCase?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
