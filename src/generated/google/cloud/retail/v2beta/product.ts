// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/retail/v2beta/product.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { Int32Value } from "../../../protobuf/wrappers.js";
import {
  Audience,
  ColorInfo,
  CustomAttribute,
  FulfillmentInfo,
  Image,
  LocalInventory,
  PriceInfo,
  Rating,
} from "./common.js";
import { Promotion } from "./promotion.js";

export const protobufPackage = "google.cloud.retail.v2beta";

/**
 * Product captures all metadata information of items to be recommended or
 * searched.
 */
export interface Product {
  /**
   * Note that this field is applied in the following ways:
   *
   * * If the [Product][google.cloud.retail.v2beta.Product] is already expired
   * when it is uploaded, this product
   *   is not indexed for search.
   *
   * * If the [Product][google.cloud.retail.v2beta.Product] is not expired
   * when it is uploaded, only the
   *   [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY]'s and
   *   [Type.COLLECTION][google.cloud.retail.v2beta.Product.Type.COLLECTION]'s
   *   expireTime is respected, and
   *   [Type.VARIANT][google.cloud.retail.v2beta.Product.Type.VARIANT]'s
   *   expireTime is not used.
   *
   * In general, we suggest the users to delete the stale
   * products explicitly, instead of using this field to determine staleness.
   *
   * [expire_time][google.cloud.retail.v2beta.Product.expire_time] must be
   * later than
   * [available_time][google.cloud.retail.v2beta.Product.available_time] and
   * [publish_time][google.cloud.retail.v2beta.Product.publish_time],
   * otherwise an INVALID_ARGUMENT error is thrown.
   *
   * Corresponding properties: Google Merchant Center property
   * [expiration_date](https://support.google.com/merchants/answer/6324499).
   */
  expireTime?:
    | Date
    | undefined;
  /**
   * Input only. The TTL (time to live) of the product. Note that this is only
   * applicable to
   * [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY] and
   * [Type.COLLECTION][google.cloud.retail.v2beta.Product.Type.COLLECTION],
   * and ignored for
   * [Type.VARIANT][google.cloud.retail.v2beta.Product.Type.VARIANT]. In
   * general, we suggest the users to delete the stale products explicitly,
   * instead of using this field to determine staleness.
   *
   * If it is set, it must be a non-negative value, and
   * [expire_time][google.cloud.retail.v2beta.Product.expire_time] is set as
   * current timestamp plus [ttl][google.cloud.retail.v2beta.Product.ttl]. The
   * derived [expire_time][google.cloud.retail.v2beta.Product.expire_time] is
   * returned in the output and [ttl][google.cloud.retail.v2beta.Product.ttl]
   * is left blank when retrieving the
   * [Product][google.cloud.retail.v2beta.Product].
   *
   * If it is set, the product is not available for
   * [SearchService.Search][google.cloud.retail.v2beta.SearchService.Search]
   * after current timestamp plus
   * [ttl][google.cloud.retail.v2beta.Product.ttl]. However, the product can
   * still be retrieved by
   * [ProductService.GetProduct][google.cloud.retail.v2beta.ProductService.GetProduct]
   * and
   * [ProductService.ListProducts][google.cloud.retail.v2beta.ProductService.ListProducts].
   */
  ttl?:
    | Duration
    | undefined;
  /**
   * Immutable. Full resource name of the product, such as
   * `projects/* /locations/global/catalogs/default_catalog/branches/default_branch/products/product_id`.
   */
  name: string;
  /**
   * Immutable. [Product][google.cloud.retail.v2beta.Product] identifier, which
   * is the final component of [name][google.cloud.retail.v2beta.Product.name].
   * For example, this field is "id_1", if
   * [name][google.cloud.retail.v2beta.Product.name] is
   * `projects/* /locations/global/catalogs/default_catalog/branches/default_branch/products/id_1`.
   *
   * This field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [id](https://support.google.com/merchants/answer/6324405). Schema.org
   * property [Product.sku](https://schema.org/sku).
   */
  id: string;
  /**
   * Immutable. The type of the product. Default to
   * [Catalog.product_level_config.ingestion_product_type][google.cloud.retail.v2beta.ProductLevelConfig.ingestion_product_type]
   * if unset.
   */
  type: Product_Type;
  /**
   * Variant group identifier. Must be an
   * [id][google.cloud.retail.v2beta.Product.id], with the same parent branch
   * with this product. Otherwise, an error is thrown.
   *
   * For [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY]
   * [Product][google.cloud.retail.v2beta.Product]s, this field can only be
   * empty or set to the same value as
   * [id][google.cloud.retail.v2beta.Product.id].
   *
   * For VARIANT [Product][google.cloud.retail.v2beta.Product]s, this field
   * cannot be empty. A maximum of 2,000 products are allowed to share the same
   * [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY]
   * [Product][google.cloud.retail.v2beta.Product]. Otherwise, an
   * INVALID_ARGUMENT error is returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [item_group_id](https://support.google.com/merchants/answer/6324507).
   * Schema.org property
   * [Product.inProductGroupWithID](https://schema.org/inProductGroupWithID).
   */
  primaryProductId: string;
  /**
   * The [id][google.cloud.retail.v2beta.Product.id] of the collection members
   * when [type][google.cloud.retail.v2beta.Product.type] is
   * [Type.COLLECTION][google.cloud.retail.v2beta.Product.Type.COLLECTION].
   *
   * Non-existent product ids are allowed.
   * The [type][google.cloud.retail.v2beta.Product.type] of the members must be
   * either [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY] or
   * [Type.VARIANT][google.cloud.retail.v2beta.Product.Type.VARIANT] otherwise
   * an INVALID_ARGUMENT error is thrown. Should not set it for other types. A
   * maximum of 1000 values are allowed. Otherwise, an INVALID_ARGUMENT error is
   * return.
   */
  collectionMemberIds: string[];
  /**
   * The Global Trade Item Number (GTIN) of the product.
   *
   * This field must be a UTF-8 encoded string with a length limit of 128
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * This field must be a Unigram. Otherwise, an INVALID_ARGUMENT error is
   * returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [gtin](https://support.google.com/merchants/answer/6324461).
   * Schema.org property
   * [Product.isbn](https://schema.org/isbn),
   * [Product.gtin8](https://schema.org/gtin8),
   * [Product.gtin12](https://schema.org/gtin12),
   * [Product.gtin13](https://schema.org/gtin13), or
   * [Product.gtin14](https://schema.org/gtin14).
   *
   * If the value is not a valid GTIN, an INVALID_ARGUMENT error is returned.
   */
  gtin: string;
  /**
   * Product categories. This field is repeated for supporting one product
   * belonging to several parallel categories. Strongly recommended using the
   * full path for better search / recommendation quality.
   *
   * To represent full path of category, use '>' sign to separate different
   * hierarchies. If '>' is part of the category name, replace it with
   * other character(s).
   *
   * For example, if a shoes product belongs to both
   * ["Shoes & Accessories" -> "Shoes"] and
   * ["Sports & Fitness" -> "Athletic Clothing" -> "Shoes"], it could be
   * represented as:
   *
   *      "categories": [
   *        "Shoes & Accessories > Shoes",
   *        "Sports & Fitness > Athletic Clothing > Shoes"
   *      ]
   *
   * Must be set for
   * [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY]
   * [Product][google.cloud.retail.v2beta.Product] otherwise an INVALID_ARGUMENT
   * error is returned.
   *
   * At most 250 values are allowed per
   * [Product][google.cloud.retail.v2beta.Product] unless overridden through the
   * Google Cloud console. Empty values are not allowed. Each value must be a
   * UTF-8 encoded string with a length limit of 5,000 characters. Otherwise, an
   * INVALID_ARGUMENT error is returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [google_product_category][mc_google_product_category]. Schema.org property
   * [Product.category] (https://schema.org/category).
   *
   * [mc_google_product_category]:
   * https://support.google.com/merchants/answer/6324436
   */
  categories: string[];
  /**
   * Required. Product title.
   *
   * This field must be a UTF-8 encoded string with a length limit of 1,000
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [title](https://support.google.com/merchants/answer/6324415). Schema.org
   * property [Product.name](https://schema.org/name).
   */
  title: string;
  /**
   * The brands of the product.
   *
   * A maximum of 30 brands are allowed unless overridden through the Google
   * Cloud console. Each
   * brand must be a UTF-8 encoded string with a length limit of 1,000
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [brand](https://support.google.com/merchants/answer/6324351). Schema.org
   * property [Product.brand](https://schema.org/brand).
   */
  brands: string[];
  /**
   * Product description.
   *
   * This field must be a UTF-8 encoded string with a length limit of 5,000
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [description](https://support.google.com/merchants/answer/6324468).
   * Schema.org property [Product.description](https://schema.org/description).
   */
  description: string;
  /**
   * Language of the title/description and other string attributes. Use language
   * tags defined by [BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).
   *
   * For product prediction, this field is ignored and the model automatically
   * detects the text language. The
   * [Product][google.cloud.retail.v2beta.Product] can include text in different
   * languages, but duplicating [Product][google.cloud.retail.v2beta.Product]s
   * to provide text in multiple languages can result in degraded model
   * performance.
   *
   * For product search this field is in use. It defaults to "en-US" if unset.
   */
  languageCode: string;
  /**
   * Highly encouraged. Extra product attributes to be included. For example,
   * for products, this could include the store name, vendor, style, color, etc.
   * These are very strong signals for recommendation model, thus we highly
   * recommend providing the attributes here.
   *
   * Features that can take on one of a limited number of possible values. Two
   * types of features can be set are:
   *
   * Textual features. some examples would be the brand/maker of a product, or
   * country of a customer. Numerical features. Some examples would be the
   * height/weight of a product, or age of a customer.
   *
   * For example: `{ "vendor": {"text": ["vendor123", "vendor456"]},
   * "lengths_cm": {"numbers":[2.3, 15.4]}, "heights_cm": {"numbers":[8.1, 6.4]}
   * }`.
   *
   * This field needs to pass all below criteria, otherwise an INVALID_ARGUMENT
   * error is returned:
   *
   * * Max entries count: 200.
   * * The key must be a UTF-8 encoded string with a length limit of 128
   *   characters.
   * * For indexable attribute, the key must match the pattern:
   *   `[a-zA-Z0-9][a-zA-Z0-9_]*`. For example, `key0LikeThis` or
   *   `KEY_1_LIKE_THIS`.
   * * For text attributes, at most 400 values are allowed. Empty values are not
   *   allowed. Each value must be a non-empty UTF-8 encoded string with a
   *   length limit of 256 characters.
   * * For number attributes, at most 400 values are allowed.
   */
  attributes: { [key: string]: CustomAttribute };
  /**
   * Custom tags associated with the product.
   *
   * At most 250 values are allowed per
   * [Product][google.cloud.retail.v2beta.Product]. This value must be a UTF-8
   * encoded string with a length limit of 1,000 characters. Otherwise, an
   * INVALID_ARGUMENT error is returned.
   *
   * This tag can be used for filtering recommendation results by passing the
   * tag as part of the
   * [PredictRequest.filter][google.cloud.retail.v2beta.PredictRequest.filter].
   *
   * Corresponding properties: Google Merchant Center property
   * [custom_label_0â€“4](https://support.google.com/merchants/answer/6324473).
   */
  tags: string[];
  /**
   * Product price and cost information.
   *
   * Corresponding properties: Google Merchant Center property
   * [price](https://support.google.com/merchants/answer/6324371).
   */
  priceInfo:
    | PriceInfo
    | undefined;
  /** The rating of this product. */
  rating:
    | Rating
    | undefined;
  /**
   * The timestamp when this [Product][google.cloud.retail.v2beta.Product]
   * becomes available for
   * [SearchService.Search][google.cloud.retail.v2beta.SearchService.Search].
   * Note that this is only applicable to
   * [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY] and
   * [Type.COLLECTION][google.cloud.retail.v2beta.Product.Type.COLLECTION], and
   * ignored for
   * [Type.VARIANT][google.cloud.retail.v2beta.Product.Type.VARIANT].
   */
  availableTime:
    | Date
    | undefined;
  /**
   * The online availability of the
   * [Product][google.cloud.retail.v2beta.Product]. Default to
   * [Availability.IN_STOCK][google.cloud.retail.v2beta.Product.Availability.IN_STOCK].
   *
   * Corresponding properties: Google Merchant Center property
   * [availability](https://support.google.com/merchants/answer/6324448).
   * Schema.org property [Offer.availability](https://schema.org/availability).
   */
  availability: Product_Availability;
  /** The available quantity of the item. */
  availableQuantity:
    | number
    | undefined;
  /**
   * Fulfillment information, such as the store IDs for in-store pickup or
   * region IDs for different shipping methods.
   *
   * All the elements must have distinct
   * [FulfillmentInfo.type][google.cloud.retail.v2beta.FulfillmentInfo.type].
   * Otherwise, an INVALID_ARGUMENT error is returned.
   */
  fulfillmentInfo: FulfillmentInfo[];
  /**
   * Canonical URL directly linking to the product detail page.
   *
   * It is strongly recommended to provide a valid uri for the product,
   * otherwise the service performance could be significantly degraded.
   *
   * This field must be a UTF-8 encoded string with a length limit of 5,000
   * characters. Otherwise, an INVALID_ARGUMENT error is returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [link](https://support.google.com/merchants/answer/6324416). Schema.org
   * property [Offer.url](https://schema.org/url).
   */
  uri: string;
  /**
   * Product images for the product. We highly recommend putting the main
   * image first.
   *
   * A maximum of 300 images are allowed.
   *
   * Corresponding properties: Google Merchant Center property
   * [image_link](https://support.google.com/merchants/answer/6324350).
   * Schema.org property [Product.image](https://schema.org/image).
   */
  images: Image[];
  /**
   * The target group associated with a given audience (e.g. male, veterans,
   * car owners, musicians, etc.) of the product.
   */
  audience:
    | Audience
    | undefined;
  /**
   * The color of the product.
   *
   * Corresponding properties: Google Merchant Center property
   * [color](https://support.google.com/merchants/answer/6324487). Schema.org
   * property [Product.color](https://schema.org/color).
   */
  colorInfo:
    | ColorInfo
    | undefined;
  /**
   * The size of the product. To represent different size systems or size types,
   * consider using this format: [[[size_system:]size_type:]size_value].
   *
   * For example, in "US:MENS:M", "US" represents size system; "MENS" represents
   * size type; "M" represents size value. In "GIRLS:27", size system is empty;
   * "GIRLS" represents size type; "27" represents size value. In "32 inches",
   * both size system and size type are empty, while size value is "32 inches".
   *
   * A maximum of 20 values are allowed per
   * [Product][google.cloud.retail.v2beta.Product]. Each value must be a UTF-8
   * encoded string with a length limit of 128 characters. Otherwise, an
   * INVALID_ARGUMENT error is returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [size](https://support.google.com/merchants/answer/6324492),
   * [size_type](https://support.google.com/merchants/answer/6324497), and
   * [size_system](https://support.google.com/merchants/answer/6324502).
   * Schema.org property [Product.size](https://schema.org/size).
   */
  sizes: string[];
  /**
   * The material of the product. For example, "leather", "wooden".
   *
   * A maximum of 20 values are allowed. Each value must be a UTF-8 encoded
   * string with a length limit of 200 characters. Otherwise, an
   * INVALID_ARGUMENT error is returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [material](https://support.google.com/merchants/answer/6324410). Schema.org
   * property [Product.material](https://schema.org/material).
   */
  materials: string[];
  /**
   * The pattern or graphic print of the product. For example, "striped", "polka
   * dot", "paisley".
   *
   * A maximum of 20 values are allowed per
   * [Product][google.cloud.retail.v2beta.Product]. Each value must be a UTF-8
   * encoded string with a length limit of 128 characters. Otherwise, an
   * INVALID_ARGUMENT error is returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [pattern](https://support.google.com/merchants/answer/6324483). Schema.org
   * property [Product.pattern](https://schema.org/pattern).
   */
  patterns: string[];
  /**
   * The condition of the product. Strongly encouraged to use the standard
   * values: "new", "refurbished", "used".
   *
   * A maximum of 1 value is allowed per
   * [Product][google.cloud.retail.v2beta.Product]. Each value must be a UTF-8
   * encoded string with a length limit of 128 characters. Otherwise, an
   * INVALID_ARGUMENT error is returned.
   *
   * Corresponding properties: Google Merchant Center property
   * [condition](https://support.google.com/merchants/answer/6324469).
   * Schema.org property
   * [Offer.itemCondition](https://schema.org/itemCondition).
   */
  conditions: string[];
  /**
   * The promotions applied to the product. A maximum of 10 values are allowed
   * per [Product][google.cloud.retail.v2beta.Product]. Only
   * [Promotion.promotion_id][google.cloud.retail.v2beta.Promotion.promotion_id]
   * will be used, other fields will be ignored if set.
   */
  promotions: Promotion[];
  /**
   * The timestamp when the product is published by the retailer for the first
   * time, which indicates the freshness of the products. Note that this field
   * is different from
   * [available_time][google.cloud.retail.v2beta.Product.available_time], given
   * it purely describes product freshness regardless of when it is available on
   * search and recommendation.
   */
  publishTime:
    | Date
    | undefined;
  /**
   * Indicates which fields in the
   * [Product][google.cloud.retail.v2beta.Product]s are returned in
   * [SearchResponse][google.cloud.retail.v2beta.SearchResponse].
   *
   * Supported fields for all [type][google.cloud.retail.v2beta.Product.type]s:
   *
   * * [audience][google.cloud.retail.v2beta.Product.audience]
   * * [availability][google.cloud.retail.v2beta.Product.availability]
   * * [brands][google.cloud.retail.v2beta.Product.brands]
   * * [color_info][google.cloud.retail.v2beta.Product.color_info]
   * * [conditions][google.cloud.retail.v2beta.Product.conditions]
   * * [gtin][google.cloud.retail.v2beta.Product.gtin]
   * * [materials][google.cloud.retail.v2beta.Product.materials]
   * * [name][google.cloud.retail.v2beta.Product.name]
   * * [patterns][google.cloud.retail.v2beta.Product.patterns]
   * * [price_info][google.cloud.retail.v2beta.Product.price_info]
   * * [rating][google.cloud.retail.v2beta.Product.rating]
   * * [sizes][google.cloud.retail.v2beta.Product.sizes]
   * * [title][google.cloud.retail.v2beta.Product.title]
   * * [uri][google.cloud.retail.v2beta.Product.uri]
   *
   * Supported fields only for
   * [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY] and
   * [Type.COLLECTION][google.cloud.retail.v2beta.Product.Type.COLLECTION]:
   *
   * * [categories][google.cloud.retail.v2beta.Product.categories]
   * * [description][google.cloud.retail.v2beta.Product.description]
   * * [images][google.cloud.retail.v2beta.Product.images]
   *
   * Supported fields only for
   * [Type.VARIANT][google.cloud.retail.v2beta.Product.Type.VARIANT]:
   *
   * * Only the first image in
   * [images][google.cloud.retail.v2beta.Product.images]
   *
   * To mark [attributes][google.cloud.retail.v2beta.Product.attributes] as
   * retrievable, include paths of the form "attributes.key" where "key" is the
   * key of a custom attribute, as specified in
   * [attributes][google.cloud.retail.v2beta.Product.attributes].
   *
   * For [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY] and
   * [Type.COLLECTION][google.cloud.retail.v2beta.Product.Type.COLLECTION], the
   * following fields are always returned in
   * [SearchResponse][google.cloud.retail.v2beta.SearchResponse] by default:
   *
   * * [name][google.cloud.retail.v2beta.Product.name]
   *
   * For [Type.VARIANT][google.cloud.retail.v2beta.Product.Type.VARIANT], the
   * following fields are always returned in by default:
   *
   * * [name][google.cloud.retail.v2beta.Product.name]
   * * [color_info][google.cloud.retail.v2beta.Product.color_info]
   *
   * The maximum number of paths is 30. Otherwise, an INVALID_ARGUMENT error is
   * returned.
   *
   * Note: Returning more fields in
   * [SearchResponse][google.cloud.retail.v2beta.SearchResponse] can increase
   * response payload size and serving latency.
   *
   * This field is deprecated. Use the retrievable site-wide control instead.
   *
   * @deprecated
   */
  retrievableFields:
    | string[]
    | undefined;
  /**
   * Output only. Product variants grouped together on primary product which
   * share similar product attributes. It's automatically grouped by
   * [primary_product_id][google.cloud.retail.v2beta.Product.primary_product_id]
   * for all the product variants. Only populated for
   * [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY]
   * [Product][google.cloud.retail.v2beta.Product]s.
   *
   * Note: This field is OUTPUT_ONLY for
   * [ProductService.GetProduct][google.cloud.retail.v2beta.ProductService.GetProduct].
   * Do not set this field in API requests.
   */
  variants: Product[];
  /**
   * Output only. A list of local inventories specific to different places.
   *
   * This field can be managed by
   * [ProductService.AddLocalInventories][google.cloud.retail.v2beta.ProductService.AddLocalInventories]
   * and
   * [ProductService.RemoveLocalInventories][google.cloud.retail.v2beta.ProductService.RemoveLocalInventories]
   * APIs if fine-grained, high-volume updates are necessary.
   */
  localInventories: LocalInventory[];
}

/** The type of this product. */
export enum Product_Type {
  /**
   * TYPE_UNSPECIFIED - Default value. Default to
   * [Catalog.product_level_config.ingestion_product_type][google.cloud.retail.v2beta.ProductLevelConfig.ingestion_product_type]
   * if unset.
   */
  TYPE_UNSPECIFIED = 0,
  /**
   * PRIMARY - The primary type.
   *
   * As the primary unit for predicting, indexing and search serving, a
   * [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY]
   * [Product][google.cloud.retail.v2beta.Product] is grouped with multiple
   * [Type.VARIANT][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product]s.
   */
  PRIMARY = 1,
  /**
   * VARIANT - The variant type.
   *
   * [Type.VARIANT][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product]s usually share some common
   * attributes on the same
   * [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY]
   * [Product][google.cloud.retail.v2beta.Product]s, but they have variant
   * attributes like different colors, sizes and prices, etc.
   */
  VARIANT = 2,
  /**
   * COLLECTION - The collection type. Collection products are bundled
   * [Type.PRIMARY][google.cloud.retail.v2beta.Product.Type.PRIMARY]
   * [Product][google.cloud.retail.v2beta.Product]s or
   * [Type.VARIANT][google.cloud.retail.v2beta.Product.Type.VARIANT]
   * [Product][google.cloud.retail.v2beta.Product]s that are sold together,
   * such as a jewelry set with necklaces, earrings and rings, etc.
   */
  COLLECTION = 3,
  UNRECOGNIZED = -1,
}

export function product_TypeFromJSON(object: any): Product_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Product_Type.TYPE_UNSPECIFIED;
    case 1:
    case "PRIMARY":
      return Product_Type.PRIMARY;
    case 2:
    case "VARIANT":
      return Product_Type.VARIANT;
    case 3:
    case "COLLECTION":
      return Product_Type.COLLECTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Product_Type.UNRECOGNIZED;
  }
}

export function product_TypeToJSON(object: Product_Type): string {
  switch (object) {
    case Product_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Product_Type.PRIMARY:
      return "PRIMARY";
    case Product_Type.VARIANT:
      return "VARIANT";
    case Product_Type.COLLECTION:
      return "COLLECTION";
    case Product_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Product availability. If this field is unspecified, the product is
 * assumed to be in stock.
 */
export enum Product_Availability {
  /**
   * AVAILABILITY_UNSPECIFIED - Default product availability. Default to
   * [Availability.IN_STOCK][google.cloud.retail.v2beta.Product.Availability.IN_STOCK]
   * if unset.
   */
  AVAILABILITY_UNSPECIFIED = 0,
  /** IN_STOCK - Product in stock. */
  IN_STOCK = 1,
  /** OUT_OF_STOCK - Product out of stock. */
  OUT_OF_STOCK = 2,
  /** PREORDER - Product that is in pre-order state. */
  PREORDER = 3,
  /** BACKORDER - Product that is back-ordered (i.e. temporarily out of stock). */
  BACKORDER = 4,
  UNRECOGNIZED = -1,
}

export function product_AvailabilityFromJSON(object: any): Product_Availability {
  switch (object) {
    case 0:
    case "AVAILABILITY_UNSPECIFIED":
      return Product_Availability.AVAILABILITY_UNSPECIFIED;
    case 1:
    case "IN_STOCK":
      return Product_Availability.IN_STOCK;
    case 2:
    case "OUT_OF_STOCK":
      return Product_Availability.OUT_OF_STOCK;
    case 3:
    case "PREORDER":
      return Product_Availability.PREORDER;
    case 4:
    case "BACKORDER":
      return Product_Availability.BACKORDER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Product_Availability.UNRECOGNIZED;
  }
}

export function product_AvailabilityToJSON(object: Product_Availability): string {
  switch (object) {
    case Product_Availability.AVAILABILITY_UNSPECIFIED:
      return "AVAILABILITY_UNSPECIFIED";
    case Product_Availability.IN_STOCK:
      return "IN_STOCK";
    case Product_Availability.OUT_OF_STOCK:
      return "OUT_OF_STOCK";
    case Product_Availability.PREORDER:
      return "PREORDER";
    case Product_Availability.BACKORDER:
      return "BACKORDER";
    case Product_Availability.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Product_AttributesEntry {
  key: string;
  value: CustomAttribute | undefined;
}

function createBaseProduct(): Product {
  return {
    expireTime: undefined,
    ttl: undefined,
    name: "",
    id: "",
    type: 0,
    primaryProductId: "",
    collectionMemberIds: [],
    gtin: "",
    categories: [],
    title: "",
    brands: [],
    description: "",
    languageCode: "",
    attributes: {},
    tags: [],
    priceInfo: undefined,
    rating: undefined,
    availableTime: undefined,
    availability: 0,
    availableQuantity: undefined,
    fulfillmentInfo: [],
    uri: "",
    images: [],
    audience: undefined,
    colorInfo: undefined,
    sizes: [],
    materials: [],
    patterns: [],
    conditions: [],
    promotions: [],
    publishTime: undefined,
    retrievableFields: undefined,
    variants: [],
    localInventories: [],
  };
}

export const Product: MessageFns<Product> = {
  encode(message: Product, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expireTime !== undefined) {
      Timestamp.encode(toTimestamp(message.expireTime), writer.uint32(130).fork()).join();
    }
    if (message.ttl !== undefined) {
      Duration.encode(message.ttl, writer.uint32(138).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.primaryProductId !== "") {
      writer.uint32(34).string(message.primaryProductId);
    }
    for (const v of message.collectionMemberIds) {
      writer.uint32(42).string(v!);
    }
    if (message.gtin !== "") {
      writer.uint32(50).string(message.gtin);
    }
    for (const v of message.categories) {
      writer.uint32(58).string(v!);
    }
    if (message.title !== "") {
      writer.uint32(66).string(message.title);
    }
    for (const v of message.brands) {
      writer.uint32(74).string(v!);
    }
    if (message.description !== "") {
      writer.uint32(82).string(message.description);
    }
    if (message.languageCode !== "") {
      writer.uint32(90).string(message.languageCode);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      Product_AttributesEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    for (const v of message.tags) {
      writer.uint32(106).string(v!);
    }
    if (message.priceInfo !== undefined) {
      PriceInfo.encode(message.priceInfo, writer.uint32(114).fork()).join();
    }
    if (message.rating !== undefined) {
      Rating.encode(message.rating, writer.uint32(122).fork()).join();
    }
    if (message.availableTime !== undefined) {
      Timestamp.encode(toTimestamp(message.availableTime), writer.uint32(146).fork()).join();
    }
    if (message.availability !== 0) {
      writer.uint32(152).int32(message.availability);
    }
    if (message.availableQuantity !== undefined) {
      Int32Value.encode({ value: message.availableQuantity! }, writer.uint32(162).fork()).join();
    }
    for (const v of message.fulfillmentInfo) {
      FulfillmentInfo.encode(v!, writer.uint32(170).fork()).join();
    }
    if (message.uri !== "") {
      writer.uint32(178).string(message.uri);
    }
    for (const v of message.images) {
      Image.encode(v!, writer.uint32(186).fork()).join();
    }
    if (message.audience !== undefined) {
      Audience.encode(message.audience, writer.uint32(194).fork()).join();
    }
    if (message.colorInfo !== undefined) {
      ColorInfo.encode(message.colorInfo, writer.uint32(202).fork()).join();
    }
    for (const v of message.sizes) {
      writer.uint32(210).string(v!);
    }
    for (const v of message.materials) {
      writer.uint32(218).string(v!);
    }
    for (const v of message.patterns) {
      writer.uint32(226).string(v!);
    }
    for (const v of message.conditions) {
      writer.uint32(234).string(v!);
    }
    for (const v of message.promotions) {
      Promotion.encode(v!, writer.uint32(274).fork()).join();
    }
    if (message.publishTime !== undefined) {
      Timestamp.encode(toTimestamp(message.publishTime), writer.uint32(266).fork()).join();
    }
    if (message.retrievableFields !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.retrievableFields), writer.uint32(242).fork()).join();
    }
    for (const v of message.variants) {
      Product.encode(v!, writer.uint32(250).fork()).join();
    }
    for (const v of message.localInventories) {
      LocalInventory.encode(v!, writer.uint32(282).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 16:
          if (tag !== 130) {
            break;
          }

          message.expireTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.ttl = Duration.decode(reader, reader.uint32());
          continue;
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.primaryProductId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.collectionMemberIds.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.gtin = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.categories.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.title = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.brands.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.description = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.languageCode = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          const entry12 = Product_AttributesEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.attributes[entry12.key] = entry12.value;
          }
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.priceInfo = PriceInfo.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.rating = Rating.decode(reader, reader.uint32());
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.availableTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 152) {
            break;
          }

          message.availability = reader.int32() as any;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.availableQuantity = Int32Value.decode(reader, reader.uint32()).value;
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.fulfillmentInfo.push(FulfillmentInfo.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.uri = reader.string();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.images.push(Image.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.audience = Audience.decode(reader, reader.uint32());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.colorInfo = ColorInfo.decode(reader, reader.uint32());
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.sizes.push(reader.string());
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.materials.push(reader.string());
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.patterns.push(reader.string());
          continue;
        case 29:
          if (tag !== 234) {
            break;
          }

          message.conditions.push(reader.string());
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.promotions.push(Promotion.decode(reader, reader.uint32()));
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.publishTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 30:
          if (tag !== 242) {
            break;
          }

          message.retrievableFields = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.variants.push(Product.decode(reader, reader.uint32()));
          continue;
        case 35:
          if (tag !== 282) {
            break;
          }

          message.localInventories.push(LocalInventory.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Product {
    return {
      expireTime: isSet(object.expireTime) ? fromJsonTimestamp(object.expireTime) : undefined,
      ttl: isSet(object.ttl) ? Duration.fromJSON(object.ttl) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? product_TypeFromJSON(object.type) : 0,
      primaryProductId: isSet(object.primaryProductId) ? globalThis.String(object.primaryProductId) : "",
      collectionMemberIds: globalThis.Array.isArray(object?.collectionMemberIds)
        ? object.collectionMemberIds.map((e: any) => globalThis.String(e))
        : [],
      gtin: isSet(object.gtin) ? globalThis.String(object.gtin) : "",
      categories: globalThis.Array.isArray(object?.categories)
        ? object.categories.map((e: any) => globalThis.String(e))
        : [],
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      brands: globalThis.Array.isArray(object?.brands) ? object.brands.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      languageCode: isSet(object.languageCode) ? globalThis.String(object.languageCode) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: CustomAttribute }>((acc, [key, value]) => {
          acc[key] = CustomAttribute.fromJSON(value);
          return acc;
        }, {})
        : {},
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      priceInfo: isSet(object.priceInfo) ? PriceInfo.fromJSON(object.priceInfo) : undefined,
      rating: isSet(object.rating) ? Rating.fromJSON(object.rating) : undefined,
      availableTime: isSet(object.availableTime) ? fromJsonTimestamp(object.availableTime) : undefined,
      availability: isSet(object.availability) ? product_AvailabilityFromJSON(object.availability) : 0,
      availableQuantity: isSet(object.availableQuantity) ? Number(object.availableQuantity) : undefined,
      fulfillmentInfo: globalThis.Array.isArray(object?.fulfillmentInfo)
        ? object.fulfillmentInfo.map((e: any) => FulfillmentInfo.fromJSON(e))
        : [],
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      images: globalThis.Array.isArray(object?.images)
        ? object.images.map((e: any) => Image.fromJSON(e))
        : [],
      audience: isSet(object.audience) ? Audience.fromJSON(object.audience) : undefined,
      colorInfo: isSet(object.colorInfo) ? ColorInfo.fromJSON(object.colorInfo) : undefined,
      sizes: globalThis.Array.isArray(object?.sizes) ? object.sizes.map((e: any) => globalThis.String(e)) : [],
      materials: globalThis.Array.isArray(object?.materials)
        ? object.materials.map((e: any) => globalThis.String(e))
        : [],
      patterns: globalThis.Array.isArray(object?.patterns)
        ? object.patterns.map((e: any) => globalThis.String(e))
        : [],
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => globalThis.String(e))
        : [],
      promotions: globalThis.Array.isArray(object?.promotions)
        ? object.promotions.map((e: any) => Promotion.fromJSON(e))
        : [],
      publishTime: isSet(object.publishTime) ? fromJsonTimestamp(object.publishTime) : undefined,
      retrievableFields: isSet(object.retrievableFields)
        ? FieldMask.unwrap(FieldMask.fromJSON(object.retrievableFields))
        : undefined,
      variants: globalThis.Array.isArray(object?.variants)
        ? object.variants.map((e: any) => Product.fromJSON(e))
        : [],
      localInventories: globalThis.Array.isArray(object?.localInventories)
        ? object.localInventories.map((e: any) => LocalInventory.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Product): unknown {
    const obj: any = {};
    if (message.expireTime !== undefined) {
      obj.expireTime = message.expireTime.toISOString();
    }
    if (message.ttl !== undefined) {
      obj.ttl = Duration.toJSON(message.ttl);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = product_TypeToJSON(message.type);
    }
    if (message.primaryProductId !== "") {
      obj.primaryProductId = message.primaryProductId;
    }
    if (message.collectionMemberIds?.length) {
      obj.collectionMemberIds = message.collectionMemberIds;
    }
    if (message.gtin !== "") {
      obj.gtin = message.gtin;
    }
    if (message.categories?.length) {
      obj.categories = message.categories;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.brands?.length) {
      obj.brands = message.brands;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.languageCode !== "") {
      obj.languageCode = message.languageCode;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = CustomAttribute.toJSON(v);
        });
      }
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.priceInfo !== undefined) {
      obj.priceInfo = PriceInfo.toJSON(message.priceInfo);
    }
    if (message.rating !== undefined) {
      obj.rating = Rating.toJSON(message.rating);
    }
    if (message.availableTime !== undefined) {
      obj.availableTime = message.availableTime.toISOString();
    }
    if (message.availability !== 0) {
      obj.availability = product_AvailabilityToJSON(message.availability);
    }
    if (message.availableQuantity !== undefined) {
      obj.availableQuantity = message.availableQuantity;
    }
    if (message.fulfillmentInfo?.length) {
      obj.fulfillmentInfo = message.fulfillmentInfo.map((e) => FulfillmentInfo.toJSON(e));
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.images?.length) {
      obj.images = message.images.map((e) => Image.toJSON(e));
    }
    if (message.audience !== undefined) {
      obj.audience = Audience.toJSON(message.audience);
    }
    if (message.colorInfo !== undefined) {
      obj.colorInfo = ColorInfo.toJSON(message.colorInfo);
    }
    if (message.sizes?.length) {
      obj.sizes = message.sizes;
    }
    if (message.materials?.length) {
      obj.materials = message.materials;
    }
    if (message.patterns?.length) {
      obj.patterns = message.patterns;
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions;
    }
    if (message.promotions?.length) {
      obj.promotions = message.promotions.map((e) => Promotion.toJSON(e));
    }
    if (message.publishTime !== undefined) {
      obj.publishTime = message.publishTime.toISOString();
    }
    if (message.retrievableFields !== undefined) {
      obj.retrievableFields = FieldMask.toJSON(FieldMask.wrap(message.retrievableFields));
    }
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => Product.toJSON(e));
    }
    if (message.localInventories?.length) {
      obj.localInventories = message.localInventories.map((e) => LocalInventory.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Product>): Product {
    return Product.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Product>): Product {
    const message = createBaseProduct();
    message.expireTime = object.expireTime ?? undefined;
    message.ttl = (object.ttl !== undefined && object.ttl !== null) ? Duration.fromPartial(object.ttl) : undefined;
    message.name = object.name ?? "";
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.primaryProductId = object.primaryProductId ?? "";
    message.collectionMemberIds = object.collectionMemberIds?.map((e) => e) || [];
    message.gtin = object.gtin ?? "";
    message.categories = object.categories?.map((e) => e) || [];
    message.title = object.title ?? "";
    message.brands = object.brands?.map((e) => e) || [];
    message.description = object.description ?? "";
    message.languageCode = object.languageCode ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: CustomAttribute }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = CustomAttribute.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.tags = object.tags?.map((e) => e) || [];
    message.priceInfo = (object.priceInfo !== undefined && object.priceInfo !== null)
      ? PriceInfo.fromPartial(object.priceInfo)
      : undefined;
    message.rating = (object.rating !== undefined && object.rating !== null)
      ? Rating.fromPartial(object.rating)
      : undefined;
    message.availableTime = object.availableTime ?? undefined;
    message.availability = object.availability ?? 0;
    message.availableQuantity = object.availableQuantity ?? undefined;
    message.fulfillmentInfo = object.fulfillmentInfo?.map((e) => FulfillmentInfo.fromPartial(e)) || [];
    message.uri = object.uri ?? "";
    message.images = object.images?.map((e) => Image.fromPartial(e)) || [];
    message.audience = (object.audience !== undefined && object.audience !== null)
      ? Audience.fromPartial(object.audience)
      : undefined;
    message.colorInfo = (object.colorInfo !== undefined && object.colorInfo !== null)
      ? ColorInfo.fromPartial(object.colorInfo)
      : undefined;
    message.sizes = object.sizes?.map((e) => e) || [];
    message.materials = object.materials?.map((e) => e) || [];
    message.patterns = object.patterns?.map((e) => e) || [];
    message.conditions = object.conditions?.map((e) => e) || [];
    message.promotions = object.promotions?.map((e) => Promotion.fromPartial(e)) || [];
    message.publishTime = object.publishTime ?? undefined;
    message.retrievableFields = object.retrievableFields ?? undefined;
    message.variants = object.variants?.map((e) => Product.fromPartial(e)) || [];
    message.localInventories = object.localInventories?.map((e) => LocalInventory.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProduct_AttributesEntry(): Product_AttributesEntry {
  return { key: "", value: undefined };
}

export const Product_AttributesEntry: MessageFns<Product_AttributesEntry> = {
  encode(message: Product_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CustomAttribute.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = CustomAttribute.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Product_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CustomAttribute.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Product_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CustomAttribute.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Product_AttributesEntry>): Product_AttributesEntry {
    return Product_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Product_AttributesEntry>): Product_AttributesEntry {
    const message = createBaseProduct_AttributesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CustomAttribute.fromPartial(object.value)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
