// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/gdchardwaremanagement/v1alpha/resources.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { DateMessage } from "../../../type/date.js";
import { TimeZone } from "../../../type/datetime.js";
import { DayOfWeek, dayOfWeekFromJSON, dayOfWeekToJSON } from "../../../type/dayofweek.js";
import { PostalAddress } from "../../../type/postal_address.js";
import { TimeOfDay } from "../../../type/timeofday.js";

export const protobufPackage = "google.cloud.gdchardwaremanagement.v1alpha";

/** The power supply options. */
export enum PowerSupply {
  /** POWER_SUPPLY_UNSPECIFIED - Power supply is unspecified. */
  POWER_SUPPLY_UNSPECIFIED = 0,
  /** POWER_SUPPLY_AC - AC power supply. */
  POWER_SUPPLY_AC = 1,
  /** POWER_SUPPLY_DC - DC power supply. */
  POWER_SUPPLY_DC = 2,
  UNRECOGNIZED = -1,
}

export function powerSupplyFromJSON(object: any): PowerSupply {
  switch (object) {
    case 0:
    case "POWER_SUPPLY_UNSPECIFIED":
      return PowerSupply.POWER_SUPPLY_UNSPECIFIED;
    case 1:
    case "POWER_SUPPLY_AC":
      return PowerSupply.POWER_SUPPLY_AC;
    case 2:
    case "POWER_SUPPLY_DC":
      return PowerSupply.POWER_SUPPLY_DC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PowerSupply.UNRECOGNIZED;
  }
}

export function powerSupplyToJSON(object: PowerSupply): string {
  switch (object) {
    case PowerSupply.POWER_SUPPLY_UNSPECIFIED:
      return "POWER_SUPPLY_UNSPECIFIED";
    case PowerSupply.POWER_SUPPLY_AC:
      return "POWER_SUPPLY_AC";
    case PowerSupply.POWER_SUPPLY_DC:
      return "POWER_SUPPLY_DC";
    case PowerSupply.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Entity is used to denote an organization or party. */
export enum Entity {
  /** ENTITY_UNSPECIFIED - Entity is unspecified. */
  ENTITY_UNSPECIFIED = 0,
  /** GOOGLE - Google. */
  GOOGLE = 1,
  /** CUSTOMER - Customer. */
  CUSTOMER = 2,
  /** VENDOR - Vendor. */
  VENDOR = 3,
  UNRECOGNIZED = -1,
}

export function entityFromJSON(object: any): Entity {
  switch (object) {
    case 0:
    case "ENTITY_UNSPECIFIED":
      return Entity.ENTITY_UNSPECIFIED;
    case 1:
    case "GOOGLE":
      return Entity.GOOGLE;
    case 2:
    case "CUSTOMER":
      return Entity.CUSTOMER;
    case 3:
    case "VENDOR":
      return Entity.VENDOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Entity.UNRECOGNIZED;
  }
}

export function entityToJSON(object: Entity): string {
  switch (object) {
    case Entity.ENTITY_UNSPECIFIED:
      return "ENTITY_UNSPECIFIED";
    case Entity.GOOGLE:
      return "GOOGLE";
    case Entity.CUSTOMER:
      return "CUSTOMER";
    case Entity.VENDOR:
      return "VENDOR";
    case Entity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An order for GDC hardware. */
export interface Order {
  /**
   * Identifier. Name of this order.
   * Format: `projects/{project}/locations/{location}/orders/{order}`
   */
  name: string;
  /** Optional. Display name of this order. */
  displayName: string;
  /** Output only. Time when this order was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when this order was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. Labels associated with this order as key value pairs.
   * For more information about labels, see [Create and manage
   * labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels).
   */
  labels: { [key: string]: string };
  /**
   * Output only. State of this order. On order creation, state will be set to
   * DRAFT.
   */
  state: Order_State;
  /** Required. Customer contact information. */
  organizationContact:
    | OrganizationContact
    | undefined;
  /**
   * Optional. Customer specified workloads of interest targeted by this order.
   * This must contain <= 20 elements and the length of each element must be <=
   * 50 characters.
   */
  targetWorkloads: string[];
  /**
   * Required. Information about the customer's motivation for this order. The
   * length of this field must be <= 1000 characters.
   */
  customerMotivation: string;
  /**
   * Required. Customer specified deadline by when this order should be
   * fulfilled.
   */
  fulfillmentTime:
    | Date
    | undefined;
  /**
   * Required. [Unicode CLDR](http://cldr.unicode.org/) region code where this
   * order will be deployed. For a list of valid CLDR region codes, see the
   * [Language Subtag
   * Registry](https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry).
   */
  regionCode: string;
  /** Output only. Link to the order form. */
  orderFormUri: string;
  /** Output only. Type of this Order. */
  type: Order_Type;
  /**
   * Output only. Time when the order was submitted. Is auto-populated to the
   * current time when an order is submitted.
   */
  submitTime:
    | Date
    | undefined;
  /** Required. The Google Cloud Billing ID to be charged for this order. */
  billingId: string;
  /**
   * Optional. Existing hardware to be removed as part of this order.
   * Note: any hardware removed will be recycled unless otherwise agreed.
   */
  existingHardware: HardwareLocation[];
}

/** Valid states of an order. */
export enum Order_State {
  /** STATE_UNSPECIFIED - State of the order is unspecified. */
  STATE_UNSPECIFIED = 0,
  /** DRAFT - Order is being drafted by the customer and has not been submitted yet. */
  DRAFT = 1,
  /** SUBMITTED - Order has been submitted to Google. */
  SUBMITTED = 2,
  /**
   * INFO_COMPLETE - All information required from the customer for fulfillment of the order
   * is complete.
   */
  INFO_COMPLETE = 12,
  /** ACCEPTED - Order has been accepted by Google. */
  ACCEPTED = 3,
  /** ADDITIONAL_INFO_NEEDED - Order needs more information from the customer. */
  ADDITIONAL_INFO_NEEDED = 4,
  /** BUILDING - Google has initiated building hardware for the order. */
  BUILDING = 5,
  /** SHIPPING - The hardware has been built and is being shipped. */
  SHIPPING = 6,
  /** INSTALLING - The hardware is being installed. */
  INSTALLING = 7,
  /**
   * FAILED - An error occurred in processing the order and customer intervention is
   * required.
   */
  FAILED = 8,
  /**
   * PARTIALLY_COMPLETED - Order has been partially completed i.e., some hardware have been
   * delivered and installed.
   */
  PARTIALLY_COMPLETED = 9,
  /** COMPLETED - Order has been completed. */
  COMPLETED = 10,
  /** CANCELLED - Order has been cancelled. */
  CANCELLED = 11,
  UNRECOGNIZED = -1,
}

export function order_StateFromJSON(object: any): Order_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Order_State.STATE_UNSPECIFIED;
    case 1:
    case "DRAFT":
      return Order_State.DRAFT;
    case 2:
    case "SUBMITTED":
      return Order_State.SUBMITTED;
    case 12:
    case "INFO_COMPLETE":
      return Order_State.INFO_COMPLETE;
    case 3:
    case "ACCEPTED":
      return Order_State.ACCEPTED;
    case 4:
    case "ADDITIONAL_INFO_NEEDED":
      return Order_State.ADDITIONAL_INFO_NEEDED;
    case 5:
    case "BUILDING":
      return Order_State.BUILDING;
    case 6:
    case "SHIPPING":
      return Order_State.SHIPPING;
    case 7:
    case "INSTALLING":
      return Order_State.INSTALLING;
    case 8:
    case "FAILED":
      return Order_State.FAILED;
    case 9:
    case "PARTIALLY_COMPLETED":
      return Order_State.PARTIALLY_COMPLETED;
    case 10:
    case "COMPLETED":
      return Order_State.COMPLETED;
    case 11:
    case "CANCELLED":
      return Order_State.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Order_State.UNRECOGNIZED;
  }
}

export function order_StateToJSON(object: Order_State): string {
  switch (object) {
    case Order_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Order_State.DRAFT:
      return "DRAFT";
    case Order_State.SUBMITTED:
      return "SUBMITTED";
    case Order_State.INFO_COMPLETE:
      return "INFO_COMPLETE";
    case Order_State.ACCEPTED:
      return "ACCEPTED";
    case Order_State.ADDITIONAL_INFO_NEEDED:
      return "ADDITIONAL_INFO_NEEDED";
    case Order_State.BUILDING:
      return "BUILDING";
    case Order_State.SHIPPING:
      return "SHIPPING";
    case Order_State.INSTALLING:
      return "INSTALLING";
    case Order_State.FAILED:
      return "FAILED";
    case Order_State.PARTIALLY_COMPLETED:
      return "PARTIALLY_COMPLETED";
    case Order_State.COMPLETED:
      return "COMPLETED";
    case Order_State.CANCELLED:
      return "CANCELLED";
    case Order_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Valid types of an Order. */
export enum Order_Type {
  /** TYPE_UNSPECIFIED - Type of the order is unspecified. */
  TYPE_UNSPECIFIED = 0,
  /** PAID - Paid by the customer. */
  PAID = 1,
  /** POC - Proof of concept for the customer. */
  POC = 2,
  UNRECOGNIZED = -1,
}

export function order_TypeFromJSON(object: any): Order_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Order_Type.TYPE_UNSPECIFIED;
    case 1:
    case "PAID":
      return Order_Type.PAID;
    case 2:
    case "POC":
      return Order_Type.POC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Order_Type.UNRECOGNIZED;
  }
}

export function order_TypeToJSON(object: Order_Type): string {
  switch (object) {
    case Order_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Order_Type.PAID:
      return "PAID";
    case Order_Type.POC:
      return "POC";
    case Order_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Order_LabelsEntry {
  key: string;
  value: string;
}

/** A physical site where hardware will be installed. */
export interface Site {
  /**
   * Identifier. Name of the site.
   * Format: `projects/{project}/locations/{location}/sites/{site}`
   */
  name: string;
  /** Optional. Display name of this Site. */
  displayName: string;
  /** Optional. Description of this Site. */
  description: string;
  /** Output only. Time when this site was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when this site was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. Labels associated with this site as key value pairs.
   * For more information about labels, see [Create and manage
   * labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels).
   */
  labels: { [key: string]: string };
  /** Required. Contact information for this site. */
  organizationContact:
    | OrganizationContact
    | undefined;
  /**
   * Required. A URL to the Google Maps address location of the site.
   * An example value is `https://goo.gl/maps/xxxxxxxxx`.
   */
  googleMapsPinUri: string;
  /**
   * Optional. The time periods when the site is accessible.
   * If this field is empty, the site is accessible at all times.
   *
   * This field is used by Google to schedule the initial installation as well
   * as any later hardware maintenance. You may update this at any time. For
   * example, if the initial installation is requested during off-hours but
   * maintenance should be performed during regular business hours, you should
   * update the access times after initial installation is complete.
   */
  accessTimes: TimePeriod[];
  /**
   * Optional. Any additional notes for this Site. Please include information
   * about:
   *  - security or access restrictions
   *  - any regulations affecting the technicians visiting the site
   *  - any special process or approval required to move the equipment
   *  - whether a representative will be available during site visits
   */
  notes: string;
  /**
   * Optional. Customer defined identifier for this Site. This can be used to
   * identify the site in the customer's own systems.
   */
  customerSiteId: string;
}

export interface Site_LabelsEntry {
  key: string;
  value: string;
}

/**
 * A group of hardware that is part of the same order, has the same SKU, and is
 * delivered to the same site.
 */
export interface HardwareGroup {
  /**
   * Identifier. Name of this hardware group.
   * Format:
   * `projects/{project}/locations/{location}/orders/{order}/hardwareGroups/{hardware_group}`
   */
  name: string;
  /** Output only. Time when this hardware group was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when this hardware group was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. Labels associated with this hardware group as key value pairs.
   * For more information about labels, see [Create and manage
   * labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels).
   */
  labels: { [key: string]: string };
  /** Required. Number of hardware in this HardwareGroup. */
  hardwareCount: number;
  /** Required. Configuration for hardware in this HardwareGroup. */
  config:
    | HardwareConfig
    | undefined;
  /**
   * Required. Name of the site where the hardware in this HardwareGroup will be
   * delivered.
   * Format: `projects/{project}/locations/{location}/sites/{site}`
   */
  site: string;
  /** Output only. Current state of this HardwareGroup. */
  state: HardwareGroup_State;
  /**
   * Optional. Name of the zone that the hardware in this HardwareGroup belongs
   * to. Format: `projects/{project}/locations/{location}/zones/{zone}`
   */
  zone: string;
  /**
   * Optional. Requested installation date for the hardware in this
   * HardwareGroup. Filled in by the customer.
   */
  requestedInstallationDate: DateMessage | undefined;
}

/** Valid states of a HardwareGroup. */
export enum HardwareGroup_State {
  /** STATE_UNSPECIFIED - State of the HardwareGroup is unspecified. */
  STATE_UNSPECIFIED = 0,
  /** ADDITIONAL_INFO_NEEDED - More information is required from the customer to make progress. */
  ADDITIONAL_INFO_NEEDED = 1,
  /** BUILDING - Google has initiated building hardware for this HardwareGroup. */
  BUILDING = 2,
  /** SHIPPING - The hardware has been built and is being shipped. */
  SHIPPING = 3,
  /** INSTALLING - The hardware is being installed. */
  INSTALLING = 4,
  /** PARTIALLY_INSTALLED - Some hardware in the HardwareGroup have been installed. */
  PARTIALLY_INSTALLED = 5,
  /** INSTALLED - All hardware in the HardwareGroup have been installed. */
  INSTALLED = 6,
  /** FAILED - An error occurred and customer intervention is required. */
  FAILED = 7,
  UNRECOGNIZED = -1,
}

export function hardwareGroup_StateFromJSON(object: any): HardwareGroup_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return HardwareGroup_State.STATE_UNSPECIFIED;
    case 1:
    case "ADDITIONAL_INFO_NEEDED":
      return HardwareGroup_State.ADDITIONAL_INFO_NEEDED;
    case 2:
    case "BUILDING":
      return HardwareGroup_State.BUILDING;
    case 3:
    case "SHIPPING":
      return HardwareGroup_State.SHIPPING;
    case 4:
    case "INSTALLING":
      return HardwareGroup_State.INSTALLING;
    case 5:
    case "PARTIALLY_INSTALLED":
      return HardwareGroup_State.PARTIALLY_INSTALLED;
    case 6:
    case "INSTALLED":
      return HardwareGroup_State.INSTALLED;
    case 7:
    case "FAILED":
      return HardwareGroup_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HardwareGroup_State.UNRECOGNIZED;
  }
}

export function hardwareGroup_StateToJSON(object: HardwareGroup_State): string {
  switch (object) {
    case HardwareGroup_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case HardwareGroup_State.ADDITIONAL_INFO_NEEDED:
      return "ADDITIONAL_INFO_NEEDED";
    case HardwareGroup_State.BUILDING:
      return "BUILDING";
    case HardwareGroup_State.SHIPPING:
      return "SHIPPING";
    case HardwareGroup_State.INSTALLING:
      return "INSTALLING";
    case HardwareGroup_State.PARTIALLY_INSTALLED:
      return "PARTIALLY_INSTALLED";
    case HardwareGroup_State.INSTALLED:
      return "INSTALLED";
    case HardwareGroup_State.FAILED:
      return "FAILED";
    case HardwareGroup_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface HardwareGroup_LabelsEntry {
  key: string;
  value: string;
}

/** An instance of hardware installed at a site. */
export interface Hardware {
  /**
   * Identifier. Name of this hardware.
   * Format: `projects/{project}/locations/{location}/hardware/{hardware}`
   */
  name: string;
  /** Optional. Display name for this hardware. */
  displayName: string;
  /** Output only. Time when this hardware was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when this hardware was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. Labels associated with this hardware as key value pairs.
   * For more information about labels, see [Create and manage
   * labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels).
   */
  labels: { [key: string]: string };
  /**
   * Required. Name of the order that this hardware belongs to.
   * Format: `projects/{project}/locations/{location}/orders/{order}`
   */
  order: string;
  /**
   * Output only. Name for the hardware group that this hardware belongs to.
   * Format:
   * `projects/{project}/locations/{location}/orders/{order}/hardwareGroups/{hardware_group}`
   */
  hardwareGroup: string;
  /**
   * Required. Name for the site that this hardware belongs to.
   * Format: `projects/{project}/locations/{location}/sites/{site}`
   */
  site: string;
  /** Output only. Current state for this hardware. */
  state: Hardware_State;
  /**
   * Output only. Link to the Customer Intake Questionnaire (CIQ) sheet for this
   * Hardware.
   */
  ciqUri: string;
  /** Required. Configuration for this hardware. */
  config:
    | HardwareConfig
    | undefined;
  /** Output only. Estimated installation date for this hardware. */
  estimatedInstallationDate:
    | DateMessage
    | undefined;
  /** Optional. Physical properties of this hardware. */
  physicalInfo:
    | HardwarePhysicalInfo
    | undefined;
  /** Optional. Information for installation of this hardware. */
  installationInfo:
    | HardwareInstallationInfo
    | undefined;
  /**
   * Required. Name for the zone that this hardware belongs to.
   * Format: `projects/{project}/locations/{location}/zones/{zone}`
   */
  zone: string;
  /**
   * Optional. Requested installation date for this hardware. This is
   * auto-populated when the order is accepted, if the hardware's HardwareGroup
   * specifies this. It can also be filled in by the customer.
   */
  requestedInstallationDate:
    | DateMessage
    | undefined;
  /**
   * Output only. Actual installation date for this hardware. Filled in by
   * Google.
   */
  actualInstallationDate: DateMessage | undefined;
}

/** Valid states for hardware. */
export enum Hardware_State {
  /** STATE_UNSPECIFIED - State of the Hardware is unspecified. */
  STATE_UNSPECIFIED = 0,
  /** ADDITIONAL_INFO_NEEDED - More information is required from the customer to make progress. */
  ADDITIONAL_INFO_NEEDED = 1,
  /** BUILDING - Google has initiated building hardware for this Hardware. */
  BUILDING = 2,
  /** SHIPPING - The hardware has been built and is being shipped. */
  SHIPPING = 3,
  /** INSTALLING - The hardware is being installed. */
  INSTALLING = 4,
  /** INSTALLED - The hardware has been installed. */
  INSTALLED = 5,
  /** FAILED - An error occurred and customer intervention is required. */
  FAILED = 6,
  UNRECOGNIZED = -1,
}

export function hardware_StateFromJSON(object: any): Hardware_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Hardware_State.STATE_UNSPECIFIED;
    case 1:
    case "ADDITIONAL_INFO_NEEDED":
      return Hardware_State.ADDITIONAL_INFO_NEEDED;
    case 2:
    case "BUILDING":
      return Hardware_State.BUILDING;
    case 3:
    case "SHIPPING":
      return Hardware_State.SHIPPING;
    case 4:
    case "INSTALLING":
      return Hardware_State.INSTALLING;
    case 5:
    case "INSTALLED":
      return Hardware_State.INSTALLED;
    case 6:
    case "FAILED":
      return Hardware_State.FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Hardware_State.UNRECOGNIZED;
  }
}

export function hardware_StateToJSON(object: Hardware_State): string {
  switch (object) {
    case Hardware_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Hardware_State.ADDITIONAL_INFO_NEEDED:
      return "ADDITIONAL_INFO_NEEDED";
    case Hardware_State.BUILDING:
      return "BUILDING";
    case Hardware_State.SHIPPING:
      return "SHIPPING";
    case Hardware_State.INSTALLING:
      return "INSTALLING";
    case Hardware_State.INSTALLED:
      return "INSTALLED";
    case Hardware_State.FAILED:
      return "FAILED";
    case Hardware_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Hardware_LabelsEntry {
  key: string;
  value: string;
}

/** A comment on an order. */
export interface Comment {
  /**
   * Identifier. Name of this comment.
   * Format:
   * `projects/{project}/locations/{location}/orders/{order}/comments/{comment}`
   */
  name: string;
  /** Output only. Time when this comment was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Optional. Labels associated with this comment as key value pairs.
   * For more information about labels, see [Create and manage
   * labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels).
   */
  labels: { [key: string]: string };
  /**
   * Output only. Username of the author of this comment. This is auto-populated
   * from the credentials used during creation of the comment.
   */
  author: string;
  /**
   * Required. Text of this comment. The length of text must be <= 1000
   * characters.
   */
  text: string;
  /**
   * Output only. Timestamp of the first time this comment was viewed by the
   * customer. If the comment wasn't viewed then this timestamp will be unset.
   */
  customerViewedTime:
    | Date
    | undefined;
  /** Output only. The entity the author belongs to. */
  authorEntity: Entity;
}

export interface Comment_LabelsEntry {
  key: string;
  value: string;
}

/** A log entry of a change made to an order. */
export interface ChangeLogEntry {
  /**
   * Identifier. Name of this change log entry.
   * Format:
   * `projects/{project}/locations/{location}/orders/{order}/changeLogEntries/{change_log_entry}`
   */
  name: string;
  /** Output only. Time when this change log entry was created. */
  createTime:
    | Date
    | undefined;
  /**
   * Optional. Labels associated with this change log entry as key value pairs.
   * For more information about labels, see [Create and manage
   * labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels).
   */
  labels: { [key: string]: string };
  /** Output only. Content of this log entry. */
  log: string;
}

export interface ChangeLogEntry_LabelsEntry {
  key: string;
  value: string;
}

/** A stock keeping unit (SKU) of GDC hardware. */
export interface Sku {
  /**
   * Identifier. Name of this SKU.
   * Format: `projects/{project}/locations/{location}/skus/{sku}`
   */
  name: string;
  /** Output only. Display name of this SKU. */
  displayName: string;
  /** Output only. Time when this SKU was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when this SKU was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Output only. Configuration for this SKU. */
  config:
    | SkuConfig
    | undefined;
  /**
   * Output only. Available instances of this SKU. This field should be used for
   * checking availability of a SKU.
   */
  instances: SkuInstance[];
  /** Output only. Description of this SKU. */
  description: string;
  /**
   * Output only. The SKU revision ID.
   * A new revision is created whenever `config` is updated. The format is an
   * 8-character hexadecimal string.
   */
  revisionId: string;
  /**
   * Output only. Flag to indicate whether or not this revision is active. Only
   * an active revision can be used in a new Order.
   */
  isActive: boolean;
  /** Output only. Type of this SKU. */
  type: Sku_Type;
  /** Output only. The vCPU count associated with this SKU. */
  vcpuCount: number;
}

/** Valid types of a SKU. */
export enum Sku_Type {
  /** TYPE_UNSPECIFIED - Type of the SKU is unspecified. This is not an allowed value. */
  TYPE_UNSPECIFIED = 0,
  /** RACK - Rack SKU. */
  RACK = 1,
  /** SERVER - Server SKU. */
  SERVER = 2,
  UNRECOGNIZED = -1,
}

export function sku_TypeFromJSON(object: any): Sku_Type {
  switch (object) {
    case 0:
    case "TYPE_UNSPECIFIED":
      return Sku_Type.TYPE_UNSPECIFIED;
    case 1:
    case "RACK":
      return Sku_Type.RACK;
    case 2:
    case "SERVER":
      return Sku_Type.SERVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Sku_Type.UNRECOGNIZED;
  }
}

export function sku_TypeToJSON(object: Sku_Type): string {
  switch (object) {
    case Sku_Type.TYPE_UNSPECIFIED:
      return "TYPE_UNSPECIFIED";
    case Sku_Type.RACK:
      return "RACK";
    case Sku_Type.SERVER:
      return "SERVER";
    case Sku_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A zone holding a set of hardware. */
export interface Zone {
  /**
   * Identifier. Name of this zone.
   * Format: `projects/{project}/locations/{location}/zones/{zone}`
   */
  name: string;
  /** Output only. Time when this zone was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. Time when this zone was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. Labels associated with this zone as key value pairs.
   * For more information about labels, see [Create and manage
   * labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels).
   */
  labels: { [key: string]: string };
  /** Optional. Human friendly display name of this zone. */
  displayName: string;
  /** Output only. Current state for this zone. */
  state: Zone_State;
  /** Required. The points of contact. */
  contacts: Contact[];
  /**
   * Output only. Link to the Customer Intake Questionnaire (CIQ) sheet for this
   * zone.
   */
  ciqUri: string;
  /** Optional. Networking configuration for this zone. */
  networkConfig:
    | ZoneNetworkConfig
    | undefined;
  /** Output only. Globally unique identifier generated for this Edge Zone. */
  globallyUniqueId: string;
  /** Output only. Subscription configurations for this zone. */
  subscriptionConfigs: SubscriptionConfig[];
}

/** Valid states for a zone. */
export enum Zone_State {
  /** STATE_UNSPECIFIED - State of the Zone is unspecified. */
  STATE_UNSPECIFIED = 0,
  /** ADDITIONAL_INFO_NEEDED - More information is required from the customer to make progress. */
  ADDITIONAL_INFO_NEEDED = 1,
  /** PREPARING - Google is preparing the Zone. */
  PREPARING = 2,
  /** READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS - Factory turnup has succeeded. */
  READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS = 5,
  /** READY_FOR_SITE_TURNUP - The Zone is ready for site turnup. */
  READY_FOR_SITE_TURNUP = 6,
  /** CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED - The Zone failed in factory turnup checks. */
  CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED = 7,
  /** ACTIVE - The Zone is available to use. */
  ACTIVE = 3,
  /** CANCELLED - The Zone has been cancelled. */
  CANCELLED = 4,
  UNRECOGNIZED = -1,
}

export function zone_StateFromJSON(object: any): Zone_State {
  switch (object) {
    case 0:
    case "STATE_UNSPECIFIED":
      return Zone_State.STATE_UNSPECIFIED;
    case 1:
    case "ADDITIONAL_INFO_NEEDED":
      return Zone_State.ADDITIONAL_INFO_NEEDED;
    case 2:
    case "PREPARING":
      return Zone_State.PREPARING;
    case 5:
    case "READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS":
      return Zone_State.READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS;
    case 6:
    case "READY_FOR_SITE_TURNUP":
      return Zone_State.READY_FOR_SITE_TURNUP;
    case 7:
    case "CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED":
      return Zone_State.CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED;
    case 3:
    case "ACTIVE":
      return Zone_State.ACTIVE;
    case 4:
    case "CANCELLED":
      return Zone_State.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Zone_State.UNRECOGNIZED;
  }
}

export function zone_StateToJSON(object: Zone_State): string {
  switch (object) {
    case Zone_State.STATE_UNSPECIFIED:
      return "STATE_UNSPECIFIED";
    case Zone_State.ADDITIONAL_INFO_NEEDED:
      return "ADDITIONAL_INFO_NEEDED";
    case Zone_State.PREPARING:
      return "PREPARING";
    case Zone_State.READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS:
      return "READY_FOR_CUSTOMER_FACTORY_TURNUP_CHECKS";
    case Zone_State.READY_FOR_SITE_TURNUP:
      return "READY_FOR_SITE_TURNUP";
    case Zone_State.CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED:
      return "CUSTOMER_FACTORY_TURNUP_CHECKS_FAILED";
    case Zone_State.ACTIVE:
      return "ACTIVE";
    case Zone_State.CANCELLED:
      return "CANCELLED";
    case Zone_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Zone_LabelsEntry {
  key: string;
  value: string;
}

/** Contact information of the customer organization. */
export interface OrganizationContact {
  /** Required. The organization's address. */
  address:
    | PostalAddress
    | undefined;
  /** Optional. The organization's email. */
  email: string;
  /** Optional. The organization's phone number. */
  phone: string;
  /**
   * Required. The individual points of contact in the organization at this
   * location.
   */
  contacts: Contact[];
}

/** Contact details of a point of contact. */
export interface Contact {
  /** Required. Given name of the contact. */
  givenName: string;
  /** Optional. Family name of the contact. */
  familyName: string;
  /** Required. Email of the contact. */
  email: string;
  /** Required. Phone number of the contact. */
  phone: string;
  /** Optional. Time zone of the contact. */
  timeZone:
    | TimeZone
    | undefined;
  /**
   * Optional. The time periods when the contact is reachable.
   * If this field is empty, the contact is reachable at all times.
   */
  reachableTimes: TimePeriod[];
}

/** Configuration for GDC hardware. */
export interface HardwareConfig {
  /**
   * Required. Reference to the SKU for this hardware. This can point to a
   * specific SKU revision in the form of `resource_name@revision_id` as defined
   * in [AIP-162](https://google.aip.dev/162). If no revision_id is specified,
   * it refers to the latest revision.
   */
  sku: string;
  /** Required. Power supply type for this hardware. */
  powerSupply: PowerSupply;
  /** Optional. Subscription duration for the hardware in months. */
  subscriptionDurationMonths: number;
}

/** Configuration for a SKU. */
export interface SkuConfig {
  /** Information about CPU configuration. */
  cpu: string;
  /** Information about GPU configuration. */
  gpu: string;
  /** Information about RAM configuration. */
  ram: string;
  /** Information about storage configuration. */
  storage: string;
}

/** A specific instance of the SKU. */
export interface SkuInstance {
  /**
   * The [Unicode CLDR](https://cldr.unicode.org) region code where this
   * instance is available.
   */
  regionCode: string;
  /** Power supply type for this instance. */
  powerSupply: PowerSupply;
  /**
   * Reference to the corresponding SKU in the Cloud Billing API.
   * The estimated price information can be retrieved using that API.
   * Format: `services/{service}/skus/{sku}`
   */
  billingSku: string;
  /**
   * Reference to the corresponding SKU per vCPU in the Cloud Billing API.
   * The estimated price information can be retrieved using that API.
   * Format: `services/{service}/skus/{sku}`
   */
  billingSkuPerVcpu: string;
  /** Subscription duration for the hardware in months. */
  subscriptionDurationMonths: number;
}

/** Physical properties of a hardware. */
export interface HardwarePhysicalInfo {
  /** Required. The power receptacle type. */
  powerReceptacle: HardwarePhysicalInfo_PowerReceptacleType;
  /** Required. Type of the uplink network connection. */
  networkUplink: HardwarePhysicalInfo_NetworkUplinkType;
  /** Required. Voltage of the power supply. */
  voltage: HardwarePhysicalInfo_Voltage;
  /** Required. Amperes of the power supply. */
  amperes: HardwarePhysicalInfo_Amperes;
}

/** Valid power receptacle types. */
export enum HardwarePhysicalInfo_PowerReceptacleType {
  /** POWER_RECEPTACLE_TYPE_UNSPECIFIED - Facility plug type is unspecified. */
  POWER_RECEPTACLE_TYPE_UNSPECIFIED = 0,
  /** NEMA_5_15 - NEMA 5-15. */
  NEMA_5_15 = 1,
  /** C_13 - C13. */
  C_13 = 2,
  /** STANDARD_EU - Standard european receptacle. */
  STANDARD_EU = 3,
  UNRECOGNIZED = -1,
}

export function hardwarePhysicalInfo_PowerReceptacleTypeFromJSON(
  object: any,
): HardwarePhysicalInfo_PowerReceptacleType {
  switch (object) {
    case 0:
    case "POWER_RECEPTACLE_TYPE_UNSPECIFIED":
      return HardwarePhysicalInfo_PowerReceptacleType.POWER_RECEPTACLE_TYPE_UNSPECIFIED;
    case 1:
    case "NEMA_5_15":
      return HardwarePhysicalInfo_PowerReceptacleType.NEMA_5_15;
    case 2:
    case "C_13":
      return HardwarePhysicalInfo_PowerReceptacleType.C_13;
    case 3:
    case "STANDARD_EU":
      return HardwarePhysicalInfo_PowerReceptacleType.STANDARD_EU;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HardwarePhysicalInfo_PowerReceptacleType.UNRECOGNIZED;
  }
}

export function hardwarePhysicalInfo_PowerReceptacleTypeToJSON(
  object: HardwarePhysicalInfo_PowerReceptacleType,
): string {
  switch (object) {
    case HardwarePhysicalInfo_PowerReceptacleType.POWER_RECEPTACLE_TYPE_UNSPECIFIED:
      return "POWER_RECEPTACLE_TYPE_UNSPECIFIED";
    case HardwarePhysicalInfo_PowerReceptacleType.NEMA_5_15:
      return "NEMA_5_15";
    case HardwarePhysicalInfo_PowerReceptacleType.C_13:
      return "C_13";
    case HardwarePhysicalInfo_PowerReceptacleType.STANDARD_EU:
      return "STANDARD_EU";
    case HardwarePhysicalInfo_PowerReceptacleType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Valid network uplink types. */
export enum HardwarePhysicalInfo_NetworkUplinkType {
  /** NETWORK_UPLINK_TYPE_UNSPECIFIED - Network uplink type is unspecified. */
  NETWORK_UPLINK_TYPE_UNSPECIFIED = 0,
  /** RJ_45 - RJ-45. */
  RJ_45 = 1,
  UNRECOGNIZED = -1,
}

export function hardwarePhysicalInfo_NetworkUplinkTypeFromJSON(object: any): HardwarePhysicalInfo_NetworkUplinkType {
  switch (object) {
    case 0:
    case "NETWORK_UPLINK_TYPE_UNSPECIFIED":
      return HardwarePhysicalInfo_NetworkUplinkType.NETWORK_UPLINK_TYPE_UNSPECIFIED;
    case 1:
    case "RJ_45":
      return HardwarePhysicalInfo_NetworkUplinkType.RJ_45;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HardwarePhysicalInfo_NetworkUplinkType.UNRECOGNIZED;
  }
}

export function hardwarePhysicalInfo_NetworkUplinkTypeToJSON(object: HardwarePhysicalInfo_NetworkUplinkType): string {
  switch (object) {
    case HardwarePhysicalInfo_NetworkUplinkType.NETWORK_UPLINK_TYPE_UNSPECIFIED:
      return "NETWORK_UPLINK_TYPE_UNSPECIFIED";
    case HardwarePhysicalInfo_NetworkUplinkType.RJ_45:
      return "RJ_45";
    case HardwarePhysicalInfo_NetworkUplinkType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Valid voltage values. */
export enum HardwarePhysicalInfo_Voltage {
  /** VOLTAGE_UNSPECIFIED - Voltage is unspecified. */
  VOLTAGE_UNSPECIFIED = 0,
  /** VOLTAGE_110 - 120V. */
  VOLTAGE_110 = 1,
  /** VOLTAGE_220 - 220V. */
  VOLTAGE_220 = 3,
  UNRECOGNIZED = -1,
}

export function hardwarePhysicalInfo_VoltageFromJSON(object: any): HardwarePhysicalInfo_Voltage {
  switch (object) {
    case 0:
    case "VOLTAGE_UNSPECIFIED":
      return HardwarePhysicalInfo_Voltage.VOLTAGE_UNSPECIFIED;
    case 1:
    case "VOLTAGE_110":
      return HardwarePhysicalInfo_Voltage.VOLTAGE_110;
    case 3:
    case "VOLTAGE_220":
      return HardwarePhysicalInfo_Voltage.VOLTAGE_220;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HardwarePhysicalInfo_Voltage.UNRECOGNIZED;
  }
}

export function hardwarePhysicalInfo_VoltageToJSON(object: HardwarePhysicalInfo_Voltage): string {
  switch (object) {
    case HardwarePhysicalInfo_Voltage.VOLTAGE_UNSPECIFIED:
      return "VOLTAGE_UNSPECIFIED";
    case HardwarePhysicalInfo_Voltage.VOLTAGE_110:
      return "VOLTAGE_110";
    case HardwarePhysicalInfo_Voltage.VOLTAGE_220:
      return "VOLTAGE_220";
    case HardwarePhysicalInfo_Voltage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Valid amperes values. */
export enum HardwarePhysicalInfo_Amperes {
  /** AMPERES_UNSPECIFIED - Amperes is unspecified. */
  AMPERES_UNSPECIFIED = 0,
  /** AMPERES_15 - 15A. */
  AMPERES_15 = 1,
  UNRECOGNIZED = -1,
}

export function hardwarePhysicalInfo_AmperesFromJSON(object: any): HardwarePhysicalInfo_Amperes {
  switch (object) {
    case 0:
    case "AMPERES_UNSPECIFIED":
      return HardwarePhysicalInfo_Amperes.AMPERES_UNSPECIFIED;
    case 1:
    case "AMPERES_15":
      return HardwarePhysicalInfo_Amperes.AMPERES_15;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HardwarePhysicalInfo_Amperes.UNRECOGNIZED;
  }
}

export function hardwarePhysicalInfo_AmperesToJSON(object: HardwarePhysicalInfo_Amperes): string {
  switch (object) {
    case HardwarePhysicalInfo_Amperes.AMPERES_UNSPECIFIED:
      return "AMPERES_UNSPECIFIED";
    case HardwarePhysicalInfo_Amperes.AMPERES_15:
      return "AMPERES_15";
    case HardwarePhysicalInfo_Amperes.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Information for installation of a Hardware. */
export interface HardwareInstallationInfo {
  /**
   * Optional. Location of the rack in the site e.g. Floor 2, Room 201, Row 7,
   * Rack 3.
   */
  rackLocation: string;
  /** Required. Distance from the power outlet in meters. */
  powerDistanceMeters: number;
  /** Required. Distance from the network switch in meters. */
  switchDistanceMeters: number;
  /** Required. Dimensions of the rack unit. */
  rackUnitDimensions:
    | Dimensions
    | undefined;
  /** Required. Rack space allocated for the hardware. */
  rackSpace:
    | RackSpace
    | undefined;
  /** Required. Type of the rack. */
  rackType: HardwareInstallationInfo_RackType;
}

/** Valid rack types. */
export enum HardwareInstallationInfo_RackType {
  /** RACK_TYPE_UNSPECIFIED - Rack type is unspecified. */
  RACK_TYPE_UNSPECIFIED = 0,
  /** TWO_POST - Two post rack. */
  TWO_POST = 1,
  /** FOUR_POST - Four post rack. */
  FOUR_POST = 2,
  UNRECOGNIZED = -1,
}

export function hardwareInstallationInfo_RackTypeFromJSON(object: any): HardwareInstallationInfo_RackType {
  switch (object) {
    case 0:
    case "RACK_TYPE_UNSPECIFIED":
      return HardwareInstallationInfo_RackType.RACK_TYPE_UNSPECIFIED;
    case 1:
    case "TWO_POST":
      return HardwareInstallationInfo_RackType.TWO_POST;
    case 2:
    case "FOUR_POST":
      return HardwareInstallationInfo_RackType.FOUR_POST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HardwareInstallationInfo_RackType.UNRECOGNIZED;
  }
}

export function hardwareInstallationInfo_RackTypeToJSON(object: HardwareInstallationInfo_RackType): string {
  switch (object) {
    case HardwareInstallationInfo_RackType.RACK_TYPE_UNSPECIFIED:
      return "RACK_TYPE_UNSPECIFIED";
    case HardwareInstallationInfo_RackType.TWO_POST:
      return "TWO_POST";
    case HardwareInstallationInfo_RackType.FOUR_POST:
      return "FOUR_POST";
    case HardwareInstallationInfo_RackType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Networking configuration for a zone. */
export interface ZoneNetworkConfig {
  /**
   * Required. An IPv4 address block for machine management.
   * Should be a private RFC1918 or public CIDR block large enough to allocate
   * at least one address per machine in the Zone.
   * Should be in `management_ipv4_subnet`, and disjoint with other address
   * ranges.
   */
  machineMgmtIpv4Range: string;
  /**
   * Required. An IPv4 address block for kubernetes nodes.
   * Should be a private RFC1918 or public CIDR block large enough to allocate
   * at least one address per machine in the Zone.
   * Should be in `kubernetes_ipv4_subnet`, and disjoint with other address
   * ranges.
   */
  kubernetesNodeIpv4Range: string;
  /**
   * Required. An IPv4 address block for kubernetes control plane.
   * Should be a private RFC1918 or public CIDR block large enough to allocate
   * at least one address per cluster in the Zone.
   * Should be in `kubernetes_ipv4_subnet`, and disjoint with other address
   * ranges.
   */
  kubernetesControlPlaneIpv4Range: string;
  /** Required. An IPv4 subnet for the management network. */
  managementIpv4Subnet:
    | Subnet
    | undefined;
  /**
   * Optional. An IPv4 subnet for the kubernetes network.
   * If unspecified, the kubernetes subnet will be the same as the management
   * subnet.
   */
  kubernetesIpv4Subnet: Subnet | undefined;
}

/** Represents a subnet. */
export interface Subnet {
  /** Required. Address range for this subnet in CIDR notation. */
  addressRange: string;
  /** Required. Default gateway for this subnet. */
  defaultGatewayIpAddress: string;
}

/** Represents a time period in a week. */
export interface TimePeriod {
  /** Required. The start of the time period. */
  startTime:
    | TimeOfDay
    | undefined;
  /** Required. The end of the time period. */
  endTime:
    | TimeOfDay
    | undefined;
  /** Required. The days of the week that the time period is active. */
  days: DayOfWeek[];
}

/** Represents the dimensions of an object. */
export interface Dimensions {
  /** Required. Width in inches. */
  widthInches: number;
  /** Required. Height in inches. */
  heightInches: number;
  /** Required. Depth in inches. */
  depthInches: number;
}

/** Represents contiguous space in a rack. */
export interface RackSpace {
  /** Required. First rack unit of the rack space (inclusive). */
  startRackUnit: number;
  /** Required. Last rack unit of the rack space (inclusive). */
  endRackUnit: number;
}

/** Represents the location of one or many hardware. */
export interface HardwareLocation {
  /**
   * Required. Name of the site where the hardware are present.
   * Format: `projects/{project}/locations/{location}/sites/{site}`
   */
  site: string;
  /**
   * Required. Location of the rack in the site e.g. Floor 2, Room 201, Row 7,
   * Rack 3.
   */
  rackLocation: string;
  /**
   * Optional. Spaces occupied by the hardware in the rack.
   * If unset, this location is assumed to be the entire rack.
   */
  rackSpace: RackSpace[];
}

/** A message to store a subscription configuration. */
export interface SubscriptionConfig {
  /** Output only. The unique identifier of the subscription. */
  subscriptionId: string;
  /**
   * Output only. The Google Cloud Billing ID that the subscription is created
   * under.
   */
  billingId: string;
  /** Output only. The current state of the subscription. */
  state: SubscriptionConfig_SubscriptionState;
}

/** Enum to represent the state of the subscription. */
export enum SubscriptionConfig_SubscriptionState {
  /** SUBSCRIPTION_STATE_UNSPECIFIED - State is unspecified. */
  SUBSCRIPTION_STATE_UNSPECIFIED = 0,
  /**
   * ACTIVE - Active state means that the subscription has been created successfully
   * and billing is happening.
   */
  ACTIVE = 1,
  /**
   * INACTIVE - Inactive means that the subscription has been created successfully, but
   * billing has not started yet.
   */
  INACTIVE = 2,
  /** ERROR - The subscription is in an erroneous state. */
  ERROR = 3,
  /**
   * FAILED_TO_RETRIEVE - The subscription state failed to be retrieved. This may be a transient
   * issue. The user should retry the request.
   */
  FAILED_TO_RETRIEVE = 4,
  /** COMPLETED - The subscription has been completed, because it has reached the end date. */
  COMPLETED = 5,
  UNRECOGNIZED = -1,
}

export function subscriptionConfig_SubscriptionStateFromJSON(object: any): SubscriptionConfig_SubscriptionState {
  switch (object) {
    case 0:
    case "SUBSCRIPTION_STATE_UNSPECIFIED":
      return SubscriptionConfig_SubscriptionState.SUBSCRIPTION_STATE_UNSPECIFIED;
    case 1:
    case "ACTIVE":
      return SubscriptionConfig_SubscriptionState.ACTIVE;
    case 2:
    case "INACTIVE":
      return SubscriptionConfig_SubscriptionState.INACTIVE;
    case 3:
    case "ERROR":
      return SubscriptionConfig_SubscriptionState.ERROR;
    case 4:
    case "FAILED_TO_RETRIEVE":
      return SubscriptionConfig_SubscriptionState.FAILED_TO_RETRIEVE;
    case 5:
    case "COMPLETED":
      return SubscriptionConfig_SubscriptionState.COMPLETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubscriptionConfig_SubscriptionState.UNRECOGNIZED;
  }
}

export function subscriptionConfig_SubscriptionStateToJSON(object: SubscriptionConfig_SubscriptionState): string {
  switch (object) {
    case SubscriptionConfig_SubscriptionState.SUBSCRIPTION_STATE_UNSPECIFIED:
      return "SUBSCRIPTION_STATE_UNSPECIFIED";
    case SubscriptionConfig_SubscriptionState.ACTIVE:
      return "ACTIVE";
    case SubscriptionConfig_SubscriptionState.INACTIVE:
      return "INACTIVE";
    case SubscriptionConfig_SubscriptionState.ERROR:
      return "ERROR";
    case SubscriptionConfig_SubscriptionState.FAILED_TO_RETRIEVE:
      return "FAILED_TO_RETRIEVE";
    case SubscriptionConfig_SubscriptionState.COMPLETED:
      return "COMPLETED";
    case SubscriptionConfig_SubscriptionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseOrder(): Order {
  return {
    name: "",
    displayName: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    state: 0,
    organizationContact: undefined,
    targetWorkloads: [],
    customerMotivation: "",
    fulfillmentTime: undefined,
    regionCode: "",
    orderFormUri: "",
    type: 0,
    submitTime: undefined,
    billingId: "",
    existingHardware: [],
  };
}

export const Order: MessageFns<Order> = {
  encode(message: Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(106).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Order_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    if (message.organizationContact !== undefined) {
      OrganizationContact.encode(message.organizationContact, writer.uint32(50).fork()).join();
    }
    for (const v of message.targetWorkloads) {
      writer.uint32(58).string(v!);
    }
    if (message.customerMotivation !== "") {
      writer.uint32(66).string(message.customerMotivation);
    }
    if (message.fulfillmentTime !== undefined) {
      Timestamp.encode(toTimestamp(message.fulfillmentTime), writer.uint32(74).fork()).join();
    }
    if (message.regionCode !== "") {
      writer.uint32(82).string(message.regionCode);
    }
    if (message.orderFormUri !== "") {
      writer.uint32(90).string(message.orderFormUri);
    }
    if (message.type !== 0) {
      writer.uint32(96).int32(message.type);
    }
    if (message.submitTime !== undefined) {
      Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(114).fork()).join();
    }
    if (message.billingId !== "") {
      writer.uint32(122).string(message.billingId);
    }
    for (const v of message.existingHardware) {
      HardwareLocation.encode(v!, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Order_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.organizationContact = OrganizationContact.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.targetWorkloads.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.customerMotivation = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.fulfillmentTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.orderFormUri = reader.string();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.submitTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.billingId = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.existingHardware.push(HardwareLocation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      state: isSet(object.state) ? order_StateFromJSON(object.state) : 0,
      organizationContact: isSet(object.organizationContact)
        ? OrganizationContact.fromJSON(object.organizationContact)
        : undefined,
      targetWorkloads: globalThis.Array.isArray(object?.targetWorkloads)
        ? object.targetWorkloads.map((e: any) => globalThis.String(e))
        : [],
      customerMotivation: isSet(object.customerMotivation) ? globalThis.String(object.customerMotivation) : "",
      fulfillmentTime: isSet(object.fulfillmentTime) ? fromJsonTimestamp(object.fulfillmentTime) : undefined,
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      orderFormUri: isSet(object.orderFormUri) ? globalThis.String(object.orderFormUri) : "",
      type: isSet(object.type) ? order_TypeFromJSON(object.type) : 0,
      submitTime: isSet(object.submitTime) ? fromJsonTimestamp(object.submitTime) : undefined,
      billingId: isSet(object.billingId) ? globalThis.String(object.billingId) : "",
      existingHardware: globalThis.Array.isArray(object?.existingHardware)
        ? object.existingHardware.map((e: any) => HardwareLocation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Order): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.state !== 0) {
      obj.state = order_StateToJSON(message.state);
    }
    if (message.organizationContact !== undefined) {
      obj.organizationContact = OrganizationContact.toJSON(message.organizationContact);
    }
    if (message.targetWorkloads?.length) {
      obj.targetWorkloads = message.targetWorkloads;
    }
    if (message.customerMotivation !== "") {
      obj.customerMotivation = message.customerMotivation;
    }
    if (message.fulfillmentTime !== undefined) {
      obj.fulfillmentTime = message.fulfillmentTime.toISOString();
    }
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.orderFormUri !== "") {
      obj.orderFormUri = message.orderFormUri;
    }
    if (message.type !== 0) {
      obj.type = order_TypeToJSON(message.type);
    }
    if (message.submitTime !== undefined) {
      obj.submitTime = message.submitTime.toISOString();
    }
    if (message.billingId !== "") {
      obj.billingId = message.billingId;
    }
    if (message.existingHardware?.length) {
      obj.existingHardware = message.existingHardware.map((e) => HardwareLocation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Order>): Order {
    return Order.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Order>): Order {
    const message = createBaseOrder();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.state = object.state ?? 0;
    message.organizationContact = (object.organizationContact !== undefined && object.organizationContact !== null)
      ? OrganizationContact.fromPartial(object.organizationContact)
      : undefined;
    message.targetWorkloads = object.targetWorkloads?.map((e) => e) || [];
    message.customerMotivation = object.customerMotivation ?? "";
    message.fulfillmentTime = object.fulfillmentTime ?? undefined;
    message.regionCode = object.regionCode ?? "";
    message.orderFormUri = object.orderFormUri ?? "";
    message.type = object.type ?? 0;
    message.submitTime = object.submitTime ?? undefined;
    message.billingId = object.billingId ?? "";
    message.existingHardware = object.existingHardware?.map((e) => HardwareLocation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrder_LabelsEntry(): Order_LabelsEntry {
  return { key: "", value: "" };
}

export const Order_LabelsEntry: MessageFns<Order_LabelsEntry> = {
  encode(message: Order_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Order_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Order_LabelsEntry>): Order_LabelsEntry {
    return Order_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Order_LabelsEntry>): Order_LabelsEntry {
    const message = createBaseOrder_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSite(): Site {
  return {
    name: "",
    displayName: "",
    description: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    organizationContact: undefined,
    googleMapsPinUri: "",
    accessTimes: [],
    notes: "",
    customerSiteId: "",
  };
}

export const Site: MessageFns<Site> = {
  encode(message: Site, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(194).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(202).string(message.description);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Site_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.organizationContact !== undefined) {
      OrganizationContact.encode(message.organizationContact, writer.uint32(42).fork()).join();
    }
    if (message.googleMapsPinUri !== "") {
      writer.uint32(50).string(message.googleMapsPinUri);
    }
    for (const v of message.accessTimes) {
      TimePeriod.encode(v!, writer.uint32(210).fork()).join();
    }
    if (message.notes !== "") {
      writer.uint32(218).string(message.notes);
    }
    if (message.customerSiteId !== "") {
      writer.uint32(226).string(message.customerSiteId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Site {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.description = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Site_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.organizationContact = OrganizationContact.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.googleMapsPinUri = reader.string();
          continue;
        case 26:
          if (tag !== 210) {
            break;
          }

          message.accessTimes.push(TimePeriod.decode(reader, reader.uint32()));
          continue;
        case 27:
          if (tag !== 218) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 28:
          if (tag !== 226) {
            break;
          }

          message.customerSiteId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Site {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      organizationContact: isSet(object.organizationContact)
        ? OrganizationContact.fromJSON(object.organizationContact)
        : undefined,
      googleMapsPinUri: isSet(object.googleMapsPinUri) ? globalThis.String(object.googleMapsPinUri) : "",
      accessTimes: globalThis.Array.isArray(object?.accessTimes)
        ? object.accessTimes.map((e: any) => TimePeriod.fromJSON(e))
        : [],
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
      customerSiteId: isSet(object.customerSiteId) ? globalThis.String(object.customerSiteId) : "",
    };
  },

  toJSON(message: Site): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.organizationContact !== undefined) {
      obj.organizationContact = OrganizationContact.toJSON(message.organizationContact);
    }
    if (message.googleMapsPinUri !== "") {
      obj.googleMapsPinUri = message.googleMapsPinUri;
    }
    if (message.accessTimes?.length) {
      obj.accessTimes = message.accessTimes.map((e) => TimePeriod.toJSON(e));
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    if (message.customerSiteId !== "") {
      obj.customerSiteId = message.customerSiteId;
    }
    return obj;
  },

  create(base?: DeepPartial<Site>): Site {
    return Site.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Site>): Site {
    const message = createBaseSite();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.organizationContact = (object.organizationContact !== undefined && object.organizationContact !== null)
      ? OrganizationContact.fromPartial(object.organizationContact)
      : undefined;
    message.googleMapsPinUri = object.googleMapsPinUri ?? "";
    message.accessTimes = object.accessTimes?.map((e) => TimePeriod.fromPartial(e)) || [];
    message.notes = object.notes ?? "";
    message.customerSiteId = object.customerSiteId ?? "";
    return message;
  },
};

function createBaseSite_LabelsEntry(): Site_LabelsEntry {
  return { key: "", value: "" };
}

export const Site_LabelsEntry: MessageFns<Site_LabelsEntry> = {
  encode(message: Site_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Site_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSite_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Site_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Site_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Site_LabelsEntry>): Site_LabelsEntry {
    return Site_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Site_LabelsEntry>): Site_LabelsEntry {
    const message = createBaseSite_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHardwareGroup(): HardwareGroup {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    hardwareCount: 0,
    config: undefined,
    site: "",
    state: 0,
    zone: "",
    requestedInstallationDate: undefined,
  };
}

export const HardwareGroup: MessageFns<HardwareGroup> = {
  encode(message: HardwareGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      HardwareGroup_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.hardwareCount !== 0) {
      writer.uint32(40).int32(message.hardwareCount);
    }
    if (message.config !== undefined) {
      HardwareConfig.encode(message.config, writer.uint32(50).fork()).join();
    }
    if (message.site !== "") {
      writer.uint32(58).string(message.site);
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.zone !== "") {
      writer.uint32(74).string(message.zone);
    }
    if (message.requestedInstallationDate !== undefined) {
      DateMessage.encode(message.requestedInstallationDate, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HardwareGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHardwareGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = HardwareGroup_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.hardwareCount = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.config = HardwareConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.site = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.requestedInstallationDate = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HardwareGroup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      hardwareCount: isSet(object.hardwareCount) ? globalThis.Number(object.hardwareCount) : 0,
      config: isSet(object.config) ? HardwareConfig.fromJSON(object.config) : undefined,
      site: isSet(object.site) ? globalThis.String(object.site) : "",
      state: isSet(object.state) ? hardwareGroup_StateFromJSON(object.state) : 0,
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      requestedInstallationDate: isSet(object.requestedInstallationDate)
        ? DateMessage.fromJSON(object.requestedInstallationDate)
        : undefined,
    };
  },

  toJSON(message: HardwareGroup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.hardwareCount !== 0) {
      obj.hardwareCount = Math.round(message.hardwareCount);
    }
    if (message.config !== undefined) {
      obj.config = HardwareConfig.toJSON(message.config);
    }
    if (message.site !== "") {
      obj.site = message.site;
    }
    if (message.state !== 0) {
      obj.state = hardwareGroup_StateToJSON(message.state);
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.requestedInstallationDate !== undefined) {
      obj.requestedInstallationDate = DateMessage.toJSON(message.requestedInstallationDate);
    }
    return obj;
  },

  create(base?: DeepPartial<HardwareGroup>): HardwareGroup {
    return HardwareGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HardwareGroup>): HardwareGroup {
    const message = createBaseHardwareGroup();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.hardwareCount = object.hardwareCount ?? 0;
    message.config = (object.config !== undefined && object.config !== null)
      ? HardwareConfig.fromPartial(object.config)
      : undefined;
    message.site = object.site ?? "";
    message.state = object.state ?? 0;
    message.zone = object.zone ?? "";
    message.requestedInstallationDate =
      (object.requestedInstallationDate !== undefined && object.requestedInstallationDate !== null)
        ? DateMessage.fromPartial(object.requestedInstallationDate)
        : undefined;
    return message;
  },
};

function createBaseHardwareGroup_LabelsEntry(): HardwareGroup_LabelsEntry {
  return { key: "", value: "" };
}

export const HardwareGroup_LabelsEntry: MessageFns<HardwareGroup_LabelsEntry> = {
  encode(message: HardwareGroup_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HardwareGroup_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHardwareGroup_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HardwareGroup_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: HardwareGroup_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<HardwareGroup_LabelsEntry>): HardwareGroup_LabelsEntry {
    return HardwareGroup_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HardwareGroup_LabelsEntry>): HardwareGroup_LabelsEntry {
    const message = createBaseHardwareGroup_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHardware(): Hardware {
  return {
    name: "",
    displayName: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    order: "",
    hardwareGroup: "",
    site: "",
    state: 0,
    ciqUri: "",
    config: undefined,
    estimatedInstallationDate: undefined,
    physicalInfo: undefined,
    installationInfo: undefined,
    zone: "",
    requestedInstallationDate: undefined,
    actualInstallationDate: undefined,
  };
}

export const Hardware: MessageFns<Hardware> = {
  encode(message: Hardware, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Hardware_LabelsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.order !== "") {
      writer.uint32(50).string(message.order);
    }
    if (message.hardwareGroup !== "") {
      writer.uint32(58).string(message.hardwareGroup);
    }
    if (message.site !== "") {
      writer.uint32(66).string(message.site);
    }
    if (message.state !== 0) {
      writer.uint32(72).int32(message.state);
    }
    if (message.ciqUri !== "") {
      writer.uint32(82).string(message.ciqUri);
    }
    if (message.config !== undefined) {
      HardwareConfig.encode(message.config, writer.uint32(90).fork()).join();
    }
    if (message.estimatedInstallationDate !== undefined) {
      DateMessage.encode(message.estimatedInstallationDate, writer.uint32(98).fork()).join();
    }
    if (message.physicalInfo !== undefined) {
      HardwarePhysicalInfo.encode(message.physicalInfo, writer.uint32(106).fork()).join();
    }
    if (message.installationInfo !== undefined) {
      HardwareInstallationInfo.encode(message.installationInfo, writer.uint32(114).fork()).join();
    }
    if (message.zone !== "") {
      writer.uint32(122).string(message.zone);
    }
    if (message.requestedInstallationDate !== undefined) {
      DateMessage.encode(message.requestedInstallationDate, writer.uint32(130).fork()).join();
    }
    if (message.actualInstallationDate !== undefined) {
      DateMessage.encode(message.actualInstallationDate, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hardware {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHardware();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Hardware_LabelsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.labels[entry5.key] = entry5.value;
          }
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.order = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.hardwareGroup = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.site = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.ciqUri = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.config = HardwareConfig.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.estimatedInstallationDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.physicalInfo = HardwarePhysicalInfo.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.installationInfo = HardwareInstallationInfo.decode(reader, reader.uint32());
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.zone = reader.string();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.requestedInstallationDate = DateMessage.decode(reader, reader.uint32());
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.actualInstallationDate = DateMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hardware {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      order: isSet(object.order) ? globalThis.String(object.order) : "",
      hardwareGroup: isSet(object.hardwareGroup) ? globalThis.String(object.hardwareGroup) : "",
      site: isSet(object.site) ? globalThis.String(object.site) : "",
      state: isSet(object.state) ? hardware_StateFromJSON(object.state) : 0,
      ciqUri: isSet(object.ciqUri) ? globalThis.String(object.ciqUri) : "",
      config: isSet(object.config) ? HardwareConfig.fromJSON(object.config) : undefined,
      estimatedInstallationDate: isSet(object.estimatedInstallationDate)
        ? DateMessage.fromJSON(object.estimatedInstallationDate)
        : undefined,
      physicalInfo: isSet(object.physicalInfo) ? HardwarePhysicalInfo.fromJSON(object.physicalInfo) : undefined,
      installationInfo: isSet(object.installationInfo)
        ? HardwareInstallationInfo.fromJSON(object.installationInfo)
        : undefined,
      zone: isSet(object.zone) ? globalThis.String(object.zone) : "",
      requestedInstallationDate: isSet(object.requestedInstallationDate)
        ? DateMessage.fromJSON(object.requestedInstallationDate)
        : undefined,
      actualInstallationDate: isSet(object.actualInstallationDate)
        ? DateMessage.fromJSON(object.actualInstallationDate)
        : undefined,
    };
  },

  toJSON(message: Hardware): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.order !== "") {
      obj.order = message.order;
    }
    if (message.hardwareGroup !== "") {
      obj.hardwareGroup = message.hardwareGroup;
    }
    if (message.site !== "") {
      obj.site = message.site;
    }
    if (message.state !== 0) {
      obj.state = hardware_StateToJSON(message.state);
    }
    if (message.ciqUri !== "") {
      obj.ciqUri = message.ciqUri;
    }
    if (message.config !== undefined) {
      obj.config = HardwareConfig.toJSON(message.config);
    }
    if (message.estimatedInstallationDate !== undefined) {
      obj.estimatedInstallationDate = DateMessage.toJSON(message.estimatedInstallationDate);
    }
    if (message.physicalInfo !== undefined) {
      obj.physicalInfo = HardwarePhysicalInfo.toJSON(message.physicalInfo);
    }
    if (message.installationInfo !== undefined) {
      obj.installationInfo = HardwareInstallationInfo.toJSON(message.installationInfo);
    }
    if (message.zone !== "") {
      obj.zone = message.zone;
    }
    if (message.requestedInstallationDate !== undefined) {
      obj.requestedInstallationDate = DateMessage.toJSON(message.requestedInstallationDate);
    }
    if (message.actualInstallationDate !== undefined) {
      obj.actualInstallationDate = DateMessage.toJSON(message.actualInstallationDate);
    }
    return obj;
  },

  create(base?: DeepPartial<Hardware>): Hardware {
    return Hardware.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Hardware>): Hardware {
    const message = createBaseHardware();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.order = object.order ?? "";
    message.hardwareGroup = object.hardwareGroup ?? "";
    message.site = object.site ?? "";
    message.state = object.state ?? 0;
    message.ciqUri = object.ciqUri ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? HardwareConfig.fromPartial(object.config)
      : undefined;
    message.estimatedInstallationDate =
      (object.estimatedInstallationDate !== undefined && object.estimatedInstallationDate !== null)
        ? DateMessage.fromPartial(object.estimatedInstallationDate)
        : undefined;
    message.physicalInfo = (object.physicalInfo !== undefined && object.physicalInfo !== null)
      ? HardwarePhysicalInfo.fromPartial(object.physicalInfo)
      : undefined;
    message.installationInfo = (object.installationInfo !== undefined && object.installationInfo !== null)
      ? HardwareInstallationInfo.fromPartial(object.installationInfo)
      : undefined;
    message.zone = object.zone ?? "";
    message.requestedInstallationDate =
      (object.requestedInstallationDate !== undefined && object.requestedInstallationDate !== null)
        ? DateMessage.fromPartial(object.requestedInstallationDate)
        : undefined;
    message.actualInstallationDate =
      (object.actualInstallationDate !== undefined && object.actualInstallationDate !== null)
        ? DateMessage.fromPartial(object.actualInstallationDate)
        : undefined;
    return message;
  },
};

function createBaseHardware_LabelsEntry(): Hardware_LabelsEntry {
  return { key: "", value: "" };
}

export const Hardware_LabelsEntry: MessageFns<Hardware_LabelsEntry> = {
  encode(message: Hardware_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hardware_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHardware_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hardware_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Hardware_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Hardware_LabelsEntry>): Hardware_LabelsEntry {
    return Hardware_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Hardware_LabelsEntry>): Hardware_LabelsEntry {
    const message = createBaseHardware_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseComment(): Comment {
  return {
    name: "",
    createTime: undefined,
    labels: {},
    author: "",
    text: "",
    customerViewedTime: undefined,
    authorEntity: 0,
  };
}

export const Comment: MessageFns<Comment> = {
  encode(message: Comment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Comment_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.author !== "") {
      writer.uint32(34).string(message.author);
    }
    if (message.text !== "") {
      writer.uint32(42).string(message.text);
    }
    if (message.customerViewedTime !== undefined) {
      Timestamp.encode(toTimestamp(message.customerViewedTime), writer.uint32(50).fork()).join();
    }
    if (message.authorEntity !== 0) {
      writer.uint32(56).int32(message.authorEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Comment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Comment_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.author = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.text = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.customerViewedTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.authorEntity = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Comment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      author: isSet(object.author) ? globalThis.String(object.author) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      customerViewedTime: isSet(object.customerViewedTime) ? fromJsonTimestamp(object.customerViewedTime) : undefined,
      authorEntity: isSet(object.authorEntity) ? entityFromJSON(object.authorEntity) : 0,
    };
  },

  toJSON(message: Comment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.author !== "") {
      obj.author = message.author;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.customerViewedTime !== undefined) {
      obj.customerViewedTime = message.customerViewedTime.toISOString();
    }
    if (message.authorEntity !== 0) {
      obj.authorEntity = entityToJSON(message.authorEntity);
    }
    return obj;
  },

  create(base?: DeepPartial<Comment>): Comment {
    return Comment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Comment>): Comment {
    const message = createBaseComment();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.author = object.author ?? "";
    message.text = object.text ?? "";
    message.customerViewedTime = object.customerViewedTime ?? undefined;
    message.authorEntity = object.authorEntity ?? 0;
    return message;
  },
};

function createBaseComment_LabelsEntry(): Comment_LabelsEntry {
  return { key: "", value: "" };
}

export const Comment_LabelsEntry: MessageFns<Comment_LabelsEntry> = {
  encode(message: Comment_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Comment_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComment_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Comment_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Comment_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Comment_LabelsEntry>): Comment_LabelsEntry {
    return Comment_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Comment_LabelsEntry>): Comment_LabelsEntry {
    const message = createBaseComment_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseChangeLogEntry(): ChangeLogEntry {
  return { name: "", createTime: undefined, labels: {}, log: "" };
}

export const ChangeLogEntry: MessageFns<ChangeLogEntry> = {
  encode(message: ChangeLogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      ChangeLogEntry_LabelsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.log !== "") {
      writer.uint32(34).string(message.log);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeLogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = ChangeLogEntry_LabelsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.labels[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.log = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeLogEntry {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      log: isSet(object.log) ? globalThis.String(object.log) : "",
    };
  },

  toJSON(message: ChangeLogEntry): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.log !== "") {
      obj.log = message.log;
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeLogEntry>): ChangeLogEntry {
    return ChangeLogEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeLogEntry>): ChangeLogEntry {
    const message = createBaseChangeLogEntry();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.log = object.log ?? "";
    return message;
  },
};

function createBaseChangeLogEntry_LabelsEntry(): ChangeLogEntry_LabelsEntry {
  return { key: "", value: "" };
}

export const ChangeLogEntry_LabelsEntry: MessageFns<ChangeLogEntry_LabelsEntry> = {
  encode(message: ChangeLogEntry_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeLogEntry_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeLogEntry_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeLogEntry_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ChangeLogEntry_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<ChangeLogEntry_LabelsEntry>): ChangeLogEntry_LabelsEntry {
    return ChangeLogEntry_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChangeLogEntry_LabelsEntry>): ChangeLogEntry_LabelsEntry {
    const message = createBaseChangeLogEntry_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSku(): Sku {
  return {
    name: "",
    displayName: "",
    createTime: undefined,
    updateTime: undefined,
    config: undefined,
    instances: [],
    description: "",
    revisionId: "",
    isActive: false,
    type: 0,
    vcpuCount: 0,
  };
}

export const Sku: MessageFns<Sku> = {
  encode(message: Sku, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.config !== undefined) {
      SkuConfig.encode(message.config, writer.uint32(50).fork()).join();
    }
    for (const v of message.instances) {
      SkuInstance.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.revisionId !== "") {
      writer.uint32(74).string(message.revisionId);
    }
    if (message.isActive !== false) {
      writer.uint32(80).bool(message.isActive);
    }
    if (message.type !== 0) {
      writer.uint32(88).int32(message.type);
    }
    if (message.vcpuCount !== 0) {
      writer.uint32(96).int32(message.vcpuCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Sku {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSku();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.config = SkuConfig.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.instances.push(SkuInstance.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.revisionId = reader.string();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.vcpuCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Sku {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      config: isSet(object.config) ? SkuConfig.fromJSON(object.config) : undefined,
      instances: globalThis.Array.isArray(object?.instances)
        ? object.instances.map((e: any) => SkuInstance.fromJSON(e))
        : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      revisionId: isSet(object.revisionId) ? globalThis.String(object.revisionId) : "",
      isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
      type: isSet(object.type) ? sku_TypeFromJSON(object.type) : 0,
      vcpuCount: isSet(object.vcpuCount) ? globalThis.Number(object.vcpuCount) : 0,
    };
  },

  toJSON(message: Sku): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.config !== undefined) {
      obj.config = SkuConfig.toJSON(message.config);
    }
    if (message.instances?.length) {
      obj.instances = message.instances.map((e) => SkuInstance.toJSON(e));
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.revisionId !== "") {
      obj.revisionId = message.revisionId;
    }
    if (message.isActive !== false) {
      obj.isActive = message.isActive;
    }
    if (message.type !== 0) {
      obj.type = sku_TypeToJSON(message.type);
    }
    if (message.vcpuCount !== 0) {
      obj.vcpuCount = Math.round(message.vcpuCount);
    }
    return obj;
  },

  create(base?: DeepPartial<Sku>): Sku {
    return Sku.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Sku>): Sku {
    const message = createBaseSku();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? SkuConfig.fromPartial(object.config)
      : undefined;
    message.instances = object.instances?.map((e) => SkuInstance.fromPartial(e)) || [];
    message.description = object.description ?? "";
    message.revisionId = object.revisionId ?? "";
    message.isActive = object.isActive ?? false;
    message.type = object.type ?? 0;
    message.vcpuCount = object.vcpuCount ?? 0;
    return message;
  },
};

function createBaseZone(): Zone {
  return {
    name: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    displayName: "",
    state: 0,
    contacts: [],
    ciqUri: "",
    networkConfig: undefined,
    globallyUniqueId: "",
    subscriptionConfigs: [],
  };
}

export const Zone: MessageFns<Zone> = {
  encode(message: Zone, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(18).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(26).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Zone_LabelsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    for (const v of message.contacts) {
      Contact.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.ciqUri !== "") {
      writer.uint32(82).string(message.ciqUri);
    }
    if (message.networkConfig !== undefined) {
      ZoneNetworkConfig.encode(message.networkConfig, writer.uint32(90).fork()).join();
    }
    if (message.globallyUniqueId !== "") {
      writer.uint32(98).string(message.globallyUniqueId);
    }
    for (const v of message.subscriptionConfigs) {
      SubscriptionConfig.encode(v!, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Zone {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZone();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = Zone_LabelsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.labels[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.contacts.push(Contact.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.ciqUri = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.networkConfig = ZoneNetworkConfig.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.globallyUniqueId = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.subscriptionConfigs.push(SubscriptionConfig.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Zone {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      state: isSet(object.state) ? zone_StateFromJSON(object.state) : 0,
      contacts: globalThis.Array.isArray(object?.contacts) ? object.contacts.map((e: any) => Contact.fromJSON(e)) : [],
      ciqUri: isSet(object.ciqUri) ? globalThis.String(object.ciqUri) : "",
      networkConfig: isSet(object.networkConfig) ? ZoneNetworkConfig.fromJSON(object.networkConfig) : undefined,
      globallyUniqueId: isSet(object.globallyUniqueId) ? globalThis.String(object.globallyUniqueId) : "",
      subscriptionConfigs: globalThis.Array.isArray(object?.subscriptionConfigs)
        ? object.subscriptionConfigs.map((e: any) => SubscriptionConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Zone): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.state !== 0) {
      obj.state = zone_StateToJSON(message.state);
    }
    if (message.contacts?.length) {
      obj.contacts = message.contacts.map((e) => Contact.toJSON(e));
    }
    if (message.ciqUri !== "") {
      obj.ciqUri = message.ciqUri;
    }
    if (message.networkConfig !== undefined) {
      obj.networkConfig = ZoneNetworkConfig.toJSON(message.networkConfig);
    }
    if (message.globallyUniqueId !== "") {
      obj.globallyUniqueId = message.globallyUniqueId;
    }
    if (message.subscriptionConfigs?.length) {
      obj.subscriptionConfigs = message.subscriptionConfigs.map((e) => SubscriptionConfig.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Zone>): Zone {
    return Zone.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Zone>): Zone {
    const message = createBaseZone();
    message.name = object.name ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.displayName = object.displayName ?? "";
    message.state = object.state ?? 0;
    message.contacts = object.contacts?.map((e) => Contact.fromPartial(e)) || [];
    message.ciqUri = object.ciqUri ?? "";
    message.networkConfig = (object.networkConfig !== undefined && object.networkConfig !== null)
      ? ZoneNetworkConfig.fromPartial(object.networkConfig)
      : undefined;
    message.globallyUniqueId = object.globallyUniqueId ?? "";
    message.subscriptionConfigs = object.subscriptionConfigs?.map((e) => SubscriptionConfig.fromPartial(e)) || [];
    return message;
  },
};

function createBaseZone_LabelsEntry(): Zone_LabelsEntry {
  return { key: "", value: "" };
}

export const Zone_LabelsEntry: MessageFns<Zone_LabelsEntry> = {
  encode(message: Zone_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Zone_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZone_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Zone_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Zone_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Zone_LabelsEntry>): Zone_LabelsEntry {
    return Zone_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Zone_LabelsEntry>): Zone_LabelsEntry {
    const message = createBaseZone_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseOrganizationContact(): OrganizationContact {
  return { address: undefined, email: "", phone: "", contacts: [] };
}

export const OrganizationContact: MessageFns<OrganizationContact> = {
  encode(message: OrganizationContact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      PostalAddress.encode(message.address, writer.uint32(10).fork()).join();
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.phone !== "") {
      writer.uint32(26).string(message.phone);
    }
    for (const v of message.contacts) {
      Contact.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrganizationContact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganizationContact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = PostalAddress.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.phone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.contacts.push(Contact.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrganizationContact {
    return {
      address: isSet(object.address) ? PostalAddress.fromJSON(object.address) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
      contacts: globalThis.Array.isArray(object?.contacts) ? object.contacts.map((e: any) => Contact.fromJSON(e)) : [],
    };
  },

  toJSON(message: OrganizationContact): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = PostalAddress.toJSON(message.address);
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    if (message.contacts?.length) {
      obj.contacts = message.contacts.map((e) => Contact.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<OrganizationContact>): OrganizationContact {
    return OrganizationContact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrganizationContact>): OrganizationContact {
    const message = createBaseOrganizationContact();
    message.address = (object.address !== undefined && object.address !== null)
      ? PostalAddress.fromPartial(object.address)
      : undefined;
    message.email = object.email ?? "";
    message.phone = object.phone ?? "";
    message.contacts = object.contacts?.map((e) => Contact.fromPartial(e)) || [];
    return message;
  },
};

function createBaseContact(): Contact {
  return { givenName: "", familyName: "", email: "", phone: "", timeZone: undefined, reachableTimes: [] };
}

export const Contact: MessageFns<Contact> = {
  encode(message: Contact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.givenName !== "") {
      writer.uint32(10).string(message.givenName);
    }
    if (message.familyName !== "") {
      writer.uint32(18).string(message.familyName);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.phone !== "") {
      writer.uint32(34).string(message.phone);
    }
    if (message.timeZone !== undefined) {
      TimeZone.encode(message.timeZone, writer.uint32(42).fork()).join();
    }
    for (const v of message.reachableTimes) {
      TimePeriod.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Contact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.givenName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.familyName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.timeZone = TimeZone.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.reachableTimes.push(TimePeriod.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Contact {
    return {
      givenName: isSet(object.givenName) ? globalThis.String(object.givenName) : "",
      familyName: isSet(object.familyName) ? globalThis.String(object.familyName) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      phone: isSet(object.phone) ? globalThis.String(object.phone) : "",
      timeZone: isSet(object.timeZone) ? TimeZone.fromJSON(object.timeZone) : undefined,
      reachableTimes: globalThis.Array.isArray(object?.reachableTimes)
        ? object.reachableTimes.map((e: any) => TimePeriod.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Contact): unknown {
    const obj: any = {};
    if (message.givenName !== "") {
      obj.givenName = message.givenName;
    }
    if (message.familyName !== "") {
      obj.familyName = message.familyName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.phone !== "") {
      obj.phone = message.phone;
    }
    if (message.timeZone !== undefined) {
      obj.timeZone = TimeZone.toJSON(message.timeZone);
    }
    if (message.reachableTimes?.length) {
      obj.reachableTimes = message.reachableTimes.map((e) => TimePeriod.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Contact>): Contact {
    return Contact.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Contact>): Contact {
    const message = createBaseContact();
    message.givenName = object.givenName ?? "";
    message.familyName = object.familyName ?? "";
    message.email = object.email ?? "";
    message.phone = object.phone ?? "";
    message.timeZone = (object.timeZone !== undefined && object.timeZone !== null)
      ? TimeZone.fromPartial(object.timeZone)
      : undefined;
    message.reachableTimes = object.reachableTimes?.map((e) => TimePeriod.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHardwareConfig(): HardwareConfig {
  return { sku: "", powerSupply: 0, subscriptionDurationMonths: 0 };
}

export const HardwareConfig: MessageFns<HardwareConfig> = {
  encode(message: HardwareConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sku !== "") {
      writer.uint32(10).string(message.sku);
    }
    if (message.powerSupply !== 0) {
      writer.uint32(16).int32(message.powerSupply);
    }
    if (message.subscriptionDurationMonths !== 0) {
      writer.uint32(24).int32(message.subscriptionDurationMonths);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HardwareConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHardwareConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sku = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.powerSupply = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.subscriptionDurationMonths = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HardwareConfig {
    return {
      sku: isSet(object.sku) ? globalThis.String(object.sku) : "",
      powerSupply: isSet(object.powerSupply) ? powerSupplyFromJSON(object.powerSupply) : 0,
      subscriptionDurationMonths: isSet(object.subscriptionDurationMonths)
        ? globalThis.Number(object.subscriptionDurationMonths)
        : 0,
    };
  },

  toJSON(message: HardwareConfig): unknown {
    const obj: any = {};
    if (message.sku !== "") {
      obj.sku = message.sku;
    }
    if (message.powerSupply !== 0) {
      obj.powerSupply = powerSupplyToJSON(message.powerSupply);
    }
    if (message.subscriptionDurationMonths !== 0) {
      obj.subscriptionDurationMonths = Math.round(message.subscriptionDurationMonths);
    }
    return obj;
  },

  create(base?: DeepPartial<HardwareConfig>): HardwareConfig {
    return HardwareConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HardwareConfig>): HardwareConfig {
    const message = createBaseHardwareConfig();
    message.sku = object.sku ?? "";
    message.powerSupply = object.powerSupply ?? 0;
    message.subscriptionDurationMonths = object.subscriptionDurationMonths ?? 0;
    return message;
  },
};

function createBaseSkuConfig(): SkuConfig {
  return { cpu: "", gpu: "", ram: "", storage: "" };
}

export const SkuConfig: MessageFns<SkuConfig> = {
  encode(message: SkuConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpu !== "") {
      writer.uint32(10).string(message.cpu);
    }
    if (message.gpu !== "") {
      writer.uint32(18).string(message.gpu);
    }
    if (message.ram !== "") {
      writer.uint32(26).string(message.ram);
    }
    if (message.storage !== "") {
      writer.uint32(34).string(message.storage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkuConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.cpu = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gpu = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ram = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.storage = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkuConfig {
    return {
      cpu: isSet(object.cpu) ? globalThis.String(object.cpu) : "",
      gpu: isSet(object.gpu) ? globalThis.String(object.gpu) : "",
      ram: isSet(object.ram) ? globalThis.String(object.ram) : "",
      storage: isSet(object.storage) ? globalThis.String(object.storage) : "",
    };
  },

  toJSON(message: SkuConfig): unknown {
    const obj: any = {};
    if (message.cpu !== "") {
      obj.cpu = message.cpu;
    }
    if (message.gpu !== "") {
      obj.gpu = message.gpu;
    }
    if (message.ram !== "") {
      obj.ram = message.ram;
    }
    if (message.storage !== "") {
      obj.storage = message.storage;
    }
    return obj;
  },

  create(base?: DeepPartial<SkuConfig>): SkuConfig {
    return SkuConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkuConfig>): SkuConfig {
    const message = createBaseSkuConfig();
    message.cpu = object.cpu ?? "";
    message.gpu = object.gpu ?? "";
    message.ram = object.ram ?? "";
    message.storage = object.storage ?? "";
    return message;
  },
};

function createBaseSkuInstance(): SkuInstance {
  return { regionCode: "", powerSupply: 0, billingSku: "", billingSkuPerVcpu: "", subscriptionDurationMonths: 0 };
}

export const SkuInstance: MessageFns<SkuInstance> = {
  encode(message: SkuInstance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.regionCode !== "") {
      writer.uint32(10).string(message.regionCode);
    }
    if (message.powerSupply !== 0) {
      writer.uint32(16).int32(message.powerSupply);
    }
    if (message.billingSku !== "") {
      writer.uint32(26).string(message.billingSku);
    }
    if (message.billingSkuPerVcpu !== "") {
      writer.uint32(34).string(message.billingSkuPerVcpu);
    }
    if (message.subscriptionDurationMonths !== 0) {
      writer.uint32(40).int32(message.subscriptionDurationMonths);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkuInstance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.regionCode = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.powerSupply = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.billingSku = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.billingSkuPerVcpu = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.subscriptionDurationMonths = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkuInstance {
    return {
      regionCode: isSet(object.regionCode) ? globalThis.String(object.regionCode) : "",
      powerSupply: isSet(object.powerSupply) ? powerSupplyFromJSON(object.powerSupply) : 0,
      billingSku: isSet(object.billingSku) ? globalThis.String(object.billingSku) : "",
      billingSkuPerVcpu: isSet(object.billingSkuPerVcpu) ? globalThis.String(object.billingSkuPerVcpu) : "",
      subscriptionDurationMonths: isSet(object.subscriptionDurationMonths)
        ? globalThis.Number(object.subscriptionDurationMonths)
        : 0,
    };
  },

  toJSON(message: SkuInstance): unknown {
    const obj: any = {};
    if (message.regionCode !== "") {
      obj.regionCode = message.regionCode;
    }
    if (message.powerSupply !== 0) {
      obj.powerSupply = powerSupplyToJSON(message.powerSupply);
    }
    if (message.billingSku !== "") {
      obj.billingSku = message.billingSku;
    }
    if (message.billingSkuPerVcpu !== "") {
      obj.billingSkuPerVcpu = message.billingSkuPerVcpu;
    }
    if (message.subscriptionDurationMonths !== 0) {
      obj.subscriptionDurationMonths = Math.round(message.subscriptionDurationMonths);
    }
    return obj;
  },

  create(base?: DeepPartial<SkuInstance>): SkuInstance {
    return SkuInstance.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkuInstance>): SkuInstance {
    const message = createBaseSkuInstance();
    message.regionCode = object.regionCode ?? "";
    message.powerSupply = object.powerSupply ?? 0;
    message.billingSku = object.billingSku ?? "";
    message.billingSkuPerVcpu = object.billingSkuPerVcpu ?? "";
    message.subscriptionDurationMonths = object.subscriptionDurationMonths ?? 0;
    return message;
  },
};

function createBaseHardwarePhysicalInfo(): HardwarePhysicalInfo {
  return { powerReceptacle: 0, networkUplink: 0, voltage: 0, amperes: 0 };
}

export const HardwarePhysicalInfo: MessageFns<HardwarePhysicalInfo> = {
  encode(message: HardwarePhysicalInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.powerReceptacle !== 0) {
      writer.uint32(8).int32(message.powerReceptacle);
    }
    if (message.networkUplink !== 0) {
      writer.uint32(16).int32(message.networkUplink);
    }
    if (message.voltage !== 0) {
      writer.uint32(24).int32(message.voltage);
    }
    if (message.amperes !== 0) {
      writer.uint32(32).int32(message.amperes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HardwarePhysicalInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHardwarePhysicalInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.powerReceptacle = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.networkUplink = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.voltage = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amperes = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HardwarePhysicalInfo {
    return {
      powerReceptacle: isSet(object.powerReceptacle)
        ? hardwarePhysicalInfo_PowerReceptacleTypeFromJSON(object.powerReceptacle)
        : 0,
      networkUplink: isSet(object.networkUplink)
        ? hardwarePhysicalInfo_NetworkUplinkTypeFromJSON(object.networkUplink)
        : 0,
      voltage: isSet(object.voltage) ? hardwarePhysicalInfo_VoltageFromJSON(object.voltage) : 0,
      amperes: isSet(object.amperes) ? hardwarePhysicalInfo_AmperesFromJSON(object.amperes) : 0,
    };
  },

  toJSON(message: HardwarePhysicalInfo): unknown {
    const obj: any = {};
    if (message.powerReceptacle !== 0) {
      obj.powerReceptacle = hardwarePhysicalInfo_PowerReceptacleTypeToJSON(message.powerReceptacle);
    }
    if (message.networkUplink !== 0) {
      obj.networkUplink = hardwarePhysicalInfo_NetworkUplinkTypeToJSON(message.networkUplink);
    }
    if (message.voltage !== 0) {
      obj.voltage = hardwarePhysicalInfo_VoltageToJSON(message.voltage);
    }
    if (message.amperes !== 0) {
      obj.amperes = hardwarePhysicalInfo_AmperesToJSON(message.amperes);
    }
    return obj;
  },

  create(base?: DeepPartial<HardwarePhysicalInfo>): HardwarePhysicalInfo {
    return HardwarePhysicalInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HardwarePhysicalInfo>): HardwarePhysicalInfo {
    const message = createBaseHardwarePhysicalInfo();
    message.powerReceptacle = object.powerReceptacle ?? 0;
    message.networkUplink = object.networkUplink ?? 0;
    message.voltage = object.voltage ?? 0;
    message.amperes = object.amperes ?? 0;
    return message;
  },
};

function createBaseHardwareInstallationInfo(): HardwareInstallationInfo {
  return {
    rackLocation: "",
    powerDistanceMeters: 0,
    switchDistanceMeters: 0,
    rackUnitDimensions: undefined,
    rackSpace: undefined,
    rackType: 0,
  };
}

export const HardwareInstallationInfo: MessageFns<HardwareInstallationInfo> = {
  encode(message: HardwareInstallationInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rackLocation !== "") {
      writer.uint32(10).string(message.rackLocation);
    }
    if (message.powerDistanceMeters !== 0) {
      writer.uint32(16).int32(message.powerDistanceMeters);
    }
    if (message.switchDistanceMeters !== 0) {
      writer.uint32(24).int32(message.switchDistanceMeters);
    }
    if (message.rackUnitDimensions !== undefined) {
      Dimensions.encode(message.rackUnitDimensions, writer.uint32(34).fork()).join();
    }
    if (message.rackSpace !== undefined) {
      RackSpace.encode(message.rackSpace, writer.uint32(42).fork()).join();
    }
    if (message.rackType !== 0) {
      writer.uint32(48).int32(message.rackType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HardwareInstallationInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHardwareInstallationInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rackLocation = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.powerDistanceMeters = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.switchDistanceMeters = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.rackUnitDimensions = Dimensions.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rackSpace = RackSpace.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.rackType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HardwareInstallationInfo {
    return {
      rackLocation: isSet(object.rackLocation) ? globalThis.String(object.rackLocation) : "",
      powerDistanceMeters: isSet(object.powerDistanceMeters) ? globalThis.Number(object.powerDistanceMeters) : 0,
      switchDistanceMeters: isSet(object.switchDistanceMeters) ? globalThis.Number(object.switchDistanceMeters) : 0,
      rackUnitDimensions: isSet(object.rackUnitDimensions) ? Dimensions.fromJSON(object.rackUnitDimensions) : undefined,
      rackSpace: isSet(object.rackSpace) ? RackSpace.fromJSON(object.rackSpace) : undefined,
      rackType: isSet(object.rackType) ? hardwareInstallationInfo_RackTypeFromJSON(object.rackType) : 0,
    };
  },

  toJSON(message: HardwareInstallationInfo): unknown {
    const obj: any = {};
    if (message.rackLocation !== "") {
      obj.rackLocation = message.rackLocation;
    }
    if (message.powerDistanceMeters !== 0) {
      obj.powerDistanceMeters = Math.round(message.powerDistanceMeters);
    }
    if (message.switchDistanceMeters !== 0) {
      obj.switchDistanceMeters = Math.round(message.switchDistanceMeters);
    }
    if (message.rackUnitDimensions !== undefined) {
      obj.rackUnitDimensions = Dimensions.toJSON(message.rackUnitDimensions);
    }
    if (message.rackSpace !== undefined) {
      obj.rackSpace = RackSpace.toJSON(message.rackSpace);
    }
    if (message.rackType !== 0) {
      obj.rackType = hardwareInstallationInfo_RackTypeToJSON(message.rackType);
    }
    return obj;
  },

  create(base?: DeepPartial<HardwareInstallationInfo>): HardwareInstallationInfo {
    return HardwareInstallationInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HardwareInstallationInfo>): HardwareInstallationInfo {
    const message = createBaseHardwareInstallationInfo();
    message.rackLocation = object.rackLocation ?? "";
    message.powerDistanceMeters = object.powerDistanceMeters ?? 0;
    message.switchDistanceMeters = object.switchDistanceMeters ?? 0;
    message.rackUnitDimensions = (object.rackUnitDimensions !== undefined && object.rackUnitDimensions !== null)
      ? Dimensions.fromPartial(object.rackUnitDimensions)
      : undefined;
    message.rackSpace = (object.rackSpace !== undefined && object.rackSpace !== null)
      ? RackSpace.fromPartial(object.rackSpace)
      : undefined;
    message.rackType = object.rackType ?? 0;
    return message;
  },
};

function createBaseZoneNetworkConfig(): ZoneNetworkConfig {
  return {
    machineMgmtIpv4Range: "",
    kubernetesNodeIpv4Range: "",
    kubernetesControlPlaneIpv4Range: "",
    managementIpv4Subnet: undefined,
    kubernetesIpv4Subnet: undefined,
  };
}

export const ZoneNetworkConfig: MessageFns<ZoneNetworkConfig> = {
  encode(message: ZoneNetworkConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.machineMgmtIpv4Range !== "") {
      writer.uint32(10).string(message.machineMgmtIpv4Range);
    }
    if (message.kubernetesNodeIpv4Range !== "") {
      writer.uint32(18).string(message.kubernetesNodeIpv4Range);
    }
    if (message.kubernetesControlPlaneIpv4Range !== "") {
      writer.uint32(26).string(message.kubernetesControlPlaneIpv4Range);
    }
    if (message.managementIpv4Subnet !== undefined) {
      Subnet.encode(message.managementIpv4Subnet, writer.uint32(34).fork()).join();
    }
    if (message.kubernetesIpv4Subnet !== undefined) {
      Subnet.encode(message.kubernetesIpv4Subnet, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZoneNetworkConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZoneNetworkConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.machineMgmtIpv4Range = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.kubernetesNodeIpv4Range = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.kubernetesControlPlaneIpv4Range = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.managementIpv4Subnet = Subnet.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.kubernetesIpv4Subnet = Subnet.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZoneNetworkConfig {
    return {
      machineMgmtIpv4Range: isSet(object.machineMgmtIpv4Range) ? globalThis.String(object.machineMgmtIpv4Range) : "",
      kubernetesNodeIpv4Range: isSet(object.kubernetesNodeIpv4Range)
        ? globalThis.String(object.kubernetesNodeIpv4Range)
        : "",
      kubernetesControlPlaneIpv4Range: isSet(object.kubernetesControlPlaneIpv4Range)
        ? globalThis.String(object.kubernetesControlPlaneIpv4Range)
        : "",
      managementIpv4Subnet: isSet(object.managementIpv4Subnet)
        ? Subnet.fromJSON(object.managementIpv4Subnet)
        : undefined,
      kubernetesIpv4Subnet: isSet(object.kubernetesIpv4Subnet)
        ? Subnet.fromJSON(object.kubernetesIpv4Subnet)
        : undefined,
    };
  },

  toJSON(message: ZoneNetworkConfig): unknown {
    const obj: any = {};
    if (message.machineMgmtIpv4Range !== "") {
      obj.machineMgmtIpv4Range = message.machineMgmtIpv4Range;
    }
    if (message.kubernetesNodeIpv4Range !== "") {
      obj.kubernetesNodeIpv4Range = message.kubernetesNodeIpv4Range;
    }
    if (message.kubernetesControlPlaneIpv4Range !== "") {
      obj.kubernetesControlPlaneIpv4Range = message.kubernetesControlPlaneIpv4Range;
    }
    if (message.managementIpv4Subnet !== undefined) {
      obj.managementIpv4Subnet = Subnet.toJSON(message.managementIpv4Subnet);
    }
    if (message.kubernetesIpv4Subnet !== undefined) {
      obj.kubernetesIpv4Subnet = Subnet.toJSON(message.kubernetesIpv4Subnet);
    }
    return obj;
  },

  create(base?: DeepPartial<ZoneNetworkConfig>): ZoneNetworkConfig {
    return ZoneNetworkConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ZoneNetworkConfig>): ZoneNetworkConfig {
    const message = createBaseZoneNetworkConfig();
    message.machineMgmtIpv4Range = object.machineMgmtIpv4Range ?? "";
    message.kubernetesNodeIpv4Range = object.kubernetesNodeIpv4Range ?? "";
    message.kubernetesControlPlaneIpv4Range = object.kubernetesControlPlaneIpv4Range ?? "";
    message.managementIpv4Subnet = (object.managementIpv4Subnet !== undefined && object.managementIpv4Subnet !== null)
      ? Subnet.fromPartial(object.managementIpv4Subnet)
      : undefined;
    message.kubernetesIpv4Subnet = (object.kubernetesIpv4Subnet !== undefined && object.kubernetesIpv4Subnet !== null)
      ? Subnet.fromPartial(object.kubernetesIpv4Subnet)
      : undefined;
    return message;
  },
};

function createBaseSubnet(): Subnet {
  return { addressRange: "", defaultGatewayIpAddress: "" };
}

export const Subnet: MessageFns<Subnet> = {
  encode(message: Subnet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.addressRange !== "") {
      writer.uint32(10).string(message.addressRange);
    }
    if (message.defaultGatewayIpAddress !== "") {
      writer.uint32(18).string(message.defaultGatewayIpAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subnet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubnet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addressRange = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.defaultGatewayIpAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subnet {
    return {
      addressRange: isSet(object.addressRange) ? globalThis.String(object.addressRange) : "",
      defaultGatewayIpAddress: isSet(object.defaultGatewayIpAddress)
        ? globalThis.String(object.defaultGatewayIpAddress)
        : "",
    };
  },

  toJSON(message: Subnet): unknown {
    const obj: any = {};
    if (message.addressRange !== "") {
      obj.addressRange = message.addressRange;
    }
    if (message.defaultGatewayIpAddress !== "") {
      obj.defaultGatewayIpAddress = message.defaultGatewayIpAddress;
    }
    return obj;
  },

  create(base?: DeepPartial<Subnet>): Subnet {
    return Subnet.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subnet>): Subnet {
    const message = createBaseSubnet();
    message.addressRange = object.addressRange ?? "";
    message.defaultGatewayIpAddress = object.defaultGatewayIpAddress ?? "";
    return message;
  },
};

function createBaseTimePeriod(): TimePeriod {
  return { startTime: undefined, endTime: undefined, days: [] };
}

export const TimePeriod: MessageFns<TimePeriod> = {
  encode(message: TimePeriod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== undefined) {
      TimeOfDay.encode(message.startTime, writer.uint32(10).fork()).join();
    }
    if (message.endTime !== undefined) {
      TimeOfDay.encode(message.endTime, writer.uint32(18).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v of message.days) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimePeriod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimePeriod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.startTime = TimeOfDay.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.endTime = TimeOfDay.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag === 24) {
            message.days.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.days.push(reader.int32() as any);
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimePeriod {
    return {
      startTime: isSet(object.startTime) ? TimeOfDay.fromJSON(object.startTime) : undefined,
      endTime: isSet(object.endTime) ? TimeOfDay.fromJSON(object.endTime) : undefined,
      days: globalThis.Array.isArray(object?.days) ? object.days.map((e: any) => dayOfWeekFromJSON(e)) : [],
    };
  },

  toJSON(message: TimePeriod): unknown {
    const obj: any = {};
    if (message.startTime !== undefined) {
      obj.startTime = TimeOfDay.toJSON(message.startTime);
    }
    if (message.endTime !== undefined) {
      obj.endTime = TimeOfDay.toJSON(message.endTime);
    }
    if (message.days?.length) {
      obj.days = message.days.map((e) => dayOfWeekToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TimePeriod>): TimePeriod {
    return TimePeriod.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TimePeriod>): TimePeriod {
    const message = createBaseTimePeriod();
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? TimeOfDay.fromPartial(object.startTime)
      : undefined;
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? TimeOfDay.fromPartial(object.endTime)
      : undefined;
    message.days = object.days?.map((e) => e) || [];
    return message;
  },
};

function createBaseDimensions(): Dimensions {
  return { widthInches: 0, heightInches: 0, depthInches: 0 };
}

export const Dimensions: MessageFns<Dimensions> = {
  encode(message: Dimensions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.widthInches !== 0) {
      writer.uint32(13).float(message.widthInches);
    }
    if (message.heightInches !== 0) {
      writer.uint32(21).float(message.heightInches);
    }
    if (message.depthInches !== 0) {
      writer.uint32(29).float(message.depthInches);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dimensions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDimensions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.widthInches = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.heightInches = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.depthInches = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dimensions {
    return {
      widthInches: isSet(object.widthInches) ? globalThis.Number(object.widthInches) : 0,
      heightInches: isSet(object.heightInches) ? globalThis.Number(object.heightInches) : 0,
      depthInches: isSet(object.depthInches) ? globalThis.Number(object.depthInches) : 0,
    };
  },

  toJSON(message: Dimensions): unknown {
    const obj: any = {};
    if (message.widthInches !== 0) {
      obj.widthInches = message.widthInches;
    }
    if (message.heightInches !== 0) {
      obj.heightInches = message.heightInches;
    }
    if (message.depthInches !== 0) {
      obj.depthInches = message.depthInches;
    }
    return obj;
  },

  create(base?: DeepPartial<Dimensions>): Dimensions {
    return Dimensions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Dimensions>): Dimensions {
    const message = createBaseDimensions();
    message.widthInches = object.widthInches ?? 0;
    message.heightInches = object.heightInches ?? 0;
    message.depthInches = object.depthInches ?? 0;
    return message;
  },
};

function createBaseRackSpace(): RackSpace {
  return { startRackUnit: 0, endRackUnit: 0 };
}

export const RackSpace: MessageFns<RackSpace> = {
  encode(message: RackSpace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startRackUnit !== 0) {
      writer.uint32(8).int32(message.startRackUnit);
    }
    if (message.endRackUnit !== 0) {
      writer.uint32(16).int32(message.endRackUnit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RackSpace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRackSpace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.startRackUnit = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.endRackUnit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RackSpace {
    return {
      startRackUnit: isSet(object.startRackUnit) ? globalThis.Number(object.startRackUnit) : 0,
      endRackUnit: isSet(object.endRackUnit) ? globalThis.Number(object.endRackUnit) : 0,
    };
  },

  toJSON(message: RackSpace): unknown {
    const obj: any = {};
    if (message.startRackUnit !== 0) {
      obj.startRackUnit = Math.round(message.startRackUnit);
    }
    if (message.endRackUnit !== 0) {
      obj.endRackUnit = Math.round(message.endRackUnit);
    }
    return obj;
  },

  create(base?: DeepPartial<RackSpace>): RackSpace {
    return RackSpace.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RackSpace>): RackSpace {
    const message = createBaseRackSpace();
    message.startRackUnit = object.startRackUnit ?? 0;
    message.endRackUnit = object.endRackUnit ?? 0;
    return message;
  },
};

function createBaseHardwareLocation(): HardwareLocation {
  return { site: "", rackLocation: "", rackSpace: [] };
}

export const HardwareLocation: MessageFns<HardwareLocation> = {
  encode(message: HardwareLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.site !== "") {
      writer.uint32(10).string(message.site);
    }
    if (message.rackLocation !== "") {
      writer.uint32(18).string(message.rackLocation);
    }
    for (const v of message.rackSpace) {
      RackSpace.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HardwareLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHardwareLocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.site = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rackLocation = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.rackSpace.push(RackSpace.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HardwareLocation {
    return {
      site: isSet(object.site) ? globalThis.String(object.site) : "",
      rackLocation: isSet(object.rackLocation) ? globalThis.String(object.rackLocation) : "",
      rackSpace: globalThis.Array.isArray(object?.rackSpace)
        ? object.rackSpace.map((e: any) => RackSpace.fromJSON(e))
        : [],
    };
  },

  toJSON(message: HardwareLocation): unknown {
    const obj: any = {};
    if (message.site !== "") {
      obj.site = message.site;
    }
    if (message.rackLocation !== "") {
      obj.rackLocation = message.rackLocation;
    }
    if (message.rackSpace?.length) {
      obj.rackSpace = message.rackSpace.map((e) => RackSpace.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<HardwareLocation>): HardwareLocation {
    return HardwareLocation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HardwareLocation>): HardwareLocation {
    const message = createBaseHardwareLocation();
    message.site = object.site ?? "";
    message.rackLocation = object.rackLocation ?? "";
    message.rackSpace = object.rackSpace?.map((e) => RackSpace.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubscriptionConfig(): SubscriptionConfig {
  return { subscriptionId: "", billingId: "", state: 0 };
}

export const SubscriptionConfig: MessageFns<SubscriptionConfig> = {
  encode(message: SubscriptionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionId !== "") {
      writer.uint32(10).string(message.subscriptionId);
    }
    if (message.billingId !== "") {
      writer.uint32(18).string(message.billingId);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.billingId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionConfig {
    return {
      subscriptionId: isSet(object.subscriptionId) ? globalThis.String(object.subscriptionId) : "",
      billingId: isSet(object.billingId) ? globalThis.String(object.billingId) : "",
      state: isSet(object.state) ? subscriptionConfig_SubscriptionStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: SubscriptionConfig): unknown {
    const obj: any = {};
    if (message.subscriptionId !== "") {
      obj.subscriptionId = message.subscriptionId;
    }
    if (message.billingId !== "") {
      obj.billingId = message.billingId;
    }
    if (message.state !== 0) {
      obj.state = subscriptionConfig_SubscriptionStateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<SubscriptionConfig>): SubscriptionConfig {
    return SubscriptionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscriptionConfig>): SubscriptionConfig {
    const message = createBaseSubscriptionConfig();
    message.subscriptionId = object.subscriptionId ?? "";
    message.billingId = object.billingId ?? "";
    message.state = object.state ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
