// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dataplex/v1/catalog.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Operation } from "../../../longrunning/operations.js";
import { FieldMask } from "../../../protobuf/field_mask.js";
import { Struct } from "../../../protobuf/struct.js";
import { Timestamp } from "../../../protobuf/timestamp.js";

export const protobufPackage = "google.cloud.dataplex.v1";

/** View for controlling which parts of an entry are to be returned. */
export enum EntryView {
  /** ENTRY_VIEW_UNSPECIFIED - Unspecified EntryView. Defaults to FULL. */
  ENTRY_VIEW_UNSPECIFIED = 0,
  /** BASIC - Returns entry only, without aspects. */
  BASIC = 1,
  /**
   * FULL - Returns all required aspects as well as the keys of all non-required
   * aspects.
   */
  FULL = 2,
  /**
   * CUSTOM - Returns aspects matching custom fields in GetEntryRequest. If the number of
   * aspects would exceed 100, the first 100 will be returned.
   */
  CUSTOM = 3,
  /**
   * ALL - Returns all aspects. If the number of aspects would exceed 100, the first
   * 100 will be returned.
   */
  ALL = 4,
  UNRECOGNIZED = -1,
}

export function entryViewFromJSON(object: any): EntryView {
  switch (object) {
    case 0:
    case "ENTRY_VIEW_UNSPECIFIED":
      return EntryView.ENTRY_VIEW_UNSPECIFIED;
    case 1:
    case "BASIC":
      return EntryView.BASIC;
    case 2:
    case "FULL":
      return EntryView.FULL;
    case 3:
    case "CUSTOM":
      return EntryView.CUSTOM;
    case 4:
    case "ALL":
      return EntryView.ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EntryView.UNRECOGNIZED;
  }
}

export function entryViewToJSON(object: EntryView): string {
  switch (object) {
    case EntryView.ENTRY_VIEW_UNSPECIFIED:
      return "ENTRY_VIEW_UNSPECIFIED";
    case EntryView.BASIC:
      return "BASIC";
    case EntryView.FULL:
      return "FULL";
    case EntryView.CUSTOM:
      return "CUSTOM";
    case EntryView.ALL:
      return "ALL";
    case EntryView.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Denotes the transfer status of a resource. It is unspecified for resources
 * created from Dataplex API.
 */
export enum TransferStatus {
  /**
   * TRANSFER_STATUS_UNSPECIFIED - The default value. It is set for resources that were not subject for
   * migration from Data Catalog service.
   */
  TRANSFER_STATUS_UNSPECIFIED = 0,
  /**
   * TRANSFER_STATUS_MIGRATED - Indicates that a resource was migrated from Data Catalog service but it
   * hasn't been transferred yet. In particular the resource cannot be updated
   * from Dataplex API.
   */
  TRANSFER_STATUS_MIGRATED = 1,
  /**
   * TRANSFER_STATUS_TRANSFERRED - Indicates that a resource was transferred from Data Catalog service. The
   * resource can only be updated from Dataplex API.
   */
  TRANSFER_STATUS_TRANSFERRED = 2,
  UNRECOGNIZED = -1,
}

export function transferStatusFromJSON(object: any): TransferStatus {
  switch (object) {
    case 0:
    case "TRANSFER_STATUS_UNSPECIFIED":
      return TransferStatus.TRANSFER_STATUS_UNSPECIFIED;
    case 1:
    case "TRANSFER_STATUS_MIGRATED":
      return TransferStatus.TRANSFER_STATUS_MIGRATED;
    case 2:
    case "TRANSFER_STATUS_TRANSFERRED":
      return TransferStatus.TRANSFER_STATUS_TRANSFERRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TransferStatus.UNRECOGNIZED;
  }
}

export function transferStatusToJSON(object: TransferStatus): string {
  switch (object) {
    case TransferStatus.TRANSFER_STATUS_UNSPECIFIED:
      return "TRANSFER_STATUS_UNSPECIFIED";
    case TransferStatus.TRANSFER_STATUS_MIGRATED:
      return "TRANSFER_STATUS_MIGRATED";
    case TransferStatus.TRANSFER_STATUS_TRANSFERRED:
      return "TRANSFER_STATUS_TRANSFERRED";
    case TransferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Aspect Type is a template for creating Aspects, and represents the
 * JSON-schema for a given Entry, e.g., BigQuery Table Schema.
 */
export interface AspectType {
  /**
   * Output only. The relative resource name of the AspectType, of the form:
   * projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}.
   */
  name: string;
  /**
   * Output only. System generated globally unique ID for the AspectType. This
   * ID will be different if the AspectType is deleted and re-created with the
   * same name.
   */
  uid: string;
  /** Output only. The time when the AspectType was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the AspectType was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. Description of the AspectType. */
  description: string;
  /** Optional. User friendly display name. */
  displayName: string;
  /** Optional. User-defined labels for the AspectType. */
  labels: { [key: string]: string };
  /**
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /** Immutable. Authorization defined for this type. */
  authorization:
    | AspectType_Authorization
    | undefined;
  /** Required. MetadataTemplate of the aspect. */
  metadataTemplate:
    | AspectType_MetadataTemplate
    | undefined;
  /**
   * Output only. Denotes the transfer status of the Aspect Type. It is
   * unspecified for Aspect Types created from Dataplex API.
   */
  transferStatus: TransferStatus;
}

/** Autorization for an Aspect Type. */
export interface AspectType_Authorization {
  /**
   * Immutable. The IAM permission grantable on the Entry Group to allow
   * access to instantiate Aspects of Dataplex owned Aspect Types, only
   * settable for Dataplex owned Types.
   */
  alternateUsePermission: string;
}

/** MetadataTemplate definition for AspectType */
export interface AspectType_MetadataTemplate {
  /**
   * Optional. Index is used to encode Template messages. The value of index
   * can range between 1 and 2,147,483,647. Index must be unique within all
   * fields in a Template. (Nested Templates can reuse indexes). Once a
   * Template is defined, the index cannot be changed, because it identifies
   * the field in the actual storage format. Index is a mandatory field, but
   * it is optional for top level fields, and map/array "values" definitions.
   */
  index: number;
  /** Required. The name of the field. */
  name: string;
  /**
   * Required. The datatype of this field. The following values are supported:
   * Primitive types (string, integer, boolean, double, datetime); datetime
   * must be of the format RFC3339 UTC "Zulu" (Examples:
   * "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z"). Complex
   * types (enum, array, map, record).
   */
  type: string;
  /**
   * Optional. Field definition, needs to be specified if the type is record.
   * Defines the nested fields.
   */
  recordFields: AspectType_MetadataTemplate[];
  /**
   * Optional. The list of values for an enum type. Needs to be defined if the
   * type is enum.
   */
  enumValues: AspectType_MetadataTemplate_EnumValue[];
  /**
   * Optional. map_items needs to be set if the type is map. map_items can
   * refer to a primitive field or a complex (record only) field. To specify a
   * primitive field, just name and type needs to be set in the nested
   * MetadataTemplate. The recommended value for the name field is item, as
   * this is not used in the actual payload.
   */
  mapItems:
    | AspectType_MetadataTemplate
    | undefined;
  /**
   * Optional. array_items needs to be set if the type is array. array_items
   * can refer to a primitive field or a complex (record only) field. To
   * specify a primitive field, just name and type needs to be set in the
   * nested MetadataTemplate. The recommended value for the name field is
   * item, as this is not used in the actual payload.
   */
  arrayItems:
    | AspectType_MetadataTemplate
    | undefined;
  /**
   * Optional. Id can be used if this definition of the field needs to be
   * reused later. Id needs to be unique across the entire template. Id can
   * only be specified if the field type is record.
   */
  typeId: string;
  /**
   * Optional. A reference to another field definition (instead of an inline
   * definition). The value must be equal to the value of an id field defined
   * elsewhere in the MetadataTemplate. Only fields with type as record can
   * refer to other fields.
   */
  typeRef: string;
  /** Optional. Specifies the constraints on this field. */
  constraints:
    | AspectType_MetadataTemplate_Constraints
    | undefined;
  /** Optional. Specifies annotations on this field. */
  annotations: AspectType_MetadataTemplate_Annotations | undefined;
}

/** Definition of Enumvalue (to be used by enum fields) */
export interface AspectType_MetadataTemplate_EnumValue {
  /** Required. Index for the enum. Cannot be modified. */
  index: number;
  /**
   * Required. Name of the enumvalue. This is the actual value that the
   * aspect will contain.
   */
  name: string;
  /**
   * Optional. Optional deprecation message to be set if an enum value needs
   * to be deprecated.
   */
  deprecated: string;
}

/** Definition of the constraints of a field */
export interface AspectType_MetadataTemplate_Constraints {
  /** Optional. Marks this as an optional/required field. */
  required: boolean;
}

/** Definition of the annotations of a field */
export interface AspectType_MetadataTemplate_Annotations {
  /**
   * Optional. Marks a field as deprecated, a deprecation message can be
   * included.
   */
  deprecated: string;
  /** Optional. Specify a displayname for a field. */
  displayName: string;
  /** Optional. Specify a description for a field */
  description: string;
  /**
   * Optional. Specify a display order for a field. Display order can be
   * used to reorder where a field is rendered
   */
  displayOrder: number;
  /**
   * Optional. String Type annotations can be used to specify special
   * meaning to string fields. The following values are supported: richText:
   * The field must be interpreted as a rich text field. url: A fully
   * qualified url link. resource: A service qualified resource reference.
   */
  stringType: string;
  /**
   * Optional. Suggested hints for string fields. These can be used to
   * suggest values to users, through an UI for example.
   */
  stringValues: string[];
}

export interface AspectType_LabelsEntry {
  key: string;
  value: string;
}

/** An Entry Group represents a logical grouping of one or more Entries. */
export interface EntryGroup {
  /**
   * Output only. The relative resource name of the EntryGroup, of the form:
   * projects/{project_number}/locations/{location_id}/entryGroups/{entry_group_id}.
   */
  name: string;
  /**
   * Output only. System generated globally unique ID for the EntryGroup. This
   * ID will be different if the EntryGroup is deleted and re-created with the
   * same name.
   */
  uid: string;
  /** Output only. The time when the EntryGroup was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the EntryGroup was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. Description of the EntryGroup. */
  description: string;
  /** Optional. User friendly display name. */
  displayName: string;
  /** Optional. User-defined labels for the EntryGroup. */
  labels: { [key: string]: string };
  /**
   * This checksum is computed by the server based on the value of other
   * fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /**
   * Output only. Denotes the transfer status of the Entry Group. It is
   * unspecified for Entry Group created from Dataplex API.
   */
  transferStatus: TransferStatus;
}

export interface EntryGroup_LabelsEntry {
  key: string;
  value: string;
}

/** Entry Type is a template for creating Entries. */
export interface EntryType {
  /**
   * Output only. The relative resource name of the EntryType, of the form:
   * projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}.
   */
  name: string;
  /**
   * Output only. System generated globally unique ID for the EntryType. This ID
   * will be different if the EntryType is deleted and re-created with the same
   * name.
   */
  uid: string;
  /** Output only. The time when the EntryType was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the EntryType was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. Description of the EntryType. */
  description: string;
  /** Optional. User friendly display name. */
  displayName: string;
  /** Optional. User-defined labels for the EntryType. */
  labels: { [key: string]: string };
  /**
   * Optional. This checksum is computed by the server based on the value of
   * other fields, and may be sent on update and delete requests to ensure the
   * client has an up-to-date value before proceeding.
   */
  etag: string;
  /**
   * Optional. Indicates the class this Entry Type belongs to, for example,
   * TABLE, DATABASE, MODEL.
   */
  typeAliases: string[];
  /** Optional. The platform that Entries of this type belongs to. */
  platform: string;
  /**
   * Optional. The system that Entries of this type belongs to. Examples include
   * CloudSQL, MariaDB etc
   */
  system: string;
  /** AspectInfo for the entry type. */
  requiredAspects: EntryType_AspectInfo[];
  /** Immutable. Authorization defined for this type. */
  authorization: EntryType_Authorization | undefined;
}

export interface EntryType_AspectInfo {
  /** Required aspect type for the entry type. */
  type: string;
}

/** Authorization for an Entry Type. */
export interface EntryType_Authorization {
  /**
   * Immutable. The IAM permission grantable on the Entry Group to allow
   * access to instantiate Entries of Dataplex owned Entry Types, only
   * settable for Dataplex owned Types.
   */
  alternateUsePermission: string;
}

export interface EntryType_LabelsEntry {
  key: string;
  value: string;
}

/** An aspect is a single piece of metadata describing an entry. */
export interface Aspect {
  /** Output only. The resource name of the type used to create this Aspect. */
  aspectType: string;
  /** Output only. The path in the entry under which the aspect is attached. */
  path: string;
  /** Output only. The time when the Aspect was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the Aspect was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Required. The content of the aspect, according to its aspect type schema.
   * This will replace `content`.
   * The maximum size of the field is 120KB (encoded as UTF-8).
   */
  data: { [key: string]: any } | undefined;
  aspectSource: AspectSource | undefined;
}

/**
 * AspectSource contains source system related information for the
 * aspect.
 */
export interface AspectSource {
  /** The create time of the aspect in the source system. */
  createTime:
    | Date
    | undefined;
  /** The update time of the aspect in the source system. */
  updateTime: Date | undefined;
}

/**
 * An entry is a representation of a data asset which can be described by
 * various metadata.
 */
export interface Entry {
  /**
   * Identifier. The relative resource name of the Entry, of the form:
   * projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}.
   */
  name: string;
  /**
   * Required. Immutable. The resource name of the EntryType used to create this
   * Entry.
   */
  entryType: string;
  /** Output only. The time when the Entry was created. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the Entry was last updated. */
  updateTime:
    | Date
    | undefined;
  /**
   * Optional. The Aspects attached to the Entry.
   * The format for the key can be one of the following:
   * 1. {projectId}.{locationId}.{aspectTypeId} (if the aspect is attached
   * directly to the entry)
   * 2. {projectId}.{locationId}.{aspectTypeId}@{path} (if the aspect is
   * attached to an entry's path)
   */
  aspects: { [key: string]: Aspect };
  /** Optional. Immutable. The resource name of the parent entry. */
  parentEntry: string;
  /**
   * Optional. A name for the entry that can reference it in an external system.
   * The maximum size of the field is 4000 characters.
   */
  fullyQualifiedName: string;
  /** Optional. Source system related information for an entry. */
  entrySource: EntrySource | undefined;
}

export interface Entry_AspectsEntry {
  key: string;
  value: Aspect | undefined;
}

/**
 * EntrySource contains source system related information for the
 * entry.
 */
export interface EntrySource {
  /**
   * The name of the resource in the source system.
   * The maximum size of the field is 4000 characters.
   */
  resource: string;
  /**
   * The name of the source system.
   * The maximum size of the field is 64 characters.
   */
  system: string;
  /**
   * The platform containing the source system.
   * The maximum size of the field is 64 characters.
   */
  platform: string;
  /**
   * User friendly display name.
   * The maximum size of the field is 500 characters.
   */
  displayName: string;
  /**
   * Description of the Entry.
   * The maximum size of the field is 2000 characters.
   */
  description: string;
  /**
   * User-defined labels.
   * The maximum size of keys and values is 128 characters each.
   */
  labels: { [key: string]: string };
  /** Immutable. The ancestors of the Entry in the source system. */
  ancestors: EntrySource_Ancestor[];
  /** The create time of the resource in the source system. */
  createTime:
    | Date
    | undefined;
  /** The update time of the resource in the source system. */
  updateTime:
    | Date
    | undefined;
  /**
   * Output only. Location of the resource in the source system. Entry will be
   * searchable by this location. By default, this should match the location of
   * the EntryGroup containing this entry. A different value allows capturing
   * source location for data external to GCP.
   */
  location: string;
}

/**
 * Ancestor contains information about individual items in the hierarchy of
 * an Entry.
 */
export interface EntrySource_Ancestor {
  /** Optional. The name of the ancestor resource. */
  name: string;
  /** Optional. The type of the ancestor resource. */
  type: string;
}

export interface EntrySource_LabelsEntry {
  key: string;
  value: string;
}

/** Create EntryGroup Request */
export interface CreateEntryGroupRequest {
  /**
   * Required. The resource name of the entryGroup, of the form:
   * projects/{project_number}/locations/{location_id}
   * where `location_id` refers to a GCP region.
   */
  parent: string;
  /** Required. EntryGroup identifier. */
  entryGroupId: string;
  /** Required. EntryGroup Resource */
  entryGroup:
    | EntryGroup
    | undefined;
  /**
   * Optional. Only validate the request, but do not perform mutations.
   * The default is false.
   */
  validateOnly: boolean;
}

/** Update EntryGroup Request */
export interface UpdateEntryGroupRequest {
  /** Required. EntryGroup Resource */
  entryGroup:
    | EntryGroup
    | undefined;
  /** Required. Mask of fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. Only validate the request, but do not perform mutations.
   * The default is false.
   */
  validateOnly: boolean;
}

/** Delele EntryGroup Request */
export interface DeleteEntryGroupRequest {
  /**
   * Required. The resource name of the EntryGroup:
   * `projects/{project_number}/locations/{location_id}/entryGroups/{entry_group_id}`.
   */
  name: string;
  /**
   * Optional. If the client provided etag value does not match the current etag
   * value, the DeleteEntryGroupRequest method returns an ABORTED error response
   */
  etag: string;
}

/** List entryGroups request. */
export interface ListEntryGroupsRequest {
  /**
   * Required. The resource name of the entryGroup location, of the form:
   * `projects/{project_number}/locations/{location_id}`
   * where `location_id` refers to a GCP region.
   */
  parent: string;
  /**
   * Optional. Maximum number of EntryGroups to return. The service may return
   * fewer than this value. If unspecified, at most 10 EntryGroups will be
   * returned. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * Optional. Page token received from a previous `ListEntryGroups` call.
   * Provide this to retrieve the subsequent page. When paginating, all other
   * parameters provided to `ListEntryGroups` must match the call that provided
   * the page token.
   */
  pageToken: string;
  /** Optional. Filter request. */
  filter: string;
  /** Optional. Order by fields for the result. */
  orderBy: string;
}

/** List ListEntryGroups response. */
export interface ListEntryGroupsResponse {
  /** ListEntryGroups under the given parent location. */
  entryGroups: EntryGroup[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachableLocations: string[];
}

/** Get EntryGroup request. */
export interface GetEntryGroupRequest {
  /**
   * Required. The resource name of the EntryGroup:
   * `projects/{project_number}/locations/{location_id}/entryGroups/{entry_group_id}`.
   */
  name: string;
}

/** Create EntryType Request */
export interface CreateEntryTypeRequest {
  /**
   * Required. The resource name of the EntryType, of the form:
   * projects/{project_number}/locations/{location_id}
   * where `location_id` refers to a GCP region.
   */
  parent: string;
  /** Required. EntryType identifier. */
  entryTypeId: string;
  /** Required. EntryType Resource */
  entryType:
    | EntryType
    | undefined;
  /**
   * Optional. Only validate the request, but do not perform mutations.
   * The default is false.
   */
  validateOnly: boolean;
}

/** Update EntryType Request */
export interface UpdateEntryTypeRequest {
  /** Required. EntryType Resource */
  entryType:
    | EntryType
    | undefined;
  /** Required. Mask of fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. Only validate the request, but do not perform mutations.
   * The default is false.
   */
  validateOnly: boolean;
}

/** Delele EntryType Request */
export interface DeleteEntryTypeRequest {
  /**
   * Required. The resource name of the EntryType:
   * `projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}`.
   */
  name: string;
  /**
   * Optional. If the client provided etag value does not match the current etag
   * value, the DeleteEntryTypeRequest method returns an ABORTED error response
   */
  etag: string;
}

/** List EntryTypes request */
export interface ListEntryTypesRequest {
  /**
   * Required. The resource name of the EntryType location, of the form:
   * `projects/{project_number}/locations/{location_id}`
   * where `location_id` refers to a GCP region.
   */
  parent: string;
  /**
   * Optional. Maximum number of EntryTypes to return. The service may return
   * fewer than this value. If unspecified, at most 10 EntryTypes will be
   * returned. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * Optional. Page token received from a previous `ListEntryTypes` call.
   * Provide this to retrieve the subsequent page. When paginating, all other
   * parameters provided to `ListEntryTypes` must match the call that provided
   * the page token.
   */
  pageToken: string;
  /**
   * Optional. Filter request. Filters are case-sensitive.
   * The following formats are supported:
   *
   * labels.key1 = "value1"
   * labels:key1
   * name = "value"
   * These restrictions can be coinjoined with AND, OR and NOT conjunctions.
   */
  filter: string;
  /**
   * Optional. Order by fields (`name` or `create_time`) for the result.
   * If not specified, the ordering is undefined.
   */
  orderBy: string;
}

/** List EntryTypes response */
export interface ListEntryTypesResponse {
  /** ListEntryTypes under the given parent location. */
  entryTypes: EntryType[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachableLocations: string[];
}

/** Get EntryType request */
export interface GetEntryTypeRequest {
  /**
   * Required. The resource name of the EntryType:
   * `projects/{project_number}/locations/{location_id}/entryTypes/{entry_type_id}`.
   */
  name: string;
}

/** Create AspectType Request */
export interface CreateAspectTypeRequest {
  /**
   * Required. The resource name of the AspectType, of the form:
   * projects/{project_number}/locations/{location_id}
   * where `location_id` refers to a GCP region.
   */
  parent: string;
  /** Required. AspectType identifier. */
  aspectTypeId: string;
  /** Required. AspectType Resource */
  aspectType:
    | AspectType
    | undefined;
  /**
   * Optional. Only validate the request, but do not perform mutations.
   * The default is false.
   */
  validateOnly: boolean;
}

/** Update AspectType Request */
export interface UpdateAspectTypeRequest {
  /** Required. AspectType Resource */
  aspectType:
    | AspectType
    | undefined;
  /** Required. Mask of fields to update. */
  updateMask:
    | string[]
    | undefined;
  /**
   * Optional. Only validate the request, but do not perform mutations.
   * The default is false.
   */
  validateOnly: boolean;
}

/** Delele AspectType Request */
export interface DeleteAspectTypeRequest {
  /**
   * Required. The resource name of the AspectType:
   * `projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}`.
   */
  name: string;
  /**
   * Optional. If the client provided etag value does not match the current etag
   * value, the DeleteAspectTypeRequest method returns an ABORTED error response
   */
  etag: string;
}

/** List AspectTypes request */
export interface ListAspectTypesRequest {
  /**
   * Required. The resource name of the AspectType location, of the form:
   * `projects/{project_number}/locations/{location_id}`
   * where `location_id` refers to a GCP region.
   */
  parent: string;
  /**
   * Optional. Maximum number of AspectTypes to return. The service may return
   * fewer than this value. If unspecified, at most 10 AspectTypes will be
   * returned. The maximum value is 1000; values above 1000 will be coerced to
   * 1000.
   */
  pageSize: number;
  /**
   * Optional. Page token received from a previous `ListAspectTypes` call.
   * Provide this to retrieve the subsequent page. When paginating, all other
   * parameters provided to `ListAspectTypes` must match the call that provided
   * the page token.
   */
  pageToken: string;
  /**
   * Optional. Filter request. Filters are case-sensitive.
   * The following formats are supported:
   *
   * labels.key1 = "value1"
   * labels:key1
   * name = "value"
   * These restrictions can be coinjoined with AND, OR and NOT conjunctions.
   */
  filter: string;
  /**
   * Optional. Order by fields (`name` or `create_time`) for the result.
   * If not specified, the ordering is undefined.
   */
  orderBy: string;
}

/** List AspectTypes response */
export interface ListAspectTypesResponse {
  /** ListAspectTypes under the given parent location. */
  aspectTypes: AspectType[];
  /**
   * Token to retrieve the next page of results, or empty if there are no more
   * results in the list.
   */
  nextPageToken: string;
  /** Locations that could not be reached. */
  unreachableLocations: string[];
}

/** Get AspectType request */
export interface GetAspectTypeRequest {
  /**
   * Required. The resource name of the AspectType:
   * `projects/{project_number}/locations/{location_id}/aspectTypes/{aspect_type_id}`.
   */
  name: string;
}

export interface CreateEntryRequest {
  /**
   * Required. The resource name of the parent Entry Group:
   * `projects/{project}/locations/{location}/entryGroups/{entry_group}`.
   */
  parent: string;
  /**
   * Required. Entry identifier. It has to be unique within an Entry Group.
   *
   * Entries corresponding to Google Cloud resources use Entry ID format based
   * on Full Resource Names
   * (https://cloud.google.com/apis/design/resource_names#full_resource_name).
   * The format is a Full Resource Name of the resource without the
   * prefix double slashes in the API Service Name part of Full Resource Name.
   * This allows retrieval of entries using their associated resource name.
   *
   * For example if the Full Resource Name of a resource is
   * `//library.googleapis.com/shelves/shelf1/books/book2`,
   * then the suggested entry_id is
   * `library.googleapis.com/shelves/shelf1/books/book2`.
   *
   * It is also suggested to follow the same convention for entries
   * corresponding to resources from other providers or systems than Google
   * Cloud.
   *
   * The maximum size of the field is 4000 characters.
   */
  entryId: string;
  /** Required. Entry resource. */
  entry: Entry | undefined;
}

export interface UpdateEntryRequest {
  /** Required. Entry resource. */
  entry:
    | Entry
    | undefined;
  /**
   * Optional. Mask of fields to update. To update Aspects, the update_mask must
   * contain the value "aspects".
   *
   * If the update_mask is empty, all modifiable fields present in the request
   * will be updated.
   */
  updateMask:
    | string[]
    | undefined;
  /** Optional. If set to true and the entry does not exist, it will be created. */
  allowMissing: boolean;
  /**
   * Optional. If set to true and the aspect_keys specify aspect ranges, any
   * existing aspects from that range not provided in the request will be
   * deleted.
   */
  deleteMissingAspects: boolean;
  /**
   * Optional. The map keys of the Aspects which should be modified. Supports
   * the following syntaxes:
   * * <aspect_type_reference> - matches aspect on given type and empty path
   * * <aspect_type_reference>@path - matches aspect on given type and specified
   * path
   * * <aspect_type_reference>* - matches aspects on given type for all paths
   * * *@path - matches aspects of all types on the given path
   *
   * Existing aspects matching the syntax will not be removed unless
   * `delete_missing_aspects` is set to true.
   *
   * If this field is left empty, it will be treated as specifying exactly those
   * Aspects present in the request.
   */
  aspectKeys: string[];
}

export interface DeleteEntryRequest {
  /**
   * Required. The resource name of the Entry:
   * `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
   */
  name: string;
}

export interface ListEntriesRequest {
  /**
   * Required. The resource name of the parent Entry Group:
   * `projects/{project}/locations/{location}/entryGroups/{entry_group}`.
   */
  parent: string;
  pageSize: number;
  /** Optional. The pagination token returned by a previous request. */
  pageToken: string;
  /**
   * Optional. A filter on the entries to return.
   * Filters are case-sensitive.
   * The request can be filtered by the following fields:
   * entry_type, entry_source.display_name.
   * The comparison operators are =, !=, <, >, <=, >= (strings are compared
   * according to lexical order)
   * The logical operators AND, OR, NOT can be used
   * in the filter. Wildcard "*" can be used, but for entry_type the full
   * project id or number needs to be provided. Example filter expressions:
   * "entry_source.display_name=AnExampleDisplayName"
   * "entry_type=projects/example-project/locations/global/entryTypes/example-entry_type"
   * "entry_type=projects/example-project/locations/us/entryTypes/a* OR
   *  entry_type=projects/another-project/locations/*"
   * "NOT entry_source.display_name=AnotherExampleDisplayName"
   */
  filter: string;
}

export interface ListEntriesResponse {
  /** The list of entries. */
  entries: Entry[];
  /** Pagination token. */
  nextPageToken: string;
}

export interface GetEntryRequest {
  /**
   * Required. The resource name of the Entry:
   * `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
   */
  name: string;
  /** Optional. View for controlling which parts of an entry are to be returned. */
  view: EntryView;
  /**
   * Optional. Limits the aspects returned to the provided aspect types.
   * Only works if the CUSTOM view is selected.
   */
  aspectTypes: string[];
  /**
   * Optional. Limits the aspects returned to those associated with the provided
   * paths within the Entry. Only works if the CUSTOM view is selected.
   */
  paths: string[];
}

export interface LookupEntryRequest {
  /**
   * Required. The project to which the request should be attributed in the
   * following form: `projects/{project}/locations/{location}`.
   */
  name: string;
  /** Optional. View for controlling which parts of an entry are to be returned. */
  view: EntryView;
  /**
   * Optional. Limits the aspects returned to the provided aspect types.
   * Only works if the CUSTOM view is selected.
   */
  aspectTypes: string[];
  /**
   * Optional. Limits the aspects returned to those associated with the provided
   * paths within the Entry. Only works if the CUSTOM view is selected.
   */
  paths: string[];
  /**
   * Required. The resource name of the Entry:
   * `projects/{project}/locations/{location}/entryGroups/{entry_group}/entries/{entry}`.
   */
  entry: string;
}

export interface SearchEntriesRequest {
  /**
   * Required. The project to which the request should be attributed in the
   * following form: `projects/{project}/locations/{location}`.
   */
  name: string;
  /** Required. The query against which entries in scope should be matched. */
  query: string;
  /** Optional. Pagination. */
  pageSize: number;
  pageToken: string;
  /** Optional. Ordering of the results. Supported options to be added later. */
  orderBy: string;
  /**
   * Optional. The scope under which the search should be operating. Should
   * either be organizations/<org_id> or projects/<project_ref>. If left
   * unspecified, it will default to the organization where the project provided
   * in `name` is located.
   */
  scope: string;
}

/** A single result of a SearchEntries request. */
export interface SearchEntriesResult {
  /**
   * Linked resource name.
   *
   * @deprecated
   */
  linkedResource: string;
  dataplexEntry:
    | Entry
    | undefined;
  /**
   * Snippets.
   *
   * @deprecated
   */
  snippets: SearchEntriesResult_Snippets | undefined;
}

/**
 * Snippets for the entry, contains HTML-style highlighting for
 * matched tokens, will be used in UI.
 *
 * @deprecated
 */
export interface SearchEntriesResult_Snippets {
  /**
   * Entry
   *
   * @deprecated
   */
  dataplexEntry: Entry | undefined;
}

export interface SearchEntriesResponse {
  /** The results matching the search query. */
  results: SearchEntriesResult[];
  /**
   * The estimated total number of matching entries. Not guaranteed to be
   * accurate.
   */
  totalSize: number;
  /** Pagination token. */
  nextPageToken: string;
  /**
   * Unreachable locations. Search results don't include data from those
   * locations.
   */
  unreachable: string[];
}

function createBaseAspectType(): AspectType {
  return {
    name: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    description: "",
    displayName: "",
    labels: {},
    etag: "",
    authorization: undefined,
    metadataTemplate: undefined,
    transferStatus: 0,
  };
}

export const AspectType: MessageFns<AspectType> = {
  encode(message: AspectType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.displayName !== "") {
      writer.uint32(50).string(message.displayName);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      AspectType_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(66).string(message.etag);
    }
    if (message.authorization !== undefined) {
      AspectType_Authorization.encode(message.authorization, writer.uint32(418).fork()).join();
    }
    if (message.metadataTemplate !== undefined) {
      AspectType_MetadataTemplate.encode(message.metadataTemplate, writer.uint32(426).fork()).join();
    }
    if (message.transferStatus !== 0) {
      writer.uint32(1616).int32(message.transferStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AspectType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAspectType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = AspectType_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }

          message.authorization = AspectType_Authorization.decode(reader, reader.uint32());
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }

          message.metadataTemplate = AspectType_MetadataTemplate.decode(reader, reader.uint32());
          continue;
        case 202:
          if (tag !== 1616) {
            break;
          }

          message.transferStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AspectType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      authorization: isSet(object.authorization) ? AspectType_Authorization.fromJSON(object.authorization) : undefined,
      metadataTemplate: isSet(object.metadataTemplate)
        ? AspectType_MetadataTemplate.fromJSON(object.metadataTemplate)
        : undefined,
      transferStatus: isSet(object.transferStatus) ? transferStatusFromJSON(object.transferStatus) : 0,
    };
  },

  toJSON(message: AspectType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.authorization !== undefined) {
      obj.authorization = AspectType_Authorization.toJSON(message.authorization);
    }
    if (message.metadataTemplate !== undefined) {
      obj.metadataTemplate = AspectType_MetadataTemplate.toJSON(message.metadataTemplate);
    }
    if (message.transferStatus !== 0) {
      obj.transferStatus = transferStatusToJSON(message.transferStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<AspectType>): AspectType {
    return AspectType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AspectType>): AspectType {
    const message = createBaseAspectType();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.description = object.description ?? "";
    message.displayName = object.displayName ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.etag = object.etag ?? "";
    message.authorization = (object.authorization !== undefined && object.authorization !== null)
      ? AspectType_Authorization.fromPartial(object.authorization)
      : undefined;
    message.metadataTemplate = (object.metadataTemplate !== undefined && object.metadataTemplate !== null)
      ? AspectType_MetadataTemplate.fromPartial(object.metadataTemplate)
      : undefined;
    message.transferStatus = object.transferStatus ?? 0;
    return message;
  },
};

function createBaseAspectType_Authorization(): AspectType_Authorization {
  return { alternateUsePermission: "" };
}

export const AspectType_Authorization: MessageFns<AspectType_Authorization> = {
  encode(message: AspectType_Authorization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alternateUsePermission !== "") {
      writer.uint32(10).string(message.alternateUsePermission);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AspectType_Authorization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAspectType_Authorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.alternateUsePermission = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AspectType_Authorization {
    return {
      alternateUsePermission: isSet(object.alternateUsePermission)
        ? globalThis.String(object.alternateUsePermission)
        : "",
    };
  },

  toJSON(message: AspectType_Authorization): unknown {
    const obj: any = {};
    if (message.alternateUsePermission !== "") {
      obj.alternateUsePermission = message.alternateUsePermission;
    }
    return obj;
  },

  create(base?: DeepPartial<AspectType_Authorization>): AspectType_Authorization {
    return AspectType_Authorization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AspectType_Authorization>): AspectType_Authorization {
    const message = createBaseAspectType_Authorization();
    message.alternateUsePermission = object.alternateUsePermission ?? "";
    return message;
  },
};

function createBaseAspectType_MetadataTemplate(): AspectType_MetadataTemplate {
  return {
    index: 0,
    name: "",
    type: "",
    recordFields: [],
    enumValues: [],
    mapItems: undefined,
    arrayItems: undefined,
    typeId: "",
    typeRef: "",
    constraints: undefined,
    annotations: undefined,
  };
}

export const AspectType_MetadataTemplate: MessageFns<AspectType_MetadataTemplate> = {
  encode(message: AspectType_MetadataTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(42).string(message.type);
    }
    for (const v of message.recordFields) {
      AspectType_MetadataTemplate.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.enumValues) {
      AspectType_MetadataTemplate_EnumValue.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.mapItems !== undefined) {
      AspectType_MetadataTemplate.encode(message.mapItems, writer.uint32(82).fork()).join();
    }
    if (message.arrayItems !== undefined) {
      AspectType_MetadataTemplate.encode(message.arrayItems, writer.uint32(90).fork()).join();
    }
    if (message.typeId !== "") {
      writer.uint32(98).string(message.typeId);
    }
    if (message.typeRef !== "") {
      writer.uint32(106).string(message.typeRef);
    }
    if (message.constraints !== undefined) {
      AspectType_MetadataTemplate_Constraints.encode(message.constraints, writer.uint32(402).fork()).join();
    }
    if (message.annotations !== undefined) {
      AspectType_MetadataTemplate_Annotations.encode(message.annotations, writer.uint32(410).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AspectType_MetadataTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAspectType_MetadataTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.type = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.recordFields.push(AspectType_MetadataTemplate.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.enumValues.push(AspectType_MetadataTemplate_EnumValue.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.mapItems = AspectType_MetadataTemplate.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.arrayItems = AspectType_MetadataTemplate.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.typeId = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.typeRef = reader.string();
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.constraints = AspectType_MetadataTemplate_Constraints.decode(reader, reader.uint32());
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.annotations = AspectType_MetadataTemplate_Annotations.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AspectType_MetadataTemplate {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      recordFields: globalThis.Array.isArray(object?.recordFields)
        ? object.recordFields.map((e: any) => AspectType_MetadataTemplate.fromJSON(e))
        : [],
      enumValues: globalThis.Array.isArray(object?.enumValues)
        ? object.enumValues.map((e: any) => AspectType_MetadataTemplate_EnumValue.fromJSON(e))
        : [],
      mapItems: isSet(object.mapItems) ? AspectType_MetadataTemplate.fromJSON(object.mapItems) : undefined,
      arrayItems: isSet(object.arrayItems) ? AspectType_MetadataTemplate.fromJSON(object.arrayItems) : undefined,
      typeId: isSet(object.typeId) ? globalThis.String(object.typeId) : "",
      typeRef: isSet(object.typeRef) ? globalThis.String(object.typeRef) : "",
      constraints: isSet(object.constraints)
        ? AspectType_MetadataTemplate_Constraints.fromJSON(object.constraints)
        : undefined,
      annotations: isSet(object.annotations)
        ? AspectType_MetadataTemplate_Annotations.fromJSON(object.annotations)
        : undefined,
    };
  },

  toJSON(message: AspectType_MetadataTemplate): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.recordFields?.length) {
      obj.recordFields = message.recordFields.map((e) => AspectType_MetadataTemplate.toJSON(e));
    }
    if (message.enumValues?.length) {
      obj.enumValues = message.enumValues.map((e) => AspectType_MetadataTemplate_EnumValue.toJSON(e));
    }
    if (message.mapItems !== undefined) {
      obj.mapItems = AspectType_MetadataTemplate.toJSON(message.mapItems);
    }
    if (message.arrayItems !== undefined) {
      obj.arrayItems = AspectType_MetadataTemplate.toJSON(message.arrayItems);
    }
    if (message.typeId !== "") {
      obj.typeId = message.typeId;
    }
    if (message.typeRef !== "") {
      obj.typeRef = message.typeRef;
    }
    if (message.constraints !== undefined) {
      obj.constraints = AspectType_MetadataTemplate_Constraints.toJSON(message.constraints);
    }
    if (message.annotations !== undefined) {
      obj.annotations = AspectType_MetadataTemplate_Annotations.toJSON(message.annotations);
    }
    return obj;
  },

  create(base?: DeepPartial<AspectType_MetadataTemplate>): AspectType_MetadataTemplate {
    return AspectType_MetadataTemplate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AspectType_MetadataTemplate>): AspectType_MetadataTemplate {
    const message = createBaseAspectType_MetadataTemplate();
    message.index = object.index ?? 0;
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.recordFields = object.recordFields?.map((e) => AspectType_MetadataTemplate.fromPartial(e)) || [];
    message.enumValues = object.enumValues?.map((e) => AspectType_MetadataTemplate_EnumValue.fromPartial(e)) || [];
    message.mapItems = (object.mapItems !== undefined && object.mapItems !== null)
      ? AspectType_MetadataTemplate.fromPartial(object.mapItems)
      : undefined;
    message.arrayItems = (object.arrayItems !== undefined && object.arrayItems !== null)
      ? AspectType_MetadataTemplate.fromPartial(object.arrayItems)
      : undefined;
    message.typeId = object.typeId ?? "";
    message.typeRef = object.typeRef ?? "";
    message.constraints = (object.constraints !== undefined && object.constraints !== null)
      ? AspectType_MetadataTemplate_Constraints.fromPartial(object.constraints)
      : undefined;
    message.annotations = (object.annotations !== undefined && object.annotations !== null)
      ? AspectType_MetadataTemplate_Annotations.fromPartial(object.annotations)
      : undefined;
    return message;
  },
};

function createBaseAspectType_MetadataTemplate_EnumValue(): AspectType_MetadataTemplate_EnumValue {
  return { index: 0, name: "", deprecated: "" };
}

export const AspectType_MetadataTemplate_EnumValue: MessageFns<AspectType_MetadataTemplate_EnumValue> = {
  encode(message: AspectType_MetadataTemplate_EnumValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.deprecated !== "") {
      writer.uint32(26).string(message.deprecated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AspectType_MetadataTemplate_EnumValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAspectType_MetadataTemplate_EnumValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.deprecated = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AspectType_MetadataTemplate_EnumValue {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      deprecated: isSet(object.deprecated) ? globalThis.String(object.deprecated) : "",
    };
  },

  toJSON(message: AspectType_MetadataTemplate_EnumValue): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.deprecated !== "") {
      obj.deprecated = message.deprecated;
    }
    return obj;
  },

  create(base?: DeepPartial<AspectType_MetadataTemplate_EnumValue>): AspectType_MetadataTemplate_EnumValue {
    return AspectType_MetadataTemplate_EnumValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AspectType_MetadataTemplate_EnumValue>): AspectType_MetadataTemplate_EnumValue {
    const message = createBaseAspectType_MetadataTemplate_EnumValue();
    message.index = object.index ?? 0;
    message.name = object.name ?? "";
    message.deprecated = object.deprecated ?? "";
    return message;
  },
};

function createBaseAspectType_MetadataTemplate_Constraints(): AspectType_MetadataTemplate_Constraints {
  return { required: false };
}

export const AspectType_MetadataTemplate_Constraints: MessageFns<AspectType_MetadataTemplate_Constraints> = {
  encode(message: AspectType_MetadataTemplate_Constraints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.required !== false) {
      writer.uint32(8).bool(message.required);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AspectType_MetadataTemplate_Constraints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAspectType_MetadataTemplate_Constraints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.required = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AspectType_MetadataTemplate_Constraints {
    return { required: isSet(object.required) ? globalThis.Boolean(object.required) : false };
  },

  toJSON(message: AspectType_MetadataTemplate_Constraints): unknown {
    const obj: any = {};
    if (message.required !== false) {
      obj.required = message.required;
    }
    return obj;
  },

  create(base?: DeepPartial<AspectType_MetadataTemplate_Constraints>): AspectType_MetadataTemplate_Constraints {
    return AspectType_MetadataTemplate_Constraints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AspectType_MetadataTemplate_Constraints>): AspectType_MetadataTemplate_Constraints {
    const message = createBaseAspectType_MetadataTemplate_Constraints();
    message.required = object.required ?? false;
    return message;
  },
};

function createBaseAspectType_MetadataTemplate_Annotations(): AspectType_MetadataTemplate_Annotations {
  return { deprecated: "", displayName: "", description: "", displayOrder: 0, stringType: "", stringValues: [] };
}

export const AspectType_MetadataTemplate_Annotations: MessageFns<AspectType_MetadataTemplate_Annotations> = {
  encode(message: AspectType_MetadataTemplate_Annotations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deprecated !== "") {
      writer.uint32(10).string(message.deprecated);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.displayOrder !== 0) {
      writer.uint32(32).int32(message.displayOrder);
    }
    if (message.stringType !== "") {
      writer.uint32(50).string(message.stringType);
    }
    for (const v of message.stringValues) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AspectType_MetadataTemplate_Annotations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAspectType_MetadataTemplate_Annotations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.deprecated = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.displayOrder = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stringType = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.stringValues.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AspectType_MetadataTemplate_Annotations {
    return {
      deprecated: isSet(object.deprecated) ? globalThis.String(object.deprecated) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      displayOrder: isSet(object.displayOrder) ? globalThis.Number(object.displayOrder) : 0,
      stringType: isSet(object.stringType) ? globalThis.String(object.stringType) : "",
      stringValues: globalThis.Array.isArray(object?.stringValues)
        ? object.stringValues.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AspectType_MetadataTemplate_Annotations): unknown {
    const obj: any = {};
    if (message.deprecated !== "") {
      obj.deprecated = message.deprecated;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.displayOrder !== 0) {
      obj.displayOrder = Math.round(message.displayOrder);
    }
    if (message.stringType !== "") {
      obj.stringType = message.stringType;
    }
    if (message.stringValues?.length) {
      obj.stringValues = message.stringValues;
    }
    return obj;
  },

  create(base?: DeepPartial<AspectType_MetadataTemplate_Annotations>): AspectType_MetadataTemplate_Annotations {
    return AspectType_MetadataTemplate_Annotations.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AspectType_MetadataTemplate_Annotations>): AspectType_MetadataTemplate_Annotations {
    const message = createBaseAspectType_MetadataTemplate_Annotations();
    message.deprecated = object.deprecated ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.displayOrder = object.displayOrder ?? 0;
    message.stringType = object.stringType ?? "";
    message.stringValues = object.stringValues?.map((e) => e) || [];
    return message;
  },
};

function createBaseAspectType_LabelsEntry(): AspectType_LabelsEntry {
  return { key: "", value: "" };
}

export const AspectType_LabelsEntry: MessageFns<AspectType_LabelsEntry> = {
  encode(message: AspectType_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AspectType_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAspectType_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AspectType_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AspectType_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<AspectType_LabelsEntry>): AspectType_LabelsEntry {
    return AspectType_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AspectType_LabelsEntry>): AspectType_LabelsEntry {
    const message = createBaseAspectType_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEntryGroup(): EntryGroup {
  return {
    name: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    description: "",
    displayName: "",
    labels: {},
    etag: "",
    transferStatus: 0,
  };
}

export const EntryGroup: MessageFns<EntryGroup> = {
  encode(message: EntryGroup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.displayName !== "") {
      writer.uint32(50).string(message.displayName);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      EntryGroup_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(66).string(message.etag);
    }
    if (message.transferStatus !== 0) {
      writer.uint32(1616).int32(message.transferStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntryGroup {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntryGroup();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = EntryGroup_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 202:
          if (tag !== 1616) {
            break;
          }

          message.transferStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntryGroup {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      transferStatus: isSet(object.transferStatus) ? transferStatusFromJSON(object.transferStatus) : 0,
    };
  },

  toJSON(message: EntryGroup): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.transferStatus !== 0) {
      obj.transferStatus = transferStatusToJSON(message.transferStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<EntryGroup>): EntryGroup {
    return EntryGroup.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntryGroup>): EntryGroup {
    const message = createBaseEntryGroup();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.description = object.description ?? "";
    message.displayName = object.displayName ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.etag = object.etag ?? "";
    message.transferStatus = object.transferStatus ?? 0;
    return message;
  },
};

function createBaseEntryGroup_LabelsEntry(): EntryGroup_LabelsEntry {
  return { key: "", value: "" };
}

export const EntryGroup_LabelsEntry: MessageFns<EntryGroup_LabelsEntry> = {
  encode(message: EntryGroup_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntryGroup_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntryGroup_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntryGroup_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EntryGroup_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EntryGroup_LabelsEntry>): EntryGroup_LabelsEntry {
    return EntryGroup_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntryGroup_LabelsEntry>): EntryGroup_LabelsEntry {
    const message = createBaseEntryGroup_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEntryType(): EntryType {
  return {
    name: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    description: "",
    displayName: "",
    labels: {},
    etag: "",
    typeAliases: [],
    platform: "",
    system: "",
    requiredAspects: [],
    authorization: undefined,
  };
}

export const EntryType: MessageFns<EntryType> = {
  encode(message: EntryType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.displayName !== "") {
      writer.uint32(50).string(message.displayName);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      EntryType_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.etag !== "") {
      writer.uint32(66).string(message.etag);
    }
    for (const v of message.typeAliases) {
      writer.uint32(74).string(v!);
    }
    if (message.platform !== "") {
      writer.uint32(82).string(message.platform);
    }
    if (message.system !== "") {
      writer.uint32(90).string(message.system);
    }
    for (const v of message.requiredAspects) {
      EntryType_AspectInfo.encode(v!, writer.uint32(402).fork()).join();
    }
    if (message.authorization !== undefined) {
      EntryType_Authorization.encode(message.authorization, writer.uint32(410).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntryType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntryType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = EntryType_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.etag = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.typeAliases.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.platform = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.system = reader.string();
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.requiredAspects.push(EntryType_AspectInfo.decode(reader, reader.uint32()));
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.authorization = EntryType_Authorization.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntryType {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
      typeAliases: globalThis.Array.isArray(object?.typeAliases)
        ? object.typeAliases.map((e: any) => globalThis.String(e))
        : [],
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
      system: isSet(object.system) ? globalThis.String(object.system) : "",
      requiredAspects: globalThis.Array.isArray(object?.requiredAspects)
        ? object.requiredAspects.map((e: any) => EntryType_AspectInfo.fromJSON(e))
        : [],
      authorization: isSet(object.authorization) ? EntryType_Authorization.fromJSON(object.authorization) : undefined,
    };
  },

  toJSON(message: EntryType): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    if (message.typeAliases?.length) {
      obj.typeAliases = message.typeAliases;
    }
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    if (message.system !== "") {
      obj.system = message.system;
    }
    if (message.requiredAspects?.length) {
      obj.requiredAspects = message.requiredAspects.map((e) => EntryType_AspectInfo.toJSON(e));
    }
    if (message.authorization !== undefined) {
      obj.authorization = EntryType_Authorization.toJSON(message.authorization);
    }
    return obj;
  },

  create(base?: DeepPartial<EntryType>): EntryType {
    return EntryType.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntryType>): EntryType {
    const message = createBaseEntryType();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.description = object.description ?? "";
    message.displayName = object.displayName ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.etag = object.etag ?? "";
    message.typeAliases = object.typeAliases?.map((e) => e) || [];
    message.platform = object.platform ?? "";
    message.system = object.system ?? "";
    message.requiredAspects = object.requiredAspects?.map((e) => EntryType_AspectInfo.fromPartial(e)) || [];
    message.authorization = (object.authorization !== undefined && object.authorization !== null)
      ? EntryType_Authorization.fromPartial(object.authorization)
      : undefined;
    return message;
  },
};

function createBaseEntryType_AspectInfo(): EntryType_AspectInfo {
  return { type: "" };
}

export const EntryType_AspectInfo: MessageFns<EntryType_AspectInfo> = {
  encode(message: EntryType_AspectInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntryType_AspectInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntryType_AspectInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntryType_AspectInfo {
    return { type: isSet(object.type) ? globalThis.String(object.type) : "" };
  },

  toJSON(message: EntryType_AspectInfo): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<EntryType_AspectInfo>): EntryType_AspectInfo {
    return EntryType_AspectInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntryType_AspectInfo>): EntryType_AspectInfo {
    const message = createBaseEntryType_AspectInfo();
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseEntryType_Authorization(): EntryType_Authorization {
  return { alternateUsePermission: "" };
}

export const EntryType_Authorization: MessageFns<EntryType_Authorization> = {
  encode(message: EntryType_Authorization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alternateUsePermission !== "") {
      writer.uint32(10).string(message.alternateUsePermission);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntryType_Authorization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntryType_Authorization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.alternateUsePermission = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntryType_Authorization {
    return {
      alternateUsePermission: isSet(object.alternateUsePermission)
        ? globalThis.String(object.alternateUsePermission)
        : "",
    };
  },

  toJSON(message: EntryType_Authorization): unknown {
    const obj: any = {};
    if (message.alternateUsePermission !== "") {
      obj.alternateUsePermission = message.alternateUsePermission;
    }
    return obj;
  },

  create(base?: DeepPartial<EntryType_Authorization>): EntryType_Authorization {
    return EntryType_Authorization.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntryType_Authorization>): EntryType_Authorization {
    const message = createBaseEntryType_Authorization();
    message.alternateUsePermission = object.alternateUsePermission ?? "";
    return message;
  },
};

function createBaseEntryType_LabelsEntry(): EntryType_LabelsEntry {
  return { key: "", value: "" };
}

export const EntryType_LabelsEntry: MessageFns<EntryType_LabelsEntry> = {
  encode(message: EntryType_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntryType_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntryType_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntryType_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EntryType_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EntryType_LabelsEntry>): EntryType_LabelsEntry {
    return EntryType_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntryType_LabelsEntry>): EntryType_LabelsEntry {
    const message = createBaseEntryType_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseAspect(): Aspect {
  return {
    aspectType: "",
    path: "",
    createTime: undefined,
    updateTime: undefined,
    data: undefined,
    aspectSource: undefined,
  };
}

export const Aspect: MessageFns<Aspect> = {
  encode(message: Aspect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aspectType !== "") {
      writer.uint32(10).string(message.aspectType);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(34).fork()).join();
    }
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(66).fork()).join();
    }
    if (message.aspectSource !== undefined) {
      AspectSource.encode(message.aspectSource, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Aspect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAspect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.aspectType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.aspectSource = AspectSource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Aspect {
    return {
      aspectType: isSet(object.aspectType) ? globalThis.String(object.aspectType) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      data: isObject(object.data) ? object.data : undefined,
      aspectSource: isSet(object.aspectSource) ? AspectSource.fromJSON(object.aspectSource) : undefined,
    };
  },

  toJSON(message: Aspect): unknown {
    const obj: any = {};
    if (message.aspectType !== "") {
      obj.aspectType = message.aspectType;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    if (message.aspectSource !== undefined) {
      obj.aspectSource = AspectSource.toJSON(message.aspectSource);
    }
    return obj;
  },

  create(base?: DeepPartial<Aspect>): Aspect {
    return Aspect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Aspect>): Aspect {
    const message = createBaseAspect();
    message.aspectType = object.aspectType ?? "";
    message.path = object.path ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.data = object.data ?? undefined;
    message.aspectSource = (object.aspectSource !== undefined && object.aspectSource !== null)
      ? AspectSource.fromPartial(object.aspectSource)
      : undefined;
    return message;
  },
};

function createBaseAspectSource(): AspectSource {
  return { createTime: undefined, updateTime: undefined };
}

export const AspectSource: MessageFns<AspectSource> = {
  encode(message: AspectSource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(82).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AspectSource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAspectSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AspectSource {
    return {
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
    };
  },

  toJSON(message: AspectSource): unknown {
    const obj: any = {};
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<AspectSource>): AspectSource {
    return AspectSource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AspectSource>): AspectSource {
    const message = createBaseAspectSource();
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    return message;
  },
};

function createBaseEntry(): Entry {
  return {
    name: "",
    entryType: "",
    createTime: undefined,
    updateTime: undefined,
    aspects: {},
    parentEntry: "",
    fullyQualifiedName: "",
    entrySource: undefined,
  };
}

export const Entry: MessageFns<Entry> = {
  encode(message: Entry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.entryType !== "") {
      writer.uint32(34).string(message.entryType);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(42).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(50).fork()).join();
    }
    Object.entries(message.aspects).forEach(([key, value]) => {
      Entry_AspectsEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    if (message.parentEntry !== "") {
      writer.uint32(82).string(message.parentEntry);
    }
    if (message.fullyQualifiedName !== "") {
      writer.uint32(98).string(message.fullyQualifiedName);
    }
    if (message.entrySource !== undefined) {
      EntrySource.encode(message.entrySource, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.entryType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = Entry_AspectsEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.aspects[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.parentEntry = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.fullyQualifiedName = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.entrySource = EntrySource.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entry {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      entryType: isSet(object.entryType) ? globalThis.String(object.entryType) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      aspects: isObject(object.aspects)
        ? Object.entries(object.aspects).reduce<{ [key: string]: Aspect }>((acc, [key, value]) => {
          acc[key] = Aspect.fromJSON(value);
          return acc;
        }, {})
        : {},
      parentEntry: isSet(object.parentEntry) ? globalThis.String(object.parentEntry) : "",
      fullyQualifiedName: isSet(object.fullyQualifiedName) ? globalThis.String(object.fullyQualifiedName) : "",
      entrySource: isSet(object.entrySource) ? EntrySource.fromJSON(object.entrySource) : undefined,
    };
  },

  toJSON(message: Entry): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.entryType !== "") {
      obj.entryType = message.entryType;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.aspects) {
      const entries = Object.entries(message.aspects);
      if (entries.length > 0) {
        obj.aspects = {};
        entries.forEach(([k, v]) => {
          obj.aspects[k] = Aspect.toJSON(v);
        });
      }
    }
    if (message.parentEntry !== "") {
      obj.parentEntry = message.parentEntry;
    }
    if (message.fullyQualifiedName !== "") {
      obj.fullyQualifiedName = message.fullyQualifiedName;
    }
    if (message.entrySource !== undefined) {
      obj.entrySource = EntrySource.toJSON(message.entrySource);
    }
    return obj;
  },

  create(base?: DeepPartial<Entry>): Entry {
    return Entry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entry>): Entry {
    const message = createBaseEntry();
    message.name = object.name ?? "";
    message.entryType = object.entryType ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.aspects = Object.entries(object.aspects ?? {}).reduce<{ [key: string]: Aspect }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Aspect.fromPartial(value);
      }
      return acc;
    }, {});
    message.parentEntry = object.parentEntry ?? "";
    message.fullyQualifiedName = object.fullyQualifiedName ?? "";
    message.entrySource = (object.entrySource !== undefined && object.entrySource !== null)
      ? EntrySource.fromPartial(object.entrySource)
      : undefined;
    return message;
  },
};

function createBaseEntry_AspectsEntry(): Entry_AspectsEntry {
  return { key: "", value: undefined };
}

export const Entry_AspectsEntry: MessageFns<Entry_AspectsEntry> = {
  encode(message: Entry_AspectsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Aspect.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Entry_AspectsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntry_AspectsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Aspect.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Entry_AspectsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Aspect.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Entry_AspectsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Aspect.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Entry_AspectsEntry>): Entry_AspectsEntry {
    return Entry_AspectsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Entry_AspectsEntry>): Entry_AspectsEntry {
    const message = createBaseEntry_AspectsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Aspect.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseEntrySource(): EntrySource {
  return {
    resource: "",
    system: "",
    platform: "",
    displayName: "",
    description: "",
    labels: {},
    ancestors: [],
    createTime: undefined,
    updateTime: undefined,
    location: "",
  };
}

export const EntrySource: MessageFns<EntrySource> = {
  encode(message: EntrySource, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.system !== "") {
      writer.uint32(18).string(message.system);
    }
    if (message.platform !== "") {
      writer.uint32(26).string(message.platform);
    }
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      EntrySource_LabelsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    for (const v of message.ancestors) {
      EntrySource_Ancestor.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(82).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(90).fork()).join();
    }
    if (message.location !== "") {
      writer.uint32(98).string(message.location);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntrySource {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntrySource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.system = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.platform = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = EntrySource_LabelsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.labels[entry7.key] = entry7.value;
          }
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.ancestors.push(EntrySource_Ancestor.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.location = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntrySource {
    return {
      resource: isSet(object.resource) ? globalThis.String(object.resource) : "",
      system: isSet(object.system) ? globalThis.String(object.system) : "",
      platform: isSet(object.platform) ? globalThis.String(object.platform) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      ancestors: globalThis.Array.isArray(object?.ancestors)
        ? object.ancestors.map((e: any) => EntrySource_Ancestor.fromJSON(e))
        : [],
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      location: isSet(object.location) ? globalThis.String(object.location) : "",
    };
  },

  toJSON(message: EntrySource): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.system !== "") {
      obj.system = message.system;
    }
    if (message.platform !== "") {
      obj.platform = message.platform;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.ancestors?.length) {
      obj.ancestors = message.ancestors.map((e) => EntrySource_Ancestor.toJSON(e));
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    return obj;
  },

  create(base?: DeepPartial<EntrySource>): EntrySource {
    return EntrySource.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntrySource>): EntrySource {
    const message = createBaseEntrySource();
    message.resource = object.resource ?? "";
    message.system = object.system ?? "";
    message.platform = object.platform ?? "";
    message.displayName = object.displayName ?? "";
    message.description = object.description ?? "";
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.ancestors = object.ancestors?.map((e) => EntrySource_Ancestor.fromPartial(e)) || [];
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.location = object.location ?? "";
    return message;
  },
};

function createBaseEntrySource_Ancestor(): EntrySource_Ancestor {
  return { name: "", type: "" };
}

export const EntrySource_Ancestor: MessageFns<EntrySource_Ancestor> = {
  encode(message: EntrySource_Ancestor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntrySource_Ancestor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntrySource_Ancestor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntrySource_Ancestor {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: EntrySource_Ancestor): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create(base?: DeepPartial<EntrySource_Ancestor>): EntrySource_Ancestor {
    return EntrySource_Ancestor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntrySource_Ancestor>): EntrySource_Ancestor {
    const message = createBaseEntrySource_Ancestor();
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseEntrySource_LabelsEntry(): EntrySource_LabelsEntry {
  return { key: "", value: "" };
}

export const EntrySource_LabelsEntry: MessageFns<EntrySource_LabelsEntry> = {
  encode(message: EntrySource_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EntrySource_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEntrySource_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EntrySource_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EntrySource_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EntrySource_LabelsEntry>): EntrySource_LabelsEntry {
    return EntrySource_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EntrySource_LabelsEntry>): EntrySource_LabelsEntry {
    const message = createBaseEntrySource_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateEntryGroupRequest(): CreateEntryGroupRequest {
  return { parent: "", entryGroupId: "", entryGroup: undefined, validateOnly: false };
}

export const CreateEntryGroupRequest: MessageFns<CreateEntryGroupRequest> = {
  encode(message: CreateEntryGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.entryGroupId !== "") {
      writer.uint32(18).string(message.entryGroupId);
    }
    if (message.entryGroup !== undefined) {
      EntryGroup.encode(message.entryGroup, writer.uint32(26).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEntryGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEntryGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entryGroupId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entryGroup = EntryGroup.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEntryGroupRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      entryGroupId: isSet(object.entryGroupId) ? globalThis.String(object.entryGroupId) : "",
      entryGroup: isSet(object.entryGroup) ? EntryGroup.fromJSON(object.entryGroup) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateEntryGroupRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.entryGroupId !== "") {
      obj.entryGroupId = message.entryGroupId;
    }
    if (message.entryGroup !== undefined) {
      obj.entryGroup = EntryGroup.toJSON(message.entryGroup);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateEntryGroupRequest>): CreateEntryGroupRequest {
    return CreateEntryGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateEntryGroupRequest>): CreateEntryGroupRequest {
    const message = createBaseCreateEntryGroupRequest();
    message.parent = object.parent ?? "";
    message.entryGroupId = object.entryGroupId ?? "";
    message.entryGroup = (object.entryGroup !== undefined && object.entryGroup !== null)
      ? EntryGroup.fromPartial(object.entryGroup)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateEntryGroupRequest(): UpdateEntryGroupRequest {
  return { entryGroup: undefined, updateMask: undefined, validateOnly: false };
}

export const UpdateEntryGroupRequest: MessageFns<UpdateEntryGroupRequest> = {
  encode(message: UpdateEntryGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entryGroup !== undefined) {
      EntryGroup.encode(message.entryGroup, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEntryGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEntryGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryGroup = EntryGroup.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEntryGroupRequest {
    return {
      entryGroup: isSet(object.entryGroup) ? EntryGroup.fromJSON(object.entryGroup) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateEntryGroupRequest): unknown {
    const obj: any = {};
    if (message.entryGroup !== undefined) {
      obj.entryGroup = EntryGroup.toJSON(message.entryGroup);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateEntryGroupRequest>): UpdateEntryGroupRequest {
    return UpdateEntryGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateEntryGroupRequest>): UpdateEntryGroupRequest {
    const message = createBaseUpdateEntryGroupRequest();
    message.entryGroup = (object.entryGroup !== undefined && object.entryGroup !== null)
      ? EntryGroup.fromPartial(object.entryGroup)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteEntryGroupRequest(): DeleteEntryGroupRequest {
  return { name: "", etag: "" };
}

export const DeleteEntryGroupRequest: MessageFns<DeleteEntryGroupRequest> = {
  encode(message: DeleteEntryGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEntryGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEntryGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteEntryGroupRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteEntryGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteEntryGroupRequest>): DeleteEntryGroupRequest {
    return DeleteEntryGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteEntryGroupRequest>): DeleteEntryGroupRequest {
    const message = createBaseDeleteEntryGroupRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseListEntryGroupsRequest(): ListEntryGroupsRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListEntryGroupsRequest: MessageFns<ListEntryGroupsRequest> = {
  encode(message: ListEntryGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntryGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntryGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntryGroupsRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListEntryGroupsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntryGroupsRequest>): ListEntryGroupsRequest {
    return ListEntryGroupsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntryGroupsRequest>): ListEntryGroupsRequest {
    const message = createBaseListEntryGroupsRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListEntryGroupsResponse(): ListEntryGroupsResponse {
  return { entryGroups: [], nextPageToken: "", unreachableLocations: [] };
}

export const ListEntryGroupsResponse: MessageFns<ListEntryGroupsResponse> = {
  encode(message: ListEntryGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entryGroups) {
      EntryGroup.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachableLocations) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntryGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntryGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryGroups.push(EntryGroup.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachableLocations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntryGroupsResponse {
    return {
      entryGroups: globalThis.Array.isArray(object?.entryGroups)
        ? object.entryGroups.map((e: any) => EntryGroup.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachableLocations: globalThis.Array.isArray(object?.unreachableLocations)
        ? object.unreachableLocations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListEntryGroupsResponse): unknown {
    const obj: any = {};
    if (message.entryGroups?.length) {
      obj.entryGroups = message.entryGroups.map((e) => EntryGroup.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachableLocations?.length) {
      obj.unreachableLocations = message.unreachableLocations;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntryGroupsResponse>): ListEntryGroupsResponse {
    return ListEntryGroupsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntryGroupsResponse>): ListEntryGroupsResponse {
    const message = createBaseListEntryGroupsResponse();
    message.entryGroups = object.entryGroups?.map((e) => EntryGroup.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachableLocations = object.unreachableLocations?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetEntryGroupRequest(): GetEntryGroupRequest {
  return { name: "" };
}

export const GetEntryGroupRequest: MessageFns<GetEntryGroupRequest> = {
  encode(message: GetEntryGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEntryGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEntryGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEntryGroupRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetEntryGroupRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEntryGroupRequest>): GetEntryGroupRequest {
    return GetEntryGroupRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEntryGroupRequest>): GetEntryGroupRequest {
    const message = createBaseGetEntryGroupRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateEntryTypeRequest(): CreateEntryTypeRequest {
  return { parent: "", entryTypeId: "", entryType: undefined, validateOnly: false };
}

export const CreateEntryTypeRequest: MessageFns<CreateEntryTypeRequest> = {
  encode(message: CreateEntryTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.entryTypeId !== "") {
      writer.uint32(18).string(message.entryTypeId);
    }
    if (message.entryType !== undefined) {
      EntryType.encode(message.entryType, writer.uint32(26).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEntryTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEntryTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entryTypeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entryType = EntryType.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEntryTypeRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      entryTypeId: isSet(object.entryTypeId) ? globalThis.String(object.entryTypeId) : "",
      entryType: isSet(object.entryType) ? EntryType.fromJSON(object.entryType) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateEntryTypeRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.entryTypeId !== "") {
      obj.entryTypeId = message.entryTypeId;
    }
    if (message.entryType !== undefined) {
      obj.entryType = EntryType.toJSON(message.entryType);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateEntryTypeRequest>): CreateEntryTypeRequest {
    return CreateEntryTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateEntryTypeRequest>): CreateEntryTypeRequest {
    const message = createBaseCreateEntryTypeRequest();
    message.parent = object.parent ?? "";
    message.entryTypeId = object.entryTypeId ?? "";
    message.entryType = (object.entryType !== undefined && object.entryType !== null)
      ? EntryType.fromPartial(object.entryType)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateEntryTypeRequest(): UpdateEntryTypeRequest {
  return { entryType: undefined, updateMask: undefined, validateOnly: false };
}

export const UpdateEntryTypeRequest: MessageFns<UpdateEntryTypeRequest> = {
  encode(message: UpdateEntryTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entryType !== undefined) {
      EntryType.encode(message.entryType, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEntryTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEntryTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryType = EntryType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEntryTypeRequest {
    return {
      entryType: isSet(object.entryType) ? EntryType.fromJSON(object.entryType) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateEntryTypeRequest): unknown {
    const obj: any = {};
    if (message.entryType !== undefined) {
      obj.entryType = EntryType.toJSON(message.entryType);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateEntryTypeRequest>): UpdateEntryTypeRequest {
    return UpdateEntryTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateEntryTypeRequest>): UpdateEntryTypeRequest {
    const message = createBaseUpdateEntryTypeRequest();
    message.entryType = (object.entryType !== undefined && object.entryType !== null)
      ? EntryType.fromPartial(object.entryType)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteEntryTypeRequest(): DeleteEntryTypeRequest {
  return { name: "", etag: "" };
}

export const DeleteEntryTypeRequest: MessageFns<DeleteEntryTypeRequest> = {
  encode(message: DeleteEntryTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEntryTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEntryTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteEntryTypeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteEntryTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteEntryTypeRequest>): DeleteEntryTypeRequest {
    return DeleteEntryTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteEntryTypeRequest>): DeleteEntryTypeRequest {
    const message = createBaseDeleteEntryTypeRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseListEntryTypesRequest(): ListEntryTypesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListEntryTypesRequest: MessageFns<ListEntryTypesRequest> = {
  encode(message: ListEntryTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntryTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntryTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntryTypesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListEntryTypesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntryTypesRequest>): ListEntryTypesRequest {
    return ListEntryTypesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntryTypesRequest>): ListEntryTypesRequest {
    const message = createBaseListEntryTypesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListEntryTypesResponse(): ListEntryTypesResponse {
  return { entryTypes: [], nextPageToken: "", unreachableLocations: [] };
}

export const ListEntryTypesResponse: MessageFns<ListEntryTypesResponse> = {
  encode(message: ListEntryTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entryTypes) {
      EntryType.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachableLocations) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntryTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntryTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entryTypes.push(EntryType.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachableLocations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntryTypesResponse {
    return {
      entryTypes: globalThis.Array.isArray(object?.entryTypes)
        ? object.entryTypes.map((e: any) => EntryType.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachableLocations: globalThis.Array.isArray(object?.unreachableLocations)
        ? object.unreachableLocations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListEntryTypesResponse): unknown {
    const obj: any = {};
    if (message.entryTypes?.length) {
      obj.entryTypes = message.entryTypes.map((e) => EntryType.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachableLocations?.length) {
      obj.unreachableLocations = message.unreachableLocations;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntryTypesResponse>): ListEntryTypesResponse {
    return ListEntryTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntryTypesResponse>): ListEntryTypesResponse {
    const message = createBaseListEntryTypesResponse();
    message.entryTypes = object.entryTypes?.map((e) => EntryType.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachableLocations = object.unreachableLocations?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetEntryTypeRequest(): GetEntryTypeRequest {
  return { name: "" };
}

export const GetEntryTypeRequest: MessageFns<GetEntryTypeRequest> = {
  encode(message: GetEntryTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEntryTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEntryTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEntryTypeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetEntryTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEntryTypeRequest>): GetEntryTypeRequest {
    return GetEntryTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEntryTypeRequest>): GetEntryTypeRequest {
    const message = createBaseGetEntryTypeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateAspectTypeRequest(): CreateAspectTypeRequest {
  return { parent: "", aspectTypeId: "", aspectType: undefined, validateOnly: false };
}

export const CreateAspectTypeRequest: MessageFns<CreateAspectTypeRequest> = {
  encode(message: CreateAspectTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.aspectTypeId !== "") {
      writer.uint32(18).string(message.aspectTypeId);
    }
    if (message.aspectType !== undefined) {
      AspectType.encode(message.aspectType, writer.uint32(26).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(32).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateAspectTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAspectTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.aspectTypeId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.aspectType = AspectType.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateAspectTypeRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      aspectTypeId: isSet(object.aspectTypeId) ? globalThis.String(object.aspectTypeId) : "",
      aspectType: isSet(object.aspectType) ? AspectType.fromJSON(object.aspectType) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: CreateAspectTypeRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.aspectTypeId !== "") {
      obj.aspectTypeId = message.aspectTypeId;
    }
    if (message.aspectType !== undefined) {
      obj.aspectType = AspectType.toJSON(message.aspectType);
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateAspectTypeRequest>): CreateAspectTypeRequest {
    return CreateAspectTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateAspectTypeRequest>): CreateAspectTypeRequest {
    const message = createBaseCreateAspectTypeRequest();
    message.parent = object.parent ?? "";
    message.aspectTypeId = object.aspectTypeId ?? "";
    message.aspectType = (object.aspectType !== undefined && object.aspectType !== null)
      ? AspectType.fromPartial(object.aspectType)
      : undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseUpdateAspectTypeRequest(): UpdateAspectTypeRequest {
  return { aspectType: undefined, updateMask: undefined, validateOnly: false };
}

export const UpdateAspectTypeRequest: MessageFns<UpdateAspectTypeRequest> = {
  encode(message: UpdateAspectTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aspectType !== undefined) {
      AspectType.encode(message.aspectType, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.validateOnly !== false) {
      writer.uint32(24).bool(message.validateOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateAspectTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAspectTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.aspectType = AspectType.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.validateOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateAspectTypeRequest {
    return {
      aspectType: isSet(object.aspectType) ? AspectType.fromJSON(object.aspectType) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      validateOnly: isSet(object.validateOnly) ? globalThis.Boolean(object.validateOnly) : false,
    };
  },

  toJSON(message: UpdateAspectTypeRequest): unknown {
    const obj: any = {};
    if (message.aspectType !== undefined) {
      obj.aspectType = AspectType.toJSON(message.aspectType);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.validateOnly !== false) {
      obj.validateOnly = message.validateOnly;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateAspectTypeRequest>): UpdateAspectTypeRequest {
    return UpdateAspectTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateAspectTypeRequest>): UpdateAspectTypeRequest {
    const message = createBaseUpdateAspectTypeRequest();
    message.aspectType = (object.aspectType !== undefined && object.aspectType !== null)
      ? AspectType.fromPartial(object.aspectType)
      : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.validateOnly = object.validateOnly ?? false;
    return message;
  },
};

function createBaseDeleteAspectTypeRequest(): DeleteAspectTypeRequest {
  return { name: "", etag: "" };
}

export const DeleteAspectTypeRequest: MessageFns<DeleteAspectTypeRequest> = {
  encode(message: DeleteAspectTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.etag !== "") {
      writer.uint32(18).string(message.etag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteAspectTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAspectTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.etag = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteAspectTypeRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      etag: isSet(object.etag) ? globalThis.String(object.etag) : "",
    };
  },

  toJSON(message: DeleteAspectTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.etag !== "") {
      obj.etag = message.etag;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteAspectTypeRequest>): DeleteAspectTypeRequest {
    return DeleteAspectTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteAspectTypeRequest>): DeleteAspectTypeRequest {
    const message = createBaseDeleteAspectTypeRequest();
    message.name = object.name ?? "";
    message.etag = object.etag ?? "";
    return message;
  },
};

function createBaseListAspectTypesRequest(): ListAspectTypesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "", orderBy: "" };
}

export const ListAspectTypesRequest: MessageFns<ListAspectTypesRequest> = {
  encode(message: ListAspectTypesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAspectTypesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAspectTypesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAspectTypesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
    };
  },

  toJSON(message: ListAspectTypesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAspectTypesRequest>): ListAspectTypesRequest {
    return ListAspectTypesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAspectTypesRequest>): ListAspectTypesRequest {
    const message = createBaseListAspectTypesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    message.orderBy = object.orderBy ?? "";
    return message;
  },
};

function createBaseListAspectTypesResponse(): ListAspectTypesResponse {
  return { aspectTypes: [], nextPageToken: "", unreachableLocations: [] };
}

export const ListAspectTypesResponse: MessageFns<ListAspectTypesResponse> = {
  encode(message: ListAspectTypesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.aspectTypes) {
      AspectType.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    for (const v of message.unreachableLocations) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListAspectTypesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAspectTypesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.aspectTypes.push(AspectType.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.unreachableLocations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListAspectTypesResponse {
    return {
      aspectTypes: globalThis.Array.isArray(object?.aspectTypes)
        ? object.aspectTypes.map((e: any) => AspectType.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachableLocations: globalThis.Array.isArray(object?.unreachableLocations)
        ? object.unreachableLocations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListAspectTypesResponse): unknown {
    const obj: any = {};
    if (message.aspectTypes?.length) {
      obj.aspectTypes = message.aspectTypes.map((e) => AspectType.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachableLocations?.length) {
      obj.unreachableLocations = message.unreachableLocations;
    }
    return obj;
  },

  create(base?: DeepPartial<ListAspectTypesResponse>): ListAspectTypesResponse {
    return ListAspectTypesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListAspectTypesResponse>): ListAspectTypesResponse {
    const message = createBaseListAspectTypesResponse();
    message.aspectTypes = object.aspectTypes?.map((e) => AspectType.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachableLocations = object.unreachableLocations?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetAspectTypeRequest(): GetAspectTypeRequest {
  return { name: "" };
}

export const GetAspectTypeRequest: MessageFns<GetAspectTypeRequest> = {
  encode(message: GetAspectTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAspectTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAspectTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetAspectTypeRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetAspectTypeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<GetAspectTypeRequest>): GetAspectTypeRequest {
    return GetAspectTypeRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAspectTypeRequest>): GetAspectTypeRequest {
    const message = createBaseGetAspectTypeRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseCreateEntryRequest(): CreateEntryRequest {
  return { parent: "", entryId: "", entry: undefined };
}

export const CreateEntryRequest: MessageFns<CreateEntryRequest> = {
  encode(message: CreateEntryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.entryId !== "") {
      writer.uint32(18).string(message.entryId);
    }
    if (message.entry !== undefined) {
      Entry.encode(message.entry, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.entryId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.entry = Entry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateEntryRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      entryId: isSet(object.entryId) ? globalThis.String(object.entryId) : "",
      entry: isSet(object.entry) ? Entry.fromJSON(object.entry) : undefined,
    };
  },

  toJSON(message: CreateEntryRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.entryId !== "") {
      obj.entryId = message.entryId;
    }
    if (message.entry !== undefined) {
      obj.entry = Entry.toJSON(message.entry);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateEntryRequest>): CreateEntryRequest {
    return CreateEntryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateEntryRequest>): CreateEntryRequest {
    const message = createBaseCreateEntryRequest();
    message.parent = object.parent ?? "";
    message.entryId = object.entryId ?? "";
    message.entry = (object.entry !== undefined && object.entry !== null) ? Entry.fromPartial(object.entry) : undefined;
    return message;
  },
};

function createBaseUpdateEntryRequest(): UpdateEntryRequest {
  return { entry: undefined, updateMask: undefined, allowMissing: false, deleteMissingAspects: false, aspectKeys: [] };
}

export const UpdateEntryRequest: MessageFns<UpdateEntryRequest> = {
  encode(message: UpdateEntryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entry !== undefined) {
      Entry.encode(message.entry, writer.uint32(10).fork()).join();
    }
    if (message.updateMask !== undefined) {
      FieldMask.encode(FieldMask.wrap(message.updateMask), writer.uint32(18).fork()).join();
    }
    if (message.allowMissing !== false) {
      writer.uint32(24).bool(message.allowMissing);
    }
    if (message.deleteMissingAspects !== false) {
      writer.uint32(32).bool(message.deleteMissingAspects);
    }
    for (const v of message.aspectKeys) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entry = Entry.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.updateMask = FieldMask.unwrap(FieldMask.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.allowMissing = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.deleteMissingAspects = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.aspectKeys.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateEntryRequest {
    return {
      entry: isSet(object.entry) ? Entry.fromJSON(object.entry) : undefined,
      updateMask: isSet(object.updateMask) ? FieldMask.unwrap(FieldMask.fromJSON(object.updateMask)) : undefined,
      allowMissing: isSet(object.allowMissing) ? globalThis.Boolean(object.allowMissing) : false,
      deleteMissingAspects: isSet(object.deleteMissingAspects)
        ? globalThis.Boolean(object.deleteMissingAspects)
        : false,
      aspectKeys: globalThis.Array.isArray(object?.aspectKeys)
        ? object.aspectKeys.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: UpdateEntryRequest): unknown {
    const obj: any = {};
    if (message.entry !== undefined) {
      obj.entry = Entry.toJSON(message.entry);
    }
    if (message.updateMask !== undefined) {
      obj.updateMask = FieldMask.toJSON(FieldMask.wrap(message.updateMask));
    }
    if (message.allowMissing !== false) {
      obj.allowMissing = message.allowMissing;
    }
    if (message.deleteMissingAspects !== false) {
      obj.deleteMissingAspects = message.deleteMissingAspects;
    }
    if (message.aspectKeys?.length) {
      obj.aspectKeys = message.aspectKeys;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateEntryRequest>): UpdateEntryRequest {
    return UpdateEntryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateEntryRequest>): UpdateEntryRequest {
    const message = createBaseUpdateEntryRequest();
    message.entry = (object.entry !== undefined && object.entry !== null) ? Entry.fromPartial(object.entry) : undefined;
    message.updateMask = object.updateMask ?? undefined;
    message.allowMissing = object.allowMissing ?? false;
    message.deleteMissingAspects = object.deleteMissingAspects ?? false;
    message.aspectKeys = object.aspectKeys?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeleteEntryRequest(): DeleteEntryRequest {
  return { name: "" };
}

export const DeleteEntryRequest: MessageFns<DeleteEntryRequest> = {
  encode(message: DeleteEntryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteEntryRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteEntryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteEntryRequest>): DeleteEntryRequest {
    return DeleteEntryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteEntryRequest>): DeleteEntryRequest {
    const message = createBaseDeleteEntryRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseListEntriesRequest(): ListEntriesRequest {
  return { parent: "", pageSize: 0, pageToken: "", filter: "" };
}

export const ListEntriesRequest: MessageFns<ListEntriesRequest> = {
  encode(message: ListEntriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    if (message.filter !== "") {
      writer.uint32(34).string(message.filter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.filter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntriesRequest {
    return {
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      filter: isSet(object.filter) ? globalThis.String(object.filter) : "",
    };
  },

  toJSON(message: ListEntriesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.filter !== "") {
      obj.filter = message.filter;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntriesRequest>): ListEntriesRequest {
    return ListEntriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntriesRequest>): ListEntriesRequest {
    const message = createBaseListEntriesRequest();
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.filter = object.filter ?? "";
    return message;
  },
};

function createBaseListEntriesResponse(): ListEntriesResponse {
  return { entries: [], nextPageToken: "" };
}

export const ListEntriesResponse: MessageFns<ListEntriesResponse> = {
  encode(message: ListEntriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      Entry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListEntriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListEntriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.entries.push(Entry.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListEntriesResponse {
    return {
      entries: globalThis.Array.isArray(object?.entries) ? object.entries.map((e: any) => Entry.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListEntriesResponse): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => Entry.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create(base?: DeepPartial<ListEntriesResponse>): ListEntriesResponse {
    return ListEntriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListEntriesResponse>): ListEntriesResponse {
    const message = createBaseListEntriesResponse();
    message.entries = object.entries?.map((e) => Entry.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseGetEntryRequest(): GetEntryRequest {
  return { name: "", view: 0, aspectTypes: [], paths: [] };
}

export const GetEntryRequest: MessageFns<GetEntryRequest> = {
  encode(message: GetEntryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    for (const v of message.aspectTypes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.paths) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.aspectTypes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.paths.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEntryRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? entryViewFromJSON(object.view) : 0,
      aspectTypes: globalThis.Array.isArray(object?.aspectTypes)
        ? object.aspectTypes.map((e: any) => globalThis.String(e))
        : [],
      paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: GetEntryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = entryViewToJSON(message.view);
    }
    if (message.aspectTypes?.length) {
      obj.aspectTypes = message.aspectTypes;
    }
    if (message.paths?.length) {
      obj.paths = message.paths;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEntryRequest>): GetEntryRequest {
    return GetEntryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEntryRequest>): GetEntryRequest {
    const message = createBaseGetEntryRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    message.aspectTypes = object.aspectTypes?.map((e) => e) || [];
    message.paths = object.paths?.map((e) => e) || [];
    return message;
  },
};

function createBaseLookupEntryRequest(): LookupEntryRequest {
  return { name: "", view: 0, aspectTypes: [], paths: [], entry: "" };
}

export const LookupEntryRequest: MessageFns<LookupEntryRequest> = {
  encode(message: LookupEntryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.view !== 0) {
      writer.uint32(16).int32(message.view);
    }
    for (const v of message.aspectTypes) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.paths) {
      writer.uint32(34).string(v!);
    }
    if (message.entry !== "") {
      writer.uint32(42).string(message.entry);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LookupEntryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLookupEntryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.view = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.aspectTypes.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.paths.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.entry = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LookupEntryRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      view: isSet(object.view) ? entryViewFromJSON(object.view) : 0,
      aspectTypes: globalThis.Array.isArray(object?.aspectTypes)
        ? object.aspectTypes.map((e: any) => globalThis.String(e))
        : [],
      paths: globalThis.Array.isArray(object?.paths) ? object.paths.map((e: any) => globalThis.String(e)) : [],
      entry: isSet(object.entry) ? globalThis.String(object.entry) : "",
    };
  },

  toJSON(message: LookupEntryRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.view !== 0) {
      obj.view = entryViewToJSON(message.view);
    }
    if (message.aspectTypes?.length) {
      obj.aspectTypes = message.aspectTypes;
    }
    if (message.paths?.length) {
      obj.paths = message.paths;
    }
    if (message.entry !== "") {
      obj.entry = message.entry;
    }
    return obj;
  },

  create(base?: DeepPartial<LookupEntryRequest>): LookupEntryRequest {
    return LookupEntryRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LookupEntryRequest>): LookupEntryRequest {
    const message = createBaseLookupEntryRequest();
    message.name = object.name ?? "";
    message.view = object.view ?? 0;
    message.aspectTypes = object.aspectTypes?.map((e) => e) || [];
    message.paths = object.paths?.map((e) => e) || [];
    message.entry = object.entry ?? "";
    return message;
  },
};

function createBaseSearchEntriesRequest(): SearchEntriesRequest {
  return { name: "", query: "", pageSize: 0, pageToken: "", orderBy: "", scope: "" };
}

export const SearchEntriesRequest: MessageFns<SearchEntriesRequest> = {
  encode(message: SearchEntriesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.query !== "") {
      writer.uint32(18).string(message.query);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(34).string(message.pageToken);
    }
    if (message.orderBy !== "") {
      writer.uint32(42).string(message.orderBy);
    }
    if (message.scope !== "") {
      writer.uint32(58).string(message.scope);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchEntriesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchEntriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderBy = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.scope = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchEntriesRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : 0,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : "",
      orderBy: isSet(object.orderBy) ? globalThis.String(object.orderBy) : "",
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
    };
  },

  toJSON(message: SearchEntriesRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.pageSize !== 0) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== "") {
      obj.pageToken = message.pageToken;
    }
    if (message.orderBy !== "") {
      obj.orderBy = message.orderBy;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchEntriesRequest>): SearchEntriesRequest {
    return SearchEntriesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchEntriesRequest>): SearchEntriesRequest {
    const message = createBaseSearchEntriesRequest();
    message.name = object.name ?? "";
    message.query = object.query ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    message.orderBy = object.orderBy ?? "";
    message.scope = object.scope ?? "";
    return message;
  },
};

function createBaseSearchEntriesResult(): SearchEntriesResult {
  return { linkedResource: "", dataplexEntry: undefined, snippets: undefined };
}

export const SearchEntriesResult: MessageFns<SearchEntriesResult> = {
  encode(message: SearchEntriesResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.linkedResource !== "") {
      writer.uint32(66).string(message.linkedResource);
    }
    if (message.dataplexEntry !== undefined) {
      Entry.encode(message.dataplexEntry, writer.uint32(74).fork()).join();
    }
    if (message.snippets !== undefined) {
      SearchEntriesResult_Snippets.encode(message.snippets, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchEntriesResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchEntriesResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 8:
          if (tag !== 66) {
            break;
          }

          message.linkedResource = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.dataplexEntry = Entry.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.snippets = SearchEntriesResult_Snippets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchEntriesResult {
    return {
      linkedResource: isSet(object.linkedResource) ? globalThis.String(object.linkedResource) : "",
      dataplexEntry: isSet(object.dataplexEntry) ? Entry.fromJSON(object.dataplexEntry) : undefined,
      snippets: isSet(object.snippets) ? SearchEntriesResult_Snippets.fromJSON(object.snippets) : undefined,
    };
  },

  toJSON(message: SearchEntriesResult): unknown {
    const obj: any = {};
    if (message.linkedResource !== "") {
      obj.linkedResource = message.linkedResource;
    }
    if (message.dataplexEntry !== undefined) {
      obj.dataplexEntry = Entry.toJSON(message.dataplexEntry);
    }
    if (message.snippets !== undefined) {
      obj.snippets = SearchEntriesResult_Snippets.toJSON(message.snippets);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchEntriesResult>): SearchEntriesResult {
    return SearchEntriesResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchEntriesResult>): SearchEntriesResult {
    const message = createBaseSearchEntriesResult();
    message.linkedResource = object.linkedResource ?? "";
    message.dataplexEntry = (object.dataplexEntry !== undefined && object.dataplexEntry !== null)
      ? Entry.fromPartial(object.dataplexEntry)
      : undefined;
    message.snippets = (object.snippets !== undefined && object.snippets !== null)
      ? SearchEntriesResult_Snippets.fromPartial(object.snippets)
      : undefined;
    return message;
  },
};

function createBaseSearchEntriesResult_Snippets(): SearchEntriesResult_Snippets {
  return { dataplexEntry: undefined };
}

export const SearchEntriesResult_Snippets: MessageFns<SearchEntriesResult_Snippets> = {
  encode(message: SearchEntriesResult_Snippets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataplexEntry !== undefined) {
      Entry.encode(message.dataplexEntry, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchEntriesResult_Snippets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchEntriesResult_Snippets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.dataplexEntry = Entry.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchEntriesResult_Snippets {
    return { dataplexEntry: isSet(object.dataplexEntry) ? Entry.fromJSON(object.dataplexEntry) : undefined };
  },

  toJSON(message: SearchEntriesResult_Snippets): unknown {
    const obj: any = {};
    if (message.dataplexEntry !== undefined) {
      obj.dataplexEntry = Entry.toJSON(message.dataplexEntry);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchEntriesResult_Snippets>): SearchEntriesResult_Snippets {
    return SearchEntriesResult_Snippets.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchEntriesResult_Snippets>): SearchEntriesResult_Snippets {
    const message = createBaseSearchEntriesResult_Snippets();
    message.dataplexEntry = (object.dataplexEntry !== undefined && object.dataplexEntry !== null)
      ? Entry.fromPartial(object.dataplexEntry)
      : undefined;
    return message;
  },
};

function createBaseSearchEntriesResponse(): SearchEntriesResponse {
  return { results: [], totalSize: 0, nextPageToken: "", unreachable: [] };
}

export const SearchEntriesResponse: MessageFns<SearchEntriesResponse> = {
  encode(message: SearchEntriesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      SearchEntriesResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalSize !== 0) {
      writer.uint32(16).int32(message.totalSize);
    }
    if (message.nextPageToken !== "") {
      writer.uint32(26).string(message.nextPageToken);
    }
    for (const v of message.unreachable) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchEntriesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchEntriesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.results.push(SearchEntriesResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalSize = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.unreachable.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchEntriesResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SearchEntriesResult.fromJSON(e))
        : [],
      totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0,
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
      unreachable: globalThis.Array.isArray(object?.unreachable)
        ? object.unreachable.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SearchEntriesResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => SearchEntriesResult.toJSON(e));
    }
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    if (message.unreachable?.length) {
      obj.unreachable = message.unreachable;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchEntriesResponse>): SearchEntriesResponse {
    return SearchEntriesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchEntriesResponse>): SearchEntriesResponse {
    const message = createBaseSearchEntriesResponse();
    message.results = object.results?.map((e) => SearchEntriesResult.fromPartial(e)) || [];
    message.totalSize = object.totalSize ?? 0;
    message.nextPageToken = object.nextPageToken ?? "";
    message.unreachable = object.unreachable?.map((e) => e) || [];
    return message;
  },
};

/**
 * The primary resources offered by this service are EntryGroups, EntryTypes,
 * AspectTypes, Entry and Aspect which collectively allow a data administrator
 * to organize, manage, secure and catalog data across their organization
 * located across cloud projects in a variety of storage systems including Cloud
 * Storage and BigQuery.
 */
export type CatalogServiceDefinition = typeof CatalogServiceDefinition;
export const CatalogServiceDefinition = {
  name: "CatalogService",
  fullName: "google.cloud.dataplex.v1.CatalogService",
  methods: {
    /** Creates an EntryType */
    createEntryType: {
      name: "CreateEntryType",
      requestType: CreateEntryTypeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              9,
              69,
              110,
              116,
              114,
              121,
              84,
              121,
              112,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              31,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              101,
              110,
              116,
              114,
              121,
              95,
              116,
              121,
              112,
              101,
              44,
              101,
              110,
              116,
              114,
              121,
              95,
              116,
              121,
              112,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              60,
              58,
              10,
              101,
              110,
              116,
              114,
              121,
              95,
              116,
              121,
              112,
              101,
              34,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              114,
              121,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a EntryType resource. */
    updateEntryType: {
      name: "UpdateEntryType",
      requestType: UpdateEntryTypeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              30,
              10,
              9,
              69,
              110,
              116,
              114,
              121,
              84,
              121,
              112,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              22,
              101,
              110,
              116,
              114,
              121,
              95,
              116,
              121,
              112,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              71,
              58,
              10,
              101,
              110,
              116,
              114,
              121,
              95,
              116,
              121,
              112,
              101,
              50,
              57,
              47,
              118,
              49,
              47,
              123,
              101,
              110,
              116,
              114,
              121,
              95,
              116,
              121,
              112,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              121,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a EntryType resource. */
    deleteEntryType: {
      name: "DeleteEntryType",
      requestType: DeleteEntryTypeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              48,
              42,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              121,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists EntryType resources in a project and location. */
    listEntryTypes: {
      name: "ListEntryTypes",
      requestType: ListEntryTypesRequest,
      requestStream: false,
      responseType: ListEntryTypesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              114,
              121,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves a EntryType resource. */
    getEntryType: {
      name: "GetEntryType",
      requestType: GetEntryTypeRequest,
      requestStream: false,
      responseType: EntryType,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              48,
              18,
              46,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              121,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates an AspectType */
    createAspectType: {
      name: "CreateAspectType",
      requestType: CreateAspectTypeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              31,
              10,
              10,
              65,
              115,
              112,
              101,
              99,
              116,
              84,
              121,
              112,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              33,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              97,
              115,
              112,
              101,
              99,
              116,
              95,
              116,
              121,
              112,
              101,
              44,
              97,
              115,
              112,
              101,
              99,
              116,
              95,
              116,
              121,
              112,
              101,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              62,
              58,
              11,
              97,
              115,
              112,
              101,
              99,
              116,
              95,
              116,
              121,
              112,
              101,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              112,
              101,
              99,
              116,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a AspectType resource. */
    updateAspectType: {
      name: "UpdateAspectType",
      requestType: UpdateAspectTypeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              31,
              10,
              10,
              65,
              115,
              112,
              101,
              99,
              116,
              84,
              121,
              112,
              101,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              97,
              115,
              112,
              101,
              99,
              116,
              95,
              116,
              121,
              112,
              101,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              74,
              58,
              11,
              97,
              115,
              112,
              101,
              99,
              116,
              95,
              116,
              121,
              112,
              101,
              50,
              59,
              47,
              118,
              49,
              47,
              123,
              97,
              115,
              112,
              101,
              99,
              116,
              95,
              116,
              121,
              112,
              101,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              112,
              101,
              99,
              116,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a AspectType resource. */
    deleteAspectType: {
      name: "DeleteAspectType",
      requestType: DeleteAspectTypeRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              42,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              112,
              101,
              99,
              116,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists AspectType resources in a project and location. */
    listAspectTypes: {
      name: "ListAspectTypes",
      requestType: ListAspectTypesRequest,
      requestStream: false,
      responseType: ListAspectTypesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              97,
              115,
              112,
              101,
              99,
              116,
              84,
              121,
              112,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves a AspectType resource. */
    getAspectType: {
      name: "GetAspectType",
      requestType: GetAspectTypeRequest,
      requestStream: false,
      responseType: AspectType,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              97,
              115,
              112,
              101,
              99,
              116,
              84,
              121,
              112,
              101,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates an EntryGroup */
    createEntryGroup: {
      name: "CreateEntryGroup",
      requestType: CreateEntryGroupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              31,
              10,
              10,
              69,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              33,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              101,
              110,
              116,
              114,
              121,
              95,
              103,
              114,
              111,
              117,
              112,
              44,
              101,
              110,
              116,
              114,
              121,
              95,
              103,
              114,
              111,
              117,
              112,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              62,
              58,
              11,
              101,
              110,
              116,
              114,
              121,
              95,
              103,
              114,
              111,
              117,
              112,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates a EntryGroup resource. */
    updateEntryGroup: {
      name: "UpdateEntryGroup",
      requestType: UpdateEntryGroupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              31,
              10,
              10,
              69,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [
            Buffer.from([
              23,
              101,
              110,
              116,
              114,
              121,
              95,
              103,
              114,
              111,
              117,
              112,
              44,
              117,
              112,
              100,
              97,
              116,
              101,
              95,
              109,
              97,
              115,
              107,
            ]),
          ],
          578365826: [
            Buffer.from([
              74,
              58,
              11,
              101,
              110,
              116,
              114,
              121,
              95,
              103,
              114,
              111,
              117,
              112,
              50,
              59,
              47,
              118,
              49,
              47,
              123,
              101,
              110,
              116,
              114,
              121,
              95,
              103,
              114,
              111,
              117,
              112,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes a EntryGroup resource. */
    deleteEntryGroup: {
      name: "DeleteEntryGroup",
      requestType: DeleteEntryGroupRequest,
      requestStream: false,
      responseType: Operation,
      responseStream: false,
      options: {
        _unknownFields: {
          8394: [
            Buffer.from([
              42,
              10,
              21,
              103,
              111,
              111,
              103,
              108,
              101,
              46,
              112,
              114,
              111,
              116,
              111,
              98,
              117,
              102,
              46,
              69,
              109,
              112,
              116,
              121,
              18,
              17,
              79,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              77,
              101,
              116,
              97,
              100,
              97,
              116,
              97,
            ]),
          ],
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              42,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists EntryGroup resources in a project and location. */
    listEntryGroups: {
      name: "ListEntryGroups",
      requestType: ListEntryGroupsRequest,
      requestStream: false,
      responseType: ListEntryGroupsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              115,
            ]),
          ],
        },
      },
    },
    /** Retrieves a EntryGroup resource. */
    getEntryGroup: {
      name: "GetEntryGroup",
      requestType: GetEntryGroupRequest,
      requestStream: false,
      responseType: EntryGroup,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              49,
              18,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Creates an Entry. */
    createEntry: {
      name: "CreateEntry",
      requestType: CreateEntryRequest,
      requestStream: false,
      responseType: Entry,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [
            Buffer.from([
              21,
              112,
              97,
              114,
              101,
              110,
              116,
              44,
              101,
              110,
              116,
              114,
              121,
              44,
              101,
              110,
              116,
              114,
              121,
              95,
              105,
              100,
            ]),
          ],
          578365826: [
            Buffer.from([
              66,
              58,
              5,
              101,
              110,
              116,
              114,
              121,
              34,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Updates an Entry. */
    updateEntry: {
      name: "UpdateEntry",
      requestType: UpdateEntryRequest,
      requestStream: false,
      responseType: Entry,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([17, 101, 110, 116, 114, 121, 44, 117, 112, 100, 97, 116, 101, 95, 109, 97, 115, 107])],
          578365826: [
            Buffer.from([
              73,
              58,
              5,
              101,
              110,
              116,
              114,
              121,
              50,
              64,
              47,
              118,
              49,
              47,
              123,
              101,
              110,
              116,
              114,
              121,
              46,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              105,
              101,
              115,
              47,
              42,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Deletes an Entry. */
    deleteEntry: {
      name: "DeleteEntry",
      requestType: DeleteEntryRequest,
      requestStream: false,
      responseType: Entry,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              42,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              105,
              101,
              115,
              47,
              42,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Lists entries within an entry group. */
    listEntries: {
      name: "ListEntries",
      requestType: ListEntriesRequest,
      requestStream: false,
      responseType: ListEntriesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([6, 112, 97, 114, 101, 110, 116])],
          578365826: [
            Buffer.from([
              59,
              18,
              57,
              47,
              118,
              49,
              47,
              123,
              112,
              97,
              114,
              101,
              110,
              116,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              125,
              47,
              101,
              110,
              116,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
    /** Gets a single entry. */
    getEntry: {
      name: "GetEntry",
      requestType: GetEntryRequest,
      requestStream: false,
      responseType: Entry,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([4, 110, 97, 109, 101])],
          578365826: [
            Buffer.from([
              60,
              18,
              58,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              121,
              71,
              114,
              111,
              117,
              112,
              115,
              47,
              42,
              47,
              101,
              110,
              116,
              114,
              105,
              101,
              115,
              47,
              42,
              42,
              125,
            ]),
          ],
        },
      },
    },
    /** Looks up a single entry. */
    lookupEntry: {
      name: "LookupEntry",
      requestType: LookupEntryRequest,
      requestStream: false,
      responseType: Entry,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            Buffer.from([
              47,
              18,
              45,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              108,
              111,
              111,
              107,
              117,
              112,
              69,
              110,
              116,
              114,
              121,
            ]),
          ],
        },
      },
    },
    /** Searches for entries matching given query and scope. */
    searchEntries: {
      name: "SearchEntries",
      requestType: SearchEntriesRequest,
      requestStream: false,
      responseType: SearchEntriesResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          8410: [Buffer.from([10, 110, 97, 109, 101, 44, 113, 117, 101, 114, 121])],
          578365826: [
            Buffer.from([
              49,
              34,
              47,
              47,
              118,
              49,
              47,
              123,
              110,
              97,
              109,
              101,
              61,
              112,
              114,
              111,
              106,
              101,
              99,
              116,
              115,
              47,
              42,
              47,
              108,
              111,
              99,
              97,
              116,
              105,
              111,
              110,
              115,
              47,
              42,
              125,
              58,
              115,
              101,
              97,
              114,
              99,
              104,
              69,
              110,
              116,
              114,
              105,
              101,
              115,
            ]),
          ],
        },
      },
    },
  },
} as const;

export interface CatalogServiceImplementation<CallContextExt = {}> {
  /** Creates an EntryType */
  createEntryType(
    request: CreateEntryTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates a EntryType resource. */
  updateEntryType(
    request: UpdateEntryTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a EntryType resource. */
  deleteEntryType(
    request: DeleteEntryTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists EntryType resources in a project and location. */
  listEntryTypes(
    request: ListEntryTypesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEntryTypesResponse>>;
  /** Retrieves a EntryType resource. */
  getEntryType(request: GetEntryTypeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<EntryType>>;
  /** Creates an AspectType */
  createAspectType(
    request: CreateAspectTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates a AspectType resource. */
  updateAspectType(
    request: UpdateAspectTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a AspectType resource. */
  deleteAspectType(
    request: DeleteAspectTypeRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists AspectType resources in a project and location. */
  listAspectTypes(
    request: ListAspectTypesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListAspectTypesResponse>>;
  /** Retrieves a AspectType resource. */
  getAspectType(request: GetAspectTypeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<AspectType>>;
  /** Creates an EntryGroup */
  createEntryGroup(
    request: CreateEntryGroupRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Updates a EntryGroup resource. */
  updateEntryGroup(
    request: UpdateEntryGroupRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Deletes a EntryGroup resource. */
  deleteEntryGroup(
    request: DeleteEntryGroupRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Operation>>;
  /** Lists EntryGroup resources in a project and location. */
  listEntryGroups(
    request: ListEntryGroupsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEntryGroupsResponse>>;
  /** Retrieves a EntryGroup resource. */
  getEntryGroup(request: GetEntryGroupRequest, context: CallContext & CallContextExt): Promise<DeepPartial<EntryGroup>>;
  /** Creates an Entry. */
  createEntry(request: CreateEntryRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Entry>>;
  /** Updates an Entry. */
  updateEntry(request: UpdateEntryRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Entry>>;
  /** Deletes an Entry. */
  deleteEntry(request: DeleteEntryRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Entry>>;
  /** Lists entries within an entry group. */
  listEntries(
    request: ListEntriesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListEntriesResponse>>;
  /** Gets a single entry. */
  getEntry(request: GetEntryRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Entry>>;
  /** Looks up a single entry. */
  lookupEntry(request: LookupEntryRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Entry>>;
  /** Searches for entries matching given query and scope. */
  searchEntries(
    request: SearchEntriesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SearchEntriesResponse>>;
}

export interface CatalogServiceClient<CallOptionsExt = {}> {
  /** Creates an EntryType */
  createEntryType(
    request: DeepPartial<CreateEntryTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates a EntryType resource. */
  updateEntryType(
    request: DeepPartial<UpdateEntryTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a EntryType resource. */
  deleteEntryType(
    request: DeepPartial<DeleteEntryTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists EntryType resources in a project and location. */
  listEntryTypes(
    request: DeepPartial<ListEntryTypesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEntryTypesResponse>;
  /** Retrieves a EntryType resource. */
  getEntryType(request: DeepPartial<GetEntryTypeRequest>, options?: CallOptions & CallOptionsExt): Promise<EntryType>;
  /** Creates an AspectType */
  createAspectType(
    request: DeepPartial<CreateAspectTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates a AspectType resource. */
  updateAspectType(
    request: DeepPartial<UpdateAspectTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a AspectType resource. */
  deleteAspectType(
    request: DeepPartial<DeleteAspectTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists AspectType resources in a project and location. */
  listAspectTypes(
    request: DeepPartial<ListAspectTypesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListAspectTypesResponse>;
  /** Retrieves a AspectType resource. */
  getAspectType(
    request: DeepPartial<GetAspectTypeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<AspectType>;
  /** Creates an EntryGroup */
  createEntryGroup(
    request: DeepPartial<CreateEntryGroupRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Updates a EntryGroup resource. */
  updateEntryGroup(
    request: DeepPartial<UpdateEntryGroupRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Deletes a EntryGroup resource. */
  deleteEntryGroup(
    request: DeepPartial<DeleteEntryGroupRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Operation>;
  /** Lists EntryGroup resources in a project and location. */
  listEntryGroups(
    request: DeepPartial<ListEntryGroupsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEntryGroupsResponse>;
  /** Retrieves a EntryGroup resource. */
  getEntryGroup(
    request: DeepPartial<GetEntryGroupRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<EntryGroup>;
  /** Creates an Entry. */
  createEntry(request: DeepPartial<CreateEntryRequest>, options?: CallOptions & CallOptionsExt): Promise<Entry>;
  /** Updates an Entry. */
  updateEntry(request: DeepPartial<UpdateEntryRequest>, options?: CallOptions & CallOptionsExt): Promise<Entry>;
  /** Deletes an Entry. */
  deleteEntry(request: DeepPartial<DeleteEntryRequest>, options?: CallOptions & CallOptionsExt): Promise<Entry>;
  /** Lists entries within an entry group. */
  listEntries(
    request: DeepPartial<ListEntriesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListEntriesResponse>;
  /** Gets a single entry. */
  getEntry(request: DeepPartial<GetEntryRequest>, options?: CallOptions & CallOptionsExt): Promise<Entry>;
  /** Looks up a single entry. */
  lookupEntry(request: DeepPartial<LookupEntryRequest>, options?: CallOptions & CallOptionsExt): Promise<Entry>;
  /** Searches for entries matching given query and scope. */
  searchEntries(
    request: DeepPartial<SearchEntriesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SearchEntriesResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
