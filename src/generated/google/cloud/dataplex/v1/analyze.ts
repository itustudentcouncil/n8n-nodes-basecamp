// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               unknown
// source: google/cloud/dataplex/v1/analyze.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Duration } from "../../../protobuf/duration.js";
import { Timestamp } from "../../../protobuf/timestamp.js";
import { State, stateFromJSON, stateToJSON } from "./resources.js";

export const protobufPackage = "google.cloud.dataplex.v1";

/**
 * Environment represents a user-visible compute infrastructure for analytics
 * within a lake.
 */
export interface Environment {
  /**
   * Output only. The relative resource name of the environment, of the form:
   * projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}
   */
  name: string;
  /** Optional. User friendly display name. */
  displayName: string;
  /**
   * Output only. System generated globally unique ID for the environment. This
   * ID will be different if the environment is deleted and re-created with the
   * same name.
   */
  uid: string;
  /** Output only. Environment creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the environment was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. User defined labels for the environment. */
  labels: { [key: string]: string };
  /** Optional. Description of the environment. */
  description: string;
  /** Output only. Current state of the environment. */
  state: State;
  /** Required. Infrastructure specification for the Environment. */
  infrastructureSpec:
    | Environment_InfrastructureSpec
    | undefined;
  /** Optional. Configuration for sessions created for this environment. */
  sessionSpec:
    | Environment_SessionSpec
    | undefined;
  /** Output only. Status of sessions created for this environment. */
  sessionStatus:
    | Environment_SessionStatus
    | undefined;
  /**
   * Output only. URI Endpoints to access sessions associated with the
   * Environment.
   */
  endpoints: Environment_Endpoints | undefined;
}

/** Configuration for the underlying infrastructure used to run workloads. */
export interface Environment_InfrastructureSpec {
  /** Optional. Compute resources needed for analyze interactive workloads. */
  compute?:
    | Environment_InfrastructureSpec_ComputeResources
    | undefined;
  /**
   * Required. Software Runtime Configuration for analyze interactive
   * workloads.
   */
  osImage?: Environment_InfrastructureSpec_OsImageRuntime | undefined;
}

/** Compute resources associated with the analyze interactive workloads. */
export interface Environment_InfrastructureSpec_ComputeResources {
  /** Optional. Size in GB of the disk. Default is 100 GB. */
  diskSizeGb: number;
  /**
   * Optional. Total number of nodes in the sessions created for this
   * environment.
   */
  nodeCount: number;
  /**
   * Optional. Max configurable nodes.
   * If max_node_count > node_count, then auto-scaling is enabled.
   */
  maxNodeCount: number;
}

/** Software Runtime Configuration to run Analyze. */
export interface Environment_InfrastructureSpec_OsImageRuntime {
  /** Required. Dataplex Image version. */
  imageVersion: string;
  /**
   * Optional. List of Java jars to be included in the runtime environment.
   * Valid input includes Cloud Storage URIs to Jar binaries.
   * For example, gs://bucket-name/my/path/to/file.jar
   */
  javaLibraries: string[];
  /**
   * Optional. A list of python packages to be installed.
   * Valid formats include Cloud Storage URI to a PIP installable library.
   * For example, gs://bucket-name/my/path/to/lib.tar.gz
   */
  pythonPackages: string[];
  /**
   * Optional. Spark properties to provide configuration for use in sessions
   * created for this environment. The properties to set on daemon config
   * files. Property keys are specified in `prefix:property` format. The
   * prefix must be "spark".
   */
  properties: { [key: string]: string };
}

export interface Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry {
  key: string;
  value: string;
}

/** Configuration for sessions created for this environment. */
export interface Environment_SessionSpec {
  /**
   * Optional. The idle time configuration of the session. The session will be
   * auto-terminated at the end of this period.
   */
  maxIdleDuration:
    | Duration
    | undefined;
  /**
   * Optional. If True, this causes sessions to be pre-created and available
   * for faster startup to enable interactive exploration use-cases. This
   * defaults to False to avoid additional billed charges. These can only be
   * set to True for the environment with name set to "default", and with
   * default configuration.
   */
  enableFastStartup: boolean;
}

/** Status of sessions created for this environment. */
export interface Environment_SessionStatus {
  /**
   * Output only. Queries over sessions to mark whether the environment is
   * currently active or not
   */
  active: boolean;
}

/** URI Endpoints to access sessions associated with the Environment. */
export interface Environment_Endpoints {
  /** Output only. URI to serve notebook APIs */
  notebooks: string;
  /** Output only. URI to serve SQL APIs */
  sql: string;
}

export interface Environment_LabelsEntry {
  key: string;
  value: string;
}

/** Content represents a user-visible notebook or a sql script */
export interface Content {
  /**
   * Output only. The relative resource name of the content, of the form:
   * projects/{project_id}/locations/{location_id}/lakes/{lake_id}/content/{content_id}
   */
  name: string;
  /**
   * Output only. System generated globally unique ID for the content. This ID
   * will be different if the content is deleted and re-created with the same
   * name.
   */
  uid: string;
  /**
   * Required. The path for the Content file, represented as directory
   * structure. Unique within a lake. Limited to alphanumerics, hyphens,
   * underscores, dots and slashes.
   */
  path: string;
  /** Output only. Content creation time. */
  createTime:
    | Date
    | undefined;
  /** Output only. The time when the content was last updated. */
  updateTime:
    | Date
    | undefined;
  /** Optional. User defined labels for the content. */
  labels: { [key: string]: string };
  /** Optional. Description of the content. */
  description: string;
  /** Required. Content data in string format. */
  dataText?:
    | string
    | undefined;
  /** Sql Script related configurations. */
  sqlScript?:
    | Content_SqlScript
    | undefined;
  /** Notebook related configurations. */
  notebook?: Content_Notebook | undefined;
}

/** Configuration for the Sql Script content. */
export interface Content_SqlScript {
  /** Required. Query Engine to be used for the Sql Query. */
  engine: Content_SqlScript_QueryEngine;
}

/** Query Engine Type of the SQL Script. */
export enum Content_SqlScript_QueryEngine {
  /** QUERY_ENGINE_UNSPECIFIED - Value was unspecified. */
  QUERY_ENGINE_UNSPECIFIED = 0,
  /** SPARK - Spark SQL Query. */
  SPARK = 2,
  UNRECOGNIZED = -1,
}

export function content_SqlScript_QueryEngineFromJSON(object: any): Content_SqlScript_QueryEngine {
  switch (object) {
    case 0:
    case "QUERY_ENGINE_UNSPECIFIED":
      return Content_SqlScript_QueryEngine.QUERY_ENGINE_UNSPECIFIED;
    case 2:
    case "SPARK":
      return Content_SqlScript_QueryEngine.SPARK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Content_SqlScript_QueryEngine.UNRECOGNIZED;
  }
}

export function content_SqlScript_QueryEngineToJSON(object: Content_SqlScript_QueryEngine): string {
  switch (object) {
    case Content_SqlScript_QueryEngine.QUERY_ENGINE_UNSPECIFIED:
      return "QUERY_ENGINE_UNSPECIFIED";
    case Content_SqlScript_QueryEngine.SPARK:
      return "SPARK";
    case Content_SqlScript_QueryEngine.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Configuration for Notebook content. */
export interface Content_Notebook {
  /** Required. Kernel Type of the notebook. */
  kernelType: Content_Notebook_KernelType;
}

/** Kernel Type of the Jupyter notebook. */
export enum Content_Notebook_KernelType {
  /** KERNEL_TYPE_UNSPECIFIED - Kernel Type unspecified. */
  KERNEL_TYPE_UNSPECIFIED = 0,
  /** PYTHON3 - Python 3 Kernel. */
  PYTHON3 = 1,
  UNRECOGNIZED = -1,
}

export function content_Notebook_KernelTypeFromJSON(object: any): Content_Notebook_KernelType {
  switch (object) {
    case 0:
    case "KERNEL_TYPE_UNSPECIFIED":
      return Content_Notebook_KernelType.KERNEL_TYPE_UNSPECIFIED;
    case 1:
    case "PYTHON3":
      return Content_Notebook_KernelType.PYTHON3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Content_Notebook_KernelType.UNRECOGNIZED;
  }
}

export function content_Notebook_KernelTypeToJSON(object: Content_Notebook_KernelType): string {
  switch (object) {
    case Content_Notebook_KernelType.KERNEL_TYPE_UNSPECIFIED:
      return "KERNEL_TYPE_UNSPECIFIED";
    case Content_Notebook_KernelType.PYTHON3:
      return "PYTHON3";
    case Content_Notebook_KernelType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Content_LabelsEntry {
  key: string;
  value: string;
}

/** Represents an active analyze session running for a user. */
export interface Session {
  /**
   * Output only. The relative resource name of the content, of the form:
   * projects/{project_id}/locations/{location_id}/lakes/{lake_id}/environment/{environment_id}/sessions/{session_id}
   */
  name: string;
  /** Output only. Email of user running the session. */
  userId: string;
  /** Output only. Session start time. */
  createTime:
    | Date
    | undefined;
  /** Output only. State of Session */
  state: State;
}

function createBaseEnvironment(): Environment {
  return {
    name: "",
    displayName: "",
    uid: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    state: 0,
    infrastructureSpec: undefined,
    sessionSpec: undefined,
    sessionStatus: undefined,
    endpoints: undefined,
  };
}

export const Environment: MessageFns<Environment> = {
  encode(message: Environment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.uid !== "") {
      writer.uint32(26).string(message.uid);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Environment_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(64).int32(message.state);
    }
    if (message.infrastructureSpec !== undefined) {
      Environment_InfrastructureSpec.encode(message.infrastructureSpec, writer.uint32(802).fork()).join();
    }
    if (message.sessionSpec !== undefined) {
      Environment_SessionSpec.encode(message.sessionSpec, writer.uint32(810).fork()).join();
    }
    if (message.sessionStatus !== undefined) {
      Environment_SessionStatus.encode(message.sessionStatus, writer.uint32(818).fork()).join();
    }
    if (message.endpoints !== undefined) {
      Environment_Endpoints.encode(message.endpoints, writer.uint32(1602).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = Environment_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.infrastructureSpec = Environment_InfrastructureSpec.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.sessionSpec = Environment_SessionSpec.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.sessionStatus = Environment_SessionStatus.decode(reader, reader.uint32());
          continue;
        case 200:
          if (tag !== 1602) {
            break;
          }

          message.endpoints = Environment_Endpoints.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? stateFromJSON(object.state) : 0,
      infrastructureSpec: isSet(object.infrastructureSpec)
        ? Environment_InfrastructureSpec.fromJSON(object.infrastructureSpec)
        : undefined,
      sessionSpec: isSet(object.sessionSpec) ? Environment_SessionSpec.fromJSON(object.sessionSpec) : undefined,
      sessionStatus: isSet(object.sessionStatus) ? Environment_SessionStatus.fromJSON(object.sessionStatus) : undefined,
      endpoints: isSet(object.endpoints) ? Environment_Endpoints.fromJSON(object.endpoints) : undefined,
    };
  },

  toJSON(message: Environment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = stateToJSON(message.state);
    }
    if (message.infrastructureSpec !== undefined) {
      obj.infrastructureSpec = Environment_InfrastructureSpec.toJSON(message.infrastructureSpec);
    }
    if (message.sessionSpec !== undefined) {
      obj.sessionSpec = Environment_SessionSpec.toJSON(message.sessionSpec);
    }
    if (message.sessionStatus !== undefined) {
      obj.sessionStatus = Environment_SessionStatus.toJSON(message.sessionStatus);
    }
    if (message.endpoints !== undefined) {
      obj.endpoints = Environment_Endpoints.toJSON(message.endpoints);
    }
    return obj;
  },

  create(base?: DeepPartial<Environment>): Environment {
    return Environment.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment>): Environment {
    const message = createBaseEnvironment();
    message.name = object.name ?? "";
    message.displayName = object.displayName ?? "";
    message.uid = object.uid ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.infrastructureSpec = (object.infrastructureSpec !== undefined && object.infrastructureSpec !== null)
      ? Environment_InfrastructureSpec.fromPartial(object.infrastructureSpec)
      : undefined;
    message.sessionSpec = (object.sessionSpec !== undefined && object.sessionSpec !== null)
      ? Environment_SessionSpec.fromPartial(object.sessionSpec)
      : undefined;
    message.sessionStatus = (object.sessionStatus !== undefined && object.sessionStatus !== null)
      ? Environment_SessionStatus.fromPartial(object.sessionStatus)
      : undefined;
    message.endpoints = (object.endpoints !== undefined && object.endpoints !== null)
      ? Environment_Endpoints.fromPartial(object.endpoints)
      : undefined;
    return message;
  },
};

function createBaseEnvironment_InfrastructureSpec(): Environment_InfrastructureSpec {
  return { compute: undefined, osImage: undefined };
}

export const Environment_InfrastructureSpec: MessageFns<Environment_InfrastructureSpec> = {
  encode(message: Environment_InfrastructureSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.compute !== undefined) {
      Environment_InfrastructureSpec_ComputeResources.encode(message.compute, writer.uint32(402).fork()).join();
    }
    if (message.osImage !== undefined) {
      Environment_InfrastructureSpec_OsImageRuntime.encode(message.osImage, writer.uint32(802).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment_InfrastructureSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment_InfrastructureSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 50:
          if (tag !== 402) {
            break;
          }

          message.compute = Environment_InfrastructureSpec_ComputeResources.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.osImage = Environment_InfrastructureSpec_OsImageRuntime.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment_InfrastructureSpec {
    return {
      compute: isSet(object.compute)
        ? Environment_InfrastructureSpec_ComputeResources.fromJSON(object.compute)
        : undefined,
      osImage: isSet(object.osImage)
        ? Environment_InfrastructureSpec_OsImageRuntime.fromJSON(object.osImage)
        : undefined,
    };
  },

  toJSON(message: Environment_InfrastructureSpec): unknown {
    const obj: any = {};
    if (message.compute !== undefined) {
      obj.compute = Environment_InfrastructureSpec_ComputeResources.toJSON(message.compute);
    }
    if (message.osImage !== undefined) {
      obj.osImage = Environment_InfrastructureSpec_OsImageRuntime.toJSON(message.osImage);
    }
    return obj;
  },

  create(base?: DeepPartial<Environment_InfrastructureSpec>): Environment_InfrastructureSpec {
    return Environment_InfrastructureSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment_InfrastructureSpec>): Environment_InfrastructureSpec {
    const message = createBaseEnvironment_InfrastructureSpec();
    message.compute = (object.compute !== undefined && object.compute !== null)
      ? Environment_InfrastructureSpec_ComputeResources.fromPartial(object.compute)
      : undefined;
    message.osImage = (object.osImage !== undefined && object.osImage !== null)
      ? Environment_InfrastructureSpec_OsImageRuntime.fromPartial(object.osImage)
      : undefined;
    return message;
  },
};

function createBaseEnvironment_InfrastructureSpec_ComputeResources(): Environment_InfrastructureSpec_ComputeResources {
  return { diskSizeGb: 0, nodeCount: 0, maxNodeCount: 0 };
}

export const Environment_InfrastructureSpec_ComputeResources: MessageFns<
  Environment_InfrastructureSpec_ComputeResources
> = {
  encode(
    message: Environment_InfrastructureSpec_ComputeResources,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.diskSizeGb !== 0) {
      writer.uint32(8).int32(message.diskSizeGb);
    }
    if (message.nodeCount !== 0) {
      writer.uint32(16).int32(message.nodeCount);
    }
    if (message.maxNodeCount !== 0) {
      writer.uint32(24).int32(message.maxNodeCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment_InfrastructureSpec_ComputeResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment_InfrastructureSpec_ComputeResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.diskSizeGb = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nodeCount = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxNodeCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment_InfrastructureSpec_ComputeResources {
    return {
      diskSizeGb: isSet(object.diskSizeGb) ? globalThis.Number(object.diskSizeGb) : 0,
      nodeCount: isSet(object.nodeCount) ? globalThis.Number(object.nodeCount) : 0,
      maxNodeCount: isSet(object.maxNodeCount) ? globalThis.Number(object.maxNodeCount) : 0,
    };
  },

  toJSON(message: Environment_InfrastructureSpec_ComputeResources): unknown {
    const obj: any = {};
    if (message.diskSizeGb !== 0) {
      obj.diskSizeGb = Math.round(message.diskSizeGb);
    }
    if (message.nodeCount !== 0) {
      obj.nodeCount = Math.round(message.nodeCount);
    }
    if (message.maxNodeCount !== 0) {
      obj.maxNodeCount = Math.round(message.maxNodeCount);
    }
    return obj;
  },

  create(
    base?: DeepPartial<Environment_InfrastructureSpec_ComputeResources>,
  ): Environment_InfrastructureSpec_ComputeResources {
    return Environment_InfrastructureSpec_ComputeResources.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Environment_InfrastructureSpec_ComputeResources>,
  ): Environment_InfrastructureSpec_ComputeResources {
    const message = createBaseEnvironment_InfrastructureSpec_ComputeResources();
    message.diskSizeGb = object.diskSizeGb ?? 0;
    message.nodeCount = object.nodeCount ?? 0;
    message.maxNodeCount = object.maxNodeCount ?? 0;
    return message;
  },
};

function createBaseEnvironment_InfrastructureSpec_OsImageRuntime(): Environment_InfrastructureSpec_OsImageRuntime {
  return { imageVersion: "", javaLibraries: [], pythonPackages: [], properties: {} };
}

export const Environment_InfrastructureSpec_OsImageRuntime: MessageFns<Environment_InfrastructureSpec_OsImageRuntime> =
  {
    encode(
      message: Environment_InfrastructureSpec_OsImageRuntime,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.imageVersion !== "") {
        writer.uint32(10).string(message.imageVersion);
      }
      for (const v of message.javaLibraries) {
        writer.uint32(18).string(v!);
      }
      for (const v of message.pythonPackages) {
        writer.uint32(26).string(v!);
      }
      Object.entries(message.properties).forEach(([key, value]) => {
        Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry.encode(
          { key: key as any, value },
          writer.uint32(34).fork(),
        ).join();
      });
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): Environment_InfrastructureSpec_OsImageRuntime {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEnvironment_InfrastructureSpec_OsImageRuntime();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1:
            if (tag !== 10) {
              break;
            }

            message.imageVersion = reader.string();
            continue;
          case 2:
            if (tag !== 18) {
              break;
            }

            message.javaLibraries.push(reader.string());
            continue;
          case 3:
            if (tag !== 26) {
              break;
            }

            message.pythonPackages.push(reader.string());
            continue;
          case 4:
            if (tag !== 34) {
              break;
            }

            const entry4 = Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry.decode(
              reader,
              reader.uint32(),
            );
            if (entry4.value !== undefined) {
              message.properties[entry4.key] = entry4.value;
            }
            continue;
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): Environment_InfrastructureSpec_OsImageRuntime {
      return {
        imageVersion: isSet(object.imageVersion) ? globalThis.String(object.imageVersion) : "",
        javaLibraries: globalThis.Array.isArray(object?.javaLibraries)
          ? object.javaLibraries.map((e: any) => globalThis.String(e))
          : [],
        pythonPackages: globalThis.Array.isArray(object?.pythonPackages)
          ? object.pythonPackages.map((e: any) => globalThis.String(e))
          : [],
        properties: isObject(object.properties)
          ? Object.entries(object.properties).reduce<{ [key: string]: string }>((acc, [key, value]) => {
            acc[key] = String(value);
            return acc;
          }, {})
          : {},
      };
    },

    toJSON(message: Environment_InfrastructureSpec_OsImageRuntime): unknown {
      const obj: any = {};
      if (message.imageVersion !== "") {
        obj.imageVersion = message.imageVersion;
      }
      if (message.javaLibraries?.length) {
        obj.javaLibraries = message.javaLibraries;
      }
      if (message.pythonPackages?.length) {
        obj.pythonPackages = message.pythonPackages;
      }
      if (message.properties) {
        const entries = Object.entries(message.properties);
        if (entries.length > 0) {
          obj.properties = {};
          entries.forEach(([k, v]) => {
            obj.properties[k] = v;
          });
        }
      }
      return obj;
    },

    create(
      base?: DeepPartial<Environment_InfrastructureSpec_OsImageRuntime>,
    ): Environment_InfrastructureSpec_OsImageRuntime {
      return Environment_InfrastructureSpec_OsImageRuntime.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<Environment_InfrastructureSpec_OsImageRuntime>,
    ): Environment_InfrastructureSpec_OsImageRuntime {
      const message = createBaseEnvironment_InfrastructureSpec_OsImageRuntime();
      message.imageVersion = object.imageVersion ?? "";
      message.javaLibraries = object.javaLibraries?.map((e) => e) || [];
      message.pythonPackages = object.pythonPackages?.map((e) => e) || [];
      message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: string }>(
        (acc, [key, value]) => {
          if (value !== undefined) {
            acc[key] = globalThis.String(value);
          }
          return acc;
        },
        {},
      );
      return message;
    },
  };

function createBaseEnvironment_InfrastructureSpec_OsImageRuntime_PropertiesEntry(): Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry {
  return { key: "", value: "" };
}

export const Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry: MessageFns<
  Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry
> = {
  encode(
    message: Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment_InfrastructureSpec_OsImageRuntime_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry>,
  ): Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry {
    return Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry>,
  ): Environment_InfrastructureSpec_OsImageRuntime_PropertiesEntry {
    const message = createBaseEnvironment_InfrastructureSpec_OsImageRuntime_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEnvironment_SessionSpec(): Environment_SessionSpec {
  return { maxIdleDuration: undefined, enableFastStartup: false };
}

export const Environment_SessionSpec: MessageFns<Environment_SessionSpec> = {
  encode(message: Environment_SessionSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxIdleDuration !== undefined) {
      Duration.encode(message.maxIdleDuration, writer.uint32(10).fork()).join();
    }
    if (message.enableFastStartup !== false) {
      writer.uint32(16).bool(message.enableFastStartup);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment_SessionSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment_SessionSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.maxIdleDuration = Duration.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.enableFastStartup = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment_SessionSpec {
    return {
      maxIdleDuration: isSet(object.maxIdleDuration) ? Duration.fromJSON(object.maxIdleDuration) : undefined,
      enableFastStartup: isSet(object.enableFastStartup) ? globalThis.Boolean(object.enableFastStartup) : false,
    };
  },

  toJSON(message: Environment_SessionSpec): unknown {
    const obj: any = {};
    if (message.maxIdleDuration !== undefined) {
      obj.maxIdleDuration = Duration.toJSON(message.maxIdleDuration);
    }
    if (message.enableFastStartup !== false) {
      obj.enableFastStartup = message.enableFastStartup;
    }
    return obj;
  },

  create(base?: DeepPartial<Environment_SessionSpec>): Environment_SessionSpec {
    return Environment_SessionSpec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment_SessionSpec>): Environment_SessionSpec {
    const message = createBaseEnvironment_SessionSpec();
    message.maxIdleDuration = (object.maxIdleDuration !== undefined && object.maxIdleDuration !== null)
      ? Duration.fromPartial(object.maxIdleDuration)
      : undefined;
    message.enableFastStartup = object.enableFastStartup ?? false;
    return message;
  },
};

function createBaseEnvironment_SessionStatus(): Environment_SessionStatus {
  return { active: false };
}

export const Environment_SessionStatus: MessageFns<Environment_SessionStatus> = {
  encode(message: Environment_SessionStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.active !== false) {
      writer.uint32(8).bool(message.active);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment_SessionStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment_SessionStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.active = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment_SessionStatus {
    return { active: isSet(object.active) ? globalThis.Boolean(object.active) : false };
  },

  toJSON(message: Environment_SessionStatus): unknown {
    const obj: any = {};
    if (message.active !== false) {
      obj.active = message.active;
    }
    return obj;
  },

  create(base?: DeepPartial<Environment_SessionStatus>): Environment_SessionStatus {
    return Environment_SessionStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment_SessionStatus>): Environment_SessionStatus {
    const message = createBaseEnvironment_SessionStatus();
    message.active = object.active ?? false;
    return message;
  },
};

function createBaseEnvironment_Endpoints(): Environment_Endpoints {
  return { notebooks: "", sql: "" };
}

export const Environment_Endpoints: MessageFns<Environment_Endpoints> = {
  encode(message: Environment_Endpoints, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notebooks !== "") {
      writer.uint32(10).string(message.notebooks);
    }
    if (message.sql !== "") {
      writer.uint32(18).string(message.sql);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment_Endpoints {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment_Endpoints();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.notebooks = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sql = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment_Endpoints {
    return {
      notebooks: isSet(object.notebooks) ? globalThis.String(object.notebooks) : "",
      sql: isSet(object.sql) ? globalThis.String(object.sql) : "",
    };
  },

  toJSON(message: Environment_Endpoints): unknown {
    const obj: any = {};
    if (message.notebooks !== "") {
      obj.notebooks = message.notebooks;
    }
    if (message.sql !== "") {
      obj.sql = message.sql;
    }
    return obj;
  },

  create(base?: DeepPartial<Environment_Endpoints>): Environment_Endpoints {
    return Environment_Endpoints.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment_Endpoints>): Environment_Endpoints {
    const message = createBaseEnvironment_Endpoints();
    message.notebooks = object.notebooks ?? "";
    message.sql = object.sql ?? "";
    return message;
  },
};

function createBaseEnvironment_LabelsEntry(): Environment_LabelsEntry {
  return { key: "", value: "" };
}

export const Environment_LabelsEntry: MessageFns<Environment_LabelsEntry> = {
  encode(message: Environment_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Environment_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironment_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Environment_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Environment_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Environment_LabelsEntry>): Environment_LabelsEntry {
    return Environment_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Environment_LabelsEntry>): Environment_LabelsEntry {
    const message = createBaseEnvironment_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseContent(): Content {
  return {
    name: "",
    uid: "",
    path: "",
    createTime: undefined,
    updateTime: undefined,
    labels: {},
    description: "",
    dataText: undefined,
    sqlScript: undefined,
    notebook: undefined,
  };
}

export const Content: MessageFns<Content> = {
  encode(message: Content, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(34).fork()).join();
    }
    if (message.updateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(42).fork()).join();
    }
    Object.entries(message.labels).forEach(([key, value]) => {
      Content_LabelsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    if (message.description !== "") {
      writer.uint32(58).string(message.description);
    }
    if (message.dataText !== undefined) {
      writer.uint32(74).string(message.dataText);
    }
    if (message.sqlScript !== undefined) {
      Content_SqlScript.encode(message.sqlScript, writer.uint32(802).fork()).join();
    }
    if (message.notebook !== undefined) {
      Content_Notebook.encode(message.notebook, writer.uint32(810).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Content {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.updateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = Content_LabelsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.labels[entry6.key] = entry6.value;
          }
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.dataText = reader.string();
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.sqlScript = Content_SqlScript.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.notebook = Content_Notebook.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Content {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      updateTime: isSet(object.updateTime) ? fromJsonTimestamp(object.updateTime) : undefined,
      labels: isObject(object.labels)
        ? Object.entries(object.labels).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      dataText: isSet(object.dataText) ? globalThis.String(object.dataText) : undefined,
      sqlScript: isSet(object.sqlScript) ? Content_SqlScript.fromJSON(object.sqlScript) : undefined,
      notebook: isSet(object.notebook) ? Content_Notebook.fromJSON(object.notebook) : undefined,
    };
  },

  toJSON(message: Content): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.updateTime !== undefined) {
      obj.updateTime = message.updateTime.toISOString();
    }
    if (message.labels) {
      const entries = Object.entries(message.labels);
      if (entries.length > 0) {
        obj.labels = {};
        entries.forEach(([k, v]) => {
          obj.labels[k] = v;
        });
      }
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.dataText !== undefined) {
      obj.dataText = message.dataText;
    }
    if (message.sqlScript !== undefined) {
      obj.sqlScript = Content_SqlScript.toJSON(message.sqlScript);
    }
    if (message.notebook !== undefined) {
      obj.notebook = Content_Notebook.toJSON(message.notebook);
    }
    return obj;
  },

  create(base?: DeepPartial<Content>): Content {
    return Content.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Content>): Content {
    const message = createBaseContent();
    message.name = object.name ?? "";
    message.uid = object.uid ?? "";
    message.path = object.path ?? "";
    message.createTime = object.createTime ?? undefined;
    message.updateTime = object.updateTime ?? undefined;
    message.labels = Object.entries(object.labels ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.description = object.description ?? "";
    message.dataText = object.dataText ?? undefined;
    message.sqlScript = (object.sqlScript !== undefined && object.sqlScript !== null)
      ? Content_SqlScript.fromPartial(object.sqlScript)
      : undefined;
    message.notebook = (object.notebook !== undefined && object.notebook !== null)
      ? Content_Notebook.fromPartial(object.notebook)
      : undefined;
    return message;
  },
};

function createBaseContent_SqlScript(): Content_SqlScript {
  return { engine: 0 };
}

export const Content_SqlScript: MessageFns<Content_SqlScript> = {
  encode(message: Content_SqlScript, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.engine !== 0) {
      writer.uint32(8).int32(message.engine);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Content_SqlScript {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContent_SqlScript();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.engine = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Content_SqlScript {
    return { engine: isSet(object.engine) ? content_SqlScript_QueryEngineFromJSON(object.engine) : 0 };
  },

  toJSON(message: Content_SqlScript): unknown {
    const obj: any = {};
    if (message.engine !== 0) {
      obj.engine = content_SqlScript_QueryEngineToJSON(message.engine);
    }
    return obj;
  },

  create(base?: DeepPartial<Content_SqlScript>): Content_SqlScript {
    return Content_SqlScript.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Content_SqlScript>): Content_SqlScript {
    const message = createBaseContent_SqlScript();
    message.engine = object.engine ?? 0;
    return message;
  },
};

function createBaseContent_Notebook(): Content_Notebook {
  return { kernelType: 0 };
}

export const Content_Notebook: MessageFns<Content_Notebook> = {
  encode(message: Content_Notebook, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.kernelType !== 0) {
      writer.uint32(8).int32(message.kernelType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Content_Notebook {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContent_Notebook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.kernelType = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Content_Notebook {
    return { kernelType: isSet(object.kernelType) ? content_Notebook_KernelTypeFromJSON(object.kernelType) : 0 };
  },

  toJSON(message: Content_Notebook): unknown {
    const obj: any = {};
    if (message.kernelType !== 0) {
      obj.kernelType = content_Notebook_KernelTypeToJSON(message.kernelType);
    }
    return obj;
  },

  create(base?: DeepPartial<Content_Notebook>): Content_Notebook {
    return Content_Notebook.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Content_Notebook>): Content_Notebook {
    const message = createBaseContent_Notebook();
    message.kernelType = object.kernelType ?? 0;
    return message;
  },
};

function createBaseContent_LabelsEntry(): Content_LabelsEntry {
  return { key: "", value: "" };
}

export const Content_LabelsEntry: MessageFns<Content_LabelsEntry> = {
  encode(message: Content_LabelsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Content_LabelsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContent_LabelsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Content_LabelsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Content_LabelsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Content_LabelsEntry>): Content_LabelsEntry {
    return Content_LabelsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Content_LabelsEntry>): Content_LabelsEntry {
    const message = createBaseContent_LabelsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSession(): Session {
  return { name: "", userId: "", createTime: undefined, state: 0 };
}

export const Session: MessageFns<Session> = {
  encode(message: Session, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.createTime !== undefined) {
      Timestamp.encode(toTimestamp(message.createTime), writer.uint32(26).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Session {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.createTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Session {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      createTime: isSet(object.createTime) ? fromJsonTimestamp(object.createTime) : undefined,
      state: isSet(object.state) ? stateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Session): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.createTime !== undefined) {
      obj.createTime = message.createTime.toISOString();
    }
    if (message.state !== 0) {
      obj.state = stateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<Session>): Session {
    return Session.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Session>): Session {
    const message = createBaseSession();
    message.name = object.name ?? "";
    message.userId = object.userId ?? "";
    message.createTime = object.createTime ?? undefined;
    message.state = object.state ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
